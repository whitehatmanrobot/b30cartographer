calAlloc(LMEM_FIXED, 32 * sizeof(TCHAR));
                sprintf(ErrorBuffer, "Unknown error code 0x%08x", theError);
            }
        }
    }
    return ErrorBuffer;
}   /*  end LastErrorString  */


void
FreeErrorString(
    void)
{
    if (NULL != ErrorBuffer)
        LocalFree(ErrorBuffer);
    ErrorBuffer = NULL;
}   /*  end FreeErrorString  */

int
poption(
    const char *opt,
    ...)

/*
 *
 *  Function description:
 *
 *      poption takes a list of keywords, supplied by parameters, and returns
 *      the number in the list that matches the input option in the first
 *      parameter.  If the input option doesn't match any in the list, then a
 *      zero is returned.  If the input option is an abbreviation of an option,
 *      then the match completes.  For example, an input option of "de" would
 *      match "debug" or "decode".  If both were present in the possible
 *      options list, then a match would be declared for the first possible
 *      option encountered.
 *
 *
 *  Arguments:
 *
 *      opt - The option to match against.
 *
 *      opt1, opt2, ... - Pointers to null terminated strings containing
 *          the possible options to look for.  The last option must be NULL,
 *          indicating the end of the list.
 *
 *
 *  Return value:
 *
 *      0 - No match found
 *      1-n - Match on option number i, 0 < i <= n, where n is the number
 *          of options given, excluding the terminating NULL.
 *
 *
 *  Side effects:
 *
 *      None.
 *
 */

{
    /*
     *  Local Variable Definitions:                                       %local-vars%
     *
        Variable                        Description
        --------                        --------------------------------------------*/
    va_list
        ap;                             /*  My parameter context.  */
    int
        len,                            /*  Length of the option string.  */
        ret                             /*  The return value.  */
            = 0,
        index                           /* loop index. */
            = 1;
    char
        *kw;                            /* Pointer to the next option  */


    /*
     *  Start of Code.
     */

    va_start(ap, opt);


    /*
     *  Step through each input parameter until we find an exact match.
     */

    len = strlen(opt);
    if (0 == len)
        return 0;                       /*  Empty strings don't match anything.  */
    kw = va_arg(ap, char*);
    while (NULL != kw)
    {
        if (0 == _strnicmp(kw, opt, len))
        {
            ret = index;
            break;
        }
        kw = va_arg(ap, char*);
        index += 1;
    }
    va_end(ap);
    return ret;
}   /*  end poption  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\tclcrypt\tclrdcmd.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    tclRdCmd

Abstract:

    This header file describes the Tcl Command Line parser object.

Author:

    Doug Barlow (dbarlow) 3/14/1998

Environment:

    Win32, C++ w/ exceptions, Tcl

--*/

#ifndef _TCLRDCMD_H_
#define _TCLRDCMD_H_
extern "C" {
#include <tcl.h>
}

#ifndef _LPCBYTE_DEFINED
#define _LPCBYTE_DEFINED
typedef const BYTE *LPCBYTE;
#endif
#ifndef _LPCVOID_DEFINED
#define _LPCVOID_DEFINED
typedef const VOID *LPCVOID;
#endif

#include <scardlib.h>

#define SZ(x) ((LPSTR)((LPCSTR)(x)))

typedef struct {
    LPCTSTR szValue;
    LONG lValue;
} ValueMap;


//
//==============================================================================
//
//  CRenderableData
//

class CRenderableData
{
public:
    typedef enum {
        Undefined,
        Text,
        Ansi,
        Unicode,
        Hexidecimal,
        File
    } DisplayType;

    //  Constructors & Destructor
    CRenderableData();
    ~CRenderableData();

    //  Properties
    //  Methods
    void LoadData(LPCTSTR szData, DisplayType dwType = Undefined);
    void LoadData(LPCBYTE pbData, DWORD cbLength)
        { m_bfData.Set(pbData, cbLength); };
    LPCTSTR RenderData(DisplayType dwType = Undefined);
    LPCBYTE Value(void) const
        { return m_bfData.Access(); };
    DWORD Length(void) const
        { return m_bfData.Length(); };
    void SetDisplayType(DisplayType dwType)
        { m_dwType = dwType; };

    //  Operators

protected:
    //  Properties
    DisplayType m_dwType;
    CBuffer m_bfData;
    CString m_szString;
    CString m_szFile;

    //  Methods

    // Friends
    friend class CTclCommand;
};


//
//==============================================================================
//
//  CArgArray
//

class CArgArray
{
public:

    //  Constructors & Destructor
    CArgArray(CTclCommand &tclCmd);
    virtual ~CArgArray();
    void LoadList(LPCSTR szList);
    DWORD Count(void) const
        { return m_dwElements; };
    void Fetch(DWORD dwIndex, CString &szValue) const
        { szValue = m_rgszElements[dwIndex]; };

    //  Properties
    //  Methods
    //  Operators

protected:
    //  Properties
    CTclCommand *m_pTclCmd;
    CDynamicArray<CHAR> m_rgszElements;
    LPSTR *m_pszMemory;
    DWORD m_dwElements;

    //  Methods
};


//
//==============================================================================
//
//  CTclCommand
//

class CTclCommand
{
public:
    //  Constructors & Destructor
    CTclCommand(void);
    CTclCommand(IN Tcl_Interp *interp, IN int argc, IN char *argv[]);
    ~CTclCommand();

    //  Properties
    //  Methods
    void Initialize(IN Tcl_Interp *interp, IN int argc, IN char *argv[]);
    void SetError(IN DWORD dwError);
    void SetError(IN LPCTSTR szMessage, IN DWORD dwError);
    void SetError(IN LPCTSTR szMsg1, ...);
    DWORD TclError(void);
    LONG Keyword(IN LPCTSTR szKey, ...);
    BOOL IsMoreArguments(DWORD dwCount = 1) const;
    void NoMoreArguments(void);
    void PeekArgument(CString &szToken);
    void NextArgument(void);
    void NextArgument(CString &szToken);
    DWORD BadSyntax(LPCTSTR szOffender = NULL);
    void GetArgument(DWORD dwArgId, CString &szToken);
    LONG Value(void);
    LONG Value(LONG lDefault);
    LONG MapValue(const ValueMap *rgvmMap, BOOL fValueOk = TRUE);
    LONG MapValue(const ValueMap *rgvmMap, CString &szValue, BOOL fValueOk = TRUE);
    DWORD MapFlags(const ValueMap *rgvmMap, BOOL fValueOk = TRUE);
    void OutputStyle(CRenderableData &outData);
    void InputStyle(CRenderableData &inData);
    void IOStyle(CRenderableData &inData, CRenderableData &outData);
    void Render(CRenderableData &outData);
    void ReadData(CRenderableData &inData);

    //  Operators
    operator Tcl_Interp*()
        { return m_pInterp; };

protected:
    //  Properties
    BOOL m_fErrorDeclared;
    Tcl_Interp *m_pInterp;
    DWORD m_dwArgCount;
    DWORD m_dwArgIndex;
    char **m_rgszArgs;

    //  Methods
    void Constructor(void);
};

#endif // _TCLRDCMD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\idl\makefile.inc ===
#
# This is the MIDL compile phase of the build process.
#
# The following is where you put the name of your .idl file without
# the .idl extension:
#

!INCLUDE $(NTMAKEENV)\makefile.plt

IDL_NAME = timeif
IMPORT   = imports

CLIENT_H = timeif_c.h
SERVER_H = timeif_s.h

CLIENT_ACF = timeif.acf
SERVER_ACF = timeif.acf

!IFNDEF DISABLE_NET_UNICODE
UNICODE=1
NET_C_DEFINES=-DUNICODE
!ENDIF

INCS  = -I$(SDK_INC_PATH) -I$(CRT_INC_PATH) -I$(DS_INC_PATH)

CLIENT_TARGETS = $(O)\$(IDL_NAME)_c.c $(O)\$(CLIENT_H)
SERVER_TARGETS = $(O)\$(IDL_NAME)_s.c $(O)\$(SERVER_H)

TARGETS = $(CLIENT_TARGETS) $(SERVER_TARGETS)

CLIENT_FLAGS = -D CLIENT=1 -acf $(CLIENT_ACF) -header $(CLIENT_H) -server none -prefix server s_ -prefix client c_ -prefix switch sw_ -out .\$(O) 
SERVER_FLAGS = -D SERVER=1 -acf $(SERVER_ACF) -header $(SERVER_H) -client none -prefix server s_ -prefix client c_ -prefix switch sw_ -out .\$(O)

CPP = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) $(C_DEFINES) $(NET_C_DEFINES)

#
# MIDL COMPILE
#

$(CLIENT_TARGETS) : .\$(IDL_NAME).idl .\$(IMPORT).idl .\$(IMPORT).h .\$(CLIENT_ACF)
    midl $(MIDL_OPTIMIZATION) -ms_ext -c_ext $(CPP) $(CLIENT_FLAGS) $(INCS) .\$(IDL_NAME).idl


$(SERVER_TARGETS) : .\$(IDL_NAME).idl .\$(IMPORT).idl .\$(IMPORT).h .\$(SERVER_ACF)
    midl $(MIDL_OPTIMIZATION) -ms_ext -c_ext $(CPP) $(SERVER_FLAGS) $(INCS) .\$(IDL_NAME).idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\tclcrypt\try.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       try.c
//
//--------------------------------------------------------------------------

#ifndef __STDC__
#define __STDC__ 1
#endif
#include <string.h>                     /*  String support.  */
#include <tcl.h>
// #include "tcldllUtil.h"                 /*  Our utility service definitions.  */

int
TclExt_tryCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int argc,
    char *argv[])

/*
 *
 *  Function description:
 *
 *      This is the main entry point for the Tcl try command.
 *
 *
 *  Arguments:
 *
 *      ClientData - Ignored.
 *
 *      interp - The Tcl interpreter in force.
 *
 *      argc - The number of arguments received.
 *
 *      argv - The array of actual arguments.
 *
 *
 *  Return value:
 *
 *      TCL_OK - All went well
 *      TCL_ERROR - An error was encountered, details in the return string.
 *
 *
 *  Side effects:
 *
 *      None.
 *
 */

{
    /*
     *  Local Variable Definitions:                                       %local-vars%
     *
        Variable                        Description
        --------                        --------------------------------------------*/
    char
        *tryCmd,                        /*  The command to try.  */
        *catchCmd,                      /*  The command to do if tryCmd fails.  */
        *varName;                       /*  The name of the variable to receive the error string, if any.  */
    int
        status;                         /*  Status return code.  */


    /*
     *  try <commands> catch [<varName>] <errorCommands>
     */

#ifdef CMD_TRACE
    int j;
    for (j = 0; j < argc; j += 1)
        (void)printf("{%s} ", argv[j]);
    (void)printf("\n");
    breakpoint;
#endif

    if ((4 > argc) || (5 < argc))
    {
        Tcl_AppendResult(
            interp,
            "wrong number of args: should be \"",
            argv[0],
            " <command> catch [<varName>] <errorCommand>\"",
            NULL);
        status = TCL_ERROR;
        goto error_exit;
    }
    if (strcmp("catch", argv[2]))
    {
        Tcl_AppendResult(
            interp,
            "invalid args: should be \"",
            argv[0],
            " <command> catch [<varName>] <errorCommand>\"",
            NULL);
        status = TCL_ERROR;
        goto error_exit;
    }


    /*
     *  Execute the first set of commands.  If an error occurs, execute the
     *  second set of commands, with the local variable errorString set to the
     *  result of the first execution.
     */

    if (5 == argc)
    {
        varName = argv[3];
        catchCmd = argv[4];
    }
    else
    {
        varName = NULL;
        catchCmd = argv[3];
    }
    tryCmd = argv[1];

    if (TCL_ERROR == (status = Tcl_Eval(interp, tryCmd)))
    {
        if (NULL != varName)
            (void)Tcl_SetVar(interp, varName, interp->result, 0);
        status = Tcl_Eval(interp, catchCmd);
    }

error_exit:
    return status;
}   /*  end TclExt_tryCmd  */
/*  end try.c  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\idl\imports.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/


#include <windef.h>
#include <w32timep.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\tclcrypt\thread.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       thread.cpp
//
//--------------------------------------------------------------------------

#include <afx.h>
#include <string.h>                     /*  String support.  */
#ifndef __STDC__
#define __STDC__ 1
#endif
extern "C" {
    #include "scext.h"
    #include "tclhelp.h"
}
#include "tclRdCmd.h"

typedef struct {
    Tcl_Interp *interp;
    LPCSTR szCmd;
} ProcData;

static DWORD WINAPI
SubCommand(
    LPVOID lpParameter)
{
    ProcData *pprc = (ProcData *)lpParameter;
    return Tcl_Eval(pprc->interp, const_cast<LPSTR>(pprc->szCmd));
}


int
TclExt_threadCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int argc,
    char *argv[])

/*
 *
 *  Function description:
 *
 *      This is the main entry point for the Tcl thread command.
 *
 *
 *  Arguments:
 *
 *      ClientData - Ignored.
 *
 *      interp - The Tcl interpreter in force.
 *
 *      argc - The number of arguments received.
 *
 *      argv - The array of actual arguments.
 *
 *
 *  Return value:
 *
 *      TCL_OK - All went well
 *      TCL_ERROR - An error was encountered, details in the return string.
 *
 *
 *  Side effects:
 *
 *      None.
 *
 */

{
    CTclCommand tclCmd(interp, argc, argv);
    int nTclStatus = TCL_OK;


    /*
     *  thread <commands>
     */

    try
    {
        CString szCommand;
        HANDLE hThread;
        DWORD dwThreadId;
        BOOL fSts;
        DWORD dwStatus;
        ProcData prcData;

        tclCmd.NextArgument(szCommand);
        tclCmd.NoMoreArguments();
        prcData.interp = tclCmd;
        prcData.szCmd = szCommand;


        /*
         *  Execute the command in an alternate thread.
         */

        hThread = CreateThread(
                        NULL,           // pointer to security attributes
                        0,              // initial thread stack size
                        SubCommand,     // pointer to thread function
                        &prcData,       // argument for new thread
                        0,              // creation flags
                        &dwThreadId);   // pointer to receive thread ID
        if (NULL != hThread)
        {
            dwStatus = WaitForSingleObject(hThread, INFINITE);
            fSts = GetExitCodeThread(hThread, &dwStatus);
            CloseHandle(hThread);
            nTclStatus = (int)dwStatus;
        }
        else
        {
            dwStatus = GetLastError();
            tclCmd.SetError(TEXT("Can't create thread: "), dwStatus);
            throw dwStatus;
        }
    }
    catch (DWORD)
    {
        nTclStatus = TCL_ERROR;
    }

    return nTclStatus;
}   /*  end TclExt_threadCmd  */
/*  end thread.cpp  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\lib\accuratesyscalls.h ===
//--------------------------------------------------------------------
// AccurateSysCalls - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 9-24-99
//
// More accurate time functions calling the NT api directly
//

#ifndef ACCURATE_SYS_CALLS_H
#define ACCURATE_SYS_CALLS_H

void __fastcall AccurateGetTickCount(unsigned __int64 * pqwTick);
void __fastcall AccurateGetSystemTime(unsigned __int64 * pqwTime);

// WARNING! YOU MUST HAVE TIME SET PRIVILEGE FOR THIS TO WORK. NO ERROR IS RETURNED!
void __fastcall AccurateSetSystemTime(unsigned __int64 * pqwTime);

unsigned __int32 SetTimeSlipEvent(HANDLE hTimeSlipEvent);
void GetSysExpirationDate(unsigned __int64 * pqwTime);

#endif // ACCURATE_SYS_CALLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\lib\accuratesyscalls.cpp ===
//--------------------------------------------------------------------
// AccurateSysCalls - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 9-24-99
//
// More accurate time functions calling the NT api directly
//

#include <nt.h>

//--------------------------------------------------------------------
void __fastcall AccurateGetSystemTime(unsigned __int64 * pqwTime) {
    NtQuerySystemTime((LARGE_INTEGER *)pqwTime);
}

//--------------------------------------------------------------------
void __fastcall AccurateSetSystemTime(unsigned __int64 * pqwTime) {
    NtSetSystemTime((LARGE_INTEGER *)pqwTime, NULL);
}

//--------------------------------------------------------------------
void __fastcall AccurateGetTickCount(unsigned __int64 * pqwTick) {

    // HACKHACK: this is not thread safe and assumes that it will 
    //  always be called more often than every 47 days
    static unsigned __int32 dwLastTickCount=0;
    static unsigned __int32 dwHighTickCount=0;

    if (USER_SHARED_DATA->TickCountLow<dwLastTickCount) {
        dwHighTickCount++;
    }
    dwLastTickCount=USER_SHARED_DATA->TickCountLow;
    *pqwTick=USER_SHARED_DATA->TickCountLow+(((unsigned __int64)dwHighTickCount)<<32);
};

//--------------------------------------------------------------------
unsigned __int32 SetTimeSlipEvent(HANDLE hTimeSlipEvent) {
    return NtSetSystemInformation(SystemTimeSlipNotification,  &hTimeSlipEvent, sizeof(HANDLE));
}

//--------------------------------------------------------------------
void GetSysExpirationDate(unsigned __int64 * pqwTime) {
    *(LARGE_INTEGER *)pqwTime=USER_SHARED_DATA->SystemExpirationDate;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\lib\atomicint64.inl ===
//--------------------------------------------------------------------
// AtomicInt64 - inline
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 10-14-99
//
// Inlines to do atomic int64s
// Suck these into a .cpp if you need them.
//
// This int64 can have multiple readers 
// and ONE writer, NOT MULTIPLE WRITERS.
//

//####################################################################
//--------------------------------------------------------------------
struct auint64 {
private:
    volatile DWORD m_dwHi1;
    volatile DWORD m_dwLo;
    volatile DWORD m_dwHi2;
public:

    //----------------------------------------------------------------
    unsigned __int64 getValue(void) {
        DWORD dwHi;
        DWORD dwLo;
        do {
            dwHi=m_dwHi1;
            dwLo=m_dwLo;
        } while (dwHi!=m_dwHi2);
        return (((unsigned __int64)dwHi)<<32)+dwLo;
    }

    //----------------------------------------------------------------
    void setValue(unsigned __int64 qw) {
        m_dwHi1=(DWORD)(qw>>32);
        m_dwLo= (DWORD) qw;
        m_dwHi2=(DWORD)(qw>>32);
    }
};


//####################################################################
//--------------------------------------------------------------------
struct asint64 {
private:
    volatile DWORD m_dwHi1;
    volatile DWORD m_dwLo;
    volatile DWORD m_dwHi2;
public:

    //----------------------------------------------------------------
    signed __int64 getValue(void) {
        DWORD dwHi;
        DWORD dwLo;
        do {
            dwHi=m_dwHi1;
            dwLo=m_dwLo;
        } while (dwHi!=m_dwHi2);
        return (signed __int64)((((unsigned __int64)dwHi)<<32)+dwLo);
    }

    //----------------------------------------------------------------
    void setValue(signed __int64 qw) {
        m_dwHi1=(DWORD)(((unsigned __int64)qw)>>32);
        m_dwLo= (DWORD) ((unsigned __int64)qw);
        m_dwHi2=(DWORD)(((unsigned __int64)qw)>>32);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\lib\dcinfo.cpp ===
//--------------------------------------------------------------------
// DcInfo - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 7-8-99
//
// Gather information about the DCs in a domain

#include "pch.h" // precompiled headers

#include "DcInfo.h"

//####################################################################
// module private functions

//--------------------------------------------------------------------
// Get a list of DCs in this domain from the DS on an up DC.
MODULEPRIVATE HRESULT GetDcListFromDs(const WCHAR * wszDomainName, DcInfo ** prgDcs, unsigned int * pnDcs)
{
    HRESULT hr;
    NET_API_STATUS dwNetStatus;
    DWORD dwDcCount;
    unsigned int nIndex;
    unsigned int nDcs;
    unsigned int nDcIndex;

    // varaibles that must be cleaned up
    DOMAIN_CONTROLLER_INFOW * pDcInfo=NULL;
    HANDLE hDs=NULL;
    DS_DOMAIN_CONTROLLER_INFO_1W * rgDsDcInfo=NULL;
    DcInfo * rgDcs=NULL;

    // initialize out variables
    *prgDcs=NULL;
    *pnDcs=0;

    // Get a DC to seed the algorithm with
    dwNetStatus=DsGetDcName(
        NULL,           // computer name
        wszDomainName,  // domain name
        NULL,           // domain guid
        NULL,           // site name
        DS_DIRECTORY_SERVICE_PREFERRED, // flags
        &pDcInfo);      // DC info
    if (NO_ERROR!=dwNetStatus) {
        hr=HRESULT_FROM_WIN32(dwNetStatus);
        _JumpError(hr, error, "DsGetDcName");
    }
    if (0==(pDcInfo->Flags&DS_DS_FLAG)) {
        hr=HRESULT_FROM_WIN32(ERROR_DS_DST_DOMAIN_NOT_NATIVE); // not an NT5 domain.
        _JumpError(hr, error, "DsGetDcName");
    }

    // Bind to the target DS
    dwNetStatus=DsBind(
        pDcInfo->DomainControllerName,  // DC Address
        NULL,                           // DNS domain name
        &hDs );                         // DS handle
    if (NO_ERROR!=dwNetStatus) {
        hr=HRESULT_FROM_WIN32(dwNetStatus);
        _JumpError(hr, error, "DsBind");
    }

    // Get the list of DCs from the target DS.
    dwNetStatus=DsGetDomainControllerInfo(
        hDs,                    // DS handle
        pDcInfo->DomainName,    // domain name
        1,                      // Info level
        &dwDcCount,             // number of names returned
        (void **)&rgDsDcInfo);  // array of names
    if (NO_ERROR!=dwNetStatus ) {
        hr=HRESULT_FROM_WIN32(dwNetStatus);
        _JumpError(hr, error, "DsGetDomainControllerInfo");
    }

    // figure out how many DCs there are with DNS names
    nDcs=0;
    for (nIndex=0; nIndex<dwDcCount; nIndex++) {
        if (NULL!=rgDsDcInfo[nIndex].DnsHostName) {
            nDcs++;
        }
    }
    if (nDcs<dwDcCount) {
        DebugWPrintf2(L"Found %u non-DNS DCs out of %u, which will be ignored.\n", dwDcCount-nDcs, dwDcCount);
    }
    if (0==nDcs) {
        hr=HRESULT_FROM_WIN32(ERROR_DOMAIN_CONTROLLER_NOT_FOUND); // no usable DCs
        _JumpError(hr, error, "Search rgDsDcInfo for usable DCs");
    }

    // allocate the list
    rgDcs=(DcInfo *)LocalAlloc(LPTR, sizeof(DcInfo)*nDcs);
    _JumpIfOutOfMemory(hr, error, rgDcs);

    // copy the names into it
    nDcIndex=0;
    for (nIndex=0; nIndex<dwDcCount; nIndex++) {
        if (NULL!=rgDsDcInfo[nIndex].DnsHostName) {

            // allocate and copy name

            rgDcs[nDcIndex].wszDnsName=(WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(rgDsDcInfo[nIndex].DnsHostName)+1));
            _JumpIfOutOfMemory(hr, error, rgDcs[nDcIndex].wszDnsName);
            wcscpy(rgDcs[nDcIndex].wszDnsName, rgDsDcInfo[nIndex].DnsHostName);

            //_Verify(NULL!=rgDsDcInfo[nIndex].NetbiosName, hr, error);
            //rgDcs[nDcIndex].wszDnsName=(WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(rgDsDcInfo[nIndex].NetbiosName)+1));
            //_JumpIfOutOfMemory(hr, error, rgDcs[nDcIndex].wszDnsName);
            //wcscpy(rgDcs[nDcIndex].wszDnsName, rgDsDcInfo[nIndex].NetbiosName);

            // copy PDCness
            rgDcs[nDcIndex].bIsPdc=rgDsDcInfo[nIndex].fIsPdc?true:false;
            nDcIndex++;
        }
    }

    // move the data to the out parameters
    *prgDcs=rgDcs;
    rgDcs=NULL;
    *pnDcs=nDcs;

    hr=S_OK;

error:
    if (NULL!=rgDcs) {
        for (nIndex=0; nIndex<nDcs; nIndex++) {
            FreeDcInfo(&rgDcs[nIndex]);
        }
        LocalFree(rgDcs);
    }
    if (NULL!=rgDsDcInfo ) {
        DsFreeDomainControllerInfo(1, dwDcCount, rgDsDcInfo);
    }
    if (NULL!=hDs) {
        DsUnBind(&hDs);
    }
    if (NULL!=pDcInfo) {
        NetApiBufferFree(pDcInfo);
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetDcListFromNetlogon(const WCHAR * wszDomainName, DcInfo ** prgDcs, unsigned int * pnDcs)
{
    HRESULT hr;
    NET_API_STATUS dwNetStatus;
    DWORD dwEntriesRead;
    DWORD dwTotalEntries;
    unsigned int nIndex;
    unsigned int nDcIndex;
    unsigned int nDcs;

    // varaibles that must be cleaned up
    DcInfo * rgDcs=NULL;
    SERVER_INFO_101 * rgsiServerInfo=NULL;

    // initialize out variables
    *prgDcs=NULL;
    *pnDcs=0;

    // enumerate all PDC and BDCs
    dwNetStatus=NetServerEnum(
        NULL,                       // server to query
        101,                        // info level
        (BYTE **)&rgsiServerInfo,   // output buffer
        MAX_PREFERRED_LENGTH,       // desired return buf size
        &dwEntriesRead,             // entries in output buffer
        &dwTotalEntries,            // total number of entries available
        SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL, // server type to find
        wszDomainName,              // domain to search
        NULL);                      // reserved
    if (NO_ERROR!=dwNetStatus ) {
        hr=HRESULT_FROM_WIN32(dwNetStatus);
        _JumpError(hr, error, "NetServerEnum");
    }

    // count how many NT 5 servers there are
    nDcs=0;
    for (nIndex=0; nIndex<dwEntriesRead; nIndex++) {
        if (0!=(rgsiServerInfo[nIndex].sv101_type&SV_TYPE_NT) 
            && rgsiServerInfo[nIndex].sv101_version_major>=5) {
            nDcs++;
        }
    }
    if (nDcs<dwEntriesRead) {
        DebugWPrintf2(L"Found %u non-NT5 DCs out of %u, which will be ignored.\n", dwEntriesRead-nDcs, dwEntriesRead);
    }
    if (0==nDcs) {
        hr=HRESULT_FROM_WIN32(ERROR_DOMAIN_CONTROLLER_NOT_FOUND); // no usable DCs
        _JumpError(hr, error, "Search rgsiServerInfo for usable DCs");
    }

    // allocate the list
    rgDcs=(DcInfo *)LocalAlloc(LPTR, sizeof(DcInfo)*nDcs);
    _JumpIfOutOfMemory(hr, error, rgDcs);

    // copy the names into it
    nDcIndex=0;
    for (nIndex=0; nIndex<dwEntriesRead; nIndex++) {
        if (0!=(rgsiServerInfo[nIndex].sv101_type&SV_TYPE_NT) 
            && rgsiServerInfo[nIndex].sv101_version_major>=5) {
            
            // allocate and copy name
            rgDcs[nDcIndex].wszDnsName=(WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(rgsiServerInfo[nIndex].sv101_name)+1));
            _JumpIfOutOfMemory(hr, error, rgDcs[nDcIndex].wszDnsName);
            wcscpy(rgDcs[nDcIndex].wszDnsName, rgsiServerInfo[nIndex].sv101_name);

            // copy PDCness
            rgDcs[nDcIndex].bIsPdc=(rgsiServerInfo[nIndex].sv101_type&SV_TYPE_DOMAIN_CTRL)?true:false;
            nDcIndex++;
        }
    }

    // move the data to the out parameters
    *prgDcs=rgDcs;
    rgDcs=NULL;
    *pnDcs=nDcs;

    hr=S_OK;

error:
    if (NULL!=rgDcs) {
        for (nIndex=0; nIndex<nDcs; nIndex++) {
            FreeDcInfo(&rgDcs[nIndex]);
        }
        LocalFree(rgDcs);
    }
    if (NULL!=rgsiServerInfo) {
        NetApiBufferFree(rgsiServerInfo);
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT FillInIpAddresses(DcInfo * pdi) {
    HRESULT hr;
    DWORD dwDataLen;
    unsigned int nIndex;

    // pointers that must be cleaned up
    HANDLE hSearch=INVALID_HANDLE_VALUE;
    WSAQUERYSETW * pqsResult=NULL;
    in_addr * rgiaLocalIpAddresses=NULL;
    in_addr * rgiaRemoteIpAddresses=NULL;

    DebugWPrintf1(L"Looking up server \"%s\":\n", pdi->wszDnsName);

    // initialize the search
    AFPROTOCOLS apInetUdp={AF_INET, IPPROTO_UDP};
    GUID guidNtp=SVCID_NTP_UDP;
    WSAQUERYSETW qsSearch;
    ZeroMemory(&qsSearch, sizeof(qsSearch));
    qsSearch.dwSize=sizeof(qsSearch);
    qsSearch.lpszServiceInstanceName=const_cast<WCHAR *>(pdi->wszDnsName);
    qsSearch.lpServiceClassId=&guidNtp;
    qsSearch.dwNameSpace=NS_ALL;
    qsSearch.dwNumberOfProtocols=1;
    qsSearch.lpafpProtocols=&apInetUdp;

    // begin the search
    if (SOCKET_ERROR==WSALookupServiceBegin(&qsSearch, LUP_RETURN_ADDR/*flags*/, &hSearch)) {
        hr=HRESULT_FROM_WIN32(WSAGetLastError());
        _JumpError(hr, error, "WSALookupServiceBegin");
    }

    // get the buffer size for the first result set
    //dwDataLen=1;
    //_Verify(SOCKET_ERROR==WSALookupServiceNext(hSearch, LUP_RETURN_ADDR/*flags*/, &dwDataLen, &qsSearch), hr, error);
    //hr=WSAGetLastError();
    //if (WSAEFAULT!=hr) {
    //    hr=HRESULT_FROM_WIN32(hr);
    //    _JumpError(hr, error, "WSALookupServiceNext(1)");
    //}
    dwDataLen=5*1024;

    // allocate the buffer
    pqsResult=(WSAQUERYSETW *)LocalAlloc(LPTR, dwDataLen);
    _JumpIfOutOfMemory(hr, error, pqsResult);
    
    // retrieve the result set
    if (SOCKET_ERROR==WSALookupServiceNext(hSearch, LUP_RETURN_ADDR/*flags*/, &dwDataLen, pqsResult)) {
        hr=HRESULT_FROM_WIN32(WSAGetLastError());
        _JumpError(hr, error, "WSALookupServiceNext(2)");
    }
    _Verify(0!=pqsResult->dwNumberOfCsAddrs, hr, error) ;

    // allocate room for the IP addresses
    rgiaLocalIpAddresses=(in_addr *)LocalAlloc(LPTR, sizeof(in_addr)*pqsResult->dwNumberOfCsAddrs);
    _JumpIfOutOfMemory(hr, error, rgiaLocalIpAddresses);
    rgiaRemoteIpAddresses=(in_addr *)LocalAlloc(LPTR, sizeof(in_addr)*pqsResult->dwNumberOfCsAddrs);
    _JumpIfOutOfMemory(hr, error, rgiaRemoteIpAddresses);

    // copy the IP addresses
    for (nIndex=0; nIndex<pqsResult->dwNumberOfCsAddrs; nIndex++) {
        // copy local
        _Verify(sizeof(sockaddr)==pqsResult->lpcsaBuffer[nIndex].LocalAddr.iSockaddrLength, hr, error);
        _Verify(AF_INET==pqsResult->lpcsaBuffer[nIndex].LocalAddr.lpSockaddr->sa_family, hr, error);
        rgiaLocalIpAddresses[nIndex].S_un.S_addr=((sockaddr_in *)(pqsResult->lpcsaBuffer[nIndex].LocalAddr.lpSockaddr))->sin_addr.S_un.S_addr;
        // copy remote
        _Verify(sizeof(sockaddr)==pqsResult->lpcsaBuffer[nIndex].RemoteAddr.iSockaddrLength, hr, error);
        _Verify(AF_INET==pqsResult->lpcsaBuffer[nIndex].RemoteAddr.lpSockaddr->sa_family, hr, error);
        rgiaRemoteIpAddresses[nIndex].S_un.S_addr=((sockaddr_in *)(pqsResult->lpcsaBuffer[nIndex].RemoteAddr.lpSockaddr))->sin_addr.S_un.S_addr;
    }

    // move the data to the out parameters
    pdi->nIpAddresses=pqsResult->dwNumberOfCsAddrs;
    pdi->rgiaLocalIpAddresses=rgiaLocalIpAddresses;
    rgiaLocalIpAddresses=NULL;
    pdi->rgiaRemoteIpAddresses=rgiaRemoteIpAddresses;
    rgiaRemoteIpAddresses=NULL;

    hr=S_OK;

error:
    if (NULL!=rgiaLocalIpAddresses) {
        LocalFree(rgiaLocalIpAddresses);
    }
    if (NULL!=rgiaRemoteIpAddresses) {
        LocalFree(rgiaRemoteIpAddresses);
    }
    if (NULL!=pqsResult) {
        LocalFree(pqsResult);
    }
    if (INVALID_HANDLE_VALUE!=hSearch) {
        if (SOCKET_ERROR==WSALookupServiceEnd(hSearch)) {
            HRESULT hr2=HRESULT_FROM_WIN32(WSAGetLastError());
            _IgnoreError(hr2, "WSALookupServiceEnd");
        }
    }

    return hr;
}

//####################################################################
// Globals

//--------------------------------------------------------------------
void FreeDcInfo(DcInfo * pdci) {
    if (NULL!=pdci->wszDnsName) {
        LocalFree(pdci->wszDnsName);
    }
    if (NULL!=pdci->rgiaLocalIpAddresses) {
        LocalFree(pdci->rgiaLocalIpAddresses);
    }
    if (NULL!=pdci->rgiaRemoteIpAddresses) {
        LocalFree(pdci->rgiaRemoteIpAddresses);
    }
}

//--------------------------------------------------------------------
// Get a list of DCs in this domain
HRESULT GetDcList(const WCHAR * wszDomainName, bool bGetIps, DcInfo ** prgDcs, unsigned int * pnDcs)
{
    HRESULT hr;
    unsigned int nDcs;
    unsigned int nIndex;

    // varaibles that must be cleaned up
    DcInfo * rgDcs=NULL;

    // initialize out variables
    *prgDcs=NULL;
    *pnDcs=0;

    hr=GetDcListFromDs(wszDomainName, &rgDcs, &nDcs);
    if (FAILED(hr)) {
        _IgnoreError(hr, "GetDcListFromDs");
        hr=GetDcListFromNetlogon(wszDomainName, &rgDcs, &nDcs);
        _JumpIfError(hr, error, "GetDcListFromNetlogon");
    }
    
    if (bGetIps) {
        // get the info about the DCs
        for (nIndex=0; nIndex<nDcs; nIndex++) {
            hr=FillInIpAddresses(&rgDcs[nIndex]);
            if (FAILED(hr)) {
                _IgnoreError(hr, "FillInIpAddresses");
                if (nIndex!=nDcs-1) {
                    // swap it with the last one
                    WCHAR * wszDnsName=rgDcs[nIndex].wszDnsName;
                    rgDcs[nIndex].wszDnsName=rgDcs[nDcs-1].wszDnsName;
                    rgDcs[nDcs-1].wszDnsName=wszDnsName;

                    in_addr * rgiaLocalIpAddresses=rgDcs[nIndex].rgiaLocalIpAddresses;
                    rgDcs[nIndex].rgiaLocalIpAddresses=rgDcs[nDcs-1].rgiaLocalIpAddresses;
                    rgDcs[nDcs-1].rgiaLocalIpAddresses=rgiaLocalIpAddresses;

                    in_addr * rgiaRemoteIpAddresses=rgDcs[nIndex].rgiaRemoteIpAddresses;
                    rgDcs[nIndex].rgiaRemoteIpAddresses=rgDcs[nDcs-1].rgiaRemoteIpAddresses;
                    rgDcs[nDcs-1].rgiaRemoteIpAddresses=rgiaRemoteIpAddresses;

                    // non-pointers can just be copied
                    rgDcs[nIndex].nIpAddresses=rgDcs[nDcs-1].nIpAddresses;
                    rgDcs[nIndex].bIsPdc=rgDcs[nDcs-1].bIsPdc;
                    rgDcs[nIndex].bIsGoodTimeSource=rgDcs[nDcs-1].bIsGoodTimeSource;
                }
                DebugWPrintf1(L"Dropping '%s' because we cannot get an IP address.\n", rgDcs[nDcs-1].wszDnsName);
                nDcs--;
                nIndex--;
            }
        }
    }

    if (0==nDcs) {
        hr=HRESULT_FROM_WIN32(ERROR_DOMAIN_CONTROLLER_NOT_FOUND); // no usable DCs
        _JumpError(hr, error, "Getting IP address for at least one DC");
    }

    // move the data to the out parameters
    *prgDcs=rgDcs;
    rgDcs=NULL;
    *pnDcs=nDcs;

    hr=S_OK;

error:
    if (NULL!=rgDcs) {
        for (nIndex=0; nIndex<nDcs; nIndex++) {
            FreeDcInfo(&rgDcs[nIndex]);
        }
        LocalFree(rgDcs);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\lib\dcinfo.h ===
//--------------------------------------------------------------------
// DcInfo - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 7-8-99
//
// Gather information about the DCs in a domain

#ifndef DCINFO_H
#define DCINFO_H

struct DcInfo {
    WCHAR * wszDnsName;
    in_addr * rgiaLocalIpAddresses;
    in_addr * rgiaRemoteIpAddresses;
    unsigned int nIpAddresses;
    bool bIsPdc;
    bool bIsGoodTimeSource;
};

void FreeDcInfo(DcInfo * pdci);
HRESULT GetDcList(const WCHAR * wszDomainName, bool bGetIps, DcInfo ** prgDcs, unsigned int * pnDcs);

#endif DCINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\lib\debugwprintf.h ===
//--------------------------------------------------------------------
// DebugWPrintf - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 2-7-99
//
// Debugging print routines
//

#ifndef DEBUGWPRINTF_H
#define DEBUGWPRINTF_H

//#ifdef  NDEBUG
#ifndef DBG

#define DebugWPrintf0(wszFormat)
#define DebugWPrintf1(wszFormat,a)
#define DebugWPrintf2(wszFormat,a,b)
#define DebugWPrintf3(wszFormat,a,b,c)
#define DebugWPrintf4(wszFormat,a,b,c,d)
#define DebugWPrintf5(wszFormat,a,b,c,d,e)
#define DebugWPrintf6(wszFormat,a,b,c,d,e,f)
#define DebugWPrintf7(wszFormat,a,b,c,d,e,f,g)
#define DebugWPrintf8(wszFormat,a,b,c,d,e,f,g,h)
#define DebugWPrintf9(wszFormat,a,b,c,d,e,f,g,h,i)
#define DebugWPrintfTerminate()

//#else //NDEBUG
#else //DBG


#define DebugWPrintf0(wszFormat)                   DebugWPrintf_((wszFormat))
#define DebugWPrintf1(wszFormat,a)                 DebugWPrintf_((wszFormat),(a))
#define DebugWPrintf2(wszFormat,a,b)               DebugWPrintf_((wszFormat),(a),(b))
#define DebugWPrintf3(wszFormat,a,b,c)             DebugWPrintf_((wszFormat),(a),(b),(c))
#define DebugWPrintf4(wszFormat,a,b,c,d)           DebugWPrintf_((wszFormat),(a),(b),(c),(d))
#define DebugWPrintf5(wszFormat,a,b,c,d,e)         DebugWPrintf_((wszFormat),(a),(b),(c),(d),(e))
#define DebugWPrintf6(wszFormat,a,b,c,d,e,f)       DebugWPrintf_((wszFormat),(a),(b),(c),(d),(e),(f))
#define DebugWPrintf7(wszFormat,a,b,c,d,e,f,g)     DebugWPrintf_((wszFormat),(a),(b),(c),(d),(e),(f),(g))
#define DebugWPrintf8(wszFormat,a,b,c,d,e,f,g,h)   DebugWPrintf_((wszFormat),(a),(b),(c),(d),(e),(f),(g),(h))
#define DebugWPrintf9(wszFormat,a,b,c,d,e,f,g,h,i) DebugWPrintf_((wszFormat),(a),(b),(c),(d),(e),(f),(g),(h),(i))
#define DebugWPrintfTerminate()                    DebugWPrintfTerminate_()

void DebugWPrintf_(const WCHAR * wszFormat, ...);
void DebugWPrintfTerminate_(void);

//#endif //NDEBUG
#endif //DBG


#endif //DEBUGWPRINTF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\lib\errorhandling.h ===
//--------------------------------------------------------------------
// ErrorHandling - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 8-10-99
//
// Macro definitions for CertSrv style error handling
//

#ifndef ERROR_HANDLING_H
#define ERROR_HANDLING_H

#include <memory>
#include <exception>
using namespace std; 

//----------------------------------------------------------------------
// Exception handling translation code.
// Translates SEH to C++-style exceptions.
//----------------------------------------------------------------------
class SeException : public std::exception
{
 public:
    SeException(unsigned int code) : m_code(code) { } 
    unsigned int getSECode() { return m_code; } 

 private:
    unsigned int m_code; 
}; 

void __cdecl SeTransFunc(unsigned int u, EXCEPTION_POINTERS* pExp);

//----------------------------------------------------------------------
// C-style error-handling routines.
//----------------------------------------------------------------------
#ifdef DBG
#define _MyAssert(expression) \
    {\
        if (!(expression)) { \
            DebugWPrintf1(L"*** Assert failed: '%s' is false.\n", L## #expression); \
            DebugBreak(); \
        }\
    }
#else  //DBG
#define _MyAssert(expression)
#endif //DBG

#define _Verify(expression, hr, label) \
    {\
        if (!(expression)) { \
            DebugWPrintf1(L"Verify failed: '%s' is false.\n", L## #expression); \
            hr=E_UNEXPECTED; \
            goto label; \
        }\
    }

#define _IgnoreError(hr, errorsource) \
    DebugWPrintf1(L##errorsource L" failed with 0x%08X, ignored.\n", hr);

#define _IgnoreErrorStr(hr, errorsource, wstr) \
    DebugWPrintf2(L##errorsource L"(%s) failed with 0x%08X, ignored.\n", wstr, hr);

#define _IgnoreLastError(errorsource) \
    DebugWPrintf1(L##errorsource L" failed with 0x%08X, ignored.\n", HRESULT_FROM_WIN32(GetLastError()));

#define _IgnoreIfError(hr, errorsource) \
    {\
        if (FAILED(hr)) { \
            DebugWPrintf1(L##errorsource L" failed with 0x%08X, ignored.\n", hr); \
        }\
    }

#define _JumpError(hr, label, errorsource) \
    DebugWPrintf1(L##errorsource L" failed with 0x%08X.\n", hr); \
    goto label;

#define _JumpErrorStr(hr, label, errorsource, wstr) \
    DebugWPrintf2(L##errorsource L"(%s) failed with 0x%08X.\n", wstr, hr); \
    goto label;

#define _JumpLastError(hr, label, errorsource) \
    hr=HRESULT_FROM_WIN32(GetLastError()); \
    DebugWPrintf1(L##errorsource L" failed with 0x%08X.\n", hr); \
    goto label;

#define _JumpLastErrorStr(hr, label, errorsource, wstr) \
    hr=HRESULT_FROM_WIN32(GetLastError()); \
    DebugWPrintf2(L##errorsource L"(%s) failed with 0x%08X.\n", wstr, hr); \
    goto label;

#define _JumpIfError(hr, label, errorsource) \
    {\
        if (FAILED(hr)) { \
            DebugWPrintf1(L##errorsource L" failed with 0x%08X.\n", hr); \
            goto label; \
        }\
    }

#define _JumpIfErrorStr(hr, label, errorsource, wstr) \
    {\
        if (FAILED(hr)) { \
            DebugWPrintf2(L##errorsource L"(%s) failed with 0x%08X.\n", wstr, hr); \
            goto label; \
        }\
    }

#define _JumpIfOutOfMemory(hr, label, pointer) \
    {\
        if (NULL==(pointer)) { \
            hr=E_OUTOFMEMORY; \
            DebugWPrintf0(L"Out of memory ('" L## #pointer L"').\n"); \
            goto label; \
        }\
    }


// Save the old se translator so we can restore it when we're done 
#define _BeginTryWith(hr) \
    { \
        _se_translator_function  fnSeTranslatorOld = _set_se_translator(SeTransFunc); \
        hr=S_OK; \
        try 

#define _TrapException(hr) \
        catch (SeException see) { \
            hr = HRESULT_FROM_WIN32(see.getSECode()); \
        } \
        catch (std::bad_alloc bae) { \
            hr = E_OUTOFMEMORY; \
        } \
        catch (...) { \
            hr = E_UNEXPECTED; \
        } \
        _set_se_translator(fnSeTranslatorOld); \
    }

#define _TeardownError(hr, hr2, errorsource) \
    {\
        if (FAILED(hr2)) { \
            DebugWPrintf1(L##errorsource L" failed with 0x%08X during teardown.\n", hr2); \
            if (!FAILED(hr)) { \
                hr=hr2; \
            } \
        }\
    }

#define _SafeStlCall(func, hr, error, errorsource) \
    {\
        _BeginTryWith(hr) {\
            (func); \
        } _TrapException(hr); \
        if (FAILED(hr)) { \
            _JumpError(hr, error, errorsource); \
        } \
    }


#define _AcquireResourceSharedOrFail(lock, bAcquiredResource, hr, error) \
{ \
    BOOLEAN bSuccess = FALSE; \
    HRESULT hr2 = myRtlAcquireResourceShared((lock), TRUE, &bSuccess);  \
    if (FAILED(hr2)) { \
        hr = hr2; \
        _JumpError(hr, error, "myRtlAcquireResourceShared"); \
    } else if (!bSuccess) { \
        hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR); \
        _JumpError(hr, error, "myRtlAcquireResourceShared: couldn't acquire resource"); \
    } \
    bAcquiredResource = true; \
}

#define _AcquireResourceExclusiveOrFail(lock, bAcquiredResource, hr, error) \
{ \
    BOOLEAN bSuccess = FALSE; \
    HRESULT hr2 = myRtlAcquireResourceExclusive((lock), TRUE, &bSuccess);  \
    if (FAILED(hr2)) { \
        hr = hr2; \
        _JumpError(hr, error, "myRtlAcquireResourceShared"); \
    } else if (!bSuccess) { \
        hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR); \
        _JumpError(hr, error, "myRtlAcquireResourceShared: couldn't acquire resource"); \
    } \
    bAcquiredResource = true; \
}

#define _ReleaseResource(lock, bAcquiredResource) \
{ \
    if (bAcquiredResource) { \
        HRESULT hr2 = myRtlReleaseResource(lock); \
        _IgnoreIfError(hr2, "myRtlReleaseResource"); \
        if (SUCCEEDED(hr2)) { \
            bAcquiredResource = false; \
        } \
    } \
} 


#endif ERROR_HANDLING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\lib\localizedwprintf.h ===
#ifndef W32TM_LOCALIZED_PRINTF_H
#define W32TM_LOCALIZED_PRINTF_H 1




HRESULT 
MyWriteConsole(
    HANDLE  fp,
    LPWSTR  lpBuffer,
    DWORD   cchBuffer
    );


HRESULT InitializeConsoleOutput(); 
HRESULT LocalizedWPrintf(UINT nResourceID); 
HRESULT LocalizedWPrintf2(UINT nResouceID, LPWSTR pwszFormat, ...); 
HRESULT LocalizedWPrintfCR(UINT nResourceID);

VOID DisplayMsg(DWORD dwSource, DWORD dwMsgId, ... );
BOOL WriteMsg(DWORD dwSource, DWORD dwMsgId, LPWSTR *ppMsg, ...);

#endif // W32TM_LOCALIZED_PRINTF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\lib\debugwprintf.cpp ===
//--------------------------------------------------------------------
// DebugWPrintf - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 2-7-99
//
// Debugging print routines
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
/*
bool g_bWindowCreated=false;
HWND g_hwDbg=NULL;
HWND g_hwOuter=NULL;
HANDLE g_hThread=NULL;
HANDLE g_hThreadReady=NULL;
*/
/*
//--------------------------------------------------------------------
static LRESULT CALLBACK DwpWinProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {

    switch (uMsg)
    {
        case WM_CREATE:
            *(HWND *)(((CREATESTRUCT *)lParam)->lpCreateParams)=CreateWindowEx(
                WS_EX_CLIENTEDGE,
                L"EDIT",     // predefined class
                NULL,       // no window title
                WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_HSCROLL | ES_LEFT | ES_MULTILINE | ES_AUTOVSCROLL | ES_AUTOHSCROLL | ES_READONLY,
                0, 0, 0, 0, // set size in WM_SIZE message
                hwnd,       // parent window
                NULL,       // edit control ID
                (HINSTANCE) GetWindowLong(hwnd, GWL_HINSTANCE),
                NULL);                // pointer not needed

            return 0;


        case WM_SETFOCUS:
            SetFocus(g_hwDbg);
            return 0;

        case WM_SIZE:

            // Make the edit control the size of the window's
            // client area.

            MoveWindow(g_hwDbg,
                0, 0,           // starting x- and y-coordinates
                LOWORD(lParam), // width of client area
                HIWORD(lParam), // height of client area
                TRUE);          // repaint window
            return 0;

        case WM_DESTROY:
            PostQuitMessage(0);
            return 0;

        default:
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}

//--------------------------------------------------------------------
static BOOL DwpRegWinClass(void) {
    WNDCLASSEX wcx;

    // Fill in the window class structure with parameters
    // that describe the main window.

    wcx.cbSize=sizeof(wcx);             // size of structure
    wcx.style=CS_NOCLOSE;               // redraw if size changes
    wcx.lpfnWndProc=DwpWinProc;         // points to window procedure
    wcx.cbClsExtra=0;                   // no extra class memory
    wcx.cbWndExtra=0;                   // no extra window memory
    wcx.hInstance=GetModuleHandle(NULL);            // handle to instance
    wcx.hIcon=LoadIcon(NULL, IDI_APPLICATION);      // predefined app. icon
    wcx.hCursor=LoadCursor(NULL, IDC_ARROW);        // predefined arrow
    wcx.hbrBackground=(HBRUSH)GetStockObject(WHITE_BRUSH); // white background brush
    wcx.lpszMenuName=NULL;              // name of menu resource
    wcx.lpszClassName=L"DwpWin";        // name of window class
    wcx.hIconSm=NULL;                   // small class icon

    // Register the window class.

    return RegisterClassEx(&wcx);
}


//--------------------------------------------------------------------
static DWORD WINAPI DebugWPrintfMsgPump(void * pvIgnored) {
    MSG msg;

    DwpRegWinClass();
    g_hwOuter=CreateWindow(
        L"DwpWin",
        L"DebugWPrintf",
        // WS_VISIBLE | WS_OVERLAPPED | WS_CAPTION | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,
        WS_VISIBLE | WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        300,
        200,
        NULL,
        NULL,
        NULL,
        &g_hwDbg);
    if (g_hwOuter) {
        SetWindowLongPtr(g_hwOuter, GWLP_WNDPROC, (LONG_PTR)DwpWinProc);
        SetWindowPos(g_hwOuter, 0, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
    }
    SetEvent(g_hThreadReady);
    if (g_hwOuter) {
        while (GetMessage(&msg, g_hwOuter, 0, 0 )>0) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return S_OK;
}
*/
//--------------------------------------------------------------------
void DebugWPrintf_(const WCHAR * wszFormat, ...) {
    WCHAR wszBuf[1024];
    va_list vlArgs;
    va_start(vlArgs, wszFormat);
    _vsnwprintf(wszBuf, 1024, wszFormat, vlArgs);
    va_end(vlArgs);

#if DBG
    {
        UNICODE_STRING UnicodeString;
        ANSI_STRING AnsiString;
        NTSTATUS Status;

        RtlInitUnicodeString(&UnicodeString,wszBuf);
        Status = RtlUnicodeStringToAnsiString(&AnsiString,&UnicodeString,TRUE);
        if ( !NT_SUCCESS(Status) ) {
            AnsiString.Buffer = "";
        }
        KdPrintEx((DPFLTR_W32TIME_ID, DPFLTR_TRACE_LEVEL, AnsiString.Buffer));
        if ( NT_SUCCESS(Status) ) {
            RtlFreeAnsiString(&AnsiString);
        }
    }
#endif
    // do basic output
    // OutputDebugStringW(wszBuf);
    if (_fileno(stdout) >= 0)
         wprintf(L"%s", wszBuf);
/*
    // convert \n to \r\n
    unsigned int nNewlines=0;
    WCHAR * wszTravel=wszBuf;
    while (NULL!=(wszTravel=wcschr(wszTravel, L'\n'))) {
        wszTravel++;
        nNewlines++;
    }
    WCHAR * wszSource=wszBuf+wcslen(wszBuf);
    WCHAR * wszTarget=wszSource+nNewlines;
    while (nNewlines>0) {
        if (L'\n'==(*wszTarget=*wszSource)) {
            wszTarget--;
            *wszTarget=L'\r';
            nNewlines--;
        }
        wszTarget--;
        wszSource--;
    }

    // create a window if there is not one already
    if (false==g_bWindowCreated) {
        g_bWindowCreated=true;
        g_hThreadReady=CreateEvent(NULL, TRUE, FALSE, NULL);
        if (NULL!=g_hThreadReady) {
            DWORD dwThreadID;
            g_hThread=CreateThread(NULL, 0, DebugWPrintfMsgPump, NULL, 0, &dwThreadID);
            if (NULL!=g_hThread) {
                WaitForSingleObject(g_hThreadReady, INFINITE);
            }
            CloseHandle(g_hThreadReady);
            g_hThreadReady=NULL;
        }
    }
    if (NULL!=g_hwDbg) {
        SendMessage(g_hwDbg, EM_SETSEL, SendMessage(g_hwDbg, WM_GETTEXTLENGTH, 0, 0), -1);
        SendMessage(g_hwDbg, EM_REPLACESEL, FALSE, (LPARAM)wszBuf);
    }
*/
}

//--------------------------------------------------------------------
void DebugWPrintfTerminate_(void) {
    /*
    MessageBox(NULL, L"Done.\n\nPress OK to close.", L"DebugWPrintfTerminate", MB_OK | MB_ICONINFORMATION);
    if (NULL!=g_hwOuter) {
        PostMessage(g_hwOuter, WM_CLOSE, 0,0);
        if (NULL!=g_hThread) {
            WaitForSingleObject(g_hThread, INFINITE);
        }
    }
    */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\lib\localizedwprintf.cpp ===
#include "pch.h"
#include <stdio.h>

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

extern HINSTANCE g_hThisModule;  
       HANDLE    g_hStdout       = NULL; 

HRESULT InitializeConsoleOutput() { 
    g_hStdout = GetStdHandle(STD_OUTPUT_HANDLE); 
    if (INVALID_HANDLE_VALUE == g_hStdout) { 
        return HRESULT_FROM_WIN32(GetLastError()); 
    }
    
    return S_OK; 
}


BOOL
FileIsConsole(
    HANDLE fp
    )
{
    DWORD htype;

    htype = GetFileType(fp);
    htype &= ~FILE_TYPE_REMOTE;
    return htype == FILE_TYPE_CHAR;
}

HRESULT
MyWriteConsole(
    HANDLE  fp,
    LPWSTR  lpBuffer,
    DWORD   cchBuffer
    )
{
    HRESULT hr;
    LPSTR  lpAnsiBuffer = NULL;

    //
    // Jump through hoops for output because:
    //
    //    1.  printf() family chokes on international output (stops
    //        printing when it hits an unrecognized character)
    //
    //    2.  WriteConsole() works great on international output but
    //        fails if the handle has been redirected (i.e., when the
    //        output is piped to a file)
    //
    //    3.  WriteFile() works great when output is piped to a file
    //        but only knows about bytes, so Unicode characters are
    //        printed as two Ansi characters.
    //

    if (FileIsConsole(fp))
    {
	hr = WriteConsole(fp, lpBuffer, cchBuffer, &cchBuffer, NULL);
        _JumpIfError(hr, error, "WriteConsole");
    }
    else
    {
        lpAnsiBuffer = (LPSTR) LocalAlloc(LPTR, cchBuffer * sizeof(WCHAR));

        if (lpAnsiBuffer != NULL)
        {
            cchBuffer = WideCharToMultiByte(CP_OEMCP,
                                            0,
                                            lpBuffer,
                                            cchBuffer,
                                            lpAnsiBuffer,
                                            cchBuffer * sizeof(WCHAR),
                                            NULL,
                                            NULL);

            if (cchBuffer != 0)
            {
                if (!WriteFile(fp, lpAnsiBuffer, cchBuffer, &cchBuffer, NULL))
                {
                    hr = GetLastError();
                    _JumpError(hr, error, "WriteFile");
                }
            }
            else
            {
                hr = GetLastError();
                _JumpError(hr, error, "WideCharToMultiByte");
            }
        }
    }

error:
    if (NULL != lpAnsiBuffer)
        LocalFree(lpAnsiBuffer);

    return hr;
}


HRESULT LocalizedWPrintf(UINT nResourceID) { 
    DWORD   ccWritten; 
    DWORD   dwRetval;
    HRESULT hr;
    WCHAR   rgwszString[512]; 

    dwRetval = LoadStringW(g_hThisModule, nResourceID, rgwszString, ARRAYSIZE(rgwszString)); 
    if (0 == dwRetval) { 
        _JumpLastError(hr, error, "LoadStringW"); 
    }

    _Verify(512 > dwRetval, hr, error);   // Shouldn't fill our buffer...

    hr = MyWriteConsole(g_hStdout, rgwszString, dwRetval);
    _JumpIfError(hr, error, "MyWriteConsole");

    
    hr = S_OK;  // All done!
 error:
    return hr; 
}

HRESULT LocalizedWPrintf2(UINT nResourceID, LPWSTR pwszFormat, ...) { 
    DWORD   ccWritten; 
    va_list args; 
    WCHAR   pwszBuffer[1024]; 

    HRESULT hr = LocalizedWPrintf(nResourceID);
    _JumpIfError(hr, error, "LocalizedWPrintf"); 

    va_start(args, pwszFormat);
    _vsnwprintf(pwszBuffer, ARRAYSIZE(pwszBuffer), pwszFormat, args); 
    va_end(args);
    
    hr = MyWriteConsole(g_hStdout, pwszBuffer, wcslen(pwszBuffer));
    _JumpIfError(hr, error, "MyWriteConsole"); 

    hr = S_OK; 
 error:
    return hr;
}

// Same as LocalizedWPrintf, but adds a carriage return. 
HRESULT LocalizedWPrintfCR(UINT nResourceID) { 
    HRESULT hr = LocalizedWPrintf(nResourceID); 
    wprintf(L"\n"); 
    return hr; 
}

VOID DisplayMsg(DWORD dwSource, DWORD dwMsgId, ... )
{
    DWORD    dwBytesWritten;
    DWORD    dwLen;
    LPWSTR   pwszDisplayBuffer  = NULL;
    va_list  ap;

    va_start(ap, dwMsgId);

    dwLen = FormatMessageW(dwSource | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                           NULL, 
                           dwMsgId, 
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           (LPWSTR)&pwszDisplayBuffer, 
                           0, 
                           &ap);

    if (dwLen && pwszDisplayBuffer) {
        MyWriteConsole(g_hStdout, pwszDisplayBuffer, dwLen);

    }

    if (NULL != pwszDisplayBuffer) { LocalFree(pwszDisplayBuffer); }

    va_end(ap);
}

BOOL WriteMsg(DWORD dwSource, DWORD dwMsgId, LPWSTR *ppMsg, ...)
{
    DWORD    dwBytesWritten;
    DWORD    dwLen;
    LPWSTR   pwszDisplayBuffer = NULL;
    va_list  ap;

    va_start(ap, ppMsg);

    dwLen = FormatMessageW(dwSource | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                           NULL, 
                           dwMsgId, 
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           (LPWSTR)ppMsg, 
                           0, 
                           &ap);
    va_end(ap);

    // 0 is the error return value of FormatMessage.  
    return (0 != dwLen);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\lib\endianswap.inl ===
//--------------------------------------------------------------------
// EndianSwap - inline
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 4-16-99
//
// Inlines to do endian conversion.
// Suck these into a .cpp if you need them.
//

//--------------------------------------------------------------------
static inline unsigned __int16 EndianSwap(unsigned __int16 wSource) {
    return (wSource&0x00ff)<<8 | (wSource&0xff00)>>8;
}

//--------------------------------------------------------------------
static inline unsigned __int32 EndianSwap(unsigned __int32 dwSource) {
    return
          (dwSource&0x000000ff)<<24 | (dwSource&0x0000ff00)<<8
        | (dwSource&0x00ff0000)>>8  | (dwSource&0xff000000)>>24;
}

//--------------------------------------------------------------------
static inline unsigned __int64 EndianSwap(unsigned __int64 qwSource) {
    return
          (qwSource&0x00000000000000ff)<<56 | (qwSource&0x000000000000ff00)<<40
        | (qwSource&0x0000000000ff0000)<<24 | (qwSource&0x00000000ff000000)<<8
        | (qwSource&0x000000ff00000000)>>8  | (qwSource&0x0000ff0000000000)>>24
        | (qwSource&0x00ff000000000000)>>40 | (qwSource&0xff00000000000000)>>56;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\lib\pch.h ===
//--------------------------------------------------------------------
// pch - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 2-7-99
//
// Precompiled header for lib
//

#include <windows.h>
#include <rpc.h>
#include <rpcdce.h>
#include <dsgetdc.h>
#include <ntdsapi.h>
#include <lmcons.h>
#include <lmserver.h>
#include <lmapibuf.h>
#include <winsock2.h>
#include <winsvc.h>
#include <svcguid.h>
#include <exception>
#include "DebugWPrintf.h"
#include "ErrorHandling.h"

#define MODULEPRIVATE static // so statics show up in VC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\lib\ntpbase.cpp ===
//--------------------------------------------------------------------
// NtpBase - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 4-16-99
//
// The basic message structure, definitions, and helper functions
// (See notes about time formats at end of file)

//--------------------------------------------------------------------
// precompiled headers
#include "pch.h" 

// local headers
#include "NtpBase.h"
#include "DebugWPrintf.h"

// inlines
#include "EndianSwap.inl"

//--------------------------------------------------------------------
// conversion constants
#define NTPTIMEOFFSET (0x014F373BFDE04000)
#define FIVETOTHESEVETH (0x001312D)

//--------------------------------------------------------------------
// global constants
const unsigned int NtpConst::nVersionNumber=3;
const unsigned int NtpConst::nPort=123;
const unsigned int NtpConst::nMaxStratum=15;
const signed int NtpConst::nMaxPollInverval=10;
const signed int NtpConst::nMinPollInverval=4; //6
const NtTimePeriod NtpConst::tpMaxClockAge={864000000000};
const NtTimePeriod NtpConst::tpMaxSkew={10000000};
const NtTimePeriod NtpConst::tpMaxDispersion={160000000};
const NtTimePeriod NtpConst::tpMinDispersion={100000};
const NtTimePeriod NtpConst::tpMaxDistance={10000000};
const unsigned int NtpConst::nMinSelectClocks=1;
const unsigned int NtpConst::nMaxSelectClocks=10;
const DWORD NtpConst::dwLocalRefId=0x4C434F4C; // "LOCL"


const unsigned int NtpReachabilityReg::nSize=8;
const NtTimeEpoch gc_teNtpZero={NTPTIMEOFFSET}; // convenient 'zero'
const NtpTimeEpoch gc_teZero={0}; // convenient 'zero'
const NtTimePeriod gc_tpZero={0}; // convenient 'zero'
const NtTimeOffset gc_toZero={0}; // convenient 'zero'

//--------------------------------------------------------------------
// convert from big-endian NTP-stye timestamp to little-endian NT-style timestamp
NtTimeEpoch NtTimeEpochFromNtpTimeEpoch(NtpTimeEpoch te) {
    NtTimeEpoch teRet;
    //return (qwNtpTime*(10**7)/(2**32))+NTPTIMEOFFSET
    // ==>
    //return (qwNtpTime*( 5**7)/(2**25))+NTPTIMEOFFSET
    // ==>
    //return ((qwNTPtime*FIVETOTHESEVETH)>>25)+NTPTIMEOFFSET;  
    // ==>
    // Note: 'After' division, we round (instead of truncate) the result for better precision
    unsigned __int64 qwNtpTime=EndianSwap(te.qw);
    unsigned __int64 qwTemp=((qwNtpTime&0x00000000FFFFFFFF)*FIVETOTHESEVETH)+0x0000000001000000; //rounding step: if 25th bit is set, round up;
    teRet.qw=(qwTemp>>25) + ((qwNtpTime&0xFFFFFFFF00000000)>>25)*FIVETOTHESEVETH + NTPTIMEOFFSET;
    return teRet;
}

//--------------------------------------------------------------------
// convert from little-endian NT-style timestamp to big-endian NTP-stye timestamp
NtpTimeEpoch NtpTimeEpochFromNtTimeEpoch(NtTimeEpoch te) {
    NtpTimeEpoch teRet;
    //return (qwNtTime-NTPTIMEOFFSET)*(2**32)/(10**7);
    // ==>
    //return (qwNtTime-NTPTIMEOFFSET)*(2**25)/(5**7);
    // ==>
    //return ((qwNtTime-NTPTIMEOFFSET)<<25)/FIVETOTHESEVETH);
    // ==>
    // Note: The high bit is lost (and assumed to be zero) but 
    //       it will not be set for another 29,000 years (around year 31587). No big loss.
    // Note: 'After' division, we truncate the result because the precision of NTP already excessive
    unsigned __int64 qwTemp=(te.qw-NTPTIMEOFFSET)<<1; 
    unsigned __int64 qwHigh=qwTemp>>8;
    unsigned __int64 qwLow=(qwHigh%FIVETOTHESEVETH)<<32 | (qwTemp&0x00000000000000FF)<<24;
    teRet.qw=EndianSwap(((qwHigh/FIVETOTHESEVETH)<<32) | (qwLow/FIVETOTHESEVETH));
    return teRet;
}

//--------------------------------------------------------------------
// convert from big-endian NTP-stye time interval to little-endian NT-style time interval
NtTimePeriod NtTimePeriodFromNtpTimePeriod(NtpTimePeriod tp) {
    NtTimePeriod tpRet;
    unsigned __int64 qwNtpTime=tp.dw;
    qwNtpTime=EndianSwap(qwNtpTime<<16);
    unsigned __int64 qwTemp=((qwNtpTime&0x00000000FFFFFFFF)*FIVETOTHESEVETH)+0x0000000001000000; //rounding step: if 25th bit is set, round up
    tpRet.qw=(qwTemp>>25) + ((qwNtpTime&0xFFFFFFFF00000000)>>25)*FIVETOTHESEVETH;
    return tpRet;
}

//--------------------------------------------------------------------
// convert from little-endian NT-style time interval to big-endian NTP-stye time interval
NtpTimePeriod NtpTimePeriodFromNtTimePeriod(NtTimePeriod tp) {
    NtpTimePeriod tpRet;
    unsigned __int64 qwTemp=(tp.qw)<<1; 
    unsigned __int64 qwHigh=qwTemp>>8;
    unsigned __int64 qwLow=(qwHigh%FIVETOTHESEVETH)<<32 | (qwTemp&0x00000000000000FF)<<24;
    qwTemp=EndianSwap(((qwHigh/FIVETOTHESEVETH)<<32) | (qwLow/FIVETOTHESEVETH));
    tpRet.dw=(unsigned __int32)(qwTemp>>16);
    return tpRet;
}

//--------------------------------------------------------------------
// convert from big-endian NTP-stye delay to little-endian NT-style delay
NtTimeOffset NtTimeOffsetFromNtpTimeOffset(NtpTimeOffset to) {
    NtTimeOffset toRet;
    if (to.dw&0x00000080) {
        to.dw=(signed __int32)EndianSwap((unsigned __int32)-(signed __int32)EndianSwap((unsigned __int32)to.dw));
        toRet.qw=-(signed __int64)(NtTimePeriodFromNtpTimePeriod(*(NtpTimePeriod*)&to).qw);
    } else {
        toRet.qw=(signed __int64)(NtTimePeriodFromNtpTimePeriod(*(NtpTimePeriod*)&to).qw);
    }
    return toRet;
}

//--------------------------------------------------------------------
// convert from little-endian NT-style delay to big-endian NTP-stye delay
NtpTimeOffset NtpTimeOffsetFromNtTimeOffset(NtTimeOffset to) {
    NtpTimeOffset toRet;
    if (to.qw<0) {
        to.qw=-to.qw;
        toRet.dw=(signed __int32)(NtpTimePeriodFromNtTimePeriod(*(NtTimePeriod*)&to).dw);
        toRet.dw=(signed __int32)EndianSwap((unsigned __int64)-(signed __int64)EndianSwap((unsigned __int32)toRet.dw));
    } else {
        toRet.dw=(signed __int32)(NtpTimePeriodFromNtTimePeriod(*(NtTimePeriod*)&to).dw);
    }
    return toRet;
}


//--------------------------------------------------------------------
// Print out the contents of an NTP packet
// If nDestinationTimestamp is zero, no round trip calculations will be done
void DumpNtpPacket(NtpPacket * pnpIn, NtTimeEpoch teDestinationTimestamp) {
    DebugWPrintf0(L"/-- NTP Packet:");

    DebugWPrintf0(L"\n| LeapIndicator: ");
    if (0==pnpIn->nLeapIndicator) {
        DebugWPrintf0(L"0 - no warning");
    } else if (1==pnpIn->nLeapIndicator) {
        DebugWPrintf0(L"1 - last minute has 61 seconds");
    } else if (2==pnpIn->nLeapIndicator) {
        DebugWPrintf0(L"2 - last minute has 59 seconds");
    } else {
        DebugWPrintf0(L"3 - not synchronized");
    }

    DebugWPrintf1(L";  VersionNumber: %u", pnpIn->nVersionNumber);

    DebugWPrintf0(L";  Mode: ");
    if (0==pnpIn->nMode) {
        DebugWPrintf0(L"0 - Reserved");
    } else if (1==pnpIn->nMode) {
        DebugWPrintf0(L"1 - SymmetricActive");
    } else if (2==pnpIn->nMode) {
        DebugWPrintf0(L"2 - SymmetricPassive");
    } else if (3==pnpIn->nMode) {
        DebugWPrintf0(L"3 - Client");
    } else if (4==pnpIn->nMode) {
        DebugWPrintf0(L"4 - Server");
    } else if (5==pnpIn->nMode) {
        DebugWPrintf0(L"5 - Broadcast");
    } else if (6==pnpIn->nMode) {
        DebugWPrintf0(L"6 - Control");
    } else {
        DebugWPrintf0(L"7 - PrivateUse");
    }

    DebugWPrintf1(L";  LiVnMode: 0x%02X", ((BYTE*)pnpIn)[0]);

    DebugWPrintf1(L"\n| Stratum: %u - ", pnpIn->nStratum);
    if (0==pnpIn->nStratum) {
        DebugWPrintf0(L"unspecified or unavailable");
    } else if (1==pnpIn->nStratum) {
        DebugWPrintf0(L"primary reference (syncd by radio clock)");
    } else if (pnpIn->nStratum<16) {
        DebugWPrintf0(L"secondary reference (syncd by (S)NTP)");
    } else {
        DebugWPrintf0(L"reserved");
    }

    DebugWPrintf1(L"\n| Poll Interval: %d - ", pnpIn->nPollInterval);
    if (pnpIn->nPollInterval<4 || pnpIn->nPollInterval>14) {
        if (0==pnpIn->nPollInterval) {
            DebugWPrintf0(L"unspecified");
        } else {
            DebugWPrintf0(L"out of valid range");
        }
    } else {
        int nSec=1<<pnpIn->nPollInterval;
        DebugWPrintf1(L"%ds", nSec);
    }

    DebugWPrintf1(L";  Precision: %d - ", pnpIn->nPrecision);
    if (pnpIn->nPrecision>-2 || pnpIn->nPrecision<-31) {
        if (0==pnpIn->nPollInterval) {
            DebugWPrintf0(L"unspecified");
        } else {
            DebugWPrintf0(L"out of valid range");
        }
    } else {
        WCHAR * wszUnit=L"s";
        double dTickInterval=1.0/(1<<(-pnpIn->nPrecision));
        if (dTickInterval<1) {
            dTickInterval*=1000;
            wszUnit=L"ms";
        }
        if (dTickInterval<1) {
            dTickInterval*=1000;
            wszUnit=L"s"; // shows up as s on console
        }
        if (dTickInterval<1) {
            dTickInterval*=1000;
            wszUnit=L"ns";
        }
        DebugWPrintf2(L"%g%s per tick", dTickInterval, wszUnit);
    }

    DebugWPrintf0(L"\n| RootDelay: ");
    {
        DWORD dwTemp=EndianSwap((unsigned __int32)pnpIn->toRootDelay.dw);
        DebugWPrintf2(L"0x%04X.%04Xs", dwTemp>>16, dwTemp&0x0000FFFF);
        if (0==dwTemp) {
            DebugWPrintf0(L" - unspecified");
        } else {
            DebugWPrintf1(L" - %gs", ((double)((signed __int32)dwTemp))/0x00010000);
        }
    }

    DebugWPrintf0(L";  RootDispersion: ");
    {
        DWORD dwTemp=EndianSwap(pnpIn->tpRootDispersion.dw);
        DebugWPrintf2(L"0x%04X.%04Xs", dwTemp>>16, dwTemp&0x0000FFFF);
        if (0==dwTemp) {
            DebugWPrintf0(L" - unspecified");
        } else {
            DebugWPrintf1(L" - %gs", ((double)dwTemp)/0x00010000);
        }
    }

    DebugWPrintf0(L"\n| ReferenceClockIdentifier: ");
    {
        DWORD dwTemp=EndianSwap(pnpIn->refid.nTransmitTimestamp);
        DebugWPrintf1(L"0x%08X", dwTemp);
        if (0==dwTemp) {
            DebugWPrintf0(L" - unspecified");
        } else if (0==pnpIn->nStratum || 1==pnpIn->nStratum) {
            char szId[5];
            szId[0]=pnpIn->refid.rgnName[0];
            szId[1]=pnpIn->refid.rgnName[1];
            szId[2]=pnpIn->refid.rgnName[2];
            szId[3]=pnpIn->refid.rgnName[3];
            szId[4]='\0';
            DebugWPrintf1(L" - source name: \"%S\"", szId);
        } else if (pnpIn->nVersionNumber<4) {
            DebugWPrintf4(L" - source IP: %d.%d.%d.%d", 
                pnpIn->refid.rgnIpAddr[0], pnpIn->refid.rgnIpAddr[1],
                pnpIn->refid.rgnIpAddr[2], pnpIn->refid.rgnIpAddr[3]);
        } else {
            DebugWPrintf1(L" - last reference timestamp fraction: %gs", ((double)dwTemp)/(4294967296.0));
        }
    }
    
    DebugWPrintf0(L"\n| ReferenceTimestamp:   ");
    DumpNtpTimeEpoch(pnpIn->teReferenceTimestamp);

    DebugWPrintf0(L"\n| OriginateTimestamp:   ");
    DumpNtpTimeEpoch(pnpIn->teOriginateTimestamp);

    DebugWPrintf0(L"\n| ReceiveTimestamp:     ");
    DumpNtpTimeEpoch(pnpIn->teReceiveTimestamp);

    DebugWPrintf0(L"\n| TransmitTimestamp:    ");
    DumpNtpTimeEpoch(pnpIn->teTransmitTimestamp);

    if (0!=teDestinationTimestamp.qw) {
        DebugWPrintf0(L"\n>-- Non-packet info:");

        NtTimeEpoch teOriginateTimestamp=NtTimeEpochFromNtpTimeEpoch(pnpIn->teOriginateTimestamp);
        NtTimeEpoch teReceiveTimestamp=NtTimeEpochFromNtpTimeEpoch(pnpIn->teReceiveTimestamp);
        NtTimeEpoch teTransmitTimestamp=NtTimeEpochFromNtpTimeEpoch(pnpIn->teTransmitTimestamp);

        DebugWPrintf0(L"\n| DestinationTimestamp: ");
        {
            NtpTimeEpoch teNtpTemp=NtpTimeEpochFromNtTimeEpoch(teDestinationTimestamp);
            NtTimeEpoch teNtTemp=NtTimeEpochFromNtpTimeEpoch(teNtpTemp);
            DumpNtpTimeEpoch(teNtpTemp);
            unsigned __int32 nConversionError;
            if (teNtTemp.qw>teDestinationTimestamp.qw) {
                nConversionError=(unsigned __int32)(teNtTemp-teDestinationTimestamp).qw;
            } else {
                nConversionError=(unsigned __int32)(teDestinationTimestamp-teNtTemp).qw;
            }
            if (0!=nConversionError) {
                DebugWPrintf1(L" - CnvErr:%u00ns", nConversionError);
            }
        }

        DebugWPrintf0(L"\n| RoundtripDelay: ");
        {
            NtTimeOffset toRoundtripDelay=
                (teDestinationTimestamp-teOriginateTimestamp)
                - (teTransmitTimestamp-teReceiveTimestamp);
            DebugWPrintf1(L"%I64d00ns", toRoundtripDelay.qw);
        }

        DebugWPrintf0(L"\n| LocalClockOffset: ");
        {
            NtTimeOffset toLocalClockOffset=
                (teReceiveTimestamp-teOriginateTimestamp)
                + (teTransmitTimestamp-teDestinationTimestamp);
            toLocalClockOffset/=2;
            DebugWPrintf1(L"%I64d00ns", toLocalClockOffset.qw);
            unsigned __int64 nAbsOffset;
            if (toLocalClockOffset.qw<0) {
                nAbsOffset=(unsigned __int64)(-toLocalClockOffset.qw);
            } else {
                nAbsOffset=(unsigned __int64)(toLocalClockOffset.qw);
            }
            DWORD dwNanoSecs=(DWORD)(nAbsOffset%10000000);
            nAbsOffset/=10000000;
            DWORD dwSecs=(DWORD)(nAbsOffset%60);
            nAbsOffset/=60;
            DebugWPrintf3(L" - %I64u:%02u.%07u00s", nAbsOffset, dwSecs, dwNanoSecs);
        }
    } // <- end if (0!=nDestinationTimestamp)

    DebugWPrintf0(L"\n\\--\n");
}

//--------------------------------------------------------------------
// Print out an NTP-style time
void DumpNtpTimeEpoch(NtpTimeEpoch te) {
    DebugWPrintf1(L"0x%016I64X", EndianSwap(te.qw));
    if (0==te.qw) {
        DebugWPrintf0(L" - unspecified");
    } else {
        DumpNtTimeEpoch(NtTimeEpochFromNtpTimeEpoch(te));
    }
}

//--------------------------------------------------------------------
// Print out an NT-style time
void DumpNtTimeEpoch(NtTimeEpoch te) {
    DebugWPrintf1(L" - %I64d00ns", te.qw);

    DWORD dwNanoSecs=(DWORD)(te.qw%10000000);
    te.qw/=10000000;
    DWORD dwSecs=(DWORD)(te.qw%60);
    te.qw/=60;
    DWORD dwMins=(DWORD)(te.qw%60);
    te.qw/=60;
    DWORD dwHours=(DWORD)(te.qw%24);
    DWORD dwDays=(DWORD)(te.qw/24);
    DebugWPrintf5(L" - %u %02u:%02u:%02u.%07us", dwDays, dwHours, dwMins, dwSecs, dwNanoSecs);
}

//--------------------------------------------------------------------
void DumpNtTimePeriod(NtTimePeriod tp) {
    DebugWPrintf2(L"%02I64u.%07I64us", tp.qw/10000000,tp.qw%10000000);
}

//--------------------------------------------------------------------
void DumpNtTimeOffset(NtTimeOffset to) {
    NtTimePeriod tp;
    if (to.qw<0) {
        DebugWPrintf0(L"-");
        tp.qw=(unsigned __int64)-to.qw;
    } else {
        DebugWPrintf0(L"+");
        tp.qw=(unsigned __int64)to.qw;
    }
    DumpNtTimePeriod(tp);
}

//--------------------------------------------------------------------
// retrieve the system time
NtTimeEpoch GetCurrentSystemNtTimeEpoch(void) {
    NtTimeEpoch teRet;
    FILETIME ft;
    GetSystemTimeAsFileTime(&ft);
    teRet.qw=ft.dwLowDateTime | (((unsigned __int64)ft.dwHighDateTime)<<32);
    return teRet;
}

/*--------------------------------------------------------------------

Time formats:
    NT time:  (10^-7)s intervals since (0h 1-Jan 1601)
    NTP time: (2^-32)s intervals since (0h 1-Jan 1900)

Offset:
    109207 days between (0h 1-Jan 1601) and (0h 1-Jan 1900) 
    == 109207*24*60*60*1E7
    == 94,354,848,000,000,000 NT intervals (0x014F 373B FDE0 4000)

When will NTP time overflow?
    Rollover: 4294967296 s 
    (0h 1-Jan 2036) = 49673 days.
    in 2036, have 3220096 seconds left = 37 days 6 hours 28 minutes 16 seconds.
    4294967296 s 
    4291747200 s = 49673 days, remainder == 3220096 s
       3196800 s = 37 days               ==   23296 s
         21600 s = 6 hours               ==    1696 s
          1680 s = 28 minutes            ==      16 s
            16 s = 16 seconds            ==       0 s

    Therefore:
    (06:28:16 7-Feb 2036 UTC)==(00:00:00 1-Jan 1900 UTC)

    What does that look like in NT time?
    (06:28:16 7-Feb 2036 UTC):
    94,354,848,000,000,000 + 42,949,672,960,000,000 = 137,304,520,960,000,000 (0x01E7 CDBB FDE0 4000)
    No problem.

When will NT time overflow?
    Rollover: 18,446,744,073,70|9,551,616 00ns

    (0h 1-Jan 60,056) = 21350250 days.
    1844674407370 s
    1844661600000 s = 21350250 days == 12807370
         12787200 s = 148 days      ==    20170
            18000 s = 5 hours       ==     2170
             2160 s = 36 minutes    ==       10
               10 s = 10 seconds    ==        0

  Therefore:
    (05:36:10.9551616 29-May 60056)==(00:00:00 1-Jan 1601)


--------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\lib\myautoptr.h ===
//--------------------------------------------------------------------
// Reference-counted pointer implementation. 
// Copyright (C) Microsoft Corporation, 2000-2001
//
// Created by: Duncan Bryce (duncanb), 12-09-2000
//


#ifndef _MY_AUTO_PTR_H_
#define _MY_AUTO_PTR_H_ 1

template <class T>
class Ref { 
public:
    Ref(T *pT) : m_pT(pT), m_nRefCount(NULL == pT ? 0 : 1) { };
    ~Ref() { delete (m_pT); } 

    volatile long m_nRefCount; 
    T * m_pT; 
private:
    Ref(); 
    Ref(const Ref & rhs); 
    Ref & operator=(const Ref & rhs); 
}; 
    

//
// The AutoPtr class implements a reference-counting wrapper for 
// pointer types.  
//
// The requirements for use are:
//     * class T must implement operator == 
//     * class T must implement operator < 
//
// Furthermore, for an AutoPtr, a, such that NULL == a, none of the operations
// in this class are valid except 
//     * operator!=
//     * operator==
//
template <class T> 
class AutoPtr { 
public:
    AutoPtr(T * pT = NULL) { 
        if (NULL == pT) { 
            m_pRef = NULL; 
        } else { 
            m_pRef = new Ref<T>(pT); 
            if (NULL == m_pRef) { 
                // Delete pT since we can't create a reference to it, 
                // and the caller is not going to delete it. 
                delete (pT);
            }
        }
    } 

    AutoPtr(const AutoPtr & rhs) : m_pRef(rhs.m_pRef) { 
        if (NULL != m_pRef) { 
            InterlockedIncrement(&m_pRef->m_nRefCount); 
        }
    }
        
    ~AutoPtr() {  
        if (NULL != m_pRef) { 
            if (0 == InterlockedDecrement(&m_pRef->m_nRefCount)) { 
                delete (m_pRef); 
            }
        }
    }

    AutoPtr & operator=(const AutoPtr & rhs) { 
        if (m_pRef == rhs.m_pRef) { 
            return *this;
        }

        if (NULL != m_pRef) { 
            if (0 == InterlockedDecrement(&m_pRef->m_nRefCount)) { 
                delete (m_pRef); 
            }
        }

        m_pRef = rhs.m_pRef; 
        
        if (NULL != rhs.m_pRef) { 
            InterlockedIncrement(&m_pRef->m_nRefCount);
        }

        return *this; 
    }
            
    //
    // If both this and rhs reference non-NULL pointers,
    // forward the == operation to the == operator in class T.  
    // Otherwise, return true iff both this AutoPtr and rhs reference
    // the same pointer. 
    // 
    BOOL operator==(const AutoPtr & rhs) { 
        if (NULL == m_pRef || NULL == rhs.m_pRef) { 
            return m_pRef == rhs.m_pRef;
        } else { 
            return m_pRef->m_pT->operator==(*(rhs.m_pRef->m_pT)); 
        }
    }

    // 
    // If both this AutoPtr and rhs point to non-NULL pointers, 
    // forward the < operation to the < operator in class T.  
    // Otherwise, operator < returns TRUE iff this AutoPtr pointers
    // to a non-NULL pointer, but rhs points to a NULL pointer.  
    // 
    BOOL operator<(const AutoPtr & rhs) { 
        if (NULL == m_pRef || NULL == rhs.m_pRef) { 
            return  NULL != m_pRef && NULL == rhs.m_pRef;
        } else { 
            return m_pRef->m_pT->operator<(*(rhs.m_pRef->m_pT)); 
        }
    }

    T * operator->() const { return m_pRef->m_pT; }
    T & operator*() const { return *m_pRef->m_pT; }
    
    //
    // Overloading == and != to allow AutoPtrs to be NULL checked transparently.
    //
    // Note, however, that this allows some code to compile which 
    // might not make sense:
    //
    //     LPWSTR      pwsz; 
    //     NtpPeerPtr  npp; 
    //     if (npp == pwsz) { // no compile error
    //         ...
    //
    friend BOOL operator==(const AutoPtr & ap, const void * pv) { 
        return (NULL == ap.m_pRef && NULL == pv) ||(ap.m_pRef->m_pT == pv); 
    }

    friend BOOL operator==(const void * pv, const AutoPtr & ap) { 
        return ap == pv; 
    }

    friend BOOL operator!=(const AutoPtr & ap, const void * pv) { 
        return !(ap == pv);
    }

    friend BOOL operator!=(const void * pv, const AutoPtr & ap) { 
        return !(ap == pv); 
    }

private:
    Ref<T> *m_pRef; 
};


#endif // #ifndef _MY_AUTO_PTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\lib\pinglib.cpp ===
//--------------------------------------------------------------------
// PingLib - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 10-8-99
//
// Various ways of pinging a server
//

#include "pch.h" // precompiled headers

#include <ipexport.h>
#include <icmpapi.h>
#include <DcInfo.h>
#include "NtpBase.h"
#include "EndianSwap.inl"


//####################################################################
// OLD CODE
#if 0
//--------------------------------------------------------------------
MODULEPRIVATE HRESULT LookupServer(IN WCHAR * wszServerName, OUT sockaddr * psaOut, IN int nAddrSize) {
    HRESULT hr;
    DWORD dwDataLen;
    SOCKET_ADDRESS * psaFound;

    // pointers that must be cleaned up
    HANDLE hSearch=INVALID_HANDLE_VALUE;
    WSAQUERYSETW * pqsResult=NULL;

    DebugWPrintf1(L"Looking up server \"%s\":\n", wszServerName);

    // initialize the search
                //  const static GUID guidHostAddressByName = SVCID_INET_HOSTADDRBYNAME;
    AFPROTOCOLS apInetUdp={AF_INET, IPPROTO_UDP};
    GUID guidNtp=SVCID_NTP_UDP;
    WSAQUERYSETW qsSearch;
    ZeroMemory(&qsSearch, sizeof(qsSearch));
    qsSearch.dwSize=sizeof(qsSearch);
    qsSearch.lpszServiceInstanceName=wszServerName;
    qsSearch.lpServiceClassId=&guidNtp;
    qsSearch.dwNameSpace=NS_ALL;
    qsSearch.dwNumberOfProtocols=1;
    qsSearch.lpafpProtocols=&apInetUdp;

    if (SOCKET_ERROR==WSALookupServiceBegin(&qsSearch, LUP_RETURN_ADDR/*flags*/, &hSearch)) {
        _JumpLastError(hr, error, "WSALookupServiceBegin");
    }

    // get the buffer size for the first value
    dwDataLen=1;
    _Verify(SOCKET_ERROR==WSALookupServiceNext(hSearch, LUP_RETURN_ADDR/*flags*/, &dwDataLen, &qsSearch), hr, error);
    if (WSAEFAULT!=GetLastError()) {
        _JumpLastError(hr, error, "WSALookupServiceNext");
    }

    // allocate the buffer
    pqsResult=reinterpret_cast<WSAQUERYSETW *>(LocalAlloc(LMEM_FIXED, dwDataLen));
    _JumpIfOutOfMemory(hr, error, pqsResult);
    
    // retrieve the first value
    if (SOCKET_ERROR==WSALookupServiceNext(hSearch, LUP_RETURN_ADDR/*flags*/, &dwDataLen, pqsResult)) {
        _JumpLastError(hr, error, "WSALookupServiceNext");
    }
    _Verify(pqsResult->dwNumberOfCsAddrs>0, hr, error);
    if (pqsResult->dwNumberOfCsAddrs>1) {
        DebugWPrintf1(L"WSALookupServiceNextW returned %d addresses. Using first one.\n", pqsResult->dwNumberOfCsAddrs);
    }
    psaFound=&(pqsResult->lpcsaBuffer[0].RemoteAddr);
    _Verify(nAddrSize==psaFound->iSockaddrLength, hr, error);

    *psaOut=*(psaFound->lpSockaddr);
    DumpSockaddr(psaOut, nAddrSize);

    hr=S_OK;

error:
    if (NULL!=pqsResult) {
        LocalFree(pqsResult);
    }
    if (INVALID_HANDLE_VALUE!=hSearch) {
        if (SOCKET_ERROR==WSALookupServiceEnd(hSearch)) {
            _IgnoreLastError("WSALookupServiceEnd");
        }
    }

    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetSample(WCHAR * wszServerName, TpcGetSamplesArgs * ptgsa) {
    HRESULT hr;
    NtpPacket npPacket;
    NtTimeEpoch teDestinationTimestamp;
    unsigned int nIpAddrs;

    // must be cleaned up
    in_addr * rgiaLocalIpAddrs=NULL;
    in_addr * rgiaRemoteIpAddrs=NULL;

    hr=MyGetIpAddrs(wszServerName, &rgiaLocalIpAddrs, &rgiaRemoteIpAddrs, &nIpAddrs, NULL);
    _JumpIfError(hr, error, "MyGetIpAddrs");
    _Verify(0!=nIpAddrs, hr, error);

    hr=MyNtpPing(&(rgiaRemoteIpAddrs[0]), 500, &npPacket, &teDestinationTimestamp);
    _JumpIfError(hr, error, "MyNtpPing");

    {
        NtTimeEpoch teOriginateTimestamp=NtTimeEpochFromNtpTimeEpoch(npPacket.teOriginateTimestamp);
        NtTimeEpoch teReceiveTimestamp=NtTimeEpochFromNtpTimeEpoch(npPacket.teReceiveTimestamp);
        NtTimeEpoch teTransmitTimestamp=NtTimeEpochFromNtpTimeEpoch(npPacket.teTransmitTimestamp);
        NtTimeOffset toRoundtripDelay=
            (teDestinationTimestamp-teOriginateTimestamp)
              - (teTransmitTimestamp-teReceiveTimestamp);
        NtTimeOffset toLocalClockOffset=
            (teReceiveTimestamp-teOriginateTimestamp)
            + (teTransmitTimestamp-teDestinationTimestamp);
        toLocalClockOffset/=2;
        NtTimePeriod tpClockTickSize;
        g_npstate.tpsc.pfnGetTimeSysInfo(TSI_ClockTickSize, &tpClockTickSize.qw);


        TimeSample * pts=(TimeSample *)ptgsa->pbSampleBuf;
        pts->dwSize=sizeof(TimeSample);
        pts->dwRefid=npPacket.refid.value;
        pts->toOffset=toLocalClockOffset.qw;
        pts->toDelay=(toRoundtripDelay
            +NtTimeOffsetFromNtpTimeOffset(npPacket.toRootDelay)
            ).qw;
        pts->tpDispersion=(tpClockTickSize
            +NtpConst::timesMaxSkewRate(abs(teDestinationTimestamp-teOriginateTimestamp))
            +NtTimePeriodFromNtpTimePeriod(npPacket.tpRootDispersion)
            ).qw;
        g_npstate.tpsc.pfnGetTimeSysInfo(TSI_TickCount, &(pts->nSysTickCount));
        g_npstate.tpsc.pfnGetTimeSysInfo(TSI_PhaseOffset, &(pts->nSysPhaseOffset));
        pts->nStratum=npPacket.nStratum;
        pts->nLeapFlags=npPacket.nLeapIndicator;

        ptgsa->dwSamplesAvailable=1;
        ptgsa->dwSamplesReturned=1;
    }

    hr=S_OK;
error:
    if (NULL!=rgiaLocalIpAddrs) {
        LocalFree(rgiaLocalIpAddrs);
    }
    if (NULL!=rgiaRemoteIpAddrs) {
        LocalFree(rgiaRemoteIpAddrs);
    }
    return hr;
}


#endif

//####################################################################
// module public

//--------------------------------------------------------------------
HRESULT MyIcmpPing(in_addr * piaTarget, DWORD dwTimeout, DWORD * pdwResponseTime) {
    HRESULT hr;
    IPAddr ipaddrDest=piaTarget->S_un.S_addr;
    BYTE rgbData[8]={'a','b','c','d','e','f','g','h'};
    BYTE rgbResponse[1024];
    DWORD dwDataSize;
        
    // must be cleaned up
    HANDLE hIcmp=NULL;

    // open a handle for icmp access
    hIcmp=IcmpCreateFile();
    if (NULL==hIcmp) {
        _JumpLastError(hr, error, "IcmpCreateFile");
    }

    // ping
    ZeroMemory(rgbResponse, sizeof(rgbResponse));
    dwDataSize=IcmpSendEcho(hIcmp, ipaddrDest, rgbData, 8, NULL, rgbResponse, sizeof(rgbResponse), dwTimeout);
    if (0==dwDataSize) {
        _JumpLastError(hr, error, "IcmpSendEcho");
    }

    *pdwResponseTime=((icmp_echo_reply *)rgbResponse)->RoundTripTime;

    hr=S_OK;
error:
    if (NULL!=hIcmp) {
        IcmpCloseHandle(hIcmp);
    }
    return hr;
}

//--------------------------------------------------------------------
HRESULT MyNtpPing(in_addr * piaTarget, DWORD dwTimeout, NtpPacket * pnpPacket, NtTimeEpoch * pteDestinationTimestamp) {
    HRESULT hr;
    sockaddr saServer;
    int nBytesRecvd;
    DWORD dwWaitResult;

    // must be cleaned up
    SOCKET sTest=INVALID_SOCKET;
    HANDLE hDataAvailEvent=NULL;

    // create a socket
    sTest=socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (INVALID_SOCKET==sTest) {
        _JumpLastError(hr, error, "socket");
    }

    // fix the destination address
    {
        sockaddr_in & saiServer=*(sockaddr_in *)(&saServer);
        saiServer.sin_port=EndianSwap((unsigned __int16)NtpConst::nPort);
        saiServer.sin_family=AF_INET;
        saiServer.sin_addr.S_un.S_addr=piaTarget->S_un.S_addr;
    }

    // connect the socket to the peer
    if (SOCKET_ERROR==connect(sTest, &saServer, sizeof(saServer))) {
        _JumpLastError(hr, error, "connect");
    }

    // send an NTP packet
    //DebugWPrintf1(L"Sending %d byte SNTP packet.\n", sizeof(NtpPacket));
    ZeroMemory(pnpPacket, sizeof(NtpPacket));
    pnpPacket->nMode=e_Client;
    pnpPacket->nVersionNumber=1;
    pnpPacket->teTransmitTimestamp=NtpTimeEpochFromNtTimeEpoch(GetCurrentSystemNtTimeEpoch());
    if (SOCKET_ERROR==send(sTest, reinterpret_cast<char *>(pnpPacket), sizeof(NtpPacket), 0/*flags*/)) {
        _JumpLastError(hr, error, "send");
    }

    // create the data available event
    hDataAvailEvent=CreateEvent(NULL /*security*/, FALSE /*auto-reset*/, FALSE /*nonsignaled*/, NULL /*name*/);
    if (NULL==hDataAvailEvent) {
        _JumpLastError(hr, error, "CreateEvent");
    }

    // bind the event to this socket
    if (SOCKET_ERROR==WSAEventSelect(sTest, hDataAvailEvent, FD_READ)) {
        _JumpLastError(hr, error, "WSAEventSelect");
    }

    // listen on the socket
    //DebugWPrintf1(L"Waiting for response for %ums...\n", dwTimeout);
    dwWaitResult=WaitForSingleObject(hDataAvailEvent, dwTimeout);
    if (WAIT_FAILED==dwWaitResult) {
        _JumpLastError(hr, error, "WaitForSingleObject");
    } else if (WAIT_TIMEOUT==dwWaitResult) {
        //DebugWPrintf0(L"No response.\n");
        hr=HRESULT_FROM_WIN32(ERROR_TIMEOUT);
        _JumpError(hr, error, "WaitForSingleObject");
    } else {

        // retrieve the data
        nBytesRecvd=recv(sTest, reinterpret_cast<char *>(pnpPacket), sizeof(NtpPacket), 0/*flags*/);
        *pteDestinationTimestamp=GetCurrentSystemNtTimeEpoch();
        if (SOCKET_ERROR==nBytesRecvd) {
            _JumpLastError(hr, error, "recv");
        }
        //DebugWPrintf2(L"Recvd %d of %d bytes.\n", nBytesRecvd, sizeof(NtpPacket));
        //DumpNtpPacket(&npPacket,teDestinationTimestamp);
    }

    // done
    hr=S_OK;

error:
    if (INVALID_SOCKET!=sTest) {
        if (SOCKET_ERROR==closesocket(sTest)) {
            _IgnoreLastError("closesocket");
        }
    }
    if (NULL!=hDataAvailEvent) {
        CloseHandle(hDataAvailEvent);
    }

    return hr;
}

//--------------------------------------------------------------------
HRESULT MyGetIpAddrs(const WCHAR * wszDnsName, in_addr ** prgiaLocalIpAddrs, in_addr ** prgiaRemoteIpAddrs, unsigned int *pnIpAddrs, bool * pbRetry) {
    AFPROTOCOLS    apInetUdp          = { AF_INET, IPPROTO_UDP }; 
    bool           bRetry             = FALSE; 
    DWORD          dwDataLen; 
    GUID           guidNtp            = SVCID_NTP_UDP; 
    HRESULT        hr; 
    HANDLE         hSearch            = INVALID_HANDLE_VALUE; 
    in_addr       *rgiaLocalIpAddrs   = NULL; 
    in_addr       *rgiaRemoteIpAddrs  = NULL; 
    WSAQUERYSETW   qsSearch; 
    WSAQUERYSETW  *pqsResult          = NULL; 

    ZeroMemory(&qsSearch, sizeof(qsSearch)); 

    // initialize the search
    qsSearch.dwSize                   = sizeof(qsSearch); 
    qsSearch.lpszServiceInstanceName  = const_cast<WCHAR *>(wszDnsName); 
    qsSearch.lpServiceClassId         = &guidNtp; 
    qsSearch.dwNameSpace              = NS_ALL; 
    qsSearch.dwNumberOfProtocols      = 1; 
    qsSearch.lpafpProtocols           = &apInetUdp; 

    // begin the search
    if (SOCKET_ERROR == WSALookupServiceBegin(&qsSearch, LUP_RETURN_ADDR/*flags*/, &hSearch)) { 
        hr = HRESULT_FROM_WIN32(WSAGetLastError()); 
        _JumpError(hr, error, "WSALookupServiceBegin"); 
    }

    // retrieve the result set
    dwDataLen = 5*1024; 
    pqsResult = (WSAQUERYSETW *)LocalAlloc(LPTR, dwDataLen); 
    _JumpIfOutOfMemory(hr, error, pqsResult); 

    if (SOCKET_ERROR == WSALookupServiceNext(hSearch, LUP_RETURN_ADDR/*flags*/, &dwDataLen, pqsResult)) { 
        hr = HRESULT_FROM_WIN32(WSAGetLastError()); 
        _JumpError(hr, error, "WSALookupServiceNext"); 
    }
    _Verify(0 != pqsResult->dwNumberOfCsAddrs, hr, error); 

    // allocate room for the IP addresses
    rgiaLocalIpAddrs = (in_addr *)LocalAlloc(LPTR, sizeof(in_addr) * pqsResult->dwNumberOfCsAddrs);
    _JumpIfOutOfMemory(hr, error, rgiaLocalIpAddrs);
    rgiaRemoteIpAddrs = (in_addr *)LocalAlloc(LPTR, sizeof(in_addr) * pqsResult->dwNumberOfCsAddrs);
    _JumpIfOutOfMemory(hr, error, rgiaRemoteIpAddrs);

    // copy the IP addresses
    for (unsigned int nIndex = 0; nIndex < pqsResult->dwNumberOfCsAddrs; nIndex++) {
        // copy local
        _Verify(sizeof(sockaddr) == pqsResult->lpcsaBuffer[nIndex].LocalAddr.iSockaddrLength, hr, error);
        _Verify(AF_INET == pqsResult->lpcsaBuffer[nIndex].LocalAddr.lpSockaddr->sa_family, hr, error);
        rgiaLocalIpAddrs[nIndex].S_un.S_addr = ((sockaddr_in *)(pqsResult->lpcsaBuffer[nIndex].LocalAddr.lpSockaddr))->sin_addr.S_un.S_addr;
        // copy remote
        _Verify(sizeof(sockaddr) == pqsResult->lpcsaBuffer[nIndex].RemoteAddr.iSockaddrLength, hr, error);
        _Verify(AF_INET == pqsResult->lpcsaBuffer[nIndex].RemoteAddr.lpSockaddr->sa_family, hr, error);
        rgiaRemoteIpAddrs[nIndex].S_un.S_addr = ((sockaddr_in *)(pqsResult->lpcsaBuffer[nIndex].RemoteAddr.lpSockaddr))->sin_addr.S_un.S_addr;
    }

    // Assign out params:
    if (NULL != prgiaLocalIpAddrs)  { *prgiaLocalIpAddrs   = rgiaLocalIpAddrs; }
    if (NULL != prgiaRemoteIpAddrs) { *prgiaRemoteIpAddrs  = rgiaRemoteIpAddrs; }
    if (NULL != pbRetry)            { *pbRetry             = bRetry; }
    if (NULL != pnIpAddrs)          { *pnIpAddrs           = pqsResult->dwNumberOfCsAddrs; }
    rgiaLocalIpAddrs     = NULL;
    rgiaRemoteIpAddrs    = NULL; 

    hr = S_OK; 
 error:
    if (NULL != pbRetry) { 
        // Probably shouldn't be removing manual peers.  Always retry. 
        *pbRetry = true; 
    }
    if (NULL != rgiaLocalIpAddrs) {
        LocalFree(rgiaLocalIpAddrs);
    }
    if (NULL != rgiaRemoteIpAddrs) {
        LocalFree(rgiaRemoteIpAddrs);
    }
    if (NULL != pqsResult) { 
        LocalFree(pqsResult); 
    }
    if (INVALID_HANDLE_VALUE != hSearch) { 
        if (SOCKET_ERROR == WSALookupServiceEnd(hSearch)) {
            HRESULT hr2 = HRESULT_FROM_WIN32(WSAGetLastError());
            _IgnoreError(hr2, "WSALookupServiceEnd");
        }
    }

    return hr; 
}

//--------------------------------------------------------------------
// initialize the socket layer
HRESULT OpenSocketLayer(void) {
    HRESULT hr;
    int nRetVal;

    WSADATA wdWinsockInfo;
    nRetVal=WSAStartup(0x0002/*version*/, &wdWinsockInfo);
    if (0!=nRetVal) {
        hr=HRESULT_FROM_WIN32(nRetVal);
        _JumpError(hr, error, "WSAStartup");
    }
    //DebugWPrintf4(L"Socket layer initialized. v:0x%04X hv:0x%04X desc:\"%S\" status:\"%S\"\n", 
    //    wdWinsockInfo.wVersion, wdWinsockInfo.wHighVersion, wdWinsockInfo.szDescription,
    //    wdWinsockInfo.szSystemStatus);

    hr=S_OK;
error:
    return hr;
}
    

//--------------------------------------------------------------------
// close down the socket layer
HRESULT CloseSocketLayer(void) {
    HRESULT hr;
    int nRetVal;

    nRetVal=WSACleanup();
    if (SOCKET_ERROR==nRetVal) {
        _JumpLastError(hr, error, "WSACleanup");
    }
    //DebugWPrintf0(L"Socket layer cleanup successful\n");

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT GetSystemErrorString(HRESULT hrIn, WCHAR ** pwszError) {
    HRESULT hr=S_OK;
    DWORD dwResult;
    WCHAR * rgParams[2]={
        NULL,
        (WCHAR *)(ULONG_PTR)hrIn
    };

    // must be cleaned up
    WCHAR * wszErrorMessage=NULL;
    WCHAR * wszFullErrorMessage=NULL;

    // initialize input params
    *pwszError=NULL;

    // get the message from the system
    dwResult=FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 
        NULL/*ignored*/, hrIn, 0/*language*/, (WCHAR *)&wszErrorMessage, 0/*min-size*/, NULL/*valist*/);
    if (0==dwResult) {
        if (ERROR_MR_MID_NOT_FOUND==GetLastError()) {
            rgParams[0]=L"";
        } else {
            _JumpLastError(hr, error, "FormatMessage");
        }
    } else {
        rgParams[0]=wszErrorMessage;

        // trim off \r\n if it exists
        if (L'\r'==wszErrorMessage[wcslen(wszErrorMessage)-2]) {
            wszErrorMessage[wcslen(wszErrorMessage)-2]=L'\0';
        }
    }

    // add the error number
    dwResult=FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY, 
        L"%1 (0x%2!08X!)", 0, 0/*language*/, (WCHAR *)&wszFullErrorMessage, 0/*min-size*/, (va_list *)rgParams);
    if (0==dwResult) {
        _JumpLastError(hr, error, "FormatMessage");
    }

    // success
    *pwszError=wszFullErrorMessage;
    wszFullErrorMessage=NULL;
    hr=S_OK;
error:
    if (NULL!=wszErrorMessage) {
        LocalFree(wszErrorMessage);
    }
    if (NULL!=wszFullErrorMessage) {
        LocalFree(wszFullErrorMessage);
    }
    return hr;
}

//--------------------------------------------------------------------
extern "C" void MIDL_user_free(void * pvValue) {
    LocalFree(pvValue);
}

//--------------------------------------------------------------------
extern "C" void * MIDL_user_allocate(size_t n) {
    return (LocalAlloc(LPTR, n));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\lib\policy.h ===
//--------------------------------------------------------------------
// Policy - header
// Copyright (C) Microsoft Corporation, 2001
//
// Created by: Duncan Bryce (duncanb), 04-22-01
//
// Helper routines from w32time's group policy support

#ifndef POLICY_H
#define POLICY_H

HRESULT MyRegQueryPolicyValueEx(HKEY hPreferenceKey, HKEY hPolicyKey, LPWSTR pwszValue, LPWSTR pwszReserved, DWORD *pdwType, BYTE *pbData, DWORD *pcbData);

#endif // POLICY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\lib\ntpbase.h ===
//--------------------------------------------------------------------
// NtpBase - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 4-16-99
//
// The basic message structure, definitions, and helper functions
//
#ifndef NTPBASE_H
#define NTPBASE_H


//--------------------------------------------------------------------
// Time formats

// a clock reading, little-endian, in (10^-7)s
struct NtTimeEpoch {
    unsigned __int64 qw;
    void dump(void);
};
// a signed time offset, little-endian, in (10^-7)s
struct NtTimeOffset {
    signed __int64 qw;
    void dump(void);
};
// a length of time, little-endian, in (10^-7)s
struct NtTimePeriod {
    unsigned __int64 qw;
    void dump(void);
};

// a clock reading, big-endian, in (2^-32)s
struct NtpTimeEpoch { 
    unsigned __int64 qw;
};
// a signed time offset, big-endian, in (2^-16)s
struct NtpTimeOffset {
    signed __int32 dw;
};
// a length of time, big-endian, in (2^-16)s
struct NtpTimePeriod {
    unsigned __int32 dw;
};

extern const NtTimeEpoch gc_teNtpZero; // convenient 'zero'
extern const NtpTimeEpoch gc_teZero; // convenient 'zero'
extern const NtTimePeriod gc_tpZero; // convenient 'zero'
extern const NtTimeOffset gc_toZero; // convenient 'zero'

//--------------------------------------------------------------------
// helpful conversion functions

NtTimeEpoch  NtTimeEpochFromNtpTimeEpoch(NtpTimeEpoch te);
NtpTimeEpoch NtpTimeEpochFromNtTimeEpoch(NtTimeEpoch te);
NtTimePeriod  NtTimePeriodFromNtpTimePeriod(NtpTimePeriod tp);
NtpTimePeriod NtpTimePeriodFromNtTimePeriod(NtTimePeriod tp);
NtTimeOffset  NtTimeOffsetFromNtpTimeOffset(NtpTimeOffset to);
NtpTimeOffset NtpTimeOffsetFromNtTimeOffset(NtTimeOffset to);

//--------------------------------------------------------------------
// Math operators

static inline NtTimeOffset operator -(const NtTimeOffset toRight) {
    NtTimeOffset toRet;
    toRet.qw=-toRight.qw;
    return toRet;
}
static inline NtTimeOffset operator -(const NtTimeEpoch teLeft, const NtTimeEpoch teRight) {
    NtTimeOffset toRet;
    toRet.qw=teLeft.qw-teRight.qw;
    return toRet;
}
static inline NtTimeOffset operator -(const NtTimeOffset toLeft, const NtTimeOffset toRight) {
    NtTimeOffset toRet;
    toRet.qw=toLeft.qw-toRight.qw;
    return toRet;
}
static inline NtTimeOffset operator +(const NtTimeOffset toLeft, const NtTimeOffset toRight) {
    NtTimeOffset toRet;
    toRet.qw=toLeft.qw+toRight.qw;
    return toRet;
}
static inline NtTimeOffset & operator /=(NtTimeOffset &toLeft, const int nDiv) {
    toLeft.qw/=nDiv;
    return toLeft;
}
static inline NtTimeOffset & operator -=(NtTimeOffset &toLeft, const NtTimeOffset toRight) {
    toLeft.qw-=toRight.qw;
    return toLeft;
}
static inline NtTimeOffset & operator +=(NtTimeOffset &toLeft, const NtTimeOffset toRight) {
    toLeft.qw-=toRight.qw;
    return toLeft;
}

static inline NtTimeEpoch operator +(const NtTimeEpoch teLeft, const NtTimePeriod tpRight) {
    NtTimeEpoch teRet;
    teRet.qw=teLeft.qw+tpRight.qw;
    return teRet;
}

static inline NtTimePeriod operator *(const NtTimePeriod tpLeft, const unsigned __int64 qwMult) {
    NtTimePeriod tpRet;
    tpRet.qw=tpLeft.qw*qwMult;
    return tpRet;
}
static inline NtTimePeriod & operator *=(NtTimePeriod &tpLeft, const unsigned __int64 qwMult) {
    tpLeft.qw*=qwMult;
    return tpLeft;
}
static inline NtTimePeriod operator /(const NtTimePeriod tpLeft, const int nDiv) {
    NtTimePeriod tpRet;
    tpRet.qw=tpLeft.qw/nDiv;
    return tpRet;
}
static inline NtTimePeriod & operator +=(NtTimePeriod &tpLeft, const NtTimePeriod tpRight) {
    tpLeft.qw+=tpRight.qw;
    return tpLeft;
}
static inline NtTimePeriod operator +(const NtTimePeriod tpLeft, const NtTimePeriod tpRight) {
    NtTimePeriod tpRet;
    tpRet.qw=tpLeft.qw+tpRight.qw;
    return tpRet;
}
static inline NtTimePeriod & operator -=(NtTimePeriod &tpLeft, const NtTimePeriod tpRight) {
    tpLeft.qw-=tpRight.qw;
    return tpLeft;
}
static inline NtTimePeriod operator -(const NtTimePeriod tpLeft, const NtTimePeriod tpRight) {
    NtTimePeriod tpRet;
    tpRet.qw=tpLeft.qw-tpRight.qw;
    return tpRet;
}


static inline bool operator <(const NtTimeEpoch teLeft, const NtTimeEpoch teRight) {
    return teLeft.qw<teRight.qw;
}
static inline bool operator <=(const NtTimeEpoch teLeft, const NtTimeEpoch teRight) {
    return teLeft.qw<=teRight.qw;
}
static inline bool operator >(const NtTimeEpoch teLeft, const NtTimeEpoch teRight) {
    return teLeft.qw>teRight.qw;
}
static inline bool operator >=(const NtTimeEpoch teLeft, const NtTimeEpoch teRight) {
    return teLeft.qw>=teRight.qw;
}
static inline bool operator ==(const NtTimeEpoch teLeft, const NtTimeEpoch teRight) {
    return teLeft.qw==teRight.qw;
}
static inline bool operator !=(const NtTimeEpoch teLeft, const NtTimeEpoch teRight) {
    return teLeft.qw!=teRight.qw;
}

static inline bool operator <(const NtTimePeriod tpLeft, const NtTimePeriod tpRight) {
    return tpLeft.qw<tpRight.qw;
}
static inline bool operator <=(const NtTimePeriod tpLeft, const NtTimePeriod tpRight) {
    return tpLeft.qw<=tpRight.qw;
}
static inline bool operator >(const NtTimePeriod tpLeft, const NtTimePeriod tpRight) {
    return tpLeft.qw>tpRight.qw;
}
static inline bool operator >=(const NtTimePeriod tpLeft, const NtTimePeriod tpRight) {
    return tpLeft.qw>=tpRight.qw;
}
static inline bool operator ==(const NtTimePeriod tpLeft, const NtTimePeriod tpRight) {
    return tpLeft.qw==tpRight.qw;
}
static inline bool operator !=(const NtTimePeriod tpLeft, const NtTimePeriod tpRight) {
    return tpLeft.qw!=tpRight.qw;
}

static inline bool operator <(const NtTimeOffset toLeft, const NtTimeOffset toRight) {
    return toLeft.qw<toRight.qw;
}
static inline bool operator <=(const NtTimeOffset toLeft, const NtTimeOffset toRight) {
    return toLeft.qw<=toRight.qw;
}
static inline bool operator >(const NtTimeOffset toLeft, const NtTimeOffset toRight) {
    return toLeft.qw>toRight.qw;
}
static inline bool operator >=(const NtTimeOffset toLeft, const NtTimeOffset toRight) {
    return toLeft.qw>=toRight.qw;
}
static inline bool operator ==(const NtTimeOffset toLeft, const NtTimeOffset toRight) {
    return toLeft.qw==toRight.qw;
}
static inline bool operator !=(const NtTimeOffset toLeft, const NtTimeOffset toRight) {
    return toLeft.qw!=toRight.qw;
}

static inline bool operator ==(const NtpTimeEpoch teLeft, const NtpTimeEpoch teRight) {
    return teLeft.qw==teRight.qw;
}
static inline bool operator !=(const NtpTimeEpoch teLeft, const NtpTimeEpoch teRight) {
    return teLeft.qw!=teRight.qw;
}

static inline NtTimePeriod abs(const NtTimeOffset to) {
    NtTimePeriod tpRet;
    tpRet.qw=((to.qw<0)?((unsigned __int64)(-to.qw)):((unsigned __int64)(to.qw)));
    return tpRet;
}

//--------------------------------------------------------------------
static inline NtTimePeriod minimum(NtTimePeriod tpLeft, NtTimePeriod tpRight) {
    return ((tpLeft<tpRight)?tpLeft:tpRight);
}


//--------------------------------------------------------------------
// identifies the particular reference source
union NtpRefId {
    unsigned __int8  rgnIpAddr[4];      // an IP address
    unsigned __int8  rgnName[4];        // 4 ascii characters
    unsigned __int32 nTransmitTimestamp; // the low order 32 bits of the latest transmit timestamp of the reference source
    unsigned __int32 value;             // for copying purposes
};


//--------------------------------------------------------------------
// The format of a standard NTP packet
struct NtpPacket {
    struct {
        unsigned __int8  nMode:3;           // the mode. Valid range: 0-7
        unsigned __int8  nVersionNumber:3;  // the NTP/SNTP version number. Valid range: 1-4
        unsigned __int8  nLeapIndicator:2;  // a warning of an impending leap second to be inserted/deleted in the last minute of the current day
    };
    unsigned __int8 nStratum;              // the stratum level of the local clock. Valid Range: 0-15
      signed __int8 nPollInterval;         // the maximum interval between successive messages, in s, log base 2. Valid range:4(16s)-14(16284s)
      signed __int8 nPrecision;            // the precision of the local clock, in s, log base 2
    NtpTimeOffset   toRootDelay;           // the total roundtrip delay to the primary reference source, in (2^-16)s
    NtpTimePeriod   tpRootDispersion;      // the nominal error relative to the primary reference, in (2^-16)s
    NtpRefId        refid;                 // identifies the particular reference source
    NtpTimeEpoch    teReferenceTimestamp;  // the time at which the local clock was last set or corrected, in (2^-32)s
    NtpTimeEpoch    teOriginateTimestamp;  // the time at which the request departed the client for the server, in (2^-32)s
    NtpTimeEpoch    teReceiveTimestamp;    // the time at which the request arrived at the server, in (2^-32)s
    NtpTimeEpoch    teTransmitTimestamp;   // the time at which the reply departed the server for the client, in (2^-32)s
};
#define SizeOfNtpPacket 48

//--------------------------------------------------------------------
// The format of an authenticated NTP packet
struct AuthenticatedNtpPacket {
    struct {
        unsigned __int8  nMode:3;           // the mode. Valid range: 0-7
        unsigned __int8  nVersionNumber:3;  // the NTP/SNTP version number. Valid range: 1-4
        unsigned __int8  nLeapIndicator:2;  // a warning of an impending leap second to be inserted/deleted in the last minute of the current day
    };
    unsigned __int8 nStratum;              // the stratum level of the local clock. Valid Range: 0-15
      signed __int8 nPollInterval;         // the maximum interval between successive messages, in s, log base 2. Valid range:4(16s)-14(16284s)
      signed __int8 nPrecision;            // the precision of the local clock, in s, log base 2
    NtpTimeOffset   toRootDelay;           // the total roundtrip delay to the primary reference source, in (2^-16)s
    NtpTimePeriod   tpRootDispersion;      // the nominal error relative to the primary reference, in (2^-16)s
    NtpRefId        refid;                 // identifies the particular reference source
    NtpTimeEpoch    teReferenceTimestamp;  // the time at which the local clock was last set or corrected, in (2^-32)s
    NtpTimeEpoch    teOriginateTimestamp;  // the time at which the request departed the client for the server, in (2^-32)s
    NtpTimeEpoch    teReceiveTimestamp;    // the time at which the request arrived at the server, in (2^-32)s
    NtpTimeEpoch    teTransmitTimestamp;   // the time at which the reply departed the server for the client, in (2^-32)s
    unsigned __int32 nKeyIdentifier;        // implementation specific, for authentication
    unsigned __int8  rgnMessageDigest[16]; // implementation specific, for authentication
};
// We define this because of structure packing issues - our structure
// contains qwords, but is not a multiple of 8 in size, so sizeof()
// incorrectly reports the size. If we were to adjust the packing,
// we might misalign the qwords. Interestingly, in the NTP spec,
// the rgnMessageDigest is 12 bytes, so the packet is a multiple of 8.
#define SizeOfNtAuthenticatedNtpPacket 68

//--------------------------------------------------------------------
// The allowed NTP modes
enum NtpMode {
    e_Reserved=0,
    e_SymmetricActive=1,
    e_SymmetricPassive=2,
    e_Client=3,
    e_Server=4,
    e_Broadcast=5,
    e_Control=6,
    e_PrivateUse=7,
};

//--------------------------------------------------------------------
// The allowed NTP modes
enum NtpLeapIndicator {
    e_NoWarning=0,
    e_AddSecond=1,
    e_SubtractSecond=2,
    e_ClockNotSynchronized=3,
};

//--------------------------------------------------------------------
// NTP constants
struct NtpConst {
    static const unsigned int nVersionNumber;   // 3                // the current NTP version number
    static const unsigned int nPort;            // 123              // the port number assigned by the Internet Assigned Numbers Authority to NTP
    static const unsigned int nMaxStratum;      // 15               // the maximum stratum value that can be encoded as a packet value, also interpreted as "infinity" or unreachable
    static const signed int nMaxPollInverval;   // 10               // the maximum poll interval allowed by any peer, in s, log base 2 (10=1024s)
    static const signed int nMinPollInverval;   // 6                // the minimum poll interval allowed by any peer, in s, log base 2 (6=64s)
    static const NtTimePeriod tpMaxClockAge;    // 86400.0000000    // the maximum inverval a reference clock will be considered valid after its last update, in (10^-7)s
    static const NtTimePeriod tpMaxSkew;        //     1.0000000    // the maximum offset error due to skew of the local clock over the interval determined by NTPCONST_MaxAge, in (10^-7)s
    static const NtTimePeriod tpMaxDispersion;  //    16.0000000    // the maximum peer dispersion and the dispersion assumed for missing data, in (10^-7)s
    static const NtTimePeriod tpMinDispersion;  //     0.0100000    // the minimum dispersion increment for each stratum level, in (10^-7)s
    static const NtTimePeriod tpMaxDistance;    //     1.0000000    // the maximum synchronization distance for peers acceptible for synchronization, in (10^-7)s
    static const unsigned int nMinSelectClocks; // 1                // the minimum number of peers acceptable for synchronization
    static const unsigned int nMaxSelectClocks; // 10               // the maximum number of peers considered for selection
    static const DWORD dwLocalRefId;            // LOCL             // the reference identifier for the local clock

    static NtTimePeriod timesMaxSkewRate(NtTimePeriod tp) {         // MaxSkewRate == phi == NTPCONST_MaxSkew / NTPCONST_MaxClockAge; in s per s (==11.5740740...PPM)
        NtTimePeriod tpRet;
        tpRet.qw=tp.qw/86400;
        return tpRet;
    }
    static void weightFilter(NtTimePeriod &tp) { tp.qw/=2; }        // weight the filter dispersion during computation (x * 1/2)
    static void weightSelect(unsigned __int64 &tp) { tp*=3;tp/=4; } // weight the select dispersion during computation (x * 3/2)

};
struct NtpReachabilityReg {
    static const unsigned int nSize;            // 8                // the size of the reachability register, in bits
    unsigned __int8 nReg;
};


//--------------------------------------------------------------------
// helpful debug dump functions
void DumpNtpPacket(NtpPacket * pnpIn, NtTimeEpoch teDestinationTimestamp);
void DumpNtpTimeEpoch(NtpTimeEpoch te);
void DumpNtTimeEpoch(NtTimeEpoch te);
void DumpNtTimePeriod(NtTimePeriod tp);
void DumpNtTimeOffset(NtTimeOffset to);

inline void NtTimeEpoch::dump(void)  { DumpNtTimeEpoch(*this);  }
inline void NtTimePeriod::dump(void) { DumpNtTimePeriod(*this); }
inline void NtTimeOffset::dump(void) { DumpNtTimeOffset(*this); }

NtTimeEpoch GetCurrentSystemNtTimeEpoch(void);

#endif // NTPBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\lib\pinglib.h ===
//--------------------------------------------------------------------
// PingLib - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 10-8-99
//
// Various ways of pinging a server
//

#ifndef PING_LIB_H
#define PING_LIB_H

// forward declarations
struct NtpPacket;
struct NtTimeEpoch;

HRESULT MyIcmpPing(in_addr * piaTarget, DWORD dwTimeout, DWORD * pdwResponseTime);
HRESULT MyNtpPing(in_addr * piaTarget, DWORD dwTimeout, NtpPacket * pnpPacket, NtTimeEpoch * pteDestinationTimestamp);
HRESULT MyGetIpAddrs(const WCHAR * wszDnsName, in_addr ** prgiaLocalIpAddrs, in_addr ** prgiaRemoteIpAddrs, unsigned int *pnIpAddrs, bool * pbRetry);
HRESULT OpenSocketLayer(void);
HRESULT CloseSocketLayer(void);

HRESULT GetSystemErrorString(HRESULT hrIn, WCHAR ** pwszError);

#endif //PING_LIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\lib\policy.cpp ===
#include "pch.h"
#include "policy.h"

HRESULT MyRegQueryPolicyValueEx(HKEY hPreferenceKey, HKEY hPolicyKey, LPWSTR pwszValue, LPWSTR pwszReserved, DWORD *pdwType, BYTE *pbData, DWORD *pcbData) { 
    bool     bUsedPolicySettings = false; 
    DWORD    dwError; 
    HRESULT  hr; 

    if (NULL != hPolicyKey) { 
        // Override with policy settings: 
        dwError=RegQueryValueEx(hPolicyKey, pwszValue, NULL, pdwType, pbData, pcbData);
        if (ERROR_SUCCESS!=dwError) {
            hr=HRESULT_FROM_WIN32(dwError);
            // We don't worry if we can't read the value, we'll just take our default from the preferences. 
            _IgnoreErrorStr(hr, "RegQueryValueEx", pwszValue);
        } else { 
	    bUsedPolicySettings = true; 
	}
    } 

    if (!bUsedPolicySettings) { // Couldn't read value from policy
        // Read the value from our preferences in the registry: 
        dwError=RegQueryValueEx(hPreferenceKey, pwszValue, NULL, pdwType, pbData, pcbData);
        if (ERROR_SUCCESS!=dwError) {
            hr=HRESULT_FROM_WIN32(dwError);
            _JumpErrorStr(hr, error, "RegQueryValueEx", pwszValue);
        }
    }   

    hr = S_OK; 
 error:
    return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\lib\w32tmconsts.h ===
//--------------------------------------------------------------------
// W32TmConsts - header
// Copyright (C) Microsoft Corporation, 2000
//
// Created by: Louis Thomas (louisth), 6-15-00
//
// Numeric and string semi-public constants
//

#ifndef W32TMCONSTS_H
#define W32TMCONSTS_H

//--------------------------------------------------------------------
// useful common definitions
//#define MODULEPRIVATE static // so statics show up in VC
#define MODULEPRIVATE          // statics don't show up in ntsd either!
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

//--------------------------------------------------------------------
// registry entries for the time service
#define wszW32TimeRegKeyConfig                      L"System\\CurrentControlSet\\Services\\W32Time\\Config"
#define wszW32TimeRegKeyPolicyConfig                L"Software\\Policies\\Microsoft\\W32Time\\Config"
#define wszW32TimeRegValuePhaseCorrectRate          L"PhaseCorrectRate"
#define wszW32TimeRegValueUpdateInterval            L"UpdateInterval"
#define wszW32TimeRegValueLastClockRate             L"LastClockRate"
#define wszW32TimeRegValueFrequencyCorrectRate      L"FrequencyCorrectRate"
#define wszW32TimeRegValuePollAdjustFactor          L"PollAdjustFactor"
#define wszW32TimeRegValueLargePhaseOffset          L"LargePhaseOffset"
#define wszW32TimeRegValueSpikeWatchPeriod          L"SpikeWatchPeriod"
#define wszW32TimeRegValueHoldPeriod                L"HoldPeriod"
#define wszW32TimeRegValueMinPollInterval           L"MinPollInterval"
#define wszW32TimeRegValueMaxPollInterval           L"MaxPollInterval"
#define wszW32TimeRegValueMinClockRate              L"MinClockRate"
#define wszW32TimeRegValueMaxClockRate              L"MaxClockRate"
#define wszW32TimeRegValueAnnounceFlags             L"AnnounceFlags"
#define wszW32TimeRegValueLocalClockDispersion      L"LocalClockDispersion"
#define wszW32TimeRegValueMaxNegPhaseCorrection     L"MaxNegPhaseCorrection"
#define wszW32TimeRegValueMaxPosPhaseCorrection     L"MaxPosPhaseCorrection"
#define wszW32TimeRegValueEventLogFlags             L"EventLogFlags"
#define wszW32TimeRegValueMaxAllowedPhaseOffset     L"MaxAllowedPhaseOffset"

// announce flags
#define Timeserv_Announce_No            0x00
#define Timeserv_Announce_Yes           0x01
#define Timeserv_Announce_Auto          0x02
#define Timeserv_Announce_Mask          0x03
#define Reliable_Timeserv_Announce_No   0x00
#define Reliable_Timeserv_Announce_Yes  0x04
#define Reliable_Timeserv_Announce_Auto 0x08
#define Reliable_Timeserv_Announce_Mask 0x0C

// event log flags
#define EvtLog_TimeJump         0x01
#define EvtLog_SourceChange     0x02
#define EvtLog_SourceNone       0x03

// phase correction constants:
#define PhaseCorrect_ANY        0xFFFFFFFF

//--------------------------------------------------------------------
// RPC constants
// Note that \pipe\ntsvcs and \pipe\w32time used to be 
// aliased in HKLM\Services\CurrentControlSet\Services\Npfs\Aliases
// serivces.exe owned these. Now, we own it and live in svchost.
#define wszW32TimeSharedProcRpcEndpointName     L"W32TIME"
#define wszW32TimeOwnProcRpcEndpointName        L"W32TIME_ALT"


//--------------------------------------------------------------------
// service and dll constants
#define wszDLLNAME              L"w32time"
#define wszSERVICENAME          L"w32time"
#define wszSERVICECOMMAND       L"%SystemRoot%\\system32\\svchost.exe -k netsvcs" //L"w32tm.exe -service"
#define wszSERVICEDISPLAYNAME   L"Windows Time"
#define wszSERVICEDESCRIPTION   L"Maintains date and time synchronization on all clients and servers in the network. If this service is stopped, date and time synchronization will be unavailable. If this service is disabled, any services that explicitly depend on it will fail to start."
#define wszSERVICEACCOUNTNAME   L"LocalSystem"

// registry entries for the service
#define wszW32TimeRegKeyEventlog                    L"System\\CurrentControlSet\\Services\\Eventlog\\System\\W32Time"
#define wszW32TimeRegKeyRoot                        L"System\\CurrentControlSet\\Services\\W32Time"
#define wszW32TimeRegKeyParameters                  L"System\\CurrentControlSet\\Services\\W32Time\\Parameters"
#define wszW32TimeRegKeyPolicyParameters            L"Software\\Policies\\Microsoft\\W32Time\\Parameters"
#define wszW32TimeRegValueServiceDll                L"ServiceDll"

// parameters for the time service: 
#define wszW32TimeRegValueSpecialType L"SpecialType"
#define wszW32TimeRegValueType        L"Type"
#define wszW32TimeRegValueNtpServer   L"NtpServer"

// Possible values for "Type"
#define W32TM_Type_NT5DS   L"NT5DS"
#define W32TM_Type_NTP     L"NTP"
#define W32TM_Type_NoSync  L"NoSync"
#define W32TM_Type_AllSync L"AllSync"

// Default value for "NtpServer"
#define W32TM_NtpServer_Default  L"time.windows.com,0x1"

// defined in timeprov.h:
// wszW32TimeRegKeyTimeProviders 
// wszW32TimeRegValueInputProvider
// wszW32TimeRegValueDllName
// wszW32TimeRegValueEnabled

//--------------------------------------------------------------------
// values for ProvDispatch
#define wszNTPCLIENTPROVIDERNAME        L"NtpClient"
#define wszNTPSERVERPROVIDERNAME        L"NtpServer"

//--------------------------------------------------------------------
// registry entries for NtpClient
#define wszNtpClientRegKeyConfig                    L"System\\CurrentControlSet\\Services\\W32Time\\TimeProviders\\NtpClient"
#define wszNtpClientRegKeyPolicyConfig              L"Software\\Policies\\Microsoft\\W32Time\\TimeProviders\\NtpClient"
#define wszNtpClientRegValueSyncFromFlags           L"SyncFromFlags"
#define wszNtpClientRegValueManualPeerList          L"ManualPeerList"
#define wszNtpClientRegValueCrossSiteSyncFlags      L"CrossSiteSyncFlags"
#define wszNtpClientRegValueAllowNonstandardModeCombinations    L"AllowNonstandardModeCombinations"
#define wszNtpClientRegValueResolvePeerBackoffMinutes           L"ResolvePeerBackoffMinutes"
#define wszNtpClientRegValueResolvePeerBackoffMaxTimes          L"ResolvePeerBackoffMaxTimes"
#define wszNtpClientRegValueCompatibilityFlags        L"CompatibilityFlags"
#define wszNtpClientRegValueSpecialPollInterval       L"SpecialPollInterval"
#define wszNtpClientRegValueEventLogFlags             L"EventLogFlags"
#define wszNtpClientRegValueSpecialPollTimeRemaining  L"SpecialPollTimeRemaining"

// registry entries for NtpServer
#define wszNtpServerRegKeyConfig                    L"System\\CurrentControlSet\\Services\\W32Time\\TimeProviders\\NtpServer"
#define wszNtpServerRegKeyPolicyConfig              L"Software\\Policies\\Microsoft\\W32Time\\TimeProviders\\NtpServer"
#define wszNtpServerRegValueAllowNonstandardModeCombinations    L"AllowNonstandardModeCombinations"

// sync sources - NtpClientSourceFlag
#define NCSF_NoSync             0x00
#define NCSF_ManualPeerList     0x01
#define NCSF_DomainHierarchy    0x02
#define NCSF_ManualAndDomhier   0x03 
#define NCSF_DynamicPeers       0x04
#define NCSF_BroadcastPeers     0x08

// cross site sync flags
#define NCCSS_None      0x00
#define NCCSS_PdcOnly   0x01
#define NCCSS_All       0x02

// compatibility flags
#define NCCF_DispersionInvalid          0x00000001
#define NCCF_IgnoreFutureRefTimeStamp   0x00000002
#define NCCF_AutodetectWin2K            0x80000000
#define NCCF_AutodetectWin2KStage2      0x40000000

// Manual flags
#define NCMF_UseSpecialPollInterval     0x00000001
#define NCMF_UseAsFallbackOnly          0x00000002
#define NCMF_SymmetricActive            0x00000004
#define NCMF_Client                     0x00000008
#define NCMF_BroadcastClient            0x00000010 // NYI
#define NCMF_AssociationModeMask        0x0000000c // NOTE: broadcast NYI

// event log flags
#define NCELF_LogReachabilityChanges    0x00000001

//--------------------------------------------------------------------
// registry entries for the file log
#define wszFileLogRegKeyConfig              L"System\\CurrentControlSet\\Services\\W32Time\\Config"
#define wszFileLogRegValueFileLogEntries    L"FileLogEntries"
#define wszFileLogRegValueFileLogName       L"FileLogName"
#define wszFileLogRegValueFileLogFlags      L"FileLogFlags"
#define wszFileLogRegValueFileLogSize       L"FileLogSize"

// format flags
#define FL_HumanReadableTimestamps   0x00000000
#define FL_NTTimeEpochTimestamps     0x00000001

//--------------------------------------------------------------------
// flags passed to W32TimeDcPromo

#define W32TIME_PROMOTE                   0x00000001
#define W32TIME_DEMOTE                    0x00000002
#define W32TIME_PROMOTE_FIRST_DC_IN_TREE  0x00000004

//--------------------------------------------------------------------
//
#define wszW32TimeAuthType  L"NT5 Digest"


#endif //W32TMCONSTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\parser\bhver.h ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    bhver.h

Revision History:

--*/

#ifndef _NMVER_CHECK_
#define _NMVER_CHECK_

#include <ntverp.h>

#define VER_BUILDMAJOR 5
#define VER_BUILDMINOR 0
#define VER_BUILDMM_STR VER_PRODUCTVERSION_STRING
#define VER_NMBUILDNUMBER VER_PRODUCTBUILD

#endif // _NMVER_CHECK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32time\errtofilelog.h ===
//--------------------------------------------------------------------
// ErrToFileLog - header
// Copyright (C) Microsoft Corporation, 2000
//
// Created by: Louis Thomas (louisth), 2-4-00
//
// Redirect error handling macros to file log
//

#ifndef ERRTOFILELOG_H
#define ERRTOFILELOG_H

#ifdef DBG


#undef DebugWPrintf0
#undef DebugWPrintf1
#undef DebugWPrintf2
#undef DebugWPrintf3
#undef DebugWPrintf4
#undef DebugWPrintf5
#undef DebugWPrintf6
#undef DebugWPrintf7
#undef DebugWPrintf8
#undef DebugWPrintf9
#undef DebugWPrintfTerminate

#define DebugWPrintf0(wszFormat)                   FileLog0(FL_Error, (wszFormat))
#define DebugWPrintf1(wszFormat,a)                 FileLog1(FL_Error, (wszFormat),(a))
#define DebugWPrintf2(wszFormat,a,b)               FileLog2(FL_Error, (wszFormat),(a),(b))
#define DebugWPrintf3(wszFormat,a,b,c)             FileLog3(FL_Error, (wszFormat),(a),(b),(c))
#define DebugWPrintf4(wszFormat,a,b,c,d)           FileLog4(FL_Error, (wszFormat),(a),(b),(c),(d))
#define DebugWPrintf5(wszFormat,a,b,c,d,e)         FileLog5(FL_Error, (wszFormat),(a),(b),(c),(d),(e))
#define DebugWPrintf6(wszFormat,a,b,c,d,e,f)       FileLog6(FL_Error, (wszFormat),(a),(b),(c),(d),(e),(f))
#define DebugWPrintf7(wszFormat,a,b,c,d,e,f,g)     FileLog7(FL_Error, (wszFormat),(a),(b),(c),(d),(e),(f),(g))
#define DebugWPrintf8(wszFormat,a,b,c,d,e,f,g,h)   FileLog8(FL_Error, (wszFormat),(a),(b),(c),(d),(e),(f),(g),(h))
#define DebugWPrintf9(wszFormat,a,b,c,d,e,f,g,h,i) FileLog9(FL_Error, (wszFormat),(a),(b),(c),(d),(e),(f),(g),(h),(i))
#define DebugWPrintfTerminate()

#endif //DBG


#endif //ERRTOFILELOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32tclnt\timeif_client.c ===
#include <timeif_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\parser\ntpparser.cpp ===
//--------------------------------------------------------------------
// NtpParser - implementation
// Copyright (C) Microsoft Corporation, 2000
//
// Created by: Louis Thomas (louisth), 2-29-00
// Based upon the parser created by kumarp, 23-June-1999
// 
// NTP parser for NetMon
//

#include <windows.h>
#include <netmon.h>
#include <parser.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "..\lib\EndianSwap.inl"

//#define MODULEPRIVATE static // so statics show up in VC
#define MODULEPRIVATE          // statics don't show up in ntsd either!

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))


//--------------------------------------------------------------------
// Forward declarations

VOID WINAPIV Ntp_FormatSummary(LPPROPERTYINST pPropertyInst);
VOID WINAPIV Ntp_FormatNtpTime(LPPROPERTYINST pPropertyInst);
VOID WINAPIV Ntp_FormatStratum(LPPROPERTYINST pPropertyInst);
VOID WINAPIV Ntp_FormatPollInterval(LPPROPERTYINST pPropertyInst);
VOID WINAPIV Ntp_FormatPrecision(LPPROPERTYINST pPropertyInst);
VOID WINAPIV Ntp_FormatRootDelay(LPPROPERTYINST pPropertyInst);
VOID WINAPIV Ntp_FormatRootDispersion(LPPROPERTYINST pPropertyInst);
VOID WINAPIV Ntp_FormatRefId(LPPROPERTYINST pPropertyInst);


//--------------------------------------------------------------------
// Property Value Labels

// Leap Indicator 
LABELED_BYTE NtpLIVals[]={
    {0xc0, NULL},
    {0x00, "LI: no warning"},
    {0x40, "LI: last minute has 61 seconds"},
    {0x80, "LI: last minute has 59 seconds"},
    {0xc0, "LI: clock not synchronized"},
};
SET NtpLISet={ARRAYSIZE(NtpLIVals), NtpLIVals};

// Version
LABELED_BYTE NtpVersionVals[]={
    {0x38, NULL},
    {0x00, "Version: 0"},
    {0x08, "Version: 1"},
    {0x10, "Version: 2"},
    {0x18, "Version: 3"},
    {0x20, "Version: 4"},
    {0x28, "Version: 5"},
    {0x30, "Version: 6"},
    {0x38, "Version: 7"},
};
SET NtpVersionSet={ARRAYSIZE(NtpVersionVals), NtpVersionVals};

// Mode
LABELED_BYTE NtpModeVals[]={
    {7, NULL},
    {0, "Mode: reserved"},
    {1, "Mode: symmetric active"},
    {2, "Mode: symmetric passive"},
    {3, "Mode: client"},
    {4, "Mode: server"},
    {5, "Mode: broadcast"},
    {6, "Mode: reserved for NTP control message"},
    {7, "Mode: reserved for private use"},
};
SET NtpModeSet={ARRAYSIZE(NtpModeVals), NtpModeVals};

enum {
    NTP_MODE_Reserved=0,
    NTP_MODE_SymmetricActive,
    NTP_MODE_SymmetricPassive,
    NTP_MODE_Client,
    NTP_MODE_Server,
    NTP_MODE_Broadcast,
    NTP_MODE_Control,
    NTP_MODE_Private,
};

//--------------------------------------------------------------------
// property ordinals (These must be kept in sync with the contents of NtpPropertyTable)
enum {
    Ntp_Summary=0,
    Ntp_LeapIndicator,
    Ntp_Version,
    Ntp_Mode,
    Ntp_Stratum,
    Ntp_PollInterval,
    Ntp_Precision,
    Ntp_RootDelay,
    Ntp_RootDispersion,
    Ntp_RefId,
    Ntp_ReferenceTimeStamp,
    Ntp_OriginateTimeStamp,
    Ntp_ReceiveTimeStamp,
    Ntp_TransmitTimeStamp
};

// Properties
PROPERTYINFO NtpPropertyTable[]={
    {
        0, 0,
        "Summary",
        "Summary of the NTP Packet",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        NULL,
        80,                     // max string size
        Ntp_FormatSummary
    }, {
        0, 0,
        "LI",
        "Leap Indicator",
        PROP_TYPE_BYTE,
        PROP_QUAL_LABELED_BITFIELD,
        &NtpLISet,
        80,
        FormatPropertyInstance
    }, {
        0, 0,
        "Version",
        "NTP Version",
        PROP_TYPE_BYTE,
        PROP_QUAL_LABELED_BITFIELD,
        &NtpVersionSet,
        80,
        FormatPropertyInstance
    }, {
        0, 0,
        "Mode",
        "Mode",
        PROP_TYPE_BYTE,
        PROP_QUAL_LABELED_BITFIELD,
        &NtpModeSet,
        80,
        FormatPropertyInstance
    }, {
        0, 0,
        "Stratum",
        "Stratum",
        PROP_TYPE_BYTE,
        PROP_QUAL_NONE,
        NULL,
        80,
        Ntp_FormatStratum
    }, {
        0, 0,
        "Poll Interval",
        "Maximum interval between two successive messages",
        PROP_TYPE_BYTE,
        PROP_QUAL_NONE,
        NULL,
        80,
        Ntp_FormatPollInterval
    }, {
        0, 0,
        "Precision",
        "Precision of the local clock",
        PROP_TYPE_BYTE,
        PROP_QUAL_NONE,
        NULL,
        80,
        Ntp_FormatPrecision
    }, {
        0, 0,
        "Root Delay",
        "Total roundtrip delay to the primary reference source",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        NULL,
        80,
        Ntp_FormatRootDelay
    }, {
        0, 0,
        "Root Dispersion",
        "Nominal error relative to the primary reference source",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        NULL,
        80,
        Ntp_FormatRootDispersion
    }, {
        0, 0,
        "Reference Identifier",
        "Reference source identifier",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        NULL,
        80,
        Ntp_FormatRefId
    }, {
        0, 0,
        "Reference Timestamp",
        "Time server was last synchronized",
        PROP_TYPE_LARGEINT,
        PROP_QUAL_NONE,
        NULL,
        150,
        Ntp_FormatNtpTime
    }, {
        0, 0,
        "Originate Timestamp",
        "Time at client when packet was transmitted",
        PROP_TYPE_LARGEINT,
        PROP_QUAL_NONE,
        NULL,
        150,
        Ntp_FormatNtpTime
    }, {
        0, 0,
        "Receive   Timestamp",
        "Time at server when packet was received",
        PROP_TYPE_LARGEINT,
        PROP_QUAL_NONE,
        NULL,
        150,
        Ntp_FormatNtpTime
   }, {
        0, 0,
        "Transmit  Timestamp",
        "Time at server when packet was transmitted",
        PROP_TYPE_LARGEINT,
        PROP_QUAL_NONE,
        NULL,
        150,
        Ntp_FormatNtpTime
    },
};

//####################################################################

//--------------------------------------------------------------------
VOID WINAPIV Ntp_FormatSummary(LPPROPERTYINST pPropertyInst) {

    BYTE bMode=(*pPropertyInst->lpByte)&7;

    switch (bMode) {
    case NTP_MODE_Client:
        lstrcpy(pPropertyInst->szPropertyText, "Client request");
        break;
            
    case NTP_MODE_Server:
        lstrcpy(pPropertyInst->szPropertyText, "Server response");
        break;

    case NTP_MODE_SymmetricActive:
        lstrcpy(pPropertyInst->szPropertyText, "Active request");
        break;

    case NTP_MODE_SymmetricPassive:
        lstrcpy(pPropertyInst->szPropertyText, "Passive reponse");
        break;

    case NTP_MODE_Broadcast:
        lstrcpy(pPropertyInst->szPropertyText, "Time broadcast");
        break;

    default:
        lstrcpy(pPropertyInst->szPropertyText, "Other NTP packet");
        break;
   }
}

//--------------------------------------------------------------------
VOID WINAPIV Ntp_FormatStratum(LPPROPERTYINST pPropertyInst) {

    unsigned __int8 nStratum=(*pPropertyInst->lpByte);

    char * szMeaning;
    if (0==nStratum) {
        szMeaning="unspecified or unavailable";
    } else if (1==nStratum) {
        szMeaning="primary reference (syncd by radio clock)";
    } else if (nStratum<16) {
        szMeaning="secondary reference (syncd by NTP)";
    } else {
        szMeaning="reserved";
    }
    wsprintf(pPropertyInst->szPropertyText, "Stratum: 0x%02X = %u = %s", nStratum, nStratum, szMeaning);
}

//--------------------------------------------------------------------
VOID WINAPIV Ntp_FormatPollInterval(LPPROPERTYINST pPropertyInst) {
    char * szMeaning;
    char szBuf[30];

    signed __int8 nPollInterval=(*pPropertyInst->lpByte);

    if (0==nPollInterval) {
        szMeaning="unspecified";
    } else if (nPollInterval<4 || nPollInterval>14) {
        szMeaning="out of valid range";
    } else {
        wsprintf(szBuf, "%ds", 1<<nPollInterval);
        szMeaning=szBuf;
    }
    wsprintf(pPropertyInst->szPropertyText, "Poll Interval: 0x%02X = %d = %s", (unsigned __int8)nPollInterval, nPollInterval, szMeaning);
}

//--------------------------------------------------------------------
VOID WINAPIV Ntp_FormatPrecision(LPPROPERTYINST pPropertyInst) {
    char * szMeaning;
    char szBuf[30];

    signed __int8 nPrecision=(*pPropertyInst->lpByte);

    if (0==nPrecision) {
        szMeaning="unspecified";
    } else if (nPrecision>-2 || nPrecision<-31) {
        szMeaning="out of valid range";
    } else {
        szMeaning=szBuf;
        char * szUnit="s";
        double dTickInterval=1.0/(1<<(-nPrecision));
        if (dTickInterval<1) {
            dTickInterval*=1000;
            szUnit="ms";
        }
        if (dTickInterval<1) {
            dTickInterval*=1000;
            szUnit="s";
        }
        if (dTickInterval<1) {
            dTickInterval*=1000;
            szUnit="ns";
        }
        sprintf(szBuf, "%g%s per tick", dTickInterval, szUnit);
    }
    wsprintf(pPropertyInst->szPropertyText, "Precision: 0x%02X = %d = %s", (unsigned __int8)nPrecision, nPrecision, szMeaning);
}

//--------------------------------------------------------------------
VOID WINAPIV Ntp_FormatRootDelay(LPPROPERTYINST pPropertyInst) {
    char * szMeaning;
    char szBuf[30];

    DWORD dwRootDelay=EndianSwap((unsigned __int32)*pPropertyInst->lpDword);

    if (0==dwRootDelay) {
        szMeaning="unspecified";
    } else {
        szMeaning=szBuf;
        sprintf(szBuf, "%gs", ((double)((signed __int32)dwRootDelay))/0x00010000);
    }

    wsprintf(pPropertyInst->szPropertyText, "Root Delay: 0x%04X.%04Xs = %s", dwRootDelay>>16, dwRootDelay&0x0000FFFF, szMeaning);
}

//--------------------------------------------------------------------
VOID WINAPIV Ntp_FormatRootDispersion(LPPROPERTYINST pPropertyInst) {
    char * szMeaning;
    char szBuf[30];

    DWORD dwRootDispersion=EndianSwap((unsigned __int32)*pPropertyInst->lpDword);

    if (0==dwRootDispersion) {
        szMeaning="unspecified";
    } else {
        szMeaning=szBuf;
        sprintf(szBuf, "%gs", ((double)((signed __int32)dwRootDispersion))/0x00010000);
    }

    wsprintf(pPropertyInst->szPropertyText, "Root Dispersion: 0x%04X.%04Xs = %s", dwRootDispersion>>16, dwRootDispersion&0x0000FFFF, szMeaning);
}

//--------------------------------------------------------------------
VOID WINAPIV Ntp_FormatRefId(LPPROPERTYINST pPropertyInst) {
    char * szMeaning;
    char szBuf[30];

    DWORD dwRefID=EndianSwap((unsigned __int32)*pPropertyInst->lpDword);
    unsigned __int8 nStratum=*(pPropertyInst->lpByte-11);
    unsigned int nVersion=*(pPropertyInst->lpByte-12);
    nVersion&=0x38;
    nVersion>>=3;


    if (0==dwRefID) {
        szMeaning="unspecified";
    } else if (0==nStratum || 1==nStratum) {
        szMeaning=szBuf;
        char szId[5];
        szId[0]=pPropertyInst->lpByte[0];
        szId[1]=pPropertyInst->lpByte[1];
        szId[2]=pPropertyInst->lpByte[2];
        szId[3]=pPropertyInst->lpByte[3];
        szId[4]='\0';
        sprintf(szBuf, "source name: \"%s\"", szId);
    } else if (nVersion<4) {
        szMeaning=szBuf;
        sprintf(szBuf, "source IP: %u.%u.%u.%u", 
                pPropertyInst->lpByte[0], pPropertyInst->lpByte[1],
                pPropertyInst->lpByte[2], pPropertyInst->lpByte[3]);
    } else {
        szMeaning=szBuf;
        sprintf(szBuf, "last reference timestamp fraction: %gs", ((double)dwRefID)/(4294967296.0));
    }

    wsprintf(pPropertyInst->szPropertyText, "Reference Identifier: 0x%08X = %s", dwRefID, szMeaning);

}



//--------------------------------------------------------------------
// conversion constants
#define NTPTIMEOFFSET (0x014F373BFDE04000)
#define FIVETOTHESEVETH (0x001312D)

//--------------------------------------------------------------------
// convert from big-endian NTP-stye timestamp to little-endian NT-style timestamp
unsigned __int64 NtTimeFromNtpTime(unsigned __int64 qwNtpTime) {
    //return (qwNtpTime*(10**7)/(2**32))+NTPTIMEOFFSET
    // ==>
    //return (qwNtpTime*(5**7)/(2**25))+NTPTIMEOFFSET
    // ==>
    //return ((qwNTPtime*FIVETOTHESEVETH)>>25)+NTPTIMEOFFSET;  
    // ==>
    // Note: 'After' division, we round (instead of truncate) the result for better precision
    unsigned __int64 qwTemp;
    qwNtpTime=EndianSwap(qwNtpTime);

    qwTemp=((qwNtpTime&0x00000000FFFFFFFF)*FIVETOTHESEVETH);
    qwTemp += qwTemp&0x0000000001000000; //rounding step: if 25th bit is set, round up
    return (qwTemp>>25) + (((qwNtpTime>>32)*FIVETOTHESEVETH)<<7) + NTPTIMEOFFSET;
}

//--------------------------------------------------------------------
void FormatNtTimeStr(unsigned __int64 qwNtTime, char * szTime) {
    DWORD dwNanoSecs, dwSecs, dwMins, dwHours, dwDays;

    dwNanoSecs=(DWORD)(qwNtTime%10000000);
    qwNtTime/=10000000;

    dwSecs=(DWORD)(qwNtTime%60);
    qwNtTime/=60;

    dwMins=(DWORD)(qwNtTime%60);
    qwNtTime/=60;

    dwHours=(DWORD)(qwNtTime%24);

    dwDays=(DWORD)(qwNtTime/24);

    wsprintf(szTime, "%u %02u:%02u:%02u.%07us",
             dwDays, dwHours, dwMins, dwSecs, dwNanoSecs);
}


//--------------------------------------------------------------------
VOID WINAPIV Ntp_FormatNtpTime(LPPROPERTYINST pPropertyInst) {
    LARGE_INTEGER liNtpTime;
    unsigned __int64 qwNtTime;
    unsigned __int64 qwNtTimeEpoch; 
    char  szTime[64];
    char  szTimeEpoch[64]; 

    
    liNtpTime=*pPropertyInst->lpLargeInt;
    qwNtTime=NtTimeFromNtpTime((((unsigned __int64) liNtpTime.HighPart) << 32) |
                                 liNtpTime.LowPart);

    if (liNtpTime.HighPart || liNtpTime.LowPart) {
        FormatNtTimeStr(qwNtTime, szTime);
    } else {
        lstrcpy(szTime, "(not specified)");
    }

    wsprintf(szTimeEpoch, " -- %I64d00ns", 
             ((((unsigned __int64)liNtpTime.HighPart) << 32) | liNtpTime.LowPart));;

    wsprintf(pPropertyInst->szPropertyText, "%s: 0x%08X.%08Xs %s = %s", 
             pPropertyInst->lpPropertyInfo->Label,
             EndianSwap((unsigned __int32)liNtpTime.LowPart),
             EndianSwap((unsigned __int32)liNtpTime.HighPart),
	     szTimeEpoch, 
	     szTime);
}

//####################################################################

//--------------------------------------------------------------------
// Create our property database and handoff sets.
void BHAPI Ntp_Register(HPROTOCOL hNtp) {
    unsigned int nIndex;

    // tell netmon to make reserve some space for our property table
    CreatePropertyDatabase(hNtp, ARRAYSIZE(NtpPropertyTable));

    // add our properties to netmon's database
    for(nIndex=0; nIndex<ARRAYSIZE(NtpPropertyTable); nIndex++) {
        AddProperty(hNtp, &NtpPropertyTable[nIndex]);
    }
}


//--------------------------------------------------------------------
// Destroy our property database and handoff set
VOID WINAPI Ntp_Deregister(HPROTOCOL hNtp) {

    // tell netmon that it may now free our database
    DestroyPropertyDatabase(hNtp);
}


//--------------------------------------------------------------------
// Determine whether we exist in the frame at the spot 
// indicated. We also indicate who (if anyone) follows us
// and how much of the frame we claim.
LPBYTE BHAPI Ntp_RecognizeFrame(HFRAME hFrame, ULPBYTE pMacFrame, ULPBYTE pNtpFrame, DWORD MacType, DWORD BytesLeft, HPROTOCOL hPrevProtocol, DWORD nPrevProtOffset, LPDWORD pProtocolStatus, LPHPROTOCOL phNextProtocol, PDWORD_PTR InstData) {

    // For now, just assume that if we got called,
    // then the packet does contain us and we go to the end of the frame
    *pProtocolStatus=PROTOCOL_STATUS_CLAIMED;
    return NULL;
}


//--------------------------------------------------------------------
// Indicate where in the frame each of our properties live.
LPBYTE BHAPI Ntp_AttachProperties(HFRAME hFrame, ULPBYTE pMacFrame, ULPBYTE pNtpFrame, DWORD MacType, DWORD BytesLeft, HPROTOCOL hPrevProtocol, DWORD nPrevProtOffset, DWORD_PTR InstData) {

    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_Summary].hProperty, (WORD)BytesLeft, (LPBYTE)pNtpFrame, 0, 0, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_LeapIndicator].hProperty, (WORD)1, (LPBYTE) pNtpFrame, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_Version].hProperty, (WORD)1, (LPBYTE) pNtpFrame, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_Mode].hProperty, (WORD)1, (LPBYTE) pNtpFrame, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_Stratum].hProperty, (WORD)1, (LPBYTE) pNtpFrame+1, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_PollInterval].hProperty, (WORD)1, (LPBYTE) pNtpFrame+2, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_Precision].hProperty, (WORD)1, (LPBYTE) pNtpFrame+3, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_RootDelay].hProperty, (WORD)4, (LPBYTE) pNtpFrame+4, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_RootDispersion].hProperty, (WORD)4, (LPBYTE) pNtpFrame+8, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_RefId].hProperty, (WORD)4, (LPBYTE) pNtpFrame+12, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_ReferenceTimeStamp].hProperty, (WORD)8, (LPBYTE) pNtpFrame+16, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_OriginateTimeStamp].hProperty, (WORD) 8, (LPBYTE) pNtpFrame+24, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_ReceiveTimeStamp].hProperty, (WORD) 8, (LPBYTE) pNtpFrame+32, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_TransmitTimeStamp].hProperty, (WORD) 8, (LPBYTE) pNtpFrame+40, 0, 1, 0);

    return NULL;
}


//--------------------------------------------------------------------
// Format the given properties on the given frame.
DWORD BHAPI Ntp_FormatProperties(HFRAME hFrame, ULPBYTE pMacFrame, ULPBYTE pNtpFrame, DWORD nPropertyInsts, LPPROPERTYINST p) {

    // loop through the property instances
    while(nPropertyInsts-->0) {
        // and call the formatter for each
        ((FORMAT)(p->lpPropertyInfo->InstanceData))(p);
        p++;
    }

    return NMERR_SUCCESS;
}


//####################################################################

//--------------------------------------------------------------------
//  AutoInstall - return all of the information neede to install us
PPF_PARSERDLLINFO WINAPI ParserAutoInstallInfo() {
    PPF_PARSERDLLINFO pParserDllInfo; 
    PPF_PARSERINFO    pParserInfo;
    DWORD NumProtocols;

    DWORD NumHandoffs;
    PPF_HANDOFFSET    pHandoffSet;
    PPF_HANDOFFENTRY  pHandoffEntry;

    // Allocate memory for parser info:
    NumProtocols=1;
    pParserDllInfo=(PPF_PARSERDLLINFO)HeapAlloc(GetProcessHeap(),
                                                   HEAP_ZERO_MEMORY,
                                                   sizeof(PF_PARSERDLLINFO) +
                                                   NumProtocols * sizeof(PF_PARSERINFO));
    if(pParserDllInfo==NULL) {
        return NULL;
    }       
    
    // fill in the parser DLL info
    pParserDllInfo->nParsers=NumProtocols;

    // fill in the individual parser infos...

    // Ntp ==============================================================
    pParserInfo=&(pParserDllInfo->ParserInfo[0]);
    wsprintf(pParserInfo->szProtocolName, "NTP");
    wsprintf(pParserInfo->szComment,      "Network Time Protocol");
    wsprintf(pParserInfo->szHelpFile,     "");

    // the incoming handoff set ----------------------------------------------
    // allocate
    NumHandoffs = 1;
    pHandoffSet = (PPF_HANDOFFSET)HeapAlloc( GetProcessHeap(),
                                             HEAP_ZERO_MEMORY,
                                             sizeof( PF_HANDOFFSET ) +
                                             NumHandoffs * sizeof( PF_HANDOFFENTRY) );
    if( pHandoffSet == NULL )
    {
        // just return early
        return pParserDllInfo;
    }

    // fill in the incoming handoff set
    pParserInfo->pWhoHandsOffToMe = pHandoffSet;
    pHandoffSet->nEntries = NumHandoffs;

    pHandoffEntry = &(pHandoffSet->Entry[0]);
    wsprintf( pHandoffEntry->szIniFile,    "TCPIP.INI" );
    wsprintf( pHandoffEntry->szIniSection, "UDP_HandoffSet" );
    wsprintf( pHandoffEntry->szProtocol,   "NTP" );
    pHandoffEntry->dwHandOffValue =        123;
    pHandoffEntry->ValueFormatBase =       HANDOFF_VALUE_FORMAT_BASE_DECIMAL;

    return pParserDllInfo;
}

//--------------------------------------------------------------------
// Tell netmon about our entry points.
extern "C" BOOL WINAPI DllMain(HANDLE hInstance, ULONG Command, LPVOID Reserved) {

    //MessageBox(NULL, "DLLEntry", "NTP ha ha", MB_OK);
    static HPROTOCOL hNtp=NULL;
    static unsigned int nAttached=0;
    
    // what type of call is this
    switch(Command) {

    case DLL_PROCESS_ATTACH:
        // are we loading for the first time?
        if (nAttached==0) {
            // the first time in we need to tell netmon 
            // about ourselves

            ENTRYPOINTS NtpEntryPoints={
                Ntp_Register,
                Ntp_Deregister,
                Ntp_RecognizeFrame,
                Ntp_AttachProperties,
                Ntp_FormatProperties
            };

            hNtp=CreateProtocol("NTP", &NtpEntryPoints, ENTRYPOINTS_SIZE);
        }
        nAttached++;
        break;

    case DLL_PROCESS_DETACH:
        nAttached--;
        // are we detaching our last instance?
        if (nAttached==0) {
            // last guy out needs to clean up
            DestroyProtocol(hNtp);
        }
        break;
    }

    // Netmon parsers ALWAYS return TRUE.
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32time\mycritsec.h ===
//--------------------------------------------------------------------
// MyCritSec - header
// Copyright (C) Microsoft Corporation, 2000
//
// Created by: Louis Thomas (louisth), 02-03-00
//
// exception handling wrapper for critical sections
//

#ifndef MYCRITSEC_H
#define MYCRITSEC_H

HRESULT myHExceptionCode(EXCEPTION_POINTERS * pep);

HRESULT myInitializeCriticalSection(CRITICAL_SECTION * pcs);
HRESULT myEnterCriticalSection(CRITICAL_SECTION * pcs);
HRESULT myTryEnterCriticalSection(CRITICAL_SECTION * pcs, BOOL * pbEntered);
HRESULT myLeaveCriticalSection(CRITICAL_SECTION * pcs);

HRESULT myRtlInitializeResource(IN PRTL_RESOURCE Resource);
HRESULT myRtlAcquireResourceExclusive(IN PRTL_RESOURCE Resource, IN BOOLEAN Wait, OUT BOOLEAN *pResult);
HRESULT myRtlAcquireResourceShared(IN PRTL_RESOURCE Resource, IN BOOLEAN Wait, OUT BOOLEAN *pResult);
HRESULT myRtlReleaseResource(IN PRTL_RESOURCE Resource);

#endif //MYCRITSEC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32time\logging.h ===
//--------------------------------------------------------------------
// Logging - header
// Copyright (C) Microsoft Corporation, 2000
//
// Created by: Louis Thomas (louisth), 02-01-00
//
// routines to do logging to the event log and to a file
//

#ifndef LOGGING_H
#define LOGGING_H

HRESULT MyLogEvent(WORD wType, DWORD dwEventID, unsigned int nStrings, const WCHAR ** rgwszStrings);
HRESULT MyLogSourceChangeEvent(LPWSTR pwszSource);
HRESULT MyResetSourceChangeLog();

HRESULT FileLogBegin(void);
void FileLogEnd(void);
HRESULT FileLogResume(void); 
HRESULT FileLogSuspend(void);
HRESULT UpdateFileLogConfig(void); 

bool FileLogAllowEntry(DWORD dwEntry);
void FileLogAdd(const WCHAR * wszFormat, ...);
void FileLogAppend(const WCHAR * wszFormat, ...);
void FileLogAddEx(bool bAppend, const WCHAR * wszFormat, va_list vlArgs);

void FileLogNtTimeEpoch(NtTimeEpoch te);
void FileLogNtTimeEpochEx(bool bAppend, NtTimeEpoch te);
void FileLogNtTimePeriod(NtTimePeriod tp);
void FileLogNtTimePeriodEx(bool bAppend, NtTimePeriod tp);
void FileLogNtTimeOffset(NtTimeOffset to);
void FileLogNtTimeOffsetEx(bool bAppend, NtTimeOffset to);
void FileLogNtpTimeEpoch(NtpTimeEpoch te);
void FileLogNtpTimeEpochEx(bool bAppend, NtpTimeEpoch te);
void FileLogNtpPacket(NtpPacket * pnpIn, NtTimeEpoch teDestinationTimestamp);
void FileLogSockaddrIn(sockaddr_in * psai);
void FileLogSockaddrInEx(bool bAppend, sockaddr_in * psai);

#define FileLog0(dwEntry,wszFormat)                   if (FileLogAllowEntry(dwEntry)) {FileLogAdd((wszFormat));}
#define FileLog1(dwEntry,wszFormat,a)                 if (FileLogAllowEntry(dwEntry)) {FileLogAdd((wszFormat),(a));}
#define FileLog2(dwEntry,wszFormat,a,b)               if (FileLogAllowEntry(dwEntry)) {FileLogAdd((wszFormat),(a),(b));}
#define FileLog3(dwEntry,wszFormat,a,b,c)             if (FileLogAllowEntry(dwEntry)) {FileLogAdd((wszFormat),(a),(b),(c));}
#define FileLog4(dwEntry,wszFormat,a,b,c,d)           if (FileLogAllowEntry(dwEntry)) {FileLogAdd((wszFormat),(a),(b),(c),(d));}
#define FileLog5(dwEntry,wszFormat,a,b,c,d,e)         if (FileLogAllowEntry(dwEntry)) {FileLogAdd((wszFormat),(a),(b),(c),(d),(e));}
#define FileLog6(dwEntry,wszFormat,a,b,c,d,e,f)       if (FileLogAllowEntry(dwEntry)) {FileLogAdd((wszFormat),(a),(b),(c),(d),(e),(f));}
#define FileLog7(dwEntry,wszFormat,a,b,c,d,e,f,g)     if (FileLogAllowEntry(dwEntry)) {FileLogAdd((wszFormat),(a),(b),(c),(d),(e),(f),(g));}
#define FileLog8(dwEntry,wszFormat,a,b,c,d,e,f,g,h)   if (FileLogAllowEntry(dwEntry)) {FileLogAdd((wszFormat),(a),(b),(c),(d),(e),(f),(g),(h));}
#define FileLog9(dwEntry,wszFormat,a,b,c,d,e,f,g,h,i) if (FileLogAllowEntry(dwEntry)) {FileLogAdd((wszFormat),(a),(b),(c),(d),(e),(f),(g),(h),(i));}

#define FileLogA0(dwEntry,wszFormat)                   if (FileLogAllowEntry(dwEntry)) {FileLogAppend((wszFormat));}
#define FileLogA1(dwEntry,wszFormat,a)                 if (FileLogAllowEntry(dwEntry)) {FileLogAppend((wszFormat),(a));}
#define FileLogA2(dwEntry,wszFormat,a,b)               if (FileLogAllowEntry(dwEntry)) {FileLogAppend((wszFormat),(a),(b));}
#define FileLogA3(dwEntry,wszFormat,a,b,c)             if (FileLogAllowEntry(dwEntry)) {FileLogAppend((wszFormat),(a),(b),(c));}
#define FileLogA4(dwEntry,wszFormat,a,b,c,d)           if (FileLogAllowEntry(dwEntry)) {FileLogAppend((wszFormat),(a),(b),(c),(d));}
#define FileLogA5(dwEntry,wszFormat,a,b,c,d,e)         if (FileLogAllowEntry(dwEntry)) {FileLogAppend((wszFormat),(a),(b),(c),(d),(e));}
#define FileLogA6(dwEntry,wszFormat,a,b,c,d,e,f)       if (FileLogAllowEntry(dwEntry)) {FileLogAppend((wszFormat),(a),(b),(c),(d),(e),(f));}
#define FileLogA7(dwEntry,wszFormat,a,b,c,d,e,f,g)     if (FileLogAllowEntry(dwEntry)) {FileLogAppend((wszFormat),(a),(b),(c),(d),(e),(f),(g));}
#define FileLogA8(dwEntry,wszFormat,a,b,c,d,e,f,g,h)   if (FileLogAllowEntry(dwEntry)) {FileLogAppend((wszFormat),(a),(b),(c),(d),(e),(f),(g),(h));}
#define FileLogA9(dwEntry,wszFormat,a,b,c,d,e,f,g,h,i) if (FileLogAllowEntry(dwEntry)) {FileLogAppend((wszFormat),(a),(b),(c),(d),(e),(f),(g),(h),(i));}

// usually shown
#define FL_Error                    0
#define FL_ThreadTrapWarn           1
#define FL_PollPeerWarn             2
#define FL_CreatePeerWarn           3
#define FL_DomHierWarn              4
#define FL_ManualPeerWarn           5
#define FL_TransResponseWarn        6
#define FL_PacketAuthCheck          7
#define FL_ListeningThrdWarn        8
#define FL_ControlProvWarn          9
#define FL_SelectSampWarn           10
#define FL_ParamChangeWarn          11
#define FL_ServicMainWarn           12
#define FL_PeerPollThrdWarn         13
#define FL_PacketCheck              14
#define FL_TimeZoneWarn             15
#define FL_TimeAdjustWarn           16
#define FL_SourceChangeWarn         17

#define FL_ManualPeerAnnounce       50
#define FL_PeerPollThrdAnnounce     51
#define FL_DomHierAnnounce          52
#define FL_ClockFilterAdd           53
#define FL_PollPeerAnnounce         54
#define FL_NetAddrDetectAnnounce    55
#define FL_TransResponseAnnounce    56
#define FL_ListeningThrdAnnounce    57
#define FL_UpdateNtpCliAnnounce     58
#define FL_NtpProvControlAnnounce   59
#define FL_ServiceControl           60
#define FL_ControlProvAnnounce      61
#define FL_ClockDisThrdAnnounce     62
#define FL_TimeSlipAnnounce         63
#define FL_ServiceMainAnnounce      64
#define FL_ParamChangeAnnounce      65
#define FL_TimeZoneAnnounce         66
#define FL_NetTopoChangeAnnounce    67
#define FL_SourceChangeAnnounce     68
#define FL_RpcAnnounce              69
#define FL_FallbackPeerAnnounce     70
#define FL_ResumeSuspendAnnounce    71
#define FL_GPUpdateAnnounce         72

// usually not shown
#define FL_ThreadTrapAnnounceLow    100
#define FL_PeerPollIntvDump         101
#define FL_ClockFilterDump          102
#define FL_PeerPollThrdAnnounceLow  103
#define FL_PacketCheck2             104
#define FL_ListeningThrdAnnounceLow 105
#define FL_ListeningThrdDumpPackets 106
#define FL_ClockDisThrdAnnounceLow  107
#define FL_SelectSampAnnounceLow    108
#define FL_SelectSampDump           109
#define FL_CollectSampDump          110
#define FL_DomHierAnnounceLow       111
#define FL_ReadConigAnnounceLow     112
#define FL_Win2KDetectAnnounceLow   113
#define FL_ReachabilityAnnounceLow  114

#endif //LOGGING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32tclnt\w32tclnt.cpp ===
//--------------------------------------------------------------------
// W32TClnt - implementation
// Copyright (C) Microsoft Corporation, 2000
//
// Created by: Louis Thomas (louisth), 2-10-00
//
// client side wrappers for w32time RPC calls
//

#include <windows.h>
#include "timeif_c.h"
#include "DebugWPrintf.h"
#include "ErrorHandling.h"
#include "W32TmConsts.h"


//--------------------------------------------------------------------
RPC_STATUS SetMyRpcSecurity(handle_t hBinding) {
    RPC_STATUS RpcStatus;

    // must be cleaned up
    WCHAR * wszServerPricipalName=NULL;

    RpcStatus=RpcMgmtInqServerPrincName(hBinding, RPC_C_AUTHN_GSS_NEGOTIATE, &wszServerPricipalName);
    if (RPC_S_OK!=RpcStatus) {
        goto error;
    }
    RpcStatus=RpcBindingSetAuthInfo(hBinding, wszServerPricipalName, RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, 
        RPC_C_AUTHN_GSS_NEGOTIATE, NULL, RPC_C_AUTHZ_NONE);

error:
    if (NULL!=wszServerPricipalName) {
        RpcStringFree(&wszServerPricipalName);
    }
    return RpcStatus;
}

//--------------------------------------------------------------------
RPC_STATUS W32TimeQueryProviderStatus(IN   LPCWSTR      wszServer, 
                                      IN   DWORD        dwFlags, 
                                      IN   LPWSTR       pwszProvider, 
                                      IN   DWORD        dwProviderType, 
                                      OUT  LPVOID      *ppProviderData)
{ 
    RPC_BINDING_HANDLE      hBinding;
    RPC_STATUS              err;
    W32TIME_PROVIDER_INFO  *pProviderInfo  = NULL;
    WCHAR                  *wszBinding;

    if (NULL == ppProviderData)
        return E_INVALIDARG; 

    //DebugWPrintf0(L"Trying \"" L"\\PIPE\\" wszW32TimeSharedProcRpcEndpointName L"\".\n");
    err=RpcStringBindingCompose(NULL, L"ncacn_np", (WCHAR *)wszServer, L"\\PIPE\\" wszW32TimeSharedProcRpcEndpointName, NULL, &wszBinding);
    if(!err) {

        err=RpcBindingFromStringBinding(wszBinding, &hBinding);
        RpcStringFree(&wszBinding);

        SetMyRpcSecurity(hBinding); // ignore retval

        if(!err) {
            // ready to try it
            __try {
                err=c_W32TimeQueryProviderStatus(hBinding, dwFlags, pwszProvider, &pProviderInfo); 
            } __except( EXCEPTION_EXECUTE_HANDLER ) {
                err=GetExceptionCode();
            }
            RpcBindingFree(&hBinding);
        }
    }

    // try our alternate name
    if (RPC_S_UNKNOWN_IF==err || RPC_S_SERVER_UNAVAILABLE==err) {
        //DebugWPrintf0(L"Trying \"" L"\\PIPE\\" wszW32TimeOwnProcRpcEndpointName L"\".\n");
        err=RpcStringBindingCompose(NULL, L"ncacn_np", (WCHAR *)wszServer, L"\\PIPE\\" wszW32TimeOwnProcRpcEndpointName, NULL, &wszBinding);
        if(!err) {

            err=RpcBindingFromStringBinding(wszBinding, &hBinding);
            RpcStringFree(&wszBinding);

            SetMyRpcSecurity(hBinding); // ignore retval

            if(!err) {
                // ready to try it
                __try {
                    err=c_W32TimeQueryProviderStatus(hBinding, dwFlags, pwszProvider, &pProviderInfo); 
                } __except( EXCEPTION_EXECUTE_HANDLER ) {
                    err=GetExceptionCode();
                }
                RpcBindingFree(&hBinding);
            }
        }
    }

    if (ERROR_SUCCESS == err) { 
        // We got a provider back, check to make sure we asked for the right provider type: 
        if (dwProviderType != pProviderInfo->ulProviderType) { 
            err = ERROR_INVALID_DATATYPE; 
        } else { 
            // Success!  Assign the out param. 
            switch (dwProviderType) 
            {
            case W32TIME_PROVIDER_TYPE_NTP:
                *ppProviderData = pProviderInfo->ProviderData.pNtpProviderData; 
                // NULL out the provider data so we don't delete it. 
                pProviderInfo->ProviderData.pNtpProviderData = NULL; 
                break; 
            case W32TIME_PROVIDER_TYPE_HARDWARE:
                *ppProviderData = pProviderInfo->ProviderData.pHardwareProviderData; 
                // NULL out the provider data so we don't delete it. 
                pProviderInfo->ProviderData.pHardwareProviderData = NULL; 
                break; 
            default:
                err = ERROR_INVALID_DATATYPE; 
            }
        }
    }

    if (NULL != pProviderInfo) { 
        if (NULL != pProviderInfo->ProviderData.pNtpProviderData) { 
            // pProviderInfo->pProviderData's allocation strategy is allocate(all_nodes)
            midl_user_free(pProviderInfo->ProviderData.pNtpProviderData); 
        }
        // pProviderInfo's allocation strategy is allocate(single_node)
        midl_user_free(pProviderInfo); 
    }

    return(err);
}



//--------------------------------------------------------------------
extern "C" DWORD W32TimeSyncNow(IN const WCHAR * wszServer, IN unsigned long ulWaitFlag, IN unsigned long ulFlags) {
    WCHAR * wszBinding;
    RPC_STATUS err;
    RPC_BINDING_HANDLE hBinding;

    //DebugWPrintf0(L"Trying \"" L"\\PIPE\\" wszW32TimeSharedProcRpcEndpointName L"\".\n");
    err=RpcStringBindingCompose(NULL, L"ncacn_np", (WCHAR *)wszServer, L"\\PIPE\\" wszW32TimeSharedProcRpcEndpointName, NULL, &wszBinding);
    if(!err) {

        err=RpcBindingFromStringBinding(wszBinding, &hBinding);
        RpcStringFree(&wszBinding);

        SetMyRpcSecurity(hBinding); // ignore retval

        if(!err) {
            // ready to try it
            __try {
                err=c_W32TimeSync(hBinding, ulWaitFlag, ulFlags);
            } __except( EXCEPTION_EXECUTE_HANDLER ) {
                err=GetExceptionCode();
            }
            RpcBindingFree(&hBinding);
        }
    }

    // try our alternate name
    if (RPC_S_UNKNOWN_IF==err || RPC_S_SERVER_UNAVAILABLE==err) {
        //DebugWPrintf0(L"Trying \"" L"\\PIPE\\" wszW32TimeOwnProcRpcEndpointName L"\".\n");
        err=RpcStringBindingCompose(NULL, L"ncacn_np", (WCHAR *)wszServer, L"\\PIPE\\" wszW32TimeOwnProcRpcEndpointName, NULL, &wszBinding);
        if(!err) {

            err=RpcBindingFromStringBinding(wszBinding, &hBinding);
            RpcStringFree(&wszBinding);

            SetMyRpcSecurity(hBinding); // ignore retval

            if(!err) {
                // ready to try it
                __try {
                    err=c_W32TimeSync(hBinding, ulWaitFlag, ulFlags);
                } __except( EXCEPTION_EXECUTE_HANDLER ) {
                    err=GetExceptionCode();
                }
                RpcBindingFree(&hBinding);
            }
        }
    }

    return(err);
}

//--------------------------------------------------------------------
// Netlogon can call this function and get our service bits if we start
// before they do. Note that we tell and they ask, and depending upon
// who started up first one of the two will be succesful. Either way,
// the flags will be set correctly.
extern "C" DWORD W32TimeGetNetlogonServiceBits(IN const WCHAR * wszServer, OUT unsigned long * pulBits) {
    WCHAR * wszBinding;
    RPC_STATUS err;
    RPC_BINDING_HANDLE hBinding;

    if (NULL==pulBits) {
        return ERROR_INVALID_PARAMETER;
    }

    //DebugWPrintf0(L"Trying \"" L"\\PIPE\\" wszW32TimeSharedProcRpcEndpointName L"\".\n");
    err=RpcStringBindingCompose(NULL, L"ncacn_np", (WCHAR *)wszServer, L"\\PIPE\\" wszW32TimeSharedProcRpcEndpointName, NULL, &wszBinding);
    if(!err){

        err=RpcBindingFromStringBinding(wszBinding, &hBinding);
        RpcStringFree(&wszBinding);

        if(!err) {
            // ready to try it
            __try {
                *pulBits=c_W32TimeGetNetlogonServiceBits(hBinding);
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                err=GetExceptionCode();
            }
            RpcBindingFree(&hBinding);
        }
    }

    // try our alternate name
    if (RPC_S_UNKNOWN_IF==err || RPC_S_SERVER_UNAVAILABLE==err) {
        //DebugWPrintf0(L"Trying \"" L"\\PIPE\\" wszW32TimeOwnProcRpcEndpointName L"\".\n");
        err=RpcStringBindingCompose(NULL, L"ncacn_np", (WCHAR *)wszServer, L"\\PIPE\\" wszW32TimeOwnProcRpcEndpointName, NULL, &wszBinding);
        if(!err){

            err=RpcBindingFromStringBinding(wszBinding, &hBinding);
            RpcStringFree(&wszBinding);

            if(!err) {
                // ready to try it
                __try {
                    *pulBits=c_W32TimeGetNetlogonServiceBits(hBinding);
                } __except(EXCEPTION_EXECUTE_HANDLER) {
                    err=GetExceptionCode();
                }
                RpcBindingFree(&hBinding);
            }
        }
    }
    
    return(err);
}

//--------------------------------------------------------------------
extern "C" DWORD W32TimeQueryHardwareProviderStatus(IN   const WCHAR *                     pwszServer, 
                                                    IN   DWORD                             dwFlags, 
                                                    IN   LPWSTR                            pwszProvider, 
                                                    OUT  W32TIME_HARDWARE_PROVIDER_DATA  **ppProviderData)
{
    return W32TimeQueryProviderStatus
        (pwszServer, 
         dwFlags, 
         pwszProvider, 
         W32TIME_PROVIDER_TYPE_HARDWARE,
         (LPVOID *)ppProviderData); 
    
    
}

//--------------------------------------------------------------------
extern "C" DWORD W32TimeQueryNTPProviderStatus(IN   LPCWSTR                      pwszServer, 
                                               IN   DWORD                        dwFlags, 
                                               IN   LPWSTR                       pwszProvider, 
                                               OUT  W32TIME_NTP_PROVIDER_DATA  **ppProviderData)
{
    return W32TimeQueryProviderStatus
        (pwszServer, 
         dwFlags, 
         pwszProvider, 
         W32TIME_PROVIDER_TYPE_NTP, 
         (LPVOID *)ppProviderData); 
}

//--------------------------------------------------------------------
extern "C" void W32TimeBufferFree(IN LPVOID pvBuffer)
{
    midl_user_free(pvBuffer); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32time\mycritsec.cpp ===
//--------------------------------------------------------------------
// MyCritSec - implementation
// Copyright (C) Microsoft Corporation, 2000
//
// Created by: Louis Thomas (louisth), 02-03-00
//
// exception handling wrapper for critical sections
//

#include "pch.h" // precompiled headers

//####################################################################
// module public functions

//--------------------------------------------------------------------
HRESULT myHExceptionCode(EXCEPTION_POINTERS * pep) {
    HRESULT hr=pep->ExceptionRecord->ExceptionCode;
    if (!FAILED(hr)) {
        hr=HRESULT_FROM_WIN32(hr);
    }
    return hr;
}


//--------------------------------------------------------------------
HRESULT myEnterCriticalSection(CRITICAL_SECTION * pcs) {
    HRESULT hr;

    _BeginTryWith(hr) {
        EnterCriticalSection(pcs);
    } _TrapException(hr);
    _JumpIfError(hr, error, "EnterCriticalSection");

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT myTryEnterCriticalSection(CRITICAL_SECTION * pcs, BOOL * pbEntered) {
    BOOL     bEntered = FALSE;
    HRESULT  hr;

    _BeginTryWith(hr) {
        bEntered = TryEnterCriticalSection(pcs);
    } _TrapException(hr);
    _JumpIfError(hr, error, "TryEnterCriticalSection");

    *pbEntered = bEntered; 
    hr = S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT myLeaveCriticalSection(CRITICAL_SECTION * pcs) {
    HRESULT hr;

    _BeginTryWith(hr) {
        LeaveCriticalSection(pcs);
    } _TrapException(hr);
    _JumpIfError(hr, error, "LeaveCriticalSection");

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT myInitializeCriticalSection(CRITICAL_SECTION * pcs) {
    HRESULT hr;

    _BeginTryWith(hr) {
        InitializeCriticalSection(pcs);
    } _TrapException(hr);
    _JumpIfError(hr, error, "InitializeCriticalSection");

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT myRtlInitializeResource(IN PRTL_RESOURCE Resource) { 
    HRESULT hr; 
    
    _BeginTryWith(hr) { 
	RtlInitializeResource(Resource); 
    } _TrapException(hr); 
    _JumpIfError(hr, error, "RtlInitializeResource"); 

    hr = S_OK; 
 error:
    return hr; 
}


//--------------------------------------------------------------------
HRESULT myRtlAcquireResourceExclusive(IN PRTL_RESOURCE Resource, IN BOOLEAN Wait, OUT BOOLEAN *pResult) { 
    HRESULT hr; 
    
    _BeginTryWith(hr) { 
	*pResult = RtlAcquireResourceExclusive(Resource, Wait); 
    } _TrapException(hr); 
    _JumpIfError(hr, error, "RtlAcquireResourceExclusive"); 

    hr = S_OK; 
 error:
    return hr; 
}

//--------------------------------------------------------------------
HRESULT myRtlAcquireResourceShared(IN PRTL_RESOURCE Resource, IN BOOLEAN Wait, OUT BOOLEAN *pResult) { 
    HRESULT hr; 
    
    _BeginTryWith(hr) { 
	*pResult = RtlAcquireResourceShared(Resource, Wait); 
    } _TrapException(hr); 
    _JumpIfError(hr, error, "RtlAcquireResourceShared"); 

    hr = S_OK; 
 error:
    return hr; 
}

//--------------------------------------------------------------------
HRESULT myRtlReleaseResource(IN PRTL_RESOURCE Resource) { 
    HRESULT hr; 
    
    _BeginTryWith(hr) { 
	RtlReleaseResource(Resource); 
    } _TrapException(hr); 
    _JumpIfError(hr, error, "RtlReleaseResource"); 

    hr = S_OK; 
 error:
    return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32time\logging.cpp ===
//depot/Lab03_N/ds/security/services/w32time/w32time/Logging.cpp#8 - edit change 10350 (text)
//--------------------------------------------------------------------
// Logging - implementation
// Copyright (C) Microsoft Corporation, 2000
//
// Created by: Louis Thomas (louisth), 02-01-00
//
// routines to do logging to the event log and to a file
//

#include "pch.h" // precompiled headers

#include "EndianSwap.inl"

//--------------------------------------------------------------------
// structures

struct LogEntryRange {
    DWORD            dwStart;
    DWORD            dwLength;
    LogEntryRange   *plerNext;
};

struct FileLogConfig {
    DWORD           dwFlags; 
    DWORD           dwFileSize; 
    LogEntryRange  *plerAllowedEntries;
    WCHAR          *wszLogFileName;
};

struct FileLogBuffer { 
    WCHAR          *wszText; 
    OVERLAPPED      overlapped; 
    FileLogBuffer  *pflbNext; 
};

struct FileLogState {
    DWORD               dwFlags; 
    unsigned __int64    qwFileSize; 
    LogEntryRange      *plerAllowedEntries;
    WCHAR              *wszLogFileName;
    HANDLE              hLogFile;
    unsigned __int64    qwFilePointer; 

    FileLogBuffer      *pflbHead; 
    FileLogBuffer      *pflbTail; 

    CRITICAL_SECTION    csState;
};

class SourceChangeLogEntry { 
public:
    ~SourceChangeLogEntry() { 
        if (NULL != m_pwszName) { LocalFree(m_pwszName); } 
    }

    static HRESULT New(IN LPWSTR pwszName, OUT SourceChangeLogEntry ** ppscle) { 
        HRESULT                hr;
        LPWSTR                 pwsz  = NULL; 
        SourceChangeLogEntry  *pscle = NULL;

        pwsz = (LPWSTR)LocalAlloc(LPTR, (wcslen(pwszName) + 1) * sizeof(WCHAR)); 
        _JumpIfOutOfMemory(hr, error, pwsz); 
        wcscpy(pwsz, pwszName); 

        pscle = new SourceChangeLogEntry(pwsz); 
        _JumpIfOutOfMemory(hr, error, pscle); 
        
        *ppscle = pscle; 
        pscle = NULL; 
        pwsz = NULL; 
        hr = S_OK; 
    error:
        if (NULL != pwsz) { LocalFree(pwsz); } 
        if (NULL != pscle) { delete (pscle); } 
        return hr; 
    }

    BOOL operator==(const SourceChangeLogEntry & scle) { 
        if (NULL == m_pwszName) {
            return NULL == scle.m_pwszName; 
        } else { 
            return 0 == wcscmp(m_pwszName, scle.m_pwszName); 
        }
    }
private:
    SourceChangeLogEntry(LPWSTR pwszName) : m_pwszName(pwszName) { } 

    SourceChangeLogEntry();
    SourceChangeLogEntry(const SourceChangeLogEntry &); 
    SourceChangeLogEntry & operator=(const SourceChangeLogEntry &); 
    LPWSTR m_pwszName; 
};

typedef AutoPtr<SourceChangeLogEntry> SCPtr; 
typedef vector<SCPtr>                 SCPtrVec; 
typedef SCPtrVec::iterator            SCPtrIter; 

//--------------------------------------------------------------------
// globals
MODULEPRIVATE FileLogState  *g_pflstate;
MODULEPRIVATE SCPtrVec      *g_pscvec; 

//--------------------------------------------------------------------
// constants

// The amount of time we allow for an asynchronous file write to complete:
const DWORD WRITE_ENTRY_TIMEOUT  = 3000;

//####################################################################
// module private
//--------------------------------------------------------------------
MODULEPRIVATE void WriteCurrentFilePos(OVERLAPPED *po) { 
    po->Offset     = static_cast<DWORD>(g_pflstate->qwFilePointer & 0xFFFFFFFF); 
    po->OffsetHigh = static_cast<DWORD>(g_pflstate->qwFilePointer >> 32); 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT MakeFileLogBuffer(LPWSTR pwszEntry, FileLogBuffer **ppflb) { 
    FileLogBuffer  *pflb; 
    HRESULT         hr; 

    pflb = (FileLogBuffer *)LocalAlloc(LPTR, sizeof(FileLogBuffer)); 
    _JumpIfOutOfMemory(hr, error, pflb); 

    pflb->overlapped.hEvent = CreateEvent(NULL/*security*/, TRUE/*manual*/, FALSE/*state*/, NULL/*name*/);
    if (NULL == pflb->overlapped.hEvent) { 
        _JumpLastError(hr, error, "CreateEvent");
    }
    WriteCurrentFilePos(&(pflb->overlapped)); 
    pflb->wszText = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(pwszEntry)+1)); 
    _JumpIfOutOfMemory(hr, error, pflb->wszText); 
    wcscpy(pflb->wszText, pwszEntry); 
    
    *ppflb = pflb; 
    pflb = NULL; 
    hr = S_OK; 
 error:
    if (NULL != pflb) { 
        if (NULL != pflb->overlapped.hEvent) { CloseHandle(pflb->overlapped.hEvent); } 
        LocalFree(pflb); 
    } 
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE void FreeFileLogBuffer(FileLogBuffer *pflb) { 
    if (NULL != pflb) { 
        if (NULL != pflb->overlapped.hEvent) { CloseHandle(pflb->overlapped.hEvent); } 
        if (NULL != pflb->wszText)           { LocalFree(pflb->wszText); }
        LocalFree(pflb); 
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT WaitForFileLogBuffer(FileLogBuffer *pflb, DWORD dwTimeout) { 
    DWORD           dwWaitResult; 
    HRESULT         hr; 

    dwWaitResult = WaitForSingleObject(pflb->overlapped.hEvent, dwTimeout); 
    switch (dwWaitResult) { 
    case WAIT_OBJECT_0: 
        break; 
    case WAIT_TIMEOUT:  // Timeout:  shouldn't be waiting this long.
        hr = HRESULT_FROM_WIN32(ERROR_TIMEOUT); 
        _JumpError(hr, error, "WaitForSingleObject"); 
    default:
        hr = HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "WaitForSingleObject"); 
    }
    
    hr = S_OK; 
 error:
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT FreeOneFileLogBuffer(DWORD dwTimeout) { 
    HRESULT hr; 

    hr = WaitForFileLogBuffer(g_pflstate->pflbHead, dwTimeout); 
    _JumpIfError(hr, error, "WaitForFileLogBuffer"); 
    
    if (S_OK == hr) { 
        FileLogBuffer *pflb = g_pflstate->pflbHead; 
        g_pflstate->pflbHead = g_pflstate->pflbHead->pflbNext; 
        FreeFileLogBuffer(pflb); 
        if (NULL == g_pflstate->pflbHead) { 
            g_pflstate->pflbTail = NULL; 
        }
    }

    hr = S_OK; 
 error:
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE void FreeLogEntryRangeChain(LogEntryRange * pler) {
    while (NULL!=pler) {
        LogEntryRange * plerTemp=pler;
        pler=pler->plerNext;
        LocalFree(plerTemp);
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE void FreeFileLogConfig(FileLogConfig * pflc) {
    if (NULL!=pflc->plerAllowedEntries) {
        FreeLogEntryRangeChain(pflc->plerAllowedEntries);
    }
    if (NULL!=pflc->wszLogFileName) {
        LocalFree(pflc->wszLogFileName);
    }
    LocalFree(pflc);
}

//--------------------------------------------------------------------
MODULEPRIVATE void EmptyAllBuffers() {
    HRESULT hr; 

    while (NULL != g_pflstate->pflbHead) { 
        FreeOneFileLogBuffer(INFINITE); 
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT AddRegionToLogEntryRangeChain(LogEntryRange ** pplerHead, DWORD dwStart, DWORD dwLength) {
    HRESULT hr;
    LogEntryRange ** pplerPrev;
    LogEntryRange * plerStart;

    // find the range this range starts in
    pplerPrev=pplerHead;
    plerStart=*pplerPrev;
    while (NULL!=plerStart) {
        if (dwStart>=plerStart->dwStart && dwStart<=plerStart->dwStart+plerStart->dwLength) {
            // we will extend this range
            break;
        } else if (dwStart<plerStart->dwStart) {
            // we need to insert before this range, so stop now
            plerStart=NULL;
            break;
        }
        pplerPrev=&plerStart->plerNext;
        plerStart=*pplerPrev;
    }

    if (NULL!=plerStart) {
        // extend this range forward
        if (plerStart->dwLength<dwStart-plerStart->dwStart+dwLength) {
            plerStart->dwLength=dwStart-plerStart->dwStart+dwLength;
        }

    } else if (NULL!=*pplerPrev && (*pplerPrev)->dwStart<=dwStart+dwLength) {

        // we cannot extend an existing range forward, but we can extend a range backward
        LogEntryRange * plerNext=(*pplerPrev);
        if (dwLength<plerNext->dwStart-dwStart+plerNext->dwLength) {
            dwLength=plerNext->dwStart-dwStart+plerNext->dwLength;
        }
        plerStart=plerNext;
        plerStart->dwLength=dwLength;
        plerStart->dwStart=dwStart;

    } else {
        // we need to make a new range
        plerStart=(LogEntryRange *)LocalAlloc(LPTR, sizeof(LogEntryRange));
        _JumpIfOutOfMemory(hr, error, plerStart);

        plerStart->plerNext=*pplerPrev;
        plerStart->dwStart=dwStart;
        plerStart->dwLength=dwLength;

        *pplerPrev=plerStart;
    }

    // see if we can merge with the next
    while (NULL!=plerStart->plerNext && plerStart->plerNext->dwStart <= plerStart->dwStart + plerStart->dwLength) {
        LogEntryRange * plerNext=plerStart->plerNext;
        // merge
        if (plerStart->dwLength < plerNext->dwStart - plerStart->dwStart + plerNext->dwLength) {
            plerStart->dwLength=plerNext->dwStart - plerStart->dwStart + plerNext->dwLength;
        }
        // delete
        plerStart->plerNext=plerNext->plerNext;
        LocalFree(plerNext);
    }

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE void WriteLogHeader(void) {
    unsigned __int64 teTime;

    AccurateGetSystemTime(&teTime);
    FileLogAdd(L"---------- Log File Opened -----------------\n");
}

//--------------------------------------------------------------------
MODULEPRIVATE void WriteLogFooter(void) {
    unsigned __int64 teTime;

    AccurateGetSystemTime(&teTime);
    FileLogAdd(L"---------- Log File Closed -----------------\n");
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT WriteFileLogBuffer(HANDLE hFile, FileLogBuffer * pflb) { 
    BOOL    fResult; 
    DWORD   dwBytesToWrite; 
    DWORD   dwErr; 
    HRESULT hr;

    dwBytesToWrite = sizeof(WCHAR)*(wcslen(pflb->wszText)); 

    while (true) { 
        fResult = WriteFile
            (hFile, 
             (LPCVOID)pflb->wszText, 
             dwBytesToWrite, 
             NULL, 
             &(pflb->overlapped)); 
        if (fResult) { break; }  // Success
        else { 
            dwErr = GetLastError(); 
            switch (dwErr) { 
            case ERROR_INVALID_USER_BUFFER:
            case ERROR_NOT_ENOUGH_MEMORY: 
                // Probably just have too many asyncronous I/O requests pending.  
                // Let some of them finish and try again:
                if (NULL == g_pflstate->pflbHead) { 
                    // No requests to free!
                    hr = HRESULT_FROM_WIN32(dwErr); 
                } else { 
                    HRESULT hr2 = FreeOneFileLogBuffer(WRITE_ENTRY_TIMEOUT); 
                    if (FAILED(hr2)) { 
                        _IgnoreError(hr2, "FreeOneFileLogBuffer");
                        hr = HRESULT_FROM_WIN32(dwErr); 
                    } else { 
                        // We've freed up some resources.  Try again...
                        hr = S_OK; 
                    }
                }
                _JumpIfError(hr, error, "WriteFile"); 

                // We've freed up some resources, let's try again ... 
                break;

            case ERROR_IO_PENDING:
                // The I/O operation has been successfully started. 
                goto success; 

            default:
                // An unexpected error: 
                hr = HRESULT_FROM_WIN32(dwErr); 
                _JumpError(hr, error, "WriteFile"); 
            }
        }
    }

 success:
    g_pflstate->qwFilePointer += dwBytesToWrite; 
    if (0 != g_pflstate->qwFileSize) { 
        // circular logging is enabled
        g_pflstate->qwFilePointer %= g_pflstate->qwFileSize; 
    }

    // Append this FileLogBuffer to the list of pending I/O operations: 
    if (NULL != g_pflstate->pflbTail) { 
        g_pflstate->pflbTail->pflbNext = pflb; 
        g_pflstate->pflbTail           = pflb; 
    } else { 
        g_pflstate->pflbHead = pflb; 
        g_pflstate->pflbTail = pflb; 
    }

    hr = S_OK;
 error:
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE void AbortCloseFile(HRESULT hr2) {
    HRESULT hr;
    const WCHAR * rgwszStrings[2]={
	L"", 
        NULL
    };

    // must be cleaned up
    WCHAR * wszError=NULL;

    hr=myEnterCriticalSection(&g_pflstate->csState);
    _IgnoreIfError(hr, "myEnterCriticalSection");

    _MyAssert(NULL!=g_pflstate->hLogFile);
    DebugWPrintf1(L"Log file '%s' had errors. File closed.\n", g_pflstate->wszLogFileName);
    CloseHandle(g_pflstate->hLogFile);
    g_pflstate->hLogFile=NULL;
    LocalFree(g_pflstate->wszLogFileName);
    g_pflstate->wszLogFileName=NULL;
    EmptyAllBuffers();

    hr=myLeaveCriticalSection(&g_pflstate->csState);
    _IgnoreIfError(hr, "myLeaveCriticalSection");

    // get the friendly error message
    hr=GetSystemErrorString(hr2, &wszError);
    _JumpIfError(hr, error, "GetSystemErrorString");

    // log the event
    rgwszStrings[1]=wszError;
    DebugWPrintf1(L"Logging error: Logging was requested, but the time service encountered an error while trying to write to the log file. The error was: %s\n", wszError);
    hr=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_FILELOG_WRITE_FAILED, 2, rgwszStrings);
    _JumpIfError(hr, error, "MyLogEvent");

error:
    if (NULL!=wszError) {
        LocalFree(wszError);
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT FlushCloseFile(void) {
    HRESULT hr;

    WriteLogFooter();
    EmptyAllBuffers(); 
    CloseHandle(g_pflstate->hLogFile);
    g_pflstate->hLogFile = NULL;
    LocalFree(g_pflstate->wszLogFileName);
    g_pflstate->wszLogFileName = NULL;

    hr = S_OK;
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT ReadFileLogConfig(FileLogConfig ** ppflc) {
    HRESULT hr;
    DWORD dwError;
    DWORD dwSize;
    DWORD dwType;
    WCHAR * wszEntryRange;

    // must be cleaned up
    LogEntryRange * plerAllowedEntries=NULL;
    FileLogConfig * pflc=NULL;
    HKEY hkConfig=NULL;
    WCHAR * wszAllowedEntries=NULL;

    // initailize out params
    *ppflc=NULL;

    // allocate a structure to hold the config data
    pflc=(FileLogConfig *)LocalAlloc(LPTR, sizeof(FileLogConfig));
    _JumpIfOutOfMemory(hr, error, pflc);

    // get our config key
    dwError=RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszFileLogRegKeyConfig, 0, KEY_READ, &hkConfig);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _IgnoreErrorStr(hr, "RegOpenKeyEx", wszFileLogRegKeyConfig);
        goto done;
    }

    // get the AllowedEntries
    dwError=RegQueryValueEx(hkConfig, wszFileLogRegValueFileLogEntries, NULL, &dwType, NULL, &dwSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _IgnoreErrorStr(hr, "RegQueryValueEx", wszFileLogRegValueFileLogEntries);
    } else if (REG_SZ!=dwType) {
        hr=HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH);
        _IgnoreErrorStr(hr, "RegQueryValueEx", wszFileLogRegValueFileLogEntries);
    } else {
        wszAllowedEntries=(WCHAR *)LocalAlloc(LPTR, dwSize);
        _JumpIfOutOfMemory(hr, error, wszAllowedEntries);
        dwError=RegQueryValueEx(hkConfig, wszFileLogRegValueFileLogEntries, NULL, &dwType, (BYTE *)wszAllowedEntries, &dwSize);
        if (ERROR_SUCCESS!=dwError) {
            hr=HRESULT_FROM_WIN32(dwError);
            _JumpErrorStr(hr, error, "RegQueryValueEx", wszFileLogRegValueFileLogEntries);
        }

        // now, parse the string
        wszEntryRange=wszAllowedEntries+wcscspn(wszAllowedEntries, L"0123456789");
        while (L'\0'!=wszEntryRange[0]) {

            DWORD dwStart;
            DWORD dwStop;
            dwStart=wcstoul(wszEntryRange, &wszEntryRange, 0);
            if (L'-'!=wszEntryRange[0]) {
                dwStop=dwStart;
            } else {
                wszEntryRange++;
                dwStop=wcstoul(wszEntryRange, &wszEntryRange, 0);
            }
            DWORD dwLen;
            if (dwStop<dwStart) {
                dwLen=1;
            } else {
                dwLen=dwStop-dwStart+1;
            }
            hr=AddRegionToLogEntryRangeChain(&pflc->plerAllowedEntries, dwStart, dwLen);
            _JumpIfError(hr, error, "AddRegionToLogEntryRangeChain");

            wszEntryRange=wszEntryRange+wcscspn(wszEntryRange, L"0123456789");
        } // <- end string parsing loop
    } // <- end if value 'FileLogEntries' available

    // get the file name
    dwError=RegQueryValueEx(hkConfig, wszFileLogRegValueFileLogName, NULL, &dwType, NULL, &dwSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _IgnoreErrorStr(hr, "RegQueryValueEx", wszFileLogRegValueFileLogName);
    } else if (REG_SZ!=dwType) {
        hr=HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH);
        _IgnoreErrorStr(hr, "RegQueryValueEx", wszFileLogRegValueFileLogEntries);
    } else {
        pflc->wszLogFileName=(WCHAR *)LocalAlloc(LPTR, dwSize);
        _JumpIfOutOfMemory(hr, error, pflc->wszLogFileName);
        dwError=RegQueryValueEx(hkConfig, wszFileLogRegValueFileLogName, NULL, &dwType, (BYTE *)pflc->wszLogFileName, &dwSize);
        if (ERROR_SUCCESS!=dwError) {
            hr=HRESULT_FROM_WIN32(dwError);
            _JumpErrorStr(hr, error, "RegQueryValueEx", wszFileLogRegValueFileLogName);
        }
    }

    // get the format flags
    dwSize = sizeof(DWORD); 
    dwError=RegQueryValueEx(hkConfig, wszFileLogRegValueFileLogFlags, NULL, &dwType, (BYTE *)&(pflc->dwFlags), &dwSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _IgnoreErrorStr(hr, "RegQueryValueEx", wszFileLogRegValueFileLogFlags);
    } else if (REG_DWORD!=dwType) {
        hr=HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH);
        _IgnoreErrorStr(hr, "RegQueryValueEx", wszFileLogRegValueFileLogFlags);
    } 
    
    // get the file log size (used for circular logging)
    dwSize = sizeof(DWORD); 
    dwError=RegQueryValueEx(hkConfig, wszFileLogRegValueFileLogSize, NULL, &dwType, (BYTE *)&(pflc->dwFileSize), &dwSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _IgnoreErrorStr(hr, "RegQueryValueEx", wszFileLogRegValueFileLogSize);
    } else if (REG_DWORD!=dwType) {
        hr=HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH);
        _IgnoreErrorStr(hr, "RegQueryValueEx", wszFileLogRegValueFileLogSize);
    } 

done:
    hr=S_OK;
    *ppflc=pflc;
    pflc=NULL;

error:
    if (NULL!=pflc) {
        FreeFileLogConfig(pflc);
    }
    if (NULL!=hkConfig) {
        RegCloseKey(hkConfig);
    }
    if (NULL!=wszAllowedEntries) {
        LocalFree(wszAllowedEntries);
    }
    return hr;
}


//####################################################################
// module public functions


//--------------------------------------------------------------------
HRESULT MyLogEvent(WORD wType, DWORD dwEventID, unsigned int nStrings, const WCHAR ** rgwszStrings) {
    HRESULT hr;

    // must be cleaned up
    HANDLE hEventLog=NULL;

    hEventLog=RegisterEventSource(NULL, L"W32Time");
    if (NULL==hEventLog) {
        _JumpLastError(hr, error, "RegisterEventSource");
    }
    if (!ReportEvent(hEventLog, wType, 0/*category*/, dwEventID, NULL, (WORD)nStrings, 0, rgwszStrings, NULL)) {
        _JumpLastError(hr, error, "ReportEvent");
    }

    hr=S_OK;
error:
    if (NULL!=hEventLog) {
        DeregisterEventSource(hEventLog);
    }
    return hr;
}


//--------------------------------------------------------------------
HRESULT MyLogSourceChangeEvent(LPWSTR pwszSource) { 
    BOOL                   bEnteredCriticalSection = false; 
    HRESULT                hr;
    SourceChangeLogEntry  *pscle = NULL; 

    hr=myEnterCriticalSection(&g_pflstate->csState);
    _JumpIfError(hr, error, "myEnterCriticalSection");
    bEnteredCriticalSection = true; 
    
    hr = SourceChangeLogEntry::New(pwszSource, &pscle); 
    _JumpIfError(hr, error, "SourceChangeLogEntry.New"); 

    {
        SCPtr scp(pscle); 
        pscle = NULL;  // pscle will now be deleted when scp is destructed. 

        SCPtrIter scExists = find(g_pscvec->begin(), g_pscvec->end(), scp); 
        if (scExists == g_pscvec->end()) { 
            // This is the first time we've done a sync from this source.  Log the event.  
            WCHAR * rgwszStrings[1] = { pwszSource };
            FileLog1(FL_SourceChangeAnnounce, L"Logging information: The time service is now synchronizing the system time with the time source %s.\n", rgwszStrings[0]);
            hr = MyLogEvent(EVENTLOG_INFORMATION_TYPE, MSG_TIME_SOURCE_CHOSEN, 1, (const WCHAR **)rgwszStrings);
            _JumpIfError(hr, error, "MyLogEvent");

            // Add this source change log event to the list:
            _SafeStlCall(g_pscvec->push_back(scp), hr, error, "g_pscvec->push_back");
        } else { 
            // We've already logged syncing from this source -- 
            // don't log it again (we'd fill up the event log).  
        }
    }

    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
        hr=myLeaveCriticalSection(&g_pflstate->csState);
        _IgnoreIfError(hr, "myLeaveCriticalSection");
        bEnteredCriticalSection = false; 
    }
    if (NULL != pscle) { delete (pscle); }
    return hr; 
}


//--------------------------------------------------------------------
HRESULT MyResetSourceChangeLog() { 
    BOOL     bEnteredCriticalSection = false; 
    HRESULT  hr; 

    hr=myEnterCriticalSection(&g_pflstate->csState);
    _JumpIfError(hr, error, "myEnterCriticalSection");
    bEnteredCriticalSection = true; 

    g_pscvec->clear(); 

    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
        hr=myLeaveCriticalSection(&g_pflstate->csState);
        _IgnoreIfError(hr, "myLeaveCriticalSection");
        bEnteredCriticalSection = false; 
    }
    return hr; 
}

//--------------------------------------------------------------------
HRESULT FileLogBegin(void) {
    HRESULT hr;

    g_pflstate = NULL; 
    g_pscvec   = NULL; 

    g_pflstate = (FileLogState *)LocalAlloc(LPTR, sizeof(FileLogState)); 
    _JumpIfOutOfMemory(hr, error, g_pflstate); 

    g_pscvec = (SCPtrVec *)new SCPtrVec; 
    _JumpIfOutOfMemory(hr, error, g_pscvec); 

    hr = myInitializeCriticalSection(&g_pflstate->csState);
    _JumpIfError(hr, error, "myInitializeCriticalSection");

    // read the initial configuration
    hr = UpdateFileLogConfig(); // returns only non-ignorable errors
    _JumpIfError(hr, error, "UpdateFileLogConfig");

    hr = S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT FileLogResume(void) { 
    bool     bEnteredCriticalSection = false; 
    HRESULT  hr; 

    hr = myEnterCriticalSection(&g_pflstate->csState);
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    hr = UpdateFileLogConfig(); 
    _JumpIfError(hr, error, "UpdateFileLogConfig"); 

    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
        HRESULT hr2 = myLeaveCriticalSection(&g_pflstate->csState); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }
    return hr; 
}

//--------------------------------------------------------------------
HRESULT FileLogSuspend(void) { 
    bool     bEnteredCriticalSection = false; 
    HRESULT  hr; 

    hr = myEnterCriticalSection(&g_pflstate->csState);
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    if (NULL != g_pflstate->hLogFile) { 
         hr=FlushCloseFile();
        _JumpIfError(hr, error, "FlushCloseFile");
    }

    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
        HRESULT hr2 = myLeaveCriticalSection(&g_pflstate->csState); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }
    return hr; 
}

//--------------------------------------------------------------------
// NOTE: FileLogEnd cannot be synchronized, so all other threads must be 
//       stopped before calling this method. 
// 
void FileLogEnd(void) {
    if (NULL != g_pflstate) { 
        if (NULL != g_pflstate->hLogFile) {
            HRESULT hr = FlushCloseFile();
            _IgnoreIfError(hr, "FlushCloseFile");
        }
        if (NULL != g_pflstate->plerAllowedEntries) { 
            FreeLogEntryRangeChain(g_pflstate->plerAllowedEntries); 
            g_pflstate->plerAllowedEntries = NULL; 
        }
        DeleteCriticalSection(&g_pflstate->csState);
        LocalFree(g_pflstate); 
        g_pflstate = NULL; 
    }
    if (NULL != g_pscvec) { 
        delete (g_pscvec); 
        g_pscvec = NULL; 
    }

}

//--------------------------------------------------------------------
bool FileLogAllowEntry(DWORD dwEntry) {
    bool bAllow=false;
    HRESULT hr;
    LogEntryRange * pler;

    _BeginTryWith(hr) {
        EnterCriticalSection(&g_pflstate->csState);

        pler=g_pflstate->plerAllowedEntries;
        while (NULL!=pler) {
            if (pler->dwStart>dwEntry) {
                break;
            } else if (pler->dwStart+pler->dwLength>dwEntry) {
                bAllow=true;
                break;
            }
            pler=pler->plerNext;
        }

        LeaveCriticalSection(&g_pflstate->csState);
    } _TrapException(hr);
    _IgnoreIfError(hr, "Enter/LeaveCriticalSection");
    
    return bAllow;   
}

//--------------------------------------------------------------------
void FileLogAddEx(bool bAppend, const WCHAR * wszFormat, va_list vlArgs) {
    bool               bEnteredCriticalSection = false;
    bool               bMultiLine; 
    DWORD              dwThreadID              = GetCurrentThreadId();
    HRESULT            hr;
    signed int         nCharsWritten;
    unsigned int       nLen;
    unsigned __int64   teTime; 
    WCHAR              wszBuf[1024];
    WCHAR              wszHeader[1024]; 

    // must be cleaned up
    FileLogBuffer     *pflb        = NULL; 


#ifdef DBG  
    //  *  In debug builds, expand the string first, and log to screen,
    //  *  then stop if file not open.
    // expand substuitutions to our buffer
    nCharsWritten=_vsnwprintf(wszBuf, ARRAYSIZE(wszBuf), wszFormat, vlArgs);
    
    // if the buffer overflowed, mark it and ignore the overflow.
    if (-1==nCharsWritten || ARRAYSIZE(wszBuf)==nCharsWritten) {
        wszBuf[ARRAYSIZE(wszBuf)-3]=L'#';
        wszBuf[ARRAYSIZE(wszBuf)-2]=L'\n';
        wszBuf[ARRAYSIZE(wszBuf)-1]=L'\0';
    }
    DebugWPrintf1(L"%s", wszBuf);
#endif // DBG

    hr=myEnterCriticalSection(&g_pflstate->csState);
    _JumpIfError(hr, error, "myEnterCriticalSection");
    bEnteredCriticalSection=true;

    // if there is no open file, don't even bother.
    if (NULL==g_pflstate->hLogFile) {
        goto done; 
    }

    while (NULL != g_pflstate->pflbHead && S_OK == hr) { // Free up as many buffers as we can: 
        hr = FreeOneFileLogBuffer(0); 
        _IgnoreIfError(hr, "FreeOneFileLogBuffer"); 
    }

#ifndef DBG
    //  *  In free builds, stop if file not open, then expand the string
    //  *  We do not log to screen.
    // expand substuitutions to our buffer
    nCharsWritten=_vsnwprintf(wszBuf, ARRAYSIZE(wszBuf), wszFormat, vlArgs);
    
    // if the buffer overflowed, mark it and ignore the overflow.
    if (-1==nCharsWritten || ARRAYSIZE(wszBuf)==nCharsWritten) {
        wszBuf[ARRAYSIZE(wszBuf)-3]=L'#';
        wszBuf[ARRAYSIZE(wszBuf)-2]=L'\n';
        wszBuf[ARRAYSIZE(wszBuf)-1]=L'\0';
    }
#endif // DBG

    /////////////////////////////////////////////////////////////
    //
    // 1) Write the header of the log entry
    
    if (FALSE == bAppend) { 
        AccurateGetSystemTime(&teTime);

        if (0 != (FL_NTTimeEpochTimestamps & g_pflstate->dwFlags)) { 
            // Use the NT time epoch directly: 
            swprintf(wszHeader, L"%08X:%016I64X:", dwThreadID, teTime);
        } else { 
            // DEFAULT: convert to human-readable time: 
            unsigned __int64 qwTemp=teTime;
            DWORD  dwNanoSecs   = (DWORD)(qwTemp%10000000);
                   qwTemp      /= 10000000;
            DWORD  dwSecs       = (DWORD)(qwTemp%60);
                   qwTemp      /= 60;
            DWORD  dwMins       = (DWORD)(qwTemp%60);
                   qwTemp      /= 60;
            DWORD  dwHours      = (DWORD)(qwTemp%24);
            DWORD  dwDays       = (DWORD)(qwTemp/24);
            swprintf(wszHeader, L"%u %02u:%02u:%02u.%07us - ", dwDays, dwHours, dwMins, dwSecs, dwNanoSecs);
        }

        hr = MakeFileLogBuffer(wszHeader, &pflb); 
        _JumpIfError(hr, error, "MakeFileLogBuffer"); 

        hr = WriteFileLogBuffer(g_pflstate->hLogFile, pflb); 
        _JumpIfError(hr, error, "WriteFileLogBuffer");
        pflb = NULL; 
    }

    //
    // 2) Parse the body of the log entry, replacing "\n" with "\r\n"
    // 

    for (WCHAR *wszEntry = wszBuf; L'\0'!=wszEntry[0]; ) {
        // find the next line in this buffer
        WCHAR  *wszEntryEnd = wcschr(wszEntry, L'\n');
        bool    bMultiLine  = NULL != wszEntryEnd; 
        WCHAR   wszMessage[1024]; 

        if (bMultiLine) { 
            nLen = (unsigned int)(wszEntryEnd-wszEntry)+2; // one more than necessary, to convert "\n" to "\r\n"
        } else {
            nLen = wcslen(wszEntry);
        }

        // copy it into an allocated buffer
        wcsncpy(wszMessage, wszEntry, nLen);
        wszMessage[nLen]=L'\0'; 

        if (bMultiLine) {
            // convert "\n" to "\r\n"
            wszMessage[nLen-2]=L'\r';
            wszMessage[nLen-1]=L'\n';
            nLen--;
        }

        hr = MakeFileLogBuffer(wszMessage, &pflb); 
        _JumpIfError(hr, error, "MakeFileLogBuffer"); 

        hr = WriteFileLogBuffer(g_pflstate->hLogFile, pflb); 
        _JumpIfError(hr, error, "WriteFileLogBuffer"); 
        pflb = NULL; // Don't need to free this locally anymore. 
        
        wszEntry += nLen;

    } // <- end message parsing loop

    // SUCCESS

 done: 
 error:
    if (bEnteredCriticalSection) {
        hr = myLeaveCriticalSection(&g_pflstate->csState);
        _IgnoreIfError(hr, "myLeaveCriticalSection");
    }
    if (NULL != pflb)     { FreeFileLogBuffer(pflb); }
}

void FileLogAdd(const WCHAR *wszFormat, ...) { 
    va_list            vlArgs;

    va_start(vlArgs, wszFormat);
    FileLogAddEx(false, wszFormat, vlArgs); 
    va_end(vlArgs);    
}

void FileLogAppend(const WCHAR *wszFormat, ...) { 
    va_list            vlArgs;

    va_start(vlArgs, wszFormat);
    FileLogAddEx(true, wszFormat, vlArgs); 
    va_end(vlArgs);    
    
}

//====================================================================
// Dump data types


//--------------------------------------------------------------------
// Print out an NT-style time
void FileLogNtTimeEpochEx(bool bAppend, NtTimeEpoch te) {
    _JumpIfError(myEnterCriticalSection(&g_pflstate->csState), error, "myEnterCriticalSection"); 

    { 
        FileLogAdd(L" - %I64d00ns", te.qw);

        DWORD dwNanoSecs=(DWORD)(te.qw%10000000);
        te.qw/=10000000;
        DWORD dwSecs=(DWORD)(te.qw%60);
        te.qw/=60;
        DWORD dwMins=(DWORD)(te.qw%60);
        te.qw/=60;
        DWORD dwHours=(DWORD)(te.qw%24);
        DWORD dwDays=(DWORD)(te.qw/24);
        if (bAppend) { FileLogAppend(L" - %u %02u:%02u:%02u.%07us", dwDays, dwHours, dwMins, dwSecs, dwNanoSecs); }
        else         { FileLogAdd(L" - %u %02u:%02u:%02u.%07us", dwDays, dwHours, dwMins, dwSecs, dwNanoSecs);    }
    }
    _IgnoreIfError(myLeaveCriticalSection(&g_pflstate->csState), "myLeaveCriticalSection"); 
 error:;
}

void FileLogNtTimeEpoch(NtTimeEpoch te) { 
    FileLogNtTimeEpochEx(false, te); 
}

//--------------------------------------------------------------------
// Print out an NTP-style time
void FileLogNtpTimeEpochEx(bool bAppend, NtpTimeEpoch te) {
    _JumpIfError(myEnterCriticalSection(&g_pflstate->csState), error, "myEnterCriticalSection"); 

    if (bAppend) { FileLogAppend(L"0x%016I64X", EndianSwap(te.qw)); } 
    else         { FileLogAdd(L"0x%016I64X", EndianSwap(te.qw)); } 

    if (0==te.qw) {
        if (bAppend) { FileLogAppend(L" - unspecified"); }
        else         { FileLogAdd(L" - unspecified"); }
    } else {
        FileLogNtTimeEpochEx(bAppend, NtTimeEpochFromNtpTimeEpoch(te));
    }

    _IgnoreIfError(myLeaveCriticalSection(&g_pflstate->csState), "myLeaveCriticalSection"); 
 error:;
}

void FileLogNtpTimeEpoch(NtpTimeEpoch te) {
    FileLogNtpTimeEpochEx(false, te); 
}

//--------------------------------------------------------------------
void FileLogNtTimePeriodEx(bool bAppend, NtTimePeriod tp) {
    _JumpIfError(myEnterCriticalSection(&g_pflstate->csState), error, "myEnterCriticalSection"); 

    if (bAppend) { FileLogAppend(L"%02I64u.%07I64us", tp.qw/10000000,tp.qw%10000000); }
    else         { FileLogAdd(L"%02I64u.%07I64us", tp.qw/10000000,tp.qw%10000000); }

    _IgnoreIfError(myLeaveCriticalSection(&g_pflstate->csState), "myLeaveCriticalSection"); 
 error:;
}

void FileLogNtTimePeriod(NtTimePeriod tp) {
    FileLogNtTimePeriodEx(false, tp);
}

//--------------------------------------------------------------------
void FileLogNtTimeOffsetEx(bool bAppend, NtTimeOffset to) {
    NtTimePeriod tp;
    WCHAR pwszSign[2]; 

    _JumpIfError(myEnterCriticalSection(&g_pflstate->csState), error, "myEnterCriticalSection"); 

    if (to.qw<0) {
        wcscpy(pwszSign, L"-"); 
        tp.qw=(unsigned __int64)-to.qw;
    } else {
        wcscpy(pwszSign, L"+"); 
        tp.qw=(unsigned __int64)to.qw;
    }
    
    if (bAppend) { FileLogAppend(pwszSign); } 
    else         { FileLogAdd(pwszSign); } 

    FileLogNtTimePeriodEx(true /*append*/, tp);

    _IgnoreIfError(myLeaveCriticalSection(&g_pflstate->csState), "myLeaveCriticalSection"); 
 error:;
}

void FileLogNtTimeOffset(NtTimeOffset to) {
    FileLogNtTimeOffsetEx(false, to);
}


//--------------------------------------------------------------------
// Print out the contents of an NTP packet
// If nDestinationTimestamp is zero, no round trip calculations will be done
void FileLogNtpPacket(NtpPacket * pnpIn, NtTimeEpoch teDestinationTimestamp) {
    _JumpIfError(myEnterCriticalSection(&g_pflstate->csState), error, "myEnterCriticalSection"); 

    FileLogAdd(L"/-- NTP Packet:\n");
    FileLogAdd(L"| LeapIndicator: ");
    if (0==pnpIn->nLeapIndicator) {
        FileLogAppend(L"0 - no warning");
    } else if (1==pnpIn->nLeapIndicator) {
        FileLogAppend(L"1 - last minute has 61 seconds");
    } else if (2==pnpIn->nLeapIndicator) {
        FileLogAppend(L"2 - last minute has 59 seconds");
    } else {
        FileLogAppend(L"3 - not synchronized");
    }

    FileLogAppend(L";  VersionNumber: %u", pnpIn->nVersionNumber);

    FileLogAppend(L";  Mode: ");
    if (0==pnpIn->nMode) {
        FileLogAppend(L"0 - Reserved");
    } else if (1==pnpIn->nMode) {
        FileLogAppend(L"1 - SymmetricActive");
    } else if (2==pnpIn->nMode) {
        FileLogAppend(L"2 - SymmetricPassive");
    } else if (3==pnpIn->nMode) {
        FileLogAppend(L"3 - Client");
    } else if (4==pnpIn->nMode) {
        FileLogAppend(L"4 - Server");
    } else if (5==pnpIn->nMode) {
        FileLogAppend(L"5 - Broadcast");
    } else if (6==pnpIn->nMode) {
        FileLogAppend(L"6 - Control");
    } else {
        FileLogAppend(L"7 - PrivateUse");
    }

    FileLogAppend(L";  LiVnMode: 0x%02X\n", ((BYTE*)pnpIn)[0]);
    FileLogAdd(L"| Stratum: %u - ", pnpIn->nStratum);
    if (0==pnpIn->nStratum) {
        FileLogAppend(L"unspecified or unavailable");
    } else if (1==pnpIn->nStratum) {
        FileLogAppend(L"primary reference (syncd by radio clock)");
    } else if (pnpIn->nStratum<16) {
        FileLogAppend(L"secondary reference (syncd by (S)NTP)");
    } else {
        FileLogAppend(L"reserved");
    }

    FileLogAppend(L"\n"); 
    FileLogAdd(L"| Poll Interval: %d - ", pnpIn->nPollInterval);
    if (pnpIn->nPollInterval<4 || pnpIn->nPollInterval>14) {
        if (0==pnpIn->nPollInterval) {
            FileLogAppend(L"unspecified");
        } else {
            FileLogAppend(L"out of valid range");
        }
    } else {
        int nSec=1<<pnpIn->nPollInterval;
        FileLogAppend(L"%ds", nSec);
    }

    FileLogAppend(L";  Precision: %d - ", pnpIn->nPrecision);
    if (pnpIn->nPrecision>-2 || pnpIn->nPrecision<-31) {
        if (0==pnpIn->nPollInterval) {
            FileLogAppend(L"unspecified");
        } else {
            FileLogAppend(L"out of valid range");
        }
    } else {
        WCHAR * wszUnit=L"s";
        double dTickInterval=1.0/(1<<(-pnpIn->nPrecision));
        if (dTickInterval<1) {
            dTickInterval*=1000;
            wszUnit=L"ms";
        }
        if (dTickInterval<1) {
            dTickInterval*=1000;
            wszUnit=L"s"; // shows up as s on console
        }
        if (dTickInterval<1) {
            dTickInterval*=1000;
            wszUnit=L"ns";
        }
        FileLogAppend(L"%g%s per tick", dTickInterval, wszUnit);
    }

    FileLogAppend(L"\n"); 
    FileLogAdd(L"| RootDelay: ");
    {
        DWORD dwTemp=EndianSwap((unsigned __int32)pnpIn->toRootDelay.dw);
        FileLogAppend(L"0x%04X.%04Xs", dwTemp>>16, dwTemp&0x0000FFFF);
        if (0==dwTemp) {
            FileLogAppend(L" - unspecified");
        } else {
            FileLogAppend(L" - %gs", ((double)((signed __int32)dwTemp))/0x00010000);
        }
    }

    FileLogAppend(L";  RootDispersion: ");
    {
        DWORD dwTemp=EndianSwap(pnpIn->tpRootDispersion.dw);
        FileLogAppend(L"0x%04X.%04Xs", dwTemp>>16, dwTemp&0x0000FFFF);
        if (0==dwTemp) {
            FileLogAppend(L" - unspecified");
        } else {
            FileLogAppend(L" - %gs", ((double)dwTemp)/0x00010000);
        }
    }

    FileLogAppend(L"\n"); 
    FileLogAdd(L"| ReferenceClockIdentifier: ");
    {
        DWORD dwTemp=EndianSwap(pnpIn->refid.nTransmitTimestamp);
        FileLogAppend(L"0x%08X", dwTemp);
        if (0==dwTemp) {
            FileLogAppend(L" - unspecified");
        } else if (0==pnpIn->nStratum || 1==pnpIn->nStratum) {
            char szId[5];
            szId[0]=pnpIn->refid.rgnName[0];
            szId[1]=pnpIn->refid.rgnName[1];
            szId[2]=pnpIn->refid.rgnName[2];
            szId[3]=pnpIn->refid.rgnName[3];
            szId[4]='\0';
            FileLogAppend(L" - source name: \"%S\"", szId);
        } else if (pnpIn->nVersionNumber<4) {
            FileLogAppend(L" - source IP: %d.%d.%d.%d", 
                pnpIn->refid.rgnIpAddr[0], pnpIn->refid.rgnIpAddr[1],
                pnpIn->refid.rgnIpAddr[2], pnpIn->refid.rgnIpAddr[3]);
        } else {
            FileLogAppend(L" - last reference timestamp fraction: %gs", ((double)dwTemp)/(4294967296.0));
        }
    }
    
    FileLogAppend(L"\n"); 
    FileLogAdd(L"| ReferenceTimestamp:   ");
    FileLogNtpTimeEpochEx(true /*append*/, pnpIn->teReferenceTimestamp);

    FileLogAppend(L"\n"); 
    FileLogAdd(L"| OriginateTimestamp:   ");
    FileLogNtpTimeEpochEx(true /*append*/, pnpIn->teOriginateTimestamp);

    FileLogAppend(L"\n"); 
    FileLogAdd(L"| ReceiveTimestamp:     ");
    FileLogNtpTimeEpochEx(true /*append*/, pnpIn->teReceiveTimestamp);

    FileLogAppend(L"\n"); 
    FileLogAdd(L"| TransmitTimestamp:    ");
    FileLogNtpTimeEpochEx(true /*append*/, pnpIn->teTransmitTimestamp);

    if (0!=teDestinationTimestamp.qw) {
        FileLogAppend(L"\n"); 
        FileLogAdd(L">-- Non-packet info:");

        NtTimeEpoch teOriginateTimestamp=NtTimeEpochFromNtpTimeEpoch(pnpIn->teOriginateTimestamp);
        NtTimeEpoch teReceiveTimestamp=NtTimeEpochFromNtpTimeEpoch(pnpIn->teReceiveTimestamp);
        NtTimeEpoch teTransmitTimestamp=NtTimeEpochFromNtpTimeEpoch(pnpIn->teTransmitTimestamp);

        FileLogAppend(L"\n"); 
        FileLogAdd(L"| DestinationTimestamp: ");
        {
            NtpTimeEpoch teNtpTemp=NtpTimeEpochFromNtTimeEpoch(teDestinationTimestamp);
            NtTimeEpoch teNtTemp=NtTimeEpochFromNtpTimeEpoch(teNtpTemp);
            FileLogNtpTimeEpoch(teNtpTemp);
            unsigned __int32 nConversionError;
            if (teNtTemp.qw>teDestinationTimestamp.qw) {
                nConversionError=(unsigned __int32)(teNtTemp-teDestinationTimestamp).qw;
            } else {
                nConversionError=(unsigned __int32)(teDestinationTimestamp-teNtTemp).qw;
            }
            if (0!=nConversionError) {
                FileLogAppend(L" - CnvErr:%u00ns", nConversionError);
            }
        }

        FileLogAppend(L"\n"); 
        FileLogAdd(L"| RoundtripDelay: ");
        {
            NtTimeOffset toRoundtripDelay=
                (teDestinationTimestamp-teOriginateTimestamp)
                - (teTransmitTimestamp-teReceiveTimestamp);
            FileLogAppend(L"%I64d00ns (%I64ds)", toRoundtripDelay.qw, toRoundtripDelay.qw/10000000);
        }

        FileLogAppend(L"\n"); 
        FileLogAdd(L"| LocalClockOffset: ");
        {
            NtTimeOffset toLocalClockOffset=
                (teReceiveTimestamp-teOriginateTimestamp)
                + (teTransmitTimestamp-teDestinationTimestamp);
            toLocalClockOffset/=2;
            FileLogAppend(L"%I64d00ns", toLocalClockOffset.qw);
            unsigned __int64 nAbsOffset;
            if (toLocalClockOffset.qw<0) {
                nAbsOffset=(unsigned __int64)(-toLocalClockOffset.qw);
            } else {
                nAbsOffset=(unsigned __int64)(toLocalClockOffset.qw);
            }
            DWORD dwNanoSecs=(DWORD)(nAbsOffset%10000000);
            nAbsOffset/=10000000;
            DWORD dwSecs=(DWORD)(nAbsOffset%60);
            nAbsOffset/=60;
            FileLogAppend(L" - %I64u:%02u.%07u00s", nAbsOffset, dwSecs, dwNanoSecs);
        }
    } // <- end if (0!=nDestinationTimestamp)

    FileLogAppend(L"\n"); 
    FileLogAdd(L"\\--\n");

    _IgnoreIfError(myLeaveCriticalSection(&g_pflstate->csState), "myLeaveCriticalSection"); 
 error:;
}

//--------------------------------------------------------------------
void FileLogSockaddrInEx(bool bAppend, sockaddr_in * psai) { 
    if (bAppend) { 
        FileLogAppend(L"%u.%u.%u.%u:%u",
                      psai->sin_addr.S_un.S_un_b.s_b1,
                      psai->sin_addr.S_un.S_un_b.s_b2,
                      psai->sin_addr.S_un.S_un_b.s_b3,
                      psai->sin_addr.S_un.S_un_b.s_b4,
                      EndianSwap((unsigned __int16)psai->sin_port));
    } else { 
        FileLogAppend(L"%u.%u.%u.%u:%u",
                      psai->sin_addr.S_un.S_un_b.s_b1,
                      psai->sin_addr.S_un.S_un_b.s_b2,
                      psai->sin_addr.S_un.S_un_b.s_b3,
                      psai->sin_addr.S_un.S_un_b.s_b4,
                      EndianSwap((unsigned __int16)psai->sin_port));
    }
}

void FileLogSockaddrIn(sockaddr_in * psai) {
    FileLogSockaddrInEx(false, psai); 
}


//--------------------------------------------------------------------
HRESULT UpdateFileLogConfig(void) {
    HRESULT hr;
    HRESULT hr2=S_OK;
    
    // must be cleaned up
    FileLogConfig * pflc=NULL;
    WCHAR * wszError=NULL;

    // read the config if possible
    hr=ReadFileLogConfig(&pflc); // returns mostly OOM errors
    _JumpIfError(hr, error,"ReadFileLogConfig");

    // gain exclusive access
    hr=myEnterCriticalSection(&g_pflstate->csState);
    _JumpIfError(hr, error, "myEnterCriticalSection");

    g_pflstate->dwFlags = pflc->dwFlags; 
    g_pflstate->qwFileSize = pflc->dwFileSize; 

    // replace the list of allowed entries
    if (NULL!=g_pflstate->plerAllowedEntries) {
        FreeLogEntryRangeChain(g_pflstate->plerAllowedEntries);
    }
    g_pflstate->plerAllowedEntries=pflc->plerAllowedEntries;
    pflc->plerAllowedEntries=NULL;

    // see what to do about the file
    if (NULL==pflc->wszLogFileName || L'\0'==pflc->wszLogFileName[0]) {
        // close the file, if necessary
        if (NULL!=g_pflstate->hLogFile) {
            hr=FlushCloseFile();
            _IgnoreIfError(hr, "FlushCloseFile");
        }
    } else {
        // open the file, if it is not opened already
        if (NULL!=g_pflstate->wszLogFileName && 0==wcscmp(pflc->wszLogFileName, g_pflstate->wszLogFileName)) {
            // same file - no change
        } else {
            // different file - open it
            LARGE_INTEGER liEOFPos; 

            // close the old file
            if (NULL!=g_pflstate->hLogFile) {
                hr=FlushCloseFile();
                _IgnoreIfError(hr, "FlushCloseFile");
            }
            g_pflstate->wszLogFileName=pflc->wszLogFileName;
            pflc->wszLogFileName=NULL;

            //open the new file
            g_pflstate->hLogFile=CreateFile(g_pflstate->wszLogFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN, NULL);
            if (INVALID_HANDLE_VALUE==g_pflstate->hLogFile) {
                hr2=HRESULT_FROM_WIN32(GetLastError());
                _IgnoreErrorStr(hr2, "CreateFile", g_pflstate->wszLogFileName);
                g_pflstate->hLogFile=NULL;
                LocalFree(g_pflstate->wszLogFileName);
                g_pflstate->wszLogFileName=NULL;
                EmptyAllBuffers();
            } else if (!GetFileSizeEx(g_pflstate->hLogFile, &liEOFPos)) { 
                hr2 = HRESULT_FROM_WIN32(GetLastError());
                _IgnoreError(hr2, "GetFileSizeEx");
                AbortCloseFile(hr2);
                hr2 = S_OK;
            } else {
                g_pflstate->qwFilePointer = liEOFPos.QuadPart; 
                if (0 != g_pflstate->qwFileSize) { 
                    g_pflstate->qwFilePointer %= g_pflstate->qwFileSize;
                }
                WriteLogHeader();
            }
        } // <- end if need to open file
    } // <- end if file name given
    
    hr=myLeaveCriticalSection(&g_pflstate->csState);
    _JumpIfError(hr, error, "myLeaveCriticalSection");

    hr=S_OK;
    if (FAILED(hr2)) {
        // log an event on failure, but otherwise ignore it.
        const WCHAR * rgwszStrings[2]={
	    L"", 
	    NULL
        };

        // get the friendly error message
        hr2=GetSystemErrorString(hr2, &wszError);
        _JumpIfError(hr2, error, "GetSystemErrorString");

        // log the event
        rgwszStrings[1]=wszError;
        DebugWPrintf1(L"Logging error: Logging was requested, but the time service encountered an error while trying to set up the log file. The error was: %s\n", wszError);
        hr2=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_FILELOG_FAILED, 2, rgwszStrings);
        _JumpIfError(hr2, error, "MyLogEvent");
    }
error:
    if (NULL!=pflc) {
        FreeFileLogConfig(pflc);
    }
    if (NULL!=wszError) {
        LocalFree(wszError);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32time\mytimer.h ===
//--------------------------------------------------------------------
// MyTimer - header
// Copyright (C) Microsoft Corporation, 2001
//
// Created by: Duncan Bryce (duncanb), 02-21-2001
//
// serialized wrapper for thread pool timers
//

#ifndef MYTIMER_H
#define MYTIMER_H

HRESULT myCreateTimerQueueTimer(PHANDLE phNewTimer);
HRESULT myStartTimerQueueTimer(HANDLE hTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, DWORD Flags);
HRESULT myStopTimerQueueTimer(HANDLE hTimerQueue, HANDLE hTimer, HANDLE hEvent);
HRESULT myChangeTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period);
void myDeleteTimerQueueTimer(HANDLE hTimerQueue, HANDLE hTimer, HANDLE hEvent);

#endif //MYTIMER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32time\mytimer.cpp ===
//--------------------------------------------------------------------
// MyTimer - implementation
// Copyright (C) Microsoft Corporation, 2001
//
// Created by: Duncan Bryce (duncanb), 02-21-2001
//
// serialized wrapper for thread pool timers
//

#include "pch.h" // precompiled headers

typedef struct _Timer { 
    CRITICAL_SECTION  csTimer; 
    HANDLE            hTimer; 
} Timer; 

//####################################################################
// module public functions

HRESULT myCreateTimerQueueTimer(PHANDLE phNewTimer)
{
    bool      bInitializedCriticalSection  = false; 
    HRESULT   hr; 
    Timer    *pTimer                       = NULL; 
    
    pTimer = static_cast<Timer *>(LocalAlloc(LPTR, sizeof(Timer))); 
    _JumpIfOutOfMemory(hr, error, pTimer); 

    hr = myInitializeCriticalSection(&pTimer->csTimer); 
    _JumpIfError(hr, error, "myInitializeCriticalSection"); 
    bInitializedCriticalSection = true; 

    *phNewTimer = static_cast<HANDLE>(pTimer);
    pTimer = NULL; 
    hr = S_OK; 
 error:
    if (NULL != pTimer) { 
        if (bInitializedCriticalSection) { 
            DeleteCriticalSection(&pTimer->csTimer); 
        } 
        LocalFree(pTimer); 
    }
    return hr; 
}

HRESULT myStartTimerQueueTimer
(HANDLE hTimer,                // handle to timer
 HANDLE hTimerQueue,           // handle to timer queue
 WAITORTIMERCALLBACK Callback, // timer callback function
 PVOID Parameter,              // callback parameter
 DWORD DueTime,                // timer due time
 DWORD Period,                 // timer period
 DWORD Flags                   // execution
 )
{
    bool      bEnteredCriticalSection  = false; 
    HRESULT   hr; 
    Timer    *pTimer                   = static_cast<Timer *>(hTimer); 

    hr = myEnterCriticalSection(&pTimer->csTimer); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    if (NULL != pTimer->hTimer) { 
        hr = HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED); 
        _JumpError(hr, error, "myStartTimerQueueTimer: already initialized"); 
    } 

    if (!CreateTimerQueueTimer(&pTimer->hTimer, hTimerQueue, Callback, Parameter, DueTime, Period, Flags)) { 
        _JumpLastError(hr, error, "CreateTimerQueueTimer"); 
    }

    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
        HRESULT hr2 = myLeaveCriticalSection(&pTimer->csTimer); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
    }
    return hr; 
}

HRESULT myStopTimerQueueTimer(HANDLE hTimerQueue, HANDLE hTimer, HANDLE hEvent)
{
    bool      bEnteredCriticalSection = false; 
    HRESULT   hr;
    Timer    *pTimer; 

    pTimer = static_cast<Timer *>(hTimer); 

    hr = myEnterCriticalSection(&pTimer->csTimer); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    if (NULL != pTimer->hTimer) { 
        if (!DeleteTimerQueueTimer(hTimerQueue, pTimer->hTimer, hEvent /*blocking*/)) { 
            hr = HRESULT_FROM_WIN32(GetLastError()); 
            _JumpError(hr, error, "DeleteTimerQueueTimer"); 
        }
        pTimer->hTimer = NULL; 
    }

    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
        HRESULT hr2 = myLeaveCriticalSection(&pTimer->csTimer); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
    }

    return hr; 
}


HRESULT myChangeTimerQueueTimer
(HANDLE hTimerQueue,  // handle to timer queue
 HANDLE hTimer,       // handle to timer
 ULONG  DueTime,      // timer due time
 ULONG  Period        // timer period
)
{
    BOOL      bEnteredCriticalSection  = FALSE;  
    HRESULT   hr; 
    Timer    *pTimer                   = static_cast<Timer *>(hTimer); 

    hr = myTryEnterCriticalSection(&pTimer->csTimer, &bEnteredCriticalSection); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 

    if (!bEnteredCriticalSection) {
        // The is the approximate error
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE); 
        _JumpError(hr, error, "myChangeTimerQueueTimer: couldn't enter critsec"); 
    }

    if (NULL == pTimer->hTimer) { 
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE); 
        _JumpError(hr, error, "myChangeTimerQueueTimer: invalid handle"); 
    } 

    if (!ChangeTimerQueueTimer(hTimerQueue, pTimer->hTimer, DueTime, Period)) { 
        _JumpLastError(hr, error, "ChangeTimerQueueTimer"); 
    }

    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
        HRESULT hr2 = myLeaveCriticalSection(&pTimer->csTimer); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
    }
    return hr; 

}

void myDeleteTimerQueueTimer(HANDLE hTimerQueue, HANDLE hTimer, HANDLE hEvent) { 
    HRESULT   hr; 
    Timer    *pTimer = static_cast<Timer *>(hTimer); 

    hr = myStopTimerQueueTimer(hTimerQueue, hTimer, hEvent);
    _IgnoreIfError(hr, "myStopTimerQueueTimer"); 

    DeleteCriticalSection(&pTimer->csTimer); 
    LocalFree(pTimer);
    _MyAssert(S_OK == hr); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32time\ntpprov.cpp ===
//depot/Lab03_N/DS/security/services/w32time/w32time/NtpProv.cpp#23 - edit change 8363 (text)
//depot/Lab03_N/DS/security/services/w32time/w32time/NtpProv.cpp#22 - edit change 8345 (text)
//--------------------------------------------------------------------
// NtpProvider - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 10-21-99
//
// An Ntp Provider
//

#include "pch.h"

#include "EndianSwap.inl"
#include "ErrToFileLog.h"

//--------------------------------------------------------------------
// structures

struct ClockFilterSample {
    NtTimeOffset toDelay;
    NtTimeOffset toOffset;
    NtTimePeriod tpDispersion;
    unsigned __int64 nSysTickCount;
    signed __int64 nSysPhaseOffset;
    NtpLeapIndicator eLeapIndicator;
    unsigned __int8 nStratum;
};

struct SortableSample {
    NtTimePeriod tpSyncDistance;
    unsigned int nAge;
};

#define ClockFilterSize 6
struct ClockFilter {
    unsigned int nNext;
    ClockFilterSample rgcfsSamples[ClockFilterSize];
};

struct NicSocket {
    sockaddr_in sai;
    SOCKET socket;
    HANDLE hDataAvailEvent;
    bool bListenOnly;
};

struct NtpClientConfig {
    DWORD dwSyncFromFlags; 
    WCHAR * mwszManualPeerList;     // valid with NCSF_ManualPeerList
    WCHAR * mwszTimeRemaining;      // only processed on startup and shutdown
    DWORD dwCrossSiteSyncFlags;     // valid with NCSF_DomainHierarchy
    DWORD dwAllowNonstandardModeCombinations;
    DWORD dwResolvePeerBackoffMinutes;    // valid with NCSF_DomainHierarchy
    DWORD dwResolvePeerBackoffMaxTimes;   // valid with NCSF_DomainHierarchy
    DWORD dwCompatibilityFlags;
    DWORD dwSpecialPollInterval;
    DWORD dwEventLogFlags;
};

struct NtpServerConfig {
    DWORD dwAllowNonstandardModeCombinations;
};

enum NtpPeerType {
    e_ManualPeer = 0,
    e_DomainHierarchyPeer,
    e_DynamicPeer,
    e_BroadcastPeer,
};

//----------------------------------------------------------------------
//
// The authentication types possible with our NTP providers. 
// NOTE: IF adding a new authentication type, make sure to update the
//       message ID table below!  Each message ID references the string
//       name of the authentication type. 
//

enum AuthType {
    e_NoAuth,
    e_NtDigest,
};

DWORD const gc_rgdwAuthTypeMsgIds[] = { 
    W32TIMEMSG_AUTHTYPE_NOAUTH, 
    W32TIMEMSG_AUTHTYPE_NTDIGEST
}; 

//
//----------------------------------------------------------------------

enum UpdateType { 
    e_Normal, 
    e_JustSent, 
    e_TimeJumped,
}; 

enum DiscoveryType { 
    e_Background=0, 
    e_Foreground, 
    e_Force, 
}; 

enum LastLoggedReachability {
    e_NewManualPeer,    // special step for manual peers, since the first outgoing message looks like a failure.
    e_NeverLogged,
    e_Reachable,
    e_Unreachable,
};

// contains information about a long term time source that was configured in the registry
struct NtpPeer {
    // Methods:
    NtpPeer();
    ~NtpPeer();

    BOOL NtpPeer::operator<(const NtpPeer & np);
    BOOL NtpPeer::operator==(const NtpPeer & np);
    void reset();

    // Fields:
    bool bCsIsInitialized; 
    CRITICAL_SECTION csPeer; 

    NtpPeerType ePeerType;
    unsigned int nResolveAttempts;
    AuthType eAuthType;

    DWORD dwCompatibilityFlags;
    DWORD dwCompatLastDispersion;           // used for autodetecting Win2K sources

    WCHAR * wszManualConfigID;
    DWORD dwManualFlags;

    WCHAR * wszDomHierDcName;
    WCHAR * wszDomHierDomainName;
    DWORD dwRequestTrustRid;                // goes in the rid field of an outgoing packet, how we want the peer to sign
    DWORD dwResponseTrustRid;               // comes from the rid field of an incoming packet, how the peer wants us to sign
    DiscoveryType eDiscoveryType; 
    bool bStratumIsAuthoritative; 
    bool bUseOldServerDigest; 
    bool bLastAuthCheckFailed; 

    sockaddr_in saiRemoteAddr;
    NicSocket * pnsSocket;
    NtTimePeriod tpTimeRemaining;
    WCHAR wszUniqueName[256];               // Admin readable name that uniquely identifies this peer

    signed __int8 nPeerPollInterval;
    signed __int8 nHostPollInterval;
    NtpMode eMode;

    NtpTimeEpoch teExactTransmitTimestamp;  // the time at which the reply departed the server for the client, in (2^-32)s
    NtpTimeEpoch teExactOriginateTimestamp; // the time at which the reply departed the peer for the host
    NtTimeEpoch teReceiveTimestamp;         // the time at which the request arrived at the host
    NtTimeEpoch teLastSuccessfulSync;       // the time at which the most recent good time sample arrived from peer

    NtpReachabilityReg nrrReachability;     // a shift register used to determine the reachability status of the peer
    unsigned int nValidDataCounter;         // the number of valid samples remaining in the filter register.
    LastLoggedReachability eLastLoggedReachability; // used for logging when peers go unreachable and reachable.

    // result of last clock filter op
    unsigned int nStratum; // Stratum of last sample added to clock filter. 
    ClockFilter clockfilter;
    NtTimeEpoch teLastClockFilterUpdate;
    unsigned int nBestSampleIndex;
    NtTimePeriod tpFilterDispersion;

    // Status reporting (used by monitoring tools)
    DWORD  dwError;
    DWORD  dwErrorMsgId; 
    
};

typedef AutoPtr<NtpPeer>      NtpPeerPtr;
typedef vector<NtpPeerPtr>    NtpPeerVec;
typedef NtpPeerVec::iterator  NtpPeerIter;

struct NameUniqueNtpPeer { 
    NameUniqueNtpPeer(NtpPeerPtr pnp) : m_pnp(pnp) { } 
    BOOL NameUniqueNtpPeer::operator<(const NameUniqueNtpPeer & np);
    BOOL NameUniqueNtpPeer::operator==(const NameUniqueNtpPeer & np);

    NtpPeerPtr m_pnp;
}; 

typedef vector<NameUniqueNtpPeer>  NUNtpPeerVec; 
typedef NUNtpPeerVec::iterator     NUNtpPeerIter; 

// contains short term information about a time source that we just heard from over the network
struct NtpSimplePeer {
    NtpMode eMode;                        // the mode. Valid range: 0-7
    unsigned __int8 nVersionNumber;       // the NTP/SNTP version number. Valid range: 1-4
    NtpLeapIndicator eLeapIndicator;      // a warning of an impending leap second to be inserted/deleted in the last minute of the current day
    unsigned __int8 nStratum;             // the stratum level of the local clock. Valid Range: 0-15
      signed __int8 nPollInterval;        // the maximum interval between successive messages, in s, log base 2. Valid range:4(16s)-14(16284s)
      signed __int8 nPrecision;           // the precision of the local clock, in s, log base 2
    NtTimeOffset   toRootDelay;           // the total roundtrip delay to the primary reference source, in (2^-16)s
    NtTimePeriod   tpRootDispersion;      // the nominal error relative to the primary reference, in (2^-16)s
    NtpRefId       refid;                 // identifies the particular reference source
    NtTimeEpoch    teReferenceTimestamp;  // the time at which the local clock was last set or corrected, in (2^-32)s
    NtTimeEpoch    teOriginateTimestamp;  // the time at which the request departed the client for the server, in (2^-32)s
    NtpTimeEpoch   teExactOriginateTimestamp;   // the time at which the reply departed the server for the client, in (2^-32)s
    NtTimeEpoch    teReceiveTimestamp;    // the time at which the request arrived at the server, in (2^-32)s
    NtTimeEpoch    teTransmitTimestamp;   // the time at which the reply departed the server for the client, in (2^-32)s
    NtpTimeEpoch   teExactTransmitTimestamp;   // the time at which the reply departed the server for the client, in (2^-32)s
    NtTimeEpoch    teDestinationTimestamp;// the time at which the reply arrived at the host, in (10^-7)s

    NtTimeOffset toRoundtripDelay;
    NtTimeOffset toLocalClockOffset;
    NtTimePeriod tpDispersion;
    unsigned __int64 nSysTickCount;     // opaque, must be GetTimeSysInfo(TSI_TickCount)
      signed __int64 nSysPhaseOffset;   // opaque, must be GetTimeSysInfo(TSI_PhaseOffset)
    NtpMode eOutMode;

    AuthType eAuthType;
    DWORD dwResponseTrustRid;           // comes from the rid field of an incoming packet, how the peer wants us to sign

    bool rgbTestsPassed[8];  // each of the 8 packet checks from NTPv3 spec
    bool bValidHeader;
    bool bValidData;
    bool bGarbagePacket;
};

struct NtpProvState {
    bool bNtpProvStarted;
    TimeProvSysCallbacks tpsc;
    bool bNtpServerStarted;
    bool bNtpClientStarted;

    bool bSocketLayerOpen;
    NicSocket ** rgpnsSockets;
    unsigned int nSockets;
    unsigned int nListenOnlySockets;

    HANDLE hStopEvent;
    HANDLE hDomHierRoleChangeEvent;

    // Events registered with the thread pool. 

    // listening thread's registered events:
    //
    //   0    - hStopEvent
    //   1-n  - rgpnsSockets[0] through rgpnsSockets[n-1]
    // 
    HANDLE *rghListeningThreadRegistered; // num elements == 1 + g_pnpstate->nSockets

    // peer polling thread's registered events:
    //
    HANDLE hRegisteredStopEvent;
    HANDLE hRegisteredPeerListUpdated;
    HANDLE hRegisteredDomHierRoleChangeEvent;

    // peer polling thread's timer: 
    HANDLE hPeerPollingThreadTimer; 

    // client state
    DWORD dwSyncFromFlags;
    bool bAllowClientNonstandardModeCominations;
    DWORD dwCrossSiteSyncFlags;
    DSROLE_MACHINE_ROLE eLastRole;
    WCHAR * wszLastSite;
    DWORD dwResolvePeerBackoffMinutes;
    DWORD dwResolvePeerBackoffMaxTimes;
    DWORD dwClientCompatibilityFlags;
    DWORD dwSpecialPollInterval;
    DWORD dwEventLogFlags;
    // messages to be logged once
    bool bLoggedOnceMSG_NOT_DOMAIN_MEMBER;
    bool bLoggedOnceMSG_DOMAIN_HIERARCHY_ROOT;
    bool bLoggedOnceMSG_NT4_DOMAIN;

    // server state
    bool bAllowServerNonstandardModeCominations;

    bool bCsThreadTrapIsInitialized; 
    CRITICAL_SECTION csThreadTrap; 
    CRITICAL_SECTION csPeerList;                 

    NtpPeerVec vActivePeers;     // protected by csPeerList
    NtpPeerVec vPendingPeers;    // protected by csPeerList
    bool bUseFallbackPeers; 
    HANDLE hPeerListUpdated;
    NtTimeEpoch tePeerListLastUpdated;
    bool bWarnIfNoActivePeers;

    // Counters
    DWORD dwIncomingPacketsHandled;
};

struct RegisterWaitForSingleObjectInfo { 
    HANDLE   hRegistered; 
    HANDLE   hObject; 
    HRESULT *pHr; 
}; 

//--------------------------------------------------------------------
// globals

MODULEPRIVATE NtpProvState *g_pnpstate;

#define NTPSERVERHANDLE ((TimeProvHandle)1)
#define NTPCLIENTHANDLE ((TimeProvHandle)2)

#define AUTODETECTWIN2KPATTERN          0xAAAAAAAA

#define PEERLISTINITIALSIZE     10
#define PEERLISTSIZEINCREMENT   10

#define LOCALHOST_IP 0x0100007f

#define MINIMUMIRREGULARINTERVAL 160000000 // 16s in 10^-7s

// The leftmost bit of the client rid determines whether to use the
// old or new server digest: 
#define TRUST_RID_OLD_DIGEST_BIT (1<<31)


#define SYNCHRONIZE_PROVIDER() \
    { \
        HRESULT hr2=myEnterCriticalSection(&g_pnpstate->csPeerList);  \
        if (FAILED(hr2)) { \
            hr = hr2; \
             _JumpError(hr, error, "myEnterCriticalSection"); \
        } \
        bEnteredCriticalSection = true; \
    }

#define UNSYNCHRONIZE_PROVIDER() \
    { \
        if (bEnteredCriticalSection) { \
            HRESULT hr2 = myLeaveCriticalSection(&g_pnpstate->csPeerList); \
            _IgnoreIfError(hr2, "myLeaveCriticalSection"); \
            if (SUCCEEDED(hr2)) { \
                bEnteredCriticalSection = false; \
            } \
        } \
    }


MODULEPRIVATE HRESULT StartListeningThread(); 
MODULEPRIVATE HRESULT StartPeerPollingThread(); 
MODULEPRIVATE HRESULT StopListeningThread();
MODULEPRIVATE HRESULT StopPeerPollingThread();
MODULEPRIVATE void UpdatePeerListTimes(void);

//####################################################################
// module private functions

//--------------------------------------------------------------------
MODULEPRIVATE void FreeNtpClientConfig(NtpClientConfig * pncc) {
    if (NULL!=pncc->mwszManualPeerList) {
        LocalFree(pncc->mwszManualPeerList);
    }
    LocalFree(pncc);
}

//--------------------------------------------------------------------
MODULEPRIVATE void FreeNtpServerConfig(NtpServerConfig * pnsc) {
    LocalFree(pnsc);
}

//--------------------------------------------------------------------------------
MODULEPRIVATE void HandleObjectNoLongerInUse(LPVOID pvhEvent, BOOLEAN bIgnored) {
    RegisterWaitForSingleObjectInfo  *pInfo = (RegisterWaitForSingleObjectInfo *)pvhEvent;

    if (NULL != pInfo) { 
	if (NULL != pInfo->hObject)      { CloseHandle(pInfo->hObject); }
	if (NULL != pInfo->pHr)          { LocalFree(pInfo->pHr); } 
	if (NULL != pInfo->hRegistered)  { UnregisterWait(pInfo->hRegistered); }
	LocalFree(pInfo); 
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE void FreeSetProviderStatusInfo(SetProviderStatusInfo * pspsi) { 
    if (NULL != pspsi) {
        if (NULL != pspsi->wszProvName) { LocalFree(pspsi->wszProvName); } 
        LocalFree(pspsi); 
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE int CompareManualConfigIDs(WCHAR *wszID1, WCHAR *wszID2) { 
    int    nRetval; 
    WCHAR *wszFlags1 = wcschr(wszID1, L','); 
    WCHAR *wszFlags2 = wcschr(wszID2, L','); 

    if (NULL != wszFlags1) { 
	wszFlags1[0] = L'\0'; 
    }
    if (NULL != wszFlags2) { 
	wszFlags2[0] = L'\0'; 
    }

    nRetval = _wcsicmp(wszID1, wszID2); 

    if (NULL != wszFlags1) { 
	wszFlags1[0] = L','; 
    }
    if (NULL != wszFlags2) { 
	wszFlags2[0] = L','; 
    }

    return nRetval; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT SetProviderStatus(LPWSTR wszProvName, DWORD dwStratum, TimeProvState tpsState, bool bAsync, DWORD dwTimeout) { 
    DWORD                             dwResult; 
    HANDLE                            hEvent     = NULL;
    HRESULT                           hr; 
    HRESULT                          *pHrAsync   = NULL; 
    RegisterWaitForSingleObjectInfo  *pInfo      = NULL;
    SetProviderStatusInfo            *pspsi      = NULL; 

    pspsi = (SetProviderStatusInfo *)LocalAlloc(LPTR, sizeof(SetProviderStatusInfo)); 
    _JumpIfOutOfMemory(hr, error, pspsi); 

    pspsi->wszProvName = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(wszProvName)+1)); 
    _JumpIfOutOfMemory(hr, error, pspsi->wszProvName); 
    wcscpy(pspsi->wszProvName, wszProvName);

    pspsi->pfnFree          = FreeSetProviderStatusInfo; 
    pspsi->dwStratum        = dwStratum; 
    pspsi->tpsCurrentState  = tpsState; 
    if (!bAsync) { 
	pspsi->hWaitEvent = CreateEvent(NULL /*security*/, TRUE /*manual-reset*/, FALSE /*nonsignaled*/, NULL /*name*/);
	if (NULL == pspsi->hWaitEvent) { 
	    _JumpLastError(hr, error, "CreateEvent"); 
	}
	pHrAsync = (HRESULT *)LocalAlloc(LPTR, sizeof(HRESULT)); 
	_JumpIfOutOfMemory(hr, error, pHrAsync); 
	pspsi->pHr = pHrAsync; 
    }

    // Get a local handle to the wait event, as pspsi is invalid after the 
    // call to pfnSetProviderStatus(). 
    hEvent = pspsi->hWaitEvent; 
    hr = g_pnpstate->tpsc.pfnSetProviderStatus(pspsi); 
    _JumpIfError(hr, error, "g_pnpstate->tpsc.pfnSetProviderStatus"); 
    pspsi = NULL;  // W32time manager is now responsible for freeing this data. 

    if (!bAsync) { 
	dwResult = WaitForSingleObject(hEvent, dwTimeout); 
	if (WAIT_FAILED == dwResult) { 
	    // Not really sure why we failed, but we can never safely close this event handle:
	    hEvent = NULL; 
	    _JumpLastError(hr, error, "WaitForSingleObject"); 
	} else if (WAIT_TIMEOUT == dwResult) { 
	    // We haven't finished executing the manager callback yet, so we can't clean up our event handle.
	    // Register a callback to do it. 
	    HANDLE hEventToWaitOn  = hEvent; 

	    // We cannot close this event until we know it is signaled. 
	    hEventToWaitOn = hEvent; 
	    pInfo = (RegisterWaitForSingleObjectInfo *)LocalAlloc(LPTR, sizeof(RegisterWaitForSingleObjectInfo)); 
	    _JumpIfOutOfMemory(hr, error, pInfo); 

	    pInfo->hObject = hEventToWaitOn; 
	    pInfo->pHr     = pHrAsync; 

	    // We're not going to wait for this any longer. 
	    if (!RegisterWaitForSingleObject(&pInfo->hRegistered, pInfo->hObject, HandleObjectNoLongerInUse, pInfo, INFINITE, WT_EXECUTEONLYONCE)) { 
		_JumpLastError(hr, error, "RegisterWaitForSingleObject"); 
	    }
	    
	    // Our callback will free pInfo. 
	    hEvent = NULL; 
	    pHrAsync = NULL; 
	    pInfo = NULL; 

	    // We're not yet done processing the callback:
	    hr = E_PENDING; 
	    _JumpError(hr, error, "WaitForSingleObject: wait timeout"); 
	} else { 
	    // wait succeeded, check the return value: 
	    hr = *pHrAsync; 
	    _JumpIfError(hr, error, "pfnSetProviderStatus: asynchronous return value"); 
	}
    }
    
    hr = S_OK; 
 error:
    if (NULL != pInfo)    { LocalFree(pInfo); }
    if (NULL != pspsi)    { FreeSetProviderStatusInfo(pspsi); } 
    if (NULL != hEvent)   { CloseHandle(hEvent); } 
    if (NULL != pHrAsync) { LocalFree(pHrAsync); } 
    return hr; 
}


//////////////////////////////////////////////////////////////////////
//
// NtpPeer member functions
//
//////////////////////////////////////////////////////////////////////

NtpPeer::NtpPeer() {
    this->reset();
}

void NtpPeer::reset() {
    memset(this, 0, sizeof(NtpPeer));
}

BOOL NtpPeer::operator<(const NtpPeer & np) {
    if (this->ePeerType == np.ePeerType) {
	if (e_ManualPeer == this->ePeerType) { 
            return wcscmp(this->wszManualConfigID, np.wszManualConfigID) < 0;
        } else { 
	    // Don't bother to sort non-manual peers
	    return TRUE; 
	}
    } else {
        // We want to resolve domain hierarchy peers first, then manual peers.
        // Dynamic and broadcast peers are not supported.
        static DWORD rgPeerTypeRanking[] = {
            1,  // e_ManualPeer
            0,  // e_DomainHierarchyPeer
            2,  // e_DynamicPeer
            3   // e_BroadcastPeer
        };

        // Use the peer type ranking table to compute which peer type is greater.
        return rgPeerTypeRanking[this->ePeerType] < rgPeerTypeRanking[np.ePeerType];
    }
}

BOOL NtpPeer::operator==(const NtpPeer & np) {
    return this == &np;
}

NtpPeer::~NtpPeer() {
    if (NULL != this->wszManualConfigID) {
        LocalFree(this->wszManualConfigID);
    }
    if (NULL != this->wszDomHierDcName) {
        LocalFree(this->wszDomHierDcName);
    }
    if (NULL != this->wszDomHierDomainName) {
        LocalFree(this->wszDomHierDomainName);
    }
    if (bCsIsInitialized) { 
	DeleteCriticalSection(&this->csPeer); 
    }
    // wszUniqueName is a fixed array
}

BOOL NameUniqueNtpPeer::operator<(const NameUniqueNtpPeer & np)
{
    return m_pnp < np.m_pnp; 
}

BOOL NameUniqueNtpPeer::operator==(const NameUniqueNtpPeer & np)
{
    BOOL bResult;

    bResult = (m_pnp->ePeerType == np.m_pnp->ePeerType);
    if (e_ManualPeer == m_pnp->ePeerType) {
        bResult = bResult && 0 == wcscmp(m_pnp->wszManualConfigID, np.m_pnp->wszManualConfigID);
    }

    return bResult;
}


//////////////////////////////////////////////////////////////////////
//
// Function objects for use in STL algorithms:
//
//////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------
struct IsPeerType {
    IsPeerType(NtpPeerType ePeerType) : m_ePeerType(ePeerType) { }
    BOOL operator()(NtpPeerPtr pnp) { return m_ePeerType == pnp->ePeerType; }
private:
    NtpPeerType m_ePeerType;
};

struct IsDnsEquivalentPeer { 
    IsDnsEquivalentPeer(NtpPeerType ePeerType, LPWSTR pwszID) : m_ePeerType(ePeerType), m_pwszID(pwszID) { } 
    BOOL operator()(NtpPeerPtr pnp) { 
	BOOL bResult;

	bResult = (pnp->ePeerType == m_ePeerType);
	if (e_ManualPeer == pnp->ePeerType) {
	    bResult = bResult && 0 == CompareManualConfigIDs(pnp->wszManualConfigID, m_pwszID);
	}

	return bResult;
    }
private:
    NtpPeerType m_ePeerType; 
    LPWSTR m_pwszID; 
}; 


MODULEPRIVATE HRESULT GetMostRecentlySyncdDnsUniquePeers(OUT NtpPeerVec & vOut)
{
    HRESULT        hr; 
    NtpPeerVec    &vActive            = g_pnpstate->vActivePeers;   // aliased for readability  
    NtpPeerVec    &vPending           = g_pnpstate->vPendingPeers;  // aliased for readability  
    NUNtpPeerVec   vUnique; 
    NtTimeEpoch    teNow;

    // 1) Create a vector of peers with unique dns names, one for each
    //    dns name present in both the active and pending lists. 
    for (DWORD dwIndex = 0; dwIndex < 2; dwIndex++) { 
	NtpPeerVec &v = 0 == dwIndex ? vActive : vPending; 
	for (NtpPeerIter pnpIter = v.begin(); pnpIter != v.end(); pnpIter++) { 
	    _SafeStlCall(vUnique.push_back(NameUniqueNtpPeer(*pnpIter)), hr, error, "vUnique.push_back(NameUniqueNtpPeer(*pnpIter))"); 
	}
    }
    vUnique.erase(unique(vUnique.begin(), vUnique.end()), vUnique.end()); 

    // 2) For each peer in our list of DNS-unique peers...
    for (NUNtpPeerIter pnpUniqueIter = vUnique.begin(); pnpUniqueIter != vUnique.end(); pnpUniqueIter++) { 
	// Search both active and pending peer lists...
	for (DWORD dwIndex = 0; dwIndex < 2; dwIndex++) { 
	    NtpPeerVec &v = 0 == dwIndex ? vActive : vPending; 
	    // Find duplicate peers with matching name...
	    NtpPeerPtr pnpUnique = (*pnpUniqueIter).m_pnp; 
	    for (NtpPeerIter pnpIter = find_if(v.begin(), v.end(), IsDnsEquivalentPeer(pnpUnique->ePeerType, pnpUnique->wszManualConfigID)); 
		 pnpIter != v.end(); 
		 pnpIter = find_if(pnpIter+1, v.end(), IsDnsEquivalentPeer(pnpUnique->ePeerType, pnpUnique->wszManualConfigID))) { 
		// If this duplicate has a more recent sync time, use this duplicate.
		if (pnpUnique->teLastSuccessfulSync < (*pnpIter)->teLastSuccessfulSync) { 
		    (*pnpUniqueIter).m_pnp = (*pnpIter); 
		}
	    } 
	}
    }								      

    // 3) Copy the resulting vector to our OUT param
    for (NUNtpPeerIter pnpIter = vUnique.begin(); pnpIter != vUnique.end(); pnpIter++) { 
	_SafeStlCall(vOut.push_back((*pnpIter).m_pnp), hr, error, "push_back"); 
    }
 
    hr = S_OK; 
 error:
    return hr; 
}


//--------------------------------------------------------------------
// BUG #312708:
// For manual peers using the special poll interval, write the time 
// remaining to the registry.  This prevents a dialup on every reboot. 
//
// The value written to the registry is a MULTI_SZ of the following format:
// 
// peer1,time1 NULL
// peer2,time2 NULL
// ...
// peerN,timeN NULL
// NULL
//
// For multiple peers with the same DNS name, we'll take the peer with the
// most recent sync time. 
// 
MODULEPRIVATE HRESULT SaveManualPeerTimes() {
    DWORD          ccTimeRemaining;
    DWORD          dwError; 
    HKEY           hkNtpClientConfig  = NULL; 
    HRESULT        hr; 
    NtpPeerVec    &vActive            = g_pnpstate->vActivePeers;   // aliased for readability  
    NtpPeerVec    &vPending           = g_pnpstate->vPendingPeers;  // aliased for readability  
    NtpPeerVec     vUnique; 
    WCHAR         *mwszTimeRemaining  = NULL; 
    WCHAR         *wszCurrent; 
    NtTimeEpoch    teNow;


    // 1) Make sure that the time remaining for each peer is current
    UpdatePeerListTimes(); 
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teNow.qw);
    teNow.qw -= ((unsigned __int64)g_pnpstate->dwSpecialPollInterval)*10000000;

    // 2) We don't want duplicates in our list, so create a list of unique dns names, 
    //    and assign sync time as the most recent sync time of all duplicates
    hr = GetMostRecentlySyncdDnsUniquePeers(vUnique); 
    _JumpIfError(hr, error, "GetMostRecentlySyncdDnsUniquePeers"); 

    // 3) Compute size of MULTI_SZ to add to the registry: 
    ccTimeRemaining = 1 /*final NULL-termination char*/;
    for (NtpPeerIter pnpIter = vUnique.begin(); pnpIter != vUnique.end(); pnpIter++) { 
	NtpPeerPtr pnp = *pnpIter;
	if (e_ManualPeer==pnp->ePeerType && (0 != (pnp->dwManualFlags & NCMF_UseSpecialPollInterval))) { 
	    ccTimeRemaining += wcslen(pnp->wszManualConfigID) + wcslen(L",") + 13 /*max chars in 32-bit number*/ + 1 /*NULL-termination char*/;  
	}
    }

    mwszTimeRemaining = (WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR) * ccTimeRemaining); 
    _JumpIfOutOfMemory(hr, error, mwszTimeRemaining); 
    wszCurrent = mwszTimeRemaining; 

    // 4) Create a MULTI_SZ with the remaining peer times
    for (NtpPeerIter pnpIter = vUnique.begin(); pnpIter != vUnique.end(); pnpIter++) { 
	NtpPeerPtr pnp = *pnpIter; 
            
	if (e_ManualPeer==pnp->ePeerType && (0 != (pnp->dwManualFlags & NCMF_UseSpecialPollInterval))) { 
	    // find the flags and hide them to get the DNS name
	    WCHAR *wszFlags = wcschr(pnp->wszManualConfigID, L','); 
	    if (NULL != wszFlags) { 
		wszFlags[0] = L'\0'; 
	    }

	    wcscat(wszCurrent, pnp->wszManualConfigID); 
	    wcscat(wszCurrent, L","); 
	    wszCurrent += wcslen(wszCurrent); 

		// now that we're done with the peer's DNS name, restore the flags:
	    if (NULL != wszFlags) { 
		wszFlags[0] = L','; 
	    }

	    //
	    // dwLastSyncTime = Now - (PollInterval - TimeRemaining)
	    // For fast calculation, we made a tradeoff with precision. The number is devide by
	    // 1000000000 and saved in the registry
	    //

	    DWORD dwLastSyncTime = (DWORD)((pnp->teLastSuccessfulSync.qw / 1000000000) & 0xFFFFFFFF);
	    _ultow( dwLastSyncTime, wszCurrent, 16 );

	    wszCurrent += wcslen(wszCurrent) + 1; 
	}
    }

    // 5) Write the MULTI_SZ to the registry
    dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszNtpClientRegKeyConfig, NULL, KEY_SET_VALUE, &hkNtpClientConfig); 
    if (ERROR_SUCCESS != dwError) { 
        hr = HRESULT_FROM_WIN32(dwError); 
        _JumpErrorStr(hr, error, "RegOpenKeyEx", wszNtpClientRegKeyConfig);
    } 
    
    dwError = RegSetValueEx(hkNtpClientConfig, wszNtpClientRegValueSpecialPollTimeRemaining, NULL, REG_MULTI_SZ ,(BYTE *)mwszTimeRemaining, sizeof(WCHAR) * ccTimeRemaining); 
    if (ERROR_SUCCESS != dwError) { 
        hr = HRESULT_FROM_WIN32(dwError); 
        _JumpErrorStr(hr, error, "RegSetValueEx", wszNtpClientRegValueSpecialPollTimeRemaining); 
    }

    hr = S_OK; 
 error:
    if (NULL != hkNtpClientConfig) { 
        RegCloseKey(hkNtpClientConfig); 
    }
    if (NULL != mwszTimeRemaining) { 
        LocalFree(mwszTimeRemaining); 
    }
    return hr; 
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT AddNewPendingManualPeer(const WCHAR * wszName, NtTimePeriod tpTimeRemaining, NtTimeEpoch teLastSuccessfulSync) {
    HRESULT  hr;
    WCHAR   *wszFlags;

    // allocate new peer: this should NULL out the peer fields
    NtpPeerPtr pnpNew(new NtpPeer);  // Automatically freed.
    _JumpIfOutOfMemory(hr, error, pnpNew);

    // initialize it to the pending state
    pnpNew->ePeerType          = e_ManualPeer;
    pnpNew->wszManualConfigID  = (WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(wszName)+1));
    _JumpIfOutOfMemory(hr, error, pnpNew->wszManualConfigID);
    wcscpy(pnpNew->wszManualConfigID, wszName);

    // Determine the value of the manual flags.  We need this to determine
    // whether or not to resolve the manual peer.
    wszFlags = wcschr(pnpNew->wszManualConfigID, L',');
    if (NULL != wszFlags) {
        pnpNew->dwManualFlags = wcstoul(wszFlags+1, NULL, 0);
    } else {
        pnpNew->dwManualFlags = 0;
    }

    // Set how long the peer has to wait before it is resolved:
    pnpNew->tpTimeRemaining = tpTimeRemaining; 

    // Set the last sync time on this peer
    pnpNew->teLastSuccessfulSync = teLastSuccessfulSync;

    // Initialize the peer critsec
    hr = myInitializeCriticalSection(&pnpNew->csPeer); 
    _JumpIfError(hr, error, "myInitializeCriticalSection"); 
    pnpNew->bCsIsInitialized = true; 

    // Append the new peer to the list of pending peers
    _SafeStlCall(g_pnpstate->vPendingPeers.push_back(pnpNew), hr, error, "push_back");
    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT AddNewPendingDomHierPeer(void) {
    HRESULT hr;

    // allocate new peer
    NtpPeerPtr pnpNew(new NtpPeer);
    _JumpIfOutOfMemory(hr, error, pnpNew);

    // initialize it to the pending state
    pnpNew->ePeerType = e_DomainHierarchyPeer;
    pnpNew->eDiscoveryType = e_Background; 

    // initialize the peer critsec
    hr = myInitializeCriticalSection(&pnpNew->csPeer); 
    _JumpIfError(hr, error, "myInitializeCriticalSection"); 
    pnpNew->bCsIsInitialized = true; 

    // Append the new peer to the list of pending peers
    _SafeStlCall(g_pnpstate->vPendingPeers.push_back(pnpNew), hr, error, "push_back");
    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
// Asynchronously queues shutdown of network providers
// 
MODULEPRIVATE void SendProviderShutdown(DWORD dwExitCode) { 
    HRESULT                 hr; 
    HRESULT                 hr2; 
    WCHAR                   wszNumberBuf[16]; 
    const WCHAR            *rgwszStrings[1]    = { wszNumberBuf }; 

    swprintf(wszNumberBuf, L"0x%08X", dwExitCode); 

    // Log an event indicating that the ntp client is shutting down:
    hr = MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_NTPCLIENT_ERROR_SHUTDOWN, 1, rgwszStrings);
    _IgnoreIfError(hr, "MyLogEvent"); 
    
    hr = SetProviderStatus(L"NtpClient", 0, TPS_Error, true, 0); // Freed by manager thread
    _IgnoreIfError(hr, "SetProviderStatus"); 
    
    // Log an event indicating that the ntp server is shutting down:
    hr = MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_NTPSERVER_ERROR_SHUTDOWN, 1, rgwszStrings);
    _IgnoreIfError(hr, "MyLogEvent"); 

    hr = SetProviderStatus(L"NtpServer", 0, TPS_Error, true, 0); // Freed by manager thread
    _IgnoreIfError(hr, "SetProviderStatus"); 
}
    
//--------------------------------------------------------------------
MODULEPRIVATE HRESULT TrapThreads (BOOL bEnterThreadTrap) {
    bool     bEnteredCriticalSection  = false; 
    HRESULT  hr; 

    if (bEnterThreadTrap) { 
	hr = myEnterCriticalSection(&g_pnpstate->csThreadTrap); 
	_JumpIfError(hr, error, "myEnterCriticalSection"); 
	bEnteredCriticalSection = true;

        // Stop the listening and the peer polling thread: 
        hr = StopPeerPollingThread(); 
        _JumpIfError(hr, error, "StopPeerPollingThread"); 

        hr = StopListeningThread(); 
        _JumpIfError(hr, error, "StopListeningThread"); 
    } else { 
	bEnteredCriticalSection = true; 

        // Start the listening and the peer polling thread: 
        hr = StartPeerPollingThread(); 
        _JumpIfError(hr, error, "StartPeerPollingThread"); 

        hr = StartListeningThread(); 
        _JumpIfError(hr, error, "StartListeningThread"); 

	// We're done 
	hr = myLeaveCriticalSection(&g_pnpstate->csThreadTrap); 
	_JumpIfError(hr, error, "myEnterCriticalSection"); 
    }

    hr=S_OK;
error:
    if (FAILED(hr)) { 
        // This is a fatal error
        SendProviderShutdown(hr); 

	if (bEnteredCriticalSection) { 
	    HRESULT hr2 = myLeaveCriticalSection(&g_pnpstate->csThreadTrap); 
	    _TeardownError(hr, hr2, "myEnterCriticalSection"); 
	}
    }
    return hr;
}

//--------------------------------------------------------------------
// perform any initialization that might fail
MODULEPRIVATE HRESULT InitializeNicSocket(NicSocket * pns, IN_ADDR * pia) {
    HRESULT hr;

    // prepare the sockaddr for later use
    ZeroMemory(&pns->sai, sizeof(pns->sai));
    pns->sai.sin_family=AF_INET;
    pns->sai.sin_port=htons((WORD)NtpConst::nPort);
    pns->sai.sin_addr.S_un.S_addr=pia->S_un.S_addr;

    // create the socket
    pns->socket=socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (INVALID_SOCKET==pns->socket) {
        hr = HRESULT_FROM_WIN32(WSAGetLastError()); 
        _JumpError(hr, error, "socket");
    }

    // bind it to the NTP port for this NIC
    if (SOCKET_ERROR==bind(pns->socket, (sockaddr *)&pns->sai, sizeof(pns->sai))) {
        hr = HRESULT_FROM_WIN32(WSAGetLastError()); 
        _JumpError(hr, error, "bind");
    }

    // create the data available event
    pns->hDataAvailEvent=CreateEvent(NULL /*security*/, FALSE /*auto-reset*/, FALSE /*nonsignaled*/, NULL /*name*/);
    if (NULL==pns->hDataAvailEvent) {
        _JumpLastError(hr, error, "CreateEvent");
    }

    // bind the event to this socket
    if (SOCKET_ERROR==WSAEventSelect(pns->socket, pns->hDataAvailEvent, FD_READ)) {
        hr = HRESULT_FROM_WIN32(WSAGetLastError()); 
        _JumpError(hr, error, "WSAEventSelect");
    }

    // check for sockets that are listen-only.
    // currently, only localhost is listen-only, but we could support more.
    if (LOCALHOST_IP==pia->S_un.S_addr) {
        pns->bListenOnly=true;
    }

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
// Uninitialized the socket
MODULEPRIVATE void FinalizeNicSocket(NicSocket * pns) {

    // close the socket
    if (INVALID_SOCKET!=pns->socket) {
        if (SOCKET_ERROR==closesocket(pns->socket)) {
            _IgnoreLastError("closesocket");
       }
       pns->socket=INVALID_SOCKET;
    }

    // release the event
    if (NULL!=pns->hDataAvailEvent) {
        if (FALSE==CloseHandle(pns->hDataAvailEvent)) {
            _IgnoreLastError("CloseHandle");
        }
        pns->hDataAvailEvent=NULL;
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetLocalAddresses(IN_ADDR ** prgiaLocalAddrs, unsigned int * pnLocalAddrs) {
    HRESULT hr;
    hostent * pHostEnt;
    unsigned int nIndex;
    unsigned int nReturnedAddrs;
    unsigned int nAllocAddrs;
    bool bLocalhostIncluded;

    // must be cleaned up
    IN_ADDR * rgiaLocalAddrs=NULL;

    // get the IP addresses of the local computer
    pHostEnt=gethostbyname(NULL);
    if (NULL==pHostEnt) {
        _JumpLastError(hr, error, "gethostbyname");
    }
    _Verify(NULL!=pHostEnt->h_addr_list, hr, error);
    _Verify(AF_INET==pHostEnt->h_addrtype, hr, error);
    _Verify(sizeof(in_addr)==pHostEnt->h_length, hr, error);

    // figure out how many addresses were returned
    bLocalhostIncluded=false;
    for (nReturnedAddrs=0; NULL!=pHostEnt->h_addr_list[nReturnedAddrs]; nReturnedAddrs++) {
        if (LOCALHOST_IP==((in_addr *)(pHostEnt->h_addr_list[nReturnedAddrs]))->S_un.S_addr) {
            bLocalhostIncluded=true;
        }
    }
    nAllocAddrs=nReturnedAddrs+(bLocalhostIncluded?0:1);

    // allocate the array
    rgiaLocalAddrs=(IN_ADDR *)LocalAlloc(LPTR, sizeof(IN_ADDR)*nAllocAddrs);
    _JumpIfOutOfMemory(hr, error, rgiaLocalAddrs);

    // copy the data
    for (nIndex=0; nIndex<nReturnedAddrs; nIndex++) {
        rgiaLocalAddrs[nIndex].S_un.S_addr=((in_addr *)(pHostEnt->h_addr_list[nIndex]))->S_un.S_addr;
    }
    // make sure localhost is included
    if (!bLocalhostIncluded) {
        rgiaLocalAddrs[nIndex].S_un.S_addr=LOCALHOST_IP;
    }

    // success
    hr=S_OK;
    *prgiaLocalAddrs=rgiaLocalAddrs;
    rgiaLocalAddrs=NULL;
    *pnLocalAddrs=nAllocAddrs;

error:
    if (NULL!=rgiaLocalAddrs) {
        LocalFree(rgiaLocalAddrs);
    }
    return hr;
}

//--------------------------------------------------------------------
// alternate version of GetLocalAddresses. Basically the same.
MODULEPRIVATE HRESULT GetLocalAddresses2(IN_ADDR ** prgiaLocalAddrs, unsigned int * pnLocalAddrs) {
    HRESULT hr;
    unsigned int nIndex;
    DWORD dwSize;
    DWORD dwError;
    unsigned int nEntries;
    unsigned int nEntryIndex;

    // must be cleaned up
    IN_ADDR * rgiaLocalAddrs=NULL;
    MIB_IPADDRTABLE * pIpAddrTable=NULL;

    // find out how big the table is
    dwSize=0;
    dwError=GetIpAddrTable(NULL, &dwSize, false);
    if (ERROR_INSUFFICIENT_BUFFER!=dwError) {
        _Verify(NO_ERROR!=dwError, hr, error);
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpError(hr, error, "GetIpAddrTable");
    }

    // allocate space for the table
    pIpAddrTable=(MIB_IPADDRTABLE *)LocalAlloc(LPTR, dwSize);
    _JumpIfOutOfMemory(hr, error, pIpAddrTable);

    // get the table
    dwError=GetIpAddrTable(pIpAddrTable, &dwSize, false);
    if (NO_ERROR!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpError(hr, error, "GetIpAddrTable");
    }

    // count how many valid entries there are
    nEntries=0;
    for (nIndex=0; nIndex<pIpAddrTable->dwNumEntries; nIndex++) {
        if (0!=pIpAddrTable->table[nIndex].dwAddr) {
            nEntries++;
        }
    }

    // allocate the array of IP addrs
    rgiaLocalAddrs=(IN_ADDR *)LocalAlloc(LPTR, sizeof(IN_ADDR)*nEntries);
    _JumpIfOutOfMemory(hr, error, rgiaLocalAddrs);

    // copy the data
    nEntryIndex=0;
    for (nIndex=0; nIndex<pIpAddrTable->dwNumEntries; nIndex++) {
        if (0!=pIpAddrTable->table[nIndex].dwAddr) {
            rgiaLocalAddrs[nEntryIndex].S_un.S_addr=pIpAddrTable->table[nIndex].dwAddr;
            nEntryIndex++;
        }
    }

    // success
    hr=S_OK;
    *prgiaLocalAddrs=rgiaLocalAddrs;
    rgiaLocalAddrs=NULL;
    *pnLocalAddrs=nEntries;
    
error:
    if (NULL!=rgiaLocalAddrs) {
        LocalFree(rgiaLocalAddrs);
    }
    if (NULL!=pIpAddrTable) {
        LocalFree(pIpAddrTable);
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetInitialSockets(NicSocket *** prgpnsSockets, unsigned int * pnSockets, unsigned int * pnListenOnlySockets) {
    HRESULT hr;
    hostent * pHostEnt;
    unsigned int nIndex;
    unsigned int nSockets;
    unsigned int nListenOnlySockets;

    // must be cleaned up
    NicSocket ** rgpnsSockets=NULL;
    IN_ADDR * rgiaLocalAddrs=NULL;

    // get the IP addresses of the local computer
    hr=GetLocalAddresses2(&rgiaLocalAddrs, &nSockets);
    _JumpIfError(hr, error, "GetLocalAddresses");

    // allocate the array
    rgpnsSockets=(NicSocket **)LocalAlloc(LPTR, sizeof(NicSocket *)*nSockets);
    _JumpIfOutOfMemory(hr, error, rgpnsSockets);

    // create a socket for each address
    for (nIndex=0; nIndex<nSockets; nIndex++) {

        // allocate the structure
        rgpnsSockets[nIndex]=(NicSocket *)LocalAlloc(LPTR, sizeof(NicSocket));
        _JumpIfOutOfMemory(hr, error, rgpnsSockets[nIndex]);

        // Initialize the socket with this address
        hr=InitializeNicSocket(rgpnsSockets[nIndex], &rgiaLocalAddrs[nIndex]);
        _JumpIfError(hr, error, "InitializeNicSocket");

    } // <- End address loop

    // count the listen-only sockets
    nListenOnlySockets=0;
    for (nIndex=0; nIndex<nSockets; nIndex++) {
        if (rgpnsSockets[nIndex]->bListenOnly) {
            nListenOnlySockets++;
        }
    }

    // success
    if (FileLogAllowEntry(FL_NetAddrDetectAnnounce)) {
        FileLogAdd(L"NtpProvider: Created %u sockets (%u listen-only): ", nSockets, nListenOnlySockets);
        for (nIndex=0; nIndex<nSockets; nIndex++) {
            if (0!=nIndex) {
                FileLogAppend(L", ");
            }
            if (rgpnsSockets[nIndex]->bListenOnly) {
                FileLogAppend(L"(");
                FileLogSockaddrInEx(true /*append*/, &rgpnsSockets[nIndex]->sai);
                FileLogAppend(L")");
            } else {
                FileLogSockaddrInEx(true /*append*/, &rgpnsSockets[nIndex]->sai);
            }
        }
        FileLogAppend(L"\n");
    }

    hr=S_OK;
    *prgpnsSockets=rgpnsSockets;
    rgpnsSockets=NULL;
    *pnSockets=nSockets;
    *pnListenOnlySockets=nListenOnlySockets;

error:
    if (NULL!=rgiaLocalAddrs) {
        LocalFree(rgiaLocalAddrs);
    }
    if (NULL!=rgpnsSockets) {
        for (nIndex=0; nIndex<nSockets; nIndex++) {
            if (NULL!=rgpnsSockets[nIndex]) {
                FinalizeNicSocket(rgpnsSockets[nIndex]);
                LocalFree(rgpnsSockets[nIndex]);
                rgpnsSockets[nIndex] = NULL; 
            }
        }
        LocalFree(rgpnsSockets);
    }
    if (FAILED(hr)) {
        _IgnoreError(hr, "GetInitialSockets");
        hr=S_OK;
        FileLog0(FL_NetAddrDetectAnnounce, L"NtpProvider: Created 0 sockets.\n");
        *prgpnsSockets=NULL;
        *pnSockets=0;
        *pnListenOnlySockets=0;
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT PrepareSamples(TpcGetSamplesArgs * ptgsa) {
    HRESULT hr;
    unsigned int nIndex;
    TimeSample * pts;
    unsigned int nBytesRemaining;
    bool bBufTooSmall=false;
    bool bUseFallbackPeers=true;
    NtpPeerVec & vActive = g_pnpstate->vActivePeers;

    hr=myEnterCriticalSection(&g_pnpstate->csPeerList);
    _JumpIfError(hr, error, "myEnterCriticalSection");

    pts=(TimeSample *)ptgsa->pbSampleBuf;
    nBytesRemaining=ptgsa->cbSampleBuf;
    ptgsa->dwSamplesAvailable=0;
    ptgsa->dwSamplesReturned=0;

    NtTimeEpoch teNow;
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teNow.qw);

    // Determine whether to use samples from our fallback peers:
    for (NtpPeerIter pnpIter = vActive.begin(); pnpIter != vActive.end(); pnpIter++) {
        if ((e_DomainHierarchyPeer == (*pnpIter)->ePeerType) || (0 == ((*pnpIter)->dwManualFlags & NCMF_UseAsFallbackOnly))) {
            // Don't use fallback peers if we have an active domain hierarchy peer, or an
            // active non-fallback manual peer
            bUseFallbackPeers = false;
            break;
        }
    }

    // loop through all the peers and send back the good ones
    for (NtpPeerIter pnpIter = vActive.begin(); pnpIter != vActive.end(); pnpIter++) {
        NtpPeerPtr pnp = *pnpIter;

        // Only use samples from fallback peers if we have no other peers to sync from:
        if (e_ManualPeer == pnp->ePeerType                     &&
            0 != (pnp->dwManualFlags & NCMF_UseAsFallbackOnly) &&
            false == bUseFallbackPeers)
        {
            continue;
        }

        ClockFilterSample & cfs=pnp->clockfilter.rgcfsSamples[pnp->nBestSampleIndex];
        if (e_ClockNotSynchronized!=cfs.eLeapIndicator &&
            cfs.tpDispersion<NtpConst::tpMaxDispersion) {
          
            // This peer is synchronized
            ptgsa->dwSamplesAvailable++;

            // is there space in the buffer to send it back?
            if (nBytesRemaining>=sizeof(TimeSample)) {
                pts->dwSize=sizeof(TimeSample);
                pts->dwRefid=pnp->saiRemoteAddr.sin_addr.S_un.S_addr;
                pts->nLeapFlags=cfs.eLeapIndicator;
                pts->nStratum=cfs.nStratum;
                pts->nSysPhaseOffset=cfs.nSysPhaseOffset;
                pts->nSysTickCount=cfs.nSysTickCount;
                pts->toDelay=cfs.toDelay.qw;
                pts->toOffset=cfs.toOffset.qw;
                pts->dwTSFlags=(e_NoAuth!=pnp->eAuthType?TSF_Authenticated:0);
                memcpy(pts->wszUniqueName, pnp->wszUniqueName, sizeof(pnp->wszUniqueName));

                // calculate the dispersion - add skew dispersion due to time
                //  since the sample's dispersion was last updated, add filter dispersion,
                //  and clamp to max dispersion.
                NtTimePeriod tpDispersionTemp=gc_tpZero;
                // see how long it's been since we last updated
                if (teNow>pnp->teLastClockFilterUpdate) {
                    tpDispersionTemp=abs(teNow-pnp->teLastClockFilterUpdate);
                    tpDispersionTemp=NtpConst::timesMaxSkewRate(tpDispersionTemp); // phi * tau
                }
                tpDispersionTemp+=cfs.tpDispersion+pnp->tpFilterDispersion;
                if (tpDispersionTemp>NtpConst::tpMaxDispersion) {
                    tpDispersionTemp=NtpConst::tpMaxDispersion;
                }
                pts->tpDispersion=tpDispersionTemp.qw;

                pts++;
                ptgsa->dwSamplesReturned++;
                nBytesRemaining-=sizeof(TimeSample);
            } else {
                bBufTooSmall=true;
            }

        } // <- end if synchronized
    } // <- end peer loop


    hr=myLeaveCriticalSection(&g_pnpstate->csPeerList);
    _JumpIfError(hr, error, "myLeaveCriticalSection");

    if (bBufTooSmall) {
        hr=HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        _JumpError(hr, error, "(filling in sample buffer)");
    }

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE void ReclampPeerHostPoll(NtpPeerPtr pnp) {
    // Make sure the  host poll interval is in bounds
    signed __int8 nPollTemp=pnp->nHostPollInterval;

    // poll interval not greater than max
    if (nPollTemp>(signed __int8)NtpConst::nMaxPollInverval) {
        nPollTemp=(signed __int8)NtpConst::nMaxPollInverval;
    }

    // poll interval not greater than system poll interval (which is
    //    based on the computed compliance of the local clock)
    // The NTP spec only says to do it if we are syncing from this peer,
    //    but right now we always do this.
    signed __int32 nSysPollInterval;
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_PollInterval, &nSysPollInterval);
    if (nPollTemp>(signed __int8)nSysPollInterval) {
        nPollTemp=(signed __int8)nSysPollInterval;
    }


    // poll interval not less than min
    if (nPollTemp<(signed __int8)NtpConst::nMinPollInverval) {
        nPollTemp=(signed __int8)NtpConst::nMinPollInverval;
    }
    pnp->nHostPollInterval=nPollTemp;
}

//--------------------------------------------------------------------
MODULEPRIVATE void UpdatePeerListTimes(void) {
    bool          bEnteredCriticalSection = false; 
    HRESULT       hr; 
    NtTimePeriod  tpWait;
    NtTimeEpoch   teNow;

    SYNCHRONIZE_PROVIDER(); 

    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teNow.qw);

    // calculate the time since the last update
    if (teNow>g_pnpstate->tePeerListLastUpdated) {
        tpWait=abs(teNow-g_pnpstate->tePeerListLastUpdated);
    } else {
        tpWait=gc_tpZero;
    }
    g_pnpstate->tePeerListLastUpdated=teNow;

    // update the time remaining for all peers:
    for (int nIndex = 0; nIndex < 2; nIndex++) {
        NtpPeerVec & v = 0 == nIndex ? g_pnpstate->vActivePeers : g_pnpstate->vPendingPeers;
        for (NtpPeerIter pnpIter = v.begin(); pnpIter != v.end(); pnpIter++) {
            if ((*pnpIter)->tpTimeRemaining <= tpWait) {
                (*pnpIter)->tpTimeRemaining = gc_tpZero;
            } else {
                (*pnpIter)->tpTimeRemaining -= tpWait;
            }
        }
    }

    hr = S_OK; 
 error:
    UNSYNCHRONIZE_PROVIDER(); 
    // return hr; 
    ;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT UpdatePeerPollingInfo(NtpPeerPtr pnp, UpdateType e_updateType) {
    HRESULT hr;

    // Make sure the host poll interval is in bounds
    ReclampPeerHostPoll(pnp);

    // calculate the actual poll interval
    // poll interval is not greater than PeerPollInterval
    signed __int8 nPollTemp=pnp->nHostPollInterval;
    if (pnp->nPeerPollInterval>=NtpConst::nMinPollInverval
        && nPollTemp>pnp->nPeerPollInterval) {
        nPollTemp=pnp->nPeerPollInterval;
    }

    NtTimePeriod tpTimeRemaining={((unsigned __int64)(((DWORD)1)<<nPollTemp))*10000000};

    // handles special poll interval
    if (e_ManualPeer==pnp->ePeerType && 0!=(NCMF_UseSpecialPollInterval&pnp->dwManualFlags)) {
        tpTimeRemaining.qw=((unsigned __int64)g_pnpstate->dwSpecialPollInterval)*10000000;
    }

    UpdatePeerListTimes();

    if (FileLogAllowEntry(FL_PeerPollIntvDump)) {
        FileLogAdd(L"Peer poll: Max:");
        FileLogNtTimePeriodEx(true /*append*/, tpTimeRemaining);
        if (e_ManualPeer==pnp->ePeerType && 0!=(NCMF_UseSpecialPollInterval&pnp->dwManualFlags)) {
            FileLogAppend(L" (special)");
        }
        FileLogAppend(L" Cur:");
        FileLogNtTimePeriodEx(true /*append*/, pnp->tpTimeRemaining);
    }

    // update the time remaining for this peer.
    // note: this is called both after transmitting and receiving
    switch (e_updateType) { 
    case e_JustSent:
        // we just send a request -- restart the timer
        pnp->tpTimeRemaining=tpTimeRemaining;
        break;

    case e_TimeJumped:
        // We need to be able to provide samples to the manager as quickly as possible.  
        tpTimeRemaining.qw = MINIMUMIRREGULARINTERVAL; 
        /* FALL THROUGH...*/

    case e_Normal:
    default:
        if (pnp->tpTimeRemaining>tpTimeRemaining) {
            // we just received a response, and we need to shorten the
            //   poll interval -- set the time until poll to be the
            //   desired poll interval, randomized so the peer hopefully
            //   doesn't get mobbed.
            // Randomization: use the system tick count as a source of
            //   randomness. Knock out random bits, but guarantee the
            //   result is between 1s and tpTimeRemaining, inclusive.
            pnp->tpTimeRemaining.qw=((((unsigned __int64)GetTickCount())*1000)&(tpTimeRemaining.qw-10000000))+10000000;

            if (FileLogAllowEntry(FL_PeerPollIntvDump)) {
                FileLogAdd(L" New:");
                FileLogNtTimePeriodEx(true /*append*/, pnp->tpTimeRemaining);
            }

            // the heap has been updated. Tell the PeerPollingThread
            if (!SetEvent(g_pnpstate->hPeerListUpdated)) {
                _JumpLastError(hr, error, "SetEvent");
            }
        } else {
            // we just received a response, and we don't need to shorten
            //   the poll interval -- do nothing
        }
    }

    FileLogA0(FL_PeerPollIntvDump, L"\n");

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE void ClearClockFilterSample(ClockFilterSample * pcfs) {
    pcfs->toDelay=gc_toZero;
    pcfs->toOffset=gc_toZero;
    pcfs->tpDispersion=NtpConst::tpMaxDispersion;
    pcfs->nSysTickCount=0;
    pcfs->nSysPhaseOffset=0;
    pcfs->eLeapIndicator=e_ClockNotSynchronized;
    pcfs->nStratum=0;
}

//--------------------------------------------------------------------
MODULEPRIVATE void ClearPeer(NtpPeerPtr pnp) {
    pnp->teExactOriginateTimestamp=gc_teZero;
    pnp->teExactTransmitTimestamp=gc_teZero;
    pnp->teReceiveTimestamp=gc_teNtpZero;
    pnp->nrrReachability.nReg=0;
    pnp->nValidDataCounter=0;

    for (unsigned int nIndex=0; nIndex<ClockFilterSize; nIndex++) {
        ClearClockFilterSample(&pnp->clockfilter.rgcfsSamples[nIndex]);
    }
    pnp->nStratum=0;
    pnp->clockfilter.nNext=0;
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &pnp->teLastClockFilterUpdate.qw); // SPEC ERROR
    pnp->nBestSampleIndex=0;
    pnp->tpFilterDispersion=gc_tpZero;

    pnp->nHostPollInterval=(signed __int8)NtpConst::nMaxPollInverval;
    UpdatePeerPollingInfo(pnp, e_Normal);

    // We're currently unsynchronized, and we'll try to sync as soon as 
    // possible.  Anyone who queries this peer before it syncs should get 
    // a timeout message. 
    pnp->dwError      = HRESULT_FROM_WIN32(ERROR_TIMEOUT); 
    pnp->dwErrorMsgId = 0; 
}

//--------------------------------------------------------------------
MODULEPRIVATE void ClearPeerTimeData(NtpPeerPtr pnp) {
    pnp->teExactOriginateTimestamp=gc_teZero;
    pnp->teExactTransmitTimestamp=gc_teZero;
    pnp->teReceiveTimestamp=gc_teNtpZero;

    for (unsigned int nIndex=0; nIndex<ClockFilterSize; nIndex++) {
        ClearClockFilterSample(&pnp->clockfilter.rgcfsSamples[nIndex]);
    }
    pnp->nStratum=0;
    pnp->clockfilter.nNext=0;
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &pnp->teLastClockFilterUpdate.qw); // SPEC ERROR
    pnp->nBestSampleIndex=0;
    pnp->tpFilterDispersion=gc_tpZero;

    // Update our status reporting fields to indicate no errors. 
    pnp->dwError      = S_OK; 
    pnp->dwErrorMsgId = 0; 
}

//--------------------------------------------------------------------
MODULEPRIVATE int __cdecl CompareSortableSamples(const void * pvElem1, const void * pvElem2) {
    SortableSample * pssElem1=(SortableSample *)pvElem1;
    SortableSample * pssElem2=(SortableSample *)pvElem2;

    if (pssElem1->tpSyncDistance<pssElem2->tpSyncDistance) {
        return -1;
    } else if (pssElem1->tpSyncDistance>pssElem2->tpSyncDistance) {
        return 1;
    } else {
        return (signed int)(pssElem1->nAge-pssElem2->nAge);
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE void AddSampleToPeerClockFilter(NtpPeerPtr pnp, NtpSimplePeer * pnsp) {
    SortableSample rgssList[ClockFilterSize];
    unsigned int nIndex;
    bool bSignalDataChanged=false;

    _MyAssert(e_ManualPeer==pnp->ePeerType || e_DomainHierarchyPeer==pnp->ePeerType);

    if (FileLogAllowEntry(FL_ClockFilterAdd)) {
        if (NULL==pnsp) {
            FileLogAdd(L"No response from peer ");
        } else {
            FileLogAdd(L"Response from peer ");
        }
        FileLogAppend(L"%s", pnp->wszUniqueName);
        if (NULL==pnsp) {
            FileLogAppend(L".\n");
        } else {
            FileLogAppend(L", ofs: ");
            FileLogNtTimeOffsetEx(true /*append*/, pnsp->toLocalClockOffset);
            FileLogAppend(L"\n");
        }
    }

    // see how long it's been since we last updated
    NtTimeEpoch teNow;
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teNow.qw);
    NtTimePeriod tpDispersionSinceLastUpdate=gc_tpZero;
    if (teNow>pnp->teLastClockFilterUpdate) {
        tpDispersionSinceLastUpdate=abs(teNow-pnp->teLastClockFilterUpdate);
        tpDispersionSinceLastUpdate=NtpConst::timesMaxSkewRate(tpDispersionSinceLastUpdate); // phi * tau
    }

    // update the samples in the filter and create the list of
    //   SyncDistances that we can sort
    for (nIndex=0; nIndex<ClockFilterSize; nIndex++) {
        ClockFilterSample & cfsCur=pnp->clockfilter.rgcfsSamples[nIndex]; // for convenience

        // if there was any valid data, then this changed it and we need to
        // notify the manager.
        if (e_ClockNotSynchronized!=cfsCur.eLeapIndicator &&
            cfsCur.tpDispersion<NtpConst::tpMaxDispersion) {
            // valid data
            bSignalDataChanged=true;
        }

        if (pnp->clockfilter.nNext==nIndex) {
            // insert the new clock sample
            if (NULL==pnsp) {
                ClearClockFilterSample(&cfsCur);
            } else {
                cfsCur.toOffset=pnsp->toLocalClockOffset;
                cfsCur.toDelay=pnsp->toRoundtripDelay+pnsp->toRootDelay; // packet delay + root delay
                cfsCur.tpDispersion=pnsp->tpDispersion+pnsp->tpRootDispersion; //  (reading error + skew during packet delay) + root dispertion
                cfsCur.nSysTickCount=pnsp->nSysTickCount;
                cfsCur.nSysPhaseOffset=pnsp->nSysPhaseOffset;
                cfsCur.eLeapIndicator=pnsp->eLeapIndicator;
                cfsCur.nStratum=pnsp->nStratum;
                bSignalDataChanged=true;
            }
        } else {
            // update the dispersion of the old sample to account for
            // the skew-error accumulation since the last update
            cfsCur.tpDispersion+=tpDispersionSinceLastUpdate;
        }
        // clamp dispersion
        if (cfsCur.tpDispersion>NtpConst::tpMaxDispersion) {
            cfsCur.tpDispersion=NtpConst::tpMaxDispersion;
        }

        // add sample SyncDistance to list
        rgssList[nIndex].tpSyncDistance=cfsCur.tpDispersion+abs(cfsCur.toDelay)/2;
        // We want older samples to sort after newer samples if their
        //   SyncDistance is equal, so enforce that all indexes (ages)
        //   are greater than nNext
        rgssList[nIndex].nAge=nIndex+(nIndex<pnp->clockfilter.nNext?ClockFilterSize:0);

    } // <- end for all samples

    // remember the last time this peer was updated
    unsigned int nYoungestAge=pnp->clockfilter.nNext;
    pnp->teLastClockFilterUpdate=teNow;
    pnp->clockfilter.nNext=(pnp->clockfilter.nNext+ClockFilterSize-1)%ClockFilterSize;

    // Sort the list first by increasing SyncDistance, then increasing age
    qsort(rgssList, ClockFilterSize, sizeof(SortableSample), CompareSortableSamples);

    // calculate the filter dispersion, a measure of recent sample
    //   variance recorded for the peer. The measure is based on
    //   first-order differences and computed as the weighted sum
    //   of the clock offsets in a temporary list sorted by
    //   synchronization distance.
    ClockFilterSample & cfsZero=pnp->clockfilter.rgcfsSamples[rgssList[0].nAge%ClockFilterSize];
    NtTimePeriod tpFilterDispersion=gc_tpZero;
    for (nIndex=ClockFilterSize; nIndex>0; nIndex--) { // note: we are working downward
        ClockFilterSample & cfsCur=pnp->clockfilter.rgcfsSamples[rgssList[nIndex-1].nAge%ClockFilterSize];

        // either add the maximum dispersion, or the clock offset
        if (cfsCur.tpDispersion>=NtpConst::tpMaxDispersion) {
            tpFilterDispersion+=NtpConst::tpMaxDispersion;
        } else {
            NtTimePeriod tpTemp=abs(cfsCur.toOffset-cfsZero.toOffset);
            if (tpTemp>NtpConst::tpMaxDispersion) {
                tpFilterDispersion+=NtpConst::tpMaxDispersion;
            } else {
                tpFilterDispersion+=tpTemp;
            }
        }
        // multiply by the (fractional) filter weight.
       NtpConst::weightFilter(tpFilterDispersion);

        if (FileLogAllowEntry(FL_ClockFilterDump)) {
            FileLogAdd(L"%u Age:%u Ofs:", nIndex-1, rgssList[nIndex-1].nAge-nYoungestAge);
            FileLogNtTimeOffsetEx(true /*append*/, cfsCur.toOffset);
            FileLogAppend(L" Dly:");
            FileLogNtTimeOffsetEx(true /*append*/, cfsCur.toDelay);
            FileLogAppend(L" Dsp:");
            FileLogNtTimePeriodEx(true /*append*/, cfsCur.tpDispersion);
            FileLogAppend(L" Dst:");
            FileLogNtTimePeriodEx(true /*append*/, rgssList[nIndex-1].tpSyncDistance);
            FileLogAppend(L" FDsp:");
            FileLogNtTimePeriodEx(true /*append*/, tpFilterDispersion);
            FileLogAppend(L"\n");
        }
    }

    // The peer offset, delay and dispersion are chosen as the values
    //   corresponding to the minimum-distance sample; in other words,
    //   the sample corresponding to the first entry on the temporary
    //   list.

    pnp->tpFilterDispersion=tpFilterDispersion;
    pnp->nBestSampleIndex=rgssList[0].nAge%ClockFilterSize;

    // only signal if we have a data change
    if (bSignalDataChanged) {
        pnp->nStratum=pnp->clockfilter.rgcfsSamples[pnp->nBestSampleIndex].nStratum; 
        g_pnpstate->tpsc.pfnAlertSamplesAvail();
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT PollPeer(NtpPeerPtr pnp, bool * pbRemovePeer) {
    AuthenticatedNtpPacket   anpOut;
    bool                     bEnteredCriticalSection  = false;   
    HRESULT                  hr;
    signed int               nPollInterval;
    NtpPacket               &npOut                    = *((NtpPacket *)&anpOut);
    NtTimeEpoch              teSysReferenceTimestamp;
    NtTimeEpoch              teSysTime;
    NtTimeOffset             toSysRootDelay;
    NtTimePeriod             tpRootDispersion; 
    NtTimePeriod             tpSkew;
    NtTimePeriod             tpSysClockTickSize;
    NtTimePeriod             tpSysRootDispersion;
    NtTimePeriod             tpTimeSinceLastSysClockUpdate; 
    sockaddr_in              saiRemoteAddr;
    SOCKET                   socket;

    *pbRemovePeer=false;

    SYNCHRONIZE_PROVIDER(); 

    // Local copies of global data (used to avoid lock contention
    saiRemoteAddr  = pnp->saiRemoteAddr; 
    socket         = pnp->pnsSocket->socket; 

    FileLog1(FL_PollPeerAnnounce, L"Polling peer %s\n", pnp->wszUniqueName);

    // grab the system parameters that we'll need
    BYTE nSysLeapFlags;
    BYTE nSysStratum;
    signed __int32 nSysPrecision;
    DWORD dwSysRefid;
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_RootDelay, &toSysRootDelay.qw);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_RootDispersion, &tpSysRootDispersion.qw);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_ClockTickSize, &tpSysClockTickSize.qw);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_LastSyncTime, &teSysReferenceTimestamp.qw);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teSysTime.qw);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_LeapFlags, &nSysLeapFlags);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_Stratum, &nSysStratum);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_ClockPrecision, &nSysPrecision);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_ReferenceIdentifier, &dwSysRefid);

    // fill out the packet
    npOut.nLeapIndicator=nSysLeapFlags;
    npOut.nVersionNumber=NtpConst::nVersionNumber;
    npOut.nMode=pnp->eMode;
    npOut.nStratum=nSysStratum;
    npOut.nPollInterval=pnp->nHostPollInterval;
    npOut.nPrecision=(signed __int8)nSysPrecision;
    npOut.toRootDelay=NtpTimeOffsetFromNtTimeOffset(toSysRootDelay);

    // calculate the dispersion
    tpTimeSinceLastSysClockUpdate=abs(teSysTime-teSysReferenceTimestamp);
    if (e_ClockNotSynchronized==nSysLeapFlags
        || tpTimeSinceLastSysClockUpdate>NtpConst::tpMaxClockAge) {
        tpSkew=NtpConst::tpMaxSkew;
    } else {
        tpSkew=NtpConst::timesMaxSkewRate(tpTimeSinceLastSysClockUpdate);
    }
    tpRootDispersion=tpSysRootDispersion+tpSysClockTickSize+tpSkew;
    if (tpRootDispersion>NtpConst::tpMaxDispersion) {
        tpRootDispersion=NtpConst::tpMaxDispersion;
    }
    npOut.tpRootDispersion=NtpTimePeriodFromNtTimePeriod(tpRootDispersion);

    // check for win2K detection for compatibility
    if (0!=(pnp->dwCompatibilityFlags&NCCF_AutodetectWin2K)) {
        if (0!=(pnp->dwCompatibilityFlags&NCCF_AutodetectWin2KStage2)) {
            // stage 2: use special value for dispersion and see if it gets echoed back
            npOut.tpRootDispersion.dw=AUTODETECTWIN2KPATTERN;
            FileLog1(FL_Win2KDetectAnnounceLow, L"Sending packet to %s in Win2K detect mode, stage 2.\n", pnp->wszUniqueName);
        } else {
            // stage 1: remember dispersion we sent and see if it gets echoed back
            pnp->dwCompatLastDispersion=npOut.tpRootDispersion.dw;
            FileLog1(FL_Win2KDetectAnnounceLow, L"Sending packet to %s in Win2K detect mode, stage 1.\n", pnp->wszUniqueName);
        }
    }

    // fill out the packet
    npOut.refid.value=dwSysRefid;
    npOut.teReferenceTimestamp=NtpTimeEpochFromNtTimeEpoch(teSysReferenceTimestamp);
    npOut.teOriginateTimestamp=pnp->teExactOriginateTimestamp;
    npOut.teReceiveTimestamp=NtpTimeEpochFromNtTimeEpoch(pnp->teReceiveTimestamp);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teSysTime.qw); // time sensitive
    npOut.teTransmitTimestamp=NtpTimeEpochFromNtTimeEpoch(teSysTime);

    if (e_NoAuth==pnp->eAuthType) {
	// Release the provider critical section for the network access. 
	// See bug #385716. 
	UNSYNCHRONIZE_PROVIDER(); 

        // send unauthenticated packet
        int nBytesSent;
        nBytesSent=sendto(socket, (char *)&npOut, SizeOfNtpPacket,
            0 /*flags*/, (sockaddr *)&saiRemoteAddr, sizeof(saiRemoteAddr));

	// We've finished our network access, get our critsec back
	SYNCHRONIZE_PROVIDER(); 

	// Now that we've re-acquired our critsec, copy over the data returned from sendto()
	pnp->saiRemoteAddr = saiRemoteAddr; 
	pnp->teExactTransmitTimestamp = npOut.teTransmitTimestamp; // must match exactly for later validation

        if (SOCKET_ERROR==nBytesSent) {
            HRESULT hr2 = HRESULT_FROM_WIN32(WSAGetLastError()); 
            _IgnoreError(hr2, "sendto"); 
            // Save the last error for this peer
            pnp->dwError       = hr2; 
            pnp->dwErrorMsgId  = W32TIMEMSG_UNREACHABLE_PEER;
        } else if (nBytesSent<SizeOfNtpPacket) {
            // BUGBUG: need error string here 
            FileLog0(FL_PollPeerWarn, L"PollPeer: Fewer bytes sent than requested. Ignoring error.\n");
        }

    } else if (e_NtDigest==pnp->eAuthType) {
        // send authenticated packet
        bool bSkipSend=false;
	// We rely on this bit being 0 -- we need to use it to request either the old or new server digest
	_MyAssert(0 == (pnp->dwRequestTrustRid & TRUST_RID_OLD_DIGEST_BIT)); 
        anpOut.nKeyIdentifier=pnp->dwRequestTrustRid;
	if (pnp->bUseOldServerDigest) { 
	    anpOut.nKeyIdentifier |= TRUST_RID_OLD_DIGEST_BIT; 
	}
        ZeroMemory(anpOut.rgnMessageDigest, sizeof(anpOut.rgnMessageDigest));
        if (0!=pnp->dwResponseTrustRid) {
	    bool bUseOldServerDigest; 
            CHAR OldMessageDigest[16];
	    CHAR NewMessageDigest[16]; 

            // We must be doing symmetric active - we are a DC responding
            // to another DC with a comination request/response.

	    // Determine whether the client desires the old or the current server digest.  This is stored in the high bit of the trust rid:
	    bUseOldServerDigest = 0 != (TRUST_RID_OLD_DIGEST_BIT & pnp->dwResponseTrustRid); 
	    // Mask off the digest bit of the rid, or we won't be able to look up the appropriate account for this rid: 
	    pnp->dwResponseTrustRid &= ~TRUST_RID_OLD_DIGEST_BIT; 

	    FileLog2(FL_TransResponseAnnounce, L"Computing server digest: OLD:%s, RID:%08X\n", (bUseOldServerDigest ? L"TRUE" : L"FALSE"), pnp->dwResponseTrustRid); 
	    // Sign the packet: 
            DWORD dwErr=I_NetlogonComputeServerDigest(NULL, pnp->dwResponseTrustRid, (BYTE *)&npOut, SizeOfNtpPacket, NewMessageDigest, OldMessageDigest);
            if (ERROR_SUCCESS!=dwErr) {
                hr=HRESULT_FROM_WIN32(dwErr);
                _IgnoreError(hr, "I_NetlogonComputeServerDigest");

                // if we can't sign, just don't send the packet.
                // this will be treated like any other unreachable condition.
                bSkipSend=true;

                { // log the warning
                    HRESULT hr2;
                    const WCHAR * rgwszStrings[2];
                    WCHAR * wszError=NULL;
                    WCHAR wszIP[16];
                    DWORD dwBufSize=ARRAYSIZE(wszIP);

                    // get the friendly error message
                    hr2=GetSystemErrorString(hr, &wszError);
                    if (FAILED(hr2)) {
                        _IgnoreError(hr2, "GetSystemErrorString");
                    } else if (SOCKET_ERROR==WSAAddressToString((sockaddr *)&pnp->pnsSocket->sai, sizeof(pnp->pnsSocket->sai), NULL/*protocol_info*/, wszIP, &dwBufSize)) {
                        _IgnoreLastError("WSAAddressToString");
                        LocalFree(wszError);
                    } else {
                        // log the event
                        rgwszStrings[0]=wszIP;
                        rgwszStrings[1]=wszError;
                        FileLog2(FL_PollPeerWarn, L"Logging warning: NtpServer encountered an error while validating the computer account for symmetric peer %s. NtpServer cannot provide secure (signed) time to the peer and will not send a packet. The error was: %s\n", rgwszStrings[0], rgwszStrings[1]);
                        hr2=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_SYMMETRIC_COMPUTE_SERVER_DIGEST_FAILED, 2, rgwszStrings);
                        _IgnoreIfError(hr2, "MyLogEvent");
                        LocalFree(wszError);
                    }
                } // <- end logging block

            } // <- end if signing failed
	    
	    // Fill in the digest fields in the packet with the digest requested by the client: 
	    if (bUseOldServerDigest) { 
		memcpy(anpOut.rgnMessageDigest, OldMessageDigest, sizeof(OldMessageDigest)); 
	    } else { 
		memcpy(anpOut.rgnMessageDigest, NewMessageDigest, sizeof(OldMessageDigest)); 
	    }
        } else {
            // client mode - we can't sign a request (because we are not a DC)
            // just send a big packet to the server knows we want a signed response
        }

        // send the signed packet
        if (false==bSkipSend) {
	    // Release the provider critical section for the network access. 
	    // See bug #385716. 
	    UNSYNCHRONIZE_PROVIDER(); 

            int nBytesSent;
            nBytesSent=sendto(socket, (char *)&anpOut, SizeOfNtAuthenticatedNtpPacket,
                0 /*flags*/, (sockaddr *)&saiRemoteAddr, sizeof(saiRemoteAddr));

	    // We've finished our network access, get our critsec back
	    SYNCHRONIZE_PROVIDER(); 

	    // Now that we've re-acquired our critsec, copy over the data returned from sendto()
	    pnp->saiRemoteAddr = saiRemoteAddr; 
	    pnp->teExactTransmitTimestamp = npOut.teTransmitTimestamp; // must match exactly for later validation

            if (SOCKET_ERROR==nBytesSent) {
                HRESULT hr2 = HRESULT_FROM_WIN32(WSAGetLastError()); 
                _IgnoreError(hr2, "sendto"); 
                // Save the last error for this peer
                pnp->dwError       = hr2; 
                pnp->dwErrorMsgId  = W32TIMEMSG_UNREACHABLE_PEER; 
            } else if (nBytesSent<SizeOfNtAuthenticatedNtpPacket) {
                FileLog0(FL_PollPeerWarn, L"PollPeer: Fewer bytes sent than requested. Ignoring error.\n");
            }
        }

    } else {
        _MyAssert(false); // unknown auth type
    }

    // update the reachability register
    pnp->nrrReachability.nReg<<=1;

    // if the peer has not responded in the last n polls, and
    // this is a temporary association, forget about it.
    if (0==pnp->nrrReachability.nReg) { 
        // Report our status, if we haven't already detected an error:
        if (!FAILED(pnp->dwError)) { 
            pnp->dwError = E_FAIL; 
            pnp->dwErrorMsgId = W32TIMEMSG_UNREACHABLE_PEER; 
        }

        if (e_DynamicPeer==pnp->ePeerType || e_DomainHierarchyPeer==pnp->ePeerType) {
            *pbRemovePeer=true;
            goto done;
        }
    }

    // If valid data have been shifted into the filter register at least once during the preceding two poll
    // intervals (low-order bit of peer.reach set to one), the valid data counter is incremented. After eight
    // such valid intervals the poll interval is incremented. Otherwise, the valid data counter and poll
    // interval are both decremented and the clock-filter procedure called with zero values for offset and
    // delay and NTP.MAXDISPERSE for dispersion. The clock-select procedure is called to reselect the
    // synchronization source, if necessary.

    if (0!=(pnp->nrrReachability.nReg&0x06)) { // test two low-order bits (shifted)
        if (pnp->nValidDataCounter<NtpReachabilityReg::nSize) {
            pnp->nValidDataCounter++;
        } else {
            pnp->nHostPollInterval++;
        }
    } else {
        if (pnp->nValidDataCounter>0) { // SPEC ERROR
            pnp->nValidDataCounter--;
        }
        pnp->nHostPollInterval--;
        AddSampleToPeerClockFilter(pnp, NULL);

        // log an event if the reachability changed
        if (e_NewManualPeer==pnp->eLastLoggedReachability) {
            pnp->eLastLoggedReachability=e_NeverLogged; // ignore the first send for manual peers
        } else if (e_Unreachable!=pnp->eLastLoggedReachability
            && 0!=(NCELF_LogReachabilityChanges&g_pnpstate->dwEventLogFlags)) {

            WCHAR * rgwszStrings[1]={pnp->wszUniqueName};
            FileLog1(FL_ReachabilityAnnounceLow, L"Logging information: NtpClient cannot reach or is currently receiving invalid time data from %s.\n", rgwszStrings[0]);
            hr=MyLogEvent(EVENTLOG_INFORMATION_TYPE, MSG_TIME_SOURCE_UNREACHABLE, 1, (const WCHAR **)rgwszStrings);
            _IgnoreIfError(hr, "MyLogEvent");
            pnp->eLastLoggedReachability=e_Unreachable;
        }
    }

    hr=UpdatePeerPollingInfo(pnp, e_JustSent /*just did send*/);
    _JumpIfError(hr, error, "UpdatePeerPollingInfo");

done:
    hr=S_OK;
error:
    UNSYNCHRONIZE_PROVIDER(); 
    return hr;
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT CreateNewActivePeers(in_addr * rgiaLocalIpAddrs, in_addr * rgiaRemoteIpAddrs, unsigned int nIpAddrs, unsigned int * pnPeersCreated) {
    HRESULT hr;
    unsigned int nIndex;
    unsigned int nEntries;
    unsigned int nAddrIndex;
    unsigned int nSockIndex;
    unsigned int nFirstNewPeer;
    unsigned int nCreatedPeers;
    NtpPeerVec &vActive = g_pnpstate->vActivePeers;  // aliased for readability

    *pnPeersCreated=0;

    // must be cleaned up
    bool bIncompleteNewPeersInMiddle=false;

    // figure out how many entries we will make
    nEntries=nIpAddrs;
    for (nIndex=0; nIndex<nIpAddrs; nIndex++) {
        if (INADDR_ANY==rgiaLocalIpAddrs[nIndex].S_un.S_addr) {
            nEntries+=g_pnpstate->nSockets-g_pnpstate->nListenOnlySockets-1;
        } else {
            // make sure that we have a socket for it
            unsigned int nSocketIndex;
            for (nSocketIndex=0; nSocketIndex<g_pnpstate->nSockets; nSocketIndex++) {
                if (!g_pnpstate->rgpnsSockets[nSocketIndex]->bListenOnly
                    && rgiaLocalIpAddrs[nIndex].S_un.S_addr==g_pnpstate->rgpnsSockets[nSocketIndex]->sai.sin_addr.S_un.S_addr) {
                    break;
                }
            }
            if (nSocketIndex==g_pnpstate->nSockets) {
                // sweep it under the rug.
                FileLog0(FL_CreatePeerWarn, L"MyGetIpAddrs returned a local IP we don't have a socket for!\n");
                nIpAddrs--;
                rgiaLocalIpAddrs[nIndex].S_un.S_addr=rgiaLocalIpAddrs[nIpAddrs].S_un.S_addr;
                rgiaRemoteIpAddrs[nIndex].S_un.S_addr=rgiaRemoteIpAddrs[nIpAddrs].S_un.S_addr;
                nEntries--;
                nIndex--;
            } // <- end if no socket for IP addr
        } // <- end if IP addr if not INADDR_ANY
    } // <- end IP addr loop

    if (0==nEntries) {
        // This is approximately the right error. We can't find a NIC for any of the local IPs.
        hr=HRESULT_FROM_WIN32(ERROR_DEV_NOT_EXIST);
        _JumpError(hr, error, "(finding sockets for IP addresses)");
    }

    // We're appending the new peer:  set this counter varible appropriately
    nFirstNewPeer = vActive.size();
    // We'll want to free the new peers we've allocated if the function fails
    // after this statement. 
    bIncompleteNewPeersInMiddle = true; 

    // allocate the blanks
    for (nCreatedPeers=0; nCreatedPeers<nEntries; nCreatedPeers++) {
        NtpPeerPtr pnp(new NtpPeer);
        _JumpIfOutOfMemory(hr, error, pnp);
        _SafeStlCall(vActive.push_back(pnp), hr, error, "push_back");

	hr = myInitializeCriticalSection(&pnp->csPeer); 
	_JumpIfError(hr, error, "myInitializeCriticalSection"); 
	pnp->bCsIsInitialized = true; 
    }

    // finish setting up the new active peers.
    nIndex=0;
    for (nAddrIndex=0; nAddrIndex<nIpAddrs; nAddrIndex++) {
        for (nSockIndex=0; nSockIndex<g_pnpstate->nSockets; nSockIndex++) {
            if (!g_pnpstate->rgpnsSockets[nSockIndex]->bListenOnly
                && (INADDR_ANY==rgiaLocalIpAddrs[nAddrIndex].S_un.S_addr
                || rgiaLocalIpAddrs[nAddrIndex].S_un.S_addr==g_pnpstate->rgpnsSockets[nSockIndex]->sai.sin_addr.S_un.S_addr)) {

                // set up this instance
                NtpPeerPtr pnp = vActive[nFirstNewPeer+nIndex];
                pnp->saiRemoteAddr.sin_port=EndianSwap((unsigned __int16)NtpConst::nPort);
                pnp->saiRemoteAddr.sin_family=AF_INET;
                pnp->saiRemoteAddr.sin_addr.S_un.S_addr=rgiaRemoteIpAddrs[nAddrIndex].S_un.S_addr;
                pnp->pnsSocket=g_pnpstate->rgpnsSockets[nSockIndex];

                pnp->dwCompatibilityFlags=g_pnpstate->dwClientCompatibilityFlags;

                nIndex++;

            } else {
                // no binding for this socket
            }
        }
    }
    _MyAssert(nIndex==nEntries);

    *pnPeersCreated=nEntries;
    bIncompleteNewPeersInMiddle=false;

    hr=S_OK;
error:
    if (bIncompleteNewPeersInMiddle) {
        vActive.erase(vActive.end() - nCreatedPeers, vActive.end());
    }

    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetDomainHierarchyIpAddrs(DiscoveryType eDiscoveryType, unsigned int nRetryMinutes, in_addr ** prgiaLocalIpAddrs, in_addr ** prgiaRemoteIpAddrs, unsigned int *pnIpAddrs, DWORD * pdwTrustRid, bool * pbRetry, WCHAR ** pwszDcName, WCHAR ** pwszDomainName, DiscoveryType * peNextDiscoveryType) {
    bool           bEnteredCriticalSection  = false; 
    DWORD          dwErr; 
    DWORD          dwForceFlags  = 0; 
    HRESULT        hr; 
    unsigned int   nIpAddrs; 
    unsigned long  ulBits; 
    WCHAR          wszForceName[20]; 

    // must be cleaned up 
    DOMAIN_CONTROLLER_INFO            *pdci                 = NULL;
    DOMAIN_CONTROLLER_INFO            *pdciChosen           = NULL;
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC  *pDomInfo             = NULL;
    in_addr                           *rgiaLocalIpAddrs     = NULL;
    in_addr                           *rgiaRemoteIpAddrs    = NULL;
    WCHAR                             *wszDcName            = NULL;
    WCHAR                             *wszDomainName        = NULL;
    WCHAR                             *wszParentDomName     = NULL; 
    WCHAR                             *wszSiteName          = NULL;
    
    // init out params
    // Keep trying to resolve domain hierarchy peers until we have a good reason not to
    *pbRetry = true;
    *peNextDiscoveryType = e_Background; 

    // 
    if (e_Force == eDiscoveryType) { 
	dwForceFlags = DS_FORCE_REDISCOVERY; 
	wcscpy(wszForceName, L"FORCE"); 
    } else if (e_Foreground == eDiscoveryType) { 
	dwForceFlags = 0;  
	wcscpy(wszForceName, L"FOREGROUND"); 
    } else if (e_Background == eDiscoveryType) { 
	dwForceFlags = DS_BACKGROUND_ONLY; 
	wcscpy(wszForceName, L"BACKGROUND"); 
    } else { 
	// Bad discovery type:
	_MyAssert(false); 
    }

    // for convenience
    DWORD dwBaseDcRequirements     = dwForceFlags|DS_TIMESERV_REQUIRED|DS_IP_REQUIRED|DS_AVOID_SELF; 
    DWORD dwGoodTimeservPreferred  = dwBaseDcRequirements | DS_GOOD_TIMESERV_PREFERRED; 
    DWORD dwPdcRequired            = dwBaseDcRequirements | DS_PDC_REQUIRED; 

    // get our current role
    dwErr=DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (BYTE **)&pDomInfo);
    if (ERROR_SUCCESS!=dwErr) {
        hr=HRESULT_FROM_WIN32(dwErr);
        _JumpError(hr, error, "DsRoleGetPrimaryDomainInformation");
    }

    // Acquire the provider critsec
    SYNCHRONIZE_PROVIDER(); 

    // get our site name so we can restrict our network usage to be local
    dwErr=DsGetSiteName(NULL, &wszSiteName);
    if (NO_ERROR!=dwErr && ERROR_NO_SITENAME!=dwErr) {
        hr=HRESULT_FROM_WIN32(dwErr);
        _JumpError(hr, error, "DsGetSiteName");
    }

    // Release the provider critsec
    UNSYNCHRONIZE_PROVIDER(); 

    if (DsRole_RoleMemberWorkstation==pDomInfo->MachineRole
        || DsRole_RoleMemberServer==pDomInfo->MachineRole) {

	WCHAR *wszSiteToQuery; 

        // We are a member of a domain. Get the time from a DC
	// First, see if we're allowed to sync out-of-site. 
	if (NCCSS_All == g_pnpstate->dwCrossSiteSyncFlags || NULL == wszSiteName) { 
	    // Either we've specified that we can sync out-of-site, or we're not in a site.  
	    wszSiteToQuery = NULL; 
	} else { 
	    // We're not allowed to sync out of site, and we have a site name:
	    wszSiteToQuery = wszSiteName; 
	}
	
	dwErr=DsGetDcName(NULL, NULL, NULL, wszSiteToQuery, dwBaseDcRequirements, &pdciChosen);
        if (NO_ERROR!=dwErr && ERROR_NO_SUCH_DOMAIN!=dwErr) {
            hr=HRESULT_FROM_WIN32(dwErr);
            _JumpError(hr, error, "DsGetDcName");
        }

        if (ERROR_NO_SUCH_DOMAIN==dwErr) {
            FileLog0(FL_DomHierAnnounceLow, L"Domain member query: no DC found.\n");
        } else {
            FileLog1(FL_DomHierAnnounceLow, L"Domain member syncing from %s.\n", pdciChosen->DomainControllerName);
        }
    } else {
	// We are a DC in a domain 
	BOOL bPdcInSite; 

        // get some more useful info
        dwErr=NetLogonGetTimeServiceParentDomain(NULL, &wszParentDomName, &bPdcInSite);
        if (ERROR_SUCCESS!=dwErr && ERROR_NO_SUCH_DOMAIN!=dwErr) {
            hr=HRESULT_FROM_WIN32(dwErr);
            _JumpError(hr, error, "NetLogonGetTimeServiceParentDomain");
        }
        // wszParentDomName may be null - that means we are root.

        dwErr=W32TimeGetNetlogonServiceBits(NULL, &ulBits); 
        if (ERROR_SUCCESS != dwErr) { 
            hr = HRESULT_FROM_WIN32(dwErr); 
            _JumpError(hr, error, "W32TimeGetNetlogonServiceBits"); 
        }
	
	// Acquire the provider critsec
	SYNCHRONIZE_PROVIDER(); 

        bool fIsPdc             = DsRole_RolePrimaryDomainController == pDomInfo->MachineRole; 
        bool fOutOfSiteAllowed  = ((NCCSS_PdcOnly == g_pnpstate->dwCrossSiteSyncFlags && fIsPdc) ||
                                   (NCCSS_All     == g_pnpstate->dwCrossSiteSyncFlags)); 
        bool fIsReliable        = 0 != (DS_GOOD_TIMESERV_FLAG & ulBits); 

	// Release the provider critsec
	UNSYNCHRONIZE_PROVIDER(); 

	//////////////////////////////////////////////////////////////////////////////////
	//
	// TIME SERVICE DISCOVERY ALGORITHM FOR DOMAIN CONTROLLERS
	// -------------------------------------------------------
	// 
	// Construct a list of DCs to search to find a time service.  Our goals are to:
	// 
	//   a) Avoid cycles in the synchronization network
	//   b) Minimize the amount of network traffic, especially out-of-site traffic
	//
	// To this end, we make 6 queries: 
	// 
	//   1) Good timeserv in the parent domain, current site
	//   2) Good timeserv in the current domain, current site
	//   3) PDC in the the current domain, current site
	//   4) Good timeserv in the parent domain, any site
	//   5) Good timeserv in the current domain, any site
	//   6) PDC in the the current domain, current any site
	// 
	// Each DC we query is assigned a score based on the following algorithm: 
	//
        //   Add 8 if DC is in-site
	//   Add 4 if DC is a reliable time service  
	//   Add 2 if DC is in the parent domaink
	//   Add 1 if DC is a PDC 
	//
	// and we do not make any more queries once we've determined that we can't improve 
	// upon the score of our current DC.  
	//
	// Finally, each query must abide by the following constraints:
	//   
	//   A reliable time service can choose only a PDC, or a DC in the parent domain. 
	//   A PDC can only choose DCs in the parent domain. 
	// 
	// the query is not made if the DC would not be able to sync from the type of 
	// DC it is querying. 
	// 
	//////////////////////////////////////////////////////////////////////////////////

        struct DcSearch { 
            BOOL   fRequireParentDom; 
            BOOL   fRequireSite; 
            BOOL   fAllowReliableClients; 
            BOOL   fAllowPdcClients; 
            LPWSTR pwszDomainName; 
            LPWSTR pwszSiteName; 
            DWORD  dwFlags; 
            DWORD  dwMaxScore; 
        } rgDCs[] = { 
            { TRUE,  TRUE,               TRUE,  TRUE,   wszParentDomName,  wszSiteName,  dwGoodTimeservPreferred,  14 }, 
            { FALSE, TRUE,               FALSE, FALSE,  NULL,              wszSiteName,  dwGoodTimeservPreferred,  12 }, 
            { FALSE, TRUE,               TRUE,  FALSE,  NULL,              wszSiteName,  dwPdcRequired,            9 }, 
            { TRUE,  !fOutOfSiteAllowed, TRUE,  TRUE,   wszParentDomName,  NULL,         dwGoodTimeservPreferred,  NULL == wszSiteName ? 14 : 6 }, 
            { FALSE, !fOutOfSiteAllowed, FALSE, FALSE,  NULL,              NULL,         dwGoodTimeservPreferred,  NULL == wszSiteName ? 12 : 4 }, 
            { FALSE, !fOutOfSiteAllowed, TRUE,  FALSE,  NULL,              NULL,         dwPdcRequired,            NULL == wszSiteName ? 9  : 1 }
        }; 

        // Search for the best possible DC to sync from: 
	DWORD dwCurrentScore = 0; 
        for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgDCs); dwIndex++) {
            DcSearch dc = rgDCs[dwIndex]; 

            // See if we need to attempt this query: 
            if ((dc.fRequireParentDom && NULL == dc.pwszDomainName) ||  // We can't query a parent DC if we have no parent domain
                (dc.fRequireSite && NULL == dc.pwszSiteName) ||         // We can't do a site-specific query if we have no site
                (dc.dwMaxScore <= dwCurrentScore) ||                    // This DC won't be any better than one we have.  No reason to query it. 
                (!dc.fAllowReliableClients && fIsReliable)  ||          // We're reliable, and this DC doesn't allow reliable TS clients from this domain
                (!dc.fAllowPdcClients && fIsPdc)                        // We're the PDC, and this DC doesn't allow PDC clients from this domain
                ) { 
                continue; 
            }

            // We'll try the query. 
            FileLog5(FL_DomHierAnnounceLow, L"Query %d (%s): <SITE: %s, DOM: %s, FLAGS: %08X>\n", dwIndex, wszForceName, dc.pwszSiteName, dc.pwszDomainName, dc.dwFlags); 
            
            dwErr=DsGetDcName(NULL, dc.pwszDomainName, NULL, dc.pwszSiteName, dc.dwFlags, &pdci);
            if (ERROR_SUCCESS!=dwErr && ERROR_NO_SUCH_DOMAIN!=dwErr) {
		FileLog1(FL_DomHierAnnounceLow, L"Query %d: error: %08X\n", dwErr); 
                hr=HRESULT_FROM_WIN32(dwErr);
                _JumpError(hr, error, "DsGetDcName");
            }
            if (ERROR_NO_SUCH_DOMAIN==dwErr) {
                FileLog1(FL_DomHierAnnounceLow, L"Query %d: no DC found.\n", dwIndex);
            } else {
                // See if the DC we've found is better than our current best: 
                DWORD dwScore = ((DS_CLOSEST_FLAG&pdci->Flags)?8:0) + ((NULL!=dc.pwszDomainName)?2:0); 

                if (0 != (DS_PDC_REQUIRED&dc.dwFlags)) { 
                    dwScore += 1; 
                } else if (0 != (DS_GOOD_TIMESERV_FLAG&pdci->Flags)) { 
                    dwScore += 4; 
                }

                FileLog3(FL_DomHierAnnounceLow, L"Query %d: %s found.  Score: %u\n", dwIndex, pdci->DomainControllerName, dwScore);

                if (dwScore > dwCurrentScore) { 
                    // This DC is the best we've found so far. 
                    if (NULL != pdciChosen) { 
                        NetApiBufferFree(pdciChosen); 
                    }
                    pdciChosen = pdci; 
                    pdci = NULL; 
                    dwCurrentScore = dwScore; 
                }
            }

            if (NULL != pdci) { 
                NetApiBufferFree(pdci); 
                pdci = NULL; 
            }
        }
    }

    if (NULL==pdciChosen) {
	SYNCHRONIZE_PROVIDER(); 

        // No DC. Why?
        if (DsRole_RolePrimaryDomainController==pDomInfo->MachineRole && NULL==wszParentDomName) {
            // we are the root of the time service
            if (false==g_pnpstate->bLoggedOnceMSG_DOMAIN_HIERARCHY_ROOT) {
                g_pnpstate->bLoggedOnceMSG_DOMAIN_HIERARCHY_ROOT=true;
                FileLog0(FL_DomHierWarn, L"Logging warning: NtpClient: This machine is the PDC of the domain at the root of the forest, so there is no machine above it in the domain hierarchy to use as a time source. NtpClient will fall back to the remaining configured time sources, if any are available.\n");
                hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_DOMAIN_HIERARCHY_ROOT, 0, NULL);
                _IgnoreIfError(hr, "MyLogEvent");
            }
            // We're the highest authority in the domain hierarchy --
            // there's no one else to sync from!
            // NOTE: We'll re-add a domain hierarchy peer if our domhier role changes
            *pbRetry = false;
            hr=HRESULT_FROM_WIN32(ERROR_DC_NOT_FOUND);
            _JumpError(hr, error, "(finding a time source when machine is hierarchy root)");
        } else if (0==(pDomInfo->Flags&DSROLE_PRIMARY_DOMAIN_GUID_PRESENT)) {
            // NT4 domain
            if (false==g_pnpstate->bLoggedOnceMSG_NT4_DOMAIN) {
                g_pnpstate->bLoggedOnceMSG_NT4_DOMAIN=true;
                FileLog0(FL_DomHierWarn, L"Logging warning: NtpClient: This machine is in an NT4 domain. NT4 domains do not have a time service, so there is no machine in the domain hierarchy to use as a time source. NtpClient will fall back to the remaining configured time sources, if any are available.\n");
                hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_NT4_DOMAIN, 0, NULL);
                _IgnoreIfError(hr, "MyLogEvent");
            }
            // Can't sync from NT4 domain
            *pbRetry = false;
            hr=HRESULT_FROM_WIN32(ERROR_DC_NOT_FOUND);
            _JumpError(hr, error, "(finding a time source when machine is in NT4 domain)");
        } else {
            // just couldn't find anything
            WCHAR wszTime[15];
            const WCHAR * rgwszStrings[1]={wszTime};
            wsprintf(wszTime, L"%u", nRetryMinutes);
            FileLog1(FL_DomHierWarn, L"Logging warning: NtpClient was unable to find a domain controller to use as a time source. NtpClient will try again in %s minutes.\n", rgwszStrings[0]);
            hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_NO_DC_LOCATED, 1, rgwszStrings);
            _IgnoreIfError(hr, "MyLogEvent");
            hr=HRESULT_FROM_WIN32(ERROR_DC_NOT_FOUND);
            _JumpError(hr, error, "(finding a time source when things should work)");
        }

	UNSYNCHRONIZE_PROVIDER(); 
    } // <- end if DC not found
    
    //get rid
    dwErr=I_NetlogonGetTrustRid(NULL, pdciChosen->DomainName, pdwTrustRid);
    if (ERROR_SUCCESS!=dwErr) {
        hr=HRESULT_FROM_WIN32(dwErr);
        _IgnoreError(hr, "I_NetlogonGetTrustRid");

        // log failures
        HRESULT hr2;
        WCHAR wszTime[15];
        const WCHAR * rgwszStrings[3]={pdciChosen->DomainName, NULL, wszTime};
        WCHAR * wszError=NULL;

        // get the friendly error message
        hr2=GetSystemErrorString(hr, &wszError);
        if (FAILED(hr2)) {
            _IgnoreError(hr2, "GetSystemErrorString");
        } else {
            // log the event
            rgwszStrings[1]=wszError;
            wsprintf(wszTime, L"%u", nRetryMinutes);
            FileLog3(FL_DomHierWarn, L"Logging warning: NtpClient failed to establish a trust relationship between this computer and the %s domain in order to securely synchronize time. NtpClient will try again in %s minutes. The error was: %s\n", rgwszStrings[0], rgwszStrings[2], rgwszStrings[1]);
            hr2=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_RID_LOOKUP_FAILED, 3, rgwszStrings);
            _IgnoreIfError(hr2, "MyLogEvent");
            LocalFree(wszError);
        }

        hr=HRESULT_FROM_WIN32(ERROR_DC_NOT_FOUND);
        _JumpError(hr, error, "I_NetlogonGetTrustRid (error translated)");
    }

    // We've gotten a DC -- if we fail after this point, we want to force rediscovery
    *peNextDiscoveryType = e_Force; 

    // Convert IP string to a number - this should always work
    _Verify(L'\\'==pdciChosen->DomainControllerAddress[0] && L'\\'==pdciChosen->DomainControllerAddress[1], hr, error);
    hr=MyGetIpAddrs(pdciChosen->DomainControllerAddress+2, &rgiaLocalIpAddrs, &rgiaRemoteIpAddrs, &nIpAddrs, NULL);
    _JumpIfError(hr, error, "MyGetIpAddrs");

    // copy the DC name
    _Verify(L'\\'==pdciChosen->DomainControllerName[0] && L'\\'==pdciChosen->DomainControllerName[1], hr, error);
    wszDcName=(WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(pdciChosen->DomainControllerName+2)+1));
    _JumpIfOutOfMemory(hr, error, wszDcName);
    wcscpy(wszDcName, pdciChosen->DomainControllerName+2);

    // copy the domain name
    wszDomainName=(WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(pdciChosen->DomainName)+1));
    _JumpIfOutOfMemory(hr, error, wszDomainName);
    wcscpy(wszDomainName, pdciChosen->DomainName);

    // completed successfully
    *prgiaLocalIpAddrs=rgiaLocalIpAddrs;
    rgiaLocalIpAddrs=NULL;
    *prgiaRemoteIpAddrs=rgiaRemoteIpAddrs;
    rgiaRemoteIpAddrs=NULL;
    *pnIpAddrs=nIpAddrs;
    *pwszDcName=wszDcName;
    wszDcName=NULL;
    *pwszDomainName=wszDomainName;
    wszDomainName=NULL;

    hr = S_OK;
 error:
    UNSYNCHRONIZE_PROVIDER(); 
    if (NULL!=pdci)              { NetApiBufferFree(pdci); }
    if (NULL!=pDomInfo)          { DsRoleFreeMemory(pDomInfo); }
    if (NULL!=pdciChosen)        { NetApiBufferFree(pdciChosen); }
    if (NULL!=rgiaLocalIpAddrs)  { LocalFree(rgiaLocalIpAddrs); }
    if (NULL!=rgiaRemoteIpAddrs) { LocalFree(rgiaRemoteIpAddrs); }
    if (NULL!=wszDcName)         { LocalFree(wszDcName); }
    if (NULL!=wszDomainName)     { LocalFree(wszDomainName); }
    if (NULL!=wszParentDomName)  { NetApiBufferFree(wszParentDomName); }
    if (NULL!=wszSiteName)       { NetApiBufferFree(wszSiteName); }
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT ResolveDomainHierarchyPeer(NtpPeerPtr pnpPending) {
    bool bEnteredCriticalSection  = false; 
    HRESULT hr;
    signed int nPollInterval;
    unsigned int nIpAddrs;
    unsigned int nIndex;
    unsigned int nPeersCreated;
    unsigned int nFirstPeerIndex;
    DWORD dwTrustRid;
    bool bRetryNeeded;
    DiscoveryType eNextDiscoveryType; 

    SYNCHRONIZE_PROVIDER();

    NtpPeerVec &vActive = g_pnpstate->vActivePeers;   // aliased for readability
    NtpPeerVec &vPending = g_pnpstate->vPendingPeers; // aliased for readability

    // must be cleaned up
    in_addr * rgiaLocalIpAddrs=NULL;
    in_addr * rgiaRemoteIpAddrs=NULL;
    WCHAR * wszDcName=NULL;
    WCHAR * wszDomainName=NULL;

    // error/situation handling:
    //----------------------------
    //                      retry   Force   Time
    //   no dc found         .       .       .
    // .  not found          Y       N       search-fail-time
    // .  root               N       .       .
    // .  nt4 domain         N       .       .
    // .  not in a domain    N       .       .
    // .  not secure         Y       N       search-fail-time
    // .  unexpected err     N       .       .
    // . sync fail           Y       Y       search-fail-time
    // . role change         Y       N       immediate
    //
    // we miss: site change, change to which domain is our parent, role/good/site of remote computer changes

    FileLog0(FL_DomHierAnnounce, L"Resolving domain hierarchy\n");

    // calculate this in case GetDomainHierarchyIpAddrs needs it when logging an error.
    unsigned int nRetryMinutes=g_pnpstate->dwResolvePeerBackoffMinutes;
    unsigned int nRetryCount=pnpPending->nResolveAttempts+1;
    if (nRetryCount>g_pnpstate->dwResolvePeerBackoffMaxTimes) {
        nRetryCount=g_pnpstate->dwResolvePeerBackoffMaxTimes;
    }
    for (nIndex=nRetryCount; nIndex>1; nIndex--) {
        nRetryMinutes*=2;
    }

    // find a DC
    UNSYNCHRONIZE_PROVIDER(); 
    hr=GetDomainHierarchyIpAddrs(pnpPending->eDiscoveryType, nRetryMinutes, &rgiaLocalIpAddrs, &rgiaRemoteIpAddrs, &nIpAddrs, &dwTrustRid, &bRetryNeeded, &wszDcName, &wszDomainName, &eNextDiscoveryType);
    _IgnoreIfError(hr, "GetDomainHierarchyIpAddrs");

    SYNCHRONIZE_PROVIDER(); 
    if (S_OK==hr) {

        // allocate an entry for each one.
        nFirstPeerIndex = vActive.size();
        hr=CreateNewActivePeers(rgiaLocalIpAddrs, rgiaRemoteIpAddrs, nIpAddrs, &nPeersCreated);
        _IgnoreIfError(hr, "CreateNewActivePeers");
        if (FAILED(hr)) {
            // log mysterious failure
            HRESULT hr2;
            const WCHAR * rgwszStrings[1];
            WCHAR * wszError=NULL;

            // get the friendly error message
            hr2=GetSystemErrorString(hr, &wszError);
            if (FAILED(hr2)) {
                _IgnoreError(hr2, "GetSystemErrorString");
            } else {
                // log the event
                rgwszStrings[0]=wszError;
                FileLog1(FL_DomHierWarn, L"Logging error: NtpClient was unable to find a domain controller to use as a time source because of an unexpected error. NtpClient will fall back to the remaining configured time sources, if any are available. The error was: %s\n", rgwszStrings[0]);
                hr2=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_NO_DC_LOCATED_UNEXPECTED_ERROR, 1, rgwszStrings);
                _IgnoreIfError(hr2, "MyLogEvent");
                LocalFree(wszError);
            }
            // Note: We will not retry after this. GetDomainHierarchyIpAddrs already set bRetryNeeded to false.
        }
    }

    // if either fails handle it here
    if (FAILED(hr)) {
        // Record our last error
        pnpPending->dwError       = hr; 
        pnpPending->dwErrorMsgId  = W32TIMEMSG_UNREACHABLE_PEER; 
      
        // ignore this, and try again later
        if (false==bRetryNeeded) {
            // this one gets the boot.
            FileLog0(FL_DomHierWarn, L"Dropping domain hierarchy because name resolution failed.\n");

	    // Check to make sure no other thread has already erased this peer
	    NtpPeerIter vEraseIter = find(vPending.begin(), vPending.end(), pnpPending); 
	    if (vPending.end() != vEraseIter) { 
		// the peer is still there, erase it... 
		vPending.erase(vEraseIter); 
	    } else { 
		// This really shouldn't happen, because you need to hold the peer critsec to delete this peer. 
		_MyAssert(FALSE); 
	    }
        } else {
            // we'll try later.
            FileLog2(FL_DomHierWarn, L"Retrying resolution for domain hierarchy. Retry %u will be in %u minutes.\n", nRetryCount, nRetryMinutes);
            pnpPending->tpTimeRemaining.qw=((unsigned __int64)g_pnpstate->dwResolvePeerBackoffMinutes)*600000000L; //minutes to hundred nanoseconds
            for (nIndex=nRetryCount; nIndex>1; nIndex--) {
                pnpPending->tpTimeRemaining*=2;
            }
            pnpPending->nResolveAttempts=nRetryCount;
            pnpPending->eDiscoveryType=eNextDiscoveryType; 
        }

    } else {

        // Fill in the details
        for (nIndex=0; nIndex<nPeersCreated; nIndex++) {
            NtpPeerPtr pnpNew = vActive[nFirstPeerIndex+nIndex];

            pnpNew->ePeerType=e_DomainHierarchyPeer;
            pnpNew->eAuthType=e_NtDigest;

            pnpNew->wszDomHierDcName=(WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(wszDcName)+1));
            _JumpIfOutOfMemory(hr, error, pnpNew->wszDomHierDcName);
            wcscpy(pnpNew->wszDomHierDcName, wszDcName);

            pnpNew->wszDomHierDomainName=(WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(wszDomainName)+1));
            _JumpIfOutOfMemory(hr, error, pnpNew->wszDomHierDomainName);
            wcscpy(pnpNew->wszDomHierDomainName, wszDomainName);

            pnpNew->dwRequestTrustRid=dwTrustRid;
            pnpNew->dwResponseTrustRid=0;

            if (true==g_pnpstate->bNtpServerStarted) {
                pnpNew->eMode=e_SymmetricActive;
            } else {
                pnpNew->eMode=e_Client;
            }
            pnpNew->nPeerPollInterval=0;

            ClearPeer(pnpNew);
            pnpNew->nrrReachability.nReg    = 1; // we do this so we have at least 8 attempts before we declare this peer unreachable.
            pnpNew->nResolveAttempts        = 0; // Reset the number of resolve attempts so we can recover more quickly from transient failures. 
            pnpNew->eLastLoggedReachability = e_NeverLogged;

	    // Can can trust the stratum returned from the domain hierarchy if we did a FORCE
	    pnpNew->eDiscoveryType           = pnpPending->eDiscoveryType; 
	    pnpNew->bStratumIsAuthoritative  = e_Force == pnpNew->eDiscoveryType; 

            // create the unique name: "<dc name> (ntp.d|aaa.bbb.ccc.ddd:ppppp->aaa.bbb.ccc.ddd:ppppp)"
            // make sure it fits in 256 char buffer
            WCHAR wszTail[60];
            swprintf(wszTail, L" (ntp.d|%u.%u.%u.%u:%u->%u.%u.%u.%u:%u)",
                pnpNew->pnsSocket->sai.sin_addr.S_un.S_un_b.s_b1,
                pnpNew->pnsSocket->sai.sin_addr.S_un.S_un_b.s_b2,
                pnpNew->pnsSocket->sai.sin_addr.S_un.S_un_b.s_b3,
                pnpNew->pnsSocket->sai.sin_addr.S_un.S_un_b.s_b4,
                EndianSwap((unsigned __int16)pnpNew->pnsSocket->sai.sin_port),
                pnpNew->saiRemoteAddr.sin_addr.S_un.S_un_b.s_b1,
                pnpNew->saiRemoteAddr.sin_addr.S_un.S_un_b.s_b2,
                pnpNew->saiRemoteAddr.sin_addr.S_un.S_un_b.s_b3,
                pnpNew->saiRemoteAddr.sin_addr.S_un.S_un_b.s_b4,
                EndianSwap((unsigned __int16)pnpNew->saiRemoteAddr.sin_port));
            unsigned int nPrefixSize=256-1-wcslen(wszTail);
            if (wcslen(pnpNew->wszDomHierDcName)<=nPrefixSize) {
                nPrefixSize=wcslen(pnpNew->wszDomHierDcName);
            }
            wcsncpy(pnpNew->wszUniqueName, pnpNew->wszDomHierDcName, nPrefixSize);
            wcscpy(pnpNew->wszUniqueName+nPrefixSize, wszTail);

        }

        // done with the pending peer
	// Check to make sure no other thread has already erased this peer
	NtpPeerIter vEraseIter = find(vPending.begin(), vPending.end(), pnpPending); 
	if (vPending.end() != vEraseIter) { 
	    // the peer is still there, erase it... 
	    vPending.erase(vEraseIter); 
	} else { 
	    // This really shouldn't happen, because you need to hold the peer critsec to delete this peer. 
	    _MyAssert(FALSE); 
	}
    }

    hr=S_OK;
error:
    UNSYNCHRONIZE_PROVIDER(); 

    if (NULL!=rgiaLocalIpAddrs) {
        LocalFree(rgiaLocalIpAddrs);
    }
    if (NULL!=rgiaRemoteIpAddrs) {
        LocalFree(rgiaRemoteIpAddrs);
    }
    if (NULL!=wszDcName) {
        LocalFree(wszDcName);
    }
    if (NULL!=wszDomainName) {
        LocalFree(wszDomainName);
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT ResolveManualPeer(NtpPeerPtr pnpPending) {
    HRESULT hr;
    signed int nPollInterval;
    unsigned int nIpAddrs;
    unsigned int nIndex;
    unsigned int nPeersCreated;
    unsigned int nFirstPeerIndex;
    WCHAR * wszFlags;
    bool bRetry;
    bool bEnteredCriticalSection = false; 

    SYNCHRONIZE_PROVIDER(); 

    NtpPeerVec  &vActive     = g_pnpstate->vActivePeers;         // aliased for readability
    NtpPeerVec  &vPending    = g_pnpstate->vPendingPeers;        // aliased for readability
    WCHAR       *wszName     = pnpPending->wszManualConfigID;

    // must be cleaned up
    in_addr * rgiaLocalIpAddrs=NULL;
    in_addr * rgiaRemoteIpAddrs=NULL;

    // Input validation:
    if (NULL == wszName) {
        FileLog0(FL_ManualPeerWarn,
                 L"Attempted to resolve a manual peer with a NULL wszManualConfigID.  This could "
                 L"indicate that the time service is in an inconsistent state.  The peer will be "
                 L"discarded, and the time service will attempt to proceed.\n");

	// Check to make sure no other thread has already erased this peer
	NtpPeerIter vEraseIter = find(vPending.begin(), vPending.end(), pnpPending); 
	if (vPending.end() != vEraseIter) { 
	    // the peer is still there, erase it... 
	    vPending.erase(vEraseIter); 
	} else { 
	    // This really shouldn't happen, because you need to hold the peer critsec to delete this peer. 
	    _MyAssert(FALSE); 
	}
        return S_OK;
    }

    FileLog1(FL_ManualPeerAnnounce, L"Resolving %s\n", wszName);

    // find the flags and hide them during the DNS lookup
    wszFlags = wcschr(wszName, L',');
    if (NULL!=wszFlags) {
        wszFlags[0]=L'\0';
    }

    // Do DNS lookup -- we can't hold the provider critsec while we're doing
    // this, as it may take a *LONG* time. 
    UNSYNCHRONIZE_PROVIDER(); 

    hr=MyGetIpAddrs(wszName, &rgiaLocalIpAddrs, &rgiaRemoteIpAddrs, &nIpAddrs, &bRetry);
    if (NULL!=wszFlags) {
        wszFlags[0]=L',';
    }
    _IgnoreIfError(hr, "MyGetIpAddrs");

    // Reacquire the provider critsec
    SYNCHRONIZE_PROVIDER(); 

    if (S_OK==hr) {
        // allocate an entry for each one.
        nFirstPeerIndex = vActive.size();
        hr=CreateNewActivePeers(rgiaLocalIpAddrs, rgiaRemoteIpAddrs, nIpAddrs, &nPeersCreated);
        _IgnoreIfError(hr, "CreateNewActivePeers");
        bRetry=false;
    }

    // if either fails handle it here
    if (FAILED(hr)) {

        if (true==bRetry) {
            // we'll try later.
            pnpPending->nResolveAttempts++;
            if (pnpPending->nResolveAttempts>g_pnpstate->dwResolvePeerBackoffMaxTimes) {
                pnpPending->nResolveAttempts=g_pnpstate->dwResolvePeerBackoffMaxTimes;
            }
            pnpPending->tpTimeRemaining.qw=((unsigned __int64)g_pnpstate->dwResolvePeerBackoffMinutes)*600000000L; //minutes to hundred nanoseconds
            for (nIndex=pnpPending->nResolveAttempts; nIndex>1; nIndex--) {
                pnpPending->tpTimeRemaining*=2;
            }
            FileLog2(FL_ManualPeerWarn, L"Retrying name resolution for %s in %u minutes.\n", wszName, (DWORD)(pnpPending->tpTimeRemaining.qw/600000000L));
        }

        // Record our last error
        pnpPending->dwError       = hr; 
        pnpPending->dwErrorMsgId  = W32TIMEMSG_UNREACHABLE_PEER; 

        // log this
        {
            HRESULT hr2;
            WCHAR wszRetry[15];
            const WCHAR * rgwszStrings[3]={wszName, NULL, wszRetry};
            WCHAR * wszError=NULL;

            // get the friendly error message
            hr2=GetSystemErrorString(hr, &wszError);
            if (FAILED(hr2)) {
                _IgnoreError(hr2, "GetSystemErrorString");
            } else {
                // log the event
                rgwszStrings[1]=wszError;
                if (false==bRetry) {
                    FileLog2(FL_ManualPeerWarn, L"Logging error: NtpClient: An unexpected error occurred during DNS lookup of the manually configured peer '%s'. This peer will not be used as a time source. The error was: %s\n", rgwszStrings[0], rgwszStrings[1]);
                    hr2=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_MANUAL_PEER_LOOKUP_FAILED_UNEXPECTED, 2, rgwszStrings);
                } else {
                    swprintf(wszRetry, L"%u", (DWORD)(pnpPending->tpTimeRemaining.qw/600000000L));
                    FileLog3(FL_ManualPeerWarn, L"Logging error: NtpClient: An error occurred during DNS lookup of the manually configured peer '%s'. NtpClient will try the DNS lookup again in %s minutes. The error was: %s\n", rgwszStrings[0], rgwszStrings[2], rgwszStrings[1]);
                    hr2=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_MANUAL_PEER_LOOKUP_FAILED_RETRYING, 3, rgwszStrings);
                }
                _IgnoreIfError(hr2, "MyLogEvent");
                LocalFree(wszError);
            }
        } // <- end logging block

        if (false==bRetry) {
            // this one gets the boot.
            FileLog1(FL_ManualPeerWarn, L"Dropping %s because name resolution failed.\n", wszName);

	    // Check to make sure no other thread has already erased this peer
	    NtpPeerIter vEraseIter = find(vPending.begin(), vPending.end(), pnpPending); 
	    if (vPending.end() != vEraseIter) { 
		// the peer is still there, erase it... 
		vPending.erase(vEraseIter); 
	    } else { 
		// This really shouldn't happen, because you need to hold the peer critsec to delete this peer. 
		_MyAssert(FALSE); 
	    }
        }
    } else {

        // Fill in the details
        for (nIndex=0; nIndex<nPeersCreated; nIndex++) {
            NtpPeerPtr pnpNew = vActive[nFirstPeerIndex+nIndex];

            pnpNew->ePeerType      = e_ManualPeer;
            pnpNew->eAuthType      = e_NoAuth;
            pnpNew->dwManualFlags  = pnpPending->dwManualFlags; 

            pnpNew->wszManualConfigID=(WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(pnpPending->wszManualConfigID)+1));
            _JumpIfOutOfMemory(hr, error, pnpNew->wszManualConfigID);
            wcscpy(pnpNew->wszManualConfigID, pnpPending->wszManualConfigID);

            if (0 == (NCMF_AssociationModeMask & pnpNew->dwManualFlags)) { 
                // No association mode was specified, dynamically determine one:
                if (true==g_pnpstate->bNtpServerStarted) {
                    pnpNew->eMode=e_SymmetricActive;
                } else {
                    pnpNew->eMode=e_Client;
                }
            } else { 
                // Use the association mode specified for this peer:
                if (0 != (NCMF_Client & pnpNew->dwManualFlags)) { 
                    pnpNew->eMode=e_Client; 
                } else if (0 != (NCMF_SymmetricActive & pnpNew->dwManualFlags)) { 
                    pnpNew->eMode=e_SymmetricActive; 
                } else { 
                    // This shouldn't be possible
                    _MyAssert(false); 
                    // If we somehow get here in a fre build, just assume client:
                    pnpNew->eMode=e_Client; 
                }
            }
                    
            pnpNew->nPeerPollInterval=0;
            ClearPeer(pnpNew);

            // Do this so the first send doesn't look like a failure  
            // NOTE:  we could just mark this manual peer as new (as was
            //        previously done).  This would always us to ignore the
            //        first false failure.  However, this makes it tough
            //        for callers querying the time service state to know
            //        whether this peer was successfully synchronized from. 
            //        Hence, we adopt the behavior of domain hierarchy peers, 
            //        and put a false success in the reachability register. 
            pnpNew->nrrReachability.nReg=1; 
            pnpNew->eLastLoggedReachability=e_NeverLogged;

            // create the unique name: "<dns> (ntp.m|0xABCDABCD|aaa.bbb.ccc.ddd:ppppp->aaa.bbb.ccc.ddd:ppppp)"
            // make sure it fits in 256 char buffer
            // note that adding multiple peers with the same name but different flags won't work, because
            // they will still have the same IP addresses
            if (NULL!=wszFlags) {
                wszFlags[0]=L'\0';
            }
            WCHAR wszTail[72];
            swprintf(wszTail, L" (ntp.m|0x%X|%u.%u.%u.%u:%u->%u.%u.%u.%u:%u)",
                pnpNew->dwManualFlags,
                pnpNew->pnsSocket->sai.sin_addr.S_un.S_un_b.s_b1,
                pnpNew->pnsSocket->sai.sin_addr.S_un.S_un_b.s_b2,
                pnpNew->pnsSocket->sai.sin_addr.S_un.S_un_b.s_b3,
                pnpNew->pnsSocket->sai.sin_addr.S_un.S_un_b.s_b4,
                EndianSwap((unsigned __int16)pnpNew->pnsSocket->sai.sin_port),
                pnpNew->saiRemoteAddr.sin_addr.S_un.S_un_b.s_b1,
                pnpNew->saiRemoteAddr.sin_addr.S_un.S_un_b.s_b2,
                pnpNew->saiRemoteAddr.sin_addr.S_un.S_un_b.s_b3,
                pnpNew->saiRemoteAddr.sin_addr.S_un.S_un_b.s_b4,
                EndianSwap((unsigned __int16)pnpNew->saiRemoteAddr.sin_port));
            unsigned int nPrefixSize=256-1-wcslen(wszTail);
            if (wcslen(wszName)<=nPrefixSize) {
                nPrefixSize=wcslen(wszName);
            }
            wcsncpy(pnpNew->wszUniqueName, wszName, nPrefixSize);
            wcscpy(pnpNew->wszUniqueName+nPrefixSize, wszTail);
            if (NULL!=wszFlags) {
                wszFlags[0]=L',';
            }
        }

        // done with the pending peer
	// Check to make sure no other thread has already erased this peer
	NtpPeerIter vEraseIter = find(vPending.begin(), vPending.end(), pnpPending); 
	if (vPending.end() != vEraseIter) { 
	    // the peer is still there, erase it... 
	    vPending.erase(vEraseIter); 
	} else { 
	    // This really shouldn't happen, because you need to hold the peer critsec to delete this peer. 
	    _MyAssert(FALSE); 
	}
    }

    hr=S_OK;
error:
    if (NULL!=rgiaLocalIpAddrs) {
        LocalFree(rgiaLocalIpAddrs);
    }
    if (NULL!=rgiaRemoteIpAddrs) {
        LocalFree(rgiaRemoteIpAddrs);
    }
    UNSYNCHRONIZE_PROVIDER(); 
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT ResolvePeer(NtpPeerPtr pnpPending) {
    bool         bEnteredCriticalSection  = false; 
    HRESULT      hr;  
    NtpPeerVec  &vPending                 = g_pnpstate->vPendingPeers; 

    if (e_ManualPeer == pnpPending->ePeerType) {
        hr=ResolveManualPeer(pnpPending);
        _JumpIfError(hr, error, "ResolveManualPeer");
    } else if (e_DomainHierarchyPeer == pnpPending->ePeerType) {
        hr=ResolveDomainHierarchyPeer(pnpPending);
    } else {
        _MyAssert(false);

        // BUGBUG: shouldn't modify list inside iterator!
	SYNCHRONIZE_PROVIDER(); 

	// Check to make sure no other thread has already erased this peer
	NtpPeerIter vEraseIter = find(vPending.begin(), vPending.end(), pnpPending); 
	if (vPending.end() != vEraseIter) { 
	    // the peer is still there, erase it... 
	    vPending.erase(vEraseIter); 
	} else { 
	    // This really shouldn't happen, because you need to hold the peer critsec to delete this peer. 
	    _MyAssert(FALSE); 
	}
    }

    hr=S_OK;
error:
    UNSYNCHRONIZE_PROVIDER(); 
    return hr;
}

//--------------------------------------------------------------------
//
// Handlers for the "peer polling thread".  Note that now the peer polling
// thread is conceptual only.  The handlers implement what used to be
// the peer polling thread more efficiently, through the user of the thread pool.
//

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT UpdatePeerPollingThreadTimerQueue1()
{
    bool               bEnteredCriticalSection      = false; 
    BOOL               bEnteredPeerCriticalSection  = FALSE; 
    bool               bInfiniteWait;
    CRITICAL_SECTION  *pcsPeer                      = NULL; 
    DWORD              dwWaitTime; 
    HRESULT            hr; 
    NtTimePeriod       tpWait;

    SYNCHRONIZE_PROVIDER(); 

    NtpPeerVec    &vActive   = g_pnpstate->vActivePeers;  // aliased for readability
    NtpPeerVec    &vPending  = g_pnpstate->vPendingPeers; // aliased for readability

    // determine how long to wait
    if ((vActive.empty() && vPending.empty())
        || g_pnpstate->nListenOnlySockets==g_pnpstate->nSockets) {
        bInfiniteWait=true;
    } else {
        bInfiniteWait = true;
        tpWait.qw = _UI64_MAX; 

        for (int vIndex = 0; vIndex < 2; vIndex++) {
            NtpPeerVec & v = 0 == vIndex ? vActive : vPending;
            for (NtpPeerIter pnpIter = v.begin(); pnpIter != v.end(); pnpIter++) {
		// Try to acquire this peers critsec.  This will succeed
		// unless the peer is being resolved, or polled. 
		pcsPeer = &((*pnpIter)->csPeer); 
		hr = myTryEnterCriticalSection(pcsPeer, &bEnteredPeerCriticalSection);
		_JumpIfError(hr, error, "myTryEnterCriticalSection"); 

		if (bEnteredPeerCriticalSection) { 
		    if ((*pnpIter)->tpTimeRemaining < tpWait) {
			tpWait = (*pnpIter)->tpTimeRemaining;
			bInfiniteWait = false; 
		    }

		    HRESULT hr2 = myLeaveCriticalSection(pcsPeer); 
		    _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
		    bEnteredPeerCriticalSection = FALSE; 
		} else { 
		    // This peer is either being resolved or polled -- 
		    // we don't want to include it in our calculation of 
		    // wait time. 
		}
            }
        }
    }

    if (bInfiniteWait) {
        FileLog0(FL_PeerPollThrdAnnounceLow, L"PeerPollingThread: waiting forever\n");
        dwWaitTime=INFINITE;
    } else {
        dwWaitTime=(DWORD)((tpWait.qw+9999)/10000);
        FileLog2(FL_PeerPollThrdAnnounceLow, L"PeerPollingThread: waiting %u.%03us\n", dwWaitTime/1000, dwWaitTime%1000);
    }

    // Update the timer queue with the new wait time: 
    // NOTE: we can't use 0xFFFFFFFF (-1) as the period, as RtlCreateTimer incorrectly maps this to 0. 
    hr = myChangeTimerQueueTimer(NULL, g_pnpstate->hPeerPollingThreadTimer, dwWaitTime, 0xFFFFFFFE /*shouldn't be used*/);
    _JumpIfError(hr, error, "myChangeTimerQueueTimer"); 

    hr = S_OK; 
 error:
    UNSYNCHRONIZE_PROVIDER(); 
    if (bEnteredPeerCriticalSection) { 
	HRESULT hr2 = myLeaveCriticalSection(pcsPeer); 
	_IgnoreIfError(hr2, "myLeaveCriticalSection"); 
    }
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT UpdatePeerPollingThreadTimerQueue2()
{
    bool               bEnteredCriticalSection      = false; 
    BOOL               bEnteredPeerCriticalSection  = FALSE;
    HRESULT            hr; 
    NtTimePeriod       tpWait;
    unsigned int       nIndex;
    CRITICAL_SECTION  *pcsPeer                      = NULL; 
    NtpPeerVec         vActiveLocal; 
    NtpPeerVec         vPendingLocal; 

    SYNCHRONIZE_PROVIDER();

    NtpPeerVec    &vActive   = g_pnpstate->vActivePeers;  // aliased for readability
    NtpPeerVec    &vPending  = g_pnpstate->vPendingPeers; // aliased for readability

    // Make copies of global data.  
    // NOTE: local vectors vActiveLocal and vPendingLocal still point to global 
    //       data.  Modifications of this data must still be protected, but 
    //       the vectors themselves can be modified without protection. 
    bool bResolvePeer; 

    for (NtpPeerIter pnpIter = vActive.begin(); pnpIter != vActive.end(); pnpIter++) { 
	_SafeStlCall(vActiveLocal.push_back(*pnpIter), hr, error, "push_back");
    }

    // if we don't have net access, don't bother trying to resolve a peer
    bResolvePeer = g_pnpstate->nListenOnlySockets != g_pnpstate->nSockets; 
    
    UNSYNCHRONIZE_PROVIDER(); 
    
    // poll any active peers
    for (NtpPeerIter pnpIter = vActiveLocal.begin(); pnpIter != vActiveLocal.end(); pnpIter++) {
	pcsPeer = &((*pnpIter)->csPeer); 
	hr = myTryEnterCriticalSection(pcsPeer, &bEnteredPeerCriticalSection); 
	_JumpIfError(hr, error, "myTryEnterCriticalSection"); 

	// If we couldn't acquire the peer critsec, another thread is already polling or resolving this peer -- just continue on. 
        if (bEnteredPeerCriticalSection && gc_tpZero == (*pnpIter)->tpTimeRemaining) {
	    // The local active peer list we have may be out of sync with 
	    // the actual list.  Ensure that we still have an active peer
	    SYNCHRONIZE_PROVIDER(); 
	    
	    if (vActive.end() == find(vActive.begin(), vActive.end(), (*pnpIter))) { 
		// Our active list is stale, this peer has been removed -- don't
		// poll it. 
		UNSYNCHRONIZE_PROVIDER(); 
	    } else { 
		UNSYNCHRONIZE_PROVIDER(); 

		bool bRemovePeer;
		hr=PollPeer(*pnpIter, &bRemovePeer);
		_JumpIfError(hr, error, "PollPeer");
		
		// demobilize association if necessary
		if (bRemovePeer) {
		    // We're going to demote this peer
		    SYNCHRONIZE_PROVIDER(); 

		    if (e_DomainHierarchyPeer == (*pnpIter)->ePeerType) {
			// This this our last domain hierarchy peer?
			if ((1 == count_if(vActive.begin(), vActive.end(), IsPeerType(e_DomainHierarchyPeer))) &&
			    (0 == count_if(vPending.begin(), vPending.end(), IsPeerType(e_DomainHierarchyPeer)))) {
			    // we'll try again a while later
			    hr = AddNewPendingDomHierPeer();
			    _JumpIfError(hr, error, "AddNewPendingDomHierPeer");
			    NtpPeerPtr pnpNew = vPending[vPending.size() - 1];
			    NtpPeerPtr pnpOld = *pnpIter;
			    
			    // Force rediscovery
			    pnpNew->eDiscoveryType = e_Force; 

			    pnpNew->nResolveAttempts = pnpOld->nResolveAttempts+1;
			    if (pnpNew->nResolveAttempts>g_pnpstate->dwResolvePeerBackoffMaxTimes) {
				pnpNew->nResolveAttempts=g_pnpstate->dwResolvePeerBackoffMaxTimes;
			    }
			    pnpNew->tpTimeRemaining.qw=((unsigned __int64)g_pnpstate->dwResolvePeerBackoffMinutes)*600000000L; //minutes to hundred nanoseconds
			    for (int nCount=pnpNew->nResolveAttempts; nCount>1; nCount--) {
				pnpNew->tpTimeRemaining*=2;
			    }
			    DWORD dwRetryMinutes=(DWORD)(pnpNew->tpTimeRemaining.qw/600000000L);
			    FileLog2(FL_DomHierWarn, L"*** Last DomHier Peer timed out - Rediscovery %u will be in %u minutes.\n", pnpNew->nResolveAttempts, dwRetryMinutes);

			    { // log the warning
				HRESULT hr2;
				WCHAR wszNumberBuf[15];
				const WCHAR * rgwszStrings[1]={
				    (*pnpIter)->wszDomHierDcName
				};
				swprintf(wszNumberBuf, L"%u", dwRetryMinutes);
				FileLog1(FL_DomHierWarn, L"Logging warning: NtpClient: No response has been received from domain controller %s after 8 attempts to contact it. This domain controller will be discarded as a time source and NtpClient will attempt to discover a new domain controller from which to synchronize.\n", rgwszStrings[0]);
				hr2=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_DOMHIER_PEER_TIMEOUT, 1, rgwszStrings);
				_IgnoreIfError(hr2, "MyLogEvent");
			    } // <- end logging block

			} else {
			    FileLog0(FL_DomHierAnnounce, L"*** DomHier Peer timed out - other paths remain.\n");
			}
			
			{ 
			    // Delete this peer from the global active peer list
			    NtpPeerIter pnpIterGlobal = find(vActive.begin(), vActive.end(), *pnpIter); 
			    if (vActive.end() != pnpIterGlobal) { 
				vActive.erase(pnpIterGlobal);
			    } else { 
				// The peer has been deleted behind our backs...
				_MyAssert(false); 
			    }
			}

		    } else {
			// TODO: handle Dynamic peers
			_MyAssert(false);
		    }

		    UNSYNCHRONIZE_PROVIDER(); 
		} // <- end if peer need to be removed
	    } // <- end if peer still in active list
	} // <- end if peer ready

	if (bEnteredPeerCriticalSection) { 
	    hr = myLeaveCriticalSection(pcsPeer); 
	    bEnteredPeerCriticalSection = false; 
	}
    } // <- end active peer loop

    if (!bResolvePeer) {
	// We're not resolving any peers (we don't have network access), so we're done!
        goto done; 
    }

    SYNCHRONIZE_PROVIDER(); 

    // Make a local copy of the pending peer list: 
    for (NtpPeerIter pnpIter = vPending.begin(); pnpIter != vPending.end(); pnpIter++) { 
	_SafeStlCall(vPendingLocal.push_back(*pnpIter), hr, error, "push_back");
    }

    // attempt to resolve ONE pending peer
    nIndex = 0;
    for (NtpPeerIter pnpIter = vPendingLocal.begin(); pnpIter != vPendingLocal.end(); pnpIter++, nIndex++) {
	pcsPeer = &((*pnpIter)->csPeer); 
	hr = myTryEnterCriticalSection(pcsPeer, &bEnteredPeerCriticalSection); 
	_JumpIfError(hr, error, "myTryEnterCriticalSection"); 

        if (bEnteredPeerCriticalSection && gc_tpZero == (*pnpIter)->tpTimeRemaining) {
	    // Release the provider critsec before we attempt to resolve this peer
	    UNSYNCHRONIZE_PROVIDER(); 
	    
	    // We're about to resolve the peer.  If anyone queries us in this time, we'll want to report 
	    // ERROR_TIMEOUT as our error.  
	    (*pnpIter)->dwError = ERROR_TIMEOUT; 
	    (*pnpIter)->dwErrorMsgId = 0; 

            // resolve this peer. This could take a while.
            hr=ResolvePeer(*pnpIter);
            _JumpIfError(hr, error, "ResolvePeer");

	    // We've successfully resolved the peer.  
	    // NOTE: resolution clears the dwError and dwErrorMsgId fields

	    // We've finished resolving the peer, we can reacquire our provider critsec
	    SYNCHRONIZE_PROVIDER(); 

            // make sure we maintain at least one peer to sync from
            g_pnpstate->bWarnIfNoActivePeers=true;

            // update remaining time
            UpdatePeerListTimes();

            // go handle some more events.
            break;
        }

	if (bEnteredPeerCriticalSection) { 
	    hr = myLeaveCriticalSection(pcsPeer); 
	    bEnteredPeerCriticalSection = false; 
	}
    }

    // verify there is at least one active peer, or log a warning
    if (true==g_pnpstate->bWarnIfNoActivePeers && vActive.empty()) {
        // no active peers. Are there any pending peers?
        if (!vPending.empty()) {
            // find out how long until the next pending peer is resolved
            tpWait = vPending[0]->tpTimeRemaining;
            for (NtpPeerIter pnpIter = vPending.begin()+1; pnpIter != vPending.end(); pnpIter++) {
                if ((*pnpIter)->tpTimeRemaining < tpWait) {
                    tpWait = (*pnpIter)->tpTimeRemaining;
                }
            }
        }
        // if there is a pending peer that will be looked up immediately,
        // fine, no error. Otherwise, log an error.
        if (vPending.empty() || gc_tpZero!=tpWait) {

            if (!vPending.empty()) {
                // log the error
                HRESULT hr2;
                WCHAR wszMinutes[100];
                const WCHAR * rgwszStrings[1]={
                    wszMinutes
                };
                tpWait.qw/=600000000;
                if (0==tpWait.qw) {
                    tpWait.qw=1;
                }
                swprintf(wszMinutes, L"%I64u", tpWait.qw);
                FileLog1(FL_PeerPollThrdWarn, L"Logging error: NtpClient has been configured to acquire time from one or more time sources, however none of the sources are currently accessible and no attempt to contact a source will be made for %s minutes. NTPCLIENT HAS NO SOURCE OF ACCURATE TIME.\n", rgwszStrings[0]);
                hr2=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_NO_NTP_PEERS_BUT_PENDING, 1, rgwszStrings);
                _IgnoreIfError(hr2, "MyLogEvent");
            } else {
                // log the error
                HRESULT hr2;
                FileLog0(FL_PeerPollThrdWarn, L"Logging error: NtpClient has been configured to acquire time from one or more time sources, however none of the sources are accessible. NTPCLIENT HAS NO SOURCE OF ACCURATE TIME.\n");
                hr2=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_NO_NTP_PEERS, 0, NULL);
                _IgnoreIfError(hr2, "MyLogEvent");
            }

            // disable warning until we do something that could bring about
            // a new active peer (ie, resolveing a pending peer)
            g_pnpstate->bWarnIfNoActivePeers=false;

        } // <- end if warning needed
    } // <- end if no active peers

 done:
    hr = S_OK; 
 error:
    if (bEnteredPeerCriticalSection) { 
	HRESULT hr2 = myLeaveCriticalSection(pcsPeer); 
	_IgnoreIfError(hr2, "myLeaveCriticalSection"); 
    }
    UNSYNCHRONIZE_PROVIDER(); 
    return hr; 
}

MODULEPRIVATE void HandlePeerPollingThreadPeerListUpdated(LPVOID pvIgnored, BOOLEAN bIgnored)
{
    bool     bEnteredCriticalSection  = false; 
    HRESULT  hr; 

    FileLog0(FL_PeerPollThrdAnnounce, L"PeerPollingThread: PeerListUpdated\n");

    // first, update the time remaining for each peer
    UpdatePeerListTimes();

    hr = UpdatePeerPollingThreadTimerQueue2(); 
    _IgnoreIfError(hr, "UpdatePeerPollingThreadTimerQueue2"); 

    hr = UpdatePeerPollingThreadTimerQueue1(); 
    _IgnoreIfError(hr, "UpdatePeerPollingThreadTimerQueue1"); 

    // hr = S_OK; 
    // error:
    // return hr; 
}

MODULEPRIVATE void HandlePeerPollingThreadStopEvent(LPVOID pvIgnored, BOOLEAN bIgnored) 
{
    // Nothing to do, just log the stop event
    FileLog0(FL_PeerPollThrdAnnounce, L"PeerPollingThread: StopEvent\n");
}

MODULEPRIVATE void HandlePeerPollingThreadTimeout(LPVOID pvIgnored, BOOLEAN bIgnored)
{
    bool     bEnteredCriticalSection = false; 
    HRESULT  hr; 
    
    FileLog0(FL_PeerPollThrdAnnounceLow, L"PeerPollingThread: WaitTimeout\n");

    // first, update the time remaining for each peer
    UpdatePeerListTimes();

    hr = UpdatePeerPollingThreadTimerQueue2(); 
    _IgnoreIfError(hr, "UpdatePeerPollingThreadTimerQueue2"); 

    hr = UpdatePeerPollingThreadTimerQueue1(); 
    _IgnoreIfError(hr, "UpdatePeerPollingThreadTimerQueue1"); 

    // hr = S_OK; 
    // error:
    // return hr; 
}

MODULEPRIVATE DWORD WINAPI HandlePeerPollingThreadDomHierRoleChangeEventWorker(LPVOID pvIgnored)
{
    bool         bEnteredCriticalSection  = false; 
    HRESULT      hr; 
    NtpPeerVec  &vActive                  = g_pnpstate->vActivePeers;  // aliased for readability
    NtpPeerVec  &vPending                 = g_pnpstate->vPendingPeers; // aliased for readability

    FileLog0(FL_PeerPollThrdAnnounceLow, L"PeerPollingThread: DomHier Role Change\n");

    // must be cleaned up
    bool bTrappedThreads=false;

    // gain excusive access
    hr=TrapThreads(true);
    _JumpIfError(hr, error, "TrapThreads");
    bTrappedThreads=true;
            
    // first, update the time remaining for each peer
    UpdatePeerListTimes(); 

    // a little safety checking
    _MyAssert(0!=(g_pnpstate->dwSyncFromFlags&NCSF_DomainHierarchy));
    // If there was a role change for this machine, we redetect where we are in the hierarchy.
    // We do this by purging the existing DomHier peers and starting with a new one in the pending state.
    if (0!=(g_pnpstate->dwSyncFromFlags&NCSF_DomainHierarchy)) {
        // remove domain hierarchy peers all from the list
        vActive.erase(remove_if(vActive.begin(), vActive.end(), IsPeerType(e_DomainHierarchyPeer)), vActive.end());
        vPending.erase(remove_if(vPending.begin(), vPending.end(), IsPeerType(e_DomainHierarchyPeer)), vPending.end());
        FileLog0(FL_DomHierAnnounce, L"  DomainHierarchy: LSA role change notification. Redetecting.\n");

        hr=AddNewPendingDomHierPeer();
        _JumpIfError(hr, error, "AddNewPendingDomHierPeer");
    }

    hr = S_OK; 
 error:
    if (true==bTrappedThreads) {
        // release excusive access
        HRESULT hr2=TrapThreads(false);
        _IgnoreIfError(hr2, "TrapThreads");
    }
    return hr; 
}

MODULEPRIVATE void HandlePeerPollingThreadDomHierRoleChangeEvent(LPVOID pvIgnored, BOOLEAN bIgnored)
{
    if (!QueueUserWorkItem(HandlePeerPollingThreadDomHierRoleChangeEventWorker, NULL, 0)) { 
	_IgnoreLastError("QueueUserWorkItem"); 
    }
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StartPeerPollingThread() {
    HRESULT  hr;

    if (NULL != g_pnpstate->hRegisteredStopEvent              ||
        NULL != g_pnpstate->hRegisteredPeerListUpdated        ||
        NULL != g_pnpstate->hRegisteredDomHierRoleChangeEvent) { 
        hr = HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED); 
        _JumpError(hr, error, "StartPeerPollingThread");
    }

    // Set up our timeout mechanism:
    hr = myStartTimerQueueTimer
        (g_pnpstate->hPeerPollingThreadTimer, 
         NULL /*default queue*/, 
         HandlePeerPollingThreadTimeout, 
         NULL, 
         0xFFFFFFFE /*dummy value */,
         0xFFFFFFFE /*dummy value NOTE: we can't use 0xFFFFFFFF (-1) as the period, as RtlCreateTimer incorrectly maps this to 0. */,
         0 /*default execution*/
         ); 
    _JumpIfError(hr, error, "myStartTimerQueueTimer"); 

    // Update the time remaining for each peer. 
    UpdatePeerListTimes(); 

    // Update the timer queue to use the most current peer times
    hr = UpdatePeerPollingThreadTimerQueue1(); 
    _JumpIfError(hr, error, "UpdatePeerPollingThreadTimerQueue1"); 

    // Register the callbacks that implement the peer polling thread: 
    struct EventsToRegister { 
        DWORD                 dwFlags; 
        HANDLE                hObject; 
        HANDLE               *phNewWaitObject; 
        WAITORTIMERCALLBACK   Callback;
    } rgEventsToRegister[] =  { 
        { 
            WT_EXECUTEONLYONCE, 
            g_pnpstate->hStopEvent,
            &g_pnpstate->hRegisteredStopEvent, 
            HandlePeerPollingThreadStopEvent
        }, { 
	    WT_EXECUTEDEFAULT, 
            g_pnpstate->hPeerListUpdated,
            &g_pnpstate->hRegisteredPeerListUpdated, 
            HandlePeerPollingThreadPeerListUpdated
        }, { 
            WT_EXECUTEDEFAULT, 
            g_pnpstate->hDomHierRoleChangeEvent,
            &g_pnpstate->hRegisteredDomHierRoleChangeEvent, 
            HandlePeerPollingThreadDomHierRoleChangeEvent
        }
    }; 

    for (int nIndex = 0; nIndex < ARRAYSIZE(rgEventsToRegister); nIndex++) { 
        if (!RegisterWaitForSingleObject
            (rgEventsToRegister[nIndex].phNewWaitObject,  // BUGBUG:  does this need to be freed?
             rgEventsToRegister[nIndex].hObject, 
             rgEventsToRegister[nIndex].Callback, 
             NULL, 
             INFINITE, 
             rgEventsToRegister[nIndex].dwFlags)) {
            _JumpLastError(hr, error, "RegisterWaitForSingleObject"); 
        }
    }
    
    hr = S_OK; 
 error:
    return hr;     
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StopPeerPollingThread()
{
    HRESULT  hr   = S_OK; 
    HRESULT  hr2; 
    
    // de-register all peer-polling events in the thread pool: 
    HANDLE *rgphRegistered[] = { 
        &g_pnpstate->hRegisteredStopEvent, 
        &g_pnpstate->hRegisteredPeerListUpdated, 
        &g_pnpstate->hRegisteredDomHierRoleChangeEvent
    }; 

    for (int nIndex = 0; nIndex < ARRAYSIZE(rgphRegistered); nIndex++) { 
        if (NULL != *rgphRegistered[nIndex]) { 
            if (!UnregisterWaitEx(*rgphRegistered[nIndex] /*event to de-register*/, INVALID_HANDLE_VALUE /*wait forever*/)) { 
                HRESULT hr2 = HRESULT_FROM_WIN32(GetLastError()); 
                _TeardownError(hr, hr2, "UnregisterWaitEx"); 
            } 
            // BUGBUG: should we try again on failure?
            *rgphRegistered[nIndex] = NULL;  
        }
    } 

    // Halt the timeout mechanism.  
    hr2 = myStopTimerQueueTimer(NULL /*default queue*/, g_pnpstate->hPeerPollingThreadTimer, INVALID_HANDLE_VALUE /*blocking*/);
    _TeardownError(hr, hr2, "myStopTimerQueueTimer"); 

    return hr; 
}

//
// END peer polling thread's implementation. 
//
//--------------------------------------------------------------------


//--------------------------------------------------------------------
MODULEPRIVATE void ParsePacket1(NtpSimplePeer * pnspPeer, NtpPacket * pnpReceived, NtTimeEpoch * pteDestinationTimestamp, signed __int64 * pnSysPhaseOffset, unsigned __int64 * pnSysTickCount) {

    // at this point, pnpReceived could be pure garbage. We need to make sure it is not
    pnspPeer->bGarbagePacket=true;
    pnspPeer->bValidData=false;
    pnspPeer->bValidHeader=false;

    // Version check and fixup:
    if (pnpReceived->nVersionNumber<1) {
        // Version 0 packets are completely incompatible
        FileLog0(FL_PacketCheck, L"Rejecting packet w/ bad version\n");
        return;
    } else if (pnpReceived->nVersionNumber>4) {
        // Version for is the latest defined so far.
        // Better safe than sorry. This may need to be changed later.
        FileLog0(FL_PacketCheck, L"Rejecting packet w/ bad version\n");
        return;
    }
    // version number is 1, 2, 3, or 4
    pnspPeer->nVersionNumber=pnpReceived->nVersionNumber;

    // Mode check and fixup
    if (e_Reserved==pnpReceived->nMode
        || e_Control==pnpReceived->nMode
        || e_PrivateUse==pnpReceived->nMode
        || e_Broadcast==pnpReceived->nMode) {
        // ignore these modes
        // note that we could do a fixup on mode 0
        FileLog0(FL_PacketCheck, L"Rejecting packet w/ bad mode\n");
        return;
    }
    // valid modes are e_SymmetricActive, e_SymmetricPassive,
    //   e_Client, e_Server, and e_Broadcast
    pnspPeer->eMode=static_cast<NtpMode>(pnpReceived->nMode);

    // all leap indicator values are valid: e_NoWarning, e_AddSecond,
    //   e_SubtractSecond, and e_ClockNotSynchronized
    pnspPeer->eLeapIndicator=static_cast<NtpLeapIndicator>(pnpReceived->nLeapIndicator);

    // all stratum valies are valid: 0 - 255
    pnspPeer->nStratum=pnpReceived->nStratum;

    if ((pnpReceived->nPollInterval<4 || pnpReceived->nPollInterval>17) && 0!=pnpReceived->nPollInterval) {
        // Poll interval is outside the range allowed in any spec: 4(16s)-17(131072s), 0-unspecified
        FileLog0(FL_PacketCheck, L"Rejecting packet w/ bad poll interval\n");
        return;
    }
    pnspPeer->nPollInterval=pnpReceived->nPollInterval;

    if ((pnpReceived->nPrecision<-30 || pnpReceived->nPrecision>-3) && 0!=pnpReceived->nPrecision) {
        // Precision is outside reasonable range: -3(8Hz/125ms) to -30(1GHz/1ns), 0-unspecified
        FileLog0(FL_PacketCheck, L"Rejecting packet w/ bad precision\n");
        return;
    }
    pnspPeer->nPrecision=pnpReceived->nPrecision;

    // Remaining parameters cannot be validated
    pnspPeer->refid.value=pnpReceived->refid.value;
    pnspPeer->toRootDelay=NtTimeOffsetFromNtpTimeOffset(pnpReceived->toRootDelay);
    pnspPeer->tpRootDispersion=NtTimePeriodFromNtpTimePeriod(pnpReceived->tpRootDispersion);
    pnspPeer->teReferenceTimestamp=NtTimeEpochFromNtpTimeEpoch(pnpReceived->teReferenceTimestamp);
    pnspPeer->teOriginateTimestamp=NtTimeEpochFromNtpTimeEpoch(pnpReceived->teOriginateTimestamp);
    pnspPeer->teExactOriginateTimestamp=pnpReceived->teOriginateTimestamp;
    pnspPeer->teReceiveTimestamp=NtTimeEpochFromNtpTimeEpoch(pnpReceived->teReceiveTimestamp);
    pnspPeer->teTransmitTimestamp=NtTimeEpochFromNtpTimeEpoch(pnpReceived->teTransmitTimestamp);
    pnspPeer->teExactTransmitTimestamp=pnpReceived->teTransmitTimestamp;
    pnspPeer->teDestinationTimestamp=*pteDestinationTimestamp;
    pnspPeer->nSysPhaseOffset=*pnSysPhaseOffset;
    pnspPeer->nSysTickCount=*pnSysTickCount;

    if (e_Broadcast==pnspPeer->eMode) {
        // fudge missing timestamps -- assume no time delays
        pnspPeer->teOriginateTimestamp=*pteDestinationTimestamp;
        pnspPeer->teExactOriginateTimestamp=NtpTimeEpochFromNtTimeEpoch(pnspPeer->teOriginateTimestamp);
        pnspPeer->teReceiveTimestamp=pnspPeer->teTransmitTimestamp;
    }

    pnspPeer->bGarbagePacket=false;
}

//--------------------------------------------------------------------
MODULEPRIVATE void ParsePacket2(NtpPeerPtr pnpPeer, NtpSimplePeer * pnspPeer, NtpPacket * pnpReceived) {
    DWORD dwCompatibilityFlags;

    // if we know this peer, use its flags. Otherwise, use the globals
    if (NULL==pnpPeer) {
        dwCompatibilityFlags=g_pnpstate->dwClientCompatibilityFlags;
    } else {
        dwCompatibilityFlags=pnpPeer->dwCompatibilityFlags;
    }

    // compatibility check
    // Win2K time server echoes the value for root dispersion so
    // this value is totally bogus. If we tell the server we are
    // hosed (disp=16s), then we will think the server is hosed too!

    if (NULL!=pnpPeer) {
        // first, check for autodetect
        // Stage 2 - check for our special pattern. If we find it, this is a win2k source.
        if (0!=(dwCompatibilityFlags&NCCF_AutodetectWin2KStage2)) {
            if (AUTODETECTWIN2KPATTERN==pnpReceived->tpRootDispersion.dw) {
                FileLog1(FL_Win2KDetectAnnounceLow, L"Peer %s is Win2K. Setting compat flags.\n", pnpPeer->wszUniqueName);
                pnpPeer->dwCompatibilityFlags&=~(NCCF_AutodetectWin2K|NCCF_AutodetectWin2KStage2);
                pnpPeer->dwCompatibilityFlags|=NCCF_DispersionInvalid|NCCF_IgnoreFutureRefTimeStamp;
            } else {
                FileLog1(FL_Win2KDetectAnnounceLow, L"Peer %s is not Win2K. Setting compat flags.\n", pnpPeer->wszUniqueName);
                pnpPeer->dwCompatibilityFlags&=~(NCCF_AutodetectWin2K|NCCF_AutodetectWin2KStage2);
            }
            dwCompatibilityFlags=pnpPeer->dwCompatibilityFlags;
        }
        // Stage 1 - see if the dispersion is the same as what we sent. If is it, this might be a win2k source
        if (0!=(dwCompatibilityFlags&NCCF_AutodetectWin2K)) {
            if (pnpPeer->dwCompatLastDispersion==pnpReceived->tpRootDispersion.dw) {
                FileLog1(FL_Win2KDetectAnnounceLow, L"Peer %s may be Win2K. Will verify on next packet.\n", pnpPeer->wszUniqueName);
                pnpPeer->dwCompatibilityFlags|=NCCF_AutodetectWin2KStage2;
                // Don't want to wait another polling interval to finish our compatibility check.  
                pnpPeer->tpTimeRemaining.qw = 0; 
                if (!SetEvent(g_pnpstate->hPeerListUpdated)) { 
                    // Not much we can about this.  Besides, we'll eventually poll this peer again anyway. 
                    _IgnoreLastError("SetEvent"); 
                }
            } else {
                FileLog1(FL_Win2KDetectAnnounceLow, L"Peer %s is not Win2K. Setting compat flags.\n", pnpPeer->wszUniqueName);
                pnpPeer->dwCompatibilityFlags&=~(NCCF_AutodetectWin2K|NCCF_AutodetectWin2KStage2);
            }
            dwCompatibilityFlags=pnpPeer->dwCompatibilityFlags;
        }
    } // <- end Win2K checks if this is a known peer

    // if we don't think we can trust this value, just set them to zero.
    if (dwCompatibilityFlags&NCCF_DispersionInvalid) {
        pnspPeer->tpRootDispersion=gc_tpZero;
    }

    // grab the system parameters that we'll need
    NtTimePeriod tpSysClockTickSize;
    BYTE nSysLeapFlags;
    BYTE nSysStratum;
    DWORD dwSysRefId;
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_ClockTickSize, &tpSysClockTickSize.qw);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_LeapFlags, &nSysLeapFlags);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_Stratum, &nSysStratum);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_ReferenceIdentifier, &dwSysRefId);

    //                /   Receive <-- Originate
    // old peer state:|           |
    //                \  Transmit --> (dest)
    //                / Originate   | Receive
    // recv'd packet: |             |
    //                \    (dest) <-- Transmit
    //                /   Receive |   Originate
    // new peer state |           |
    //                \  Transmit --> (dest)

    // calculate derived data
    pnspPeer->toRoundtripDelay=
        (pnspPeer->teDestinationTimestamp-pnspPeer->teOriginateTimestamp)
          - (pnspPeer->teTransmitTimestamp-pnspPeer->teReceiveTimestamp);
    pnspPeer->toLocalClockOffset=
        (pnspPeer->teReceiveTimestamp-pnspPeer->teOriginateTimestamp)
        + (pnspPeer->teTransmitTimestamp-pnspPeer->teDestinationTimestamp);
    pnspPeer->toLocalClockOffset/=2;
    // Dispersion of the host relative to the peer: the maximum error due to
    //   measurement error at the host and local-clock skew accumulation over
    //   the interval since the last message was transmitted to the peer.
    pnspPeer->tpDispersion=tpSysClockTickSize+NtpConst::timesMaxSkewRate(abs(pnspPeer->teDestinationTimestamp-pnspPeer->teOriginateTimestamp));

    bool bTest1;
    bool bTest2;
    bool bTest3;
    bool bTest4;
    bool bTest5;
    bool bTest6;
    bool bTest7;
    bool bTest8;

    if (e_Broadcast!=pnspPeer->eMode) {
        // * Test 1 requires the transmit timestamp not match the last one
        //     received from the same peer; otherwise, the message might
        //     be an old duplicate.
        bTest1=pnspPeer->teExactTransmitTimestamp!=pnpPeer->teExactOriginateTimestamp;
        if (!bTest1 && FileLogAllowEntry(FL_PacketCheck2)) {
            FileLogAdd(L"Packet test 1 failed (we've seen this response).\n");
        }


        // * Test 2 requires the originate timestamp match the last one
        //     sent to the same peer; otherwise, the message might be out
        //     of order, bogus or worse.
        bTest2=pnspPeer->teExactOriginateTimestamp==pnpPeer->teExactTransmitTimestamp;
        if (!bTest2 && FileLogAllowEntry(FL_PacketCheck2)) {
            FileLogAdd(L"Packet test 2 failed (response does not match request).\n");
        }

    } else {
        // these tests don't work on broadcast packets, so assume they passed.
        bTest1=true;
        bTest2=true;
    }

    // * Test 3 requires that both the originate and receive timestamps are
    //     nonzero. If either of the timestamps are zero, the association has
    //     not synchronized or has lost reachability in one or both directions.
    //     (if they are zero, this is a request, not a response)
    bTest3=(gc_teZero!=pnpReceived->teOriginateTimestamp && gc_teZero!=pnpReceived->teReceiveTimestamp);
    if (!bTest3 && FileLogAllowEntry(FL_PacketCheck2)) {
        FileLogAdd(L"Packet test 3 failed (looks like a request).\n");
    }

    // * Test 4 requires that the calculated delay be within
    //     "reasonable" bounds
    bTest4=(abs(pnspPeer->toRoundtripDelay)<NtpConst::tpMaxDispersion && pnspPeer->tpDispersion<NtpConst::tpMaxDispersion);
    if (!bTest4 && FileLogAllowEntry(FL_PacketCheck2)) {
        FileLogAdd(L"Packet test 4 failed (bad value for delay or dispersion).\n");
    }

    // * Test 5 requires either that authentication be explicitly
    //     disabled or that the authenticator be present and correct
    //     as determined by the decrypt procedure.
    bTest5=true; // We do this elsewhere

    // * Test 6 requires the peer clock be synchronized and the
    //     interval since the peer clock was last updated be positive
    //     and less than NTP.MAXAGE.
    bTest6=(e_ClockNotSynchronized!=pnspPeer->eLeapIndicator
            && (0!=(dwCompatibilityFlags&NCCF_IgnoreFutureRefTimeStamp)
                || pnspPeer->teReferenceTimestamp<=pnspPeer->teTransmitTimestamp)
            && (pnspPeer->teTransmitTimestamp<pnspPeer->teReferenceTimestamp+NtpConst::tpMaxClockAge
                || gc_teNtpZero==pnspPeer->teReferenceTimestamp)); // SPEC ERROR:
    if (!bTest6 && FileLogAllowEntry(FL_PacketCheck2)) {
        FileLogAdd(L"Packet test 6 failed (not syncd or bad interval since last sync).\n");
    }
    
    // * Test 7 insures that the host will not synchronize on a peer
    //     with greater stratum.  The one exception is for peers that 
    //     we trust enough that we'll use them regardless of stratum 
    //     (for example, domhier peers discovered using the FORCE flag). 

    if (pnpPeer->bStratumIsAuthoritative) { 
	// The "authoritative stratum" shouldn't be used more than once.  
	pnpPeer->bStratumIsAuthoritative = false; 

	bool bValidStratum=true; 
	NtpPeerVec &vActive = g_pnpstate->vActivePeers; 
	for (NtpPeerIter pnpIter = vActive.begin(); pnpIter != vActive.end(); pnpIter++) { 
	    if (e_DomainHierarchyPeer != (*pnpIter)->ePeerType) { 
		if ((*pnpIter)->nStratum < pnspPeer->nStratum) { 
		    // We've already got a manual peer a better stratum than the domain hierarchy peer.  
		    bValidStratum = false; 
		    break; 
		}
	    }
	}

	if (bValidStratum) { 
	    // Attempt to update the provider stratum -- allow 1 second for the call to complete.  We can't
	    // block forever because we'd deadlock, but 1 second should be more than enough.  If the call 
	    // fails, we'll just have to wait for the next time we poll this peer. 
	    HRESULT hr = SetProviderStatus(L"NtpClient", pnspPeer->nStratum+1, TPS_Running, false /*synchronous*/, 1000 /*1s timeout*/); 
	    _IgnoreIfError(hr, "SetProviderStatus"); 
	} 	    
    }
    
    bTest7=((pnspPeer->nStratum<=nSysStratum || e_ClockNotSynchronized==nSysLeapFlags || 
	     NtpConst::dwLocalRefId==dwSysRefId || 0==dwSysRefId) // SPEC ERROR: initial sys stratum is 0
	    && pnspPeer->nStratum<NtpConst::nMaxStratum
	    && 0!=pnspPeer->nStratum); // my own test: SPEC ERROR
    if (!bTest7 && FileLogAllowEntry(FL_PacketCheck2)) {
        FileLogAdd(L"Packet test 7 failed (bad stratum).\n");
    }

    // * Test 8 requires that the header contains "reasonable" values
    //     for the pkt.root-delay and pkt.rootdispersion fields.
    bTest8=(abs(pnspPeer->toRootDelay)<NtpConst::tpMaxDispersion && pnspPeer->tpRootDispersion<NtpConst::tpMaxDispersion);
    if (!bTest8 && FileLogAllowEntry(FL_PacketCheck2)) {
        FileLogAdd(L"Packet test 8 failed (bad value for root delay or root dispersion).\n");
    }

    // Packets with valid data can be used to calculate offset, delay
    //   and dispersion values.
    pnspPeer->bValidData=(bTest1 && bTest2 && bTest3 && bTest4);

    // Packets with valid headers can be used to determine whether a
    //   peer can be selected for synchronization.
    pnspPeer->bValidHeader=(bTest5 && bTest6 && bTest7 && bTest8);

    // Remember which tests passed.  This is used for error-reporting only. 
    { 
        bool rgbTests[] = { bTest1, bTest2, bTest3, bTest4, bTest5, bTest6, bTest7, bTest8 }; 
        _MyAssert(ARRAYSIZE(rgbTests) == ARRAYSIZE(pnspPeer->rgbTestsPassed)); 

        for (DWORD dwIndex=0; dwIndex < ARRAYSIZE(pnspPeer->rgbTestsPassed); dwIndex++) { 
            pnspPeer->rgbTestsPassed[dwIndex] = rgbTests[dwIndex]; 
        }
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE void TransmitResponse(NtpSimplePeer * pnspPeer, sockaddr_in * psaiPeerAddress, NicSocket * pnsHostSocket) {
    bool bSkipSend=false;
    AuthenticatedNtpPacket anpOut;
    NtpPacket & npOut=*(NtpPacket *)&anpOut;

    // grab the system parameters that we'll need
    NtTimeOffset toSysRootDelay;
    NtTimePeriod tpSysRootDispersion;
    NtTimePeriod tpSysClockTickSize;
    NtTimeEpoch teSysReferenceTimestamp;
    NtTimeEpoch teSysTime;
    BYTE nSysLeapFlags;
    BYTE nSysStratum;
    signed __int32 nSysPrecision;
    DWORD dwSysRefid;
    signed __int32 nSysPollInterval;
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_RootDelay, &toSysRootDelay.qw);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_RootDispersion, &tpSysRootDispersion.qw);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_ClockTickSize, &tpSysClockTickSize.qw);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_LastSyncTime, &teSysReferenceTimestamp.qw);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teSysTime.qw);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_LeapFlags, &nSysLeapFlags);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_Stratum, &nSysStratum);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_ClockPrecision, &nSysPrecision);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_ReferenceIdentifier, &dwSysRefid);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_PollInterval, &nSysPollInterval);

    // fill out the packet
    npOut.nLeapIndicator=nSysLeapFlags;
    npOut.nVersionNumber=NtpConst::nVersionNumber;
    npOut.nMode=pnspPeer->eOutMode;
    npOut.nStratum=nSysStratum;
    npOut.nPollInterval=(signed __int8)nSysPollInterval;
    npOut.nPrecision=(signed __int8)nSysPrecision;
    npOut.toRootDelay=NtpTimeOffsetFromNtTimeOffset(toSysRootDelay);

    // calculate the dispersion
    NtTimePeriod tpSkew;
    NtTimePeriod tpTimeSinceLastSysClockUpdate=abs(teSysTime-teSysReferenceTimestamp);
    if (e_ClockNotSynchronized==nSysLeapFlags
        || tpTimeSinceLastSysClockUpdate>NtpConst::tpMaxClockAge) {
        tpSkew=NtpConst::tpMaxSkew;
    } else {
        tpSkew=NtpConst::timesMaxSkewRate(tpTimeSinceLastSysClockUpdate);
    }
    NtTimePeriod tpRootDispersion=tpSysRootDispersion+tpSysClockTickSize+tpSkew;
    if (tpRootDispersion>NtpConst::tpMaxDispersion) {
        tpRootDispersion=NtpConst::tpMaxDispersion;
    }
    npOut.tpRootDispersion=NtpTimePeriodFromNtTimePeriod(tpRootDispersion);

    // fill out the packet
    npOut.refid.value=dwSysRefid;
    npOut.teReferenceTimestamp=NtpTimeEpochFromNtTimeEpoch(teSysReferenceTimestamp);
    npOut.teOriginateTimestamp=pnspPeer->teExactTransmitTimestamp;
    npOut.teReceiveTimestamp=NtpTimeEpochFromNtTimeEpoch(pnspPeer->teDestinationTimestamp);

    // time sensitive
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teSysTime.qw);
    npOut.teTransmitTimestamp=NtpTimeEpochFromNtTimeEpoch(teSysTime);

    // send packet
    if (e_NoAuth==pnspPeer->eAuthType) {
        // send unauthenticated packet
        int nBytesSent;
        nBytesSent=sendto(pnsHostSocket->socket, (char *)&npOut, SizeOfNtpPacket,
            0 /*flags*/, (sockaddr *)psaiPeerAddress, sizeof(*psaiPeerAddress));
        if (SOCKET_ERROR==nBytesSent) {
            _IgnoreLastError("sendto");
        } else if (nBytesSent<SizeOfNtpPacket) {
            FileLog0(FL_TransResponseWarn, L"TransmitResponse: Fewer bytes sent than requested. Ignoring error.\n");
        }

    } else if (e_NtDigest==pnspPeer->eAuthType) {
        // send authenticated packet
        anpOut.nKeyIdentifier=0,
        ZeroMemory(anpOut.rgnMessageDigest, sizeof(anpOut.rgnMessageDigest));
        if (0!=pnspPeer->dwResponseTrustRid) {
	    bool bUseOldServerDigest; 
            CHAR OldMessageDigest[16];
	    CHAR NewMessageDigest[16]; 

            // we are a DC responding to a request that needs an authenticated response

	    // Determine whether the client desires the old or the current server digest.  This is stored in the high bit of the trust rid:
	    bUseOldServerDigest = 0 != (TRUST_RID_OLD_DIGEST_BIT & pnspPeer->dwResponseTrustRid); 
	    // Mask off the digest bit of the rid, or we won't be able to look up the appropriate account for this rid: 
	    pnspPeer->dwResponseTrustRid &= ~TRUST_RID_OLD_DIGEST_BIT; 

	    FileLog2(FL_TransResponseAnnounce, L"Computing server digest: OLD:%s, RID:%08X\n", (bUseOldServerDigest ? L"TRUE" : L"FALSE"), pnspPeer->dwResponseTrustRid); 
	    // Sign the packet: 
            DWORD dwErr=I_NetlogonComputeServerDigest(NULL, pnspPeer->dwResponseTrustRid, (BYTE *)&npOut, SizeOfNtpPacket, NewMessageDigest, OldMessageDigest);
            if (ERROR_SUCCESS!=dwErr) {
                HRESULT hr=HRESULT_FROM_WIN32(dwErr);
                _IgnoreError(hr, "I_NetlogonComputeServerDigest");

                { // log the warning
                    HRESULT hr2;
                    const WCHAR * rgwszStrings[2];
                    WCHAR * wszError=NULL;
                    WCHAR wszIP[16];
                    DWORD dwBufSize=ARRAYSIZE(wszIP);

                    // get the friendly error message
                    hr2=GetSystemErrorString(hr, &wszError);
                    if (FAILED(hr2)) {
                        _IgnoreError(hr2, "GetSystemErrorString");
                    } else if (SOCKET_ERROR==WSAAddressToString((sockaddr *)&pnsHostSocket->sai, sizeof(pnsHostSocket->sai), NULL/*protocol_info*/, wszIP, &dwBufSize)) {
                        _IgnoreLastError("WSAAddressToString");
                        LocalFree(wszError);
                    } else {
                        // log the event
                        rgwszStrings[0]=wszIP;
                        rgwszStrings[1]=wszError;
                        FileLog2(FL_TransResponseWarn, L"Logging warning: NtpServer encountered an error while validating the computer account for client %s. NtpServer cannot provide secure (signed) time to the client and will ignore the request. The error was: %s\n", rgwszStrings[0], rgwszStrings[1]);
                        hr2=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_CLIENT_COMPUTE_SERVER_DIGEST_FAILED, 2, rgwszStrings);
                        _IgnoreIfError(hr2, "MyLogEvent");
                        LocalFree(wszError);
                    }
                } // <- end logging block
            } // <- end if signing failed

	    // Fill in the digest fields in the packet with the digest requested by the client: 
	    if (bUseOldServerDigest) { 
		memcpy(anpOut.rgnMessageDigest, OldMessageDigest, sizeof(OldMessageDigest)); 
	    } else { 
		memcpy(anpOut.rgnMessageDigest, NewMessageDigest, sizeof(NewMessageDigest)); 
	    }
        } else {
            FileLog0(FL_TransResponseWarn,
                     L"Warning: this request expects an authenticated response, but did not provide "
                     L"the client ID.  Sounds like we're responding to a server response, which is "
                     L"incorrect behavior.  However, this can also be caused by other applications "
                     L"broadcasting NTP packets, using an unrecognized authentication mechanism.");

            bSkipSend = true;
        }

        // send the signed packet
        if (false==bSkipSend) {
            int nBytesSent;
            nBytesSent=sendto(pnsHostSocket->socket, (char *)&anpOut, SizeOfNtAuthenticatedNtpPacket,
                0 /*flags*/, (sockaddr *)psaiPeerAddress, sizeof(*psaiPeerAddress));
            if (SOCKET_ERROR==nBytesSent) {
                _IgnoreLastError("sendto");
            } else if (nBytesSent<SizeOfNtAuthenticatedNtpPacket) {
                FileLog0(FL_TransResponseWarn, L"TransmitResponse: Fewer bytes sent than requested. Ignoring error.\n");
            }
        }

    } else {
        _MyAssert(false); // unknown auth type
    }

    if (!bSkipSend && FileLogAllowEntry(FL_TransResponseAnnounce)) {
        FileLogAdd(L"TransmitResponse: sent ");
        FileLogSockaddrInEx(true /*append*/, &pnsHostSocket->sai);
        FileLogAppend(L"->");
        FileLogSockaddrInEx(true /*append*/, psaiPeerAddress);
        FileLogAppend(L"\n");
    }

}


DWORD const gc_rgdwPacketTestErrorMsgIds[] = { 
    W32TIMEMSG_ERROR_PACKETTEST1, 
    W32TIMEMSG_ERROR_PACKETTEST2,
    W32TIMEMSG_ERROR_PACKETTEST3,
    W32TIMEMSG_ERROR_PACKETTEST4,
    W32TIMEMSG_ERROR_PACKETTEST5,
    W32TIMEMSG_ERROR_PACKETTEST6,
    W32TIMEMSG_ERROR_PACKETTEST7,
    W32TIMEMSG_ERROR_PACKETTEST8
}; 

//--------------------------------------------------------------------
MODULEPRIVATE void ProcessPeerUpdate(NtpPeerPtr pnp, NtpSimplePeer * pnspNewData) {

    // get the test results
    bool bValidData=pnspNewData->bValidData;
    bool bValidHeader=pnspNewData->bValidHeader;

    // If we followed the NTP spec, we would update the ReceiveTimestamp and
    // OriginateTimestamp, and polling interval for every packet, no matter how
    // many tests it failed. We would mark the peer as reachable it bValidHeader
    // was true, and we would only add a sample to the clock filter if bValidData
    // was true. RobertG and LouisTh discussed this and decided that for our
    // purposes, if any of the tests fail, we should ignore the packet. While in our
    // implementation some peers may be marked as unreachable that the NTP spec
    // might think are reachable, this is not a big problem because manual peers
    // don't worry about reachability and if our domhier peer that can't sychronize
    // us, we should rediscover anyway. We also thought it also seemed like a poor
    // idea to use any fields from a replay attack or a packet with a bad signature.

    if (false==bValidData || false==bValidHeader) {
        FileLog1(FL_PacketCheck, L"Ignoring packet that failed tests from %s.\n", pnp->wszUniqueName);
        // Remember the error associated with this peer
        pnp->dwError = E_FAIL;
        // Make sure we've kept our error message table in sync with the table of possible packet test failures!
        _MyAssert(ARRAYSIZE(pnspNewData->rgbTestsPassed) == ARRAYSIZE(gc_rgdwPacketTestErrorMsgIds)); 
        for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(pnspNewData->rgbTestsPassed); dwIndex++) { 
            if (!pnspNewData->rgbTestsPassed[dwIndex]) { 
                // Lookup the error message
                pnp->dwErrorMsgId = gc_rgdwPacketTestErrorMsgIds[dwIndex]; 
            }
        }
        return;
    } else { 
        // Update our status reporting fields to indicate no errors. 
        pnp->dwError       = S_OK; 
        pnp->dwErrorMsgId  = 0; 
    }

    // update timestamps
    pnp->teReceiveTimestamp=pnspNewData->teDestinationTimestamp;
    pnp->teExactOriginateTimestamp=pnspNewData->teExactTransmitTimestamp;
    pnp->teLastSuccessfulSync=pnspNewData->teDestinationTimestamp;

    // save the peer's poll interval
    pnp->nPeerPollInterval=pnspNewData->nPollInterval;

    // reschedule the next poll to this peer
    UpdatePeerPollingInfo(pnp, e_Normal /*just received*/);

    // mark that this peer was reachable
    pnp->nrrReachability.nReg|=1;

    // Once we've gotten at least one good sample from this peer, we want
    // our next time service discovery to be done as a background caller
    pnp->eDiscoveryType = e_Background; 

    // add it to our clock filter.
    AddSampleToPeerClockFilter(pnp, pnspNewData);

    // log an event if the reachability changed
    if (e_Reachable!=pnp->eLastLoggedReachability
        && 0!=(NCELF_LogReachabilityChanges&g_pnpstate->dwEventLogFlags)) {

        WCHAR * rgwszStrings[1]={pnp->wszUniqueName};
        FileLog1(FL_ReachabilityAnnounceLow, L"Logging information: NtpClient is currently receiving valid time data from %s.\n", rgwszStrings[0]);
        HRESULT hr=MyLogEvent(EVENTLOG_INFORMATION_TYPE, MSG_TIME_SOURCE_REACHABLE, 1, (const WCHAR **)rgwszStrings);
        _IgnoreIfError(hr, "MyLogEvent");
        pnp->eLastLoggedReachability=e_Reachable;
    }

	
}

//--------------------------------------------------------------------
    // In SymAct - preconfigured, peer sending server-to-server
    // In SymPas - dynamic, peer responding to server-to-server
    // In Client - preconfigured, peer sending client-to-server
    // In Server - dynamic, peer responding to client-to-server

    // Out SymAct - preconfigured, host sending server-to-server
    // Out SymPas - dynamic, host responding to server-to-server
    // Out Client - preconfigured, host sending client-to-server
    // Out Server - dynamic, host responding to client-to-server

enum Action {
    e_Error=0,      // error - ignore
    e_Save=1,       // save time data
    e_Send=2,       // send response immediately
    e_SaveSend=3,   // save or send depending upon packet quality
    e_Nstd=4,       // Nonstandard, but workable
    e_SaveNstd=5,   // save time data
    e_SendNstd=6,   // send response immediately
};

MODULEPRIVATE const Action gc_rgrgeAction[5/*InMode*/][5/*OutMode*/]=
// OutMode  Rsv      SymAct      SymPas      Client      Server
/*InMode*/{
/* Rsv  */ {e_Error, e_Error,    e_Error,    e_Error,    e_Error    },
/*SymAct*/ {e_Error, e_Save,     e_SaveSend, e_SaveNstd, e_SendNstd },
/*SymPas*/ {e_Error, e_Save,     e_Error,    e_SaveNstd, e_Error    },
/*Client*/ {e_Error, e_SendNstd, e_SendNstd, e_Error,    e_Send     },
/*Server*/ {e_Error, e_SaveNstd, e_Error,    e_Save,     e_Error    }
          };

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT HandleIncomingPacket(AuthenticatedNtpPacket * panpPacket, bool bContainsAuthInfo, unsigned int nHostSocket, sockaddr_in * psaiPeer, NtTimeEpoch * pteDestinationTimestamp, signed __int64 * pnSysPhaseOffset, unsigned __int64 * pnSysTickCount) {
    Action          eAction;
    bool            bAllowDynamicPeers  = (true==g_pnpstate->bNtpClientStarted && (g_pnpstate->dwSyncFromFlags&NCSF_DynamicPeers));
    HRESULT         hr;
    NtpMode         eInMode;
    NtpMode         eOutMode;
    NtpPacket      *pnpPacket           = (NtpPacket *)(panpPacket);
    NtpPeerPtr      pnpPeer(NULL);
    NtpPeerVec     &vActive             = g_pnpstate->vActivePeers;
    NtpPeerVec     &vPending            = g_pnpstate->vPendingPeers;
    NtpSimplePeer   nsp;
    unsigned int    nIndex;

    // must be cleaned up
    bool bEnteredCritSec=false;


    // decode the packet and do the first set of checks on it
    ParsePacket1(&nsp, pnpPacket, pteDestinationTimestamp, pnSysPhaseOffset, pnSysTickCount);
    if (true==nsp.bGarbagePacket) {
        FileLog0(FL_PacketCheck, L"Ignoring garbage packet.\n");
        goto done;
    }

    // we only remember peers if we are a client.
    // Also, client mode requests are never associated with a remembered peer.
    if (true==g_pnpstate->bNtpClientStarted && pnpPacket->nMode!=e_Client) {

        // see if we know this peer
        hr=myEnterCriticalSection(&g_pnpstate->csPeerList);
        _JumpIfError(hr, error, "myEnterCriticalSection");
        bEnteredCritSec=true;
        for (NtpPeerIter pnpIter = vActive.begin(); pnpIter != vActive.end(); pnpIter++) {
            if ((*pnpIter)->pnsSocket == g_pnpstate->rgpnsSockets[nHostSocket]
                && (*pnpIter)->saiRemoteAddr.sin_family==psaiPeer->sin_family
                && (*pnpIter)->saiRemoteAddr.sin_port==psaiPeer->sin_port
                && (*pnpIter)->saiRemoteAddr.sin_addr.S_un.S_addr==psaiPeer->sin_addr.S_un.S_addr) {

                pnpPeer = *pnpIter;
                break;
            }
        }
        // nope, we don't know this peer.
        // release the heap.
        if (NULL == pnpPeer) {
            bEnteredCritSec=false;
            hr=myLeaveCriticalSection(&g_pnpstate->csPeerList);
            _JumpIfError(hr, error, "myLeaveCriticalSection");
        }
    }

    // check the authentication
    if (bContainsAuthInfo) {
        if (NULL != pnpPeer) {
            nsp.eAuthType=pnpPeer->eAuthType;
            if (e_NtDigest==nsp.eAuthType) {
                unsigned __int8 rgnMessageDigestNew[16];  // Hash computed with current machine password
                unsigned __int8 rgnMessageDigestOld[16];  // Hash computed with previous machine password

                //DWORD dwErr=I_NetlogonComputeServerDigest(NULL, pnpPeer->dwRequestTrustRid, (BYTE *)pnpPacket, SizeOfNtpPacket, (char *)rgnMessageDigest);
                DWORD dwErr=I_NetlogonComputeClientDigest(NULL, pnpPeer->wszDomHierDomainName, (BYTE *)pnpPacket, SizeOfNtpPacket, (char *)rgnMessageDigestNew, (char *)rgnMessageDigestOld);
                if (ERROR_SUCCESS!=dwErr) {
                    hr=HRESULT_FROM_WIN32(dwErr);
                    _IgnoreError(hr, "I_NetlogonComputeClientDigest");
                    { // log the warning
                        HRESULT hr2;
                        const WCHAR * rgwszStrings[2]={
                            pnpPeer->wszDomHierDcName,
                            NULL
                        };
                        WCHAR * wszError=NULL;

                        // get the friendly error message
                        hr2=GetSystemErrorString(hr, &wszError);
                        if (FAILED(hr2)) {
                            _IgnoreError(hr2, "GetSystemErrorString");
                        } else {
                            // log the event
                            rgwszStrings[1]=wszError;
                            FileLog2(FL_PacketAuthCheck, L"Logging warning: NtpClient encountered an error while validating the computer account for this machine, so NtpClient cannot determine whether the response received from %s has a valid signature. The response will be ignored. The error was: %s\n", rgwszStrings[0], rgwszStrings[1]);
                            hr2=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_COMPUTE_CLIENT_DIGEST_FAILED, 2, rgwszStrings);
                            _IgnoreIfError(hr2, "MyLogEvent");
                            LocalFree(wszError);
                        }
                    } // <- end logging block
                    FileLog0(FL_PacketAuthCheck, L"Can't verify packet because compute digest failed. Ignoring packet.\n");
                    goto done;

                    // When the machine password for a member server changes, the change is communicated
                    // to some DC.  However, until replication of the change occurs, other DCs will continue 
                    // to use the old password to sign their NTP packets.  This causes bogus trust failures
                    // because the client uses its new machine password to communicate with a DC to which the 
                    // password change has not yet been replicated.  To remedy this, I_NetlogonComputeClientDigest 
                    // actually returns two digests -- one computed with the current password, and one computed with
                    // the previous password. 
                    //
                    // We will trust messages with a digest that matches either of these computed digests: 
                    // 
                } else if ((0 != memcmp(rgnMessageDigestNew, panpPacket->rgnMessageDigest, sizeof(rgnMessageDigestNew))) &&
                           (0 != memcmp(rgnMessageDigestOld, panpPacket->rgnMessageDigest, sizeof(rgnMessageDigestOld)))) {
		    if (pnpPeer->bLastAuthCheckFailed) { 
			// log the warning
                        HRESULT hr2;
                        const WCHAR * rgwszStrings[1]={
                            pnpPeer->wszDomHierDcName
                        };
                        FileLog1(FL_PacketAuthCheck, L"Logging warning: NtpClient: The response received from domain controller %s has an bad signature. The response may have been tampered with and will be ignored.\n", rgwszStrings[0]);
                        hr2=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_BAD_SIGNATURE, 1, rgwszStrings);
                        _IgnoreIfError(hr2, "MyLogEvent");

			FileLog0(FL_PacketAuthCheck, L"Digest shows packet tampered with. Ignoring packet.\n");

			// Our best bet is to request the new server digest, as it should eventually be correct:
			pnpPeer->bUseOldServerDigest = false; 
                    } else { 
			pnpPeer->bLastAuthCheckFailed = true; 
			pnpPeer->bUseOldServerDigest = !pnpPeer->bUseOldServerDigest; 
		    }
                    goto done;
                } else { 
		    // Authentication successful
		    pnpPeer->bLastAuthCheckFailed = false; 
		}
            } else if (e_NoAuth==nsp.eAuthType) {
                FileLog0(FL_PacketAuthCheck, L"non-auth peer set authenticated packet!\n");
                _MyAssert(false); // this is a weird case and if it should ever happen, stop and find out why
                goto done;
            } else {
                _MyAssert(false); // unknown auth type
            }
        } else {
            // unauthenticated request, desires authenticated response
            nsp.eAuthType=e_NtDigest;
            nsp.dwResponseTrustRid=panpPacket->nKeyIdentifier;
        }

    } else {
        nsp.eAuthType=e_NoAuth;
        if (NULL!=pnpPeer && e_NoAuth!=pnpPeer->eAuthType) {
            // This packet is bogus.
            if (e_NtDigest==pnpPeer->eAuthType) {
                { // log the warning
                    HRESULT hr2;
                    const WCHAR * rgwszStrings[1]={
                        pnpPeer->wszDomHierDcName
                    };
                    FileLog1(FL_PacketAuthCheck, L"Logging warning: NtpClient: The response received from domain controller %s is missing the signature. The response may have been tampered with and will be ignored.\n", rgwszStrings[0]);
                    hr2=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_MISSING_SIGNATURE, 1, rgwszStrings);
                    _IgnoreIfError(hr2, "MyLogEvent");
                } // <- end logging block
            } else {
                _MyAssert(false); // unknown auth type
            }
            FileLog0(FL_PacketAuthCheck, L"Unauthenticated packet recieved from authenticated peer.\n");
            goto done;
        }
    }

    // determine our relationship to the peer (the 'in' mode and the 'out' mode)
    eInMode=nsp.eMode;              // SymAct, SymPas, Client, or Server
    if (NULL!=pnpPeer) {
        eOutMode=pnpPeer->eMode;    // SymAct, SymPas, or Client
    } else {
        if (true!=g_pnpstate->bNtpServerStarted) {
            eOutMode=e_Reserved;        // guaranteed discard packet
        } else if (e_Client!=eInMode    // SymAct, SymPas, or Server
            && bAllowDynamicPeers) {
            eOutMode=e_SymmetricPassive;
        } else {
            eOutMode=e_Server;          // Client
        }
    }
    nsp.eOutMode=eOutMode;
    eAction=gc_rgrgeAction[eInMode][eOutMode];

    // if the mode combination is just terrible, ignore the packet
    if (e_Error==eAction) {
        FileLog2(FL_PacketCheck, L"Ignoring packet invalid mode combination (in:%d out:%d).\n", eInMode, eOutMode);
        goto done;
    }
    // filter out nonstandard modes: either bail or remove the flag
    if (e_SaveNstd==eAction) {
        if (true==g_pnpstate->bAllowClientNonstandardModeCominations) {
            eAction=e_Save;
        } else {
            FileLog0(FL_PacketCheck, L"Ignoring packet in nonstandard mode.\n");
            goto done;
        }
    }
    if (e_SendNstd==eAction) {
        if (true==g_pnpstate->bAllowServerNonstandardModeCominations) {
            eAction=e_Send;
        } else {
            FileLog0(FL_PacketCheck, L"Ignoring packet in nonstandard mode.\n");
            goto done;
        }
    }

    // handle weird case where we are SymPas to a SymAct peer
    if (e_SaveSend==eAction) {
        if (true==nsp.bValidHeader && bAllowDynamicPeers) {
            // The peer is worth synchronizing from - we will establish a long-term association
            eAction=e_Save;
        } else {
            // the peer has a worse stratum or is otherwise poor - don't establish a long-term association
            eAction=e_Send;
        }
    }

    // Two main choices:
    if (e_Send==eAction) {
        // Reply immediately
        if (false==g_pnpstate->bNtpServerStarted) {
            FileLog0(FL_PacketCheck, L"Ignoring packet because server not running.\n");
            goto done;
        }
        // send a quick response
        TransmitResponse(&nsp, psaiPeer, g_pnpstate->rgpnsSockets[nHostSocket]);
        if (NULL!=pnpPeer) {
            // we have a long-term association, so demobilize it
            // TODO: handle Dynamic peers
            FileLog0(FL_PacketCheck, L"ListeningThread -- demobilize long term peer (NYI).\n");
            _MyAssert(false);
        }

    } else { // e_Save==eAction
        // save the synchronization data and reply after a while.
        if (NULL==pnpPeer) {
            if (false==bAllowDynamicPeers) {
                FileLog0(FL_PacketCheck, L"Ignoring packet that would create dynamic peer\n");
                goto done;
            }
            // TODO: handle Dynamic peers
            FileLog0(FL_PacketCheck, L"ListeningThread -- save response from new long term peer (NYI)\n");
            _MyAssert(false);
        } else {

            // finish decoding and checking the packet
            ParsePacket2(pnpPeer, &nsp, pnpPacket);

            // save response from long term peer
            ProcessPeerUpdate(pnpPeer, &nsp);
        }
    }

    // all done
done:
    hr=S_OK;
error:
    if (true==bEnteredCritSec) {
        HRESULT hr2;
        hr2=myLeaveCriticalSection(&g_pnpstate->csPeerList);
        _TeardownError(hr, hr2, "myLeaveCriticalSection");
    }
    return hr;
}

//--------------------------------------------------------------------
//
// Handlers for the "listening thread".  Note that now the listening
// thread is conceptual only.  The handlers implement what used to be
// the listening thread more efficiently, through the user of the thread pool.
//

//--------------------------------------------------------------------
MODULEPRIVATE void HandleListeningThreadStopEvent(LPVOID pvIgnored, BOOLEAN bIgnored)
{
    // Nothing to do, just log the stop event
    FileLog0(FL_ListeningThrdAnnounce, L"ListeningThread: StopEvent\n");
}

//--------------------------------------------------------------------
MODULEPRIVATE void HandleListeningThreadDataAvail(LPVOID pvSocketIndex, BOOLEAN bIgnored) 
{
    AuthenticatedNtpPacket  anpPacket;
    bool                    bContainsAuthInfo;
    HRESULT                 hr;
    int                     nBytesRecvd;
    int                     nPeerAddrSize           = sizeof(sockaddr);
    INT_PTR                 ipSocketIndex           = (INT_PTR)pvSocketIndex; 
    NtTimeEpoch             teDestinationTimestamp;
    signed __int64          nSysPhaseOffset;        // opaque, must be GetTimeSysInfo(TSI_PhaseOffset)
    sockaddr                saPeer;
    unsigned int            nSocket                 = (unsigned int)(ipSocketIndex & 0xFFFFFFFF); 
    unsigned __int64        nSysTickCount;          // opaque, must be GetTimeSysInfo(TSI_TickCount)

    if (FileLogAllowEntry(FL_ListeningThrdAnnounceLow)) {
        FileLogAdd(L"ListeningThread -- DataAvailEvent set for socket %u (", nSocket);
        FileLogSockaddrInEx(true /*append*/, &g_pnpstate->rgpnsSockets[nSocket]->sai);
        FileLogAppend(L")\n");
    }

    ZeroMemory(&saPeer, sizeof(saPeer));

    // retrieve the packet
    nBytesRecvd = recvfrom
        (g_pnpstate->rgpnsSockets[nSocket]->socket,
         (char *)(&anpPacket), 
         SizeOfNtAuthenticatedNtpPacket, 
         0/*flags*/,
         &saPeer, 
         &nPeerAddrSize);

    // save the time related info
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teDestinationTimestamp.qw);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_PhaseOffset, &nSysPhaseOffset);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_TickCount,   &nSysTickCount);

    // now, see what happened
    if (SOCKET_ERROR==nBytesRecvd) {
        hr=HRESULT_FROM_WIN32(WSAGetLastError());
        if (HRESULT_FROM_WIN32(WSAECONNRESET)==hr) {
            if (FileLogAllowEntry(FL_ListeningThrdWarn)) {
                FileLogAdd(L"ListeningThread -- no NTP service running at ");
                FileLogSockaddrInEx(true /*append*/, (sockaddr_in *)&saPeer);
                FileLogAppend(L"\n");
            }
        } else {
            FileLog1(FL_ListeningThrdWarn, L"ListeningThread: recvfrom failed with 0x%08X. Ignoring.\n", hr);
        }
        goto done; 
    } else if (SizeOfNtAuthenticatedNtpPacket==nBytesRecvd) {
        bContainsAuthInfo=true;
    } else if (SizeOfNtpPacket==nBytesRecvd) {
        bContainsAuthInfo=false;
    } else {
        FileLog3(FL_ListeningThrdWarn, L"ListeningThread -- Recvd %d of %u/%u bytes. Ignoring.\n", nBytesRecvd, SizeOfNtpPacket, SizeOfNtAuthenticatedNtpPacket);
        goto done; 
    }
    if (FileLogAllowEntry(FL_ListeningThrdAnnounceLow)) {
        FileLogAdd(L"ListeningThread -- response heard from ");
        FileLogSockaddrInEx(true /*append*/, (sockaddr_in *)&saPeer);
        FileLogAppend(L"\n");
    }
    if (FileLogAllowEntry(FL_ListeningThrdDumpPackets)) {
        FileLogNtpPacket((NtpPacket *)&anpPacket, teDestinationTimestamp);
    }

    hr = HandleIncomingPacket(&anpPacket, bContainsAuthInfo, nSocket, (sockaddr_in *)&saPeer, &teDestinationTimestamp, &nSysPhaseOffset, &nSysTickCount);
    _JumpIfError(hr, error, "HandleIncomingPacket");

 done: 
    hr = S_OK; 
 error:
    // BUGBUG Should shutdown on error?
    // return hr; 
    ;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StartListeningThread() { 
    HRESULT hr;

    if (NULL != g_pnpstate->rghListeningThreadRegistered) { 
        hr = HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED); 
        _JumpError(hr, error, "StartListeningThread"); 
    }

    // Note: socket list must be initialized at this point!
    g_pnpstate->rghListeningThreadRegistered = (HANDLE *)LocalAlloc(LPTR, sizeof(HANDLE) * (2 + g_pnpstate->nSockets)); 
    _JumpIfOutOfMemory(hr, error, g_pnpstate->rghListeningThreadRegistered);

    // Register the handler for the stop event:
    if (!RegisterWaitForSingleObject
        (&g_pnpstate->rghListeningThreadRegistered[0],
         g_pnpstate->hStopEvent, 
         HandleListeningThreadStopEvent,
         NULL, 
         INFINITE, 
         WT_EXECUTEONLYONCE)) { 
        hr = HRESULT_FROM_WIN32(GetLastError()); 
        _JumpError(hr, error, "RegisterWaitForSingleObject");
    }
         
    // Register the handlers for each socket we're using:
    for (unsigned int nIndex = 1; nIndex < 1+g_pnpstate->nSockets; nIndex++) { 
        if (!RegisterWaitForSingleObject
            (&g_pnpstate->rghListeningThreadRegistered[nIndex],
             g_pnpstate->rgpnsSockets[nIndex-1]->hDataAvailEvent, 
             HandleListeningThreadDataAvail, 
             UIntToPtr(nIndex-1),
             INFINITE, 
             0)) { 
            hr = HRESULT_FROM_WIN32(GetLastError()); 
            _JumpError(hr, error, "RegisterWaitForSingleObject");
        }
    }

    hr = S_OK; 
 error:
    return hr; 

}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StopListeningThread() { 
    HRESULT hr = S_OK; 

    if (NULL != g_pnpstate->rghListeningThreadRegistered) { 
        // De-register all the callbacks which implemented the listening thread:
        for (DWORD dwIndex = 0; dwIndex < 1+g_pnpstate->nSockets; dwIndex++) { 
            if (NULL != g_pnpstate->rghListeningThreadRegistered[dwIndex]) { 
                if (!UnregisterWaitEx(g_pnpstate->rghListeningThreadRegistered[dwIndex] /*event to de-register*/, INVALID_HANDLE_VALUE /*wait forever*/)) { 
                    HRESULT hr2 = HRESULT_FROM_WIN32(GetLastError()); 
                    _TeardownError(hr, hr2, "UnregisterWaitEx"); 
                } 
            }
        }

        LocalFree(g_pnpstate->rghListeningThreadRegistered); 
        g_pnpstate->rghListeningThreadRegistered = NULL; 
    }

    return hr; 
}

//
// END listening thread's implementation. 
//
//--------------------------------------------------------------------


//####################################################################

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT HandleNtpProvShutdown(void) {
    bool     bEnteredCriticalSection  = false; 
    HRESULT  hr; 

    SYNCHRONIZE_PROVIDER(); 
    
    // All we really need to do on shutdown is save remaining peer list times
    // in the registry. 
    hr = SaveManualPeerTimes(); 
    _JumpIfError(hr, error, "SaveManualPeerTimes"); 

    hr = S_OK; 
 error:
    UNSYNCHRONIZE_PROVIDER(); 
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StopNtpProv(void) {
    HRESULT hr = S_OK;
    HRESULT hr2; 
    unsigned int nIndex;

    // shut everything down.

    g_pnpstate->bNtpProvStarted=false;

    // stop the threads
    if (NULL!=g_pnpstate->hStopEvent) {
        SetEvent(g_pnpstate->hStopEvent);
    }

    hr2 = myEnterCriticalSection(&g_pnpstate->csThreadTrap); 
    _TeardownError(hr, hr2, "myEnterCriticalSection"); 
    
    // Stop the listening and the peer polling thread: 
    hr2 = StopPeerPollingThread(); 
    _TeardownError(hr, hr2, "StopPeerPollingThread"); 

    hr2 = StopListeningThread();
    _TeardownError(hr, hr2, "StopListeningThread"); 

    hr2 = myLeaveCriticalSection(&g_pnpstate->csThreadTrap); 
    _TeardownError(hr, hr2, "myLeaveCriticalSection"); 

    // clean up our timer object:
    if (NULL != g_pnpstate->hPeerPollingThreadTimer) { 
        myDeleteTimerQueueTimer(NULL, g_pnpstate->hPeerPollingThreadTimer, INVALID_HANDLE_VALUE); 
    }

    // now clean up events
    if (NULL!=g_pnpstate->hStopEvent) {
        CloseHandle(g_pnpstate->hStopEvent);
    }
    if (NULL!=g_pnpstate->hDomHierRoleChangeEvent) {
        CloseHandle(g_pnpstate->hDomHierRoleChangeEvent);
    }

    // close the sockets
    if (NULL!=g_pnpstate->rgpnsSockets) {
        for (nIndex=0; nIndex<g_pnpstate->nSockets; nIndex++) {
            if (NULL != g_pnpstate->rgpnsSockets[nIndex]) { 
                FinalizeNicSocket(g_pnpstate->rgpnsSockets[nIndex]);
                LocalFree(g_pnpstate->rgpnsSockets[nIndex]);
                g_pnpstate->rgpnsSockets[nIndex] = NULL; 
            }
        }
        LocalFree(g_pnpstate->rgpnsSockets);
    }

    // we are done with winsock
    if (true==g_pnpstate->bSocketLayerOpen) {
        hr=CloseSocketLayer();
        _IgnoreIfError(hr, "CloseSocketLayer");
    }

    // We shouldn't have any more peers lying around
    _MyAssert(g_pnpstate->vActivePeers.empty());
    _MyAssert(g_pnpstate->vPendingPeers.empty());

    // free the sync objects for the peer list
    if (NULL!=g_pnpstate->hPeerListUpdated) {
        CloseHandle(g_pnpstate->hPeerListUpdated);
    }
    DeleteCriticalSection(&g_pnpstate->csPeerList);
    if (g_pnpstate->bCsThreadTrapIsInitialized) { 
	DeleteCriticalSection(&g_pnpstate->csThreadTrap);
    }

    if (NULL != g_pnpstate) {
        delete (g_pnpstate);
        g_pnpstate = NULL;
    }

    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StartNtpProv(TimeProvSysCallbacks * pSysCallbacks) {
    HRESULT hr;
    DWORD dwThreadID;

    // make sure global state is reset, in case we are restarted without being unloaded
    g_pnpstate = (NtpProvState *)new NtpProvState;
    _JumpIfOutOfMemory(hr, error, g_pnpstate);
    ZeroMemory(g_pnpstate, sizeof(NtpProvState));

    // We are now
    g_pnpstate->bNtpProvStarted=true;

    // save the callbacks table
    if (sizeof(g_pnpstate->tpsc)!=pSysCallbacks->dwSize) {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        _JumpError(hr, error, "(save sys callbacks)");
    }
    memcpy(&g_pnpstate->tpsc, pSysCallbacks, sizeof(TimeProvSysCallbacks));

    // init peer list
    g_pnpstate->hPeerListUpdated=CreateEvent(NULL/*security*/, FALSE/*auto*/, FALSE/*state*/, NULL/*name*/);
    if (NULL==g_pnpstate->hPeerListUpdated) {
        _JumpLastError(hr, error, "CreateEvent");
    }

    hr=myInitializeCriticalSection(&g_pnpstate->csPeerList);
    _JumpIfError(hr, error, "myInitializeCriticalSection");

    hr=myInitializeCriticalSection(&g_pnpstate->csThreadTrap);
    _JumpIfError(hr, error, "myInitializeCriticalSection"); 
    g_pnpstate->bCsThreadTrapIsInitialized = true; 

    // we need winsock
    hr=OpenSocketLayer();
    _JumpIfError(hr, error, "OpenSocketLayer");
    g_pnpstate->bSocketLayerOpen=true;

    // get the set of sockets to listen on
    hr=GetInitialSockets(&g_pnpstate->rgpnsSockets, &g_pnpstate->nSockets, &g_pnpstate->nListenOnlySockets);
    _JumpIfError(hr, error, "GetInitialSockets");

    g_pnpstate->hStopEvent=CreateEvent(NULL/*security*/, TRUE/*manual*/, FALSE/*state*/, NULL/*name*/);
    if (NULL==g_pnpstate->hStopEvent) {
        _JumpLastError(hr, error, "CreateEvent");
    }
    g_pnpstate->hDomHierRoleChangeEvent=CreateEvent(NULL/*security*/, FALSE/*auto*/, FALSE/*state*/, NULL/*name*/);
    if (NULL==g_pnpstate->hDomHierRoleChangeEvent) {
        _JumpLastError(hr, error, "CreateEvent");
    }

    // Create a timer which we'll use to implement "peer timeouts"
    hr = myCreateTimerQueueTimer(&g_pnpstate->hPeerPollingThreadTimer);
    _JumpIfError(hr, error, "myCreateTimerQueueTimer"); 

    hr = StartPeerPollingThread(); 
    _JumpIfError(hr, error, "StartPeerPollingThread"); 

    hr = StartListeningThread(); 
    _JumpIfError(hr, error, "StartListeningThread"); 

    hr=S_OK;
error:
    if(FAILED(hr)) {
        StopNtpProv();
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE int __cdecl compareStrings(const void * pcwsz1, const void * pcwsz2)
{
    LPVOID pv1 = const_cast<LPVOID>(pcwsz1);
    LPVOID pv2 = const_cast<LPVOID>(pcwsz2);

    return wcscmp(*static_cast<LPWSTR *>(pv1), *static_cast<LPWSTR *>(pv2));
}

MODULEPRIVATE HRESULT multiSzToStringArray(LPWSTR    mwsz,
                                           LPWSTR  **prgwszMultiSz,
                                           int      *pcStrings)
{
    int     cStrings     = 0;
    HRESULT hr           = E_UNEXPECTED;
    LPWSTR *rgwszMultiSz = NULL;

    if (NULL == prgwszMultiSz || NULL == pcStrings) {
        _JumpError(hr = E_INVALIDARG, ErrorReturn, "multiSzToStringArray");
    }

    for (WCHAR * wszName = mwsz; L'\0' != wszName[0]; wszName += wcslen(wszName) + 1) {
        cStrings++;
    }

    rgwszMultiSz = (LPWSTR *)LocalAlloc(LPTR, sizeof(LPWSTR) * cStrings);
    _JumpIfOutOfMemory(hr, ErrorReturn, rgwszMultiSz);

    cStrings = 0;
    for (WCHAR * wszName = mwsz; L'\0' != wszName[0]; wszName += wcslen(wszName) + 1) {
        rgwszMultiSz[cStrings++] = wszName;
    }

    *prgwszMultiSz = rgwszMultiSz;
    *pcStrings     = cStrings;
    hr = S_OK;

 CommonReturn:
    return hr;

 ErrorReturn:
    if (NULL != rgwszMultiSz) { LocalFree(rgwszMultiSz); }
    goto CommonReturn;
}

MODULEPRIVATE HRESULT ValidateNtpClientConfig(NtpClientConfig * pnccConfig) {
    const int RANGE_SPECIFIER  = -1;
    const int ALL_VALUES_VALID = -2;

    int       cStrings         = 0;
    HRESULT   hr               = S_OK;
    LPWSTR   *rgwszManualPeers = NULL;

    {
        struct {
            WCHAR *pwszRegValue;
            DWORD  dwValue;
            DWORD  dwValid[4];
            int    cValid;
        } rgValidSettings[] = {
            {
                wszNtpClientRegValueAllowNonstandardModeCombinations,
                pnccConfig->dwAllowNonstandardModeCombinations,
                { 0 },
                ALL_VALUES_VALID
            },{
                wszNtpClientRegValueCompatibilityFlags,
                pnccConfig->dwCompatibilityFlags,
                { 0 },
                ALL_VALUES_VALID
            },{
                wszNtpClientRegValueSpecialPollInterval,
                pnccConfig->dwSpecialPollInterval,
                { 0 },
                ALL_VALUES_VALID
            },{
                wszNtpClientRegValueResolvePeerBackoffMinutes,
                pnccConfig->dwResolvePeerBackoffMinutes,
                { 0 },
                ALL_VALUES_VALID
            },{
                wszNtpClientRegValueResolvePeerBackoffMaxTimes,
                pnccConfig->dwResolvePeerBackoffMaxTimes,
                { 0 },
                ALL_VALUES_VALID
            },{
                wszNtpClientRegValueEventLogFlags,
                pnccConfig->dwEventLogFlags,
                { 0 },
                ALL_VALUES_VALID
            }
        };

        for (unsigned int nIndex = 0; nIndex < ARRAYSIZE(rgValidSettings); nIndex++) {
            BOOL bValid;
            int  cValid  = rgValidSettings[nIndex].cValid;

            if (ALL_VALUES_VALID == cValid) {
                bValid = TRUE;
            }
            else if (RANGE_SPECIFIER == cValid) {
                bValid =
                    rgValidSettings[nIndex].dwValue >= rgValidSettings[nIndex].dwValid[0] &&
                    rgValidSettings[nIndex].dwValue <= rgValidSettings[nIndex].dwValid[1];
            }
            else if (0 <= cValid) {
                bValid = FALSE;
                for (int nValidIndex = 0; nValidIndex < cValid; nValidIndex++) {
                    if (rgValidSettings[nValidIndex].dwValue == rgValidSettings[nValidIndex].dwValid[nValidIndex]) {
                        bValid = TRUE;
                        break;
                    }
                }
            }
            else {
                _JumpError(hr = E_UNEXPECTED, error, "ValidateNtpClientConfig");
            }

            if (FALSE == bValid) {
                hr = HRESULT_FROM_WIN32(ERROR_BAD_CONFIGURATION);
                _JumpError(hr, error, "ValidateNtpClientConfig (DWORD tests)");
            }
        }
    }

    // Special-case validation
    {
        // Special case 1:
        //   Ensure that if we're sync'ing from the manual peer list,
        //   no duplicates exist in the peer list.

        if (pnccConfig->dwSyncFromFlags & NCSF_ManualPeerList) {
            hr = multiSzToStringArray(pnccConfig->mwszManualPeerList, &rgwszManualPeers, &cStrings);
            _Verify(S_OK != hr || NULL != rgwszManualPeers, hr, error);
            _JumpIfError(hr, error, "multiSzToStringArray");

            qsort(static_cast<LPVOID>(rgwszManualPeers), cStrings, sizeof(LPWSTR), compareStrings);

            for (int nIndex = 0; nIndex < (cStrings-1); nIndex++) {
                int nCharsToCompare1, nCharsToCompare2;

                nCharsToCompare1 = wcscspn(rgwszManualPeers[nIndex], L",");
                nCharsToCompare2 = wcscspn(rgwszManualPeers[nIndex+1], L",");
                nCharsToCompare1 = nCharsToCompare2 > nCharsToCompare1 ? nCharsToCompare2 : nCharsToCompare1;

                if (0 == _wcsnicmp(rgwszManualPeers[nIndex], rgwszManualPeers[nIndex+1], nCharsToCompare1)) {
                    // Error: duplicate peer in manual peer list:
                    hr = HRESULT_FROM_WIN32(ERROR_BAD_CONFIGURATION);
                    _JumpError(hr, error, "ValidateNtpClientConfig (duplicate manual peer entry)");
                }
            }
        }
    }

    hr = S_OK;

 error:
    if (NULL != rgwszManualPeers) { LocalFree(rgwszManualPeers); }
    return hr;
}

MODULEPRIVATE HRESULT ReadNtpClientConfig(NtpClientConfig ** ppnccConfig) {
    HRESULT hr;
    DWORD dwError;
    DWORD dwSize;
    DWORD dwType;
    WCHAR pwszType[512];

    memset(&pwszType[0], 0, sizeof(pwszType));

    // must be cleaned up
    HKEY              hkPolicyConfig          = NULL;
    HKEY              hkPolicyParameters      = NULL;
    HKEY              hkPreferenceConfig      = NULL;
    HKEY              hkPreferenceParameters  = NULL;
    NtpClientConfig  *pnccConfig    = NULL;

    struct RegKeysToOpen { 
        LPWSTR   pwszName; 
        HKEY     *phKey; 
	bool      fRequired; 
    } rgKeys[] = { 
        { wszNtpClientRegKeyPolicyConfig,    &hkPolicyConfig,          false }, 
        { wszW32TimeRegKeyPolicyParameters,  &hkPolicyParameters,      false },
        { wszNtpClientRegKeyConfig,          &hkPreferenceConfig,      true },
        { wszW32TimeRegKeyParameters,        &hkPreferenceParameters,  true }
    };  

    // allocate a new config structure
    pnccConfig=(NtpClientConfig *)LocalAlloc(LPTR, sizeof(NtpClientConfig));
    _JumpIfOutOfMemory(hr, error, pnccConfig);

    // Open the reg keys we'll be querying: 
    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgKeys); dwIndex++) { 
        dwError=RegOpenKeyEx(HKEY_LOCAL_MACHINE, rgKeys[dwIndex].pwszName, 0, KEY_READ, rgKeys[dwIndex].phKey);
        if (ERROR_SUCCESS!=dwError) {
            hr=HRESULT_FROM_WIN32(dwError);
	    if (rgKeys[dwIndex].fRequired) { // Can't proceed without this key:
		_JumpErrorStr(hr, error, "RegOpenKeyEx", rgKeys[dwIndex].pwszName);
	    } else { // We don't actually need this reg key: 
		_IgnoreErrorStr(hr, "RegOpenKeyEx", rgKeys[dwIndex].pwszName);
	    }
        }
    }

    // read all the values for the client configuration
    {
        struct {
            WCHAR * wszRegValue;
            DWORD * pdwValue;
        } rgRegParams[]={
            {
                wszNtpClientRegValueAllowNonstandardModeCombinations,
                &pnccConfig->dwAllowNonstandardModeCombinations
            },{
                wszNtpClientRegValueCompatibilityFlags,
                &pnccConfig->dwCompatibilityFlags
            },{
                wszNtpClientRegValueSpecialPollInterval,
                &pnccConfig->dwSpecialPollInterval
            },{
                wszNtpClientRegValueResolvePeerBackoffMinutes,
                &pnccConfig->dwResolvePeerBackoffMinutes
            },{
                wszNtpClientRegValueResolvePeerBackoffMaxTimes,
                &pnccConfig->dwResolvePeerBackoffMaxTimes
            },{
                wszNtpClientRegValueEventLogFlags,
                &pnccConfig->dwEventLogFlags
            }
        };
        // for each param
        for (unsigned int nParamIndex=0; nParamIndex<ARRAYSIZE(rgRegParams); nParamIndex++) {
            // Read the value from our preferences in the registry: 
            dwSize=sizeof(DWORD);
            hr = MyRegQueryPolicyValueEx(hkPreferenceConfig, hkPolicyConfig, rgRegParams[nParamIndex].wszRegValue, NULL, &dwType, (BYTE *)rgRegParams[nParamIndex].pdwValue, &dwSize);
            _JumpIfErrorStr(hr, error, "MyRegQueryPolicyValueEx", rgRegParams[nParamIndex].wszRegValue);
            _Verify(REG_DWORD==dwType, hr, error);
            FileLog2(FL_ReadConigAnnounceLow, L"ReadConfig: '%s'=0x%08X\n", rgRegParams[nParamIndex].wszRegValue, *rgRegParams[nParamIndex].pdwValue);
        }
    }

    //////////////////////////////////////////////////////////////////////
    //
    // Need to convert W2k time service reg key "Parameters\Type"
    // to Whistler Time Service "syncFromFlags".  The mapping is as
    // follows:
    //
    // Parameters\Type (REG_SZ)      syncFromFlags (DWORD)
    //
    // AllSync                   --> NCSF_DomainHierarchy | NCSF_ManualPeerList
    // NT5DS                     --> NCSF_DomainHierarchy
    // NTP                       --> NCSF_ManualPeerList
    // NoSync                    --> NCSF_NoSync
    //

    dwSize  = sizeof(pwszType);
    hr = MyRegQueryPolicyValueEx(hkPreferenceParameters, hkPolicyParameters, wszW32TimeRegValueType, NULL, &dwType, (BYTE *)pwszType, &dwSize);
    _JumpIfErrorStr(hr, error, "MyRegQueryPolicyValueEx", wszW32TimeRegValueType);
    _Verify(REG_SZ == dwType, hr, error);

    if (0 == _wcsicmp(pwszType, W32TM_Type_AllSync)) {
        pnccConfig->dwSyncFromFlags = NCSF_DomainHierarchy | NCSF_ManualPeerList;
    } else if (0 == _wcsicmp(pwszType, W32TM_Type_NT5DS)) {
        pnccConfig->dwSyncFromFlags = NCSF_DomainHierarchy;
    } else if (0 == _wcsicmp(pwszType, W32TM_Type_NTP)) {
        pnccConfig->dwSyncFromFlags = NCSF_ManualPeerList;
    } else if (0 == _wcsicmp(pwszType, W32TM_Type_NoSync)) {
        pnccConfig->dwSyncFromFlags = NCSF_NoSync;
    } else {
        _JumpErrorStr(hr = E_UNEXPECTED, error, "RegQueryValueEx", wszW32TimeRegValueType);
    }

    //
    // End Conversion.
    //
    //////////////////////////////////////////////////////////////////////


    // read values needed if we are syncing from the manual peers
    if (pnccConfig->dwSyncFromFlags&NCSF_ManualPeerList) {

        //////////////////////////////////////////////////////////////////////
        //
        // Need to convert W2k time service reg key "Parameters\NtpServer"
        // to Whistler Time Service "manualPeerList".  The mapping converts
        // the space-delimited string value in Parameters\NtpServer to
        // a NULL-delimited, double-NULL-terminated MULTI_SZ.
        //
    
        hr = MyRegQueryPolicyValueEx(hkPreferenceParameters, hkPolicyParameters, wszW32TimeRegValueNtpServer, NULL, &dwType, NULL, &dwSize);
        _JumpIfErrorStr(hr, error, "MyRegQueryPolicyValueEx", wszW32TimeRegValueNtpServer);
        _Verify(REG_SZ == dwType, hr, error);
   
        pnccConfig->mwszManualPeerList = (LPWSTR)LocalAlloc(LPTR, dwSize + sizeof(WCHAR));
        _JumpIfOutOfMemory(hr, error, pnccConfig->mwszManualPeerList);

        hr = MyRegQueryPolicyValueEx(hkPreferenceParameters, hkPolicyParameters, wszW32TimeRegValueNtpServer, NULL, &dwType, (BYTE *)pnccConfig->mwszManualPeerList, &dwSize);
        _JumpIfErrorStr(hr, error, "MyRegQueryPolicyValueEx", wszW32TimeRegValueNtpServer);

        // Perform the conversion -- convert all spaces to NULL,
        // and add a NULL to the end of the string.
        //
        pnccConfig->mwszManualPeerList[wcslen(pnccConfig->mwszManualPeerList)] = L'\0';
        for (LPWSTR pwszTemp = wcschr(pnccConfig->mwszManualPeerList, L' '); NULL != pwszTemp; pwszTemp = wcschr(pwszTemp, L' ')) {
            *pwszTemp++ = '\0';
        }

        dwError = RegQueryValueEx(hkPreferenceConfig, wszNtpClientRegValueSpecialPollTimeRemaining, NULL, &dwType, NULL, &dwSize); 
        if (ERROR_SUCCESS != dwError) { 
            hr=HRESULT_FROM_WIN32(dwError); 
            _JumpErrorStr(hr, error, "RegQueryValueEx", wszNtpClientRegValueSpecialPollTimeRemaining); 
        }
        _Verify(REG_MULTI_SZ == dwType, hr, error); 
   
        pnccConfig->mwszTimeRemaining = (LPWSTR)LocalAlloc(LPTR, dwSize); 
        _JumpIfOutOfMemory(hr, error, pnccConfig->mwszTimeRemaining); 

        dwError = RegQueryValueEx(hkPreferenceConfig, wszNtpClientRegValueSpecialPollTimeRemaining, NULL, &dwType, (BYTE *)pnccConfig->mwszTimeRemaining, &dwSize); 
        if (ERROR_SUCCESS != dwError) { 
            hr=HRESULT_FROM_WIN32(dwError); 
            _JumpErrorStr(hr, error, "RegQueryValueEx", wszNtpClientRegValueSpecialPollTimeRemaining); 
        }
        
        //
        // End Conversion.
        //
        //////////////////////////////////////////////////////////////////////
    
        if (FileLogAllowEntry(FL_ReadConigAnnounceLow)) {
            FileLogAdd(L"ReadConfig: '%s'=", wszNtpClientRegValueManualPeerList);
            WCHAR * wszTravel=pnccConfig->mwszManualPeerList;
            while (L'\0'!=wszTravel[0]) {
                if (wszTravel!=pnccConfig->mwszManualPeerList) {
                    FileLogAppend(L", '%s'", wszTravel);
                } else {
                    FileLogAppend(L"'%s'", wszTravel);
                }
                wszTravel+=wcslen(wszTravel)+1;
            }
            FileLogAppend(L"\n");
        }
    }

    // read values needed if we are syncing from the domain hierarchy
    if (pnccConfig->dwSyncFromFlags&NCSF_DomainHierarchy) {
        // get synchronize across sites flag
        dwSize=sizeof(DWORD);
        hr = MyRegQueryPolicyValueEx(hkPreferenceConfig, hkPolicyConfig, wszNtpClientRegValueCrossSiteSyncFlags, NULL, &dwType, (BYTE *)&pnccConfig->dwCrossSiteSyncFlags, &dwSize);
        _JumpIfErrorStr(hr, error, "MyRegQueryPolicyValueEx", wszNtpClientRegValueCrossSiteSyncFlags);
        _Verify(REG_DWORD==dwType, hr, error);
        FileLog2(FL_ReadConigAnnounceLow, L"ReadConfig: '%s'=0x%08X\n", wszNtpClientRegValueCrossSiteSyncFlags, pnccConfig->dwCrossSiteSyncFlags);
    }

     hr = ValidateNtpClientConfig(pnccConfig);
     _JumpIfError(hr, error, "ValidateNtpClientConfig");

    // success
    hr=S_OK;
    *ppnccConfig=pnccConfig;
    pnccConfig=NULL;

error:
    if (NULL!=pnccConfig) {
        FreeNtpClientConfig(pnccConfig);
    }
    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgKeys); dwIndex++) { 
        if (NULL != *(rgKeys[dwIndex].phKey)) {
            RegCloseKey(*(rgKeys[dwIndex].phKey));
	}
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StopNtpClient(void) {
    HRESULT      hr;
    NtpPeerVec  &vActive   = g_pnpstate->vActivePeers;   // aliased for readability
    NtpPeerVec  &vPending  = g_pnpstate->vPendingPeers;  // aliased for readability

    // must be cleaned up
    bool bTrappedThreads=false;

    // gain excusive access
    hr=TrapThreads(true);
    _JumpIfError(hr, error, "TrapThreads");
    bTrappedThreads=true;

    g_pnpstate->bNtpClientStarted=false;

    if (NULL!=g_pnpstate->wszLastSite) {
        LocalFree(g_pnpstate->wszLastSite);
        g_pnpstate->wszLastSite=NULL;
    };

    // Save time remaining for special poll interval peers in the registry
    hr=SaveManualPeerTimes(); 
    _IgnoreIfError(hr, "SaveManualPeerTimes"); // this error is not fatal

    // we need to empty the peer lists
    vActive.clear();
    vPending.clear();
    g_pnpstate->bWarnIfNoActivePeers=false;

    // Stop recieving notification of role changes
    if (0!=(g_pnpstate->dwSyncFromFlags&NCSF_DomainHierarchy)) {
        hr=LsaUnregisterPolicyChangeNotification(PolicyNotifyServerRoleInformation, g_pnpstate->hDomHierRoleChangeEvent);
        if (ERROR_SUCCESS!=hr) {
            hr=HRESULT_FROM_WIN32(LsaNtStatusToWinError(hr));
            _JumpError(hr, error, "LsaUnregisterPolicyChangeNotification");
        }
    }

    if (!SetEvent(g_pnpstate->hPeerListUpdated)) {
        _JumpLastError(hr, error, "SetEvent");
    }

    hr=S_OK;
error:
    if (true==bTrappedThreads) {
        // release excusive access
        HRESULT hr2=TrapThreads(false);
        _TeardownError(hr, hr2, "TrapThreads");
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE void ResetNtpClientLogOnceMessages(void) {
    g_pnpstate->bLoggedOnceMSG_NOT_DOMAIN_MEMBER=false;
    g_pnpstate->bLoggedOnceMSG_DOMAIN_HIERARCHY_ROOT=false;
    g_pnpstate->bLoggedOnceMSG_NT4_DOMAIN=false;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StartNtpClient(void) {
    HRESULT hr;
    bool bPeerListUpdated=false;
    NtTimeEpoch teNow; 
    NtpPeerVec &vPending = g_pnpstate->vPendingPeers; // aliased for readability

    // must be cleaned up
    NtpClientConfig * pncc=NULL;
    bool bTrappedThreads=false;

    // read the configuration
    hr=ReadNtpClientConfig(&pncc);
    _JumpIfError(hr, error, "ReadNtpClientConfig");

    // gain excusive access
    hr=TrapThreads(true);
    _JumpIfError(hr, error, "TrapThreads");
    bTrappedThreads=true;

    g_pnpstate->bNtpClientStarted=true;

    ResetNtpClientLogOnceMessages();

    // start watching the clock
    UpdatePeerListTimes();

    // create the manual peers
    if ((pncc->dwSyncFromFlags&NCSF_ManualPeerList) && NULL!=pncc->mwszManualPeerList) {
        // loop over all the entries in the multi_sz
        WCHAR * wszName = pncc->mwszManualPeerList;
        while (L'\0'!=wszName[0]) {
            NtTimePeriod tpTimeRemaining = gc_tpZero; 
	    NtTimeEpoch  teLastSyncTime = {0};

            for (WCHAR *wszTimeRemaining = pncc->mwszTimeRemaining; L'\0'!=wszTimeRemaining[0]; wszTimeRemaining += wcslen(wszTimeRemaining)+1) { 
                if (0 == CompareManualConfigIDs(wszName, wszTimeRemaining)) { 
                    wszTimeRemaining = wcschr(wszTimeRemaining, L',') + 1;

                    // We need to restore the NT time of LastSyncTime by LastSyncTime * 1000000000

                    teLastSyncTime.qw = ((unsigned __int64)wcstoul(wszTimeRemaining, NULL, 16)) * 1000000000;
                    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teNow.qw);
                    tpTimeRemaining.qw = teNow.qw - teLastSyncTime.qw;
                    if ( tpTimeRemaining.qw < ((unsigned __int64)pncc->dwSpecialPollInterval)*10000000){
                        tpTimeRemaining.qw = ((unsigned __int64)pncc->dwSpecialPollInterval)*10000000 - tpTimeRemaining.qw;
                    } else {
                        tpTimeRemaining.qw = 0;
                    }


                }
            } 

            hr=AddNewPendingManualPeer(wszName, tpTimeRemaining, teLastSyncTime);
            _JumpIfError(hr, error, "AddNewPendingManualPeer");
            wszName+=wcslen(wszName)+1;
            bPeerListUpdated=true;

        }
    }

    // handle domain hierarchy
    if (pncc->dwSyncFromFlags&NCSF_DomainHierarchy) {
        g_pnpstate->dwCrossSiteSyncFlags=pncc->dwCrossSiteSyncFlags;
        hr=AddNewPendingDomHierPeer();
        _JumpIfError(hr, error, "AddNewPendingDomHierPeer");
        bPeerListUpdated=true;

        // Start recieving notification of role changes
        hr=LsaRegisterPolicyChangeNotification(PolicyNotifyServerRoleInformation, g_pnpstate->hDomHierRoleChangeEvent);
        if (ERROR_SUCCESS!=hr) {
            hr=HRESULT_FROM_WIN32(LsaNtStatusToWinError(hr));
            _JumpError(hr, error, "LsaRegisterPolicyChangeNotification");
        }
    }

    if (bPeerListUpdated) {
	// Set a reasonable value for the last peer list update. 
	g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teNow.qw); 
	g_pnpstate->tePeerListLastUpdated=teNow; 

        sort(vPending.begin(), vPending.end());
        if (!SetEvent(g_pnpstate->hPeerListUpdated)) {
            _JumpLastError(hr, error, "SetEvent");
        }
    }

    // other interesting parameters
    g_pnpstate->bAllowClientNonstandardModeCominations=(0!=pncc->dwAllowNonstandardModeCombinations);
    g_pnpstate->dwSyncFromFlags=pncc->dwSyncFromFlags;
    g_pnpstate->dwClientCompatibilityFlags=pncc->dwCompatibilityFlags;
    g_pnpstate->dwSpecialPollInterval=pncc->dwSpecialPollInterval;
    g_pnpstate->dwResolvePeerBackoffMinutes=pncc->dwResolvePeerBackoffMinutes;
    g_pnpstate->dwResolvePeerBackoffMaxTimes=pncc->dwResolvePeerBackoffMaxTimes;
    g_pnpstate->dwEventLogFlags=pncc->dwEventLogFlags;

    // if we have no peers, then disable this warning.
    if (0==pncc->dwSyncFromFlags) {
        g_pnpstate->bWarnIfNoActivePeers=false;
    } else {
	// otherwise, we should have peers!
        g_pnpstate->bWarnIfNoActivePeers=true;

	if (NCSF_ManualPeerList==pncc->dwSyncFromFlags) { 
	    // The one exception is when we have only peers using the special poll interval -- 
	    // we don't want to warn until one of them is resolved.  
	    g_pnpstate->bWarnIfNoActivePeers=false;
	    for (NtpPeerIter pnpIter = vPending.begin(); pnpIter != vPending.end(); pnpIter++) { 
		if (0 == (NCMF_UseSpecialPollInterval & (*pnpIter)->dwManualFlags)) { 
		    g_pnpstate->bWarnIfNoActivePeers=true;
		}
	    }
	}
    }

    hr=S_OK;
error:
    if (true==bTrappedThreads) {
        // release excusive access
        HRESULT hr2=TrapThreads(false);
        _TeardownError(hr, hr2, "TrapThreads");
    }
    if (NULL!=pncc) {
        FreeNtpClientConfig(pncc);
    }
    if (FAILED(hr)) {
        HRESULT hr2=StopNtpClient();
        _IgnoreIfError(hr2, "StopNtpClient");
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT UpdateNtpClient(void) {
    bool            bPeerListUpdated = false;
    HRESULT         hr;
    NtpPeerVec     &vActive          = g_pnpstate->vActivePeers;   // aliased for readability
    NtpPeerVec     &vPending         = g_pnpstate->vPendingPeers;  // aliased for readability
    unsigned int    nIndex;

    // must be cleaned up
    NtpClientConfig * pncc=NULL;
    bool bTrappedThreads=false;

    // read the configuration
    hr=ReadNtpClientConfig(&pncc);
    _JumpIfError(hr, error, "ReadNtpClientConfig");

    // gain excusive access
    hr=TrapThreads(true);
    _JumpIfError(hr, error, "TrapThreads");
    bTrappedThreads=true;

    ResetNtpClientLogOnceMessages();

    // now, work through the parameters

    // check NonstandardModeCominations
    if (g_pnpstate->bAllowClientNonstandardModeCominations!=(0!=pncc->dwAllowNonstandardModeCombinations)) {
        g_pnpstate->bAllowClientNonstandardModeCominations=(0!=pncc->dwAllowNonstandardModeCombinations);
        FileLog0(FL_UpdateNtpCliAnnounce, L"  AllowClientNonstandardModeCominations changed.\n");
    };

    // check EventLogFlags
    if (g_pnpstate->dwEventLogFlags!=pncc->dwEventLogFlags) {
        g_pnpstate->dwEventLogFlags=pncc->dwEventLogFlags;
        FileLog0(FL_UpdateNtpCliAnnounce, L"  EventLogFlags changed.\n");
    };

    // check special poll interval
    if (g_pnpstate->dwSpecialPollInterval!=pncc->dwSpecialPollInterval) {
        g_pnpstate->dwSpecialPollInterval=pncc->dwSpecialPollInterval;
        // Make sure that any manual peers waiting on the special poll interval
        // don't wait too long if the special poll interval decreases.
        unsigned int nChanged=0;
        NtTimePeriod tpMaxTime={((unsigned __int64)g_pnpstate->dwSpecialPollInterval)*10000000};
        for (NtpPeerIter pnpIter = vActive.begin(); pnpIter != vActive.end(); pnpIter++) {
            if (e_ManualPeer == (*pnpIter)->ePeerType
                && 0 != (NCMF_UseSpecialPollInterval & (*pnpIter)->dwManualFlags)
                && (*pnpIter)->tpTimeRemaining > tpMaxTime) {
                // fix this one
                (*pnpIter)->tpTimeRemaining = tpMaxTime;
                nChanged++;
                bPeerListUpdated=true;
            } // <- end if manual peer that needs changing
        } // <- end removal loop
        FileLog1(FL_UpdateNtpCliAnnounce, L"  SpecialPollInterval disabled. chng:%u\n", nChanged);
    }

    // check compatibility flags
    if (g_pnpstate->dwClientCompatibilityFlags!=pncc->dwCompatibilityFlags) {
        g_pnpstate->dwClientCompatibilityFlags=pncc->dwCompatibilityFlags;
        unsigned int nChanged=0;
        for (NtpPeerIter pnpIter = vActive.begin(); pnpIter != vActive.end(); pnpIter++) {
            if ((*pnpIter)->dwCompatibilityFlags != g_pnpstate->dwClientCompatibilityFlags) {
                (*pnpIter)->dwCompatibilityFlags = g_pnpstate->dwClientCompatibilityFlags;
                bPeerListUpdated=true;
                nChanged++;
            }
        } // <- end flag fix loop
        FileLog1(FL_UpdateNtpCliAnnounce, L"  Compatibility flags changed. chng:%u\n", nChanged);
    } // <- end Compatibility flags

    // see if ResolvePeerBackoff* changed
    if (g_pnpstate->dwResolvePeerBackoffMinutes!=pncc->dwResolvePeerBackoffMinutes
        || g_pnpstate->dwResolvePeerBackoffMaxTimes!=pncc->dwResolvePeerBackoffMaxTimes) {

        // Now, update the ResolvePeerBackoff* params. Bring anyone in if they are too far out.
        g_pnpstate->dwResolvePeerBackoffMinutes=pncc->dwResolvePeerBackoffMinutes;
        g_pnpstate->dwResolvePeerBackoffMaxTimes=pncc->dwResolvePeerBackoffMaxTimes;
        unsigned int nNoChange=0;
        unsigned int nFixed=0;
        // calculate when we can retry
        NtTimePeriod tpMaxTimeRemaining={((unsigned __int64)g_pnpstate->dwResolvePeerBackoffMinutes)*600000000L}; //minutes to hundred nanoseconds
        for (nIndex=g_pnpstate->dwResolvePeerBackoffMaxTimes; nIndex>1; nIndex--) {
            tpMaxTimeRemaining*=2;
        }


        for (nIndex = 0; nIndex < 2; nIndex++) {
            NtpPeerVec &v = 0 == nIndex ? g_pnpstate->vActivePeers : g_pnpstate->vPendingPeers;
            for (NtpPeerIter pnpIter = v.begin(); pnpIter != v.end(); pnpIter++) {
                // Check this one
                bool bFixed=false;
                if ((*pnpIter)->nResolveAttempts>g_pnpstate->dwResolvePeerBackoffMaxTimes) {
                    (*pnpIter)->nResolveAttempts=g_pnpstate->dwResolvePeerBackoffMaxTimes;
                    bFixed=true;
                }
                if ((*pnpIter)->tpTimeRemaining>tpMaxTimeRemaining) {
                    (*pnpIter)->tpTimeRemaining=tpMaxTimeRemaining;
                    bFixed=true;
                }
                if (bFixed) {
                    bPeerListUpdated=true;
                    nFixed++;
                } else {
                    nNoChange++;
                }
            } // <- end fix loop
        }
        FileLog2(FL_UpdateNtpCliAnnounce, L"  ResolvePeerBackoff changed. fix:%u noch:%u\n", nFixed, nNoChange);
    } // <- end if ResolvePeerBackoff* changed

    // check each flag
    if (0==(pncc->dwSyncFromFlags&NCSF_ManualPeerList)) {
        if (0!=(g_pnpstate->dwSyncFromFlags&NCSF_ManualPeerList)) {
            // mask out
            g_pnpstate->dwSyncFromFlags&=~NCSF_ManualPeerList;
            // remove all from the list
            unsigned __int64 nRemoved;

            nRemoved  = count_if(vActive.begin(), vActive.end(), IsPeerType(e_ManualPeer));
            nRemoved += count_if(vPending.begin(), vPending.end(), IsPeerType(e_ManualPeer));
            vActive.erase(remove_if(vActive.begin(), vActive.end(), IsPeerType(e_ManualPeer)), vActive.end());
            vPending.erase(remove_if(vPending.begin(), vPending.end(), IsPeerType(e_ManualPeer)), vPending.end());
            bPeerListUpdated = nRemoved > 0;

            FileLog1(FL_UpdateNtpCliAnnounce, L"  ManualPeerList disabled. del:%I64u\n", nRemoved);
        } // <- end if change necessary
    } else {
        // mask in
        g_pnpstate->dwSyncFromFlags|=NCSF_ManualPeerList;

        // update list.
        unsigned int nAdded=0;
        unsigned int nRemoved=0;
        unsigned int nNoChange=0;

        // first, look at the current list and find deletions and duplicates.
        for (nIndex = 0; nIndex < 2; nIndex++) {
            NtpPeerVec & v = 0 == nIndex ? g_pnpstate->vActivePeers : g_pnpstate->vPendingPeers;
            for (NtpPeerIter pnpIter = v.begin(); pnpIter != v.end(); pnpIter++) {
                if (e_ManualPeer == (*pnpIter)->ePeerType) {
                    // find this peer in the list
                    WCHAR * wszPeerName = pncc->mwszManualPeerList;
                    while (L'\0' != wszPeerName[0]) {
                        if (0 == wcscmp(wszPeerName, (*pnpIter)->wszManualConfigID)) {
                            break;
                        }
                        wszPeerName += wcslen(wszPeerName) + 1;
                    }

                    // is this peer in the list?
                    if (L'\0'==wszPeerName[0]) {
                        // no - remove this one
                        pnpIter = v.erase(pnpIter);
                        nRemoved++;
                        bPeerListUpdated=true;
                    } else {
                        // yes. Step over subsequent duplicates
                        while (++pnpIter != v.end()
                               && e_ManualPeer == (*pnpIter)->ePeerType
                               && 0 == wcscmp((*pnpIter)->wszManualConfigID, (*(pnpIter-1))->wszManualConfigID)) {
                            nNoChange++;
                        }

                        // remove the name from the string
                        unsigned int nTailChars;
                        for (nTailChars=0; L'\0'!=wszPeerName[nTailChars]; nTailChars+=wcslen(&wszPeerName[nTailChars])+1) {;}
                        unsigned int nNameLen=wcslen(wszPeerName)+1;
                        nTailChars-=nNameLen-1;
                        memmove(wszPeerName, wszPeerName+nNameLen, sizeof(WCHAR)*nTailChars);
                        nNoChange++;
                    } // done with this peer. check the next

                    // Processing the manual peer ends up incrementing our iterator.
                    // If we don't decrement the iterator, we'll have an extra increment in our loop.
                    pnpIter--;
               } // <- end if manual peer
            } // <- end pnpIter = v.begin() through v.end()
        }

        // now, whatever is left in the string is new.
        WCHAR * wszName=pncc->mwszManualPeerList;
        while (L'\0'!=wszName[0]) {
	    NtTimeEpoch teNeverSyncd = {0}; 
            hr=AddNewPendingManualPeer(wszName, gc_tpZero, teNeverSyncd);
            _JumpIfError(hr, error, "AddNewPendingManualPeer");
            wszName+=wcslen(wszName)+1;
            bPeerListUpdated=true;
            nAdded++;
        } // <- end adding new manual peers

        FileLog3(FL_UpdateNtpCliAnnounce, L"  ManualPeerListUpdate: add:%u del:%u noch:%u\n", nAdded, nRemoved, nNoChange);

    } // <- end handling of NCSF_ManualPeerList flag

    // handle domain hierarchy
    if (0==(pncc->dwSyncFromFlags&NCSF_DomainHierarchy)) {
        if (0!=(g_pnpstate->dwSyncFromFlags&NCSF_DomainHierarchy)) {
            // stop Domain Hierarchy
            // mask out
            g_pnpstate->dwSyncFromFlags&=~NCSF_DomainHierarchy;
            // remove all from the list
            unsigned __int64 nRemoved;

            nRemoved  = count_if(vActive.begin(), vActive.end(), IsPeerType(e_DomainHierarchyPeer));
            nRemoved += count_if(vPending.begin(), vPending.end(), IsPeerType(e_DomainHierarchyPeer));
            vActive.erase(remove_if(vActive.begin(), vActive.end(), IsPeerType(e_DomainHierarchyPeer)), vActive.end());
            vPending.erase(remove_if(vPending.begin(), vPending.end(), IsPeerType(e_DomainHierarchyPeer)), vPending.end());
            bPeerListUpdated = nRemoved > 0;
            FileLog1(FL_UpdateNtpCliAnnounce, L"  DomainHierarchy disabled. del:%I64u\n", nRemoved);

            // Stop recieving notification of role changes
            hr=LsaUnregisterPolicyChangeNotification(PolicyNotifyServerRoleInformation, g_pnpstate->hDomHierRoleChangeEvent);
            if (ERROR_SUCCESS!=hr) {
                hr=HRESULT_FROM_WIN32(LsaNtStatusToWinError(hr));
                _JumpError(hr, error, "LsaUnegisterPolicyChangeNotification");
            }
        }
    } else {
        if (0==(g_pnpstate->dwSyncFromFlags&NCSF_DomainHierarchy)) {
            // start Domain Hierarchy
            // mask in
            g_pnpstate->dwSyncFromFlags|=NCSF_DomainHierarchy;

            g_pnpstate->dwCrossSiteSyncFlags=pncc->dwCrossSiteSyncFlags;

            hr=AddNewPendingDomHierPeer();
            _JumpIfError(hr, error, "AddNewPendingDomHierPeer");
            bPeerListUpdated=true;

            // Start recieving notification of role changes
            hr=LsaRegisterPolicyChangeNotification(PolicyNotifyServerRoleInformation, g_pnpstate->hDomHierRoleChangeEvent);
            if (ERROR_SUCCESS!=hr) {
                hr=HRESULT_FROM_WIN32(LsaNtStatusToWinError(hr));
                _JumpError(hr, error, "LsaRegisterPolicyChangeNotification");
            }

        } else {
            // update domain hierarchy

            // redetect if CrossSiteSyncFlags changes
            if (g_pnpstate->dwCrossSiteSyncFlags!=pncc->dwCrossSiteSyncFlags) {
                g_pnpstate->dwCrossSiteSyncFlags=pncc->dwCrossSiteSyncFlags;

                // remove all from the list
                unsigned __int64 nRemoved=0;
                nRemoved  = count_if(vActive.begin(), vActive.end(), IsPeerType(e_DomainHierarchyPeer));
                nRemoved += count_if(vPending.begin(), vPending.end(), IsPeerType(e_DomainHierarchyPeer));
                vActive.erase(remove_if(vActive.begin(), vActive.end(), IsPeerType(e_DomainHierarchyPeer)), vActive.end());
                vPending.erase(remove_if(vPending.begin(), vPending.end(), IsPeerType(e_DomainHierarchyPeer)), vPending.end());
                bPeerListUpdated = nRemoved > 0;

                FileLog1(FL_UpdateNtpCliAnnounce,L"  DomainHierarchy: CrossSiteSyncFlags changed. Redetecting. del:%I64u\n", nRemoved);

                hr=AddNewPendingDomHierPeer();
                _JumpIfError(hr, error, "AddNewPendingDomHierPeer");
                bPeerListUpdated=true;
            }

        } // <- end if we were already doing DomainHierarchy
    } // <- end handling NCSF_DomainHierarchy flag

    // if we have no peers, then disable this warning.
    // otherwise, we should have peers!
    if (0==pncc->dwSyncFromFlags) {
        g_pnpstate->bWarnIfNoActivePeers=false;
    } else {
        g_pnpstate->bWarnIfNoActivePeers=true;
    }

    // we have finished the update. Notify the peer polling thread if necessary
    if (bPeerListUpdated) {
        sort(vPending.begin(), vPending.end());
        sort(vActive.begin(), vActive.end());
        if (!SetEvent(g_pnpstate->hPeerListUpdated)) {
            _JumpLastError(hr, error, "SetEvent");
        }
    }

    hr=S_OK;
error:
    if (true==bTrappedThreads) {
        // release excusive access
        HRESULT hr2=TrapThreads(false);
        _TeardownError(hr, hr2, "TrapThreads");
    }
    if (NULL!=pncc) {
        FreeNtpClientConfig(pncc);
    }
    if (FAILED(hr)) {
        HRESULT hr2=StopNtpClient();
        _IgnoreIfError(hr2, "StopNtpClient");
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT ReadNtpServerConfig(NtpServerConfig ** ppnscConfig) {
    HRESULT hr;
    DWORD dwError;
    DWORD dwSize;
    DWORD dwType;

    // must be cleaned up
    HKEY hkConfig=NULL;
    NtpServerConfig * pnscConfig=NULL;

    // allocate a new config structure
    pnscConfig=(NtpServerConfig *)LocalAlloc(LPTR, sizeof(NtpServerConfig));
    _JumpIfOutOfMemory(hr, error, pnscConfig);

    // get our config key
    dwError=RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszNtpServerRegKeyConfig, 0, KEY_READ, &hkConfig);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegOpenKeyEx", wszNtpServerRegKeyConfig);
    }

    // get the AllowNonstandardModeCombinations flag
    dwSize=sizeof(DWORD);
    dwError=RegQueryValueEx(hkConfig, wszNtpServerRegValueAllowNonstandardModeCombinations, NULL, &dwType, (BYTE *)&pnscConfig->dwAllowNonstandardModeCombinations, &dwSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegQueryValueEx", wszNtpServerRegValueAllowNonstandardModeCombinations);
    }
    _Verify(REG_DWORD==dwType, hr, error);
    FileLog2(FL_ReadConigAnnounceLow, L"ReadConfig: '%s'=0x%08X\n", wszNtpServerRegValueAllowNonstandardModeCombinations, pnscConfig->dwAllowNonstandardModeCombinations);

    // success
    hr=S_OK;
    *ppnscConfig=pnscConfig;
    pnscConfig=NULL;

error:
    if (NULL!=pnscConfig) {
        FreeNtpServerConfig(pnscConfig);
    }
    if (NULL!=hkConfig) {
        RegCloseKey(hkConfig);
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StopNtpServer(void) {
    HRESULT  hr;

    // must be cleaned up
    bool bTrappedThreads=false;

    // gain excusive access
    hr=TrapThreads(true);
    _JumpIfError(hr, error, "TrapThreads");
    bTrappedThreads=true;

    g_pnpstate->bNtpServerStarted=false;

    // Adjust peers  (see bug #127559).
    for (DWORD dwIndex = 0; dwIndex < 2; dwIndex++) {
        NtpPeerVec &v = 0 == dwIndex ? g_pnpstate->vActivePeers : g_pnpstate->vPendingPeers;
        for (NtpPeerIter pnpIter = v.begin(); pnpIter != v.end(); pnpIter++) {
            // If we've dynamically determined the association mode, fix it up: 
            if (0 != (NCMF_AssociationModeMask & (*pnpIter)->dwManualFlags)) { 
                if (e_SymmetricActive == (*pnpIter)->eMode) {
                    (*pnpIter)->eMode = e_Client;
                } else if (e_SymmetricPassive == (*pnpIter)->eMode) {
                    // TODO: handle dymanic peers
                }
            }
        }
    }

    hr=S_OK;
error:
    if (true==bTrappedThreads) {
        // release excusive access
        HRESULT hr2=TrapThreads(false);
        _TeardownError(hr, hr2, "TrapThreads");
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StartNtpServer(void) {
    HRESULT hr;

    // must be cleaned up
    NtpServerConfig * pnsc=NULL;
    bool bTrappedThreads=false;

    // read the configuration
    hr=ReadNtpServerConfig(&pnsc);
    _JumpIfError(hr, error, "ReadNtpServerConfig");

    // gain excusive access
    hr=TrapThreads(true);
    _JumpIfError(hr, error, "TrapThreads");
    bTrappedThreads=true;

    g_pnpstate->bNtpServerStarted=true;

    g_pnpstate->bAllowServerNonstandardModeCominations=(0!=pnsc->dwAllowNonstandardModeCombinations);

    // Adjust peers  (see bug #127559).
    for (DWORD dwIndex = 0; dwIndex < 2; dwIndex++) {
        NtpPeerVec &v = 0 == dwIndex ? g_pnpstate->vActivePeers : g_pnpstate->vPendingPeers;
        for (NtpPeerIter pnpIter = v.begin(); pnpIter != v.end(); pnpIter++) {
            // If we've dynamically determined the association mode, fix it up: 
            if (0 != (NCMF_AssociationModeMask & (*pnpIter)->dwManualFlags)) { 
                if (e_Client == (*pnpIter)->eMode) {
                    (*pnpIter)->eMode = e_SymmetricActive;
                } else if (e_SymmetricPassive == (*pnpIter)->eMode) {
                    // All symmetric passive peers should have been disconnected
                    // on server shutdown.
                    _MyAssert(FALSE);
                }
            }
        }
    }

    hr=S_OK;
error:
    if (true==bTrappedThreads) {
        // release excusive access
        HRESULT hr2=TrapThreads(false);
        _TeardownError(hr, hr2, "TrapThreads");
    }
    if (NULL!=pnsc) {
        FreeNtpServerConfig(pnsc);
    }
    if (FAILED(hr)) {
        HRESULT hr2=StopNtpClient();
        _IgnoreIfError(hr2, "StopNtpClient");
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT UpdateNtpServer(void) {
    HRESULT hr;

    // must be cleaned up
    NtpServerConfig * pnsc=NULL;
    bool bTrappedThreads=false;

    // read the configuration
    hr=ReadNtpServerConfig(&pnsc);
    _JumpIfError(hr, error, "ReadNtpServerConfig");

    // gain excusive access
    hr=TrapThreads(true);
    _JumpIfError(hr, error, "TrapThreads");
    bTrappedThreads=true;

    // only one parameter
    g_pnpstate->bAllowServerNonstandardModeCominations=(0!=pnsc->dwAllowNonstandardModeCombinations);

    hr=S_OK;
error:
    if (true==bTrappedThreads) {
        // release excusive access
        HRESULT hr2=TrapThreads(false);
        _TeardownError(hr, hr2, "TrapThreads");
    }
    if (NULL!=pnsc) {
        FreeNtpServerConfig(pnsc);
    }
    if (FAILED(hr)) {
        HRESULT hr2=StopNtpClient();
        _IgnoreIfError(hr2, "StopNtpClient");
    }
    return hr;
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT HandleNtpProvQuery(PW32TIME_PROVIDER_INFO *ppProviderInfo) {
    bool                    bEnteredCriticalSection  = false; 
    DWORD                   cb                       = 0; 
    DWORD                   dwPeers                  = 0; 
    HRESULT                 hr                       = HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED); 
    LPWSTR                  pwszCurrent              = NULL; 
    NtpPeerVec             &vActive                  = g_pnpstate->vActivePeers; 
    NtpPeerVec             &vPending                 = g_pnpstate->vPendingPeers; 
    W32TIME_PROVIDER_INFO  *pProviderInfo            = NULL;

    // NULL-out the OUT parameter: 
    *ppProviderInfo = NULL; 

    //---------------------------------------------------------------------- 
    // Make a TIME_PROVIDER_INFO blob to return to the caller.  The structure
    // of the blob is:
    //
    //                           +------------------------------+
    //                           + W32TIME_PROVIDER_INFO        +
    //                           +------------------------------+
    // n                         | ulProviderType               |
    // n+0x4                     | pProviderData                | --> n+0x8
    //                           +------------------------------+
    //                           + W32TIME_NTP_PROVIDER_DATA    +
    //                           +------------------------------+
    // n+0x8                     | ulSize                       |
    // n+0xc                     | ulError                      | 
    // n+0x10                    | ulErrorMsgId                 |
    // n+0x14                    | cPeerInfo                    |
    // n+0x18                    | pPeerInfo                    | --> n+0x1c
    //                           +------------------------------+
    //                           + W32TIME_NTP_PEER_INFO array  +
    //                           +------------------------------+
    // n+0x1c                    | elem[0]                      |
    // &elem[0]+sizeof(elem[0])  | elem[1]                      |
    // &elem[1]+sizeof(elem[0])  | elem[2]                      |
    // ...
    //                           +------------------------------+
    //                           | Strings used by peer array   |
    //                           +------------------------------+
    // 
    //---------------------------------------------------------------------- 

    SYNCHRONIZE_PROVIDER(); 

    // Make sure we have the most current peer list times: 
    UpdatePeerListTimes(); 

    // Since our OUT param is allocate(all_nodes), we need to determine the size
    // of the blob to allocate: 
    cb += sizeof(W32TIME_PROVIDER_INFO);
    cb += sizeof(W32TIME_NTP_PROVIDER_DATA); 
    for (DWORD dwIndex = 0; dwIndex < 2; dwIndex++) { 
        NtpPeerVec &v = 0 == dwIndex ? vActive : vPending; 
        for (NtpPeerIter pnpIter = v.begin(); pnpIter != v.end(); pnpIter++) { 
            cb += sizeof(W32TIME_NTP_PEER_INFO); 
            if (NULL != (*pnpIter)->wszManualConfigID) { 
		cb += sizeof(WCHAR) * (wcslen((*pnpIter)->wszManualConfigID) + 1); 
	    } else { 
		cb += sizeof(WCHAR);
	    }
        }
    }

    // Allocate the returned blob: 
    pProviderInfo = (W32TIME_PROVIDER_INFO *)midl_user_allocate(cb); 
    _JumpIfOutOfMemory(hr, error, pProviderInfo); 
    ZeroMemory(pProviderInfo, cb); 

    // Fill in the query information:
    //
    // W32TIME_PROVIDER_INFO 
    pProviderInfo->ulProviderType                 = W32TIME_PROVIDER_TYPE_NTP;
    pProviderInfo->ProviderData.pNtpProviderData  = (W32TIME_NTP_PROVIDER_DATA *)(pProviderInfo + 1);

    // W32TIME_NTP_PROVIDER_DATA
    { 
        W32TIME_NTP_PROVIDER_DATA *pProviderData = pProviderInfo->ProviderData.pNtpProviderData; 

        pProviderData->ulSize        = sizeof(W32TIME_NTP_PROVIDER_DATA); 
        pProviderData->ulError       = S_OK;  // Provider errors n.y.i.
        pProviderData->ulErrorMsgId  = 0;     // Provider errors n.y.i.
        pProviderData->cPeerInfo     = vActive.size() + vPending.size(); 
        pProviderData->pPeerInfo     = (W32TIME_NTP_PEER_INFO *)(pProviderData + 1); 

        // W32TIME_NTP_PEER_INFO array: 

        // set pwszCurrent to the next available location for string data:
        // (starts at the END of the W32TIME_NTP_PEER_INFO array. 
        // 
        pwszCurrent = (WCHAR *)(pProviderData->pPeerInfo + pProviderData->cPeerInfo); 
        for (DWORD dwIndex = 0; dwIndex < 2; dwIndex++) { 
            NtpPeerVec &v = 0 == dwIndex ? vActive : vPending; 
            for (NtpPeerIter pnpIter = v.begin(); pnpIter != v.end(); pnpIter++) {
                NtpPeerPtr pnp = *pnpIter; 
        
                pProviderData->pPeerInfo[dwPeers].ulSize                = sizeof(W32TIME_NTP_PEER_INFO);
                pProviderData->pPeerInfo[dwPeers].ulResolveAttempts     = pnp->nResolveAttempts; 
                pProviderData->pPeerInfo[dwPeers].u64TimeRemaining      = pnp->tpTimeRemaining.qw; 
                pProviderData->pPeerInfo[dwPeers].u64LastSuccessfulSync = pnp->teLastSuccessfulSync.qw;
                pProviderData->pPeerInfo[dwPeers].ulLastSyncError       = pnp->dwError;
                pProviderData->pPeerInfo[dwPeers].ulLastSyncErrorMsgId  = pnp->dwErrorMsgId; 
                pProviderData->pPeerInfo[dwPeers].ulPeerPollInterval    = pnp->nPeerPollInterval; 
                pProviderData->pPeerInfo[dwPeers].ulHostPollInterval    = pnp->nHostPollInterval; 
                pProviderData->pPeerInfo[dwPeers].ulMode                = pnp->eMode; 
                pProviderData->pPeerInfo[dwPeers].ulReachability        = pnp->nrrReachability.nReg; 
                pProviderData->pPeerInfo[dwPeers].ulValidDataCounter    = pnp->nValidDataCounter; 
                pProviderData->pPeerInfo[dwPeers].ulAuthTypeMsgId       = gc_rgdwAuthTypeMsgIds[pnp->eAuthType]; 
                pProviderData->pPeerInfo[dwPeers].ulStratum             = (unsigned char)pnp->nStratum;
		// pwszCurrent points to the next free location for string data
		pProviderData->pPeerInfo[dwPeers].wszUniqueName = pwszCurrent; 

                if (NULL != pnp->wszManualConfigID) { 
		    wcscpy(pwszCurrent, pnp->wszManualConfigID); 
		} else { 
		    pwszCurrent[0] = L'\0'; 
		}
		 
		// set pwszCurrent to point to the end of the current string.  
		pwszCurrent += wcslen(pwszCurrent) + 1; 
		    
                dwPeers++; 
            }
        }
    }
    
    // Success: 
    *ppProviderInfo           = pProviderInfo; 
    pProviderInfo             = NULL; 
    hr                        = S_OK; 
 error:
    UNSYNCHRONIZE_PROVIDER(); 
    if (NULL != pProviderInfo) { 
        midl_user_free(pProviderInfo); 
    }
    return hr; 
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT HandleNtpClientTimeJump(TpcTimeJumpedArgs *ptjArgs) {
    HRESULT        hr;
    unsigned int   nIndex;
    NtpPeerVec    &vActive   = g_pnpstate->vActivePeers;   // aliased for readability
    NtpPeerVec    &vPending  = g_pnpstate->vPendingPeers;  // aliased for readability

    // must be cleaned up
    bool bEnteredCriticalSection=false;

    // The time has changed, so fix everything time dependent.
    // o the listening thread has no time dependencies
    // o the peer polling thread does everything by intervals and not
    //   absolute times. If the clock is moved forward, things will come
    //   due sooner, maybe all at once. If the clock is moved backward
    //   all the time that has passed up to this point will not be
    //   deducted from the wait intervals - if you almost finished
    //   waiting a half hour, and there was a slip, you might have to
    //   wait another half hour. Both of these are acceptible in this
    //   circumstance, and all we need to do is tell the thread to
    //   update and these fixups will happen automatically.
    // o the saved data on the peers. Just need to call ClearPeerTimeData
    //   on all the peers
    //
    //   NOTE:  I disagree with this analysis.  If you've timejumped, 
    //          you may be off by several minutes.  It is important to provide
    //          time samples to the manager as soon as possible.  (duncanb)
    // 

    // gain access to the peer list, but we don't have to block the
    // listening thread
    SYNCHRONIZE_PROVIDER(); 

    for (NtpPeerIter pnpIter = vActive.begin(); pnpIter != vActive.end(); pnpIter++) { 
        // reset the time data (but not connectivity data) on all the peers
        ClearPeerTimeData(*pnpIter); 

	// We want to update the peer list times in the following cases:
	// 1) If the time slip was requested by the user OR
	// 2) If the peer is not a manual peer using the special poll interval
	if ((0 != (TJF_UserRequested & ptjArgs->tjfFlags)) ||
	    (e_ManualPeer != (*pnpIter)->ePeerType) ||
	    (0 == (NCMF_UseSpecialPollInterval & (*pnpIter)->dwManualFlags))) { 
	    UpdatePeerPollingInfo(*pnpIter, e_TimeJumped); 
	}
    }

    for (NtpPeerIter pnpIter = vPending.begin(); pnpIter != vPending.end(); pnpIter++) { 
	// We want to resolve any manual peers using the special poll interval, 
	// IF the time slip was requested by the user.  Otherwise, the timedate cpl
	// will have no way of waking up our pending peers to resync (it pulses us 
	// by setting the time slip event). 
	// 
	if ((0 != (TJF_UserRequested & ptjArgs->tjfFlags)) &&
	    (e_ManualPeer == (*pnpIter)->ePeerType) &&
	    (0 != (NCMF_UseSpecialPollInterval & (*pnpIter)->dwManualFlags))) { 
	    
	    // We've gotten a user-requested time slip.  Time to try resolving
	    // this peer again. 
	    (*pnpIter)->tpTimeRemaining   = gc_tpZero; 
	    (*pnpIter)->nResolveAttempts  = 0;
	}	
    }

    // tell the peer poling thread that it needs to update
    if (!SetEvent(g_pnpstate->hPeerListUpdated)) {
        _JumpLastError(hr, error, "SetEvent");
    }

    hr=S_OK;
error:
    UNSYNCHRONIZE_PROVIDER(); 
    if (FAILED(hr)) {
        HRESULT hr2=StopNtpClient();
        _IgnoreIfError(hr2, "StopNtpClient");
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT HandleNtpClientPollIntervalChange(void) {
    HRESULT hr;
    unsigned int nIndex;

    // must be cleaned up
    bool bEnteredCriticalSection=false;

    // gain access to the peer list, but we don't have to block the
    // listening thread
    SYNCHRONIZE_PROVIDER(); 

    // reset the time data (but not connectivity data) on all the peers
    for (NtpPeerIter pnpIter = g_pnpstate->vActivePeers.begin(); pnpIter != g_pnpstate->vActivePeers.end(); pnpIter++) {
        UpdatePeerPollingInfo(*pnpIter, e_Normal);
    }

    // tell the peer poling thread that it needs to update
    if (!SetEvent(g_pnpstate->hPeerListUpdated)) {
        _JumpLastError(hr, error, "SetEvent");
    }

    hr=S_OK;
error:
    UNSYNCHRONIZE_PROVIDER(); 

    if (FAILED(hr)) {
        HRESULT hr2=StopNtpClient();
        _IgnoreIfError(hr2, "StopNtpClient");
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT HandleNetTopoChange(TpcNetTopoChangeArgs *ptntcArgs) {
    HRESULT        hr;
    NtpPeerVec    &vActive    = g_pnpstate->vActivePeers;   // aliased for readability
    NtpPeerVec    &vPending   = g_pnpstate->vPendingPeers;  // aliased for readability
    NtpPeerVec     vPendingUnique; 
    unsigned int   nIndex;
    unsigned int   nRemoved   = 0;
    unsigned int   nPended    = 0;
    unsigned int   nOldPend   = 0;

    // must be cleaned up
    bool bTrappedThreads=false;

    // gain excusive access
    hr=TrapThreads(true);
    _JumpIfError(hr, error, "TrapThreads");
    bTrappedThreads=true;

    FileLog0(FL_NetTopoChangeAnnounce, L"NtpProvider: Network Topology Change\n");

    // close the sockets.  
    // NOTE: Do this first so if we error out, at least our socket list is invalidated.
    if (NULL!=g_pnpstate->rgpnsSockets) {
        for (nIndex=0; nIndex<g_pnpstate->nSockets; nIndex++) {
            if (NULL != g_pnpstate->rgpnsSockets[nIndex]) { 
                FinalizeNicSocket(g_pnpstate->rgpnsSockets[nIndex]);
                LocalFree(g_pnpstate->rgpnsSockets[nIndex]);
                g_pnpstate->rgpnsSockets[nIndex] = NULL; 
            }
        }
        LocalFree(g_pnpstate->rgpnsSockets);
    }
    g_pnpstate->rgpnsSockets=NULL;
    g_pnpstate->nSockets=0;
    g_pnpstate->nListenOnlySockets=0;

    // demote all active peers to pending
    _SafeStlCall(copy(vActive.begin(), vActive.end(), back_inserter(vPending)), hr, error, "copy");
    vActive.clear();
    
    // sort the pending peer list: 
    sort(vPending.begin(), vPending.end());
    
    // delete duplicates, retaining the peers with the most recent sync times
    hr = GetMostRecentlySyncdDnsUniquePeers(vPendingUnique); 
    _JumpIfError(hr, error, "GetMostRecentlySyncdDnsUniquePeers"); 

    // clear the old pending list, and copy back the remaining (unique) peers
    vPending.clear(); 
    for (NtpPeerIter pnpIter = vPendingUnique.begin(); pnpIter != vPendingUnique.end(); pnpIter++) { 
	_SafeStlCall(vPending.push_back(*pnpIter), hr, error, "push_back"); 
    }

    // give all pending peers a clean slate.  
    // NOTE: this does not apply to manual peers using the special poll interval.  We don't want 
    //       to resolve them until their poll interval is up. 
    // 
    // Also, we don't want to log an event indicating that we have no peers
    // if our only peers are manual peers using the special poll interval. 
    // These peers will not be re-resolved at this time, but we don't need
    // them to be resolved until their next poll time, so we shouldn't 
    // indicate an error. 
    NtTimeEpoch teNow;
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teNow.qw);
    g_pnpstate->bWarnIfNoActivePeers=false;
    for (NtpPeerIter pnpIter = vPending.begin(); pnpIter != vPending.end(); pnpIter++) {
	bool bResetTimeRemaining = true; 

	// We want to update the peer list times EXCEPT in the case where
	// we have a manual peer using the special poll interval.  In this case,
	// we'll only update if it's been greater than one poll interval since
	// the last sync. 
	if ((0 == (NTC_UserRequested & ptntcArgs->ntcfFlags)) &&
	    (e_ManualPeer == (*pnpIter)->ePeerType) &&
	    (0 != (NCMF_UseSpecialPollInterval & (*pnpIter)->dwManualFlags))) { 
	    // We've got a manual peer using the special poll interval.  We'll 
	    // reset it's time remaining to 0 if it has not sync'd in greater than
	    // the poll interval. '
	    bResetTimeRemaining = ((*pnpIter)->teLastSuccessfulSync.qw + (((unsigned __int64)g_pnpstate->dwSpecialPollInterval)*10000000)) < teNow.qw; 
	}
 
	if (bResetTimeRemaining) { 
	    // Reset the peer time to zero (resolve immediately):
	    (*pnpIter)->tpTimeRemaining      = gc_tpZero;
	    (*pnpIter)->nResolveAttempts     = 0;
	    // We should be able to resolve at least one peer!
	    g_pnpstate->bWarnIfNoActivePeers = true;
	}
    }
    nOldPend = vPending.size();

    for (NtpPeerIter pnpIter = vPending.begin(); pnpIter != vPending.end(); pnpIter++) {
        // change state variables
        if (NULL != (*pnpIter)->wszDomHierDcName) {
            LocalFree((*pnpIter)->wszDomHierDcName);
        }
        if (NULL != (*pnpIter)->wszDomHierDomainName) {
            LocalFree((*pnpIter)->wszDomHierDomainName);
        }
        {
            // Reset this peer.  
            // 1) Keep track of variables we wish to save:
            NtpPeerType        ePeerType             = (*pnpIter)->ePeerType;
            WCHAR             *wszManualConfigID     = (*pnpIter)->wszManualConfigID;
            DWORD              dwManualFlags         = (*pnpIter)->dwManualFlags; 
	    NtTimePeriod       tpTimeRemaining       = (*pnpIter)->tpTimeRemaining; 
	    CRITICAL_SECTION   csPeer                = (*pnpIter)->csPeer; 
	    bool               bCsIsInitialized	     = (*pnpIter)->bCsIsInitialized; 
	    NtTimeEpoch        teLastSuccessfulSync  = (*pnpIter)->teLastSuccessfulSync;
	    DWORD              dwError               = (*pnpIter)->dwError; 
	    DWORD              dwErrorMsgId          = (*pnpIter)->dwErrorMsgId;

            // 2) reset all variables to initial state
            (*pnpIter)->reset();          // ZeroMemory(pnpIter, sizeof(NtpPeer));

            // 3) Restore saved variables
            (*pnpIter)->ePeerType             = ePeerType;
            (*pnpIter)->wszManualConfigID     = wszManualConfigID;
            (*pnpIter)->dwManualFlags         = dwManualFlags; 
	    (*pnpIter)->tpTimeRemaining       = tpTimeRemaining; 
	    (*pnpIter)->csPeer                = csPeer; 
	    (*pnpIter)->bCsIsInitialized      = bCsIsInitialized; 
	    (*pnpIter)->teLastSuccessfulSync  = teLastSuccessfulSync; 
	    (*pnpIter)->dwError               = dwError; 
	    (*pnpIter)->dwErrorMsgId          = dwErrorMsgId; 
        }

        nPended++;
    }
    FileLog3(FL_NetTopoChangeAnnounce, L"  Peers reset: p-p:%u a-p:%u a-x:%u\n", nOldPend, nPended, nRemoved);

    for (NtpPeerIter pnpIter = vPending.begin(); pnpIter != vPending.end(); pnpIter++) {
        if (e_DomainHierarchyPeer == (*pnpIter)->ePeerType) {
	    // Discover the domain hierarchy as a background caller.  
	    // If this fails, we'll fall back and force it anyway.  
            (*pnpIter)->eDiscoveryType=e_Background;
        }
    }

    // we have finished the update. Notify the peer polling thread
    if (!SetEvent(g_pnpstate->hPeerListUpdated)) {
        _JumpLastError(hr, error, "SetEvent");
    }

    // get new set of sockets
    hr=GetInitialSockets(&g_pnpstate->rgpnsSockets, &g_pnpstate->nSockets, &g_pnpstate->nListenOnlySockets);
    _JumpIfError(hr, error, "GetInitialSockets");

    hr=S_OK;
error:
    if (true==bTrappedThreads) {
        // release excusive access
        HRESULT hr2=TrapThreads(false);
        _TeardownError(hr, hr2, "TrapThreads");
    }
    return hr;

}

//####################################################################
// module public functions


//--------------------------------------------------------------------
HRESULT __stdcall
NtpTimeProvOpen(IN WCHAR * wszName, IN TimeProvSysCallbacks * pSysCallbacks, OUT TimeProvHandle * phTimeProv) {
    HRESULT hr;
    bool bCheckStartupFailed=false;

    FileLog1(FL_NtpProvControlAnnounce, L"NtpTimeProvOpen(\"%s\") called.\n", wszName);

    if (0==wcscmp(wszName, wszNTPSERVERPROVIDERNAME)) {
        if (NULL != g_pnpstate && true==g_pnpstate->bNtpServerStarted) {
            hr=HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
            _JumpError(hr, error, "(provider init)");
        }
        if (NULL == g_pnpstate || false==g_pnpstate->bNtpProvStarted) {
            hr=StartNtpProv(pSysCallbacks);
            _JumpIfError(hr, error, "StartNtpProv");
        }
        hr=StartNtpServer();
        bCheckStartupFailed=true;
        _JumpIfError(hr, error, "StartNtpServer");

        *phTimeProv=NTPSERVERHANDLE;
        FileLog0(FL_NtpProvControlAnnounce, L"NtpServer started.\n");

    } else if (0==wcscmp(wszName, wszNTPCLIENTPROVIDERNAME)) {
        if (NULL != g_pnpstate && true==g_pnpstate->bNtpClientStarted) {
            hr=HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
            _JumpError(hr, error, "(provider init)");
        }
        if (NULL == g_pnpstate || false==g_pnpstate->bNtpProvStarted) {
            hr=StartNtpProv(pSysCallbacks);
            _JumpIfError(hr, error, "StartNtpProv");
        }
        hr=StartNtpClient();
        bCheckStartupFailed=true;
        _JumpIfError(hr, error, "StartNtpClient");

        *phTimeProv=NTPCLIENTHANDLE;
        FileLog0(FL_NtpProvControlAnnounce, L"NtpClient started.\n");

    } else {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        _JumpError(hr, error, "(dispatch by provider name)");
    }

    hr=S_OK;
error:
    if (FAILED(hr) && true==bCheckStartupFailed
        && false==g_pnpstate->bNtpServerStarted && false==g_pnpstate->bNtpClientStarted) {
        HRESULT hr2=StopNtpProv();
        _IgnoreIfError(hr2, "StopNtpProv");
    }
    return hr;
}

//--------------------------------------------------------------------
HRESULT __stdcall
NtpTimeProvCommand(IN TimeProvHandle hTimeProv, IN TimeProvCmd eCmd, IN TimeProvArgs pvArgs) {
    HRESULT hr;

    const WCHAR * wszCmd;
    switch (eCmd) {
    case TPC_TimeJumped:
        wszCmd=L"TPC_TimeJumped"; break;
    case TPC_UpdateConfig:
        wszCmd=L"TPC_UpdateConfig"; break;
    case TPC_PollIntervalChanged:
        wszCmd=L"TPC_PollIntervalChanged"; break;
    case TPC_GetSamples:
        wszCmd=L"TPC_GetSamples"; break;
    case TPC_NetTopoChange:
        wszCmd=L"TPC_NetTopoChange"; break;
    case TPC_Query:
	wszCmd=L"TPC_Query"; break; 
    case TPC_Shutdown:
	wszCmd=L"TPC_Shutdown"; break; 
    default:
        wszCmd=L"(unknown command)"; break;
    }

    const WCHAR * wszProv;
    if (NTPSERVERHANDLE==hTimeProv && g_pnpstate->bNtpServerStarted) {
        wszProv=L"NtpServer";
    } else if (NTPCLIENTHANDLE==hTimeProv && g_pnpstate->bNtpClientStarted) {
        wszProv=L"NtpClient";
    } else {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "(provider handle verification)");
    }
    FileLog2(FL_NtpProvControlAnnounce, L"TimeProvCommand([%s], %s) called.\n", wszProv, wszCmd);

    switch (eCmd) {
    case TPC_TimeJumped:
        if (NTPCLIENTHANDLE==hTimeProv) {
            hr=HandleNtpClientTimeJump((TpcTimeJumpedArgs *)pvArgs);
            _JumpIfError(hr, error, "HandleNtpClientTimeJump");
        } else {
            // nothing to do
        }
        break;

    case TPC_UpdateConfig:
        if (NTPSERVERHANDLE==hTimeProv) {
            hr=UpdateNtpServer();
            _JumpIfError(hr, error, "UpdateNtpServer");
        } else {
            hr=UpdateNtpClient();
            _JumpIfError(hr, error, "UpdateNtpClient");
        }
        break;

    case TPC_PollIntervalChanged:
        if (NTPCLIENTHANDLE==hTimeProv) {
            hr=HandleNtpClientPollIntervalChange();
            _JumpIfError(hr, error, "HandleNtpClientPollIntervalChange");
        } else {
            // nothing to do
        }
        break;

    case TPC_GetSamples:
        if (NTPSERVERHANDLE==hTimeProv) {
            TpcGetSamplesArgs & args=*(TpcGetSamplesArgs *)pvArgs;
            args.dwSamplesAvailable=0;
            args.dwSamplesReturned=0;
        } else {
            hr=PrepareSamples((TpcGetSamplesArgs *)pvArgs);
            _JumpIfError(hr, error, "PrepareSamples");
        }
        break;

    case TPC_NetTopoChange:
        // We don't want to deal with this more than once,
        // so if both providers are running, only handle it on the NtpClient call
        if (NTPCLIENTHANDLE==hTimeProv
            || (NTPSERVERHANDLE==hTimeProv && false==g_pnpstate->bNtpClientStarted)) {
            hr=HandleNetTopoChange((TpcNetTopoChangeArgs *)pvArgs);
            _JumpIfError(hr, error, "HandleNetTopoChange");
        }
        break;

    case TPC_Query:
        // Same query for client and server:
        hr=HandleNtpProvQuery((W32TIME_PROVIDER_INFO **)pvArgs);
        _JumpIfError(hr, error, "HandleNtpProvQuery");
        break; 

    case TPC_Shutdown:
	// Perform critical cleanup operations -- no need to distinguish between 
	// client and server, because we don't need to be in a good state after call. 
	hr=HandleNtpProvShutdown(); 
	_JumpIfError(hr, error, "HandleNtpProvShutdown"); 
	break; 
	
    default:
        hr=HRESULT_FROM_WIN32(ERROR_BAD_COMMAND);
        FileLog1(FL_NtpProvControlAnnounce, L"  Bad Command: 0x%08X\n", eCmd);
        _JumpError(hr, error, "(command dispatch)");
    }

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT __stdcall
NtpTimeProvClose(IN TimeProvHandle hTimeProv) {
    HRESULT hr;

    const WCHAR * wszProv;
    if (NTPSERVERHANDLE==hTimeProv && g_pnpstate->bNtpServerStarted) {
        wszProv=L"NtpServer";
    } else if (NTPCLIENTHANDLE==hTimeProv && g_pnpstate->bNtpClientStarted) {
        wszProv=L"NtpClient";
    } else {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "(provider handle verification)");
    }
    FileLog1(FL_NtpProvControlAnnounce, L"NtpTimeProvClose([%s]) called.\n", wszProv);

    // stop the appropriate part of the provider
    if (NTPSERVERHANDLE==hTimeProv) {
        hr=StopNtpServer();
        _JumpIfError(hr, error, "StopNtpServer");
    } else {
        hr=StopNtpClient();
        _JumpIfError(hr, error, "StopNtpClient");
    }

    // shut down completely if necessary, so we can be unloaded.
    if (false==g_pnpstate->bNtpServerStarted && false==g_pnpstate->bNtpClientStarted) {
        hr=StopNtpProv();
        _JumpIfError(hr, error, "StopNtpProv");
    }

    hr=S_OK;
error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32time\ntpprov.h ===
//--------------------------------------------------------------------
// NtpProv - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 10-21-99
//
// Various ways of pinging a server
//

#ifndef NTP_PROV_H
#define NTP_PROV_H

HRESULT __stdcall NtpTimeProvOpen(IN WCHAR * wszName, IN TimeProvSysCallbacks * pSysCallbacks, OUT TimeProvHandle * phTimeProv);
HRESULT __stdcall NtpTimeProvCommand(IN TimeProvHandle hTimeProv, IN TimeProvCmd eCmd, IN TimeProvArgs pvArgs);
HRESULT __stdcall NtpTimeProvClose(IN TimeProvHandle hTimeProv);

#endif //NTP_PROV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32time\provdispatch.cpp ===
//--------------------------------------------------------------------
// ProvDispatch - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 9-14-99
//
// interface to providers included in the system
//

#include "pch.h"
#include "ErrToFileLog.h"

//--------------------------------------------------------------------
// structures

typedef HRESULT (__stdcall
    TimeProvOpenFunc)(
        IN WCHAR * wszName,
        IN TimeProvSysCallbacks * pSysCallbacks,  // copy this data, do not free it!
        OUT TimeProvHandle * phTimeProv);

typedef HRESULT (__stdcall
    TimeProvCommandFunc)(
        IN TimeProvHandle hTimeProv,
        IN TimeProvCmd eCmd,
        IN TimeProvArgs pvArgs);

typedef HRESULT (__stdcall
    TimeProvCloseFunc)(
        IN TimeProvHandle hTimeProv);

struct ProviderInfo {
    WCHAR * wszProviderName;
    TimeProvHandle hTimeProv;
    bool bStarted;
    TimeProvOpenFunc * pfnTimeProvOpen;
    TimeProvCommandFunc * pfnTimeProvCommand;
    TimeProvCloseFunc * pfnTimeProvClose;
};

//--------------------------------------------------------------------
// globals

MODULEPRIVATE ProviderInfo g_rgpiDispatchTable[]={
    {
        wszNTPCLIENTPROVIDERNAME,
        NULL,
        false,
        NtpTimeProvOpen,
        NtpTimeProvCommand,
        NtpTimeProvClose
    }, {
        wszNTPSERVERPROVIDERNAME,
        NULL,
        false,
        NtpTimeProvOpen,
        NtpTimeProvCommand,
        NtpTimeProvClose
    }
};

//####################################################################
// module public functions

//--------------------------------------------------------------------
HRESULT __stdcall 
TimeProvOpen(IN WCHAR * wszName, IN TimeProvSysCallbacks * pSysCallbacks, OUT TimeProvHandle * phTimeProv) {
    HRESULT hr;
    unsigned __int3264 nProvIndex;
    bool bProviderFound=false;

    // find the provider in our table
    for (nProvIndex=0; nProvIndex<ARRAYSIZE(g_rgpiDispatchTable); nProvIndex++) {

        // is this the provider they asked for?
        if (0==wcscmp(wszName, g_rgpiDispatchTable[nProvIndex].wszProviderName)) {

            // have we already started it?
            if (true==g_rgpiDispatchTable[nProvIndex].bStarted) {
                hr=HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
                _JumpError(hr, error, "(provider lookup)");
            }

            // start the provider
            hr=g_rgpiDispatchTable[nProvIndex].pfnTimeProvOpen(wszName, pSysCallbacks, &g_rgpiDispatchTable[nProvIndex].hTimeProv);
            _JumpIfError(hr, error, "TimeProvOpen");
            g_rgpiDispatchTable[nProvIndex].bStarted=true;
            bProviderFound=true;
            *phTimeProv=(TimeProvHandle)(nProvIndex+1);
            break;
        }
    }
    if (false==bProviderFound) {
        hr=HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        _JumpError(hr, error, "(provider lookup)");
    }

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT __stdcall 
TimeProvCommand(IN TimeProvHandle hTimeProv, IN TimeProvCmd eCmd, IN TimeProvArgs pvArgs) {
    HRESULT hr;
    unsigned int nProvIndex=((unsigned int)(ULONG_PTR)(hTimeProv))-1;

    if (nProvIndex>=ARRAYSIZE(g_rgpiDispatchTable)) {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "(handle translation)");
    }
    if (false==g_rgpiDispatchTable[nProvIndex].bStarted) {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "(handle translation)");
    }

    hr=g_rgpiDispatchTable[nProvIndex].pfnTimeProvCommand(g_rgpiDispatchTable[nProvIndex].hTimeProv, eCmd, pvArgs);

error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT __stdcall 
TimeProvClose(IN TimeProvHandle hTimeProv) {
    HRESULT hr;

    unsigned int nProvIndex=((unsigned int)(ULONG_PTR)(hTimeProv))-1;

    if (nProvIndex>=ARRAYSIZE(g_rgpiDispatchTable)) {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "(handle translation)");
    }
    if (false==g_rgpiDispatchTable[nProvIndex].bStarted) {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "(handle translation)");
    }

    // pfnTimeProvClose may throw an exception -- mark the started flag as false so we
    // can restart the provider if this occurs (we won't restart providers marked as 
    // already started!)
    g_rgpiDispatchTable[nProvIndex].bStarted=false;
    hr=g_rgpiDispatchTable[nProvIndex].pfnTimeProvClose(g_rgpiDispatchTable[nProvIndex].hTimeProv);
    g_rgpiDispatchTable[nProvIndex].hTimeProv=NULL;

error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32time\timeif_server.c ===
#include <timeif_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32time\pch.h ===
//--------------------------------------------------------------------
// pch - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 2-7-99
//
// Precompiled header for w32time
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <eh.h>
#include <malloc.h>
#include <vector>
#include <algorithm>
#include <exception>
#include <winsock2.h>
#include <svcguid.h>
#include <winsvc.h>
#include <math.h>
#include <wchar.h>
#include <search.h>
#include <dsrole.h>
#include <dsgetdc.h>
#include <ntsecapi.h>
//typedef LONG NTSTATUS;// for netlogp.h, from ntdef.h
#include <lmcons.h>  // for netlogp.h
extern "C" {
#include <netlogp.h> // private\inc
};
#include <lmapibuf.h>
#include <svcs.h>
#include <srvann.h>
#include <lmserver.h>
#include <iphlpapi.h>
#include <userenv.h>
#include <sddl.h>
#include "DebugWPrintf.h"
#include "ErrorHandling.h"
#include "TimeProv.h"
#include "W32TimeMsg.h"
#include "NtpBase.h"
#include "NtpProv.h"
#include "PingLib.h"
#include "Policy.h"
#include "AccurateSysCalls.h"
#include "Logging.h"
#include "MyCritSec.h"
#include "MyTimer.h"
#include "timeif_s.h"
#include "W32TmConsts.h"

using namespace std; 
#include "MyAutoPtr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32time\register.cpp ===
//--------------------------------------------------------------------
// Register - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 11-15-99
//
// Command line utility
//

#include "pch.h" // precompiled headers


//--------------------------------------------------------------------
// forward declarations

struct DwordValueEntries;
struct SzValueEntries;

MODULEPRIVATE HRESULT GetDwordLastClockRate(DWORD * pdwValue, const DwordValueEntries * pdve);
MODULEPRIVATE HRESULT GetDwordMinClockRate(DWORD * pdwValue, const DwordValueEntries * pdve);
MODULEPRIVATE HRESULT GetDwordMaxClockRate(DWORD * pdwValue, const DwordValueEntries * pdve);
MODULEPRIVATE HRESULT GetStringSyncFromFlagsMember(WCHAR ** pwszSyncFromFlags, const SzValueEntries *pszve); 
MODULEPRIVATE HRESULT GetStringSyncFromFlagsStandalone(WCHAR ** pwszSyncFromFlags, const SzValueEntries *pszve); 
MODULEPRIVATE HRESULT GetStringNtpServer(WCHAR ** pwszNtpServer, const SzValueEntries *pszve);  
MODULEPRIVATE HRESULT GetStringDllPath(WCHAR ** pwszLocation, const SzValueEntries *pszve); 

extern "C" void W32TimeVerifyJoinConfig(void);
extern "C" void W32TimeVerifyUnjoinConfig(void); 
extern "C" void W32TimeDcPromo(DWORD dwFlags);

//--------------------------------------------------------------------
// types

typedef HRESULT (fnGetDword)(DWORD * pdwValue, const DwordValueEntries * pdve);
typedef HRESULT (fnGetString)(WCHAR ** pwszValue, const SzValueEntries * pszve);


struct DwordValueEntries {
    WCHAR * wszKey;
    WCHAR * wszName;
    DWORD dwValue;
    fnGetDword * pfnGetDword;
};
struct SzValueEntries {
    WCHAR * wszKey;
    WCHAR * wszName;
    WCHAR * wszValue;
    fnGetString * pfnGetString;
};
struct MultiSzValueEntries {
    WCHAR * wszKey;
    WCHAR * wszName;
    WCHAR * mwszValue;
};

struct RoleSpecificEntries { 
    const DwordValueEntries  *pDwordValues; 
    DWORD                     cDwordValues; 
    const SzValueEntries     *pSzValues; 
    DWORD                     cSzValues; 
};


//--------------------------------------------------------------------
// Role-specific data.
// Current roles differ primarily in the aggressiveness of synchronization. 
// In order of decreasing aggressiveness:
// 
// 1) DCs
// 2) Domain members
// 3) Standalone machines
// 


MODULEPRIVATE const DwordValueEntries gc_rgFirstDCDwordValues[] = { 
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValuePhaseCorrectRate,       7,                 NULL},
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueMinPollInterval,        6,                 NULL},
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueMaxNegPhaseCorrection,  PhaseCorrect_ANY,  NULL},
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueMaxPosPhaseCorrection,  PhaseCorrect_ANY,  NULL},
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueUpdateInterval,         100,               NULL},
    {wszNtpClientRegKeyConfig, wszNtpClientRegValueSpecialPollInterval,  3600,              NULL},
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueAnnounceFlags,          6,                 NULL},
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueMaxAllowedPhaseOffset,    300,               NULL},  // 300s 
};

MODULEPRIVATE const SzValueEntries gc_rgFirstDCSzValues[] = { 
    {wszW32TimeRegKeyParameters, wszW32TimeRegValueType,      W32TM_Type_NT5DS, GetStringSyncFromFlagsMember}, 
};


MODULEPRIVATE const DwordValueEntries gc_rgDCDwordValues[] = { 
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValuePhaseCorrectRate,       7,                 NULL},
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueMinPollInterval,        6,                 NULL},
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueMaxNegPhaseCorrection,    PhaseCorrect_ANY,  NULL},
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueMaxPosPhaseCorrection,  PhaseCorrect_ANY,  NULL},
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueUpdateInterval,         100,               NULL},
    {wszNtpClientRegKeyConfig, wszNtpClientRegValueSpecialPollInterval,  3600,              NULL},
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueAnnounceFlags,          10,                NULL},
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueMaxAllowedPhaseOffset,    300,               NULL},  // 300s 
};

MODULEPRIVATE const SzValueEntries gc_rgDCSzValues[] = { 
    {wszW32TimeRegKeyParameters, wszW32TimeRegValueType,      W32TM_Type_NT5DS, GetStringSyncFromFlagsMember}, 
};

MODULEPRIVATE const DwordValueEntries gc_rgMBRDwordValues[] = { 
    {wszW32TimeRegKeyConfig,    wszW32TimeRegValuePhaseCorrectRate,      1,                 NULL},
    {wszW32TimeRegKeyConfig,    wszW32TimeRegValueMinPollInterval,       10,                NULL},
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueMaxNegPhaseCorrection,    PhaseCorrect_ANY,  NULL},
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueMaxPosPhaseCorrection,  PhaseCorrect_ANY,  NULL},
    {wszW32TimeRegKeyConfig,    wszW32TimeRegValueUpdateInterval,        30000,             NULL},
    {wszNtpClientRegKeyConfig,  wszNtpClientRegValueSpecialPollInterval, 3600,              NULL},
    {wszW32TimeRegKeyConfig,    wszW32TimeRegValueAnnounceFlags,         10,                NULL},
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueMaxAllowedPhaseOffset,    300,               NULL},  // 300s 
};

MODULEPRIVATE const SzValueEntries gc_rgMBRSzValues[] = { 
    {wszW32TimeRegKeyParameters, wszW32TimeRegValueType,      W32TM_Type_NT5DS, GetStringSyncFromFlagsMember}, 
};

MODULEPRIVATE const DwordValueEntries gc_rgStandaloneDwordValues[] = { 
    {wszW32TimeRegKeyConfig,    wszW32TimeRegValuePhaseCorrectRate,       1,       NULL},
    {wszW32TimeRegKeyConfig,    wszW32TimeRegValueMinPollInterval,        10,      NULL},
    {wszW32TimeRegKeyConfig,    wszW32TimeRegValueUpdateInterval,         360000,  NULL},
    {wszW32TimeRegKeyConfig,    wszW32TimeRegValueMaxNegPhaseCorrection,  54000,   NULL},
    {wszW32TimeRegKeyConfig,    wszW32TimeRegValueMaxPosPhaseCorrection,  54000,   NULL},
    {wszNtpClientRegKeyConfig,  wszNtpClientRegValueSpecialPollInterval,  604800,  NULL},
    {wszW32TimeRegKeyConfig,    wszW32TimeRegValueAnnounceFlags,          10,      NULL},
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueMaxAllowedPhaseOffset,     1,       NULL},  // 1s 
};

MODULEPRIVATE const SzValueEntries gc_rgStandaloneSzValues[] = { 
    {wszW32TimeRegKeyParameters, wszW32TimeRegValueNtpServer, W32TM_NtpServer_Default,  GetStringNtpServer}, 
    {wszW32TimeRegKeyParameters, wszW32TimeRegValueType,      W32TM_Type_NTP,           GetStringSyncFromFlagsStandalone}, 
};

enum RoleType { 
    e_FirstDC = 0, 
    e_DC, 
    e_MBR_Server, 
    e_Standalone
}; 

MODULEPRIVATE const RoleSpecificEntries gc_RoleSpecificEntries[] = { 
    { &gc_rgFirstDCDwordValues[0],     8,  &gc_rgFirstDCSzValues[0],     1  }, 
    { &gc_rgDCDwordValues[0],          8,  &gc_rgDCSzValues[0],          1  }, 
    { &gc_rgMBRDwordValues[0],         8,  &gc_rgMBRSzValues[0],         1  }, 
    { &gc_rgStandaloneDwordValues[0],  8,  &gc_rgStandaloneSzValues[0],  2  } 
};

//--------------------------------------------------------------------
// Role-independent data

MODULEPRIVATE const WCHAR * gc_rgwszKeyNames[]={
    wszW32TimeRegKeyEventlog,
    wszW32TimeRegKeyRoot,
    wszW32TimeRegKeyTimeProviders,
    wszNtpClientRegKeyConfig,
    wszNtpServerRegKeyConfig,
    wszW32TimeRegKeyConfig,
    wszW32TimeRegKeyParameters
};

MODULEPRIVATE const DwordValueEntries gc_rgDwordValues[]={
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueLastClockRate,        100144, GetDwordLastClockRate}, 
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueMinClockRate,         100000, GetDwordMinClockRate},
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueMaxClockRate,         100288, GetDwordMaxClockRate},
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueFrequencyCorrectRate,      4, NULL},
    {wszW32TimeRegKeyConfig, wszW32TimeRegValuePollAdjustFactor,          5, NULL},
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueLargePhaseOffset,    1280000, NULL},
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueSpikeWatchPeriod,         90, NULL},
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueHoldPeriod,                5, NULL},
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueMaxPollInterval,          15, NULL}, // be careful changing this; 15 is max. see spec.
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueLocalClockDispersion,     10, NULL},
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueEventLogFlags,             2, NULL},
    {wszW32TimeRegKeyEventlog, L"TypesSupported",                         7, NULL}, 

    {wszNtpClientRegKeyConfig, wszW32TimeRegValueEnabled,                            1, NULL},
    {wszNtpClientRegKeyConfig, wszW32TimeRegValueInputProvider,                      1, NULL},
    {wszNtpClientRegKeyConfig, wszNtpClientRegValueAllowNonstandardModeCombinations, 1, NULL},
    {wszNtpClientRegKeyConfig, wszNtpClientRegValueCrossSiteSyncFlags,               2, NULL},
    {wszNtpClientRegKeyConfig, wszNtpClientRegValueResolvePeerBackoffMinutes,       15, NULL},
    {wszNtpClientRegKeyConfig, wszNtpClientRegValueResolvePeerBackoffMaxTimes,       7, NULL},
    {wszNtpClientRegKeyConfig, wszNtpClientRegValueCompatibilityFlags,      0x80000000, NULL}, 
    {wszNtpClientRegKeyConfig, wszNtpClientRegValueEventLogFlags,                    0, NULL},

    {wszNtpServerRegKeyConfig, wszW32TimeRegValueEnabled,                            1, NULL}, 
    {wszNtpServerRegKeyConfig, wszW32TimeRegValueInputProvider,                      0, NULL},
    {wszNtpServerRegKeyConfig, wszNtpServerRegValueAllowNonstandardModeCombinations, 1, NULL}, 
};

MODULEPRIVATE const SzValueEntries gc_rgSzValues[]={
    {wszNtpClientRegKeyConfig,   wszW32TimeRegValueDllName,   wszDLLNAME,               GetStringDllPath},
    {wszNtpServerRegKeyConfig,   wszW32TimeRegValueDllName,   wszDLLNAME,               GetStringDllPath},
    {wszW32TimeRegKeyParameters, L"ServiceMain",              L"SvchostEntry_W32Time",  NULL}, 
};

MODULEPRIVATE const SzValueEntries gc_rgExpSzValues[]={
    {wszW32TimeRegKeyEventlog,   L"EventMessageFile",          wszDLLNAME, GetStringDllPath}, 
    {wszW32TimeRegKeyParameters, wszW32TimeRegValueServiceDll, wszDLLNAME, GetStringDllPath}, 
};

MODULEPRIVATE const MultiSzValueEntries gc_rgMultiSzValues[]= { 
    {wszNtpClientRegKeyConfig, wszNtpClientRegValueSpecialPollTimeRemaining, L"\0"}, 
};

//####################################################################
// module private

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetDwordLastClockRate(DWORD * pdwValue, const DwordValueEntries * pdve) {
    HRESULT hr;
    
    DWORD dwCurrentSecPerTick;
    DWORD dwDefaultSecPerTick;
    BOOL bSyncToCmosDisabled;
    if (!GetSystemTimeAdjustment(&dwCurrentSecPerTick, &dwDefaultSecPerTick, &bSyncToCmosDisabled)) {
        _JumpLastError(hr, error, "GetSystemTimeAdjustment");
    }

    *pdwValue=dwDefaultSecPerTick;

    hr=S_OK;
error:
    return hr;
}


//--------------------------------------------------------------------
MODULEPRIVATE BOOL HasNewPeerlist() {
    bool   fResult = false; 
    DWORD  dwRetval; 
    DWORD  dwSize; 
    DWORD  dwType; 
    HKEY   hkParameters = NULL; 
    LPWSTR wszSyncFromFlags = NULL; 
    WCHAR  wszValue[MAX_PATH]; 

    dwRetval = RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyParameters, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkParameters);
    if (ERROR_SUCCESS == dwRetval) {
        dwRetval = RegQueryValueEx(hkParameters, wszW32TimeRegValueNtpServer, NULL, &dwType, (BYTE *)&wszValue[0], &dwSize);
	if (ERROR_SUCCESS == dwRetval) { 
	    fResult = 0 != _wcsicmp(W32TM_NtpServer_Default, wszValue); 
	}
    }

    if (NULL != hkParameters) { 
	RegCloseKey(hkParameters);
    }
    return fResult; 
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetDwordMinClockRate(DWORD * pdwValue, const DwordValueEntries * pdve) {
    HRESULT hr;
    
    DWORD dwCurrentSecPerTick;
    DWORD dwDefaultSecPerTick;
    BOOL bSyncToCmosDisabled;
    if (!GetSystemTimeAdjustment(&dwCurrentSecPerTick, &dwDefaultSecPerTick, &bSyncToCmosDisabled)) {
        _JumpLastError(hr, error, "GetSystemTimeAdjustment");
    }

    *pdwValue=dwDefaultSecPerTick-(dwDefaultSecPerTick/400); // 1/4%

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetDwordMaxClockRate(DWORD * pdwValue, const DwordValueEntries * pdve) {
    HRESULT hr;
    
    DWORD dwCurrentSecPerTick;
    DWORD dwDefaultSecPerTick;
    BOOL bSyncToCmosDisabled;
    if (!GetSystemTimeAdjustment(&dwCurrentSecPerTick, &dwDefaultSecPerTick, &bSyncToCmosDisabled)) {
        _JumpLastError(hr, error, "GetSystemTimeAdjustment");
    }

    *pdwValue=dwDefaultSecPerTick+(dwDefaultSecPerTick/400); // 1/4%

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetStringSyncFromFlags(WCHAR ** pwszSyncFromFlags, const SzValueEntries * pszve, RoleType eRole) {
    HRESULT hr;
    DWORD dwRetval;
    DWORD dwSize;
    DWORD dwType;
    WCHAR wszValue[MAX_PATH]; 

    // must be cleaned up
    HKEY hkW32Time  = NULL;
    HKEY hkParameters     = NULL;

    // First, check for the existence of configuration information:
    dwRetval = RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyParameters, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkParameters);
    if (ERROR_SUCCESS == dwRetval) {
        dwRetval = RegQueryValueEx(hkParameters, wszW32TimeRegValueType, NULL, &dwType, (BYTE *)&wszValue[0], &dwSize);
    }

    if (ERROR_SUCCESS == dwRetval) {
        // We have pre-existing config info.  See whether or not we want to preserve it, 
	// or write our own configuration out. 
	LPWSTR wszNewSyncFromFlags; 

	if (0 == _wcsicmp(wszValue, W32TM_Type_NoSync) || (e_Standalone != eRole && HasNewPeerlist())) { 
	    // We always preserve the NoSync setting, and we want to preserve the this setting for 
	    // non-standalone machines with new peerlists. 
	    wszNewSyncFromFlags = wszValue; 
	} else { 
	    // We're a standalone machine OR we've kept the default peerlist, do NOT preserve the value. 
	    // Instead, use the default for this role. 
	    wszNewSyncFromFlags = pszve->wszValue; 
	}
	
	// Assign the OUT param: 
	*pwszSyncFromFlags = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (wcslen(wszNewSyncFromFlags) + 1)); 
	_JumpIfOutOfMemory(hr, error, *pwszSyncFromFlags); 
	wcscpy(*pwszSyncFromFlags, wszNewSyncFromFlags); 
    }
    else { 
        // No pre-existing configuration info.  Try to use our "special" reg value. 
        dwRetval=RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyRoot, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkW32Time);
        if (ERROR_SUCCESS!=dwRetval) {
            hr=HRESULT_FROM_WIN32(dwRetval);
            _JumpErrorStr(hr, error, "RegOpenKeyEx", wszW32TimeRegKeyRoot);
        }

        // get the value;
        dwSize=sizeof(wszValue);
        dwRetval=RegQueryValueEx(hkW32Time, wszW32TimeRegValueSpecialType, NULL, &dwType, (BYTE *)&wszValue[0], &dwSize);
        if (ERROR_SUCCESS==dwRetval) {
            _Verify(REG_SZ==dwType, hr, error);

            // success
            // note that we will use this value even if the delete step fails.
            *pwszSyncFromFlags = (LPWSTR)LocalAlloc(LPTR, dwSize); 
            _JumpIfOutOfMemory(hr, error, *pwszSyncFromFlags); 
            wcscpy(*pwszSyncFromFlags, &wszValue[0]); 

            // delete the key so we don't use it again
            dwRetval=RegDeleteValue(hkW32Time, wszW32TimeRegValueSpecialType);
            if (ERROR_SUCCESS!=dwRetval) {
                hr=HRESULT_FROM_WIN32(dwRetval);
                _JumpErrorStr(hr, error, "RegDeleteValue", wszW32TimeRegValueSpecialType);
            }

        } else if (ERROR_FILE_NOT_FOUND==dwRetval) {
            // doesn't exist - don't worry about it
            *pwszSyncFromFlags = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (wcslen(pszve->wszValue) + 1)); 
            _JumpIfOutOfMemory(hr, error, *pwszSyncFromFlags); 
            wcscpy(*pwszSyncFromFlags, pszve->wszValue); 
        } else {
            // other error
            hr=HRESULT_FROM_WIN32(dwRetval);
            _JumpErrorStr(hr, error, "RegQueryValueEx", wszW32TimeRegValueSpecialType);
        }
    }

    hr = S_OK;
error:
    if (NULL != hkW32Time)     { RegCloseKey(hkW32Time); }
    if (NULL != hkParameters)  { RegCloseKey(hkParameters); }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetStringSyncFromFlagsStandalone(WCHAR ** pwszSyncFromFlags, const SzValueEntries * pszve) {
    return GetStringSyncFromFlags(pwszSyncFromFlags, pszve, e_Standalone); 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetStringSyncFromFlagsMember(WCHAR ** pwszSyncFromFlags, const SzValueEntries * pszve) {
    return GetStringSyncFromFlags(pwszSyncFromFlags, pszve, e_MBR_Server); 
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetStringNtpServer(WCHAR ** pwszNtpServer, const SzValueEntries * pszve) {
    HRESULT hr;
    DWORD dwRetval;
    DWORD dwSize;
    DWORD dwType;
    LPWSTR pwszTemp = NULL; 

    // must be cleaned up
    HKEY   hkParameters  = NULL;
    LPWSTR pwszValue     = NULL;

    // First, check for the existence of configuration information:
    dwRetval = RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyParameters, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkParameters);
    if (ERROR_SUCCESS == dwRetval) {
        // query the size of the buffer we need: 
        dwSize = 0; 
        dwRetval = RegQueryValueEx(hkParameters, wszW32TimeRegValueNtpServer, NULL, &dwType, NULL, &dwSize);
    }

    if (ERROR_SUCCESS == dwRetval) {
        // We've got pre-existing config info.
        
        // Allocate a buffer to hold both the current peer list, and the default peer (if we have one)
        dwSize += NULL != pszve->wszValue ? (1+wcslen(pszve->wszValue)) : 0; 
        pwszValue = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (dwSize + 1)); 
        _JumpIfOutOfMemory(hr, error, pwszValue); 

        // Get the current peer list
        dwRetval = RegQueryValueEx(hkParameters, wszW32TimeRegValueNtpServer, NULL, &dwType, (BYTE *)pwszValue, &dwSize);
        if (ERROR_SUCCESS != dwRetval) { 
            hr = HRESULT_FROM_WIN32(dwRetval); 
            _JumpError(hr, error, "RegQueryValueEx"); 
        }

        if (L'\0' != pszve->wszValue[0]) { 
            // We have a default value to append to our peerlist
            
            // Strip off the peer flags.  It is the NAME of the peer that we use
            // to determine if this peer is already in the peer list.  The flags
            // should not be used as part of this comparison. 
            pwszTemp = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(pszve->wszValue) + 1)); 
            _JumpIfOutOfMemory(hr, error, pwszTemp); 

            wcscpy(pwszTemp, pszve->wszValue); 
            LPWSTR pwszComma = wcschr(pwszTemp, L','); 
            if (NULL != pwszComma) { 
                *pwszComma = L'\0'; 
            }

            if (NULL == wcsstr(pwszValue /*NtpServer list from registry*/, pwszTemp /*Default peer, without peer flags*/)) { 
                // The NtpServer list in the registry did not contain the default peer.  Add it to the list. 
                if (L'\0' != pwszValue[0]) { 
                    // The list is space-delimited, and this is not the first peer in the list. 
                    // Add a space delimiter. 
                    wcscat(pwszValue, L" "); 
                } 
                wcscat(pwszValue, pszve->wszValue); 
            } 
        }
    }
    else { 
        // No pre-existing configuration info: set to the default. 
        pwszValue = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (wcslen(pszve->wszValue) + 1)); 
        _JumpIfOutOfMemory(hr, error, pwszValue); 
        wcscpy(pwszValue, pszve->wszValue); 
    }

    // Assign the OUT param: 
    *pwszNtpServer = pwszValue; 
    pwszValue = NULL; 
    hr = S_OK;
error:
    if (NULL != hkParameters)  { RegCloseKey(hkParameters); }
    if (NULL != pwszValue)     { LocalFree(pwszValue); }
    if (NULL != pwszTemp)      { LocalFree(pwszTemp); } 
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetStringDllPath(WCHAR ** pwszLocation, const SzValueEntries * pszve) {
    HRESULT hr;
    HMODULE hmThisDll;
    WCHAR wszName[MAX_PATH];
    DWORD dwLen;

    // initialize out params
    *pwszLocation=NULL;

    // first, get the handle to our dll
    hmThisDll=GetModuleHandle(wszDLLNAME);
    if (NULL==hmThisDll) {
        _JumpLastError(hr, error, "GetModuleHandle");
    }

    // find our dll's path
    dwLen=GetModuleFileName(hmThisDll, wszName, ARRAYSIZE(wszName));
    if (0==dwLen) {
        _JumpLastError(hr, error, "GetModuleFileName");
    }
    _Verify(ARRAYSIZE(wszName)!=dwLen, hr, error);

    // make a copy to return to the caller
    *pwszLocation=(WCHAR *)LocalAlloc(LPTR, (dwLen+1)*sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, *pwszLocation);
    wcscpy(*pwszLocation, wszName);

    hr=S_OK;
error:
    return hr;
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT CreateRoleSpecificRegValues(RoleType role) {
    const DwordValueEntries  *pdve; 
    const SzValueEntries     *pszve; 
    HRESULT                   hr       = S_OK; 
    unsigned int              nIndex;

    // create all role-specific DWORDS
    pdve = gc_RoleSpecificEntries[role].pDwordValues; 
    for (nIndex=0; nIndex<gc_RoleSpecificEntries[role].cDwordValues; nIndex++) {
        HKEY     hkKey;
        DWORD    dwValue = pdve[nIndex].dwValue;
        HRESULT  hr2     = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pdve[nIndex].wszKey, NULL, KEY_SET_VALUE, &hkKey);
        hr2 = HRESULT_FROM_WIN32(hr2);
        if (FAILED(hr2)) {
            DebugWPrintf1(L"OpenKey failed(0x%08X)", hr2);
            if (S_OK==hr) {
                hr=hr2;
            }
        } else {
            if (NULL!=pdve[nIndex].pfnGetDword) {
                hr2=pdve[nIndex].pfnGetDword(&dwValue, &pdve[nIndex]);
                if (FAILED(hr2)) {
                    DebugWPrintf1(L"fnGetDwordXxx failed (0x%08X), using default. ", hr2);
                    if (S_OK==hr) {
                        hr=hr2;
                    }
                    // default value from array will be used
                }
            }
            hr2=RegSetValueEx(hkKey, pdve[nIndex].wszName, NULL, REG_DWORD, (BYTE *)&dwValue, sizeof(DWORD));
            hr2=HRESULT_FROM_WIN32(hr2);
            RegCloseKey(hkKey);
            if (FAILED(hr2)) {
                DebugWPrintf1(L"SetValue failed(0x%08X)", hr2);
                if (S_OK==hr) {
                    hr=hr2;
                }
            } else {
                DebugWPrintf0(L"Value set");
            }
        }
        DebugWPrintf3(L": HKLM\\%s\\%s=(REG_DWORD)0x%08X\n", pdve[nIndex].wszKey, pdve[nIndex].wszName, dwValue);
    }

    // create all role-specific SZs 
    pszve = gc_RoleSpecificEntries[role].pSzValues; 
    for (nIndex=0; nIndex<gc_RoleSpecificEntries[role].cSzValues; nIndex++) {
        HRESULT   hr2;
        HKEY      hkKey;
        WCHAR    *wszValue = pszve[nIndex].wszValue;

        // must be cleaned up
        WCHAR * wszFnValue=NULL;

        hr2=RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszve[nIndex].wszKey, NULL, KEY_SET_VALUE, &hkKey);
        hr2=HRESULT_FROM_WIN32(hr2);
        if (FAILED(hr2)) {
            DebugWPrintf1(L"OpenKey failed(0x%08X)", hr2);
            if (S_OK==hr) {
                hr=hr2;
            }
        } else {

            if (NULL!=pszve[nIndex].pfnGetString) {
                hr2=pszve[nIndex].pfnGetString(&wszFnValue, &pszve[nIndex]);
                if (FAILED(hr2)) {
                    DebugWPrintf1(L"fnGetStringXxx failed (0x%08X), using default. ", hr2);
                    if (S_OK==hr) {
                        hr=hr2;
                    }
                    // default value from array will be used
                } else {
                    wszValue=wszFnValue;
                }
            }

            DWORD dwSize=sizeof(WCHAR)*(wcslen(wszValue)+1);
            hr2=RegSetValueEx(hkKey, pszve[nIndex].wszName, NULL, REG_SZ, (BYTE *)wszValue, dwSize);
            hr2=HRESULT_FROM_WIN32(hr2);
            RegCloseKey(hkKey);
            if (FAILED(hr2)) {
                DebugWPrintf1(L"SetValue failed(0x%08X)", hr2);
                if (S_OK==hr) {
                    hr=hr2;
                }
            } else {
                DebugWPrintf0(L"Value set");
            }
        }
        DebugWPrintf3(L": HKLM\\%s\\%s=(REG_SZ)'%s'\n", pszve[nIndex].wszKey, pszve[nIndex].wszName, wszValue);

        if (NULL!=wszFnValue) {
            LocalFree(wszFnValue);
        }
    }

    // hr = S_OK; 
    // error: 
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT CreateRegValues(void) {
    HRESULT hr=S_OK;
    unsigned int nIndex;
    DWORD dwDisposition;

    // create all interesting keys
    for (nIndex=0; nIndex<ARRAYSIZE(gc_rgwszKeyNames); nIndex++) {
        HKEY hkNew;
        HRESULT hr2=RegCreateKeyEx(HKEY_LOCAL_MACHINE, gc_rgwszKeyNames[nIndex], NULL, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkNew, &dwDisposition);
        hr2=HRESULT_FROM_WIN32(hr2);
        if (FAILED(hr2)) {
            DebugWPrintf1(L"Create failed (0x%08X)", hr2);
            if (S_OK==hr) {
                hr=hr2;
            }
        } else {
            RegCloseKey(hkNew);
            if (REG_CREATED_NEW_KEY==dwDisposition) {
                DebugWPrintf0(L"Created");
            } else  {
                DebugWPrintf0(L"Exists");
            }
        }
        DebugWPrintf1(L": HKLM\\%s\n", gc_rgwszKeyNames[nIndex]);
    }

    // create all DWORDS
    for (nIndex=0; nIndex<ARRAYSIZE(gc_rgDwordValues); nIndex++) {
        HKEY hkKey;
        DWORD dwValue=gc_rgDwordValues[nIndex].dwValue;
        HRESULT hr2=RegOpenKeyEx(HKEY_LOCAL_MACHINE, gc_rgDwordValues[nIndex].wszKey, NULL, KEY_SET_VALUE, &hkKey);
        hr2=HRESULT_FROM_WIN32(hr2);
        if (FAILED(hr2)) {
            DebugWPrintf1(L"OpenKey failed(0x%08X)", hr2);
            if (S_OK==hr) {
                hr=hr2;
            }
        } else {
            if (NULL!=gc_rgDwordValues[nIndex].pfnGetDword) {
                hr2=gc_rgDwordValues[nIndex].pfnGetDword(&dwValue, &gc_rgDwordValues[nIndex]);
                if (FAILED(hr2)) {
                    DebugWPrintf1(L"fnGetDwordXxx failed (0x%08X), using default. ", hr2);
                    if (S_OK==hr) {
                        hr=hr2;
                    }
                    // default value from array will be used
                }
            }
            hr2=RegSetValueEx(hkKey, gc_rgDwordValues[nIndex].wszName, NULL, REG_DWORD, (BYTE *)&dwValue, sizeof(DWORD));
            hr2=HRESULT_FROM_WIN32(hr2);
            RegCloseKey(hkKey);
            if (FAILED(hr2)) {
                DebugWPrintf1(L"SetValue failed(0x%08X)", hr2);
                if (S_OK==hr) {
                    hr=hr2;
                }
            } else {
                DebugWPrintf0(L"Value set");
            }
        }
        DebugWPrintf3(L": HKLM\\%s\\%s=(REG_DWORD)0x%08X\n", gc_rgDwordValues[nIndex].wszKey, gc_rgDwordValues[nIndex].wszName, dwValue);
    }

    // create all Sz's
    for (nIndex=0; nIndex<ARRAYSIZE(gc_rgSzValues); nIndex++) {
        HRESULT hr2;
        HKEY hkKey;
        WCHAR * wszValue=gc_rgSzValues[nIndex].wszValue;

        // must be cleaned up
        WCHAR * wszFnValue=NULL;

        hr2=RegOpenKeyEx(HKEY_LOCAL_MACHINE, gc_rgSzValues[nIndex].wszKey, NULL, KEY_SET_VALUE, &hkKey);
        hr2=HRESULT_FROM_WIN32(hr2);
        if (FAILED(hr2)) {
            DebugWPrintf1(L"OpenKey failed(0x%08X)", hr2);
            if (S_OK==hr) {
                hr=hr2;
            }
        } else {

            if (NULL!=gc_rgSzValues[nIndex].pfnGetString) {
                hr2=gc_rgSzValues[nIndex].pfnGetString(&wszFnValue, &gc_rgSzValues[nIndex]);
                if (FAILED(hr2)) {
                    DebugWPrintf1(L"fnGetStringXxx failed (0x%08X), using default. ", hr2);
                    if (S_OK==hr) {
                        hr=hr2;
                    }
                    // default value from array will be used
                } else {
                    wszValue=wszFnValue;
                }
            }

            DWORD dwSize=sizeof(WCHAR)*(wcslen(wszValue)+1);
            hr2=RegSetValueEx(hkKey, gc_rgSzValues[nIndex].wszName, NULL, REG_SZ, (BYTE *)wszValue, dwSize);
            hr2=HRESULT_FROM_WIN32(hr2);
            RegCloseKey(hkKey);
            if (FAILED(hr2)) {
                DebugWPrintf1(L"SetValue failed(0x%08X)", hr2);
                if (S_OK==hr) {
                    hr=hr2;
                }
            } else {
                DebugWPrintf0(L"Value set");
            }
        }
        DebugWPrintf3(L": HKLM\\%s\\%s=(REG_SZ)'%s'\n", gc_rgSzValues[nIndex].wszKey, gc_rgSzValues[nIndex].wszName, wszValue);

        if (NULL!=wszFnValue) {
            LocalFree(wszFnValue);
        }
    }

    // create all ExpSz's
    for (nIndex=0; nIndex<ARRAYSIZE(gc_rgExpSzValues); nIndex++) {
        HRESULT hr2;
        HKEY hkKey;
        WCHAR * wszValue=gc_rgExpSzValues[nIndex].wszValue;

        // must be cleaned up
        WCHAR * wszFnValue=NULL;

        hr2=RegOpenKeyEx(HKEY_LOCAL_MACHINE, gc_rgExpSzValues[nIndex].wszKey, NULL, KEY_SET_VALUE, &hkKey);
        hr2=HRESULT_FROM_WIN32(hr2);
        if (FAILED(hr2)) {
            DebugWPrintf1(L"OpenKey failed(0x%08X)", hr2);
            if (S_OK==hr) {
                hr=hr2;
            }
        } else {

            if (NULL!=gc_rgExpSzValues[nIndex].pfnGetString) {
                hr2=gc_rgExpSzValues[nIndex].pfnGetString(&wszFnValue, &gc_rgExpSzValues[nIndex]);
                if (FAILED(hr2)) {
                    DebugWPrintf1(L"fnGetStringXxx failed (0x%08X), using default. ", hr2);
                    if (S_OK==hr) {
                        hr=hr2;
                    }
                    // default value from array will be used
                } else {
                    wszValue=wszFnValue;
                }
            }

            DWORD dwSize=sizeof(WCHAR)*(wcslen(wszValue)+1);
            hr2=RegSetValueEx(hkKey, gc_rgExpSzValues[nIndex].wszName, NULL, REG_EXPAND_SZ, (BYTE *)wszValue, dwSize);
            hr2=HRESULT_FROM_WIN32(hr2);
            RegCloseKey(hkKey);
            if (FAILED(hr2)) {
                DebugWPrintf1(L"SetValue failed(0x%08X)", hr2);
                if (S_OK==hr) {
                    hr=hr2;
                }
            } else {
                DebugWPrintf0(L"Value set");
            }
        }
        DebugWPrintf3(L": HKLM\\%s\\%s=(REG_EXPAND_SZ)'%s'\n", gc_rgExpSzValues[nIndex].wszKey, gc_rgExpSzValues[nIndex].wszName, wszValue);

        if (NULL!=wszFnValue) {
            LocalFree(wszFnValue);
        }
    }

    // create all MultiSz's
    for (nIndex=0; nIndex<ARRAYSIZE(gc_rgMultiSzValues); nIndex++) {
        HKEY hkKey;
        HRESULT hr2=RegOpenKeyEx(HKEY_LOCAL_MACHINE, gc_rgMultiSzValues[nIndex].wszKey, NULL, KEY_SET_VALUE, &hkKey);
        hr2=HRESULT_FROM_WIN32(hr2);
        if (FAILED(hr2)) {
            DebugWPrintf1(L"OpenKey failed(0x%08X)", hr2);
            if (S_OK==hr) {
                hr=hr2;
            }
        } else {
            DWORD dwSize=0;
            WCHAR * wszTravel=gc_rgMultiSzValues[nIndex].mwszValue;
            while (L'\0'!=wszTravel[0]) {
                unsigned int nSize=wcslen(wszTravel)+1;
                dwSize+=nSize;
                wszTravel+=nSize;
            };
            dwSize++;
            dwSize*=sizeof(WCHAR);

            hr2=RegSetValueEx(hkKey, gc_rgMultiSzValues[nIndex].wszName, NULL, REG_MULTI_SZ, (BYTE *)gc_rgMultiSzValues[nIndex].mwszValue, dwSize);
            hr2=HRESULT_FROM_WIN32(hr2);
            RegCloseKey(hkKey);
            if (FAILED(hr2)) {
                DebugWPrintf1(L"SetValue failed(0x%08X)", hr2);
                if (S_OK==hr) {
                    hr=hr2;
                }
            } else {
                DebugWPrintf0(L"Value set");
            }
        }
        DebugWPrintf2(L": HKLM\\%s\\%s=(REG_MULTI_SZ)", gc_rgMultiSzValues[nIndex].wszKey, gc_rgMultiSzValues[nIndex].wszName);
        WCHAR * wszTravel=gc_rgMultiSzValues[nIndex].mwszValue;
        while (L'\0'!=wszTravel[0]) {
            if (wszTravel!=gc_rgMultiSzValues[nIndex].mwszValue) {
                DebugWPrintf0(L",");
            }
            DebugWPrintf1(L"'%s'", wszTravel);
            wszTravel+=wcslen(wszTravel)+1;
        };
        DebugWPrintf1(L"\n", wszTravel);
    }

    //hr=S_OK;
//error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT RegisterService(void) {
    HRESULT hr;
    DWORD dwLen;
    DWORD dwResult; 
    HANDLE  hW32Time;
    WCHAR * pchLastSlash;

    // must be cleaned up
    SC_HANDLE hSCManager=NULL;
    SC_HANDLE hNewService=NULL;
    WCHAR * wszDllPath=NULL;
    WCHAR * wszServiceCommand=NULL;
    WCHAR * wszServiceDescription=NULL; 

    // open communications with the service control manager
    hSCManager=OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
    if (NULL==hSCManager) {
        _JumpLastError(hr, error, "OpenSCManager");
    }
    
    // determine the command line for the service

    // get the location of the dll
    //hr=GetStringDllPath(&wszDllPath);
    //_JumpIfError(hr, error, "GetStringDllPath");
    //pchLastSlash=wcsrchr(wszDllPath, L'\\');
    //_Verify(NULL!=pchLastSlash, hr, error);
    //pchLastSlash[1]=L'\0';

    // build the service command line
    //dwLen=wcslen(wszDllPath)+wcslen(wszSERVICECOMMAND)+1;
    //wszServiceCommand=(WCHAR *)LocalAlloc(LPTR, dwLen*sizeof(WCHAR));
    //_JumpIfOutOfMemory(hr, error, wszServiceCommand);
    //wcscpy(wszServiceCommand, wszDllPath);
    //wcscat(wszServiceCommand, wszSERVICECOMMAND);

    // create the service
    hNewService=CreateService(hSCManager, wszSERVICENAME, wszSERVICEDISPLAYNAME, GENERIC_WRITE,
        SERVICE_WIN32_SHARE_PROCESS, SERVICE_AUTO_START,
        SERVICE_ERROR_NORMAL, wszSERVICECOMMAND, NULL, NULL, NULL, wszSERVICEACCOUNTNAME, NULL);
    if (NULL==hNewService) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        if (HRESULT_FROM_WIN32(ERROR_SERVICE_EXISTS)==hr) {
            DebugWPrintf0(L"Service already exists.\n");
            hNewService=OpenService(hSCManager, wszSERVICENAME, SERVICE_CHANGE_CONFIG); 
            if (NULL==hNewService) { 
                _JumpLastError(hr, error, "OpenService"); 
            }
        } else {
            _JumpError(hr, error, "CreateService");
        }
    } else { 
        DebugWPrintf0(L"Service created.\n");
    }

    {
        SERVICE_DESCRIPTION svcdesc;

	// Load a localized service description to create the service with
	hW32Time = GetModuleHandle(L"w32time.dll"); 
	if (NULL == hW32Time) { 
	    _JumpLastError(hr, error, "GetModuleHandle"); 
	}
	
	if (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE, hW32Time, W32TIMEMSG_SERVICE_DESCRIPTION, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPWSTR)&wszServiceDescription, 0, NULL)) { 
	    _JumpLastError(hr, error, "FormatMessage"); 
	}

        svcdesc.lpDescription=wszServiceDescription;
        if (!ChangeServiceConfig2(hNewService, SERVICE_CONFIG_DESCRIPTION, &svcdesc)) {
            _JumpLastError(hr, error, "ChangeServiceConfig2");
        }

        // Set the service to auto-start
        if (!ChangeServiceConfig(hNewService, SERVICE_NO_CHANGE, SERVICE_AUTO_START, SERVICE_NO_CHANGE, NULL, NULL, NULL, NULL, NULL, NULL, NULL)) { 
            _JumpLastError(hr, error, "ChangeServiceConfig");
        }
    }


    hr=S_OK;
error:
    if (NULL!=hNewService) {
        CloseServiceHandle(hNewService);
    }
    if (NULL!=hSCManager) {
        CloseServiceHandle(hSCManager);
    }
    if (NULL!=wszDllPath) {
        LocalFree(wszDllPath);
    }
    if (NULL!=wszServiceCommand) {
        LocalFree(wszServiceCommand);
    }
    if (NULL!=wszServiceDescription) { 
	LocalFree(wszServiceDescription); 
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT UnregisterService(void) {
    HRESULT hr;

    // must be cleaned up
    SC_HANDLE hSCManager=NULL;
    SC_HANDLE hTimeService=NULL;

    // open communications with the service control manager
    hSCManager=OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
    if (NULL==hSCManager) {
        _JumpLastError(hr, error, "OpenSCManager");
    }

    // identify the service we are working on
    hTimeService=OpenService(hSCManager, wszSERVICENAME, DELETE);
    if (NULL==hTimeService) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        if (HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST)==hr) {
            DebugWPrintf0(L"Service does not exist.\n");
        } else {
            _JumpError(hr, error, "OpenService");
        }

    // delete it
    } else if (!DeleteService(hTimeService)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        if (HRESULT_FROM_WIN32(ERROR_SERVICE_MARKED_FOR_DELETE)==hr) {
            DebugWPrintf0(L"Service already marked for deletion.\n");
        } else {
            _JumpError(hr, error, "DeleteService");
        }

    } else {
        DebugWPrintf0(L"Service deleted.\n");
    }

    hr=S_OK;
error:
    if (NULL!=hTimeService) {
        CloseServiceHandle(hTimeService);
    }
    if (NULL!=hSCManager) {
        CloseServiceHandle(hSCManager);
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT DestroyRegValues(void) {
    HRESULT hr=S_OK;
    unsigned int nIndex;
    DWORD dwDisposition;

    // delete all interesting keys
    for (nIndex=0; nIndex<ARRAYSIZE(gc_rgwszKeyNames); nIndex++) {
        HKEY hkNew;
        HRESULT hr2=RegDeleteKey(HKEY_LOCAL_MACHINE, gc_rgwszKeyNames[ARRAYSIZE(gc_rgwszKeyNames)-nIndex-1]);
        hr2=HRESULT_FROM_WIN32(hr2);
        if (FAILED(hr2)) {
            if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)==hr2) {
                DebugWPrintf0(L"Already deleted");
            } else {
                DebugWPrintf1(L"Delete failed (0x%08X)", hr2);
                if (S_OK==hr) {
                    hr=hr2;
                }
            }
        } else {
            DebugWPrintf0(L"Deleted");
        }
        DebugWPrintf1(L": HKLM\\%s\n", gc_rgwszKeyNames[ARRAYSIZE(gc_rgwszKeyNames)-nIndex-1]);
    }

    //hr=S_OK;
//error:
    return hr;
}

MODULEPRIVATE HRESULT GetRole(RoleType *pe_Role)
{
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC  *pDomInfo  = NULL;
    DWORD                              dwErr; 
    HRESULT                            hr; 
    RoleType                           e_Role; 

    dwErr = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (BYTE **)&pDomInfo);
    if (ERROR_SUCCESS != dwErr) { 
        hr = HRESULT_FROM_WIN32(dwErr); 
        _JumpError(hr, error, "DsRoleGetPrimaryDomainInformation"); 
    }

    switch (pDomInfo->MachineRole)
    {
    case DsRole_RoleStandaloneWorkstation:
    case DsRole_RoleStandaloneServer:
        e_Role = e_Standalone; 
        break; 
    case DsRole_RoleMemberWorkstation: 
    case DsRole_RoleMemberServer:
        e_Role = e_MBR_Server; 
        break ;
    case DsRole_RoleBackupDomainController:
    case DsRole_RolePrimaryDomainController: 
        e_Role = e_DC; 
        break; 
    default: 
        hr = E_UNEXPECTED; 
        _JumpError(hr, error, "DsRoleGetPrimaryDomainInformation: bad retval."); 
    }

    if (NULL != pe_Role) { *pe_Role = e_Role; } 
    hr = S_OK; 
 error:
    if (NULL != pDomInfo) { DsRoleFreeMemory(pDomInfo); } 
    return hr; 
}


//####################################################################
// module public functions

//--------------------------------------------------------------------
extern "C" HRESULT __stdcall DllRegisterServer(void) {
    HRESULT   hr;
    RoleType  e_Role;

    hr=RegisterService();
    _JumpIfError(hr, error, "RegisterService");

    hr=CreateRegValues();
    _JumpIfError(hr, error, "CreateRegValues");

    hr = GetRole(&e_Role); 
    _JumpIfError(hr, error, "GetRole"); 

    hr=CreateRoleSpecificRegValues(e_Role); 
    _JumpIfError(hr, error, "CreateRoleSpecificRegValues");

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
extern "C" HRESULT __stdcall DllUnregisterServer(void) {
    HRESULT hr;

    hr=UnregisterService();
    _JumpIfError(hr, error, "UnregisterService");

    hr=DestroyRegValues();
    _JumpIfError(hr, error, "DestroyRegValues");

    hr=S_OK;
error:
    return hr;
}

extern "C" HRESULT __stdcall DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    HRESULT  hr; 
    LONG     lResult;
    LPCWSTR  wszCurrentCmd = pszCmdLine;

    // parse the cmd line
    while(wszCurrentCmd && *wszCurrentCmd)
    {
        while(*wszCurrentCmd == L' ')
            wszCurrentCmd++;
        if(*wszCurrentCmd == 0)
            break;

        switch(*wszCurrentCmd++)
        {
        case L'i': // Install
            {
                RoleType e_Role; 

                switch (*wszCurrentCmd++)
                {

                case 'f': // install first DC
                    e_Role = e_FirstDC; 
                    break; 
                case 'd': // install DC
                    e_Role = e_DC; 
                    break; 
                case 'm': // install member server
                    e_Role = e_MBR_Server;
                    break; 
                case 's': // Install standalone
                    e_Role = e_Standalone; 
                    break; 
                default: 
                    hr = E_INVALIDARG; 
                    _JumpError(hr, error, "Unrecognized role."); 
                }

                hr=RegisterService();
                _JumpIfError(hr, error, "RegisterService");
                
                hr=CreateRegValues();
                _JumpIfError(hr, error, "CreateRegValues");
                
                hr=CreateRoleSpecificRegValues(e_Role); 
                _JumpIfError(hr, error, "CreateRoleSpecificRegValues");
            }
            break; 

        case L'n': // net join
            {
                switch (*wszCurrentCmd++)
                {
                case 'j': // join operation
                    W32TimeVerifyJoinConfig(); 
                    break; 
                case 'u': // unjoin operation
                    W32TimeVerifyUnjoinConfig(); 
                    break ;
                default:
                    hr = E_INVALIDARG; 
                    _JumpError(hr, error, "Unrecognized join operation."); 
                }
            }
            break; 

        case L'd': // dcpromo
            {
                switch (*wszCurrentCmd++) 
                {
                case 'f': // first DC in tree
                    W32TimeDcPromo(W32TIME_PROMOTE_FIRST_DC_IN_TREE); 
                    break; 
                case 'p': // regular promotion
                    W32TimeDcPromo(W32TIME_PROMOTE); 
                    break; 
                case 'd': // regular demotion
                    W32TimeDcPromo(W32TIME_DEMOTE);
                    break;
                default:
                    hr = E_INVALIDARG; 
                    _JumpError(hr, error, "Unrecognized dcpromo operation."); 
                }
            }
            break;
        default: 
            hr = E_INVALIDARG;
            _JumpError(hr, error, "Unrecognized command."); 
        }
    }

    hr = S_OK; 
 error:
    return hr; 
}



//--------------------------------------------------------------------
MODULEPRIVATE HRESULT WriteSyncFromFlagsSpecial(DWORD dwValue) {
    DWORD    dwRetval;
    DWORD    dwSize;
    HRESULT  hr;
    LPWSTR   pwszValue;

    // must be cleaned up
    HKEY hkW32Time=NULL;

    switch (dwValue)
        {
        case NCSF_NoSync:             pwszValue = W32TM_Type_NoSync;  break;
        case NCSF_ManualPeerList:     pwszValue = W32TM_Type_NTP;     break;
        case NCSF_DomainHierarchy:    pwszValue = W32TM_Type_NT5DS;   break;
        case NCSF_ManualAndDomhier:   pwszValue = W32TM_Type_AllSync; break;
        default:
            hr = E_NOTIMPL; 
            _JumpError(hr, error, "SyncFromFlags not supported."); 
        }

    dwSize = sizeof(WCHAR) * (wcslen(pwszValue) + 1); 

    // open the key
    dwRetval=RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyParameters, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkW32Time);
    if (ERROR_SUCCESS==dwRetval) {
        // normal case
        dwRetval=RegSetValueEx(hkW32Time, wszW32TimeRegValueType, NULL, REG_SZ, (BYTE *)pwszValue, dwSize);
        if (ERROR_SUCCESS!=dwRetval) {
            hr=HRESULT_FROM_WIN32(dwRetval);
            _JumpErrorStr(hr, error, "RegSetValueEx", wszW32TimeRegValueType);
        }
        
    } else if (ERROR_FILE_NOT_FOUND==dwRetval) {
        // this may be during windows setup and our reg keys are not available yet. Write a special value in the service key
        dwRetval=RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyRoot, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkW32Time);
        if (ERROR_SUCCESS!=dwRetval) {
            hr=HRESULT_FROM_WIN32(dwRetval);
            _JumpErrorStr(hr, error, "RegOpenKeyEx", wszW32TimeRegKeyRoot);
        }
        dwRetval=RegSetValueEx(hkW32Time, wszW32TimeRegValueSpecialType, NULL, REG_SZ, (BYTE *)pwszValue, dwSize);
        if (ERROR_SUCCESS!=dwRetval) {
            hr=HRESULT_FROM_WIN32(dwRetval);
            _JumpErrorStr(hr, error, "RegSetValueEx", wszW32TimeRegValueSpecialType);
        }

    } else {
        // other error
        hr=HRESULT_FROM_WIN32(dwRetval);
        _JumpErrorStr(hr, error, "RegOpenKeyEx", wszNtpClientRegKeyConfig);
    }

    hr=S_OK;
error:
    if (NULL!=hkW32Time) {
        RegCloseKey(hkW32Time);
    }
    return hr;
}



//--------------------------------------------------------------------
extern "C" void W32TimeVerifyJoinConfig(void) {
    // this entry point is called by net join.
    // Enable sync from dom hierarchy.
    // The other defaults are all fine, so if the user changed anything else,
    // they're responsible for setting it back.
    
    DWORD  dwRetval; 
    DWORD  dwSize; 
    DWORD  dwType;
    HKEY   hkParameters = NULL; 
    LPWSTR wszSyncFromFlags = NULL; 
    WCHAR  wszValue[MAX_PATH]; 

    dwRetval = RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyParameters, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkParameters);
    if (ERROR_SUCCESS == dwRetval) {
        dwRetval = RegQueryValueEx(hkParameters, wszW32TimeRegValueType, NULL, &dwType, (BYTE *)&wszValue[0], &dwSize);
	if (ERROR_SUCCESS == dwRetval) { 
	    wszSyncFromFlags = wszValue; 
	}
    }

    if (NULL == wszSyncFromFlags) { 
	// No config info.  Just sync from the domain hierarchy. 
	WriteSyncFromFlagsSpecial(NCSF_DomainHierarchy); 
    } else if (0 == _wcsicmp(wszSyncFromFlags, W32TM_Type_NoSync)) { 
	WriteSyncFromFlagsSpecial(NCSF_NoSync); 
    } else if (0 == _wcsicmp(wszSyncFromFlags, W32TM_Type_NT5DS)) { 
	WriteSyncFromFlagsSpecial(NCSF_DomainHierarchy);
    } else if (0 == _wcsicmp(wszSyncFromFlags, W32TM_Type_AllSync)) { 
	WriteSyncFromFlagsSpecial(NCSF_ManualAndDomhier);  
    } else { 
	// W32TM_TYPE_NTP
	if (HasNewPeerlist()) { 
	    // We've been configured to sync from a manual peer.  
	    // preserve this setting, and also sync from the domain. 
	    WriteSyncFromFlagsSpecial(NCSF_ManualAndDomhier); 
	} else { 
	    WriteSyncFromFlagsSpecial(NCSF_DomainHierarchy); 
	}
    }

    CreateRoleSpecificRegValues(e_MBR_Server);

    if (NULL != hkParameters) { 
	RegCloseKey(hkParameters);
    }
}

//--------------------------------------------------------------------
extern "C" void W32TimeVerifyUnjoinConfig(void) {
    // this entry point is called by net join during an unjoin.
    // Make sure that we will sync from the manual peer list:
    // Turn on the NtpClient, enable sync from manual peer list.
    // The defaults are all fine, so if the user changed anything else,
    // they're responsible for setting it back.

    DWORD  dwRetval; 
    DWORD  dwSize;
    DWORD  dwType; 
    HKEY   hkParameters = NULL; 
    LPWSTR wszSyncFromFlags = NULL; 
    WCHAR  wszValue[MAX_PATH]; 

    dwRetval = RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyParameters, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkParameters);
    if (ERROR_SUCCESS == dwRetval) {
        dwRetval = RegQueryValueEx(hkParameters, wszW32TimeRegValueType, NULL, &dwType, (BYTE *)&wszValue[0], &dwSize);
	if (ERROR_SUCCESS == dwRetval) { 
	    wszSyncFromFlags = wszValue; 
	}
    }

    if (NULL != wszSyncFromFlags && (0 == _wcsicmp(wszSyncFromFlags, W32TM_Type_NoSync))) { 
	WriteSyncFromFlagsSpecial(NCSF_NoSync);
    } else { 
	WriteSyncFromFlagsSpecial(NCSF_ManualPeerList);
    }

    CreateRoleSpecificRegValues(e_Standalone);

    if (NULL != hkParameters) { 
	RegCloseKey(hkParameters);
    }
}

//--------------------------------------------------------------------
// this entry point is called by dcpromo during dc promotion/demotion.
// This resets the time service defaults based on the dwFlags parameter:
//
//     W32TIME_PROMOTE                   0x1 - uses DC defaults
//     W32TIME_DEMOTE                    0x2 - uses member server defaults
//     W32TIME_PROMOTE_FIRST_DC_IN_TREE  0x4 - the DC is the first DC in a (non-child) domain

extern "C" void W32TimeDcPromo(DWORD dwFlags)
{
    HRESULT hr; 

    if (W32TIME_PROMOTE_FIRST_DC_IN_TREE & dwFlags) { 
        hr = CreateRoleSpecificRegValues(e_FirstDC);          
        _JumpIfError(hr, error, "CreateRoleSpecificRegValues: e_FirstDC"); 
        WriteSyncFromFlagsSpecial(NCSF_NoSync); 
    } else if (W32TIME_PROMOTE & dwFlags) { 
        hr = CreateRoleSpecificRegValues(e_DC);          
        _JumpIfError(hr, error, "CreateRoleSpecificRegValues: e_DC"); 
        WriteSyncFromFlagsSpecial(NCSF_DomainHierarchy); 
    } else if (W32TIME_DEMOTE & dwFlags) { 
        hr = CreateRoleSpecificRegValues(e_MBR_Server);  
        _JumpIfError(hr, error, "CreateRoleSpecificRegValues: e_MBR_Server"); 
        WriteSyncFromFlagsSpecial(NCSF_DomainHierarchy);
    } else { 
        hr = E_INVALIDARG; 
        _IgnoreIfError(hr, "Invalid flags."); 
    }

 error:
    // Nothing we can do if there was an error...
    _IgnoreIfError(hr, "W32TimeDcPromo");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32tm\othercmds.h ===
//--------------------------------------------------------------------
// OtherCmds - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 2-17-00
//
// Other useful w32tm commands
//

#ifndef OTHER_CMDS_H
#define OTHER_CMDS_H

// forward decalrations
struct CmdArgs;

void PrintHelpOtherCmds(void);
HRESULT SysExpr(CmdArgs * pca);
HRESULT PrintNtte(CmdArgs * pca);
HRESULT PrintNtpte(CmdArgs * pca);
HRESULT ResyncCommand(CmdArgs * pca);
HRESULT Stripchart(CmdArgs * pca);
HRESULT Config(CmdArgs * pca);
HRESULT TestInterface(CmdArgs * pca);
HRESULT ShowTimeZone(CmdArgs * pca);
HRESULT DumpReg(CmdArgs * pca); 

#endif //OTHER_CMDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32tm\cmdargs.h ===
//--------------------------------------------------------------------
// CmdArgs - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 10-4-99
//
// stuff to deal with command line arguments
//

#ifndef CMD_ARGS_H
#define CMD_ARGS_H

struct CmdArgs {
    WCHAR ** rgwszArgs;
    unsigned int nArgs;
    unsigned int nNextArg;
};

bool CheckNextArg(IN CmdArgs * pca, IN WCHAR * wszTag, OUT WCHAR ** pwszParam);
bool FindArg(IN CmdArgs * pca, IN WCHAR * wszTag, OUT WCHAR ** pwszParam, OUT unsigned int * pnIndex);
void MarkArgUsed(IN CmdArgs * pca, IN unsigned int nIndex);
HRESULT VerifyAllArgsUsed(IN CmdArgs * pca);

#endif //CMD_ARGS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32timep\config.cpp ===
//--------------------------------------------------------------------
// w32timep - implementation
// Copyright (C) Microsoft Corporation, 2000
//
// Created by: Duncan Bryce (duncanb), 12-07-00
//
// Contains methods to configure or query the windows time service
// 

#include <windows.h>
#include <w32timep.h>
#include "DebugWPrintf.h"
#include "ErrorHandling.h"
#include "W32TmConsts.h"

struct PropertyTable { 
    DWORD   dwProperty;
    LPWSTR  pwszRegKeyName;
    LPWSTR  pwszRegValueName; 
} g_rgProperties[] = { 
    { W32TIME_CONFIG_SPECIAL_POLL_INTERVAL,  wszNtpClientRegKeyConfig,    wszNtpClientRegValueSpecialPollInterval }, 
    { W32TIME_CONFIG_MANUAL_PEER_LIST,       wszW32TimeRegKeyParameters,  wszW32TimeRegValueNtpServer }
}; 

//-------------------------------------------------------------------------------------
HRESULT MODULEPRIVATE myRegOpenKeyForProperty(IN DWORD dwProperty, OUT HKEY *phKey) { 
    DWORD    dwRetval; 
    HRESULT  hr; 
    LPWSTR   pwszKeyName  = NULL;

    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(g_rgProperties); dwIndex++) { 
        if (dwProperty == g_rgProperties[dwIndex].dwProperty) { 
            pwszKeyName = g_rgProperties[dwIndex].pwszRegKeyName; 
            break; 
        }
    }

    if (NULL == pwszKeyName) { 
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND); 
        _JumpError(hr, error, "myRegOpenKeyForProperty: key not found"); 
    }

    dwRetval = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pwszKeyName, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, phKey); 
    if (ERROR_SUCCESS != dwRetval) { 
        hr = HRESULT_FROM_WIN32(dwRetval); 
        _JumpError(hr, error, "RegOpenKeyEx"); 
    }

    hr = S_OK; 
 error:
    return hr; 
}

//-------------------------------------------------------------------------------------
HRESULT MODULEPRIVATE myRegQueryValueForProperty(DWORD dwProperty, HKEY hKey, DWORD *pdwType, BYTE *pbValue, DWORD *pdwSize) { 
    DWORD    dwRetval; 
    HRESULT  hr; 
    LPWSTR   pwszValueName  = NULL;

    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(g_rgProperties); dwIndex++) { 
        if (dwProperty == g_rgProperties[dwIndex].dwProperty) { 
            pwszValueName = g_rgProperties[dwIndex].pwszRegValueName; 
            break; 
        }
    }

    if (NULL == pwszValueName) { 
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND); 
        _JumpError(hr, error, "myRegQueryValueForProperty: value not found");
    }

    dwRetval = RegQueryValueEx(hKey, pwszValueName, NULL, pdwType, pbValue, pdwSize); 
    if (ERROR_SUCCESS != dwRetval) { 
        hr = HRESULT_FROM_WIN32(dwRetval); 
        _JumpError(hr, error, "RegQueryValueEx"); 
    }

    hr = S_OK; 
 error:
    return hr; 
}

//-------------------------------------------------------------------------------------
HRESULT MODULEPRIVATE myRegSetValueForProperty(DWORD dwProperty, HKEY hKey, DWORD dwType, BYTE *pbValue, DWORD dwSize) { 
    DWORD    dwRetval; 
    HRESULT  hr; 
    LPWSTR   pwszValueName  = NULL;

    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(g_rgProperties); dwIndex++) { 
        if (dwProperty == g_rgProperties[dwIndex].dwProperty) { 
            pwszValueName = g_rgProperties[dwIndex].pwszRegValueName; 
            break; 
        }
    }

    if (NULL == pwszValueName) { 
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND); 
        _JumpError(hr, error, "myRegSetValueForProperty: value not found");
    }

    dwRetval = RegSetValueEx(hKey, pwszValueName, NULL, dwType, pbValue, dwSize); 
    if (ERROR_SUCCESS != dwRetval) { 
        hr = HRESULT_FROM_WIN32(dwRetval); 
        _JumpError(hr, error, "RegSetValueEx"); 
    }

    hr = S_OK; 
 error:
    return hr; 
}

//-------------------------------------------------------------------------------------
// MODULEPUBLIC functions
//

//-------------------------------------------------------------------------------------
HRESULT  W32TimeQueryConfig(IN       DWORD   dwProperty, 
                            OUT      DWORD  *pdwType, 
                            IN OUT   BYTE   *pbConfig, 
                            IN OUT   DWORD  *pdwSize) 
{ 
    HKEY     hKey  = NULL; 
    HRESULT  hr;

    if (NULL == pdwType || NULL == pbConfig || NULL == pdwSize) { 
        hr = E_INVALIDARG; 
        _JumpError(hr, error, "W32TimeQueryConfig: input validation"); 
    }
    
    hr = myRegOpenKeyForProperty(dwProperty, &hKey); 
    _JumpIfError(hr, error, "myOpenRegKeyForProperty"); 

    hr = myRegQueryValueForProperty(dwProperty, hKey, pdwType, pbConfig, pdwSize); 
    _JumpIfError(hr, error, "myQueryRegValueForProperty"); 
    
    hr = S_OK; 
 error:
    if (NULL != hKey) { RegCloseKey(hKey); } 
    return hr; 
}

//-------------------------------------------------------------------------------------
HRESULT W32TimeSetConfig(IN  DWORD  dwProperty, 
                         IN  DWORD  dwType, 
                         IN  BYTE  *pbConfig, 
                         IN  DWORD  dwSize) 
{ 
    DWORD    dwRetval; 
    HKEY     hKey      = NULL; 
    HRESULT  hr;

    hr = myRegOpenKeyForProperty(dwProperty, &hKey); 
    _JumpIfError(hr, error, "myRegOpenKeyForProperty"); 

    hr = myRegSetValueForProperty(dwProperty, hKey, dwType, pbConfig, dwSize);
    _JumpIfError(hr, error, "myRegSetValueForProperty"); 

    hr = S_OK; 
 error:
    if (NULL != hKey) { RegCloseKey(hKey); } 
    return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32tm\pch.h ===
//--------------------------------------------------------------------
// pch - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 2-7-99
//
// Precompiled header for w32tm
//

#include <windows.h>
#include <winsock2.h>
#include <winsvc.h>
#include <stdio.h>
#include <ipexport.h>
#include <wchar.h>
#include "ServiceHost.h"
#include "CmdArgs.h"
#include "TimeMonitor.h"
#include "DebugWPrintf.h"
#include "LocalizedWPrintf.h"
#include "ErrorHandling.h"
#include "w32tmrc.h"
#include "w32tmmsg.h"
#include "NtpBase.h"
#include "PingLib.h"
#include "DcInfo.h"
#include <w32timep.h>
#include "AccurateSysCalls.h"
#include "OtherCmds.h"
#include "W32TmConsts.h"
#include "shellapi.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32tm\cmdargs.cpp ===
//--------------------------------------------------------------------
// CmdArgs - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 10-4-99
//
// stuff to deal with command line arguments
//

#include "pch.h"

//--------------------------------------------------------------------
bool CheckNextArg(CmdArgs * pca, WCHAR * wszTag, WCHAR ** pwszParam) {

    // make sure there are more arguments to look at
    if (pca->nNextArg==pca->nArgs) {
        return false;
    }

    WCHAR * wszArg=pca->rgwszArgs[pca->nNextArg];

    // our args must always start with a switch char
    if (L'/'!=wszArg[0] && L'-'!=wszArg[0]) {
        return false;
    }

    wszArg++;
    WCHAR * pwchColon=NULL;
    // if it is supposed to have a parameter, make sure it does
    if (NULL!=pwszParam) {
        pwchColon=wcschr(wszArg, L':');
        if (NULL==pwchColon) {
            return false;
        }
        *pwchColon=L'\0';
    }

    // is this the one we're looking for?
    if (0!=_wcsicmp(wszTag, wszArg)) {
        // no. 
        // put colon back if there was one
        if (NULL!=pwchColon) {
            *pwchColon=L':';
        }
        return false;
    } else {
        // yes.
        // put colon back, and point at the parameter, if necessary
        if (NULL!=pwszParam) {
            *pwchColon=L':';
            *pwszParam=pwchColon+1;
        }
        pca->nNextArg++;
        return true;
    }
}

//--------------------------------------------------------------------
bool FindArg(CmdArgs * pca, WCHAR * wszTag, WCHAR ** pwszParam, unsigned int * pnIndex) {
    unsigned int nOrigNextArg=pca->nNextArg;
    bool bFound=false;

    // check each arg to see if it matches
    unsigned int nIndex;
    for (nIndex=nOrigNextArg; nIndex<pca->nArgs; nIndex++) {
        pca->nNextArg=nIndex;
        if (CheckNextArg(pca, wszTag, pwszParam)) {
            *pnIndex=nIndex;
            bFound=true;
            break;
        }
    }
    pca->nNextArg=nOrigNextArg;
    return bFound;
}

//--------------------------------------------------------------------
void MarkArgUsed(CmdArgs * pca, unsigned int nIndex) {
    if (nIndex<pca->nNextArg || nIndex>=pca->nArgs) {
        return;
    }
    for (; nIndex>pca->nNextArg; nIndex--) {
        WCHAR * wszTemp=pca->rgwszArgs[nIndex];
        pca->rgwszArgs[nIndex]=pca->rgwszArgs[nIndex-1];
        pca->rgwszArgs[nIndex-1]=wszTemp;
    }
    pca->nNextArg++;

}

//--------------------------------------------------------------------
HRESULT VerifyAllArgsUsed(CmdArgs * pca) {
    HRESULT hr;

    if (pca->nArgs!=pca->nNextArg) {
        LocalizedWPrintfCR(IDS_W32TM_ERRORGENERAL_UNEXPECTED_PARAMS);
        for(; pca->nArgs!=pca->nNextArg; pca->nNextArg++) {
            wprintf(L" %s", pca->rgwszArgs[pca->nNextArg]);
        }
        wprintf(L"\n");
        hr=E_INVALIDARG;
        _JumpError(hr, error, "command line parsing");
    }
    hr=S_OK;
error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32time\w32time.cpp ===
//--------------------------------------------------------------------
// w32time - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 9-8-99
//
// Time service
//

#include "pch.h"

#include "AtomicInt64.inl"

#include "ErrToFileLog.h"

//--------------------------------------------------------------------
// structures

typedef HRESULT (__stdcall
        TimeProvOpenFunc)(
            IN WCHAR * wszName,
            IN TimeProvSysCallbacks * pSysCallbacks,
            OUT TimeProvHandle * phTimeProv);

typedef HRESULT (__stdcall
        TimeProvCommandFunc)(
            IN TimeProvHandle hTimeProv,
            IN TimeProvCmd eCmd,
            IN TimeProvArgs pvArgs);

typedef HRESULT (__stdcall
        TimeProvCloseFunc)(
            IN TimeProvHandle hTimeProv);

struct TimeProvider {
    WCHAR * wszDllName;
    WCHAR * wszProvName;
    bool bInputProvider;
    TimeProvider * ptpNext;
    HINSTANCE hDllInst;
    TimeProvHandle hTimeProv;
    TimeProvCommandFunc * pfnTimeProvCommand;
    TimeProvCloseFunc * pfnTimeProvClose;
    DWORD dwStratum; 
};

struct LocalClockConfigInfo {
    DWORD dwLastClockRate;
    DWORD dwMinClockRate;
    DWORD dwMaxClockRate;
    DWORD dwPhaseCorrectRate;
    DWORD dwUpdateInterval;
    DWORD dwFrequencyCorrectRate;
    DWORD dwPollAdjustFactor;
    DWORD dwLargePhaseOffset;
    DWORD dwSpikeWatchPeriod;
    DWORD dwHoldPeriod;
    DWORD dwMinPollInterval;
    DWORD dwMaxPollInterval;
    DWORD dwLocalClockDispersion;
    DWORD dwMaxNegPhaseCorrection;
    DWORD dwMaxPosPhaseCorrection;
    DWORD dwMaxAllowedPhaseOffset; 
};

struct ConfigInfo {
    TimeProvider * ptpProviderList;
    LocalClockConfigInfo lcci;
    DWORD dwAnnounceFlags;
    DWORD dwEventLogFlags;
};

struct TimeSampleInfo { 
    TimeSample   *pts; 
    TimeProvider *ptp;  // The provider that provided this sample
}; 

struct EndpointEntry {
    signed __int64 toEndpoint;
    signed int nType;
};
struct CandidateEntry {
    unsigned __int64 tpDistance;
    unsigned int nSampleIndex;
};

enum LocalClockState {
    e_Unset,
    e_Hold,
    e_Sync,
    e_Spike,
};

enum ResyncResult {
    e_Success=ResyncResult_Success,
    e_NoData=ResyncResult_NoData,
    e_StaleData=ResyncResult_StaleData,
    e_ChangeTooBig=ResyncResult_ChangeTooBig,
    e_Shutdown=ResyncResult_Shutdown
};

enum WaitTimeoutReason {
    e_RegularPoll,
    e_IrregularPoll,
    e_LongTimeNoSync,
};

enum LocalClockCommand {
    e_ParamChange,
    e_TimeSlip,
    e_RegularUpdate,
    e_IrregularUpdate,
    e_GoUnsyncd,
};

#define ClockFreqPredictErrBufSize 4
#define SysDispersionBufSize 4
#define SampleBufInitialSize 10
struct StateInfo {
    SERVICE_STATUS servicestatus;
    SERVICE_STATUS_HANDLE servicestatushandle;

    // synchronization
    BOOL   bCSInitialized; 
    CRITICAL_SECTION csW32Time;  
    HANDLE hShutDownEvent;
    HANDLE hClockDisplnThread;
    HANDLE hClockCommandAvailEvent;
    HANDLE hClockCommandCompleteEvent;
    HANDLE hPollIntervalChangeEvent;
    HANDLE hManagerGPUpdateEvent;  
    HANDLE hManagerParamChangeEvent;
    HANDLE hTimeSlipEvent;      // also, hard resync
    HANDLE hRpcSyncCompleteAEvent;
    HANDLE hRpcSyncCompleteBEvent;
    HANDLE hNetTopoChangeEvent;
    OVERLAPPED olNetTopoIOOverlapped;
    HANDLE hNetTopoIOHandle;
    HANDLE hNetTopoRpcEvent;    // rediscover resync (can't overload hNetTopoChangeEvent because we need it to detect IO complete)
    HANDLE hDomHierRoleChangeEvent; 
    HANDLE hSamplesAvailEvent;

    // Wait handles used to de-register objects from the thread pool wait function:
    HANDLE hRegisteredManagerParamChangeEvent;
    HANDLE hRegisteredManagerGPUpdateEvent;
    HANDLE hRegisteredTimeSlipEvent;
    HANDLE hRegisteredNetTopoChangeEvent; 
    HANDLE hRegisteredClockDisplnThread; 
    HANDLE hRegisteredDomHierRoleChangeEvent; 
    HANDLE hRegisteredSamplesAvailEvent; 

    // Timer objects
    HANDLE hTimer;  

    // NTP state
    volatile NtpLeapIndicator eLeapIndicator;
    volatile unsigned int nStratum;
    volatile NtpRefId refidSource;
    volatile signed int nPollInterval;
    asint64 toSysPhaseOffset;
    auint64 teLastSyncTime;
    asint64 toRootDelay;
    auint64 tpRootDispersion;
    volatile DWORD dwTSFlags;
    
    // transfer from manager to local clock
    TimeSample tsNextClockUpdate; 
    TimeSampleInfo tsiNextClockUpdate;
    NtTimePeriod tpSelectDispersion;
    LocalClockCommand eLocalClockCommand;
    // transfer from local clock to manager
    bool bClockJumped;
    NtTimeOffset toClockJump;
    bool bPollIntervalChanged;
    bool bStaleData;
    bool bClockChangeTooBig;
    NtTimeOffset toIgnoredChange;
    WCHAR wszSourceName[256];
    bool bSourceChanged;
    bool bControlClockFromSoftware;  


    // local clock state
    signed __int64 toKnownPhaseOffset;
    unsigned __int64 qwPhaseCorrectStartTickCount;
    unsigned __int64 qwLastUpdateTickCount;
    DWORD dwClockRate;
    signed __int32 nPhaseCorrectRateAdj;
    signed __int32 nRateAdj;
    signed __int32 nFllRateAdj;
    signed __int32 nPllRateAdj;
    unsigned int nErrorIndex;
    double rgdFllError[ClockFreqPredictErrBufSize];
    double rgdPllError[ClockFreqPredictErrBufSize];
    DWORD dwPllLoopGain;
    unsigned int nSysDispersionIndex;
    unsigned __int64 rgtpSysDispersion[SysDispersionBufSize];
    unsigned int nPollUpdateCounter;
    LocalClockState lcState;
    unsigned int nHoldCounter;
    unsigned __int64 teSpikeStart;
    WCHAR wszPreUnsyncSourceName[256];
    WCHAR wszPreTimeSlipSourceName[256];

    // manager state
    ConfigInfo * pciConfig;
    unsigned __int64 tpPollDelayRemaining;
    unsigned __int64 teManagerWaitStart;
    unsigned __int64 tpIrregularDelayRemaining;
    unsigned __int64 tpTimeSinceLastSyncAttempt;
    unsigned __int64 tpTimeSinceLastGoodSync;
    unsigned __int64 tpWaitInterval;
    signed int nClockPrecision;
    TimeSample * rgtsSampleBuf;
    TimeSampleInfo * rgtsiSampleInfoBuf; 
    EndpointEntry * rgeeEndpointList;
    CandidateEntry * rgceCandidateList;
    unsigned int nSampleBufAllocSize;
    bool bTimeSlipNotificationStarted;
    bool bNetTopoChangeNotificationStarted;
    bool bGPNotificationStarted; 
    ResyncResult eLastRegSyncResult;
    WaitTimeoutReason eTimeoutReason;
    bool bDontLogClockChangeTooBig;
    DWORD dwEventLogFlags;
    bool bIsDomainRoot; 

    CRITICAL_SECTION csAPM; 
    bool bCSAPMInitialized; 
    bool bAPMStoppedFileLog;
    bool bAPMAcquiredSystemClock; 

    // RPC state
    bool bRpcServerStarted;
    volatile DWORD dwNetlogonServiceBits;
    volatile ResyncResult eLastSyncResult;
    volatile HANDLE hRpcSyncCompleteEvent;

};

// Used to prevent multiple concurrent shutdown requests
struct ShutdownInfo { 
    BOOL              bCSInitialized;
    CRITICAL_SECTION  cs; 
    HANDLE            hShutdownReady; 
    DWORD             dwNumRunning; 
    BOOL              fShuttingDown; 
}; 

//--------------------------------------------------------------------
// globals

#define W32TIME_ERROR_SHUTDOWN      HRESULT_FROM_WIN32(ERROR_SERVICE_CANNOT_ACCEPT_CTRL)

#define WAITHINT_WAITFORMANAGER     1000 // 1 sec until the manager thread notices the stop event.
#define WAITHINT_WAITFORDISPLN      1000 // 1 sec until the clock discipline thread notices the stop event.
#define WAITHINT_WAITFORPROV        1000 // 1 sec until a time provider shuts down 

#define PLLLOOPGAINBASE 6368 // number of ticks in 64s
#define MINIMUMIRREGULARINTERVAL 160000000 // 16s in 10^-7s
#define TIMEZONEMAXBIAS 900 // 15hr in min 

#define wszW32TimeUNLocalCmosClock              L"Local CMOS Clock"             // start
#define wszW32TimeUNFreeSysClock                L"Free-running System Clock"    // unsyncd

// 
// Create a security descriptors to ACL named events:  
//
// LocalSystem:  "O:SYG:SYD:(A;;GA;;;SY)"
// 
// O:SY         -- owner == local system
// G:SY         -- group == local system
// D:           -- no dacl flags
// (A;;GA;;;SY) -- one ACE -- ACCESS_ALLOWED, GENERIC_ALL, trustee == LocalSystem
//
#define LOCAL_SYSTEM_SD  L"O:SYG:SYD:(A;;GA;;;SY)"

MODULEPRIVATE StateInfo g_state;
MODULEPRIVATE ShutdownInfo g_shutdown; 

// for running under svchost.exe
MODULEPRIVATE SVCHOST_GLOBAL_DATA * g_pSvcsGlobalData=NULL;

// externally modified function pointer table
SERVICE_STATUS_HANDLE (WINAPI * fnW32TmRegisterServiceCtrlHandlerEx)(LPCWSTR, LPHANDLER_FUNCTION_EX, LPVOID);
BOOL (WINAPI * fnW32TmSetServiceStatus)(SERVICE_STATUS_HANDLE, LPSERVICE_STATUS);


//--------------------------------------------------------------------
// function prototypes
MODULEPRIVATE unsigned int CountInputProvidersInList(TimeProvider * ptpHead); 
MODULEPRIVATE HRESULT HandleManagerApmResumeSuspend(void);
MODULEPRIVATE HRESULT HandleManagerApmSuspend(void);
MODULEPRIVATE HRESULT HandleManagerGoUnsyncd(void);
MODULEPRIVATE HRESULT HandleManagerHardResync(TimeProvCmd tpc, LPVOID pvArgs);
MODULEPRIVATE void WINAPI HandleManagerNetTopoChangeNoRPC(LPVOID pvIgnored, BOOLEAN bIgnored); 
MODULEPRIVATE void HandleManagerSystemShutdown(void); 
MODULEPRIVATE DWORD WINAPI HandleSetProviderStatus(PVOID pvSetProviderStatusInfo);
MODULEPRIVATE DWORD WINAPI SendServiceShutdownWorker(PVOID pvIgnored);
MODULEPRIVATE HRESULT ShutdownNetlogonServiceBits(void);
MODULEPRIVATE HRESULT StartOrStopTimeSlipNotification(bool bStart);
MODULEPRIVATE HRESULT StopNetTopoChangeNotification(void);
MODULEPRIVATE HRESULT StopProvider(TimeProvider * ptp);
MODULEPRIVATE HRESULT UpdateNetlogonServiceBits(bool bFullUpdate) ;
MODULEPRIVATE HRESULT UpdateTimerQueue1(void);
MODULEPRIVATE HRESULT UpdateTimerQueue2(void);
MODULEPRIVATE HRESULT W32TmStopRpcServer(void);

extern "C" void WINAPI W32TmServiceMain(unsigned int nArgs, WCHAR ** rgwszArgs);

//####################################################################
// module private functions

void __cdecl SeTransFunc(unsigned int u, EXCEPTION_POINTERS* pExp) { 
    throw SeException(u); 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT AcquireControlOfSystemClock(bool bEnter, bool bBlock, bool *pbAcquired) { 
    BOOL     bAcquired = TRUE; 
    HRESULT  hr; 

    if (bEnter) { 
	if (bBlock) { 
	    hr = myEnterCriticalSection(&g_state.csAPM); 
	    _JumpIfError(hr, error, "myEnterCriticalSection"); 
	    bAcquired = TRUE;
	} else { 
	    hr = myTryEnterCriticalSection(&g_state.csAPM, &bAcquired); 
	    _JumpIfError(hr, error, "myTryEnterCriticalSection"); 
	}
    } else { 
	hr = myLeaveCriticalSection(&g_state.csAPM); 
	_JumpIfError(hr, error, "myLeaveCriticalSection");  
    }
    
    if (NULL != pbAcquired) { 
	*pbAcquired = bAcquired ? true : false; 
    }
    hr = S_OK; 
 error:
    return hr; 
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT AllowShutdown(BOOL fAllow) { 
    bool     bEnteredCriticalSection  = false; 
    HRESULT  hr; 
    
    hr = myEnterCriticalSection(&g_shutdown.cs); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    if (fAllow) { 
	// This worker no longer needs to block shutdown. 
	// BUGBUG:  note that if SetEvent() fails, the shutdown thread may 
	//          never be woken up!
	if (0 == --g_shutdown.dwNumRunning && g_shutdown.fShuttingDown) { 
	    if (!SetEvent(g_shutdown.hShutdownReady)) { 
		_JumpLastError(hr, error, "SetEvent"); 
	    }
	}
    } else { 
	if (g_shutdown.fShuttingDown) { 
	    hr = W32TIME_ERROR_SHUTDOWN; 
	    _JumpError(hr, error, "AllowShutdown: g_shutdown.fShuttingDown==TRUE"); 
	}

	// We're not shutting down, increment the number of running
	// shutdown-aware workers: 
	g_shutdown.dwNumRunning++; 
    }

    hr = S_OK;
 error:
    if (bEnteredCriticalSection) { 
	HRESULT hr2 = myLeaveCriticalSection(&g_shutdown.cs); 
	_TeardownError(hr, hr2, "myLeaveCriticalSection"); 
    }
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StartShutdown() { 
    bool     bEnteredCriticalSection  = false; 
    HRESULT  hr; 

    hr = myEnterCriticalSection(&g_shutdown.cs); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    if (g_shutdown.fShuttingDown) { 
	hr = W32TIME_ERROR_SHUTDOWN; 
	_JumpError(hr, error, "StartShutdown: g_shutdown.fShuttingDown==TRUE");
    }

    g_shutdown.fShuttingDown = true; 

    if (g_shutdown.dwNumRunning) {
	hr = myLeaveCriticalSection(&g_shutdown.cs); 
	if (SUCCEEDED(hr)) { 
	    bEnteredCriticalSection = false; 
	} else { 
	    _IgnoreError(hr, "myLeaveCriticalSection"); // Not much we can do if failed.  Just hope for the best...
	}

	if (WAIT_FAILED == WaitForSingleObject(g_shutdown.hShutdownReady, INFINITE)) { 
	    _JumpLastError(hr, error, "WaitForSingleObject"); 
	}
    }

    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
	HRESULT hr2 = myLeaveCriticalSection(&g_shutdown.cs); 
	_TeardownError(hr, hr2, "myLeaveCriticalSection"); 
    }
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE bool IsEventSet(HANDLE hEvent) {
    return (WAIT_OBJECT_0==WaitForSingleObject(hEvent,0));
}

//--------------------------------------------------------------------
MODULEPRIVATE void FreeTimeProviderList(TimeProvider * ptpHead) {
    while (NULL!=ptpHead) {
        TimeProvider * ptpTemp=ptpHead;
        ptpHead=ptpHead->ptpNext;
        LocalFree(ptpTemp->wszDllName);
        LocalFree(ptpTemp->wszProvName);
        LocalFree(ptpTemp);
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT RemoveProviderFromList(TimeProvider *ptp) { 
    bool           bEnteredCriticalSection = false; 
    HRESULT        hr; 
    TimeProvider   tpDummy; 
    TimeProvider  *ptpHead;
    TimeProvider  *ptpPrev;
    WCHAR         *wszError=NULL;

    hr = myEnterCriticalSection(&g_state.csW32Time); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    FileLog1(FL_ServiceMainAnnounce, L"Removing provider from list: %s\n", ptp->wszProvName); 

    // Insert a dummy first element to simplify list operations: 
    ptpHead                            = g_state.pciConfig->ptpProviderList;
    g_state.pciConfig->ptpProviderList = &tpDummy; 
    tpDummy.ptpNext                    = ptpHead; 
    ptpPrev                            = &tpDummy; 

    while (NULL != ptpHead) { 
        TimeProvider *ptpTemp = ptpHead; 
        if (ptp == ptpHead) { // We've found the provider to remove
            // Unlink ptpHead from the list of providers: 
            ptpPrev->ptpNext = ptpHead->ptpNext; 
            // Now free it: 
            LocalFree(ptpHead->wszDllName); 
            LocalFree(ptpHead->wszProvName); 
            LocalFree(ptpHead); 
            break; 
        } 

        // Continue searching through the list ...
        ptpPrev = ptpHead; 
        ptpHead = ptpPrev->ptpNext; 
    }

    // Remove the dummy element we inserted at the beginning of the function:
    g_state.pciConfig->ptpProviderList = tpDummy.ptpNext; 
    
    // If there are no input providers left, log an error
    if (0==CountInputProvidersInList(g_state.pciConfig->ptpProviderList)) { 
        const WCHAR * rgwszStrings[1]={NULL}; 
            
        FileLog0(FL_ServiceMainAnnounce, L"The time service has been configured to use one or more input providers, however, none of the input providers are still running. THE TIME SERVICE HAS NO SOURCE OF ACCURATE TIME.\n"); 
        hr=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_NO_INPUT_PROVIDERS_STARTED, 2, rgwszStrings); 
        _JumpIfError(hr, error, "MyLogEvent");
    }

    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
        HRESULT hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT RemoveDefaultProvidersFromList() { 
    HRESULT hr; 

    for (TimeProvider *ptp = g_state.pciConfig->ptpProviderList; NULL != ptp; ptp = ptp->ptpNext) { 
        if (0 == wcscmp(ptp->wszDllName /*The provider's DLL*/, wszDLLNAME /*w32time.dll*/)) { 
            hr = RemoveProviderFromList(ptp); 
            _JumpIfError(hr, error, "RemoveProviderFromList");
        }
    }

    hr = S_OK; 
 error:
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE unsigned int CountInputProvidersInList(TimeProvider * ptpHead) {
    unsigned int nCount=0;
    while (NULL!=ptpHead) {
        if (ptpHead->bInputProvider) {
            nCount++;
        }
        ptpHead=ptpHead->ptpNext;
    }

    return nCount;
}

//--------------------------------------------------------------------
MODULEPRIVATE void FreeConfigInfo(ConfigInfo * pci) {
    FreeTimeProviderList(pci->ptpProviderList);
    LocalFree(pci);
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT InitShutdownState(void) {
    HRESULT  hr; 

    ZeroMemory(&g_shutdown, sizeof(g_shutdown)); 

    hr = myInitializeCriticalSection(&g_shutdown.cs); 
    _JumpIfError(hr, error, "myInitializeCriticalSection");
    g_shutdown.bCSInitialized = true; 
    
    g_shutdown.hShutdownReady = CreateEvent(NULL, FALSE /*auto-reset*/, FALSE /*non-signaled*/, NULL /*no security*/);
    if (NULL == g_shutdown.hShutdownReady) { 
	_JumpLastError(hr, error, "CreateEvent"); 
    }
    
    hr = S_OK;
 error:
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT InitGlobalState(void) {
    DWORD                 cbSD; 
    HRESULT               hr;
    PSECURITY_DESCRIPTOR  pSD   = NULL; 
    SECURITY_ATTRIBUTES   SA; 
    
    ZeroMemory(&g_state, sizeof(g_state)); 

    //g_state.servicestatus // OK
    g_state.servicestatushandle=NULL;

    hr = myInitializeCriticalSection(&g_state.csW32Time); 
    _JumpIfError(hr, error, "myInitializeCriticalSection"); 
    g_state.bCSInitialized = true; 

    hr = myInitializeCriticalSection(&g_state.csAPM); 
    _JumpIfError(hr, error, "myInitializeCriticalSection"); 
    g_state.bCSAPMInitialized = true; 

    // Create all of the events used by the manager: 
    // 
    struct EventToCreate { 
        HANDLE          *phEvent; 
        const WCHAR     *pwszSD; 
        BOOL             bManualReset; 
        BOOL             bInitialState; 
	const WCHAR     *pwszName; 
    } rgEvents[] = { 
        { &g_state.hShutDownEvent,              NULL,             TRUE,   FALSE,  NULL }, 
        { &g_state.hClockCommandAvailEvent,     NULL,             FALSE,  FALSE,  NULL },  
        { &g_state.hClockCommandCompleteEvent,  NULL,             FALSE,  FALSE,  NULL }, 
        { &g_state.hManagerParamChangeEvent,    NULL,             FALSE,  FALSE,  NULL }, 
        { &g_state.hManagerGPUpdateEvent,       NULL,             TRUE,   FALSE,  NULL }, 
        { &g_state.hTimeSlipEvent,              LOCAL_SYSTEM_SD,  FALSE,  FALSE,  W32TIME_NAMED_EVENT_SYSTIME_NOT_CORRECT}, 
        { &g_state.hNetTopoChangeEvent,         NULL,             TRUE,   FALSE,  NULL }, 
        { &g_state.hRpcSyncCompleteAEvent,      NULL,             TRUE,   FALSE,  NULL }, 
        { &g_state.hRpcSyncCompleteBEvent,      NULL,             TRUE,   FALSE,  NULL }, 
        { &g_state.hDomHierRoleChangeEvent,     NULL,             FALSE,  FALSE,  NULL }, 
	{ &g_state.hSamplesAvailEvent,          NULL,             FALSE,  FALSE,  NULL }
    }; 

    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgEvents); dwIndex++) { 
        EventToCreate         etc  = rgEvents[dwIndex]; 
        PSECURITY_ATTRIBUTES  pSA  = NULL; 
        
        if (NULL != etc.pwszSD) { 
            if (!ConvertStringSecurityDescriptorToSecurityDescriptor(etc.pwszSD, SDDL_REVISION_1, &pSD, &cbSD)) { 
                _JumpLastError(hr, error, "ConvertStringSecurityDescriptorToSecurityDescriptor"); 
            }

            SA.nLength               = cbSD;
            SA.lpSecurityDescriptor  = pSD; 
            SA.bInheritHandle        = FALSE; 
            pSA = &SA; 
        }

        if (NULL != etc.pwszName) { 
            HANDLE hTempEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, etc.pwszName);
            if (NULL != hTempEvent || E_ACCESSDENIED == HRESULT_FROM_WIN32(GetLastError())) { 
                // POTENTIAL SECURITY RISK:  Someone has already created our named event before 
                //                           we have.  They may have ACL'd it differently than we desire. 
                //                           Log an error and don't start the time service. 
                const WCHAR * rgwszStrings[1] = {etc.pwszName}; 
                HRESULT hr2 = MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_NAMED_EVENT_ALREADY_OPEN, 1, rgwszStrings); 
                _IgnoreIfError(hr2, "MyLogEvent"); 

                if (NULL != hTempEvent) { // Close the handle if we successfully opened it. 
                    CloseHandle(hTempEvent); 
                }

                hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS); 
                _JumpError(hr, error, "OpenEvent: event already open"); 
            }         
        } 
            
        *(etc.phEvent) = CreateEvent(pSA, etc.bManualReset, etc.bInitialState, etc.pwszName);
        if (NULL == *(etc.phEvent)) {
            _JumpLastError(hr, error, "CreateEvent");
        }

        LocalFree(pSD); 
        pSD = NULL;
    }

    hr = myCreateTimerQueueTimer(&g_state.hTimer);
    _JumpIfError(hr, error, "myCreateTimerQueueTimer"); 

    g_state.eLeapIndicator=e_ClockNotSynchronized;
    g_state.nStratum=0;
    g_state.refidSource.value=0;
    //g_state.nPollInterval // OK  =NtpConst::nMinPollInverval;
    g_state.toRootDelay.setValue(0);
    g_state.tpRootDispersion.setValue(0);
    g_state.toSysPhaseOffset.setValue(0);
    g_state.teLastSyncTime.setValue(gc_teNtpZero.qw);

    //g_state.tsNextClockUpdate // OK
    //g_state.tpSelectDispersion // OK

    //g_state.bClockJumped // OK
    //g_state.toClockJump // OK
    //g_state.bPollIntervalChanged // OK
    //g_state.bStaleData // OK
    //g_state.bClockChangeTooBig // OK
    //g_state.toIgnoredChange //OK

    // local clock state // OK

    // manager state
    g_state.pciConfig=NULL;
    // g_state.tpPollDelayRemaining // OK
    // g_state.teManagerWaitStart // OK
    // g_state.tpIrregularDelayRemaining // OK
    // g_state.tpTimeSinceLastSyncAttempt // OK
    // g_state.tpTimeSinceLastGoodSync // OK
    // g_state.tpWaitInterval // OK
    g_state.nSampleBufAllocSize=SampleBufInitialSize;
    g_state.rgtsSampleBuf=NULL;
    g_state.rgtsiSampleInfoBuf=NULL;
    g_state.rgeeEndpointList=NULL;
    g_state.rgceCandidateList=NULL;
    g_state.bTimeSlipNotificationStarted=false;
    g_state.bNetTopoChangeNotificationStarted=false;
    g_state.eLastRegSyncResult=e_NoData;
    // g_state.eTimeoutReason // OK
    g_state.bDontLogClockChangeTooBig=false;
    // g_state.dwEventLogFlags // OK

    // RPC State
    g_state.bRpcServerStarted=false;
    g_state.dwNetlogonServiceBits=0;
    g_state.eLastSyncResult=e_NoData;
    g_state.hRpcSyncCompleteEvent=g_state.hRpcSyncCompleteAEvent;

    g_state.rgtsSampleBuf=(TimeSample *)LocalAlloc(LPTR, sizeof(TimeSample)*g_state.nSampleBufAllocSize);
    _JumpIfOutOfMemory(hr, error, g_state.rgtsSampleBuf);

    g_state.rgtsiSampleInfoBuf=(TimeSampleInfo *)LocalAlloc(LPTR, sizeof(TimeSampleInfo)*g_state.nSampleBufAllocSize); 
    _JumpIfOutOfMemory(hr, error, g_state.rgtsiSampleInfoBuf);

    g_state.rgeeEndpointList=(EndpointEntry *)LocalAlloc(LPTR, sizeof(EndpointEntry)*3*g_state.nSampleBufAllocSize);
    _JumpIfOutOfMemory(hr, error, g_state.rgeeEndpointList);

    g_state.rgceCandidateList=(CandidateEntry *)LocalAlloc(LPTR, sizeof(CandidateEntry)*g_state.nSampleBufAllocSize);
    _JumpIfOutOfMemory(hr, error, g_state.rgceCandidateList);


    hr=S_OK;
error:
    if (NULL != pSD) { 
        LocalFree(pSD); 
    }
    // on error, any succefully created objects will be freed in FreeGlobalState.
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE void FreeGlobalState(void) {
    //g_state.servicestatus // OK
    //g_state.servicestatushandle // OK

    if (g_state.bCSInitialized) { 
        DeleteCriticalSection(&g_state.csW32Time); 
        g_state.bCSInitialized = false; 
    }

    if (g_state.bCSAPMInitialized) { 
	DeleteCriticalSection(&g_state.csAPM);
	g_state.bCSAPMInitialized = false; 
    }

    HANDLE rgEvents[] = { 
        g_state.hShutDownEvent,           
        g_state.hClockCommandAvailEvent,  
        g_state.hClockCommandCompleteEvent,
        g_state.hManagerGPUpdateEvent, 
        g_state.hManagerParamChangeEvent,
        g_state.hTimeSlipEvent,        
        g_state.hNetTopoChangeEvent,   
        g_state.hRpcSyncCompleteAEvent,
        g_state.hRpcSyncCompleteBEvent,
        g_state.hDomHierRoleChangeEvent, 
	g_state.hSamplesAvailEvent, 
    }; 

    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgEvents); dwIndex++) { 
        if (NULL != rgEvents[dwIndex]) { 
            CloseHandle(rgEvents[dwIndex]);
        }
    }

    //g_state.eLeapIndicator // OK
    //g_state.nStratum // OK
    //g_state.refidSource // OK
    //g_state.nPollInterval // OK
    //g_state.toRootDelay // OK
    //g_state.tpRootDispersion // OK
    //g_state.toSysPhaseOffset // OK
    //g_state.teLastSyncTime // OK

    //g_state.tsNextClockUpdate // OK
    //g_state.tsNextClockUpdate // OK
    //g_state.tpSelectDispersion // OK

    //g_state.bClockJumped // OK
    //g_state.toClockJump // OK
    //g_state.bPollIntervalChanged // OK
    //g_state.bStaleData // OK
    //g_state.bClockChangeTooBig // OK
    //g_state.toIgnoredChange //OK

    // local clock state // OK

    // manager state
    if (NULL!=g_state.pciConfig) {
        FreeConfigInfo(g_state.pciConfig);
    }
    // g_state.tpPollDelayRemaining // OK
    // g_state.teManagerWaitStart // OK
    // g_state.tpIrregularDelayRemaining // OK
    // g_state.tpTimeSinceLastSyncAttempt // OK
    // g_state.tpTimeSinceLastGoodSync // OK
    // g_state.tpWaitInterval // OK
    // g_state.nClockPrecision // OK
    if (NULL!=g_state.rgtsSampleBuf) {
        LocalFree(g_state.rgtsSampleBuf);
    }
    if (NULL!=g_state.rgeeEndpointList) {
        LocalFree(g_state.rgeeEndpointList);
    }
    if (NULL!=g_state.rgceCandidateList) {
        LocalFree(g_state.rgceCandidateList);
    }
    
    ZeroMemory(&g_state, sizeof(g_state)); 
}


//--------------------------------------------------------------------
MODULEPRIVATE void FreeShutdownState(void) {
    if (g_shutdown.bCSInitialized) { 
	DeleteCriticalSection(&g_shutdown.cs); 
	g_shutdown.bCSInitialized = false; 
    }
    if (g_shutdown.hShutdownReady) { 
	CloseHandle(g_shutdown.hShutdownReady); 
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT EnlargeSampleBuf(unsigned int nSamples) {
    HRESULT hr;

    // must be cleaned up
    TimeSample * rgtsNewSampleBuf=NULL;
    TimeSampleInfo * rgtsiNewSampleInfoBuf=NULL;
    EndpointEntry * rgeeNewEndpointList=NULL;
    CandidateEntry * rgceNewCandidateList=NULL;

    rgtsNewSampleBuf=(TimeSample *)LocalAlloc(LPTR, sizeof(TimeSample)*(g_state.nSampleBufAllocSize+nSamples));
    _JumpIfOutOfMemory(hr, error, rgtsNewSampleBuf);

    rgtsiNewSampleInfoBuf=(TimeSampleInfo *)LocalAlloc(LPTR, sizeof(TimeSampleInfo)*(g_state.nSampleBufAllocSize+nSamples));
    _JumpIfOutOfMemory(hr, error, rgtsiNewSampleInfoBuf);

    rgeeNewEndpointList=(EndpointEntry *)LocalAlloc(LPTR, sizeof(EndpointEntry)*3*(g_state.nSampleBufAllocSize+nSamples));
    _JumpIfOutOfMemory(hr, error, rgeeNewEndpointList);

    rgceNewCandidateList=(CandidateEntry *)LocalAlloc(LPTR, sizeof(CandidateEntry)*(g_state.nSampleBufAllocSize+nSamples));
    _JumpIfOutOfMemory(hr, error, rgceNewCandidateList);

    // we succeeded

    // copy the current data and remeber our new allocated size.
    // note the the endpoint and candidate lists do not need to be copied
    memcpy(rgtsNewSampleBuf, g_state.rgtsSampleBuf, sizeof(TimeSample)*g_state.nSampleBufAllocSize);
    memcpy(rgtsiNewSampleInfoBuf, g_state.rgtsiSampleInfoBuf, sizeof(TimeSampleInfo)*g_state.nSampleBufAllocSize);
    g_state.nSampleBufAllocSize+=nSamples;

    LocalFree(g_state.rgtsSampleBuf);
    g_state.rgtsSampleBuf=rgtsNewSampleBuf;
    rgtsNewSampleBuf=NULL;

    LocalFree(g_state.rgtsiSampleInfoBuf);
    g_state.rgtsiSampleInfoBuf=rgtsiNewSampleInfoBuf;
    rgtsiNewSampleInfoBuf=NULL;

    LocalFree(g_state.rgeeEndpointList);
    g_state.rgeeEndpointList=rgeeNewEndpointList;
    rgeeNewEndpointList=NULL;

    LocalFree(g_state.rgceCandidateList);
    g_state.rgceCandidateList=rgceNewCandidateList;
    rgceNewCandidateList=NULL;

    hr=S_OK;
error:
    if (NULL!=rgtsNewSampleBuf) {
        LocalFree(rgtsNewSampleBuf);
    }
    if (NULL!=rgtsiNewSampleInfoBuf) {
        LocalFree(rgtsiNewSampleInfoBuf);
    }
    if (NULL!=rgeeNewEndpointList) {
        LocalFree(rgeeNewEndpointList);
    }
    if (NULL!=rgceNewCandidateList) {
        LocalFree(rgceNewCandidateList);
    }
    return hr;
}

//====================================================================
// service control routines

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT MySetServiceStatus(DWORD dwCurrentState, DWORD dwCheckPoint, DWORD dwWaitHint, DWORD dwExitCode) {
    HRESULT hr;

    g_state.servicestatus.dwServiceType=SERVICE_WIN32_SHARE_PROCESS; // | SERVICE_INTERACTIVE_PROCESS;
    g_state.servicestatus.dwCurrentState=dwCurrentState;
    switch (dwCurrentState) {
    case SERVICE_STOPPED:
    case SERVICE_STOP_PENDING:
        g_state.servicestatus.dwControlsAccepted=0;
        break;
    case SERVICE_RUNNING:
    case SERVICE_PAUSED:
        g_state.servicestatus.dwControlsAccepted=SERVICE_ACCEPT_STOP
          //| SERVICE_ACCEPT_PAUSE_CONTINUE
            | SERVICE_ACCEPT_SHUTDOWN
            | SERVICE_ACCEPT_PARAMCHANGE
            | SERVICE_ACCEPT_NETBINDCHANGE
            | SERVICE_ACCEPT_HARDWAREPROFILECHANGE
            | SERVICE_ACCEPT_POWEREVENT;
        break;
    case SERVICE_START_PENDING:
    case SERVICE_CONTINUE_PENDING:
    case SERVICE_PAUSE_PENDING:
        g_state.servicestatus.dwControlsAccepted=SERVICE_ACCEPT_STOP
          //| SERVICE_ACCEPT_PAUSE_CONTINUE
            | SERVICE_ACCEPT_SHUTDOWN
            | SERVICE_ACCEPT_PARAMCHANGE
            | SERVICE_ACCEPT_NETBINDCHANGE
            | SERVICE_ACCEPT_HARDWAREPROFILECHANGE
            | SERVICE_ACCEPT_POWEREVENT;
        break;
    }
    g_state.servicestatus.dwWin32ExitCode = HRESULT_CODE(dwExitCode);
    g_state.servicestatus.dwServiceSpecificExitCode = 0;
    g_state.servicestatus.dwCheckPoint=dwCheckPoint;
    g_state.servicestatus.dwWaitHint=dwWaitHint;

    if (!fnW32TmSetServiceStatus(g_state.servicestatushandle, &g_state.servicestatus)) {
        _JumpLastError(hr, error, "fnW32TmSetServiceStatus");
    }

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
// for start/stop/pause pending
MODULEPRIVATE HRESULT MySetServicePending(DWORD dwCurrentState, DWORD dwCheckPoint, DWORD dwWaitHint) {
    return MySetServiceStatus(dwCurrentState, dwCheckPoint, dwWaitHint, S_OK);
}

//--------------------------------------------------------------------
// for running/paused
MODULEPRIVATE HRESULT MySetServiceState(DWORD dwCurrentState) {
    return MySetServiceStatus(dwCurrentState, 0, 0, S_OK);
}
 
//--------------------------------------------------------------------
// for stop
MODULEPRIVATE HRESULT MySetServiceStopped(HRESULT hr) {

    return MySetServiceStatus(SERVICE_STOPPED, 0, 0, hr);
}
 
//--------------------------------------------------------------------
MODULEPRIVATE HRESULT SaveLastClockRate(void) {
    HRESULT hr;
    if (e_Sync==g_state.lcState && e_ClockNotSynchronized!=g_state.eLeapIndicator) {
        HKEY hkKey;
        hr=RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyConfig, NULL, KEY_SET_VALUE, &hkKey);
        hr=HRESULT_FROM_WIN32(hr);
        _JumpIfError(hr, error, "RegOpenKeyEx");

        hr=RegSetValueEx(hkKey, wszW32TimeRegValueLastClockRate, NULL, REG_DWORD, (BYTE *)&g_state.dwClockRate, sizeof(DWORD));
        hr=HRESULT_FROM_WIN32(hr);
        RegCloseKey(hkKey);
        _JumpIfError(hr, error, "RegSetValueEx");
    }
    hr=S_OK;
error:
    return hr;
}
        

//--------------------------------------------------------------------
// Stops the time service. 
//
MODULEPRIVATE void ServiceShutdown(DWORD dwExitCode) { 
    BOOL    fResult; 
    HRESULT hr        = dwExitCode; 
    HRESULT hr2; 
    int     nCheckpoint = 2; 

    // Events registered with the thread pool: 
    HANDLE  *rghRegistered[] = { 
        &g_state.hRegisteredManagerParamChangeEvent,
	&g_state.hRegisteredManagerGPUpdateEvent,
        &g_state.hRegisteredNetTopoChangeEvent,
        &g_state.hRegisteredTimeSlipEvent, 
        &g_state.hRegisteredClockDisplnThread, 
        &g_state.hRegisteredDomHierRoleChangeEvent, 
        &g_state.hRegisteredSamplesAvailEvent 
    }; 

    FileLog1(FL_ServiceMainAnnounce, L"Service shutdown initiated with exit code: %d.\n", dwExitCode);

    hr2=MySetServicePending(SERVICE_STOP_PENDING, nCheckpoint++, WAITHINT_WAITFORDISPLN);
    _TeardownError(hr, hr2, "MySetServicePending");

    // Next, de-register all events in the thread pool: 
    for (int nIndex = 0; nIndex < ARRAYSIZE(rghRegistered); nIndex++) { 
        if (NULL != *(rghRegistered[nIndex])) { 
            if (!UnregisterWaitEx(*(rghRegistered[nIndex]) /*event to de-register*/, INVALID_HANDLE_VALUE /*wait forever*/)) { 
                hr2 = HRESULT_FROM_WIN32(GetLastError()); 
                _TeardownError(hr, hr2, "UnregisterWaitEx"); 
            }
	    // Don't want to unregister twice under any circumstances
	    *(rghRegistered[nIndex]) = NULL; 
            hr2=MySetServicePending(SERVICE_STOP_PENDING, nCheckpoint++, WAITHINT_WAITFORDISPLN);
            _TeardownError(hr, hr2, "MySetServicePending");
        }
    } 

    // Delete the timer queue.  This must be done before shutting down the
    // clock discipline thread, as a timer queue timeout can block waiting
    // for a "clock command complete" event, generated by the clock 
    // discipline thread.  
    if (NULL != g_state.hTimer) { 
	myDeleteTimerQueueTimer(NULL /*default queue*/, g_state.hTimer, INVALID_HANDLE_VALUE /*blocking*/); 
	g_state.hTimer = NULL; 
    }

    // Set the shutdown event.  This should stop the clock discipline thread.
    if (NULL != g_state.hShutDownEvent) { 
	if (!SetEvent(g_state.hShutDownEvent)) { 
	    hr2 = HRESULT_FROM_WIN32(GetLastError()); 
	    _TeardownError(hr, hr2, "SetEvent"); 
	} else { 
	    // wait for the clock discipline thread to finish
	    if (-1 == WaitForSingleObject(g_state.hClockDisplnThread, INFINITE)) { 
		hr2=HRESULT_FROM_WIN32(GetLastError()); 
		_TeardownError(hr, hr2, "WaitForSingleObject"); 
	    }
	    else { 
		// we haven't errored out yet -- check that the clock discipline
		// thread shut down correctly:
		if (!GetExitCodeThread(g_state.hClockDisplnThread, (DWORD *)&hr)) { 
		    hr2=HRESULT_FROM_WIN32(GetLastError()); 
		    _TeardownError(hr, hr2, "GetExitCodeThread");
		}
	    }
	}
    }

    // stash the last clock rate, if possible
    hr2 = SaveLastClockRate();
    _TeardownError(hr, hr2, "SaveLastClockRate");
    
    // shutdown stage 2: wait for providers, if the provider list has been initialized
    if (NULL != g_state.pciConfig) { 
        for (TimeProvider *ptpList=g_state.pciConfig->ptpProviderList; NULL!=ptpList; nCheckpoint++, ptpList=ptpList->ptpNext) {
            hr2=MySetServicePending(SERVICE_STOP_PENDING, nCheckpoint, WAITHINT_WAITFORPROV);
            _TeardownError(hr, hr2, "MySetServicePending");
            
            // tell the provider to shut down.  
            hr2=StopProvider(ptpList);
            _TeardownError(hr, hr2, "StopProvider");
            
        } // <- end provider shutdown loop
        // the timeprov list will be freed later
    }

    hr2 = LsaUnregisterPolicyChangeNotification(PolicyNotifyServerRoleInformation, g_state.hDomHierRoleChangeEvent);
    if (ERROR_SUCCESS != hr2) {
        hr2 = HRESULT_FROM_WIN32(LsaNtStatusToWinError(hr2));
        _TeardownError(hr, hr2, "LsaUnegisterPolicyChangeNotification");
    }
    
    hr2=ShutdownNetlogonServiceBits();
    _TeardownError(hr, hr2, "ShutdownNetlogonServiceBits");

    if (true==g_state.bRpcServerStarted) {
        hr2=W32TmStopRpcServer();
        _TeardownError(hr, hr2, "W32TmStopRpcServer");
    }


    if (true==g_state.bNetTopoChangeNotificationStarted) {
        hr2=StopNetTopoChangeNotification();
        _TeardownError(hr, hr2, "StopNetTopoChangeNotification");
    }
    if (true==g_state.bGPNotificationStarted) { 
        if (!UnregisterGPNotification(g_state.hManagerGPUpdateEvent)) { 
            hr2 = HRESULT_FROM_WIN32(GetLastError()); 
            _TeardownError(hr, hr2, "UnregisterGPNotification"); 
        }
    }
    if (true==g_state.bTimeSlipNotificationStarted) {
        hr2=StartOrStopTimeSlipNotification(false);
        _TeardownError(hr, hr2, "StartOrStopTimeSlipNotification");
    }

    FileLog0(FL_ServiceMainAnnounce, L"Exiting ServiceShutdown\n");
    FileLogEnd();
    if (NULL!=g_state.servicestatushandle) {
        // WARNING: The process may be killed after we report we are stopped
        // even though this thread has not exited. Thus, the file log
        // must be closed before this call.
        MySetServiceStopped(hr);  
    }
    
    FreeGlobalState();
    FreeShutdownState(); 
    DebugWPrintfTerminate();
    return;
}


//--------------------------------------------------------------------
// NOTE: this function should not be called directly.  Rather, it should
//       be invoked through SendServiceShutdown(), which protects against
//       multiple concurrent shutdowns. 
MODULEPRIVATE DWORD WINAPI SendServiceShutdownWorker(PVOID pvErr)
{
    DWORD         dwErr              = (UINT_PTR)pvErr; 
    HRESULT       hr; 
    WCHAR         wszNumberBuf[20]; 
    const WCHAR  *rgwszStrings[1]    = { wszNumberBuf }; 

    // 1) On failure, log an event indicating that we are shutting down. 
    if (S_OK != dwErr) { 

	swprintf(wszNumberBuf, L"0x%08X", dwErr); 

	    // Log an event indicating that the service is shutting down: 
	    hr = MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_ERROR_SHUTDOWN, 1, rgwszStrings);
	    _IgnoreIfError(hr, "MyLogEvent"); 
	}
    
    // 2) Actually shut down the time service: 
    ServiceShutdown(dwErr); 

    return S_OK; 
}

//--------------------------------------------------------------------
// NOTE: this function should not be called directly.  Rather, it should
//       be invoked through SendServiceShutdown(), which protects against
//       multiple concurrent shutdowns. 
MODULEPRIVATE DWORD WINAPI SendServiceRestartWorker(PVOID pvErr)
{
    HRESULT hr;

    hr = SendServiceShutdownWorker(pvErr); 
    _IgnoreIfError(hr, "SendServiceShutdownWorker"); 

    // Restart the service
    // W32TmServiceMain(0, NULL); 

    return S_OK; 
}

//--------------------------------------------------------------------
// Asynchronously queues a shutdown request for the time service
MODULEPRIVATE HRESULT SendServiceShutdown(DWORD dwErr, BOOL bRestartService, BOOL bAsync) { 
    HRESULT hr; 
    LPTHREAD_START_ROUTINE pfnShutdownWorker; 

    // See if we're already shutting down: 
    hr = StartShutdown(); 
    _JumpIfError(hr, error, "StartShutdown"); 

    if (bRestartService) { 
	pfnShutdownWorker = SendServiceRestartWorker;
    } else { 
	pfnShutdownWorker = SendServiceShutdownWorker;
    }
	
    if (bAsync) { 
	if (!QueueUserWorkItem(pfnShutdownWorker, UIntToPtr(dwErr), 0)) { 
	    _JumpLastError(hr, error, "QueueUserWorkItem"); 
	}
    } else { 
	hr = pfnShutdownWorker(UIntToPtr(dwErr)); 
	_JumpIfError(hr, error, "pfnShutdownWorker"); 
    }
	
    hr = S_OK; 
 error:
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE DWORD WINAPI W32TimeServiceCtrlHandler(DWORD dwControl, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext) {
    bool     bHandled             = false;
    bool     bShutdownDisallowed  = false; 
    HRESULT  hr;

    // We don't want to be shutdown while processing a service control
    hr = AllowShutdown(false); 
    _JumpIfError(hr, error, "AllowShutdown"); 
    bShutdownDisallowed = true; 

    FileLog0(FL_ServiceControl, L"W32TimeHandler called: ");
    switch (dwControl) {
    case SERVICE_CONTROL_STOP:
        FileLogA0(FL_ServiceControl, L"SERVICE_CONTROL_STOP\n"); 

        // Let the SCM know we're shutting down...
        hr=MySetServicePending(SERVICE_STOP_PENDING, 1, WAITHINT_WAITFORMANAGER);
        _JumpIfError(hr, error, "MySetServicePending");

	// We can't attempt to shutdown the service is shutdown is disallowed!
	hr = AllowShutdown(true); 
	_JumpIfError(hr, error, "AllowShutdown"); 
	bShutdownDisallowed = false; 

        // Stop the service.  
        SendServiceShutdown(g_state.servicestatus.dwWin32ExitCode, FALSE /*don't restart*/, TRUE /*async*/); 
        bHandled=true;
        break; 
    case SERVICE_CONTROL_PAUSE:
        FileLogA0(FL_ServiceControl, L"SERVICE_CONTROL_PAUSE\n"); break;
    case SERVICE_CONTROL_CONTINUE:
        FileLogA0(FL_ServiceControl, L"SERVICE_CONTROL_CONTINUE\n"); break;
    case SERVICE_CONTROL_INTERROGATE:
        FileLogA0(FL_ServiceControl, L"SERVICE_CONTROL_INTERROGATE\n"); 
        // our default handling is the right thing to do
        break;
    case SERVICE_CONTROL_SHUTDOWN:
	FileLogA0(FL_ServiceControl, L"SERVICE_CONTROL_SHUTDOWN\n"); 

	// We can't attempt to shutdown the service is shutdown is disallowed!
	hr = AllowShutdown(true); 
	_JumpIfError(hr, error, "AllowShutdown"); 
	bShutdownDisallowed = false; 

	// Perform minimal shutdown. 
        HandleManagerSystemShutdown();
	bHandled=true; 
	break;
    case SERVICE_CONTROL_PARAMCHANGE:
        FileLogA0(FL_ServiceControl, L"SERVICE_CONTROL_PARAMCHANGE\n"); 
        // We could handle this in the current thread, but this could take
        // a while, so we use the thread pool instead. 
        if (!SetEvent(g_state.hManagerParamChangeEvent)) {
            _JumpLastError(hr, error, "SetEvent");
        }
        // our default handling is the right thing to do
        break;
    case SERVICE_CONTROL_NETBINDADD:
        FileLogA0(FL_ServiceControl, L"SERVICE_CONTROL_NETBINDADD\n"); break;
    case SERVICE_CONTROL_NETBINDREMOVE:
        FileLogA0(FL_ServiceControl, L"SERVICE_CONTROL_NETBINDREMOVE\n"); break;
    case SERVICE_CONTROL_NETBINDENABLE:
        FileLogA0(FL_ServiceControl, L"SERVICE_CONTROL_NETBINDENABLE\n"); break;
    case SERVICE_CONTROL_NETBINDDISABLE:
        FileLogA0(FL_ServiceControl, L"SERVICE_CONTROL_NETBINDDISABLE\n"); break;
    case SERVICE_CONTROL_DEVICEEVENT:
        FileLogA2(FL_ServiceControl, L"SERVICE_CONTROL_DEVICEEVENT(0x%08X, 0x%p)\n", dwEventType, lpEventData); break;
    case SERVICE_CONTROL_HARDWAREPROFILECHANGE:
        FileLogA2(FL_ServiceControl, L"SERVICE_CONTROL_HARDWAREPROFILECHANGE(0x%08X, 0x%p)\n", dwEventType, lpEventData); break;
    case SERVICE_CONTROL_POWEREVENT:
        FileLogA2(FL_ServiceControl, L"SERVICE_CONTROL_POWEREVENT(0x%08X, 0x%p)\n", dwEventType, lpEventData); 

        switch (dwEventType) 
            { 
            case PBT_APMSUSPEND: 
                // System is suspending operation. 
                hr = HandleManagerApmSuspend(); 
                _JumpIfError(hr, error, "HandleManagerApmSuspend"); 
                break; 

            case PBT_APMRESUMECRITICAL:      
            case PBT_APMRESUMESUSPEND:  
		// NOTE: services will get APMRESUMESUSPEND regardless of whether we're recovering from 
		//       a critical suspension.  So, we need our code to handle a resume without knowing
		//       

                // Operation resuming after suspension. 
                hr = HandleManagerApmResumeSuspend(); 
                _JumpIfError(hr, error, "HandleManagerApmResumeSuspend"); 
                break; 

            case PBT_APMQUERYSUSPENDFAILED:  // Suspension request denied. 
            case PBT_APMQUERYSUSPEND:        // Request for permission to suspend. 
            case PBT_APMBATTERYLOW:          // Battery power is low. 
            case PBT_APMRESUMEAUTOMATIC:     // Operation resuming automatically after event. 
            case PBT_APMOEMEVENT:            // OEM-defined event occurred. 
            case PBT_APMPOWERSTATUSCHANGE:   // Power status has changed. 
                // These power events don't need to be handled by w32time.
                break;
            default:
                hr = E_INVALIDARG; 
                _JumpError(hr, error, "SERVICE_CONTROL_POWEREVENT: bad wparam."); 
            }
        break; 

    default:
        FileLogA3(FL_ServiceControl, L"unknown service control (0x%08X, 0x%08X, 0x%p)\n", dwControl, dwEventType, lpEventData); break;
    }

    hr=S_OK;
 error:
    if (!bHandled) {
        HRESULT hr2=MySetServiceStatus(g_state.servicestatus.dwCurrentState, g_state.servicestatus.dwCheckPoint, 
            g_state.servicestatus.dwWaitHint, g_state.servicestatus.dwServiceSpecificExitCode);
        _TeardownError(hr, hr2, "MySetServiceStatus");
    }
    if (bShutdownDisallowed) { 
	HRESULT hr2 = AllowShutdown(true); 
	_TeardownError(hr, hr2, "AllowShutdown"); 
    }
    _IgnoreIfError(hr, "W32TimeServiceCtrlHandler");
    return NO_ERROR;
}


//--------------------------------------------------------------------
// read the provider list from the registry
MODULEPRIVATE HRESULT GetEnabledProviderList(TimeProvider ** pptpList) {
    HRESULT hr;
    DWORD dwError;
    unsigned int nKeyIndex;
    WCHAR wszNameBuf[MAX_PATH];
    DWORD dwNameLength;
    FILETIME ftLastWrite;
    DWORD dwType;
    DWORD dwEnabled;
    DWORD dwSize;
    WCHAR wszDllBuf[MAX_PATH];
    DWORD dwInputProvider;

    // must be cleaned up
    HKEY hkTimeProvs=NULL;
    HKEY hkCurProv=NULL;
    TimeProvider * ptpList=NULL;
    TimeProvider * ptpNew=NULL;

    // initialize out params
    *pptpList=NULL;

    // get the key with the time providers
    dwError=RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyTimeProviders, 0, KEY_READ, &hkTimeProvs);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegOpenKeyEx", wszW32TimeRegKeyTimeProviders);
    }

    // enumerate the subkeys
    for (nKeyIndex=0; true; nKeyIndex++) {
        // get the next key name
        dwNameLength=MAX_PATH;
        dwError=RegEnumKeyEx(hkTimeProvs, nKeyIndex, wszNameBuf, &dwNameLength, NULL, NULL, NULL, &ftLastWrite);
        if (ERROR_NO_MORE_ITEMS==dwError) {
            break;
        } else if (ERROR_SUCCESS!=dwError) {
            hr=HRESULT_FROM_WIN32(dwError);
            _JumpError(hr, error, "RegEnumKeyEx",);
        }
        FileLog1(FL_ReadConigAnnounceLow, L"ReadConfig: Found provider '%s':\n", wszNameBuf);

        // get the key of the current time provider
        dwError=RegOpenKeyEx(hkTimeProvs, wszNameBuf, 0, KEY_READ, &hkCurProv);
        if (ERROR_SUCCESS!=dwError) {
            hr=HRESULT_FROM_WIN32(dwError);
            _JumpErrorStr(hr, error, "RegOpenKeyEx", wszNameBuf);
        }

        // see if the provider is enabled
        dwSize=sizeof(DWORD);
        dwError=RegQueryValueEx(hkCurProv, wszW32TimeRegValueEnabled, NULL, &dwType, (BYTE *)&dwEnabled, &dwSize);
        if (ERROR_SUCCESS!=dwError) {
            hr=HRESULT_FROM_WIN32(dwError);
            _JumpErrorStr(hr, error, "RegQueryValueEx", wszW32TimeRegValueEnabled);
        } else {
            _Verify(REG_DWORD==dwType, hr, error);
            FileLog2(FL_ReadConigAnnounceLow, L"ReadConfig:   '%s'=0x%08X\n", wszW32TimeRegValueEnabled, dwEnabled);
            if (0!=dwEnabled) {
                // use this provider

                // get the dll name
                dwSize=MAX_PATH*sizeof(WCHAR);
                dwError=RegQueryValueEx(hkCurProv, wszW32TimeRegValueDllName, NULL, &dwType, (BYTE *)wszDllBuf, &dwSize);
                if (ERROR_SUCCESS!=dwError) {
                    hr=HRESULT_FROM_WIN32(dwError);
                    _JumpErrorStr(hr, error, "RegQueryValueEx", wszW32TimeRegValueDllName);
                }
                _Verify(REG_SZ==dwType, hr, error);
                FileLog2(FL_ReadConigAnnounceLow, L"ReadConfig:   '%s'='%s'\n", wszW32TimeRegValueDllName, wszDllBuf);

                // get the provider type
                dwSize=sizeof(DWORD);
                dwError=RegQueryValueEx(hkCurProv, wszW32TimeRegValueInputProvider, NULL, &dwType, (BYTE *)&dwInputProvider, &dwSize);
                if (ERROR_SUCCESS!=dwError) {
                    hr=HRESULT_FROM_WIN32(dwError);
                    _JumpErrorStr(hr, error, "RegQueryValueEx", wszW32TimeRegValueInputProvider);
                }
                _Verify(REG_DWORD==dwType, hr, error);
                FileLog2(FL_ReadConigAnnounceLow, L"ReadConfig:   '%s'=0x%08X\n", wszW32TimeRegValueInputProvider, dwInputProvider);

                // create a new element
                ptpNew=(TimeProvider *)LocalAlloc(LPTR, sizeof(TimeProvider));
                _JumpIfOutOfMemory(hr, error, ptpNew);
                
                // copy the provider name
                ptpNew->wszProvName=(WCHAR *)LocalAlloc(LPTR, (wcslen(wszNameBuf)+1)*sizeof(WCHAR));
                _JumpIfOutOfMemory(hr, error, ptpNew->wszProvName);
                wcscpy(ptpNew->wszProvName, wszNameBuf);

                // copy the dll name
                ptpNew->wszDllName=(WCHAR *)LocalAlloc(LPTR, (wcslen(wszDllBuf)+1)*sizeof(WCHAR));
                _JumpIfOutOfMemory(hr, error, ptpNew->wszDllName);
                wcscpy(ptpNew->wszDllName, wszDllBuf);

                // set the provider type
                ptpNew->bInputProvider=(dwInputProvider?true:false);

                // add it to our list
                ptpNew->ptpNext=ptpList;
                ptpList=ptpNew;
                ptpNew=NULL;

            } // <- end if provider enabled
        } // <- end if query value 'enabled' successful

        // done with this key
        RegCloseKey(hkCurProv);
        hkCurProv=NULL;

    } // <- end provider enumeration loop

    // successful
    hr=S_OK;
    *pptpList=ptpList;
    ptpList=NULL;

error:
    if (NULL!=ptpNew) {
        if (NULL!=ptpNew->wszDllName) {
            LocalFree(ptpNew->wszDllName);
        }
        if (NULL!=ptpNew->wszProvName) {
            LocalFree(ptpNew->wszProvName);
        }
        LocalFree(ptpNew);
    }
    if (NULL!=hkTimeProvs) {
        RegCloseKey(hkCurProv);
    }
    if (NULL!=hkTimeProvs) {
        RegCloseKey(hkTimeProvs);
    }
    if (NULL!=ptpList) {
        FreeTimeProviderList(ptpList);
    }
    return hr;
}



//--------------------------------------------------------------------
// read the current configuration. This does not modify the active
// configuration, so that changed can be detected.
MODULEPRIVATE HRESULT ReadConfig(ConfigInfo ** ppciConfig) {
    HRESULT  hr;
    BOOL     bSyncToCmosDisabled;
    DWORD    dwCurrentSecPerTick;
    DWORD    dwDefaultSecPerTick;
    DWORD    dwError;
    DWORD    dwSize;
    DWORD    dwType;

    // must be cleaned up
    ConfigInfo  *pciConfig           = NULL;
    HKEY         hkPolicyConfig      = NULL;
    HKEY         hkPreferenceConfig  = NULL; 

    // allocate a new config structure
    pciConfig=(ConfigInfo *)LocalAlloc(LPTR, sizeof(ConfigInfo));
    _JumpIfOutOfMemory(hr, error, pciConfig);

    // get the list of providers
    hr=GetEnabledProviderList(&pciConfig->ptpProviderList);
    _JumpIfError(hr, error, "GetEnabledProviderList");

    // get our preference config key
    dwError=RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyConfig, 0, KEY_READ, &hkPreferenceConfig);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegOpenKeyEx", wszW32TimeRegKeyConfig);
    }

    // get our policy config key
    dwError=RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyPolicyConfig, 0, KEY_READ, &hkPolicyConfig);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        // May just not have policy settings on this machine -- that's OK. 
        _IgnoreErrorStr(hr, "RegOpenKeyEx", wszW32TimeRegKeyPolicyConfig);
    }

    // read all the values for the local clock configuration 
    // and service configuration
    {
        struct {
            WCHAR * wszRegValue;
            DWORD * pdwValue;
        } rgRegParams[]={
            {
                wszW32TimeRegValuePhaseCorrectRate,
                &pciConfig->lcci.dwPhaseCorrectRate
            },{
                wszW32TimeRegValueUpdateInterval,
                &pciConfig->lcci.dwUpdateInterval
            },{
                wszW32TimeRegValueFrequencyCorrectRate,
                &pciConfig->lcci.dwFrequencyCorrectRate
            },{
                wszW32TimeRegValuePollAdjustFactor,
                &pciConfig->lcci.dwPollAdjustFactor
            },{
                wszW32TimeRegValueLargePhaseOffset,
                &pciConfig->lcci.dwLargePhaseOffset
            },{
                wszW32TimeRegValueSpikeWatchPeriod,
                &pciConfig->lcci.dwSpikeWatchPeriod
            },{
                wszW32TimeRegValueHoldPeriod,
                &pciConfig->lcci.dwHoldPeriod
            },{
                wszW32TimeRegValueMinPollInterval,
                &pciConfig->lcci.dwMinPollInterval
            },{
                wszW32TimeRegValueMaxPollInterval,
                &pciConfig->lcci.dwMaxPollInterval
            },{
                wszW32TimeRegValueAnnounceFlags,
                &pciConfig->dwAnnounceFlags
            },{
                wszW32TimeRegValueLocalClockDispersion,
                &pciConfig->lcci.dwLocalClockDispersion
            },{
                wszW32TimeRegValueMaxNegPhaseCorrection,
                &pciConfig->lcci.dwMaxNegPhaseCorrection
            },{
                wszW32TimeRegValueMaxPosPhaseCorrection,
                &pciConfig->lcci.dwMaxPosPhaseCorrection
            },{
                wszW32TimeRegValueEventLogFlags,
                &pciConfig->dwEventLogFlags
            },{
                wszW32TimeRegValueMaxAllowedPhaseOffset, 
                &pciConfig->lcci.dwMaxAllowedPhaseOffset
            }

        };

        // for each param 
        for (unsigned int nParamIndex=0; nParamIndex<ARRAYSIZE(rgRegParams); nParamIndex++) {
            // Read in our preferences from the registry first.  
            dwSize=sizeof(DWORD);
            hr=MyRegQueryPolicyValueEx(hkPreferenceConfig, hkPolicyConfig, rgRegParams[nParamIndex].wszRegValue, NULL, &dwType, (BYTE *)rgRegParams[nParamIndex].pdwValue, &dwSize);
            _JumpIfErrorStr(hr, error, "MyRegQueryPolicyValueEx", rgRegParams[nParamIndex].wszRegValue);
            _Verify(REG_DWORD==dwType, hr, error);

            // Log the value we've acquired: 
            FileLog2(FL_ReadConigAnnounceLow, L"ReadConfig: '%s'=0x%08X\n", rgRegParams[nParamIndex].wszRegValue, *rgRegParams[nParamIndex].pdwValue);
        }
    }
    
    if (!GetSystemTimeAdjustment(&dwCurrentSecPerTick, &dwDefaultSecPerTick, &bSyncToCmosDisabled)) {
        _JumpLastError(hr, error, "GetSystemTimeAdjustment");
    }

    pciConfig->lcci.dwLastClockRate = dwDefaultSecPerTick; 
    pciConfig->lcci.dwMinClockRate  = dwDefaultSecPerTick-(dwDefaultSecPerTick/400); // 1/4%
    pciConfig->lcci.dwMaxClockRate  = dwDefaultSecPerTick+(dwDefaultSecPerTick/400); // 1/4%

    // success
    hr=S_OK;
    *ppciConfig=pciConfig;
    pciConfig=NULL;

error:
    if (NULL!=pciConfig) {
        FreeConfigInfo(pciConfig);
    }
    if (NULL!=hkPreferenceConfig) {
        RegCloseKey(hkPreferenceConfig);
    }
    if (NULL!=hkPolicyConfig) {
        RegCloseKey(hkPolicyConfig);
    }
    return hr;
}

//--------------------------------------------------------------------
// This function is passed to providers.
// No synchronization currently necessary.
MODULEPRIVATE HRESULT __stdcall MyLogTimeProvEvent(IN WORD wType, IN WCHAR * wszProvName, IN WCHAR * wszMessage) {
    if (NULL==wszProvName || NULL==wszMessage) {
        return E_INVALIDARG;
    }
    const WCHAR * rgwszStrings[2]={wszProvName, wszMessage};

    switch (wType) {
    case EVENTLOG_ERROR_TYPE:
        return MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_TIMEPROV_ERROR, 2, rgwszStrings);
    case EVENTLOG_WARNING_TYPE:
        return MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_TIMEPROV_WARNING, 2, rgwszStrings);
    case EVENTLOG_INFORMATION_TYPE:
        return MyLogEvent(EVENTLOG_INFORMATION_TYPE, MSG_TIMEPROV_INFORMATIONAL, 2, rgwszStrings);
    default:
        return E_INVALIDARG;
    };
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT __stdcall MyGetTimeSysInfo(IN TimeSysInfo eInfo, OUT void * pvInfo) {
    if (NULL==pvInfo) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    switch (eInfo) {

    case TSI_LastSyncTime:   // (unsigned __int64 *)pvInfo, NtTimeEpoch, in (10^-7)s
        *((unsigned __int64 *)pvInfo)=g_state.teLastSyncTime.getValue();
        break;

    case TSI_ClockTickSize:  // (unsigned __int64 *)pvInfo, NtTimePeriod, in (10^-7)s
        *((unsigned __int64 *)pvInfo)=g_state.dwClockRate;
        break;

    case TSI_ClockPrecision: // (  signed __int32 *)pvInfo, ClockTickSize, in log2(s)
        *((signed __int32 *)pvInfo)=g_state.nClockPrecision;
        break;

    case TSI_CurrentTime:    // (unsigned __int64 *)pvInfo, NtTimeEpoch, in (10^-7)s
        AccurateGetSystemTime(((unsigned __int64 *)pvInfo));
        break;

    case TSI_PhaseOffset:   // (  signed __int64 *)pvInfo, opaque
        *((signed __int64 *)pvInfo)=g_state.toSysPhaseOffset.getValue();
        break;

    case TSI_TickCount:      // (unsigned __int64 *)pvInfo, opaque
        AccurateGetTickCount(((unsigned __int64 *)pvInfo));
        break;

    case TSI_LeapFlags:      // (            BYTE *)pvInfo, a warning of an impending leap second or loss of synchronization
        *((BYTE *)pvInfo)=(BYTE)g_state.eLeapIndicator;
        break;

    case TSI_Stratum:        // (            BYTE *)pvInfo, how far away the computer is from a reference source
        *((BYTE *)pvInfo)=(BYTE)g_state.nStratum;
        break;

    case TSI_ReferenceIdentifier: // (      DWORD *)pvInfo, NtpRefId
        *((DWORD *)pvInfo)=g_state.refidSource.value;
        break;

    case TSI_PollInterval:   // (  signed __int32 *)pvInfo, poll interval, in log2(s)
        *((signed __int32 *)pvInfo)=g_state.nPollInterval;
        break;

    case TSI_RootDelay:      // (  signed __int64 *)pvInfo, NtTimeOffset, in (10^-7)s
        *((signed __int64 *)pvInfo)=g_state.toRootDelay.getValue();
        break;

    case TSI_RootDispersion: // (unsigned __int64 *)pvInfo, NtTimePeriod, in (10^-7)s
        *((unsigned __int64 *)pvInfo)=g_state.tpRootDispersion.getValue();
        break;

    case TSI_TSFlags:        // (           DWORD *)pvInfo, Time source flags
        *((DWORD *)pvInfo)=g_state.dwTSFlags;
        break;

    default:
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
    return S_OK;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT __stdcall MyAlertSamplesAvail(void) {
    HRESULT hr; 

    if (!SetEvent(g_state.hSamplesAvailEvent)) { 
	_JumpLastError(hr, error, "SetEvent"); 
    }

    hr = S_OK; 
 error:
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT __stdcall MySetProviderStatus(SetProviderStatusInfo *pspsi) { 
    HRESULT hr; 

    if (!QueueUserWorkItem(HandleSetProviderStatus, (LPVOID)pspsi, 0)) { 
        _JumpLastError(hr, error, "QueueUserWorkItem"); 
    }
    
    pspsi = NULL; 
    hr = S_OK; 
 error:
    if (NULL != pspsi) { 
        pspsi->pfnFree(pspsi); 
    }
    return hr; 
}

//====================================================================
// Provider control routines

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StartProvider(TimeProvider * ptp) {
    HRESULT hr;
    TimeProvOpenFunc * pfnTimeProvOpen;
    TimeProvSysCallbacks tpsc={
        sizeof(TimeProvSysCallbacks),
        MyGetTimeSysInfo,
        MyLogTimeProvEvent,
        MyAlertSamplesAvail,
        MySetProviderStatus
    };
    
    FileLog2(FL_ControlProvAnnounce, L"Starting '%s', dll:'%s'\n", ptp->wszProvName, ptp->wszDllName);
    ptp->hDllInst=LoadLibrary(ptp->wszDllName);
    if (NULL==ptp->hDllInst) {
        _JumpLastErrorStr(hr, error, "LoadLibrary", ptp->wszDllName);
    }

    ptp->pfnTimeProvClose=(TimeProvCloseFunc *)GetProcAddress(ptp->hDllInst, "TimeProvClose");
    if (NULL==ptp->pfnTimeProvClose) {
        _JumpLastError(hr, error, "GetProcAddress(TimeProvClose)");
    }

    ptp->pfnTimeProvCommand=(TimeProvCommandFunc *)GetProcAddress(ptp->hDllInst, "TimeProvCommand");
    if (NULL==ptp->pfnTimeProvCommand) {
        _JumpLastError(hr, error, "GetProcAddress(TimeProvCommand)");
    }

    pfnTimeProvOpen=(TimeProvOpenFunc *)GetProcAddress(ptp->hDllInst, "TimeProvOpen");
    if (NULL==pfnTimeProvOpen) {
        _JumpLastError(hr, error, "GetProcAddress(TimeProvOpen)");
    }

    // NOTE: this does not need to be synchronized because
    //       no other threads should be able to call into the time
    //       providers at the time of this call. 
    hr=pfnTimeProvOpen(ptp->wszProvName, &tpsc, &ptp->hTimeProv);
    _JumpIfError(hr, error, "pfnTimeProvOpen");

    hr=S_OK;
error:
    if (FAILED(hr)) {
        HRESULT hr2;
        WCHAR * wszError;
        const WCHAR * rgwszStrings[2]={
            ptp->wszProvName,
            NULL
        };

        hr2=GetSystemErrorString(hr, &wszError);
        _JumpIfError(hr2, suberror, "GetSystemErrorString");

        rgwszStrings[1]=wszError;
        FileLog2(FL_ControlProvWarn, L"Logging error: Time provider '%s' failed to start due to the following error: %s\n", ptp->wszProvName, wszError);
        hr2=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_TIMEPROV_FAILED_START, 2, rgwszStrings);
        _JumpIfError(hr2, suberror, "MyLogEvent");

        hr2=S_OK;
    suberror:
        if (NULL!=wszError) {
            LocalFree(wszError);
        }
        if (NULL!=ptp->hDllInst) {
            FreeLibrary(ptp->hDllInst);
        }
        _IgnoreIfError(hr2, "StartProvider");
    }

    return hr;
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StopProvider(TimeProvider * ptp) { 
    bool     bEnteredCriticalSection   = false; 
    HRESULT  hr;
    HRESULT  hr2;
    
    // must be cleaned up
    WCHAR * wszError=NULL;

    hr = myEnterCriticalSection(&g_state.csW32Time); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    _BeginTryWith(hr2) {
	if (NULL != ptp->pfnTimeProvClose) { 
	    // If we've initialized the provider callbacks, stop the provider
	    FileLog2(FL_ControlProvAnnounce, L"Stopping '%s', dll:'%s'\n", ptp->wszProvName, ptp->wszDllName);
	    hr2=ptp->pfnTimeProvClose(ptp->hTimeProv);
	} else { 
	    // We haven't initialized the callbacks: the provider is already stopped.
	    hr2 = S_OK;
	}
    } _TrapException(hr2);
    if (FAILED(hr2)) {
        // log an event on failure, but otherwise ignore it.
        const WCHAR * rgwszStrings[2]={
            ptp->wszProvName,
            NULL
        };

        // get the friendly error message
        hr=GetSystemErrorString(hr2, &wszError);
        _JumpIfError(hr, error, "GetSystemErrorString");

        // log the event
        rgwszStrings[1]=wszError;
        FileLog2(FL_ControlProvWarn, L"Logging error: The time provider '%s' returned the following error during shutdown: %s\n", ptp->wszProvName, wszError);
        hr=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_TIMEPROV_FAILED_STOP, 2, rgwszStrings);
        _JumpIfError(hr, error, "MyLogEvent");
    } 

    // release the dll
    if (!FreeLibrary(ptp->hDllInst)) {
        _JumpLastErrorStr(hr, error, "FreeLibrary", ptp->wszDllName);
    }

    hr=S_OK;
error:
    if (bEnteredCriticalSection) { 
        hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }
    if (NULL!=wszError) {
        LocalFree(wszError);
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT SendNotificationToProvider(TimeProvider * ptp, TimeProvCmd tpc, LPVOID pvArgs) {
    bool     bEnteredCriticalSection = false; 
    HRESULT  hr;
    HRESULT  hr2;

    // must be cleaned up
    WCHAR * wszError=NULL;

    hr = myEnterCriticalSection(&g_state.csW32Time); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    // send a "Param changed" message
    _BeginTryWith(hr2) {
        hr2=ptp->pfnTimeProvCommand(ptp->hTimeProv, tpc, pvArgs);
    } _TrapException(hr2);
    if (FAILED(hr2)) {
        // log an event on failure, but otherwise ignore it.
        const WCHAR * rgwszStrings[2]={
            ptp->wszProvName,
            NULL
        };

        // get the friendly error message
        hr=GetSystemErrorString(hr2, &wszError);
        _JumpIfError(hr, error, "GetSystemErrorString");

        // log the event
        rgwszStrings[1]=wszError;
        if (TPC_UpdateConfig==tpc) {
            FileLog2(FL_ControlProvWarn, L"Logging warning: The time provider '%s' returned an error while updating its configuration. The error will be ignored. The error was: %s\n", ptp->wszProvName, wszError);
            hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_TIMEPROV_FAILED_UPDATE, 2, rgwszStrings);
        } else if (TPC_PollIntervalChanged==tpc) {
            FileLog2(FL_ControlProvWarn, L"Logging warning: The time provider '%s' returned an error when notified of a polling interval change. The error will be ignored. The error was: %s\n", ptp->wszProvName, wszError);
            hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_TIMEPROV_FAILED_POLLUPDATE, 2, rgwszStrings);
        } else if (TPC_TimeJumped==tpc) {
            FileLog2(FL_ControlProvWarn, L"Logging warning: The time provider '%s' returned an error when notified of a time jump. The error will be ignored. The error was: %s\n", ptp->wszProvName, wszError);
            hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_TIMEPROV_FAILED_TIMEJUMP, 2, rgwszStrings);
        } else if (TPC_NetTopoChange==tpc) { 
            FileLog2(FL_ControlProvWarn, L"Logging warning: The time provider '%s' returned an error when notified of a net topography change. The error will be ignored. The error was: %s\n", ptp->wszProvName, wszError);
            hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_TIMEPROV_FAILED_NETTOPOCHANGE, 2, rgwszStrings); 
        }
        _JumpIfError(hr, error, "MyLogEvent");
    }

    hr=S_OK;
error:
    if (bEnteredCriticalSection) { 
        hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }
    if (NULL!=wszError) {
        LocalFree(wszError);
    }
    return hr;
}


//--------------------------------------------------------------------
MODULEPRIVATE void StartAllProviders(void) {
    HRESULT hr;
    TimeProvider ** pptpPrev=&(g_state.pciConfig->ptpProviderList);
    TimeProvider * ptpTravel=*pptpPrev;
    unsigned int nStarted=0;
    unsigned int nRequestedInputProviders=CountInputProvidersInList(g_state.pciConfig->ptpProviderList);

    FileLog0(FL_ControlProvAnnounce, L"Starting Providers.\n");
    while (NULL!=ptpTravel) {
        hr=StartProvider(ptpTravel);
        if (FAILED(hr)) {
            FileLog1(FL_ControlProvWarn, L"Discarding provider '%s'.\n", ptpTravel->wszProvName);
            *pptpPrev=ptpTravel->ptpNext;
            ptpTravel->ptpNext=NULL;
            FreeTimeProviderList(ptpTravel);
            ptpTravel=*pptpPrev;
        } else {
            nStarted++;
            pptpPrev=&ptpTravel->ptpNext;
            ptpTravel=ptpTravel->ptpNext;
        }
    }
    FileLog1(FL_ControlProvAnnounce, L"Successfully started %u providers.\n", nStarted);

    // if we were supposed to have time providers, but NONE started, log a big warning
    if (0==CountInputProvidersInList(g_state.pciConfig->ptpProviderList) && 0!=nRequestedInputProviders) {
        FileLog0(FL_ParamChangeWarn, L"Logging error: The time service has been configured to use one or more input providers, however, none of the input providers could be started. THE TIME SERVICE HAS NO SOURCE OF ACCURATE TIME.\n");
        hr=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_NO_INPUT_PROVIDERS_STARTED, 0, NULL);
        _IgnoreIfError(hr, "MyLogEvent");
    }

}

//====================================================================
// Local Clock

//--------------------------------------------------------------------
// Make sure that the system has a valid time zone. If not, log an
// error and set the time zone to a nice defualt (GMT)
MODULEPRIVATE HRESULT VerifyAndFixTimeZone(void) {
    HRESULT hr;
    TIME_ZONE_INFORMATION tzi;
    DWORD dwRetval;

    dwRetval=GetTimeZoneInformation(&tzi);
    if (TIME_ZONE_ID_STANDARD==dwRetval || TIME_ZONE_ID_DAYLIGHT==dwRetval || TIME_ZONE_ID_UNKNOWN==dwRetval) {
        // the system believes the time zone is valid
        // do one more sanity check - I saw a computer with a time zone bias of +2 years.
        // UTC = local time + bias 
        if (tzi.Bias<=TIMEZONEMAXBIAS && tzi.Bias>=-TIMEZONEMAXBIAS
            && tzi.DaylightBias<=TIMEZONEMAXBIAS && tzi.DaylightBias>=-TIMEZONEMAXBIAS
            && tzi.StandardBias<=TIMEZONEMAXBIAS && tzi.StandardBias>=-TIMEZONEMAXBIAS) {
            // looks OK
            FileLog0(FL_TimeZoneAnnounce, L"Time zone OK.\n");
            goto done;
        } else {
            // fall through and fix
        }
    }

    // set the time zone to GMT
    ZeroMemory(&tzi, sizeof(tzi));
    tzi.DaylightBias=-60;
    tzi.StandardDate.wMonth=10;
    tzi.StandardDate.wDay=5;
    tzi.StandardDate.wHour=2;
    tzi.DaylightDate.wMonth=3;
    tzi.DaylightDate.wDay=5;
    tzi.DaylightDate.wHour=1;
    wcscpy(tzi.StandardName, L"GMT Standard Time (Recovered)");
    wcscpy(tzi.DaylightName, L"GMT Daylight Time (Recovered)");

    if (!SetTimeZoneInformation(&tzi)) {
        hr=HRESULT_FROM_WIN32(GetLastError());

        // log an event on failure
        WCHAR * rgwszStrings[1]={NULL};
        HRESULT hr2=hr;
        hr=GetSystemErrorString(hr2, &(rgwszStrings[0]));
        _JumpIfError(hr, error, "GetSystemErrorString");
        FileLog1(FL_TimeZoneWarn, L"Logging error: The time service discovered that the system time zone information was corrupted. The time service tried to reset the system time zone to GMT, but failed. The time service cannot start. The error was: %s\n", rgwszStrings[0]);
        hr=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_TIME_ZONE_FIX_FAILED, 1, (const WCHAR **)rgwszStrings);
        LocalFree(rgwszStrings[0]);
        _JumpIfError(hr, error, "MyLogEvent");
        hr=hr2;

        _JumpError(hr, error, "SetTimeZoneInformation");
    }

    // Log the change
    FileLog0(FL_TimeZoneWarn, L"Logging warning: The time service discovered that the system time zone information was corrupted. Because many system components require valid time zone information, the time service has reset the system time zone to GMT. Use the Date/Time control panel if you wish to change the system time zone.\n");
    hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_TIME_ZONE_FIXED, 0, NULL);
    _JumpIfError(hr, error, "MyLogEvent");

done:
    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
// assert the time setting privilege
MODULEPRIVATE HRESULT GetPriveleges(void) {
    HRESULT hr;
    const unsigned int nPrivileges=2;

    // must be cleaned up
    HANDLE hProcToken=NULL;
    TOKEN_PRIVILEGES * ptp=NULL;

    // get the token for our process
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hProcToken)) {
        _JumpLastError(hr, error, "OpenProcessToken");
    }

    // allocate the list of privileges
    ptp=(TOKEN_PRIVILEGES *)LocalAlloc(LPTR, sizeof(TOKEN_PRIVILEGES)+(nPrivileges-ANYSIZE_ARRAY)*sizeof(LUID_AND_ATTRIBUTES));
    _JumpIfOutOfMemory(hr, error, ptp);

    // fill in the list of privileges
    ptp->PrivilegeCount=nPrivileges;

    // we want to change the system clock
    if (!LookupPrivilegeValue(NULL, SE_SYSTEMTIME_NAME, &(ptp->Privileges[0].Luid))) {
        _JumpLastError(hr, error, "LookupPrivilegeValue");
    }
    ptp->Privileges[0].Attributes=SE_PRIVILEGE_ENABLED;

    // we want increased priority
    if (!LookupPrivilegeValue(NULL, SE_INC_BASE_PRIORITY_NAME, &(ptp->Privileges[1].Luid))) {
        _JumpLastError(hr, error, "LookupPrivilegeValue");
    }
    ptp->Privileges[1].Attributes=SE_PRIVILEGE_ENABLED;


    // make the requested privilege change
    if (!AdjustTokenPrivileges(hProcToken, FALSE, ptp, 0, NULL, 0)) {
        _JumpLastError(hr, error, "AdjustTokenPrivileges");
    }

    hr=S_OK;
error:
    if (NULL!=hProcToken) {
        CloseHandle(hProcToken);
    }
    if (NULL!=ptp) {
        LocalFree(ptp);
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE BOOL IsTimeServiceReliable() { 
    BOOL bIsReliable; 

    // If we've been manually configured to be a reliable timeserv, 
    // we want to provide time even when unsync'd.
    // We are reliable if:
    //      a) We've been configured to always be reliable  
    //   OR b) We've been configured to automatically decide if we're reliable, and
    //         we are the root DC in a domain tree. 
    //       
    switch (Reliable_Timeserv_Announce_Mask & g_state.pciConfig->dwAnnounceFlags)
    {
    case Reliable_Timeserv_Announce_Yes: 
        bIsReliable = TRUE; 
        break;

    case Reliable_Timeserv_Announce_Auto:
        bIsReliable = g_state.bIsDomainRoot;
        break; 

    case Reliable_Timeserv_Announce_No:
    default: 
        bIsReliable = TRUE; 
    }

    return bIsReliable; 
}

//--------------------------------------------------------------------
//
// NOTE: This must be called in the clock discipline thread.
//
MODULEPRIVATE void SetClockUnsynchronized(LocalClockConfigInfo * plcci) {
    if (IsTimeServiceReliable()) { 
        g_state.eLeapIndicator=(NtpLeapIndicator)g_state.tsNextClockUpdate.nLeapFlags;
        g_state.nStratum=1;
        g_state.refidSource.value=NtpConst::dwLocalRefId;

        g_state.toRootDelay.setValue(0);
        g_state.tpRootDispersion.setValue(((unsigned __int64)plcci->dwLocalClockDispersion)*10000000);
        g_state.dwTSFlags=0;

        // Remember when we last processed a sample
        unsigned __int64 qwNow;
        AccurateGetSystemTime(&qwNow);
        g_state.teLastSyncTime.setValue(qwNow);
        }
    else { 
        // All other servers don't need this unconventional behavior, 
        // indicate that we are unsynchronized. 
        g_state.eLeapIndicator=e_ClockNotSynchronized;
        g_state.nStratum=0;
        g_state.refidSource.value=0;  // Unsynchronized
        }
     
    FileLog5(FL_ClockDisThrdAnnounce, L" LI:%u S:%u RDl:%I64d RDs:%I64u TSF:0x%X",
             g_state.eLeapIndicator,
             g_state.nStratum,
             g_state.toRootDelay.getValue(),
             g_state.tpRootDispersion.getValue(),
             g_state.dwTSFlags);
   

    //--------------------------------------------------------------------------------
    //
    // N.B. the following code is required to keep the software clock in sync
    //      with the cmos clock.  W32time controls the software clock using the
    //      system time adjustment.  This never gets propagated to the software
    //      clock.  GetSystemTime will read the software clock -- and SetSystemTime
    //      will actually write through to the CMOS clock.  
    // 
    //--------------------------------------------------------------------------------

    // Only push the value from the software to the CMOS clock if we need 
    // to, otherwise we degrade the accuracy of the CMOS clock. 
    if (g_state.bControlClockFromSoftware) 
    {
        bool bAcquired; 
        HRESULT hr = AcquireControlOfSystemClock(true /*acquire?*/, false /*block?*/, &bAcquired /*success?*/); 
        if (SUCCEEDED(hr) && bAcquired) { 
            SYSTEMTIME stTime; 

            GetSystemTime(&stTime); 
            if (!SetSystemTime(&stTime)) { 
                _IgnoreLastError("SetSystemTime"); 
                }	
    
            // Allow the interal CMOS clock to adjust time of day using its own internal mechanisms
            if (!SetSystemTimeAdjustment(0 /*ignored*/, TRUE /*cmos*/)) {  
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError()); 
                _IgnoreError(hr, "SetSystemTimeAdjustment"); 
                } 
            g_state.bControlClockFromSoftware = false; 

	        // Release control of the system clock
            hr = AcquireControlOfSystemClock(false /*acquire*/, false /*ignored*/, NULL /*ignored*/);
            _IgnoreIfError(hr, "AcquireControlOfSystemClock"); 
            }
        }

    { 
        // Don't want to advertise as a time service when we're unsynchronized
        HRESULT hr = UpdateNetlogonServiceBits(true /*full update*/); 
        _IgnoreIfError(hr, "UpdateNetlogonServiceBits"); 
    }
}

//--------------------------------------------------------------------
// Issues remaining:
// * poll update - is current alg sufficient?
// * What are proper values for dwPllLoopGain and dwPhaseCorrectRate?
MODULEPRIVATE DWORD WINAPI ClockDisciplineThread(void * pvIgnored) {
    HRESULT hr;
    DWORD dwWaitResult;
    DWORD dwError;
    unsigned int nIndex;
    LocalClockConfigInfo lcci;

    HANDLE rghWait[2]={
        g_state.hShutDownEvent,
        g_state.hClockCommandAvailEvent,
    };

    // initialize time variables
    g_state.toKnownPhaseOffset=0;
    AccurateGetTickCount(&g_state.qwPhaseCorrectStartTickCount);
    AccurateGetTickCount(&g_state.qwLastUpdateTickCount);
    g_state.nPhaseCorrectRateAdj=0;
    g_state.dwClockRate=g_state.pciConfig->lcci.dwLastClockRate; // special 'constant'
    g_state.nRateAdj=0;
    g_state.nFllRateAdj=0;
    g_state.nPllRateAdj=0;
    g_state.nErrorIndex=0;
    for (nIndex=0; nIndex<ClockFreqPredictErrBufSize; nIndex++) {
        g_state.rgdFllError[nIndex]=0;
        g_state.rgdPllError[nIndex]=0;
    };
    g_state.nSysDispersionIndex=0;
    for (nIndex=0; nIndex<SysDispersionBufSize; nIndex++) {
        g_state.rgtpSysDispersion[nIndex]=0;
    };
    g_state.nPollUpdateCounter=0;
    g_state.lcState=e_Unset;

    // the current source
    wcscpy(g_state.wszSourceName, wszW32TimeUNLocalCmosClock);
    // use this to see if the source changed. Time slip can cause the source to change,
    // but we don't want to log events if we go back to the same source after a time slip.
    wcscpy(g_state.wszPreTimeSlipSourceName, wszW32TimeUNLocalCmosClock);
    // just FYI, not used in a calculation
    wcscpy(g_state.wszPreUnsyncSourceName, wszW32TimeUNLocalCmosClock);

    // initialize 'constants'
    memcpy(&lcci, &g_state.pciConfig->lcci, sizeof(LocalClockConfigInfo));

    g_state.dwPllLoopGain=lcci.dwFrequencyCorrectRate*PLLLOOPGAINBASE; // number of ticks in 64s

    // assert the time setting privilege
    hr=GetPriveleges();
    _JumpIfError(hr, error, "GetPriveleges");

    // we need to be called at the right time.
    // (highest of any non-realtime. should be in realtime class?)
    if (!SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL)) {
        _JumpLastError(hr, error, "SetThreadPriority");
    }

    // initialize the state to unsynchronized
    FileLog0(FL_ClockDisThrdAnnounce, L"ClockDisciplineThread: Starting:");
    SetClockUnsynchronized(&lcci);
    FileLogA0(FL_ClockDisThrdAnnounce, L"\n");

    // tell the manager we're initialized
    if (!SetEvent(g_state.hClockCommandCompleteEvent)) {
        _JumpLastError(hr, error, "SetEvent");
    }

    // begin main event loop
    while (true) {
	// If we're controlling the computer clock ourselves, we need to wake up to discipline it.  
	// If the computer clock is being controlled from CMOS, wake up only often enough to update
	// our teLastSyncTime field.  This is necessary for reliable time servers that trust 
	// their local clock.  See bug #374491. 
	DWORD dwWaitTime = g_state.bControlClockFromSoftware ? lcci.dwUpdateInterval*10 : (NtpConst::tpMaxClockAge.qw / 2); // more careful calculation not worth the effort

        dwWaitResult=WaitForMultipleObjects(ARRAYSIZE(rghWait), rghWait, false/*any*/, dwWaitTime); 
        if (WAIT_FAILED==dwWaitResult) {
            _JumpLastError(hr, error, "WaitForMultipleObjects");
        } else if (WAIT_OBJECT_0==dwWaitResult) {
            // received stop request
            FileLog0(FL_ClockDisThrdAnnounce, L"ClockDisciplineThread: hShutDownEvent signaled. Exiting.\n");
            break;
        } else if (WAIT_OBJECT_0+1==dwWaitResult && e_ParamChange==g_state.eLocalClockCommand) {
            // Param change message
            FileLog0(FL_ClockDisThrdAnnounce, L"ClockDisciplineThread: ParamChange. Reloading constants.\n");

            // reinitialize 'constants'
            memcpy(&lcci, &g_state.pciConfig->lcci, sizeof(LocalClockConfigInfo));
            g_state.dwPllLoopGain=lcci.dwFrequencyCorrectRate*PLLLOOPGAINBASE; // number of ticks in 64s
            // note, dwLastClockRate is ignored.
            if (g_state.dwClockRate<lcci.dwMinClockRate) {
                FileLog0(FL_ClockDisThrdAnnounce, L"ClockDispln: ClockRate adjusted to keep in bounds\n");
                g_state.dwClockRate=lcci.dwMinClockRate;
            } else if (g_state.dwClockRate>lcci.dwMaxClockRate) {
                FileLog0(FL_ClockDisThrdAnnounce, L"ClockDispln: ClockRate adjusted to keep in bounds\n");
                g_state.dwClockRate=lcci.dwMaxClockRate;
            }
            if (NtpConst::dwLocalRefId==g_state.refidSource.value
                && ((unsigned __int64)lcci.dwLocalClockDispersion)*10000000!=g_state.tpRootDispersion.getValue()) {
                FileLog0(FL_ClockDisThrdAnnounce, L"ClockDispln: LocalClockDispersion adjusted.\n");
                g_state.tpRootDispersion.setValue(((unsigned __int64)lcci.dwLocalClockDispersion)*10000000); 
            }
            // toKnownPhaseOffset could be outside of dwMax(Neg/Pos)PhaseCorrection but it will be 
            // decreasing to 0 eventually. We will not worry about it.
        } else if (WAIT_TIMEOUT==dwWaitResult) { 
	    // See whether we're actually controlling the software clock ourselves:
	    if (!g_state.bControlClockFromSoftware) { 
		if (IsTimeServiceReliable()) { 
		    // We're a reliable time service syncing from our local clock.  Fake clock 
		    // updates so our clients don't filter us out for having an old update time. 
		    
		    unsigned __int64 qwNow;
		    AccurateGetSystemTime(&qwNow);
		    g_state.teLastSyncTime.setValue(qwNow);
		}
		// Nothing more to do, we're not disciplining the computer clock
		continue; 
	    } else { 
		// We're disciplining the computer clock.  Continue on...
	    }
	}

        // finish the outstanding phase correction
        unsigned __int64 qwPhaseCorrectionTicks;
        AccurateGetTickCount(&qwPhaseCorrectionTicks);
        qwPhaseCorrectionTicks-=g_state.qwPhaseCorrectStartTickCount;
        signed __int64 toPhaseCorrection=g_state.nPhaseCorrectRateAdj*((signed __int64)qwPhaseCorrectionTicks);
        g_state.toKnownPhaseOffset-=toPhaseCorrection;
        g_state.qwPhaseCorrectStartTickCount+=qwPhaseCorrectionTicks;
        g_state.toSysPhaseOffset.setValue(toPhaseCorrection+g_state.toSysPhaseOffset.getValue());

        FileLog0(FL_ClockDisThrdAnnounceLow, L"ClockDispln:");
        
        if (WAIT_OBJECT_0+1==dwWaitResult && (e_RegularUpdate==g_state.eLocalClockCommand || e_IrregularUpdate==g_state.eLocalClockCommand)) {
            // process new update
            FileLogA0(FL_ClockDisThrdAnnounce, L"ClockDispln Update:");

            // make sure return values are initialized
            g_state.bPollIntervalChanged=false;
            g_state.bClockJumped=false;
            g_state.bStaleData=false;
            g_state.bClockChangeTooBig=false;
            g_state.bSourceChanged=false;

            // only process this update if the sample is not older than the last processed sample
            if (g_state.tsNextClockUpdate.nSysTickCount<=g_state.qwLastUpdateTickCount) {
                FileLogA0(FL_ClockDisThrdAnnounce, L" *STALE*");
                g_state.bStaleData=true;
            } else {

                // calculate the time between updates
                unsigned __int64 qwUpdateTicks=g_state.tsNextClockUpdate.nSysTickCount-g_state.qwLastUpdateTickCount;
                g_state.qwLastUpdateTickCount+=qwUpdateTicks;

                // get the measured phase offset, accounting for known offset, and update known offset
                signed __int64 toSampleOffset=g_state.tsNextClockUpdate.toOffset+g_state.tsNextClockUpdate.nSysPhaseOffset-g_state.toSysPhaseOffset.getValue();
                signed __int64 toPhaseOffset=toSampleOffset-g_state.toKnownPhaseOffset;

                bool bPossibleSpike=(toPhaseOffset<-((signed __int64)lcci.dwLargePhaseOffset) || toPhaseOffset>((signed __int64)lcci.dwLargePhaseOffset) // default 128ms
                                        || toPhaseOffset<-((signed __int64)(qwUpdateTicks<<7)) || toPhaseOffset>((signed __int64)(qwUpdateTicks<<7)));      // watch for frequency spikes as well.

                FileLogA5(FL_ClockDisThrdAnnounce, L" SO:%I64d KPhO:%I64d %sPhO:%I64d uT:%I64u", toSampleOffset, g_state.toKnownPhaseOffset, (bPossibleSpike?L"*":L""), toPhaseOffset, qwUpdateTicks);

                if (((lcci.dwMaxNegPhaseCorrection != PhaseCorrect_ANY) && 
                     (toSampleOffset<-(signed __int64)(((unsigned __int64)lcci.dwMaxNegPhaseCorrection)*10000000)))
                    ||
                    ((lcci.dwMaxPosPhaseCorrection != PhaseCorrect_ANY) && 
                     (toSampleOffset>(signed __int64)(((unsigned __int64)lcci.dwMaxPosPhaseCorrection)*10000000)))) {
                    g_state.bClockChangeTooBig=true;
                    g_state.toIgnoredChange.qw=toSampleOffset;
                    FileLogA0(FL_ClockDisThrdAnnounce, L" *TOO BIG*");
                } else {

                    if (e_Unset==g_state.lcState) {
                        // we can't make frequency predictions until after the first update
                        // we believe this sample, so adjust the amount of phase offset we have left to correct.
                        g_state.toKnownPhaseOffset=toSampleOffset;
                    } else if (bPossibleSpike && (e_Spike==g_state.lcState || e_Sync==g_state.lcState)) {
                        // spike detector active - see if this large error is persistent
                    } else {
                        // we believe this sample, so adjust the amount of phase offset we have left to correct.
                        g_state.toKnownPhaseOffset=toSampleOffset;

                        // see how well FLL and PLL did at predicting this offset (zero==perfect frequency prediction)
                        double dFllPredictPhaseError=toPhaseOffset+(g_state.nRateAdj-g_state.nFllRateAdj)*((double)(signed __int64)qwUpdateTicks);
                        double dPllPredictPhaseError=toPhaseOffset+(g_state.nRateAdj-g_state.nPllRateAdj)*((double)(signed __int64)qwUpdateTicks);
                        FileLogA2(FL_ClockDisThrdAnnounce, L" FllPPE:%g PllPPE:%g", dFllPredictPhaseError, dPllPredictPhaseError);

                        // add these to our moving average buffer 
                        g_state.rgdFllError[g_state.nErrorIndex]=dFllPredictPhaseError*dFllPredictPhaseError;
                        g_state.rgdPllError[g_state.nErrorIndex]=dPllPredictPhaseError*dPllPredictPhaseError;
                        g_state.nErrorIndex=(g_state.nErrorIndex+1)%ClockFreqPredictErrBufSize;

                        // calculate the root-means-squared error for the last few FLL & PLL predictions
                        dFllPredictPhaseError=0;
                        dPllPredictPhaseError=0;
                        for (nIndex=0; nIndex<ClockFreqPredictErrBufSize; nIndex++) {
                            dFllPredictPhaseError+=g_state.rgdFllError[nIndex];
                            dPllPredictPhaseError+=g_state.rgdPllError[nIndex];
                        };
                        dFllPredictPhaseError=sqrt(dFllPredictPhaseError/ClockFreqPredictErrBufSize);
                        dPllPredictPhaseError=sqrt(dPllPredictPhaseError/ClockFreqPredictErrBufSize);
                        FileLogA2(FL_ClockDisThrdAnnounce, L" FllPPrE:%g PllPPrE:%g", dFllPredictPhaseError, dPllPredictPhaseError);

                        // allow for perfection
                        if (0==dFllPredictPhaseError && 0==dPllPredictPhaseError) {
                            dFllPredictPhaseError=1;
                        }

                        // calculate the new frequency predictions
                        g_state.nFllRateAdj=(signed __int32)(toPhaseOffset/((signed __int64)qwUpdateTicks)/((signed __int32)lcci.dwFrequencyCorrectRate));
                        g_state.nPllRateAdj=(signed __int32)(toPhaseOffset*((signed __int64)qwUpdateTicks)/((signed __int32)g_state.dwPllLoopGain)/((signed __int32)g_state.dwPllLoopGain));
                        FileLogA2(FL_ClockDisThrdAnnounce, L" FllRA:%d PllRA:%d", g_state.nFllRateAdj, g_state.nPllRateAdj);

                        // calculate the combined frequency prediction
                        g_state.nRateAdj=(signed __int32)((g_state.nFllRateAdj*dPllPredictPhaseError+g_state.nPllRateAdj*dFllPredictPhaseError)
                            /(dPllPredictPhaseError+dFllPredictPhaseError));

                        // Keep the clock rate in bounds
                        if ((g_state.nRateAdj<0 && g_state.dwClockRate<(unsigned __int32)(-g_state.nRateAdj)) 
                            || g_state.dwClockRate+g_state.nRateAdj<lcci.dwMinClockRate) {
                            FileLogA0(FL_ClockDisThrdAnnounce, L" [");
                            g_state.nRateAdj=lcci.dwMinClockRate-g_state.dwClockRate;
                        } else if ((g_state.nRateAdj>0 && g_state.dwClockRate<(unsigned __int32)(g_state.nRateAdj)) 
                            || g_state.dwClockRate+g_state.nRateAdj>lcci.dwMaxClockRate) {
                            FileLogA0(FL_ClockDisThrdAnnounce, L" ]");
                            g_state.nRateAdj=lcci.dwMaxClockRate-g_state.dwClockRate;
                        }

                        // calculate the new frequency
                        g_state.dwClockRate+=g_state.nRateAdj;
                        FileLogA2(FL_ClockDisThrdAnnounce, L" RA:%d CR:%u", g_state.nRateAdj, g_state.dwClockRate);

                        // calculate phase error due to use of incorrect rate since sample was taken
                        unsigned __int64 qwNewTicks;
                        AccurateGetTickCount(&qwNewTicks);
                        qwNewTicks-=g_state.qwLastUpdateTickCount;
                        signed __int64 toRateAdjPhaseOffset=((signed __int64)qwNewTicks)*g_state.nRateAdj;
                        g_state.toKnownPhaseOffset+=toRateAdjPhaseOffset;
                        FileLogA2(FL_ClockDisThrdAnnounce,L" nT:%I64u RAPhO:%I64d", qwNewTicks, toRateAdjPhaseOffset);

                    } // <- end if not first update


                    // add these dispersions to our moving average buffer 
                    g_state.rgtpSysDispersion[g_state.nSysDispersionIndex]=
                        g_state.tpSelectDispersion.qw*g_state.tpSelectDispersion.qw+
                        g_state.tsNextClockUpdate.tpDispersion*g_state.tsNextClockUpdate.tpDispersion;
                    g_state.nSysDispersionIndex=(g_state.nSysDispersionIndex+1)%SysDispersionBufSize;

                    // calculate the root-means-squared dispersion
                    unsigned __int64 tpSysDispersion=0;
                    for (nIndex=0; nIndex<SysDispersionBufSize; nIndex++) {
                        tpSysDispersion+=g_state.rgtpSysDispersion[nIndex];
                    };
                    tpSysDispersion=(unsigned __int64)sqrt(((double)(signed __int64)tpSysDispersion)/SysDispersionBufSize); //compiler error C2520: conversion from unsigned __int64 to double not implemented, use signed __int64
                    FileLogA1(FL_ClockDisThrdAnnounce, L" SD:%I64u", tpSysDispersion);

                    // see if we need to change the poll interval
                    unsigned __int64 tpAbsPhaseOffset;
                    if (toPhaseOffset<0) {
                        tpAbsPhaseOffset=(unsigned __int64)-toPhaseOffset;
                    } else {
                        tpAbsPhaseOffset=(unsigned __int64)toPhaseOffset;
                    }
                    if (e_IrregularUpdate==g_state.eLocalClockCommand) {
                        // do not adjust the poll because this update
                        // is irregular and not one of our scheduled updates. This
                        // prevents one hyperactive provider from driving
                        // the poll rate up for the other providers
                        FileLogA0(FL_ClockDisThrdAnnounce, L" (i)");
                    } else if (tpAbsPhaseOffset>lcci.dwPollAdjustFactor*tpSysDispersion) {
                        g_state.nPollUpdateCounter=0;
                        if (g_state.nPollInterval>((signed int)lcci.dwMinPollInterval)) {
                            FileLogA0(FL_ClockDisThrdAnnounce, L" Poll--");
                            g_state.nPollInterval--;
                            g_state.bPollIntervalChanged=true;
                        }
                    } else {
                        g_state.nPollUpdateCounter++;
                        if (SysDispersionBufSize==g_state.nPollUpdateCounter
                            && g_state.nPollInterval<((signed int)lcci.dwMaxPollInterval)) {
                            FileLogA0(FL_ClockDisThrdAnnounce, L" Poll++");
                            g_state.nPollUpdateCounter=0;
                            g_state.nPollInterval++;
                            g_state.bPollIntervalChanged=true;
                        }
                    }

                    // update the other system parameters
                    g_state.eLeapIndicator=(NtpLeapIndicator)g_state.tsNextClockUpdate.nLeapFlags;
                    g_state.nStratum=g_state.tsNextClockUpdate.nStratum+1;
                    g_state.tsiNextClockUpdate.ptp->dwStratum=g_state.nStratum; 
                    g_state.refidSource.value=g_state.tsNextClockUpdate.dwRefid;
                    g_state.toRootDelay.setValue(g_state.tsNextClockUpdate.toDelay);
                    tpSysDispersion=g_state.tpSelectDispersion.qw+tpAbsPhaseOffset;
                    if (tpSysDispersion<NtpConst::tpMinDispersion.qw) {
                        tpSysDispersion=NtpConst::tpMinDispersion.qw;
                    }
                    g_state.tpRootDispersion.setValue(g_state.tsNextClockUpdate.tpDispersion+tpSysDispersion);
                    g_state.dwTSFlags=g_state.tsNextClockUpdate.dwTSFlags;
                    FileLogA5(FL_ClockDisThrdAnnounce, L" LI:%u S:%u RDl:%I64d RDs:%I64u TSF:0x%X",
                        g_state.eLeapIndicator,
                        g_state.nStratum,
                        g_state.toRootDelay.getValue(),
                        g_state.tpRootDispersion.getValue(),
                        g_state.dwTSFlags);

                    // update our source
                    g_state.tsNextClockUpdate.wszUniqueName[255]=L'\0';
                    if (0!=wcscmp(g_state.tsNextClockUpdate.wszUniqueName, g_state.wszPreTimeSlipSourceName)) {
                        g_state.bSourceChanged=true;
                        wcscpy(g_state.wszPreTimeSlipSourceName, g_state.tsNextClockUpdate.wszUniqueName);
                        wcscpy(g_state.wszSourceName, g_state.tsNextClockUpdate.wszUniqueName);
                    }
		    // We've got time samples, so we're able to control the clock ourselves...
		    g_state.bControlClockFromSoftware = true; 

                    // Remember when we last processed a sample
                    unsigned __int64 qwNow;
                    AccurateGetSystemTime(&qwNow);
                    g_state.teLastSyncTime.setValue(qwNow);

                    // perform state transitions
                    if (e_Unset==g_state.lcState) {
                        FileLogA0(FL_ClockDisThrdAnnounce, L" Unset->Hold");
                        g_state.lcState=e_Hold;
                        g_state.nHoldCounter=0;
                    } else if (e_Hold==g_state.lcState) {
                        FileLogA1(FL_ClockDisThrdAnnounce, L" Hold(%u)", g_state.nHoldCounter);
                        g_state.nHoldCounter++;
                        if (g_state.nHoldCounter>=lcci.dwHoldPeriod && !bPossibleSpike) { // default HoldPeriod: 5 updates
                            g_state.lcState=e_Sync;
                            FileLogA0(FL_ClockDisThrdAnnounce, L"->Sync");
                        }
                    } else if (e_Sync==g_state.lcState) {
                        FileLogA0(FL_ClockDisThrdAnnounce, L" Sync");
                        if (bPossibleSpike) {
                            g_state.lcState=e_Spike;
                            g_state.teSpikeStart=qwNow;
                            FileLogA0(FL_ClockDisThrdAnnounce, L"->Spike");
                        }
                    } else if (e_Spike==g_state.lcState) {
                        FileLogA0(FL_ClockDisThrdAnnounce, L" Spike");
                        if (!bPossibleSpike) {
                            g_state.lcState=e_Sync;
                            FileLogA0(FL_ClockDisThrdAnnounce, L"->Sync");
                        } else if (qwNow-g_state.teSpikeStart>(((unsigned __int64)lcci.dwSpikeWatchPeriod)*10000000)) { // default SpikeWatchPeriod: 900s
                            g_state.lcState=e_Unset;
                            g_state.eLeapIndicator=e_ClockNotSynchronized;
                            FileLogA0(FL_ClockDisThrdAnnounce, L"->Unset");
                        }
                    }
                
                }// <- end if not too big
            } // <- end if not stale update

            FileLogA0(FL_ClockDisThrdAnnounce,L"\n");

        } // <- end if update available
        if (WAIT_OBJECT_0+1==dwWaitResult && e_TimeSlip==g_state.eLocalClockCommand) {

            FileLog0(FL_ClockDisThrdAnnounce, L"ClockDispln TimeSlip:");
            g_state.bClockJumped=true;

            // reinitialize pretty much everything
            // internal state variables.
            g_state.toKnownPhaseOffset=0;
            AccurateGetTickCount(&g_state.qwPhaseCorrectStartTickCount);
            AccurateGetTickCount(&g_state.qwLastUpdateTickCount);
            g_state.nPhaseCorrectRateAdj=0;
            g_state.nRateAdj=0;
            g_state.nFllRateAdj=0;
            g_state.nPllRateAdj=0;
            g_state.nErrorIndex=0;
            for (nIndex=0; nIndex<ClockFreqPredictErrBufSize; nIndex++) {
                g_state.rgdFllError[nIndex]=0;
                g_state.rgdPllError[nIndex]=0;
            };
            // keep the system error history
            //g_state.nSysDispersionIndex=0;
            //for (nIndex=0; nIndex<SysDispersionBufSize; nIndex++) {
            //    g_state.rgtpSysDispersion[nIndex]=0;
            //};
            g_state.nPollUpdateCounter=0;
            g_state.lcState=e_Unset;

            wcscpy(g_state.wszSourceName, wszW32TimeUNFreeSysClock);

            // world visible state
            if (g_state.nPollInterval>((signed int)lcci.dwMinPollInterval)) {
                FileLogA0(FL_ClockDisThrdAnnounce, L" [Poll");
                g_state.nPollInterval=(signed int)lcci.dwMinPollInterval;
                g_state.bPollIntervalChanged=true;
            }
            SetClockUnsynchronized(&lcci);
            
            FileLogA0(FL_ClockDisThrdAnnounce, L"\n");
        } // <- end if time slip


        if (WAIT_OBJECT_0+1==dwWaitResult && e_GoUnsyncd==g_state.eLocalClockCommand) {
            // the manager says that it's been so long since the last sync that
            // we should be telling the world that we're running of the local clock,
            // not some other time source.
            // this doesn't affect our calculations, just what we report to the outside world
            FileLog0(FL_ClockDisThrdAnnounce, L"ClockDispln GoUnsyncd:");
            g_state.bSourceChanged=false;

            // set the source name, saving the old one
            if (0!=wcscmp(wszW32TimeUNFreeSysClock, g_state.wszPreTimeSlipSourceName)) {
                wcscpy(g_state.wszPreTimeSlipSourceName, wszW32TimeUNFreeSysClock);
                wcscpy(g_state.wszSourceName, wszW32TimeUNFreeSysClock);
                wcscpy(g_state.wszPreUnsyncSourceName, g_state.wszSourceName);
                g_state.bSourceChanged=true;
            }

            SetClockUnsynchronized(&lcci);
            FileLogA0(FL_ClockDisThrdAnnounce, L"\n");
        }


        // if we're controlling the clock ourselves, begin a new phase correction
        // add a little to the rate
	bool bAcquired = false;
	hr = AcquireControlOfSystemClock(true /*acquire?*/, false /*block?*/, &bAcquired /*success?*/); 
	_IgnoreIfError(hr, "AcquireControlOfSystemClock"); 
	bAcquired = SUCCEEDED(hr) && bAcquired; 
	if (g_state.bControlClockFromSoftware && bAcquired) { 
	    toPhaseCorrection=g_state.toKnownPhaseOffset;
	    toPhaseCorrection/=(signed __int32)lcci.dwPhaseCorrectRate;
	    toPhaseCorrection/=(signed __int32)lcci.dwUpdateInterval; // won't correct really small phase errors
	    g_state.nPhaseCorrectRateAdj=(signed __int32)toPhaseCorrection;
	    if (toPhaseCorrection<0) {
		toPhaseCorrection=-toPhaseCorrection;
	    }
        
	    // Used to compare against "dwMaxAllowedPhaseOffset"
	    signed __int64 toPhaseCorrectionInSeconds = g_state.toKnownPhaseOffset; 
	    if (toPhaseCorrectionInSeconds < 0) { 
		toPhaseCorrectionInSeconds = -toPhaseCorrectionInSeconds; 
	    }
	    toPhaseCorrectionInSeconds /= 10000000;  // Convert from 100ns units, to 1s units 	 

	    FileLog0(FL_ClockDisThrdAnnounceLow, L" "); 
	    if ((((unsigned __int32)toPhaseCorrection)>g_state.dwClockRate/2) || 
		((unsigned __int32)toPhaseCorrectionInSeconds > lcci.dwMaxAllowedPhaseOffset)) { 
		if (WAIT_OBJECT_0+1==dwWaitResult) {
		    // too far out of whack to slew - just jump to the correct time
		    unsigned __int64 teSysTime;
		    AccurateGetSystemTime(&teSysTime);
		    teSysTime+=g_state.toKnownPhaseOffset;
		    AccurateSetSystemTime(&teSysTime);
		    g_state.toClockJump.qw=g_state.toKnownPhaseOffset;
		    g_state.nPhaseCorrectRateAdj=0;
		    g_state.toSysPhaseOffset.setValue(g_state.toKnownPhaseOffset+g_state.toSysPhaseOffset.getValue());
		    g_state.toKnownPhaseOffset=0;
		    FileLogA1(FL_ClockDisThrdAnnounceLow, L" PhCRA:%I64d *SET*TIME*", toPhaseCorrection);
		    g_state.bClockJumped=true;
		} else {
		    // This can only happen if we are making a large change and 
		    // this thread is preempted for so long that we overshoot. 
		    // This should be very rare.
		    if (g_state.toKnownPhaseOffset<0) { 
			toPhaseCorrection = -g_state.dwClockRate/2;
		    } else { 
			toPhaseCorrection =  g_state.dwClockRate/2; 
		    }
		}
	    }
	    // slew to correct time.
	    SetSystemTimeAdjustment(g_state.nPhaseCorrectRateAdj+g_state.dwClockRate, false/*no cmos*/);

	    FileLogA3(FL_ClockDisThrdAnnounceLow, L" PhCRA:%d phcT:%I64u KPhO:%I64d\n", g_state.nPhaseCorrectRateAdj, qwPhaseCorrectionTicks, g_state.toKnownPhaseOffset);
	}

	if (bAcquired) { 
	    // Release control of system clock:
	    hr = AcquireControlOfSystemClock(false /*acquire*/, false /*ignored*/, NULL /*ignored*/); 
	    _IgnoreIfError(hr, "AcquireControlOfSystemClock"); 
	}
	
        if (WAIT_OBJECT_0+1==dwWaitResult) {
            // ready for a new update
            if (!SetEvent(g_state.hClockCommandCompleteEvent)) {
                _JumpLastError(hr, error, "SetEvent");
            }
        }

    } // <- end main loop
    
    // BUGBUG: should we put this in serviceshutdown code? 
    SetSystemTimeAdjustment(lcci.dwLastClockRate, true/*cmos*/);

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StartClockDiscipline(void) {
    HRESULT hr;
    DWORD dwThreadID;

    g_state.hClockDisplnThread=CreateThread(NULL, NULL, ClockDisciplineThread, NULL, 0, &dwThreadID);
    if (NULL==g_state.hClockDisplnThread) {
        _JumpLastError(hr, error, "CreateThread");
    }

    { // wait for clock discipline thread to read the initial config
        HANDLE rghWait[2]={
            g_state.hClockCommandCompleteEvent,
            g_state.hClockDisplnThread
        };
        DWORD dwWaitResult;

        dwWaitResult=WaitForMultipleObjects(ARRAYSIZE(rghWait), rghWait, false, INFINITE);
        if (WAIT_FAILED==dwWaitResult) {
            _JumpLastError(hr, error, "WaitForMultipleObjects");
        } else if (WAIT_OBJECT_0==dwWaitResult) {
            // Command acknowledged
        } else {
            // the ClockDiscipline thread shut down!
            // fall outward to the manager thread main loop to analyze the issue.
        }
    }


    hr=S_OK;
error:
    return hr;
}

//====================================================================
// manager routines

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT ShutdownNetlogonServiceBits(void) {
    HRESULT hr;
    DWORD dwErr;

    // stop announcing that we are a server
    g_state.dwNetlogonServiceBits=0;

    dwErr=NetLogonSetServiceBits(NULL, DS_TIMESERV_FLAG|DS_GOOD_TIMESERV_FLAG, 0);
    if (0xC0020012==dwErr) { //RPC_NT_UNKNOWN_IF in ntstatus.h
        // This happens if we are not joined to a domain. No problem, just ignore it.
        _IgnoreError(dwErr, "NetLogonSetServiceBits")
    } else if (S_OK!=dwErr) {
        hr=HRESULT_FROM_WIN32(dwErr);
        _JumpError(hr, error, "NetLogonSetServiceBits")
    }
    if (!I_ScSetServiceBits(g_state.servicestatushandle, SV_TYPE_TIME_SOURCE, FALSE, TRUE, NULL)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        if (HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE)==hr && (SERVICE_STATUS_HANDLE)3==g_state.servicestatushandle) {
            // we are not really running as a service. just ignore this
        } else {
            _JumpError(hr, error, "I_ScSetServiceBits");
        }
    }

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT UpdateNetlogonServiceBits(bool bFullUpdate) {
    HRESULT hr;
    DWORD dwErr;
    bool bTimeserv;
    bool bReliableTimeserv;
    DWORD dwNetlogonServiceBits;

    // must be cleaned up
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC * pDomInfo=NULL;

    if (false==bFullUpdate) {
        // we only want to update the 'reliable' flag
        // so keep the old timeserv flag
        bTimeserv=(0!=(g_state.dwNetlogonServiceBits&DS_TIMESERV_FLAG));

    } else {
        // are we a time server? check the flags first
        if (Timeserv_Announce_No==(Timeserv_Announce_Mask&g_state.pciConfig->dwAnnounceFlags)) {
            bTimeserv=false;
        } else if (Timeserv_Announce_Auto==(Timeserv_Announce_Mask&g_state.pciConfig->dwAnnounceFlags)) {
            // autodetect
            bool bWeAreADc=false;
            bool bTimeOutputProvFound=false;
            bool bWeAreSynchronized=false; 
            TimeProvider * ptpTravel;

            // get our current role
            dwErr=DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (BYTE **)&pDomInfo);
            if (ERROR_SUCCESS!=dwErr) {
                hr=HRESULT_FROM_WIN32(dwErr);
                _JumpError(hr, error, "DsRoleGetPrimaryDomainInformation");
            }

            if (DsRole_RoleStandaloneWorkstation==pDomInfo->MachineRole || 
                DsRole_RoleStandaloneServer==pDomInfo->MachineRole) { 
                // We're a standalone machine -- netlogon is not started.
                // Don't bother to set service bits, we'll just cause an RPC exception
                hr = S_OK; 
                goto error;
            }

            if (DsRole_RoleBackupDomainController==pDomInfo->MachineRole 
                || DsRole_RolePrimaryDomainController==pDomInfo->MachineRole) {
                bWeAreADc=true;
            }

            // see if there are any provider running
            ptpTravel=g_state.pciConfig->ptpProviderList;
            while (NULL!=ptpTravel) {
                if (false==ptpTravel->bInputProvider) {
                    bTimeOutputProvFound=true;
                    break;
                }
                ptpTravel=ptpTravel->ptpNext;
            }

            if (e_ClockNotSynchronized != g_state.eLeapIndicator) { 
                bWeAreSynchronized = true; 
            }

            // We are a time service if we are a DC and there is a output provider running
            bTimeserv=(bWeAreADc && bTimeOutputProvFound && bWeAreSynchronized);

        } else {
            // the Timeserv_Announce_Yes flag is set
            bTimeserv=true;
        }
    }

    // now see if we are a reliable time server
    if (false==bTimeserv 
        || Reliable_Timeserv_Announce_No==(Reliable_Timeserv_Announce_Mask&g_state.pciConfig->dwAnnounceFlags)) {
        bReliableTimeserv=false;
    } else if (Reliable_Timeserv_Announce_Auto==(Reliable_Timeserv_Announce_Mask&g_state.pciConfig->dwAnnounceFlags)) {
        // autodetect
        if (1==g_state.nStratum && NtpConst::dwLocalRefId==g_state.refidSource.value) {
            bReliableTimeserv=true;
        } else {
            bReliableTimeserv=false;
        }
    } else {
        // the Reliable_Timeserv_Announce_Yes flag is set
        bReliableTimeserv=true;
    }

    // now see if we need to tell netlogon what our flags are
    if (true==bFullUpdate
        || (true==bReliableTimeserv && 0==(g_state.dwNetlogonServiceBits&DS_GOOD_TIMESERV_FLAG))
        || (false==bReliableTimeserv && 0!=(g_state.dwNetlogonServiceBits&DS_GOOD_TIMESERV_FLAG))) {

        // assume dword reads and writes are atomic
        g_state.dwNetlogonServiceBits=(bTimeserv?DS_TIMESERV_FLAG:0)|(bReliableTimeserv?DS_GOOD_TIMESERV_FLAG:0);

        dwErr=NetLogonSetServiceBits(NULL, DS_TIMESERV_FLAG|DS_GOOD_TIMESERV_FLAG, g_state.dwNetlogonServiceBits);
        if (0xC0020012==dwErr) { //RPC_NT_UNKNOWN_IF in ntstatus.h
            // This happens if we are not joined to a domain. No problem, just ignore it.
            _IgnoreError(dwErr, "NetLogonSetServiceBits")
        } else if (S_OK!=dwErr) {
            hr=HRESULT_FROM_WIN32(dwErr);
            _JumpError(hr, error, "NetLogonSetServiceBits")
        }
        if (!I_ScSetServiceBits(g_state.servicestatushandle, SV_TYPE_TIME_SOURCE, bTimeserv, TRUE, NULL)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            if (HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE)==hr && (SERVICE_STATUS_HANDLE)3==g_state.servicestatushandle) {
                // we are not really running as a service. just ignore this
            } else {
                _JumpError(hr, error, "I_ScSetServiceBits");
            }
        }
    }

    hr=S_OK;
error:
    if (NULL!=pDomInfo) {
        DsRoleFreeMemory(pDomInfo);
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE int __cdecl CompareEndpointEntries(const void * pvElem1, const void * pvElem2) {
    EndpointEntry * peeElem1=(EndpointEntry *)pvElem1;
    EndpointEntry * peeElem2=(EndpointEntry *)pvElem2;

    if (peeElem1->toEndpoint<peeElem2->toEndpoint) {
        return -1;
    } else if (peeElem1->toEndpoint>peeElem2->toEndpoint) {
        return 1;
    } else {
        return 0;
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE int __cdecl CompareCandidateEntries(const void * pvElem1, const void * pvElem2) {
    CandidateEntry * pceElem1=(CandidateEntry *)pvElem1;
    CandidateEntry * pceElem2=(CandidateEntry *)pvElem2;

    if (pceElem1->tpDistance<pceElem2->tpDistance) {
        return -1;
    } else if (pceElem1->tpDistance>pceElem2->tpDistance) {
        return 1;
    } else {
        return 0;
    }
}

//--------------------------------------------------------------------
// NOTE: The method requires that nSamplesAvail > 0. 
// 
MODULEPRIVATE HRESULT SelectBestSample(unsigned int nSamplesAvail, bool * pbSuccessful) {
    unsigned int nIndex;
    signed __int64 toLow;
    signed __int64 toHigh;
    unsigned int nDroppedSamples;       // f in RFC-1305
    unsigned int nCandidates;

    // note that the endpoint list and the candidate list will always be big enough to hold
    // the entire sample buf, as ensured by EnlargeSampleBuf

    //
    // intersection algorithm
    //

    // create the list of endpoints
    for (nIndex=0; nIndex<nSamplesAvail; nIndex++) {
        unsigned __int64 tpSyncDistance;
        if (g_state.rgtsSampleBuf[nIndex].toDelay<0) {
            tpSyncDistance=(unsigned __int64)(-g_state.rgtsSampleBuf[nIndex].toDelay);
        } else {
            tpSyncDistance=(unsigned __int64)(g_state.rgtsSampleBuf[nIndex].toDelay);
        }
        tpSyncDistance/=2;
        tpSyncDistance+=g_state.rgtsSampleBuf[nIndex].tpDispersion;
        g_state.rgeeEndpointList[nIndex*3+0].toEndpoint=g_state.rgtsSampleBuf[nIndex].toOffset-tpSyncDistance;
        g_state.rgeeEndpointList[nIndex*3+0].nType=-1;
        g_state.rgeeEndpointList[nIndex*3+1].toEndpoint=g_state.rgtsSampleBuf[nIndex].toOffset;
        g_state.rgeeEndpointList[nIndex*3+1].nType=0;
        g_state.rgeeEndpointList[nIndex*3+2].toEndpoint=g_state.rgtsSampleBuf[nIndex].toOffset+tpSyncDistance;
        g_state.rgeeEndpointList[nIndex*3+2].nType=1;
    }

    // sort the list
    qsort(g_state.rgeeEndpointList, nSamplesAvail*3, sizeof(EndpointEntry), CompareEndpointEntries);

    // determine the high and low of the range that at least half of the samples agree upon
    for (nDroppedSamples=0; nDroppedSamples<=nSamplesAvail/2; nDroppedSamples++) {
        unsigned int nIntersectionCount=0;    // i in RFC-1305
        unsigned int nFalseTickers=0;         // c in RFC-1305

        // find the lowest point including nSamplesAvail-nDroppedSamples samples
        for (nIndex=0; nIndex<nSamplesAvail*3; nIndex++) {
            nIntersectionCount-=g_state.rgeeEndpointList[nIndex].nType;
            toLow=g_state.rgeeEndpointList[nIndex].toEndpoint;
            if (nIntersectionCount>=nSamplesAvail-nDroppedSamples) {
                break;
            } else if (0==g_state.rgeeEndpointList[nIndex].nType) {
                nFalseTickers++;
            }
        }

        // find the highest point including nSamplesAvail-nDroppedSamples samples
        nIntersectionCount=0;
        for (nIndex=nSamplesAvail*3; nIndex>0; nIndex--) {
            nIntersectionCount+=g_state.rgeeEndpointList[nIndex-1].nType;
            toHigh=g_state.rgeeEndpointList[nIndex-1].toEndpoint;
            if (nIntersectionCount>=nSamplesAvail-nDroppedSamples) {
                break;
            } else if (0==g_state.rgeeEndpointList[nIndex-1].nType) {
                nFalseTickers++;
            }
        }

        if (nFalseTickers<=nDroppedSamples) {
            // we found all the falsetickers, so we can stop now.
            break;
        }
    }

    // Was there a range that the samples agreed upon?
    if (toLow>toHigh) {
        FileLog0(FL_SelectSampWarn, L"** No m/2 samples agreed upon range\n");
        *pbSuccessful=false;
        goto done;
    }

    FileLog1(FL_SelectSampAnnounceLow, L"Intersection successful with %u dropped samples.\n", nDroppedSamples);


    //
    // Clustering algorithm
    //

    // build the list of candidates that are in the intersection range
    nCandidates=0;
    for (nIndex=0; nIndex<nSamplesAvail; nIndex++) {
        if (g_state.rgtsSampleBuf[nIndex].toOffset<=toHigh && g_state.rgtsSampleBuf[nIndex].toOffset>=toLow) {
            unsigned __int64 tpSyncDistance;
            if (g_state.rgtsSampleBuf[nIndex].toDelay<0) {
                tpSyncDistance=(unsigned __int64)(-g_state.rgtsSampleBuf[nIndex].toDelay);
            } else {
                tpSyncDistance=(unsigned __int64)(g_state.rgtsSampleBuf[nIndex].toDelay);
            }
            tpSyncDistance/=2;
            tpSyncDistance+=g_state.rgtsSampleBuf[nIndex].tpDispersion;

            g_state.rgceCandidateList[nCandidates].nSampleIndex=nIndex;
            g_state.rgceCandidateList[nCandidates].tpDistance=tpSyncDistance+NtpConst::tpMaxDispersion.qw*g_state.rgtsSampleBuf[nIndex].nStratum;
            nCandidates++;
        }
    }

    // sort the list
    qsort(g_state.rgceCandidateList, nCandidates, sizeof(CandidateEntry), CompareCandidateEntries);

    // just look at the top few
    if (nCandidates>NtpConst::nMaxSelectClocks) {
        nCandidates=NtpConst::nMaxSelectClocks;
    }

    // trim the candidate list to a small number
    while (true) {
        unsigned __int64 tpMaxSelectDispersion=0;;
        unsigned int nMaxSelectDispersionIndex=0;
        unsigned __int64 tpSelectDispersion=0;
        TimeSample * ptsZero=&g_state.rgtsSampleBuf[g_state.rgceCandidateList[0].nSampleIndex];
        unsigned __int64 tpMinDispersion=ptsZero->tpDispersion;

        // we are looking for the maximum select dispersion and the minimum dispersion
        for (nIndex=nCandidates; nIndex>0; nIndex--) {
            // calculate the select dispersion for this candidate
            signed __int64 toDelta=g_state.rgtsSampleBuf[g_state.rgceCandidateList[nIndex-1].nSampleIndex].toOffset-ptsZero->toOffset;
            unsigned __int64 tpAbsDelta;
            if (toDelta<0) {
                tpAbsDelta=(unsigned __int64)(-toDelta);
            } else {
                tpAbsDelta=(unsigned __int64)(toDelta);
            }
            if (tpAbsDelta>NtpConst::tpMaxDispersion.qw) {
                tpAbsDelta=NtpConst::tpMaxDispersion.qw;
            }
            tpSelectDispersion+=tpAbsDelta;
            NtpConst::weightSelect(tpSelectDispersion);

            if (FileLogAllowEntry(FL_SelectSampDump)) {
                FileLogAdd(L"  %u: Sample:%u SyncDist:%I64u SelectDisp:%I64u\n", 
                    nIndex-1,
                    g_state.rgceCandidateList[nIndex-1].nSampleIndex,
                    g_state.rgceCandidateList[nIndex-1].tpDistance,
                    tpSelectDispersion);
            }

            // we are looking for the maximum select dispersion and the minimum dispersion
            if (tpMaxSelectDispersion<tpSelectDispersion) {
                tpMaxSelectDispersion=tpSelectDispersion;
                nMaxSelectDispersionIndex=nIndex-1;
            }
            if (tpMinDispersion>g_state.rgtsSampleBuf[g_state.rgceCandidateList[nIndex-1].nSampleIndex].tpDispersion) {
                tpMinDispersion=g_state.rgtsSampleBuf[g_state.rgceCandidateList[nIndex-1].nSampleIndex].tpDispersion;
            }
        } // <- end min/max calc loop

        // did we eliminate enough outliers?
        if  (tpMaxSelectDispersion<=tpMinDispersion || nCandidates<=NtpConst::nMinSelectClocks) {

            /*
            // One last check - is it less that the maximum sync distance?
            unsigned __int64 tpSyncDistance;
            if (ptsZero->toDelay<0) {
                tpSyncDistance=(unsigned __int64)(-ptsZero->toDelay);
            } else {
                tpSyncDistance=(unsigned __int64)(ptsZero->toDelay);
            }
            tpSyncDistance/=2;
            tpSyncDistance+=ptsZero->tpDispersion;
            if (tpSyncDistance>=NtpConst::tpMaxDistance.qw) {
                FileLog0(FL_SelectSampWarn, L"** Chosen sample's sync distance is too big.\n");
                *pbSuccessful=false;
                goto done;
            }
            */

            // TODO: could do clock combining.

            // save the answer
            memcpy(&g_state.tsNextClockUpdate, ptsZero, sizeof(TimeSample));
            g_state.tsiNextClockUpdate.ptp = g_state.rgtsiSampleInfoBuf[g_state.rgceCandidateList[0].nSampleIndex].ptp; 
            g_state.tsiNextClockUpdate.pts = &g_state.tsNextClockUpdate; 
            g_state.tpSelectDispersion.qw=tpSelectDispersion;

            if (FileLogAllowEntry(FL_SelectSampDump)) {
                FileLogAdd(L"Sample %u chosen. Select Dispersion:", g_state.rgceCandidateList[0].nSampleIndex);
                FileLogNtTimePeriodEx(true /*append*/, g_state.tpSelectDispersion);
                FileLogAppend(L"\n");
            }

            // All done! We are successful!
            break;

        } else {

            FileLog1(FL_SelectSampDump, L"Discarding %u\n", nMaxSelectDispersionIndex);

            // get rid of the worst offender
            if (nMaxSelectDispersionIndex!=nCandidates-1) {
                memmove(&g_state.rgceCandidateList[nMaxSelectDispersionIndex], &g_state.rgceCandidateList[nMaxSelectDispersionIndex+1], (nCandidates-1-nMaxSelectDispersionIndex)*sizeof(CandidateEntry));
            }
            nCandidates--;
        }

    } // <- end candidate list trimming
    

    *pbSuccessful=true;
done:
    return S_OK;

}

//--------------------------------------------------------------------
MODULEPRIVATE void WINAPI HandleClockDisplnThread(LPVOID pvIgnored, BOOLEAN bIgnored) { 
    HRESULT                  hr; 
    HRESULT                  hrThread           = E_FAIL;

    // Clock discipline thread has shut down!!  Stop the service, if we're 
    // not already performing a shutdown: 
    if (!GetExitCodeThread(g_state.hClockDisplnThread, (DWORD *)&hrThread)) { 
        hr = HRESULT_FROM_WIN32(GetLastError()); 
        _IgnoreIfError(hr, "GetExitCodeThread"); 
    }
    
    // Can't shutdown the service from a registered callback function -- we'll deadlock!  
    // Queue shutdown asynchronously: 
    hr = SendServiceShutdown(hrThread, TRUE /*restart*/, TRUE /*async*/); 
    _IgnoreIfError(hr, "SendServiceShutdown"); 

    // return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT HandleManagerApmSuspend() { 
    HRESULT hr   = S_OK;  
    HRESULT hr2; 

    FileLog0(FL_ResumeSuspendAnnounce, L"W32Time: Processing APM suspend notification.  File logging will be disabled."); 

    // APM suspend requires that we close any open files: 
    hr2 = FileLogSuspend(); 
    _TeardownError(hr, hr2, "FileLogSuspend"); 
    if (SUCCEEDED(hr2)) { 
	g_state.bAPMStoppedFileLog = true; 
    }

    // Let the CMOS clock take care of itself:
    hr2 = HandleManagerGoUnsyncd(); 
    _TeardownError(hr, hr2, "HandleManagerGoUnsynched"); 

    // BUGBUG:  should we propagate error to SCM?
    hr2 = AcquireControlOfSystemClock(true /*acquire*/, true /*block*/, NULL /*assume acquired on success for blocking call*/); 
    _TeardownError(hr, hr2, "AllowSystemClockUpdates"); 
    if (SUCCEEDED(hr2)) { 
	g_state.bAPMAcquiredSystemClock = true; 
    }

    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT HandleManagerApmResumeSuspend() { 
    HRESULT hr; 
    TpcTimeJumpedArgs tjArgs = { TJF_Default }; 
    TpcNetTopoChangeArgs ntcArgs = { NTC_Default }; 
    
    if (!g_state.bAPMStoppedFileLog) { 
	// We're resuming from a critical suspend, or stopping the filelog
	// failed last time.  Our file logging may be trashed at this point.  Stop it and restart...
	hr = FileLogSuspend(); 
	_JumpIfError(hr, error, "FileLogSuspend"); 
	g_state.bAPMStoppedFileLog = true; 
    }
    
    if (g_state.bAPMAcquiredSystemClock) { 
	// We're resuming from a regular suspend, and we have the APM critsec locked.
	// We must have the APM critsec locked -- free it and continue.
	// BUGBUG:  should we propagate error to SCM?
	hr = AcquireControlOfSystemClock(false /*acquire*/, false /*ignored*/, NULL /*ignored*/); 
	_JumpIfError(hr, error, "AllowSystemClockUpdates"); 
	g_state.bAPMAcquiredSystemClock = false; 
    } 

    hr = FileLogResume(); 
    _JumpIfError(hr, error, "FileLogResume"); 
    g_state.bAPMStoppedFileLog = false; 

    FileLog0(FL_ResumeSuspendAnnounce, L"W32Time: Processing APM resume notification"); 

    // APM suspend doesn't preserve net connections.  Rediscover network sources: 
    hr = HandleManagerHardResync(TPC_NetTopoChange, &ntcArgs); 
    _JumpIfError(hr, error, "HandleManagerHardResync (TPC_NetTopoChange) ");  // Fatal

    // APM suspend almost certainly has caused a time slip.  
    hr = HandleManagerHardResync(TPC_TimeJumped, &tjArgs); 
    _JumpIfError(hr, error, "HandleManagerHardResync (TPC_TimeJumped) ");  // Fatal

    FileLog0(FL_ResumeSuspendAnnounce, L"W32Time: resume complete"); 

    hr = S_OK; 
 error:
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT HandleManagerGetTimeSamples(bool bIrregular) {
    HRESULT hr;
    TimeProvider * ptp;
    TpcGetSamplesArgs tgsa;
    unsigned int nSamplesSoFar=0;
    bool bBufferTooSmall;
    bool bSuccessful;
    bool bEnteredCriticalSection = false; 

    // must be cleaned up
    WCHAR * wszError=NULL;

    hr = myEnterCriticalSection(&g_state.csW32Time); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection=true; 

    // loop over all the input providers and gather the samples.
    ptp=g_state.pciConfig->ptpProviderList;
    while (ptp!=NULL) {
        if (true==ptp->bInputProvider) {
            do {
                // prepare the buffer for the next person to append to
                tgsa.pbSampleBuf=(BYTE *)(&g_state.rgtsSampleBuf[nSamplesSoFar]);
                tgsa.cbSampleBuf=sizeof(TimeSample)*(g_state.nSampleBufAllocSize-nSamplesSoFar);
                tgsa.dwSamplesAvailable=0;
                tgsa.dwSamplesReturned=0;
                bBufferTooSmall=false;

                // request the samples
                _BeginTryWith(hr) {
                    hr=ptp->pfnTimeProvCommand(ptp->hTimeProv, TPC_GetSamples, &tgsa);
                } _TrapException(hr);

                // was the buffer not big enough?
                if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)==hr) {
                    bBufferTooSmall=true;
                    hr=EnlargeSampleBuf(tgsa.dwSamplesAvailable-tgsa.dwSamplesReturned);
                    _JumpIfError(hr, error, "EnlargeSampleBuf");
                }
            } while (bBufferTooSmall);

            if (FAILED(hr)) {
                // log an event on failure, but otherwise ignore it.
                const WCHAR * rgwszStrings[2]={
                    ptp->wszProvName,
                    NULL
                };

                // get the friendly error message
                hr=GetSystemErrorString(hr, &wszError);
                _JumpIfError(hr, error, "GetSystemErrorString");

                // log the event
                rgwszStrings[1]=wszError;
                FileLog2(FL_ControlProvWarn, L"Logging warning: The time provider '%s' returned an error when asked for time samples. The error will be ignored. The error was: %s\n", ptp->wszProvName, wszError);
                hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_TIMEPROV_FAILED_GETSAMPLES, 2, rgwszStrings);
                _JumpIfError(hr, error, "MyLogEvent");

                LocalFree(wszError);
                wszError=NULL;
            } else {
                // success. keep these samples and ask the next provider.
                FileLog2(FL_CollectSampDump, L"%s returned %d samples.\n", ptp->wszProvName, tgsa.dwSamplesReturned);

                // Maintain w32time-specific information: 
                for (unsigned int nIndex = nSamplesSoFar; nIndex < nSamplesSoFar+tgsa.dwSamplesReturned; nIndex++) {
                    g_state.rgtsiSampleInfoBuf[nIndex].pts = &g_state.rgtsSampleBuf[nIndex]; 
                    g_state.rgtsiSampleInfoBuf[nIndex].ptp = ptp;  // Store the provider that provided this sample
                }

                nSamplesSoFar+=tgsa.dwSamplesReturned;
            }

        } // <- end if provider is an input provider

        ptp=ptp->ptpNext;
    } // <- end provider loop

    {
        HRESULT hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }

    if (FileLogAllowEntry(FL_CollectSampDump)) {
        unsigned int nIndex;
        for (nIndex=0; nIndex<nSamplesSoFar; nIndex++) {
            NtTimeOffset to={g_state.rgtsSampleBuf[nIndex].toOffset};
            FileLogAdd(L"Sample %d offset:", nIndex);
            FileLogNtTimeOffsetEx(true /*append*/, to);
            FileLogAppend(L" delay:");
            to.qw=g_state.rgtsSampleBuf[nIndex].toDelay;
            FileLogNtTimeOffsetEx(true /*append*/, to);
            FileLogAppend(L" dispersion:");
            NtTimePeriod tp={g_state.rgtsSampleBuf[nIndex].tpDispersion};
            FileLogNtTimePeriodEx(true /*append*/, tp);
            FileLogAppend(L"\n");
        }
    }

    bSuccessful=false;
    if (nSamplesSoFar>0) {
        hr=SelectBestSample(nSamplesSoFar, &bSuccessful);
        _JumpIfError(hr, error, "SelectBestSample");
    }

    if (bSuccessful) {
        // we found someone to synchronize from!

        HANDLE rghWait[2]={
            g_state.hClockCommandCompleteEvent,
            g_state.hClockDisplnThread
        };
        DWORD dwWaitResult;

        g_state.eLocalClockCommand=bIrregular?e_IrregularUpdate:e_RegularUpdate;
        if (!SetEvent(g_state.hClockCommandAvailEvent)) {
            _JumpLastError(hr, error, "SetEvent");
        }
        dwWaitResult=WaitForMultipleObjects(ARRAYSIZE(rghWait), rghWait, false, INFINITE);
        if (WAIT_FAILED==dwWaitResult) {
            _JumpLastError(hr, error, "WaitForMultipleObjects");
        } else if (WAIT_OBJECT_0==dwWaitResult) {
            // We may need to change our status with netlogon if
            //   1) We've gone from unsynchronized --> synchronized, 
            //      we can now advertise as a time source
            //   2) We've become a reliable time source
            hr=UpdateNetlogonServiceBits(true);
            _JumpIfError(hr, error, "UpdateNetlogonServiceBits");

            // save result for RPC requests
            if (true==g_state.bStaleData) {
                g_state.eLastSyncResult=e_StaleData;
            } else if (true==g_state.bClockChangeTooBig) {
                g_state.eLastSyncResult=e_ChangeTooBig;
            } else {
                g_state.eLastSyncResult=e_Success;
                g_state.tpTimeSinceLastGoodSync=0;
            }

            // log a message if the time source changed
            if (g_state.bSourceChanged && 0!=(EvtLog_SourceChange&g_state.dwEventLogFlags)) {
                hr = MyLogSourceChangeEvent(g_state.wszSourceName); 
                _JumpIfError(hr, error, "MyLogSourceChangeEvent");
            }

            // log a message if the clock jumped
            if (g_state.bClockJumped && 0!=(EvtLog_TimeJump&g_state.dwEventLogFlags)) {
                WCHAR wszNumberBuf[35];
                WCHAR * rgwszStrings[1]={wszNumberBuf};
                if (g_state.toClockJump<gc_toZero) {
                    swprintf(wszNumberBuf, L"-%I64u", (-g_state.toClockJump.qw)/10000000);
                } else {
                    swprintf(wszNumberBuf, L"+%I64u", g_state.toClockJump.qw/10000000); 
                }
                FileLog1(FL_TimeAdjustWarn, L"Logging warning: The time service has made a discontinuous change in the system clock. The system time has been changed by %s seconds.\n", rgwszStrings[0]);
                hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_TIME_JUMPED, 1, (const WCHAR **)rgwszStrings);
                _JumpIfError(hr, error, "MyLogEvent");
            }

            // log a message if the clock change was ignored
            if (true==g_state.bClockChangeTooBig && false==g_state.bDontLogClockChangeTooBig) {
                WCHAR wszNumberBuf1[35];
                WCHAR wszNumberBuf2[35];
                WCHAR * rgwszStrings[3]={wszNumberBuf1, wszNumberBuf2, NULL};
                rgwszStrings[2]=g_state.tsNextClockUpdate.wszUniqueName;
                if (g_state.toIgnoredChange<gc_toZero) {
                    swprintf(wszNumberBuf1, L"-%I64u", (-g_state.toIgnoredChange.qw)/10000000);
                    swprintf(wszNumberBuf2, L"-%u", g_state.pciConfig->lcci.dwMaxNegPhaseCorrection);
                } else {
                    swprintf(wszNumberBuf1, L"+%I64u", g_state.toIgnoredChange.qw/10000000); 
                    swprintf(wszNumberBuf2, L"+%u", g_state.pciConfig->lcci.dwMaxPosPhaseCorrection);
                }
                FileLog3(FL_TimeAdjustWarn, L"Logging error: The time service has detected that the system time need to be changed by %s seconds. For security reasons, the time service will not change the system time by more than %s seconds. Verify that your time and time zone are correct, and that the time source %s is working properly.\n", rgwszStrings[0], rgwszStrings[1], rgwszStrings[2]);
                hr=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_TIME_CHANGE_TOO_BIG, 3, (const WCHAR **)rgwszStrings);
                _JumpIfError(hr, error, "MyLogEvent");
                g_state.bDontLogClockChangeTooBig=true;
            }
            if (false==g_state.bStaleData && false==g_state.bClockChangeTooBig && true==g_state.bDontLogClockChangeTooBig) {
                g_state.bDontLogClockChangeTooBig=false;
            }

            // propogate the message to the providers
            if (g_state.bPollIntervalChanged || g_state.bClockJumped) {
                TimeProvider * ptpTravel;
                for (ptpTravel=g_state.pciConfig->ptpProviderList; NULL!=ptpTravel; ptpTravel=ptpTravel->ptpNext) {
                    if (g_state.bClockJumped) {
			TpcTimeJumpedArgs tjArgs = { TJF_Default }; 
                        hr=SendNotificationToProvider(ptpTravel, TPC_TimeJumped, &tjArgs);
                        _JumpIfError(hr, error, "SendNotificationToProvider");
                    }
                    if (g_state.bPollIntervalChanged) {
                        hr=SendNotificationToProvider(ptpTravel, TPC_PollIntervalChanged, NULL);
                        _JumpIfError(hr, error, "SendNotificationToProvider");
                    }
                } // <- end provider loop
            } // <- end if messages to propogate
        } else {
            // the ClockDiscipline thread shut down!
            // fall outward to the manager thread main loop to analyze the issue.
        }

    } else {
        // save result for RPC requests
        g_state.eLastSyncResult=e_NoData;
    }

    // Allow any waiting RPC requests to finish
    if (g_state.hRpcSyncCompleteEvent==g_state.hRpcSyncCompleteAEvent) {
        if (!ResetEvent(g_state.hRpcSyncCompleteBEvent)) {
            _JumpLastError(hr, error, "ResetEvent");
        }
        g_state.hRpcSyncCompleteEvent=g_state.hRpcSyncCompleteBEvent;
        if (!SetEvent(g_state.hRpcSyncCompleteAEvent)) {
            _JumpLastError(hr, error, "ResetEvent");
        }
    } else {
        if (!ResetEvent(g_state.hRpcSyncCompleteAEvent)) {
            _JumpLastError(hr, error, "ResetEvent");
        }
        g_state.hRpcSyncCompleteEvent=g_state.hRpcSyncCompleteAEvent;
        if (!SetEvent(g_state.hRpcSyncCompleteBEvent)) {
            _JumpLastError(hr, error, "ResetEvent");
        }
    }

    // update the time remaining
    if (!bIrregular) {
        // start a new regular wait
        g_state.tpPollDelayRemaining=((unsigned __int64)(((DWORD)1)<<g_state.nPollInterval))*10000000;
        g_state.eLastRegSyncResult=g_state.eLastSyncResult;
    }
    // clear the irregular time, and contiue with the remaining regular wait
    g_state.tpIrregularDelayRemaining=0;
    g_state.tpTimeSinceLastSyncAttempt=0;

    hr=S_OK;
error:
    if (bEnteredCriticalSection) { 
        HRESULT hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }
    if (NULL!=wszError) {
        LocalFree(wszError);
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT HandleManagerGoUnsyncd(void) {
    HRESULT hr;
    HANDLE rghWait[2]={
        g_state.hClockCommandCompleteEvent,
        g_state.hClockDisplnThread
    };
    DWORD dwWaitResult;

    g_state.eLocalClockCommand=e_GoUnsyncd;
    if (!SetEvent(g_state.hClockCommandAvailEvent)) {
        _JumpLastError(hr, error, "SetEvent");
    }
    dwWaitResult=WaitForMultipleObjects(ARRAYSIZE(rghWait), rghWait, false, INFINITE);
    if (WAIT_FAILED==dwWaitResult) {
        _JumpLastError(hr, error, "WaitForMultipleObjects");
    } else if (WAIT_OBJECT_0==dwWaitResult) {

        // log a message if we went unsynced
        if (g_state.bSourceChanged && 0!=(EvtLog_SourceChange&g_state.dwEventLogFlags)) {
            WCHAR wszNumberBuf[35];
            WCHAR * rgwszStrings[1]={wszNumberBuf};
            DWORD dwLongTimeNoSync=((DWORD)3)<<(g_state.pciConfig->lcci.dwMaxPollInterval-1);
            swprintf(wszNumberBuf, L"%u", dwLongTimeNoSync);
            FileLog1(FL_SourceChangeWarn, L"Logging warning: The time service has not been able to synchronize the system time for %s seconds because none of the time providers has been able to provide a usable time stamp. The system clock is unsynchronized.\n", rgwszStrings[0]);
            hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_TIME_SOURCE_NONE, 1, (const WCHAR **)rgwszStrings);
            _JumpIfError(hr, error, "MyLogEvent");
        }

    
    } else {
        // the ClockDiscipline thread shut down!
        // fall outward to the manager thread main loop to analyze the issue.
    }

    // update the time remaining
    g_state.tpTimeSinceLastGoodSync=0;

    hr=S_OK;
error:
    return hr;
}


//--------------------------------------------------------------------
MODULEPRIVATE void WINAPI HandleManagerParamChange(PVOID pvIgnored, BOOLEAN bIgnored) {
    bool                      bEnteredCriticalSection   = false; 
    HRESULT                   hr;
    HRESULT                   hr2;
    TimeProvider            **pptpCurPrev;
    TimeProvider             *ptpCurTravel;
    unsigned int              nProvidersStopped         = 0;
    unsigned int              nProvidersStarted         = 0;
    unsigned int              nProvidersNotChanged      = 0;
    unsigned int              nRequestedInputProviders  = 0;
    

    // Must be cleaned up
    ConfigInfo * pciConfig=NULL;
    WCHAR * rgwszStrings[1]={NULL};

    FileLog0(FL_ParamChangeAnnounce, L"W32TmServiceMain: Param change notification\n");

    // We've been called asynchronously by the SCM.  Need to serialize this call: 
    hr = myEnterCriticalSection(&g_state.csW32Time); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection=true; 

    hr = UpdateTimerQueue2(); 
    _JumpIfError(hr, error, "UpdateTimerQueue2"); 

   // Propagate the message to the file log: 
    hr2 = UpdateFileLogConfig(); 
    _IgnoreIfError(hr2, "UpdateFileLogConfig"); 

    // get the configuration data
    hr2=ReadConfig(&pciConfig);
    if (FAILED(hr2)) {
        // log an event on failure
        hr=GetSystemErrorString(hr2, &(rgwszStrings[0]));
        _JumpIfError(hr, error, "GetSystemErrorString");
        FileLog1(FL_ParamChangeWarn, L"Logging warning: The time service encountered an error while reading its configuration from the registry, and will continue running with its previous configuration. The error was: %s\n", rgwszStrings[0]);
        hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_CONFIG_READ_FAILED_WARNING, 1, (const WCHAR **)rgwszStrings);
        _JumpIfError(hr, error, "MyLogEvent");

        // propogate the message  to the providers at least
        for (ptpCurTravel=g_state.pciConfig->ptpProviderList; NULL!=ptpCurTravel; ptpCurTravel=ptpCurTravel->ptpNext) {
            hr=SendNotificationToProvider(ptpCurTravel, TPC_UpdateConfig, NULL);
            _JumpIfError(hr, error, "SendNotificationToProvider");
        }

    } else {
        // see if anything changed

        // first, check the local clock config
        if (0!=memcmp(&g_state.pciConfig->lcci, &pciConfig->lcci, sizeof(LocalClockConfigInfo))) {
            FileLog0(FL_ParamChangeAnnounce, L"  Updating params for local clock.\n");

            // config is different. Grab it and tell the local clock.
            memcpy(&g_state.pciConfig->lcci, &pciConfig->lcci, sizeof(LocalClockConfigInfo));

            // fix the poll interval if necessary
            // this is safe becuase the local clock only changes poll interval during an update, and we
            // wait for the local clock to finish updates before proceding (so we're not updating now)
            if (g_state.nPollInterval<((signed int)g_state.pciConfig->lcci.dwMinPollInterval) 
                || g_state.nPollInterval>((signed int)g_state.pciConfig->lcci.dwMaxPollInterval)) {
                if (g_state.nPollInterval<((signed int)g_state.pciConfig->lcci.dwMinPollInterval)) {
                    g_state.nPollInterval=((signed int)g_state.pciConfig->lcci.dwMinPollInterval);
                } else {
                    g_state.nPollInterval=((signed int)g_state.pciConfig->lcci.dwMaxPollInterval);
                    if (g_state.tpPollDelayRemaining>((unsigned __int64)(((DWORD)1)<<g_state.nPollInterval))*10000000) {
                        g_state.tpPollDelayRemaining=((unsigned __int64)(((DWORD)1)<<g_state.nPollInterval))*10000000;
                    }
                }

                // propogate the message to the providers
                for (ptpCurTravel=g_state.pciConfig->ptpProviderList; NULL!=ptpCurTravel; ptpCurTravel=ptpCurTravel->ptpNext) {
                    hr=SendNotificationToProvider(ptpCurTravel, TPC_PollIntervalChanged, NULL);
                    _JumpIfError(hr, error, "SendNotificationToProvider");
                }

            }
            
            // now, tell the local clock.
            {
                HANDLE rghWait[2]={
                    g_state.hClockCommandCompleteEvent,
                    g_state.hClockDisplnThread
                };
                DWORD dwWaitResult;

                g_state.eLocalClockCommand=e_ParamChange;
                if (!SetEvent(g_state.hClockCommandAvailEvent)) {
                    _JumpLastError(hr, error, "SetEvent");
                }
                dwWaitResult=WaitForMultipleObjects(ARRAYSIZE(rghWait), rghWait, false, INFINITE);
                if (WAIT_FAILED==dwWaitResult) {
                    _JumpLastError(hr, error, "WaitForMultipleObjects");
                } else if (WAIT_OBJECT_0==dwWaitResult) {
                    // Command acknowledged
                } else {
                    // the ClockDiscipline thread shut down!
                    // fall outward to the manager thread main loop to analyze the issue.
                }
            }

        } else {
            FileLog0(FL_ParamChangeAnnounce, L"  No params changed for local clock.\n");
        } // <- end if config change for local clock

        // second, check the provider list
        //   synchronization: currently, this thread (the manager thread) 
        //   is the only thread that walks the provider list.
        
        // check each provider in the current list against the new list
        nRequestedInputProviders=CountInputProvidersInList(pciConfig->ptpProviderList);
        pptpCurPrev=&(g_state.pciConfig->ptpProviderList);
        ptpCurTravel=*pptpCurPrev;
        while (NULL!=ptpCurTravel) {

            // walk the new provider list
            TimeProvider ** pptpNewPrev=&(pciConfig->ptpProviderList);
            TimeProvider * ptpNewTravel=*pptpNewPrev;
            while (NULL!=ptpNewTravel) {
                // stop if this new provider matches the current provider
                if (0==wcscmp(ptpNewTravel->wszDllName, ptpCurTravel->wszDllName)
                    && 0==wcscmp(ptpNewTravel->wszProvName, ptpCurTravel->wszProvName)
                    && ptpNewTravel->bInputProvider==ptpCurTravel->bInputProvider) {
                    break;
                }
                pptpNewPrev=&ptpNewTravel->ptpNext;
                ptpNewTravel=ptpNewTravel->ptpNext;
            }
            if (NULL!=ptpNewTravel) {
                // provider is in both lists, so we can drop the new one
                nProvidersNotChanged++;
                *pptpNewPrev=ptpNewTravel->ptpNext;
                ptpNewTravel->ptpNext=NULL;
                FreeTimeProviderList(ptpNewTravel);

                // send a "Param changed" message
                // do it here, so stopped and started providers don't get the update message
                hr=SendNotificationToProvider(ptpCurTravel, TPC_UpdateConfig, NULL);
                _JumpIfError(hr, error, "SendNotificationToProvider");

                // procede to the next provider in the current list
                pptpCurPrev=&ptpCurTravel->ptpNext;
                ptpCurTravel=ptpCurTravel->ptpNext;

            } else {
                // provider is not in new list
                // stop the privider
                nProvidersStopped++;
                hr=StopProvider(ptpCurTravel); 
                _JumpIfError(hr, error, "StopProvider");

                // remove it from the list
                *pptpCurPrev=ptpCurTravel->ptpNext;
                ptpCurTravel->ptpNext=NULL;
                FreeTimeProviderList(ptpCurTravel);
                ptpCurTravel=*pptpCurPrev;
            }
        } // <- End list comparison loop

        // Now, the only providers left in the new list are truly new providers.
        // Append to our current list and start them.
        *pptpCurPrev=pciConfig->ptpProviderList;
        pciConfig->ptpProviderList=NULL;
        ptpCurTravel=*pptpCurPrev;
        while (NULL!=ptpCurTravel) {
            hr=StartProvider(ptpCurTravel);
            if (FAILED(hr)) {
                FileLog1(FL_ParamChangeAnnounce, L"Discarding provider '%s'.\n", ptpCurTravel->wszProvName);
                *pptpCurPrev=ptpCurTravel->ptpNext;
                ptpCurTravel->ptpNext=NULL;
                FreeTimeProviderList(ptpCurTravel);
                ptpCurTravel=*pptpCurPrev;
            } else {
                nProvidersStarted++;
                pptpCurPrev=&ptpCurTravel->ptpNext;
                ptpCurTravel=ptpCurTravel->ptpNext;
            }
        } // <- end provider starting loop

        FileLog3(FL_ParamChangeAnnounce, L"  Provider list: %u stopped, %u started, %u not changed.\n",
            nProvidersStopped, nProvidersStarted, nProvidersNotChanged);

        // if we were supposed to have time providers, but NONE started, log a big warning
        if (0==CountInputProvidersInList(g_state.pciConfig->ptpProviderList) && 0!=nRequestedInputProviders) {
            FileLog0(FL_ParamChangeWarn, L"Logging error: The time service has been configured to use one or more input providers, however, none of the input providers could be started. THE TIME SERVICE HAS NO SOURCE OF ACCURATE TIME.\n");
            hr=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_NO_INPUT_PROVIDERS_STARTED, 0, NULL);
            _IgnoreIfError(hr, "MyLogEvent");
        }

        // now, check the announce flags
        if (g_state.pciConfig->dwAnnounceFlags!=pciConfig->dwAnnounceFlags) {
            FileLog2(FL_ParamChangeAnnounce, L"  AnnounceFlags changed from 0x%08X to 0x%08X.\n", g_state.pciConfig->dwAnnounceFlags, pciConfig->dwAnnounceFlags);
            g_state.pciConfig->dwAnnounceFlags=pciConfig->dwAnnounceFlags;
            hr=UpdateNetlogonServiceBits(true);
            _JumpIfError(hr, error, "UpdateNetlogonServiceBits");
        } else if ((0!=nProvidersStopped || 0!=nProvidersStarted) 
            && Timeserv_Announce_Auto==(Timeserv_Announce_Mask&g_state.pciConfig->dwAnnounceFlags)) {
            FileLog0(FL_ParamChangeAnnounce, L"  AnnounceFlags are auto. Updating announcement to match new provider list.\n");
            hr=UpdateNetlogonServiceBits(true);
            _JumpIfError(hr, error, "UpdateNetlogonServiceBits");
        }

        // check the EventLogFlags flag
        if (g_state.dwEventLogFlags!=pciConfig->dwEventLogFlags) {
            FileLog2(FL_ParamChangeAnnounce, L"  EventLogFlags changed from 0x%08X to 0x%08X.\n", 
                g_state.dwEventLogFlags, pciConfig->dwEventLogFlags);
            g_state.dwEventLogFlags=pciConfig->dwEventLogFlags;
        }

        // That's all the configuration parameters so far.

        // log this again as well
        g_state.bDontLogClockChangeTooBig=false;

    } // <- end if configuration successfully read

    hr = UpdateTimerQueue1(); 
    _JumpIfError(hr, error, "UpdateTimerQueue1"); 

    hr=S_OK;
 error:
    if (NULL!=pciConfig) {
        FreeConfigInfo(pciConfig);
    }
    if (NULL!=rgwszStrings[0]) {
        LocalFree(rgwszStrings[0]);
    }
    if (S_OK != hr) { // The service should not continue if this function failed: stop the service on error. 
        hr2 = SendServiceShutdown(hr, TRUE /*restart*/, TRUE /*async*/); 
        _IgnoreIfError(hr2, "SendServiceShutdown"); 
    }
    if (bEnteredCriticalSection) { 
        hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }
    // return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE void WINAPI HandleManagerGPUpdate(PVOID pvIgnored, BOOLEAN bIgnored) {
    bool     bDisallowedShutdown  = false; 
    HRESULT  hr; 

    FileLog0(FL_GPUpdateAnnounce, L"W32TmServiceMain: Group Policy Update\n");

    HandleManagerParamChange(NULL, FALSE); 

    // We can't mess with our registered callbacks FROM a callback 
    // if we're shutting down!
    hr = AllowShutdown(false); 
    _JumpIfError(hr, error, "AllowShutdown"); 
    bDisallowedShutdown = true; 

    if (!ResetEvent(g_state.hManagerGPUpdateEvent)) {
        // If we can't reset the event, don't attempt to re-register for policy notification.  
        // We don't want to get caught in an infinite loop of policy updates. 
        _JumpLastError(hr, error, "ResetEvent"); 
    } 
    
    if (NULL != g_state.hRegisteredManagerGPUpdateEvent) { 
	if (!UnregisterWaitEx(g_state.hRegisteredManagerGPUpdateEvent, 0 /*don't wait*/)) { 
	    // Should just be a resource leak if we can't unregister this event. 
	    _IgnoreLastError("UnregisterWait"); 
	}
	g_state.hRegisteredManagerGPUpdateEvent = NULL; 
    }

    if (!RegisterWaitForSingleObject(&g_state.hRegisteredManagerGPUpdateEvent, g_state.hManagerGPUpdateEvent, HandleManagerGPUpdate, NULL, INFINITE, WT_EXECUTEONLYONCE)) { 
        _JumpLastError(hr, error, "RegisterWaitForSingleObject"); 
    }

    hr = S_OK; 
 error: 
    if (bDisallowedShutdown) { 
	hr = AllowShutdown(true); 
	_IgnoreIfError(hr, "AllowShutdown"); 
    }
    ;
    // BUGBUG:  log event to indicate no more policy updates: 
    // return hr; 
}

//--------------------------------------------------------------------
// common code for time slip and net topo change
MODULEPRIVATE HRESULT HandleManagerHardResync(TimeProvCmd tpc, LPVOID pvArgs) {
    HRESULT hr;
    HANDLE rghWait[2]={
        g_state.hClockCommandCompleteEvent,
        g_state.hClockDisplnThread
    };
    DWORD dwWaitResult;

    // send a slip message to the local clock
    g_state.eLocalClockCommand=e_TimeSlip;
    if (!SetEvent(g_state.hClockCommandAvailEvent)) {
        _JumpLastError(hr, error, "SetEvent");
    }

    dwWaitResult=WaitForMultipleObjects(ARRAYSIZE(rghWait), rghWait, false, INFINITE);
    if (WAIT_FAILED==dwWaitResult) {
        _JumpLastError(hr, error, "WaitForMultipleObjects");
    } else if (WAIT_OBJECT_0==dwWaitResult) {
        // propagate the message to the providers
        TimeProvider * ptpTravel;
        for (ptpTravel=g_state.pciConfig->ptpProviderList; NULL!=ptpTravel; ptpTravel=ptpTravel->ptpNext) {

            hr=SendNotificationToProvider(ptpTravel, tpc, pvArgs);
            _JumpIfError(hr, error, "SendNotificationToProvider");

            if (g_state.bPollIntervalChanged) {
                hr=SendNotificationToProvider(ptpTravel, TPC_PollIntervalChanged, NULL);
                _JumpIfError(hr, error, "SendNotificationToProvider");
            } 
        } // <- end provider loop
    } else {
        // the ClockDiscipline thread shut down!
        // fall outward to the manager thread main loop to analyze the issue.
    }

    // log this again as well
    g_state.bDontLogClockChangeTooBig=false;

    // update the time remaining
    // we want to update as soon as possible. Delay some, so providers can collect data.
    g_state.tpPollDelayRemaining=((unsigned __int64)(((DWORD)1)<<g_state.nPollInterval))*10000000;
    g_state.tpTimeSinceLastSyncAttempt=0;
    g_state.tpTimeSinceLastGoodSync=0;
    g_state.tpIrregularDelayRemaining=MINIMUMIRREGULARINTERVAL; // 16s
    // If the minimum poll interval is small, use it the regular interval instead
    if (g_state.tpPollDelayRemaining<g_state.tpIrregularDelayRemaining
        || (g_state.tpPollDelayRemaining-g_state.tpIrregularDelayRemaining)<=MINIMUMIRREGULARINTERVAL) {
        g_state.tpIrregularDelayRemaining=0; // zero means no irregular sync
    }
    g_state.eLastSyncResult=e_NoData;
    g_state.eLastRegSyncResult=e_NoData;

    hr=S_OK;
error:
    return hr;
}

MODULEPRIVATE HRESULT UpdateTimerQueue2() { 
    BOOL     bEnteredCriticalSection  = false; 
    HRESULT  hr; 
    HRESULT  hr2; 

    hr = myEnterCriticalSection(&g_state.csW32Time); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    // keep track of how long we have left to wait
    unsigned __int64 teManagerWaitStop;
    AccurateGetSystemTime(&teManagerWaitStop);
    if (teManagerWaitStop>g_state.teManagerWaitStart) {
        unsigned __int64 tpManagerWait=teManagerWaitStop-g_state.teManagerWaitStart;
        if (tpManagerWait<g_state.tpPollDelayRemaining) {
            g_state.tpPollDelayRemaining-=tpManagerWait;
        } else {
            g_state.tpPollDelayRemaining=0;
        }
        if (0!=g_state.tpIrregularDelayRemaining) {
            if (tpManagerWait<g_state.tpIrregularDelayRemaining) {
                g_state.tpIrregularDelayRemaining-=tpManagerWait-1; // never goes to zero due to timeout
            } else {
                g_state.tpIrregularDelayRemaining=1; // never goes to zero due to timeout
            }
        }
        g_state.tpTimeSinceLastSyncAttempt+=tpManagerWait;
        g_state.tpTimeSinceLastGoodSync+=tpManagerWait;
    }

    hr = S_OK;
 error:
    if (bEnteredCriticalSection) { 
        hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }
    return hr; 
}

MODULEPRIVATE void WINAPI HandleTimeout(PVOID pvIgnored, BOOLEAN bIgnored) { 
    BOOL     bEnteredCriticalSection = false; 
    HRESULT  hr; 
    HRESULT  hr2; 

    FileLog0(FL_ServiceMainAnnounce, L"W32TmServiceMain: timeout\n");

    hr = myEnterCriticalSection(&g_state.csW32Time); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    hr = UpdateTimerQueue2(); 
    _JumpIfError(hr, error, "UpdateTimerQueue2"); 

    // wait time out.
    if (e_LongTimeNoSync==g_state.eTimeoutReason) {
        // this will handle most errors. returned errors are fatal
        hr = HandleManagerGoUnsyncd();
        _JumpIfError(hr, error, "HandleManagerGoUnsyncd");
    } else {
        // this will handle most errors. returned errors are fatal
        hr = HandleManagerGetTimeSamples(0!=g_state.tpIrregularDelayRemaining && g_state.eLastRegSyncResult==e_Success);
        _JumpIfError(hr, error, "HandleManagerGetTimeSamples");
    }

    hr = UpdateTimerQueue1(); 
    _JumpIfError(hr, error, "UpdateTimerQueue1"); 

    hr = S_OK; 
 error:
    if (S_OK != hr) { 
        // Errors in this function are fatal.  
        hr2 = SendServiceShutdown(hr, TRUE /*restart*/, TRUE /*async*/); 
        _IgnoreIfError(hr2, "SendServiceShutdown"); 
    }

    if (bEnteredCriticalSection) { 
        hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }        
}

// 1) Disables timeout
// 2) 
MODULEPRIVATE HRESULT UpdateTimerQueue1() { 
    BOOL              bEnteredCriticalSection  = false; 
    HRESULT           hr; 
    HRESULT           hr2; 
    unsigned __int64  tpLongTimeNoSync; 

    hr = myEnterCriticalSection(&g_state.csW32Time); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    // determine what timeout happens first
    g_state.tpWaitInterval=g_state.tpPollDelayRemaining;
    g_state.eTimeoutReason=e_RegularPoll;
    if (0!=g_state.tpIrregularDelayRemaining) {
        g_state.tpWaitInterval=g_state.tpIrregularDelayRemaining;
        g_state.eTimeoutReason=e_IrregularPoll;
    }
    // if we don't synchronize for 1.5 times the maximum interval, go unsynchronized
    tpLongTimeNoSync=((unsigned __int64)(((DWORD)3)<<(g_state.pciConfig->lcci.dwMaxPollInterval-1)))*10000000;
    if (tpLongTimeNoSync<g_state.tpTimeSinceLastGoodSync) {
        g_state.tpWaitInterval=0;
        g_state.eTimeoutReason=e_LongTimeNoSync;
    } else if (tpLongTimeNoSync-g_state.tpTimeSinceLastGoodSync<g_state.tpWaitInterval) {
        g_state.tpWaitInterval=tpLongTimeNoSync-g_state.tpTimeSinceLastGoodSync;
        g_state.eTimeoutReason=e_LongTimeNoSync;
    }

    // do the wait
    if (e_RegularPoll==g_state.eTimeoutReason) {
        FileLog2(FL_ServiceMainAnnounce, L"W32TmServiceMain: waiting %u.%03us\n",
                 (DWORD)(g_state.tpPollDelayRemaining/10000000),
                 (DWORD)((g_state.tpPollDelayRemaining/10000)%1000));
    } else if (e_LongTimeNoSync==g_state.eTimeoutReason) {
        FileLog4(FL_ServiceMainAnnounce, L"W32TmServiceMain: waiting ltns%u.%03us (%u.%03us)\n",
                 (DWORD)(g_state.tpWaitInterval/10000000),
                 (DWORD)((g_state.tpWaitInterval/10000)%1000),
                 (DWORD)(g_state.tpPollDelayRemaining/10000000),
                 (DWORD)((g_state.tpPollDelayRemaining/10000)%1000));
    } else { //e_IrregularPoll==g_state.eTimeoutReason
        FileLog4(FL_ServiceMainAnnounce, L"W32TmServiceMain: waiting i%u.%03us (%u.%03us)\n",
                 (DWORD)(g_state.tpIrregularDelayRemaining/10000000),
                 (DWORD)((g_state.tpIrregularDelayRemaining/10000)%1000),
                 (DWORD)(g_state.tpPollDelayRemaining/10000000),
                 (DWORD)((g_state.tpPollDelayRemaining/10000)%1000));
    }
    AccurateGetSystemTime(&g_state.teManagerWaitStart);

    // Update the timer queue with the new wait time: 
    if (NULL != g_state.hTimer) { 
        hr = myChangeTimerQueueTimer(NULL, g_state.hTimer, (DWORD)(g_state.tpWaitInterval/10000), 0xFFFFFF /*shouldn't be used*/);
	if (HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE) == hr) { 
	    // Someone's modifying the timer now -- either we're shutting down or someone else is using the timer thread.  
	    // We can ignore this error. 
	    _IgnoreError(hr, "myChangeTimerQueueTimer"); 
	} else { 
	    _JumpIfError(hr, error, "myChangeTimerQueueTimer"); 
	}
    }

    
    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
        hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false;
    }
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE void WINAPI HandleSamplesAvail(LPVOID pvIgnored, BOOLEAN bIgnored) { 
    bool     bDisallowedShutdown     = false; 
    bool     bEnteredCriticalSection = false; 
    HRESULT  hr; 
    HRESULT  hr2; 

    FileLog0(FL_ServiceMainAnnounce, L"W32TmServiceMain: resync req,");

    hr = myEnterCriticalSection(&g_state.csW32Time); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    hr = UpdateTimerQueue2(); 
    _JumpIfError(hr, error, "UpdateTimerQueue2"); 

    if (0!=g_state.tpIrregularDelayRemaining) {
        FileLogA0(FL_ServiceMainAnnounce, L" irreg already pending.\n");
    } else {
        // we will never sync more often than every 16s
        // get the minimum interval
        g_state.tpIrregularDelayRemaining=MINIMUMIRREGULARINTERVAL; // 16s
        // subtract any time we've already waited
        if (g_state.tpTimeSinceLastSyncAttempt>g_state.tpIrregularDelayRemaining) {
            g_state.tpIrregularDelayRemaining=1; // never goes to zero due to timeout
        } else {
            g_state.tpIrregularDelayRemaining-=g_state.tpTimeSinceLastSyncAttempt-1; // never goes to zero due to timeout
        }
        // if it's less than 16s until we do a regular sync,
        // we don't have time to do an irregular sync, so just skip it
        if (g_state.tpIrregularDelayRemaining>g_state.tpPollDelayRemaining
            || (g_state.tpPollDelayRemaining-g_state.tpIrregularDelayRemaining)<=MINIMUMIRREGULARINTERVAL) {
            g_state.tpIrregularDelayRemaining=0; // zero means no irregular sync
            FileLogA0(FL_ServiceMainAnnounce, L" reg too soon.\n");
        } else {
            FileLogA0(FL_ServiceMainAnnounce, L" irreg now pending.\n");
        }
    } // <- end if irregular update needs to be scheduled

    hr = UpdateTimerQueue1(); 
    _JumpIfError(hr, error, "UpdateTimerQueue1"); 

    hr = AllowShutdown(false); 
    _JumpIfError(hr, error, "AllowShutdown"); 
    bDisallowedShutdown = true; 

    // We've got to deregister this callback, even though it's only 
    // a WT_EXECUTEONLYONCE callback. 
    if (NULL != g_state.hRegisteredSamplesAvailEvent) { 
	if (!UnregisterWaitEx(g_state.hRegisteredSamplesAvailEvent, 0 /*don't wait*/)) { 
	    // Should just be a resource leak if we can't unregister this event. 
	    _IgnoreLastError("UnregisterWait"); 
	}
	g_state.hRegisteredSamplesAvailEvent = NULL; 
    }
    
    // Re-register the wait on our samples-avail event. 
    if (!RegisterWaitForSingleObject(&g_state.hRegisteredSamplesAvailEvent, g_state.hSamplesAvailEvent, HandleSamplesAvail, NULL, INFINITE, WT_EXECUTEONLYONCE)) { 
        _JumpLastError(hr, error, "RegisterWaitForSingleObject"); 
    }

    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
        hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }
    if (bDisallowedShutdown) { 
	hr2 = AllowShutdown(true); 
	_TeardownError(hr, hr2, "AllowShutdown"); 
    }

    // return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE DWORD WINAPI HandleSetProviderStatus(PVOID pvSetProviderStatusInfo) { 
    bool                     bDisallowedShutdown      = false; 
    bool                     bEnteredCriticalSection  = false; 
    bool                     bUpdateSystemStratum;
    HRESULT                  hr; 
    SetProviderStatusInfo   *pspsi                    = static_cast<SetProviderStatusInfo *>(pvSetProviderStatusInfo); 
    TimeProvider            *ptp                      = NULL; 

    FileLog0(FL_ServiceMainAnnounce, L"W32TmServiceMain: provider status update request: ");

    hr = myEnterCriticalSection(&g_state.csW32Time); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection=true; 

    hr = AllowShutdown(false); 
    _JumpIfError(hr, error, "AllowShutdown"); 
    bDisallowedShutdown = true; 

    // Search for the provider that requested a stratum change:
    for (ptp = g_state.pciConfig->ptpProviderList; NULL != ptp; ptp = ptp->ptpNext) { 
	if (0 == wcscmp(pspsi->wszProvName, ptp->wszProvName)) { 
	    // We've found the provider which made the callback
	    break; 
	}
    }

    // provider not found
    if (NULL == ptp) {         
	FileLogA0(FL_ServiceMainAnnounce, L"provider not found.\n"); 
	hr = E_INVALIDARG; 
	_JumpError(hr, error, "Provider not found"); 
    }

    if (TPS_Error == pspsi->tpsCurrentState) { 
	FileLogA2(FL_ServiceMainAnnounce, L" <%s, %d, TPS_Error>\n", ptp->wszProvName, pspsi->dwStratum); 

	// The provider has encountered an error it cannot recover from.  
	// 1) Stop the provider
	hr = StopProvider(ptp); 
	if (FAILED(hr)) { 
	    _IgnoreError(hr, "HandleSetProviderStatus: StopProvider"); 
	    FileLog1(FL_ServiceMainAnnounce, L"Couldn't stop provider: %s\n", ptp->wszProvName); 
	} 

	// 2) Delete it from our provider list, and report the error:
	hr = RemoveProviderFromList(ptp); 
	if (FAILED(hr)) { 
	    _IgnoreError(hr, "HandleSetProviderStatus: RemoveProviderFromList"); 
	    FileLog1(FL_ServiceMainAnnounce, L"Couldn't remove provider from list: %s\n", ptp->wszProvName); 
	}
    } else if (TPS_Running == pspsi->tpsCurrentState) { 
	// The provider is still running, now set other status information for the provider:

	// 1) Set the provider stratum
	    
	// Don't allow the provider to set its stratum to a value BETTER than the
	// best sample it has provided. 
	if (0 != pspsi->dwStratum && ptp->dwStratum > pspsi->dwStratum) { 
	    FileLogA1(FL_ServiceMainAnnounce, L"stratum too low (best provider stratum == %d).\n", ptp->dwStratum); 
	    hr = E_INVALIDARG; 
	    _JumpError(hr, error, "Stratum too low");
	}

	FileLogA2(FL_ServiceMainAnnounce, L"<%s, %d, TPS_Running>\n", ptp->wszProvName, pspsi->dwStratum); 

	// Update the provider with the new stratum information: 
	ptp->dwStratum = pspsi->dwStratum; 

	// Check if we need to update the system stratum. 
	// The system stratum will be updated iff the providers new stratum 
	// is superior all other provider's stratums, and inferior to the
	// current system stratum. 
	//
	if (e_ClockNotSynchronized == g_state.eLeapIndicator || 
	    (0 != pspsi->dwStratum && g_state.nStratum >= pspsi->dwStratum)) { 
	    // The new stratum is superior to the system stratum -- 
	    // the system stratum will not be updated. 
	    bUpdateSystemStratum = false; 
	} else { 
	    bUpdateSystemStratum = true; 
	    for (ptp = g_state.pciConfig->ptpProviderList; NULL != ptp; ptp = ptp->ptpNext) { 
		if (0 != ptp->dwStratum &&  
		    (0 == pspsi->dwStratum || pspsi->dwStratum > ptp->dwStratum)) {
		    // The new stratum is NOT superior to this provider's stratum, do not update 
		    // the system stratum. 
		    bUpdateSystemStratum = false; 
		}
	    }
	}
     
	if (bUpdateSystemStratum) { 
	    FileLog2(FL_ServiceMainAnnounce, L"***System stratum updated***, %d --> %d", g_state.nStratum, pspsi->dwStratum); 
	    g_state.nStratum = pspsi->dwStratum; 
	    if (0 == g_state.nStratum) { 
		// We've reset our system stratum to 0 -- this means we're not synchronized.
		g_state.eLeapIndicator = e_ClockNotSynchronized; 
	    }
	} else { 
	    FileLog1(FL_ServiceMainAnnounce, L"System stratum not updated: %d\n", g_state.nStratum); 
	}
    } else { 
	FileLogA1(FL_ServiceMainAnnounce, L"bad provider status code, %d\n", pspsi->tpsCurrentState);  
	hr = E_INVALIDARG; 
	_JumpError(hr, error, "bad provider status code");
    }
	
    hr = S_OK; 
 
 error:
    if (bEnteredCriticalSection) { 
	HRESULT hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
	_IgnoreIfError(hr2, "myLeaveCriticalSection"); 
	bEnteredCriticalSection = false; 
    }
    if (bDisallowedShutdown) { 
	HRESULT hr2 = AllowShutdown(true); 
	_TeardownError(hr, hr2, "AllowShutdown"); 
    }
    if (NULL != pspsi) { 
	// We're done, write the result of the operations, 
	// and signal completion if caller passed us an event handle:
	if (NULL != pspsi->pHr) { 
	    *(pspsi->pHr) = hr; 
	}
	if (NULL != pspsi->pdwSysStratum) { 
	    *(pspsi->pdwSysStratum) = g_state.nStratum; 
	}
	if (NULL != pspsi->hWaitEvent) { 
	    if (!SetEvent(pspsi->hWaitEvent)) { 
		_IgnoreError(HRESULT_FROM_WIN32(GetLastError()), "SetEvent"); 
	    }
	}
	// Use the callback deallocation function to free the input param
	pspsi->pfnFree(pspsi); 
    }

    return hr; 
}


//--------------------------------------------------------------------
MODULEPRIVATE void HandleDomHierRoleChangeEvent(LPVOID pvIgnored, BOOLEAN bIgnored) {
    bool                               bEnteredCriticalSection  = false; 
    bool                               bIsDomainRoot; 
    BOOL                               bPdcInSite; 
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC  *pDomInfo                 = NULL;
    DWORD                              dwErr; 
    HRESULT                            hr;
    LPWSTR                             pwszParentDomName        = NULL; 

    FileLog0(FL_DomHierAnnounce, L"  DomainHierarchy: LSA role change notification. Redetecting.\n");

    dwErr = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (BYTE **)&pDomInfo);
    if (ERROR_SUCCESS != dwErr) {
        hr = HRESULT_FROM_WIN32(dwErr);
        _JumpError(hr, error, "DsRoleGetPrimaryDomainInformation");
    }

    dwErr = NetLogonGetTimeServiceParentDomain(NULL, &pwszParentDomName, &bPdcInSite);
    if (ERROR_SUCCESS!=dwErr && ERROR_NO_SUCH_DOMAIN != dwErr) {
        hr = HRESULT_FROM_WIN32(dwErr);
        _JumpError(hr, error, "NetLogonGetTimeServiceParentDomain");
    }

    bIsDomainRoot = ((DsRole_RolePrimaryDomainController == pDomInfo->MachineRole) && 
                     (NULL                               == pwszParentDomName)); 

    hr = myEnterCriticalSection(&g_state.csW32Time); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    if (bIsDomainRoot != g_state.bIsDomainRoot) { 
        // The PDC role in the root domain has changed.  Update whether we are a reliable time service. 
        g_state.bIsDomainRoot = bIsDomainRoot; 
        hr = UpdateNetlogonServiceBits(false /*reliable only*/);
        _JumpIfError(hr, error, "UpdateNetlogonServiceBits"); 

        if (bIsDomainRoot) { 
            FileLog0(FL_DomHierAnnounce, L"    DomainHierarchy:  we are now the domain root.  Should be advertised as reliable\n");
        } else { 
            FileLog0(FL_DomHierAnnounce, L"    DomainHierarchy:  we are no longer the domain root.  Should NOT be advertised as reliable\n");
        }
    }

    hr = S_OK; 
 error: 
    if (bEnteredCriticalSection) { 
        HRESULT hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }
    if (NULL!=pDomInfo)          { DsRoleFreeMemory(pDomInfo); }
    if (NULL!=pwszParentDomName) { NetApiBufferFree(pwszParentDomName); }

    if (FAILED(hr)) { 
        // Couldn't determine our domain role.  Log an event. 
        
    }
    // return hr; 
}


//--------------------------------------------------------------------
MODULEPRIVATE void HandleManagerTimeSlip(LPVOID pvIgnored, BOOLEAN bIgnored) {
    BOOL                     bEnteredCriticalSection = false; 
    HRESULT                  hr;
    HRESULT                  hr2;
    TpcTimeJumpedArgs        tjArgs; 

    FileLog0(FL_TimeSlipAnnounce, L"W32TmServiceMain: ********** Time Slip Notification **********\n");

    hr = myEnterCriticalSection(&g_state.csW32Time); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    hr = UpdateTimerQueue2(); 
    _JumpIfError(hr, error, "UpdateTimerQueue2"); 

    // tell the local clock and the providers and update the timeouts
    if (NULL == pvIgnored) { 
	tjArgs.tjfFlags = TJF_Default; 
    } else { 
	tjArgs = *((TpcTimeJumpedArgs *)pvIgnored); 
    }
    hr=HandleManagerHardResync(TPC_TimeJumped, &tjArgs);
    _JumpIfError(hr, error, "HandleManagerHardResync");
    
    hr = UpdateTimerQueue1(); 
    _JumpIfError(hr, error, "UpdateTimerQueue1"); 
    
    hr = S_OK;
error:
    if (S_OK != hr) {
        // Errors in this function are fatal.  
        hr2 = SendServiceShutdown(hr, TRUE /*restart*/, TRUE /*async*/); 
        _IgnoreIfError(hr2, "SendServiceShutdown"); 
    }
    if (bEnteredCriticalSection) { 
        hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }

    // return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT RequestNetTopoChangeNotification(void) {
    HRESULT hr;

    // get notified whenever a change occurs in the table that maps IP addresses to interfaces.
    // Essentially, we're making an overlapped call to DeviceIORequest.
    ZeroMemory(&g_state.olNetTopoIOOverlapped, sizeof(OVERLAPPED));
    g_state.olNetTopoIOOverlapped.hEvent=g_state.hNetTopoChangeEvent;
    hr=NotifyAddrChange(&g_state.hNetTopoIOHandle, &g_state.olNetTopoIOOverlapped);
    _Verify(NO_ERROR!=hr, hr, error);

    if (ERROR_OPEN_FAILED == hr) { 
        // Probably just don't have TCP/IP installed -- we should still be able to sync
        // from a HW prov.  Should we try to redected network? 
        HRESULT hr2 = MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_TCP_NOT_INSTALLED, 0, NULL); 
        _IgnoreIfError(hr2, "MyLogEvent"); 

        // No reason for our default network providers to run anymore -- shut them down:
        RemoveDefaultProvidersFromList(); 

        // Returned errors are fatal -- we can recover from this error, so log an event
        // and move on.  
        hr = S_OK;  
        goto error; 
    }
        
    if (ERROR_IO_PENDING!=hr) {
        hr=HRESULT_FROM_WIN32(hr);
        _JumpError(hr, error, "NotifyAddrChange");
    }

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StopNetTopoChangeNotification(void) {
    return S_OK; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT HandleManagerNetTopoChange(bool bRpc) {
    bool                     bDisallowedShutdown      = false;
    bool                     bEnteredCriticalSection  = false; 
    DWORD                    dwIgnored;
    HRESULT                  hr;
    HRESULT                  hr2;
    TpcNetTopoChangeArgs     ntcArgs = { NTC_Default }; 

    hr = myEnterCriticalSection(&g_state.csW32Time); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    hr = UpdateTimerQueue2(); 
    _JumpIfError(hr, error, "UpdateTimerQueue2"); 

    if (bRpc) {
        FileLog0(FL_NetTopoChangeAnnounce, L"W32TmServiceMain: Network Topology Change (RPC)\n");
	// The user requested this net topo change
	ntcArgs.ntcfFlags = NTC_UserRequested; 
    } else {
        FileLog0(FL_NetTopoChangeAnnounce, L"W32TmServiceMain: Network Topology Change\n");

	// We've received this message
	if (!ResetEvent(g_state.hNetTopoChangeEvent)) { 
	    _JumpLastError(hr, error, "ResetEvent"); 
	}

	// We can't mess with our registered callbacks FROM a callback 
	// if we're shutting down!
	hr = AllowShutdown(false); 
	_JumpIfError(hr, error, "AllowShutdown"); 
	bDisallowedShutdown = true; 

	// The registered event handle could be NULL if registering the
	// net topo change handler failed: 
	if (NULL != g_state.hRegisteredNetTopoChangeEvent) {
	    if (!UnregisterWaitEx(g_state.hRegisteredNetTopoChangeEvent, 0 /*don't wait*/)) { 
		// Should just be a resource leak if we can't unregister this event. 
		_IgnoreLastError("UnregisterWait"); 
	    }
	    g_state.hRegisteredNetTopoChangeEvent = NULL; 
	}

	if (!RegisterWaitForSingleObject(&g_state.hRegisteredNetTopoChangeEvent, g_state.hNetTopoChangeEvent, HandleManagerNetTopoChangeNoRPC, NULL, INFINITE, WT_EXECUTEONLYONCE)) { 
	    _JumpLastError(hr, error, "RegisterWaitForSingleObject"); 
	} 
	
	// We can't mess with our registered callbacks FROM a callback 
	// if we're shutting down!
	hr = AllowShutdown(true); 
	_JumpIfError(hr, error, "AllowShutdown"); 
	bDisallowedShutdown = false; 

	// request a notification of the next change
	hr=RequestNetTopoChangeNotification();
	_JumpIfError(hr, error, "RequestNetTopoChangeNotification");
    }

    // tell the local clock and the providers and update the timeouts.
    // Errors in this function are fatal, as we won't be able to serve time
    // if we can't process a net topo change. 
    hr=HandleManagerHardResync(TPC_NetTopoChange, &ntcArgs);
    _JumpIfError(hr, error, "HandleManagerHardResync");

    // Since we're going to have to rediscover our network sources,
    // clear our event log cache:
    hr = MyResetSourceChangeLog(); 
    _JumpIfError(hr, error, "MyResetSourceChangeLog"); 

    hr = UpdateTimerQueue1(); 
    _JumpIfError(hr, error, "UpdateTimerQueue1"); 

    hr=S_OK;
error:
    if (bEnteredCriticalSection) { 
        hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }
    if (bDisallowedShutdown) { 
	hr2 = AllowShutdown(true); 
	_TeardownError(hr, hr2, "AllowShutdown"); 
    }
    if (FAILED(hr) && W32TIME_ERROR_SHUTDOWN != hr) { 
        // Returned errors are fatal: 
        HRESULT hr2 = SendServiceShutdown(hr, TRUE /*restart*/, TRUE /*async*/); 
        _IgnoreIfError(hr2, "SendServiceShutdown"); 
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE void WINAPI HandleManagerNetTopoChangeNoRPC(LPVOID pvIgnored, BOOLEAN bIgnored) {
    HandleManagerNetTopoChange(FALSE); 
}


//--------------------------------------------------------------------
MODULEPRIVATE void HandleManagerSystemShutdown(void) { 
    HRESULT hr; 

    // Perform critical cleanup operations.  We don't need to be in a good
    // state after this method returns, as the system is shutting down. 
    
    // 1) See if we're already shutting down.  We don't want multiple
    //    shutdowns to occur at the same time. 
    hr = StartShutdown(); 
    _JumpIfError(hr, error, "StartShutdown"); 

    FileLog0(FL_ServiceMainAnnounce, L"Beginning System Shutdown\n");

	// 2) try our best to restore control to the cmos clock, by shutting 
	//    down the clock discipline thread.  This is important, as 
	//    the software clock may have a very different reading than the 
	//    cmos clock, and failing to do so may give us bad time on the next
	//    boot. 
    if (!SetEvent(g_state.hShutDownEvent)) { 
	_IgnoreLastError("SetEvent"); 
    } else { 
	if (-1 == WaitForSingleObject(g_state.hClockDisplnThread, INFINITE)) { 
	    _IgnoreLastError("WaitForSingleObject"); 
	}
    }

    // 3) inform our providers that a system shutdown is occuring
    if (NULL != g_state.pciConfig) { 
	for (TimeProvider *ptpList=g_state.pciConfig->ptpProviderList; NULL!=ptpList; ptpList=ptpList->ptpNext) {
	    // tell the provider to shut down.  
	    HRESULT hr = ptpList->pfnTimeProvCommand(ptpList->hTimeProv, TPC_Shutdown, NULL); 
	    _IgnoreIfError(hr, "ptpList->pfnTimeProvCommand: TPC_Shutdown"); 
	} 
    }

    FileLog0(FL_ServiceMainAnnounce, L"Exiting System Shutdown\n");

    if (NULL!=g_state.servicestatushandle) {
	// WARNING: The process may be killed after we report we are stopped
	// even though this thread has not exited. Thus, the file log
	// must be closed before this call.
	MySetServiceStopped(0);  
    }

 error:;
    // return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StartOrStopTimeSlipNotification(bool bStart) {
    HRESULT hr;
    const unsigned int nPrivileges=1;

    // must be cleaned up
    HANDLE hProcToken=NULL;
    TOKEN_PRIVILEGES * ptp=NULL;
    bool bPrivilegeChanged=false;

    // get the token for our process
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hProcToken)) {
        _JumpLastError(hr, error, "OpenProcessToken");
    }

    // allocate the list of privileges
    ptp=(TOKEN_PRIVILEGES *)LocalAlloc(LPTR, sizeof(TOKEN_PRIVILEGES)+(nPrivileges-ANYSIZE_ARRAY)*sizeof(LUID_AND_ATTRIBUTES));
    _JumpIfOutOfMemory(hr, error, ptp);

    // fill in the list of privileges
    ptp->PrivilegeCount=nPrivileges;

    // we need the system clock changing privelege to change who will be notified of time slip events.
    if (!LookupPrivilegeValue(NULL, SE_SYSTEMTIME_NAME, &(ptp->Privileges[0].Luid))) {
        _JumpLastError(hr, error, "LookupPrivilegeValue");
    }
    ptp->Privileges[0].Attributes=SE_PRIVILEGE_ENABLED;

    // make the requested privilege change
    if (!AdjustTokenPrivileges(hProcToken, FALSE, ptp, 0, NULL, 0)) {
        _JumpLastError(hr, error, "AdjustTokenPrivileges");
    }
    bPrivilegeChanged=true;

    if (true==bStart) {
        hr=SetTimeSlipEvent(g_state.hTimeSlipEvent);
    } else {
        hr=SetTimeSlipEvent(NULL);
    }
    if (ERROR_SUCCESS!=hr) {
        hr=HRESULT_FROM_WIN32(LsaNtStatusToWinError(hr));
        _JumpError(hr, error, "SetTimeSlipEvent");
    }

    hr=S_OK;
error:
    if (true==bPrivilegeChanged) {
        // don't need this special privilege any more
        ptp->Privileges[0].Attributes=0;

        // make the requested privilege change
        if (!AdjustTokenPrivileges(hProcToken, FALSE, ptp, 0, NULL, 0)) {
            HRESULT hr2=HRESULT_FROM_WIN32(GetLastError());
            _TeardownError(hr, hr2, "AdjustTokenPrivileges");
        }
    }
    if (NULL!=hProcToken) {
        CloseHandle(hProcToken);
    }
    if (NULL!=ptp) {
        LocalFree(ptp);
    }
    return hr;

}

//====================================================================
// RPC routines

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT W32TmStartRpcServer(void) {
    HRESULT hr;
    RPC_STATUS RpcStatus;

    // must be cleaned up
    WCHAR * wszServerPrincipalName=NULL;

    if (NULL!=g_pSvcsGlobalData) {
        // we are running under services.exe - we have to play nicely and share
        // the proces's RPC server. (The other services wouldn't be happy if we 
        // shut it down while they were still using it.)
        //RpcStatus=g_pSvcsGlobalData->StartRpcServer(g_pSvcsGlobalData->SvcsRpcPipeName, s_W32Time_v4_1_s_ifspec);
        RpcStatus=g_pSvcsGlobalData->StartRpcServer(wszW32TimeSharedProcRpcEndpointName, s_W32Time_v4_1_s_ifspec);
        if (RPC_S_OK!=RpcStatus) {
            hr=HRESULT_FROM_WIN32(RpcStatus);
            _JumpError(hr, error, "g_pSvcsGlobalData->StartRpcServer");
        }

    } else {
        // we are running by ourselves, so manage RPC by ourselves

        // tell Rpc to prepare our named pipe for use. we specify no security descriptor. 
        // we get our security from the underlying transport layer security of named pipes.
        RpcStatus=RpcServerUseProtseqEp(L"ncacn_np", RPC_C_PROTSEQ_MAX_REQS_DEFAULT , L"\\PIPE\\" wszW32TimeOwnProcRpcEndpointName, NULL);
        if (RPC_S_OK!=RpcStatus) {
            hr=HRESULT_FROM_WIN32(RpcStatus);
            _JumpError(hr, error, "RpcServerUseProtseqEp");
        }

        // register our interface
        RpcStatus=RpcServerRegisterIf(s_W32Time_v4_1_s_ifspec, NULL, NULL);
        if (RPC_S_OK!=RpcStatus) {
            hr=HRESULT_FROM_WIN32(RpcStatus);
            _JumpError(hr, error, "RpcServerRegisterIf");
        }

        // start the Rpc server (non-blocking).
        RpcStatus=RpcServerListen(1, RPC_C_LISTEN_MAX_CALLS_DEFAULT, TRUE);
        if (RPC_S_OK!=RpcStatus) {
            hr=HRESULT_FROM_WIN32(RpcStatus);
            _JumpError(hr, error, "RpcServerListen");
        }
    }
    
    // The RPC server is now active. 
    g_state.bRpcServerStarted=true;

    // allow clients to make authenticated requests
    RpcStatus=RpcServerInqDefaultPrincName(RPC_C_AUTHN_GSS_NEGOTIATE, &wszServerPrincipalName);
    if (RPC_S_OK!=RpcStatus) {
        hr=HRESULT_FROM_WIN32(RpcStatus);
        _JumpError(hr, error, "RpcServerListen");
    }
    RpcStatus=RpcServerRegisterAuthInfo(wszServerPrincipalName, RPC_C_AUTHN_GSS_NEGOTIATE, NULL, NULL);
    if (RPC_S_OK!=RpcStatus) {
        hr=HRESULT_FROM_WIN32(RpcStatus);
        _JumpError(hr, error, "RpcServerListen");
    }

    hr=S_OK;
error:
    if (NULL!=wszServerPrincipalName) {
        RpcStringFree(&wszServerPrincipalName);
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT W32TmStopRpcServer(void) {
    HRESULT hr;
    RPC_STATUS RpcStatus;

    // shut down any pending resync requests
    // open up both gates
    g_state.eLastSyncResult=e_Shutdown;
    if (!SetEvent(g_state.hRpcSyncCompleteAEvent)) {
        _JumpLastError(hr, error, "SetEvent");
    }
    if (!SetEvent(g_state.hRpcSyncCompleteBEvent)) {
        _JumpLastError(hr, error, "SetEvent");
    }

    if (NULL!=g_pSvcsGlobalData) {
        // we are running under services.exe - we have to play nicely and share
        // the proces's RPC server. (The other services wouldn't be happy if we 
        // shut it down while they were still using it.)
        RpcStatus=g_pSvcsGlobalData->StopRpcServer(s_W32Time_v4_1_s_ifspec);
        if (RPC_S_OK!=RpcStatus) {
            hr=HRESULT_FROM_WIN32(RpcStatus);
            _JumpError(hr, error, "g_pSvcsGlobalData->StopRpcServer");
        }

    } else {
        // we are running by ourselves, so manage RPC by ourselves

        // stop listening on our interface, and wait for calls to complete
        RpcStatus=RpcServerUnregisterIf(s_W32Time_v4_1_s_ifspec, NULL, TRUE);
        if (RPC_S_OK!=RpcStatus) {
            hr=HRESULT_FROM_WIN32(RpcStatus);
            _JumpError(hr, error, "RpcServerUnregisterIf");
        }

        // tell the local server to stop completely
        RpcStatus=RpcMgmtStopServerListening(NULL);
        if (RPC_S_OK!=RpcStatus) {
            hr=HRESULT_FROM_WIN32(RpcStatus);
            _JumpError(hr, error, "RpcMgmtStopServerListening");
        }

        // wait for the server to stop completely
        RpcStatus=RpcMgmtWaitServerListen();
        if (RPC_S_OK!=RpcStatus) {
            hr=HRESULT_FROM_WIN32(RpcStatus);
            _JumpError(hr, error, "RpcMgmtWaitServerListen");
        }

    }

    hr=S_OK;
error:
    return hr;
}
      
//--------------------------------------------------------------------
MODULEPRIVATE HRESULT DumpRpcCaller(HANDLE hToken) {
    HRESULT hr;
    WCHAR wszName[1024];
    WCHAR wszDomain[1024];
    DWORD dwSize;
    DWORD dwSize2;
    SID_NAME_USE SidType;
    WCHAR * wszEnable;

    // must be cleaned up
    TOKEN_USER * pTokenUser=NULL;
    WCHAR * wszSid=NULL;

    // Call GetTokenInformation to get the buffer size.
    _Verify(!GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize), hr, error);
    if (GetLastError()!=ERROR_INSUFFICIENT_BUFFER) {
        _JumpLastError(hr, error, "GetTokenInformation");
    }

    // Allocate the buffer.
    pTokenUser=(TOKEN_USER *)LocalAlloc(LPTR, dwSize);
    _JumpIfOutOfMemory(hr, error, pTokenUser);

    // Call GetTokenInformation again to get the group information.
    if (!GetTokenInformation(hToken, TokenUser, pTokenUser, dwSize, &dwSize)) {
        _JumpLastError(hr, error, "GetTokenInformation");
    }

    // Lookup the account name and print it.
    dwSize=ARRAYSIZE(wszName);
    dwSize2=ARRAYSIZE(wszDomain);
    if (!LookupAccountSid(NULL, pTokenUser->User.Sid, wszName, &dwSize, wszDomain, &dwSize2, &SidType ) ) {
        hr=GetLastError();
        if (ERROR_NONE_MAPPED==hr) {
            wcscpy(wszName, L"NONE_MAPPED");
        } else {
            _JumpLastError(hr, error, "LookupAccountSid");
        }
    }

    if (!ConvertSidToStringSid(pTokenUser->User.Sid, &wszSid)) {
        _JumpLastError(hr, error, "ConvertSidToStringSid");
    }

    FileLog3(FL_RpcAnnounce, L"RPC Caller is %s\\%s (%s)\n", wszDomain, wszName, wszSid);

    hr=S_OK;
error:
    if (NULL!=pTokenUser) {
        LocalFree(pTokenUser);
    }
    if (NULL!=wszSid) {
        LocalFree(wszSid);
    }
    if (FAILED(hr)) { 
        FileLog1(FL_RpcAnnounce, L"*** Couldn't dump RPC caller.  The error was: %d\n", hr); 
    }
    return hr;
}

//--------------------------------------------------------------------
extern "C" DWORD s_W32TimeSync(handle_t hHandle, ULONG ulWait, ULONG ulFlags) {
    BOOL     fHasPrivilege  = FALSE;
    DWORD    dwWaitTimeout  = INFINITE; 
    HRESULT  hr;

    // become the caller
    hr=RpcImpersonateClient((RPC_BINDING_HANDLE) hHandle);
    if (RPC_S_OK==hr) {
        BYTE            pbPrivsBuffer[sizeof(PRIVILEGE_SET) + (1-ANYSIZE_ARRAY)*sizeof(LUID_AND_ATTRIBUTES)]; 
        PRIVILEGE_SET  *ppsRequiredPrivs;

        // must be cleaned up
        HANDLE hClientToken=NULL;

        // generate the list of required privileges - namely, the ability to set the clock
        ppsRequiredPrivs=(PRIVILEGE_SET *)(&pbPrivsBuffer[0]);
        ppsRequiredPrivs->PrivilegeCount=1;
        ppsRequiredPrivs->Control=PRIVILEGE_SET_ALL_NECESSARY;
        ppsRequiredPrivs->Privilege[0].Attributes=0;
        if (!LookupPrivilegeValue(NULL, SE_SYSTEMTIME_NAME, &(ppsRequiredPrivs->Privilege[0].Luid))) {
            _JumpLastError(hr, access_check_error, "LookupPrivilegeValue");
        }

        // get our impersonated token
        if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hClientToken)) {
            _JumpLastError(hr, access_check_error, "OpenThreadToken");
        }

        // log the caller.
        if (FileLogAllowEntry(FL_RpcAnnounce)) {
            DumpRpcCaller(hClientToken);
        }

        // see if this caller has time setting privileges
        if (!PrivilegeCheck(hClientToken, ppsRequiredPrivs, &fHasPrivilege)) {
            _JumpLastError(hr, access_check_error, "PrivilegeCheck");
        }
        
        // done
    access_check_error:
        if (NULL!=hClientToken) {
            CloseHandle(hClientToken);
        }
        hr = RpcRevertToSelf();
        _IgnoreIfError(hr, "RpcRevertToSelf"); 

    } else {
	_IgnoreError(hr, "RpcImpersonateClient");
    }

    // alert the manager as to what type of resync we want to do
    if (0!=(ulFlags&TimeSyncFlag_Rediscover)) {
        if (!fHasPrivilege) {
            FileLog0(FL_RpcAnnounce, L"RPC Call - Rediscover - Access Denied\n")
            hr=HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
            goto error;
        }
        FileLog0(FL_RpcAnnounce, L"RPC Call - Rediscover\n");
        hr = HandleManagerNetTopoChange(TRUE /*rpc*/);
        _JumpIfError(hr, error, "HandleManagerNetTopoChange"); 
    } else if (0!=(ulFlags&TimeSyncFlag_HardResync)) {
        if (!fHasPrivilege) {
            FileLog0(FL_RpcAnnounce, L"RPC Call - HardResync - Access Denied\n")
            hr=HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
            goto error;
        }
        FileLog0(FL_RpcAnnounce, L"RPC Call - HardResync\n"); 
	TpcTimeJumpedArgs tjArgs = { TJF_UserRequested }; 
	HandleManagerTimeSlip(&tjArgs, FALSE); 
    } else if (0!=(ulFlags&TimeSyncFlag_UpdateAndResync)) { 
	if (!fHasPrivilege) { 
            FileLog0(FL_RpcAnnounce, L"RPC Call - UpdateAndResync - Access Denied\n")
            hr=HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
            goto error;
        }
        FileLog0(FL_RpcAnnounce, L"RPC Call - UpdateAndResync\n"); 
	HandleManagerParamChange(NULL /*pvIgnored*/, FALSE /*bIgnored*/); 
	dwWaitTimeout = MINIMUMIRREGULARINTERVAL / 10000; 
    } else {
        FileLog0(FL_RpcAnnounce, L"RPC Call - SoftResync\n"); 
        if (!SetEvent(g_state.hSamplesAvailEvent)) { 
	    _JumpLastError(hr, error, "SetEvent"); 
	}
    }

    // wait for resync to complete if so instructed
    if (0!=ulWait) {
	DWORD dwWaitResult = WaitForSingleObject(g_state.hRpcSyncCompleteEvent, dwWaitTimeout); 
	if (WAIT_FAILED==dwWaitResult) { 
            _JumpLastError(hr, error, "WaitForSingleObject");
        } else if (WAIT_TIMEOUT==dwWaitResult) { 
	    hr = ResyncResult_NoData; 
	    goto error; 
	}
    }

    // successful
    hr=S_OK;
    if (0!=ulWait && 0!=(ulFlags&TimeSyncFlag_ReturnResult)) {
        hr=g_state.eLastSyncResult;
    }

error:
    return hr;
}

//--------------------------------------------------------------------

extern "C" unsigned long s_W32TimeQueryProviderStatus(/* [in] */           handle_t                 hRPCBinding, 
                                                      /* [in] */           unsigned __int32         ulFlags, 
                                                      /* [in, string] */   wchar_t                 *pwszProvider, 
                                                      /* [in, out] */      PW32TIME_PROVIDER_INFO  *pProviderInfo)
{
  
    HRESULT        hr; 
    TimeProvider  *ptp = NULL; 

    // BUGBUG:  what is the appropriate access needed to call this routine? 

    // Search for the provider to query: 
    // BUGBUG: should we ensure somewhere that provider names are < 1024? 
    for (ptp = g_state.pciConfig->ptpProviderList; NULL != ptp; ptp = ptp->ptpNext) { 
        // Don't compare more than 1024 characters (prevents possible DoS attack for very long strings)
        if (0 == _wcsnicmp(pwszProvider, ptp->wszProvName, 1024)) { 
            break; 
        }
    }

    if (NULL == ptp) { 
        // Couldn't find a provider. 
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND); 
        _JumpError(hr, error, "W32TimeQueryProviderStatus_r:  provider not found."); 
    } 

    // We've found a matching provider, dispatch the query command to it.
    _BeginTryWith(hr) { 
        hr = ptp->pfnTimeProvCommand(ptp->hTimeProv, TPC_Query, pProviderInfo); 
    } _TrapException(hr); 
    
    if (FAILED(hr)) { 
	// An exception occured querying the provider
	_JumpError(hr, error, "ptp->pfnTimeProvCommand"); 
    }

    hr = S_OK; 
 error:
    return hr;  
}

//--------------------------------------------------------------------
// Netlogon can call this function and get our service bits if we start
// before they do. Note that we tell and they ask, and depending upon
// who started up first one of the two will be succesful. Either way,
// the flags will be set correctly.
extern "C" unsigned long s_W32TimeGetNetlogonServiceBits(handle_t hBinding) {
    // assume dword reads and writes are atomic
    return g_state.dwNetlogonServiceBits;
}

//####################################################################
// module public functions

//--------------------------------------------------------------------
extern "C" void WINAPI W32TmServiceMain(unsigned int nArgs, WCHAR ** rgwszArgs) {
    DWORD         dwWaitResult;
    HANDLE        rghWait[7];
    HRESULT       hr;
    unsigned int  nCheckpoint;

    _set_se_translator(SeTransFunc); 

    // do the bare minimum initialization
    hr=InitShutdownState(); 
    _JumpIfError(hr, error, "InitShutdownState"); 
    hr=InitGlobalState();
    _JumpIfError(hr, error, "InitGlobalState");
    hr=FileLogBegin();
    _JumpIfError(hr, error, "FileLogBegin");
    FileLog0(FL_ServiceMainAnnounce, L"Entered W32TmServiceMain\n");

    {
        DWORD dwAdj;
        DWORD dwInc;
        BOOL bDisabled;
        GetSystemTimeAdjustment(&dwAdj, &dwInc, &bDisabled);
        FileLog3(FL_ServiceMainAnnounce, L"CurSpc:%u00ns  BaseSpc:%u00ns  SyncToCmos:%s\n", dwAdj, dwInc, (bDisabled?L"Yes":L"No"));
        LARGE_INTEGER nPerfFreq;
        if (QueryPerformanceFrequency(&nPerfFreq)) {
            FileLog1(FL_ServiceMainAnnounce, L"PerfFreq:%I64uc/s\n", nPerfFreq.QuadPart);
        }
 
    }

    g_state.servicestatushandle=fnW32TmRegisterServiceCtrlHandlerEx(wszSERVICENAME, W32TimeServiceCtrlHandler, NULL);
    if (NULL==g_state.servicestatushandle) {
        _JumpLastError(hr, error, "fnW32TmRegisterServiceCtrlHandlerEx");
    }

    // if the time zone is invalid, fixing the time won't help any.
    hr=VerifyAndFixTimeZone();
    _JumpIfError(hr, error, "VerifyAndFixTimeZone");

    // get the configuration data
    hr=ReadConfig(&g_state.pciConfig);
    if (FAILED(hr)) {
        // log an event on failure
        WCHAR * rgwszStrings[1]={NULL};
        HRESULT hr2=hr;
        hr=GetSystemErrorString(hr2, &(rgwszStrings[0]));
        _JumpIfError(hr, error, "GetSystemErrorString");
        FileLog1(FL_ParamChangeWarn, L"Logging error: The time service encountered an error while reading its configuration from the registry and cannot start. The error was: %s\n", rgwszStrings[0]);
        hr=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_CONFIG_READ_FAILED, 1, (const WCHAR **)rgwszStrings);
        LocalFree(rgwszStrings[0]);
        _JumpIfError(hr, error, "MyLogEvent");
        hr=hr2;
        _JumpError(hr, error, "ReadConfig");
    }
    // other global state that must come from configuration
    g_state.nPollInterval=g_state.pciConfig->lcci.dwMinPollInterval;
    g_state.nClockPrecision=(signed int)ceil(log(1e-7*g_state.pciConfig->lcci.dwLastClockRate)/(0.69314718)); // just do this once
    g_state.dwEventLogFlags=g_state.pciConfig->dwEventLogFlags;

    // receive time slip notifications
    hr=StartOrStopTimeSlipNotification(true);
    _JumpIfError(hr, error, "StartOrStopTimeSlipNotification");
    g_state.bTimeSlipNotificationStarted=true;

    // receive network topology change notifications
    hr=RequestNetTopoChangeNotification();
    _JumpIfError(hr, error, "RequestNetTopoChangeNotification");
    g_state.bNetTopoChangeNotificationStarted=true;

    // start the rpc server
    hr=W32TmStartRpcServer();
    _JumpIfError(hr, error, "W32TmStartRpcServer");

    // Register for policy change notification: 
    if (!RegisterGPNotification(g_state.hManagerGPUpdateEvent, TRUE /*machine*/)) { 
        _IgnoreLastError("RegisterGPNotification"); 
        // BUGBUG: log event indicating no policy updates are coming: 
    } else { 
        g_state.bGPNotificationStarted = true; 
    }

    // Initialize our domain role information
    HandleDomHierRoleChangeEvent(NULL /*ignored*/, FALSE /*ignored*/); 

    hr = LsaRegisterPolicyChangeNotification(PolicyNotifyServerRoleInformation, g_state.hDomHierRoleChangeEvent);
    if (ERROR_SUCCESS != hr) {
        hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(hr));
        _JumpError(hr, error, "LsaRegisterPolicyChangeNotification");
    }

    // tell netlogon whether it needs to announce that we are a time server 
    // (at this stage, we will not be announced as a time server)
    hr=UpdateNetlogonServiceBits(true);
    _JumpIfError(hr, error, "UpdateNetlogonServiceBits");

    // start the clock discipline thread
    hr=StartClockDiscipline();
    _JumpIfError(hr, error, "StartClockDiscipline");

    //  start the providers.  We can no longer jump to the "error" label, 
    //  as this does not shutdown the started providers.  
    StartAllProviders();

    // Set up polling information
    g_state.tpPollDelayRemaining        = ((unsigned __int64)(1 << g_state.nPollInterval))*10000000;
    g_state.tpIrregularDelayRemaining   = MINIMUMIRREGULARINTERVAL;  // HACK: make the first poll quick (2^5 seconds).  
    g_state.tpTimeSinceLastSyncAttempt  = MINIMUMIRREGULARINTERVAL;  // really, should be very large, but this is the only interesting value in use.
    g_state.tpTimeSinceLastGoodSync     = 0;
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // 
    // The service must be configured to handle the following events: 
    // 
    // Event                 Received from                Handled by             Description
    // 
    // shutdown              SCM                          SCM thread             SERVICE_CONTROL_SHUTDOWN received
    // clock displn thread   clock displn thread          Thread pool handler    Clock discipline thread has stopped
    // param change          SCM                          Thread pool handler    SERVICE_CONTROL_PARAMCHANGE received
    // time slip             RequestTimeSlipNotification  Thread pool handler    Time slip event has occured
    // samples available     NTP provider                 Thread pool handler    New samples are available from a provider
    // net topo change       NotifyAddr                   Thread pool handler    A change in the IP address table has occured
    // net topo RPC          W32TimeSync                  RPC thread             RPC Client requests time slip or net topo change
    // timeout               Timer Queue                  Thread pool handler    We've gone too long without new time samples
    // LSA role change       LSA                          Thread poll handler    Server role has changed -- need to update netlogon bits
    //
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    { 
        struct EventsToRegister { 
            DWORD                 dwFlags; 
            HANDLE                hObject; 
            HANDLE               *phNewWaitObject; 
            WAITORTIMERCALLBACK   Callback;
        }rgEventsToRegister[] =  { 
            { 
                WT_EXECUTEONLYONCE, 
                g_state.hManagerGPUpdateEvent, 
                &g_state.hRegisteredManagerGPUpdateEvent, 
                HandleManagerGPUpdate, 
            }, { 
                WT_EXECUTEDEFAULT, 
                g_state.hManagerParamChangeEvent, 
                &g_state.hRegisteredManagerParamChangeEvent,
                HandleManagerParamChange
            }, { 
                WT_EXECUTEDEFAULT, 
                g_state.hTimeSlipEvent,           
                &g_state.hRegisteredTimeSlipEvent, 
                HandleManagerTimeSlip
            }, { 
                WT_EXECUTEONLYONCE, 
                g_state.hNetTopoChangeEvent,      
                &g_state.hRegisteredNetTopoChangeEvent, 
                HandleManagerNetTopoChangeNoRPC
            }, { 
                WT_EXECUTEONLYONCE, 
                g_state.hClockDisplnThread, 
                &g_state.hRegisteredClockDisplnThread, 
                HandleClockDisplnThread
            }, { 
                WT_EXECUTEDEFAULT, 
                g_state.hDomHierRoleChangeEvent, 
                &g_state.hRegisteredDomHierRoleChangeEvent, 
                HandleDomHierRoleChangeEvent
            }, { 
		WT_EXECUTEONLYONCE, 
		g_state.hSamplesAvailEvent, 
		&g_state.hRegisteredSamplesAvailEvent,
		HandleSamplesAvail
	    }
        }; 

        for (int nIndex = 0; nIndex < ARRAYSIZE(rgEventsToRegister); nIndex++) { 
            if (!RegisterWaitForSingleObject
                (rgEventsToRegister[nIndex].phNewWaitObject,  // BUGBUG:  does this need to be freed?
                 rgEventsToRegister[nIndex].hObject, 
                 rgEventsToRegister[nIndex].Callback, 
                 NULL, 
                 INFINITE, 
                 rgEventsToRegister[nIndex].dwFlags)) {
                _JumpLastError(hr, error, "RegisterWaitForSingleObject"); 
            }
        }

        // Set up our timeout mechanism:
        hr = myStartTimerQueueTimer
            (g_state.hTimer, 
             NULL /*default queue*/, 
             HandleTimeout, 
             NULL, 
             0xFFFF /*dummy value*/,
             0xFFFF /*dummy value*/,
             0 /*default execution*/
             );
	_JumpIfError(hr, error, "myStartTimerQueueTimer"); 
    }

    hr = UpdateTimerQueue1(); 
    _JumpIfError(hr, error, "UpdateTimerQueue1"); 

    // We're fully initialized -- now we're ready to receive controls from the SCM.  
    hr=MySetServiceState(SERVICE_RUNNING);
    _JumpIfError(hr, error, "MySetServiceState");

    // The service is now completely up and running.
    hr = S_OK;
 error:
    if (FAILED(hr)) { // Didn't start the service successfully.  Shutdown:
	SendServiceShutdown(hr, FALSE /*don't restart*/, FALSE /*not async*/); 
    }
}
 




//--------------------------------------------------------------------
extern "C" void WINAPI SvchostEntry_W32Time(unsigned int nArgs, WCHAR ** rgwszArgs) {
    // this entry point is called by svchost.exe (base\screg\sc\svchost\svchost.c)
    // adjust our function pointers, then procede as normal.
    fnW32TmRegisterServiceCtrlHandlerEx=RegisterServiceCtrlHandlerExW;
    fnW32TmSetServiceStatus=SetServiceStatus;
    //g_pSvcsGlobalData=pGlobalData; // see SvchostPushServiceGlobals
    W32TmServiceMain(0, NULL);
}

//--------------------------------------------------------------------
extern "C" VOID SvchostPushServiceGlobals(PSVCHOST_GLOBAL_DATA pGlobalData) {
    // this entry point is called by svchost.exe
    g_pSvcsGlobalData=pGlobalData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32tm\othercmds.cpp ===
/--------------------------------------------------------------------
// OtherCmds-implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 2-17-00
//
// Other useful w32tm commands
//

#include "pch.h" // precompiled headers

//--------------------------------------------------------------------
//####################################################################
//##
//## Copied from c run time and modified to be 64bit capable
//##

#include <crt\limits.h>



/* flag values */
#define FL_UNSIGNED   1       /* wcstoul called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */


MODULEPRIVATE unsigned __int64 my_wcstoxl (const WCHAR * nptr, WCHAR ** endptr, int ibase, int flags) {
    const WCHAR *p;
    WCHAR c;
    unsigned __int64 number;
    unsigned __int64 digval;
    unsigned __int64 maxval;

    p=nptr;                       /* p is our scanning pointer */
    number=0;                     /* start with zero */

    c=*p++;                       /* read char */
    while (iswspace(c))
        c=*p++;               /* skip whitespace */

    if (c=='-') {
        flags|=FL_NEG;        /* remember minus sign */
        c=*p++;
    }
    else if (c=='+')
        c=*p++;               /* skip sign */

    if (ibase<0 || ibase==1 || ibase>36) {
        /* bad base! */
        if (endptr)
            /* store beginning of string in endptr */
            *endptr=(wchar_t *)nptr;
        return 0L;              /* return 0 */
    }
    else if (ibase==0) {
        /* determine base free-lance, based on first two chars of
           string */
        if (c != L'0')
            ibase=10;
        else if (*p==L'x' || *p==L'X')
            ibase=16;
        else
            ibase=8;
    }

    if (ibase==16) {
        /* we might have 0x in front of number; remove if there */
        if (c==L'0' && (*p==L'x' || *p==L'X')) {
            ++p;
            c=*p++;       /* advance past prefix */
        }
    }

    /* if our number exceeds this, we will overflow on multiply */
    maxval=_UI64_MAX / ibase;


    for (;;) {      /* exit in middle of loop */
        /* convert c to value */
        if (iswdigit(c))
            digval=c-L'0';
        else if (iswalpha(c))
            digval=(TCHAR)CharUpper((LPTSTR)c)-L'A'+10;
        else
            break;
        if (digval>=(unsigned)ibase)
            break;          /* exit loop if bad digit found */

        /* record the fact we have read one digit */
        flags|=FL_READDIGIT;

        /* we now need to compute number=number*base+digval,
           but we need to know if overflow occured.  This requires
           a tricky pre-check. */

        if (number<maxval || (number==maxval &&
        (unsigned __int64)digval<=_UI64_MAX%ibase)) {
            /* we won't overflow, go ahead and multiply */
            number=number*ibase+digval;
        }
        else {
            /* we would have overflowed -- set the overflow flag */
            flags|=FL_OVERFLOW;
        }

        c=*p++;               /* read next digit */
    }

    --p;                            /* point to place that stopped scan */

    if (!(flags&FL_READDIGIT)) {
        /* no number there; return 0 and point to beginning of
           string */
        if (endptr)
            /* store beginning of string in endptr later on */
            p=nptr;
        number=0L;            /* return 0 */
    }
    else if ((flags&FL_OVERFLOW) ||
              (!(flags&FL_UNSIGNED) &&
                (((flags&FL_NEG) && (number>-_I64_MIN)) ||
                  (!(flags&FL_NEG) && (number>_I64_MAX)))))
    {
        /* overflow or signed overflow occurred */
        //errno=ERANGE;
        if ( flags&FL_UNSIGNED )
            number=_UI64_MAX;
        else if ( flags&FL_NEG )
            number=(unsigned __int64)(-_I64_MIN);
        else
            number=_I64_MAX;
    }

    if (endptr != NULL)
        /* store pointer to char that stopped the scan */
        *endptr=(wchar_t *)p;

    if (flags&FL_NEG)
        /* negate result if there was a neg sign */
        number=(unsigned __int64)(-(__int64)number);

    return number;                  /* done. */
}
MODULEPRIVATE unsigned __int64 wcstouI64(const WCHAR *nptr, WCHAR ** endptr, int ibase) {
    return my_wcstoxl(nptr, endptr, ibase, FL_UNSIGNED);
}

//####################################################################

//--------------------------------------------------------------------
HRESULT myHExceptionCode(EXCEPTION_POINTERS * pep) {
    HRESULT hr=pep->ExceptionRecord->ExceptionCode;
    if (!FAILED(hr)) {
        hr=HRESULT_FROM_WIN32(hr);
    }
    return hr;
}


//--------------------------------------------------------------------
// NOTE:  this function is accessed through a hidden option, and does not need to be localized.
void PrintNtpPeerInfo(W32TIME_NTP_PEER_INFO *pnpInfo) { 
    LPWSTR pwszNULL = L"(null)"; 

    wprintf(L"PEER: %s\n",                      pnpInfo->wszUniqueName ? pnpInfo->wszUniqueName : pwszNULL); 
    wprintf(L"ulSize: %d\n",                    pnpInfo->ulSize); 
    wprintf(L"ulResolveAttempts: %d\n",         pnpInfo->ulResolveAttempts); 
    wprintf(L"u64TimeRemaining: %I64u\n",       pnpInfo->u64TimeRemaining); 
    wprintf(L"u64LastSuccessfulSync: %I64u\n",  pnpInfo->u64LastSuccessfulSync); 
    wprintf(L"ulLastSyncError: 0x%08X\n",       pnpInfo->ulLastSyncError); 
    wprintf(L"ulLastSyncErrorMsgId: 0x%08X\n",  pnpInfo->ulLastSyncErrorMsgId); 
    wprintf(L"ulValidDataCounter: %d\n",        pnpInfo->ulValidDataCounter); 
    wprintf(L"ulAuthTypeMsgId: 0x%08X\n",       pnpInfo->ulAuthTypeMsgId);     
    wprintf(L"ulMode: %d\n",                    pnpInfo->ulMode); 
    wprintf(L"ulStratum: %d\n",                 pnpInfo->ulStratum); 
    wprintf(L"ulReachability: %d\n",            pnpInfo->ulReachability); 
    wprintf(L"ulPeerPollInterval: %d\n",        pnpInfo->ulPeerPollInterval); 
    wprintf(L"ulHostPollInterval: %d\n",        pnpInfo->ulHostPollInterval); 
}


//--------------------------------------------------------------------
// NOTE:  this function is accessed through a hidden option, and does not need to be localized.
void PrintNtpProviderData(W32TIME_NTP_PROVIDER_DATA *pNtpProviderData) { 
    wprintf(L"ulSize: %d, ulError: 0x%08X, ulErrorMsgId: 0x%08X, cPeerInfo: %d\n", 
            pNtpProviderData->ulSize, 
            pNtpProviderData->ulError, 
            pNtpProviderData->ulErrorMsgId, 
            pNtpProviderData->cPeerInfo
            ); 

    for (DWORD dwIndex = 0; dwIndex < pNtpProviderData->cPeerInfo; dwIndex++) { 
        wprintf(L"\n"); 
        PrintNtpPeerInfo(&(pNtpProviderData->pPeerInfo[dwIndex]));
    }
}

//--------------------------------------------------------------------
HRESULT PrintStr(HANDLE hOut, WCHAR * wszBuf) 
{
    return MyWriteConsole(hOut, wszBuf, wcslen(wszBuf));
}

//--------------------------------------------------------------------
HRESULT Print(HANDLE hOut, WCHAR * wszFormat, ...) {
    WCHAR wszBuf[1024];
    int nWritten;
    va_list vlArgs;

    va_start(vlArgs, wszFormat);
    nWritten=_vsnwprintf(wszBuf, ARRAYSIZE(wszBuf)-1, wszFormat, vlArgs);
    va_end(vlArgs);
    wszBuf[ARRAYSIZE(wszBuf)-1]=L'\0';

    return PrintStr(hOut, wszBuf);
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT PrintNtTimeAsLocalTime(HANDLE hOut, unsigned __int64 qwTime) {
    HRESULT hr;
    FILETIME ftLocal;
    SYSTEMTIME stLocal;
    unsigned int nChars;

    // must be cleaned up
    WCHAR * wszDate=NULL;
    WCHAR * wszTime=NULL;

    if (!FileTimeToLocalFileTime((FILETIME *)(&qwTime), &ftLocal)) {
        _JumpLastError(hr, error, "FileTimeToLocalFileTime");
    }
    if (!FileTimeToSystemTime(&ftLocal, &stLocal)) {
        _JumpLastError(hr, error, "FileTimeToSystemTime");
    }

    nChars=GetDateFormat(NULL, 0, &stLocal, NULL, NULL, 0);
    if (0==nChars) {
        _JumpLastError(hr, error, "GetDateFormat");
    }
    wszDate=(WCHAR *)LocalAlloc(LPTR, nChars*sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, wszDate);
    nChars=GetDateFormat(NULL, 0, &stLocal, NULL, wszDate, nChars);
    if (0==nChars) {
        _JumpLastError(hr, error, "GetDateFormat");
    }

    nChars=GetTimeFormat(NULL, 0, &stLocal, NULL, NULL, 0);
    if (0==nChars) {
        _JumpLastError(hr, error, "GetTimeFormat");
    }
    wszTime=(WCHAR *)LocalAlloc(LPTR, nChars*sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, wszTime);
    nChars=GetTimeFormat(NULL, 0, &stLocal, NULL, wszTime, nChars);
    if (0==nChars) {
        _JumpLastError(hr, error, "GetTimeFormat");
    }

    Print(hOut, L"%s %s (local time)", wszDate, wszTime);

    hr=S_OK;
error:
    if (NULL!=wszDate) {
        LocalFree(wszDate);
    }
    if (NULL!=wszTime) {
        LocalFree(wszTime);
    }
    return hr;
}

//--------------------------------------------------------------------
void PrintNtTimePeriod(HANDLE hOut, NtTimePeriod tp) {
    Print(hOut, L"%02I64u.%07I64us", tp.qw/10000000,tp.qw%10000000);
}

//--------------------------------------------------------------------
void PrintNtTimeOffset(HANDLE hOut, NtTimeOffset to) {
    NtTimePeriod tp;
    if (to.qw<0) {
        PrintStr(hOut, L"-");
        tp.qw=(unsigned __int64)-to.qw;
    } else {
        PrintStr(hOut, L"+");
        tp.qw=(unsigned __int64)to.qw;
    }
    PrintNtTimePeriod(hOut, tp);
}

//####################################################################
//--------------------------------------------------------------------
void PrintHelpOtherCmds(void) {
    UINT idsText[] = { 
        IDS_W32TM_OTHERCMDHELP_LINE1,  IDS_W32TM_OTHERCMDHELP_LINE2,
        IDS_W32TM_OTHERCMDHELP_LINE3,  IDS_W32TM_OTHERCMDHELP_LINE4,
        IDS_W32TM_OTHERCMDHELP_LINE5,  IDS_W32TM_OTHERCMDHELP_LINE6,
        IDS_W32TM_OTHERCMDHELP_LINE7,  IDS_W32TM_OTHERCMDHELP_LINE8,
        IDS_W32TM_OTHERCMDHELP_LINE9,  IDS_W32TM_OTHERCMDHELP_LINE10,
        IDS_W32TM_OTHERCMDHELP_LINE11, IDS_W32TM_OTHERCMDHELP_LINE12,
        IDS_W32TM_OTHERCMDHELP_LINE13, IDS_W32TM_OTHERCMDHELP_LINE14,
        IDS_W32TM_OTHERCMDHELP_LINE15, IDS_W32TM_OTHERCMDHELP_LINE16,
        IDS_W32TM_OTHERCMDHELP_LINE17, IDS_W32TM_OTHERCMDHELP_LINE18,
        IDS_W32TM_OTHERCMDHELP_LINE19, IDS_W32TM_OTHERCMDHELP_LINE20,
        IDS_W32TM_OTHERCMDHELP_LINE21, IDS_W32TM_OTHERCMDHELP_LINE22,
        IDS_W32TM_OTHERCMDHELP_LINE23, IDS_W32TM_OTHERCMDHELP_LINE24,
        IDS_W32TM_OTHERCMDHELP_LINE25, IDS_W32TM_OTHERCMDHELP_LINE26,
        IDS_W32TM_OTHERCMDHELP_LINE27, IDS_W32TM_OTHERCMDHELP_LINE28,
        IDS_W32TM_OTHERCMDHELP_LINE29, IDS_W32TM_OTHERCMDHELP_LINE30,
        IDS_W32TM_OTHERCMDHELP_LINE31, IDS_W32TM_OTHERCMDHELP_LINE32,
        IDS_W32TM_OTHERCMDHELP_LINE33, IDS_W32TM_OTHERCMDHELP_LINE34,
        IDS_W32TM_OTHERCMDHELP_LINE35, IDS_W32TM_OTHERCMDHELP_LINE36,
        IDS_W32TM_OTHERCMDHELP_LINE37, IDS_W32TM_OTHERCMDHELP_LINE38,
        IDS_W32TM_OTHERCMDHELP_LINE39, IDS_W32TM_OTHERCMDHELP_LINE40,
        IDS_W32TM_OTHERCMDHELP_LINE41, IDS_W32TM_OTHERCMDHELP_LINE42,
        IDS_W32TM_OTHERCMDHELP_LINE43, IDS_W32TM_OTHERCMDHELP_LINE44,
        IDS_W32TM_OTHERCMDHELP_LINE45, IDS_W32TM_OTHERCMDHELP_LINE46,
        IDS_W32TM_OTHERCMDHELP_LINE47, IDS_W32TM_OTHERCMDHELP_LINE48,
        IDS_W32TM_OTHERCMDHELP_LINE49, IDS_W32TM_OTHERCMDHELP_LINE50,
        IDS_W32TM_OTHERCMDHELP_LINE51, IDS_W32TM_OTHERCMDHELP_LINE52,
        IDS_W32TM_OTHERCMDHELP_LINE53, IDS_W32TM_OTHERCMDHELP_LINE54,
        IDS_W32TM_OTHERCMDHELP_LINE55, IDS_W32TM_OTHERCMDHELP_LINE56,
        IDS_W32TM_OTHERCMDHELP_LINE57, IDS_W32TM_OTHERCMDHELP_LINE58, 
        IDS_W32TM_OTHERCMDHELP_LINE59, IDS_W32TM_OTHERCMDHELP_LINE60 
    };  

    for (int n=0; n<ARRAYSIZE(idsText); n++) {
	LocalizedWPrintf(idsText[n]); 
    }
}

//--------------------------------------------------------------------
HRESULT PrintNtte(CmdArgs * pca) {
    HRESULT hr;
    unsigned __int64 qwTime;
    HANDLE hOut;

    // must be cleaned up
    WCHAR * wszDate=NULL;
    WCHAR * wszTime=NULL;

    if (pca->nNextArg!=pca->nArgs-1) {
        if (pca->nNextArg==pca->nArgs) {
            LocalizedWPrintfCR(IDS_W32TM_ERRORGENERAL_MISSING_PARAM);
        } else {
            LocalizedWPrintfCR(IDS_W32TM_ERRORGENERAL_TOO_MANY_PARAMS);
        }
        hr=E_INVALIDARG;
        _JumpError(hr, error, "(command line parsing)");
    }

    qwTime=wcstouI64(pca->rgwszArgs[pca->nNextArg], NULL, 0);
    

    {
        unsigned __int64 qwTemp=qwTime;
        DWORD dwNanoSecs=(DWORD)(qwTemp%10000000);
        qwTemp/=10000000;
        DWORD dwSecs=(DWORD)(qwTemp%60);
        qwTemp/=60;
        DWORD dwMins=(DWORD)(qwTemp%60);
        qwTemp/=60;
        DWORD dwHours=(DWORD)(qwTemp%24);
        DWORD dwDays=(DWORD)(qwTemp/24);
        DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_W32TM_NTTE, dwDays, dwHours, dwMins, dwSecs, dwNanoSecs);
    }

    hOut=GetStdHandle(STD_OUTPUT_HANDLE);
    if (INVALID_HANDLE_VALUE==hOut) {
        _JumpLastError(hr, error, "GetStdHandle");
    }

    hr=PrintNtTimeAsLocalTime(hOut, qwTime);
    if (FAILED(hr)) {
        if (HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER)==hr) {
            LocalizedWPrintfCR(IDS_W32TM_ERRORGENERAL_INVALID_LOCALTIME);
        } else {
            _JumpError(hr, error, "PrintNtTimeAsLocalTime");
        }
    }
    wprintf(L"\n");

    hr=S_OK;
error:
    if (NULL!=wszDate) {
        LocalFree(wszDate);
    }
    if (NULL!=wszTime) {
        LocalFree(wszTime);
    }
    return hr;
}

//--------------------------------------------------------------------
HRESULT PrintNtpte(CmdArgs * pca) {
    HRESULT hr;
    unsigned __int64 qwTime;
    HANDLE hOut;

    // must be cleaned up
    WCHAR * wszDate=NULL;
    WCHAR * wszTime=NULL;

    if (pca->nNextArg!=pca->nArgs-1) {
        if (pca->nNextArg==pca->nArgs) {
            LocalizedWPrintfCR(IDS_W32TM_ERRORGENERAL_MISSING_PARAM);
        } else {
            LocalizedWPrintfCR(IDS_W32TM_ERRORGENERAL_TOO_MANY_PARAMS);
        }
        hr=E_INVALIDARG;
        _JumpError(hr, error, "(command line parsing)");
    }

    qwTime=wcstouI64(pca->rgwszArgs[pca->nNextArg], NULL, 0);
    
    {
        NtpTimeEpoch teNtp={qwTime};
        qwTime=NtTimeEpochFromNtpTimeEpoch(teNtp).qw;

        unsigned __int64 qwTemp=qwTime;
        DWORD dwNanoSecs=(DWORD)(qwTemp%10000000);
        qwTemp/=10000000;
        DWORD dwSecs=(DWORD)(qwTemp%60);
        qwTemp/=60;
        DWORD dwMins=(DWORD)(qwTemp%60);
        qwTemp/=60;
        DWORD dwHours=(DWORD)(qwTemp%24);
        DWORD dwDays=(DWORD)(qwTemp/24);
        DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_W32TM_NTPTE, qwTime, dwDays, dwHours, dwMins, dwSecs, dwNanoSecs);
    }

    hOut=GetStdHandle(STD_OUTPUT_HANDLE);
    if (INVALID_HANDLE_VALUE==hOut) {
        _JumpLastError(hr, error, "GetStdHandle")
    }

    hr=PrintNtTimeAsLocalTime(hOut, qwTime);
    if (FAILED(hr)) {
        if (HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER)==hr) {
            LocalizedWPrintf(IDS_W32TM_ERRORGENERAL_INVALID_LOCALTIME);
        } else {
            _JumpError(hr, error, "PrintNtTimeAsLocalTime");
        }
    }
    wprintf(L"\n");

    hr=S_OK;
error:
    if (NULL!=wszDate) {
        LocalFree(wszDate);
    }
    if (NULL!=wszTime) {
        LocalFree(wszTime);
    }
    return hr;
}

//--------------------------------------------------------------------
// NOTE:  this function is accessed through a hidden option, and does not need to be localized.
HRESULT SysExpr(CmdArgs * pca) {
    HRESULT hr;
    unsigned __int64 qwExprDate;
    HANDLE hOut;

    hr=VerifyAllArgsUsed(pca);
    _JumpIfError(hr, error, "VerifyAllArgsUsed");

    hOut=GetStdHandle(STD_OUTPUT_HANDLE);
    if (INVALID_HANDLE_VALUE==hOut) {
        _JumpLastError(hr, error, "GetStdHandle")
    }

    GetSysExpirationDate(&qwExprDate);

    wprintf(L"0x%016I64X - ", qwExprDate);
    if (0==qwExprDate) {
        wprintf(L"no expiration date\n");
    } else {
        hr=PrintNtTimeAsLocalTime(hOut, qwExprDate);
        _JumpIfError(hr, error, "PrintNtTimeAsLocalTime")
        wprintf(L"\n");
    }

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT ResyncCommand(CmdArgs * pca) {
    HANDLE hTimeSlipEvent  = NULL; 
    HRESULT hr;
    WCHAR * wszComputer=NULL;
    WCHAR * wszComputerDisplay;
    bool bUseDefaultErrorPrinting = false; 
    bool bHard=true;
    bool bNoWait=false;
    bool bRediscover=false;
    unsigned int nArgID;
    DWORD dwResult;
    DWORD dwSyncFlags=0; 

    // must be cleaned up
    WCHAR * wszError=NULL;

    // find out what computer to resync
    if (FindArg(pca, L"computer", &wszComputer, &nArgID)) {
        MarkArgUsed(pca, nArgID);
    }
    wszComputerDisplay=wszComputer;
    if (NULL==wszComputerDisplay) {
        wszComputerDisplay=L"local computer";
    }

    // find out if we need to use the w32tm named timeslip event to resync
    if (FindArg(pca, L"event", NULL, &nArgID)) { 
        MarkArgUsed(pca, nArgID); 

        hr=VerifyAllArgsUsed(pca);
        _JumpIfError(hr, error, "VerifyAllArgsUsed");
        
        hTimeSlipEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, W32TIME_NAMED_EVENT_SYSTIME_NOT_CORRECT); 
        if (NULL == hTimeSlipEvent) { 
	    bUseDefaultErrorPrinting = true; 
            _JumpLastError(hr, error, "OpenEvent"); 
        }

        if (!SetEvent(hTimeSlipEvent)) { 
	    bUseDefaultErrorPrinting = true; 
            _JumpLastError(hr, error, "SetEvent"); 
        }

    } else { 
        // find out if we need to do a soft resync
        if (FindArg(pca, L"soft", NULL, &nArgID)) {
            MarkArgUsed(pca, nArgID);
            dwSyncFlags = TimeSyncFlag_SoftResync;
        } else if (FindArg(pca, L"update", NULL, &nArgID)) { 
	    MarkArgUsed(pca, nArgID); 
            dwSyncFlags = TimeSyncFlag_UpdateAndResync;	    
	} else if (FindArg(pca, L"rediscover", NULL, &nArgID)) {  
	    // find out if we need to do a rediscover
	    MarkArgUsed(pca, nArgID);
            dwSyncFlags = TimeSyncFlag_Rediscover; 
        } else { 
	    dwSyncFlags = TimeSyncFlag_HardResync; 
	}

        // find out if we don't want to wait
        if (FindArg(pca, L"nowait", NULL, &nArgID)) {
            MarkArgUsed(pca, nArgID);
            bNoWait=true;
        }

        hr=VerifyAllArgsUsed(pca);
        _JumpIfError(hr, error, "VerifyAllArgsUsed");

        if (bRediscover && !bHard) {
            LocalizedWPrintfCR(IDS_W32TM_WARN_IGNORE_SOFT); 
        }

        LocalizedWPrintf2(IDS_W32TM_STATUS_SENDING_RESYNC_TO, L" %s...\n", wszComputerDisplay);
        dwResult=W32TimeSyncNow(wszComputer, !bNoWait, TimeSyncFlag_ReturnResult | dwSyncFlags); 
        if (ResyncResult_Success==dwResult) {
            LocalizedWPrintfCR(IDS_W32TM_ERRORGENERAL_COMMAND_SUCCESSFUL); 
        } else if (ResyncResult_NoData==dwResult) {
            LocalizedWPrintfCR(IDS_W32TM_ERRORRESYNC_NO_TIME_DATA); 
        } else if (ResyncResult_StaleData==dwResult) {
            LocalizedWPrintfCR(IDS_W32TM_ERRORRESYNC_STALE_DATA);
        } else if (ResyncResult_Shutdown==dwResult) {
            LocalizedWPrintfCR(IDS_W32TM_ERRORRESYNC_SHUTTING_DOWN);
        } else if (ResyncResult_ChangeTooBig==dwResult) {
            LocalizedWPrintfCR(IDS_W32TM_ERRORRESYNC_CHANGE_TOO_BIG); 
        } else {
	    bUseDefaultErrorPrinting = true; 
	    hr = HRESULT_FROM_WIN32(dwResult); 
	    _JumpError(hr, error, "W32TimeSyncNow"); 
        }
    }

    
    hr=S_OK;
error:
    if (FAILED(hr)) { 
	HRESULT hr2 = GetSystemErrorString(hr, &wszError);
	_IgnoreIfError(hr2, "GetSystemErrorString");
	
	if (SUCCEEDED(hr2)) { 
	    LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
	}
    }

    if (NULL!=hTimeSlipEvent) { 
        CloseHandle(hTimeSlipEvent);
    }
    if (NULL!=wszError) {
        LocalFree(wszError);
    }
    return hr;
}

//--------------------------------------------------------------------
HRESULT Stripchart(CmdArgs * pca) {
    HRESULT hr;
    WCHAR * wszParam;
    WCHAR * wszComputer;
    bool bDataOnly=false;
    unsigned int nArgID;
    unsigned int nIpAddrs;
    TIME_ZONE_INFORMATION timezoneinfo;
    signed __int64 nFullTzBias;
    DWORD dwTimeZoneMode;
    DWORD dwSleepSeconds;
    HANDLE hOut;
    bool bDontRunForever=false;
    unsigned int nSamples;
    NtTimeEpoch teNow;

    // must be cleaned up
    WCHAR * wszError=NULL;
    bool bSocketLayerOpened=false;
    in_addr * rgiaLocalIpAddrs=NULL;
    in_addr * rgiaRemoteIpAddrs=NULL;

    // find out what computer to watch
    if (FindArg(pca, L"computer", &wszComputer, &nArgID)) {
        MarkArgUsed(pca, nArgID);
    } else {
        LocalizedWPrintfCR(IDS_W32TM_ERRORPARAMETER_COMPUTER_MISSING); 
        hr=E_INVALIDARG;
        _JumpError(hr, error, "command line parsing");
    }

    // find out how often to watch
    if (FindArg(pca, L"period", &wszParam, &nArgID)) {
        MarkArgUsed(pca, nArgID);
        dwSleepSeconds=wcstoul(wszParam, NULL, 0);
        if (dwSleepSeconds<1) {
            dwSleepSeconds=1;
        }
    } else {
        dwSleepSeconds=2;
    }

    // find out if we want a limited number of samples
    if (FindArg(pca, L"samples", &wszParam, &nArgID)) {
        MarkArgUsed(pca, nArgID);
        bDontRunForever=true;
        nSamples=wcstoul(wszParam, NULL, 0);
    }

    // find out if we only want to dump data
    if (FindArg(pca, L"dataonly", NULL, &nArgID)) {
        MarkArgUsed(pca, nArgID);
        bDataOnly=true;
    }

    // redirect to file handled via stdout
        hOut=GetStdHandle(STD_OUTPUT_HANDLE);
        if (INVALID_HANDLE_VALUE==hOut) {
            _JumpLastError(hr, error, "GetStdHandle")
        }

    hr=VerifyAllArgsUsed(pca);
    _JumpIfError(hr, error, "VerifyAllArgsUsed");

    dwTimeZoneMode=GetTimeZoneInformation(&timezoneinfo);
    if (TIME_ZONE_ID_INVALID==dwTimeZoneMode) {
        _JumpLastError(hr, error, "GetTimeZoneInformation");
    } else if (TIME_ZONE_ID_DAYLIGHT==dwTimeZoneMode) {
        nFullTzBias=(signed __int64)(timezoneinfo.Bias+timezoneinfo.DaylightBias);
    } else {
        nFullTzBias=(signed __int64)(timezoneinfo.Bias+timezoneinfo.StandardBias);
    }
    nFullTzBias*=600000000; // convert to from minutes to 10^-7s

    hr=OpenSocketLayer();
    _JumpIfError(hr, error, "OpenSocketLayer");
    bSocketLayerOpened=true;

    hr=MyGetIpAddrs(wszComputer, &rgiaLocalIpAddrs, &rgiaRemoteIpAddrs, &nIpAddrs, NULL);
    _JumpIfError(hr, error, "MyGetIpAddrs");

    // write out who we are tracking
    Print(hOut, L"Tracking %s [%u.%u.%u.%u].\n",
        wszComputer,
        rgiaRemoteIpAddrs[0].S_un.S_un_b.s_b1, rgiaRemoteIpAddrs[0].S_un.S_un_b.s_b2,
        rgiaRemoteIpAddrs[0].S_un.S_un_b.s_b3, rgiaRemoteIpAddrs[0].S_un.S_un_b.s_b4);
    if (bDontRunForever) {
        Print(hOut, L"Collecting %u samples.\n", nSamples);
    }

    // Write out the current time in full, since we will be using abbreviations later.
    PrintStr(hOut, L"The current time is ");
    AccurateGetSystemTime(&teNow.qw);
    PrintNtTimeAsLocalTime(hOut, teNow.qw);
    PrintStr(hOut, L".\n");

    while (false==bDontRunForever || nSamples>0) {

        const DWORD c_dwTimeout=1000;
        NtpPacket npPacket;
        NtTimeEpoch teDestinationTimestamp;

        DWORD dwSecs;
        DWORD dwMins;
        DWORD dwHours;
        signed int nMsMin=-10000;
        signed int nMsMax=10000;
        unsigned int nGraphWidth=55;
        AccurateGetSystemTime(&teNow.qw);
        teNow.qw-=nFullTzBias;
        teNow.qw/=10000000;
        dwSecs=(DWORD)(teNow.qw%60);
        teNow.qw/=60;
        dwMins=(DWORD)(teNow.qw%60);
        teNow.qw/=60;
        dwHours=(DWORD)(teNow.qw%24);
        if (!bDataOnly) {
            Print(hOut, L"%02u:%02u:%02u ", dwHours, dwMins, dwSecs);
        } else {
            Print(hOut, L"%02u:%02u:%02u, ", dwHours, dwMins, dwSecs);
        }

        hr=MyNtpPing(&(rgiaRemoteIpAddrs[0]), c_dwTimeout, &npPacket, &teDestinationTimestamp);
        if (FAILED(hr)) {
            Print(hOut, L"error: 0x%08X", hr);
        } else {
            // calculate the offset
            NtTimeEpoch teOriginateTimestamp=NtTimeEpochFromNtpTimeEpoch(npPacket.teOriginateTimestamp);
            NtTimeEpoch teReceiveTimestamp=NtTimeEpochFromNtpTimeEpoch(npPacket.teReceiveTimestamp);
            NtTimeEpoch teTransmitTimestamp=NtTimeEpochFromNtpTimeEpoch(npPacket.teTransmitTimestamp);
            NtTimeOffset toLocalClockOffset=
                (teReceiveTimestamp-teOriginateTimestamp)
                + (teTransmitTimestamp-teDestinationTimestamp);
            toLocalClockOffset/=2;

            // calculate the delay
            NtTimeOffset toRoundtripDelay=
                (teDestinationTimestamp-teOriginateTimestamp)
                - (teTransmitTimestamp-teReceiveTimestamp);

            if (!bDataOnly) {
                PrintStr(hOut, L"d:");
                PrintNtTimeOffset(hOut, toRoundtripDelay);
                PrintStr(hOut, L" o:");
                PrintNtTimeOffset(hOut, toLocalClockOffset);
            } else {
                PrintNtTimeOffset(hOut, toLocalClockOffset);
            }

            // draw graph
            if (!bDataOnly) {
                unsigned int nSize=nMsMax-nMsMin+1;
                double dRatio=((double)nGraphWidth)/nSize;
                signed int nPoint=(signed int)(toLocalClockOffset.qw/10000);
                bool bOutOfRange=false;
                if (nPoint>nMsMax) {
                    nPoint=nMsMax;
                    bOutOfRange=true;
                } else if (nPoint<nMsMin) {
                    nPoint=nMsMin;
                    bOutOfRange=true;
                }
                unsigned int nLeftOffset=(unsigned int)((nPoint-nMsMin)*dRatio);
                unsigned int nZeroOffset=(unsigned int)((0-nMsMin)*dRatio);
                PrintStr(hOut, L"  [");
                unsigned int nIndex;
                for (nIndex=0; nIndex<nGraphWidth; nIndex++) {
                    if (nIndex==nLeftOffset) {
                        if (bOutOfRange) {
                            PrintStr(hOut, L"@");
                        } else {
                            PrintStr(hOut, L"*");
                        }
                    } else if (nIndex==nZeroOffset) {
                        PrintStr(hOut, L"|");
                    } else {
                        PrintStr(hOut, L" ");
                    }
                }
                PrintStr(hOut, L"]");
            } // <- end drawing graph

        } // <- end if sample received

        PrintStr(hOut, L"\n");
        nSamples--;
        if (0!=nSamples) {
            Sleep(dwSleepSeconds*1000);
        }

    } // <- end sample collection loop

    hr=S_OK;
error:
    if (NULL!=rgiaLocalIpAddrs) {
        LocalFree(rgiaLocalIpAddrs);
    }
    if (NULL!=rgiaRemoteIpAddrs) {
        LocalFree(rgiaRemoteIpAddrs);
    }
    if (bSocketLayerOpened) {
        HRESULT hr2=CloseSocketLayer();
        _TeardownError(hr, hr2, "CloseSocketLayer");
    }
    if (FAILED(hr)) {
        WCHAR * wszError;
        HRESULT hr2=GetSystemErrorString(hr, &wszError);
        if (FAILED(hr2)) {
            _IgnoreError(hr2, "GetSystemErrorString");
        } else {
            LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError); 
            LocalFree(wszError);
        }
    }
    return hr;
}

//--------------------------------------------------------------------
HRESULT Config(CmdArgs * pca) {
    HRESULT hr;
    DWORD dwRetval;
    WCHAR * wszParam;
    WCHAR * wszComputer;
    unsigned int nArgID;

    bool bManualPeerList=false;
    bool bUpdate=false;
    bool bSyncFromFlags=false;
    bool bLocalClockDispersion=false;

    unsigned int nManualPeerListLenBytes;
    DWORD dwSyncFromFlags;
    DWORD dwLocalClockDispersion;

    // must be cleaned up
    WCHAR * mwszManualPeerList=NULL;
    HKEY hkLMRemote=NULL;
    HKEY hkW32TimeConfig=NULL;
    HKEY hkW32TimeParameters=NULL;
    SC_HANDLE hSCM=NULL;
    SC_HANDLE hTimeService=NULL;

    // find out what computer to talk to
    if (FindArg(pca, L"computer", &wszComputer, &nArgID)) {
        MarkArgUsed(pca, nArgID);
    } else {
        // modifying local computer
        wszComputer=NULL;
    }

    // find out if we want to notify the service
    if (FindArg(pca, L"update", NULL, &nArgID)) {
        MarkArgUsed(pca, nArgID);
        bUpdate=true;
    }

    // see if they want to change the manual peer list
    if (FindArg(pca, L"manualpeerlist", &wszParam, &nArgID)) {
        MarkArgUsed(pca, nArgID);

        nManualPeerListLenBytes=(wcslen(wszParam)+1)*sizeof(WCHAR);
        mwszManualPeerList=(WCHAR *)LocalAlloc(LPTR, nManualPeerListLenBytes);
        _JumpIfOutOfMemory(hr, error, mwszManualPeerList);
        wcscpy(mwszManualPeerList, wszParam);

        bManualPeerList=true;
    }

    // see if they want to change the syncfromflags
    if (FindArg(pca, L"syncfromflags", &wszParam, &nArgID)) {
        MarkArgUsed(pca, nArgID);

        // find keywords in the string
        dwSyncFromFlags=0;
        WCHAR * wszKeyword=wszParam;
        bool bLastKeyword=false;
        while (false==bLastKeyword) {
            WCHAR * wszNext=wcschr(wszKeyword, L',');
            if (NULL==wszNext) {
                bLastKeyword=true;
            } else {
                wszNext[0]=L'\0';
                wszNext++;
            }
            if (L'\0'==wszKeyword[0]) {
                // 'empty' keyword - no changes, but can be used to sync from nowhere.
            } else if (0==_wcsicmp(L"manual", wszKeyword)) {
                dwSyncFromFlags|=NCSF_ManualPeerList;
            } else if (0==_wcsicmp(L"domhier", wszKeyword)) {
                dwSyncFromFlags|=NCSF_DomainHierarchy;
            } else {
                LocalizedWPrintf2(IDS_W32TM_ERRORPARAMETER_UNKNOWN_PARAMETER_SYNCFROMFLAGS, L" '%s'.\n", wszKeyword);
                hr=E_INVALIDARG;
                _JumpError(hr, error, "command line parsing");
            }
            wszKeyword=wszNext;
        }

        bSyncFromFlags=true;
    }

    // see if they want to change the local clock dispersion
    if (FindArg(pca, L"localclockdispersion", &wszParam, &nArgID)) {
        MarkArgUsed(pca, nArgID);

        dwLocalClockDispersion=wcstoul(wszParam, NULL, 0);
        bLocalClockDispersion=true;
    }

    hr=VerifyAllArgsUsed(pca);
    _JumpIfError(hr, error, "VerifyAllArgsUsed");

    if (!bManualPeerList && !bSyncFromFlags && !bUpdate && !bLocalClockDispersion) {
        LocalizedWPrintfCR(IDS_W32TM_ERRORCONFIG_NO_CHANGE_SPECIFIED);
        hr=E_INVALIDARG;
        _JumpError(hr, error, "command line parsing");
    }

    // make registry changes
    if (bManualPeerList || bSyncFromFlags || bLocalClockDispersion) {
        // open the key
        dwRetval=RegConnectRegistry(wszComputer, HKEY_LOCAL_MACHINE, &hkLMRemote);
        if (ERROR_SUCCESS!=dwRetval) {
            hr=HRESULT_FROM_WIN32(dwRetval);
            _JumpError(hr, error, "RegConnectRegistry");
        }

        // set "w32time\parameters" reg values
        if (bManualPeerList || bSyncFromFlags) { 
            dwRetval=RegOpenKey(hkLMRemote, wszW32TimeRegKeyParameters, &hkW32TimeParameters);
            if (ERROR_SUCCESS!=dwRetval) {
                hr=HRESULT_FROM_WIN32(dwRetval);
                _JumpError(hr, error, "RegOpenKey");
            }

            if (bManualPeerList) {
                dwRetval=RegSetValueEx(hkW32TimeParameters, wszW32TimeRegValueNtpServer, 0, REG_SZ, (BYTE *)mwszManualPeerList, nManualPeerListLenBytes);
                if (ERROR_SUCCESS!=dwRetval) {
                    hr=HRESULT_FROM_WIN32(dwRetval);
                    _JumpError(hr, error, "RegSetValueEx");
                }
            }

            if (bSyncFromFlags) {
                LPWSTR pwszType; 
                switch (dwSyncFromFlags) { 
                case NCSF_NoSync:             pwszType = W32TM_Type_NoSync;  break;
                case NCSF_ManualPeerList:     pwszType = W32TM_Type_NTP;     break;
                case NCSF_DomainHierarchy:    pwszType = W32TM_Type_NT5DS;   break;
                case NCSF_ManualAndDomhier:   pwszType = W32TM_Type_AllSync; break;
                default:
                    hr = E_NOTIMPL; 
                    _JumpError(hr, error, "SyncFromFlags not supported."); 
                }
                
                dwRetval=RegSetValueEx(hkW32TimeParameters, wszW32TimeRegValueType, 0, REG_SZ, (BYTE *)pwszType, (wcslen(pwszType)+1) * sizeof(WCHAR));
                if (ERROR_SUCCESS!=dwRetval) {
                    hr=HRESULT_FROM_WIN32(dwRetval);
                    _JumpError(hr, error, "RegSetValueEx");
                }
            }
        }

        if (bLocalClockDispersion) { 
            dwRetval=RegOpenKey(hkLMRemote, wszW32TimeRegKeyConfig, &hkW32TimeConfig);
            if (ERROR_SUCCESS!=dwRetval) {
                hr=HRESULT_FROM_WIN32(dwRetval);
                _JumpError(hr, error, "RegOpenKey");
            }
            
            dwRetval=RegSetValueEx(hkW32TimeConfig, wszW32TimeRegValueLocalClockDispersion, 0, REG_DWORD, (BYTE *)&dwLocalClockDispersion, sizeof(dwLocalClockDispersion));
            if (ERROR_SUCCESS!=dwRetval) {
                hr=HRESULT_FROM_WIN32(dwRetval);
                _JumpError(hr, error, "RegSetValueEx");
            }
        }
    }

    // send service message
    if (bUpdate) {
        SERVICE_STATUS servicestatus;

        hSCM=OpenSCManager(wszComputer, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT);
        if (NULL==hSCM) {
            _JumpLastError(hr, error, "OpenSCManager");
        }

        hTimeService=OpenService(hSCM, L"w32time", SERVICE_PAUSE_CONTINUE);
        if (NULL==hTimeService) {
            _JumpLastError(hr, error, "OpenService");
        }

        if (!ControlService(hTimeService, SERVICE_CONTROL_PARAMCHANGE, &servicestatus)) {
            _JumpLastError(hr, error, "ControlService");
        }
    }


    hr=S_OK;
error:
    if (NULL!=mwszManualPeerList) {
        LocalFree(mwszManualPeerList);
    }
    if (NULL!=hkW32TimeConfig) {
        RegCloseKey(hkW32TimeConfig);
    }
    if (NULL!=hkW32TimeParameters) {
        RegCloseKey(hkW32TimeParameters);
    }
    if (NULL!=hkLMRemote) {
        RegCloseKey(hkLMRemote);
    }
    if (NULL!=hTimeService) {
        CloseServiceHandle(hTimeService);
    }
    if (NULL!=hSCM) {
        CloseServiceHandle(hSCM);
    }
    if (FAILED(hr) && E_INVALIDARG!=hr) {
        WCHAR * wszError;
        HRESULT hr2=GetSystemErrorString(hr, &wszError);
        if (FAILED(hr2)) {
            _IgnoreError(hr2, "GetSystemErrorString");
        } else {
            LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
            LocalFree(wszError);
        }
    } else if (S_OK==hr) {
        LocalizedWPrintfCR(IDS_W32TM_ERRORGENERAL_COMMAND_SUCCESSFUL);
    }
    return hr;
}

//--------------------------------------------------------------------
// NOTE:  this function is accessed through a hidden option, and does not need to be localized.
HRESULT TestInterface(CmdArgs * pca) {
    HRESULT hr;
    WCHAR * wszComputer=NULL;
    WCHAR * wszComputerDisplay;
    unsigned int nArgID;
    DWORD dwResult;
    unsigned long ulBits;
    void (* pfnW32TimeVerifyJoinConfig)(void);
    void (* pfnW32TimeVerifyUnjoinConfig)(void);


    // must be cleaned up
    WCHAR * wszError=NULL;
    HMODULE hmW32Time=NULL;

    // check for gnsb (get netlogon service bits)
    if (true==CheckNextArg(pca, L"gnsb", NULL)) {

        // find out what computer to resync
        if (FindArg(pca, L"computer", &wszComputer, &nArgID)) {
            MarkArgUsed(pca, nArgID);
        }
        wszComputerDisplay=wszComputer;
        if (NULL==wszComputerDisplay) {
            wszComputerDisplay=L"local computer";
        }

        hr=VerifyAllArgsUsed(pca);
        _JumpIfError(hr, error, "VerifyAllArgsUsed");

        LocalizedWPrintf2(IDS_W32TM_STATUS_CALLING_GETNETLOGONBITS_ON, L" %s.\n", wszComputerDisplay);
        dwResult=W32TimeGetNetlogonServiceBits(wszComputer, &ulBits);
        if (S_OK==dwResult) {
            wprintf(L"Bits: 0x%08X\n", ulBits);
        } else {
            hr=GetSystemErrorString(HRESULT_FROM_WIN32(dwResult), &wszError);
            _JumpIfError(hr, error, "GetSystemErrorString");

	    LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
        }

    // check for vjc (verify join config)
    } else if (true==CheckNextArg(pca, L"vjc", NULL)) {

        hr=VerifyAllArgsUsed(pca);
        _JumpIfError(hr, error, "VerifyAllArgsUsed");

        LocalizedWPrintfCR(IDS_W32TM_STATUS_CALLING_JOINCONFIG);

        hmW32Time=LoadLibrary(wszDLLNAME);
        if (NULL==hmW32Time) {
            _JumpLastError(hr, vjcerror, "LoadLibrary");
        }

        pfnW32TimeVerifyJoinConfig=(void (*)(void))GetProcAddress(hmW32Time, "W32TimeVerifyJoinConfig");
        if (NULL==pfnW32TimeVerifyJoinConfig) {
            _JumpLastErrorStr(hr, vjcerror, "GetProcAddress", L"W32TimeVerifyJoinConfig");
        }

        _BeginTryWith(hr) {
            pfnW32TimeVerifyJoinConfig();
        } _TrapException(hr);
        _JumpIfError(hr, vjcerror, "pfnW32TimeVerifyJoinConfig");

        hr=S_OK;
    vjcerror:
        if (FAILED(hr)) {
            HRESULT hr2=GetSystemErrorString(hr, &wszError);
            if (FAILED(hr2)) {
                _IgnoreError(hr2, "GetSystemErrorString");
            } else {
                LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
            }
            goto error;
        }

    // check for vuc (verify unjoin config)
    } else if (true==CheckNextArg(pca, L"vuc", NULL)) {

        hr=VerifyAllArgsUsed(pca);
        _JumpIfError(hr, error, "VerifyAllArgsUsed");

        LocalizedWPrintfCR(IDS_W32TM_STATUS_CALLING_UNJOINCONFIG);

        hmW32Time=LoadLibrary(wszDLLNAME);
        if (NULL==hmW32Time) {
            _JumpLastError(hr, vucerror, "LoadLibrary");
        }

        pfnW32TimeVerifyUnjoinConfig=(void (*)(void))GetProcAddress(hmW32Time, "W32TimeVerifyUnjoinConfig");
        if (NULL==pfnW32TimeVerifyUnjoinConfig) {
            _JumpLastErrorStr(hr, vucerror, "GetProcAddress", L"W32TimeVerifyJoinConfig");
        }

        _BeginTryWith(hr) {
            pfnW32TimeVerifyUnjoinConfig();
        } _TrapException(hr);
        _JumpIfError(hr, vucerror, "pfnW32TimeVerifyUnjoinConfig");

        hr=S_OK;
    vucerror:
        if (FAILED(hr)) {
            HRESULT hr2=GetSystemErrorString(hr, &wszError);
            if (FAILED(hr2)) {
                _IgnoreError(hr2, "GetSystemErrorString");
            } else {
                LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
            }
            goto error;
        }

    // error out appropriately
    } else if (true==CheckNextArg(pca, L"qps", NULL)) {
        // find out what computer to resync
        if (FindArg(pca, L"computer", &wszComputer, &nArgID)) {
            MarkArgUsed(pca, nArgID);
        }
        wszComputerDisplay=wszComputer;
        if (NULL==wszComputerDisplay) {
            wszComputerDisplay=L"local computer";
        }

        hr=VerifyAllArgsUsed(pca);
        _JumpIfError(hr, error, "VerifyAllArgsUsed");

        //LocalizedWPrintf2(IDS_W32TM_STATUS_CALLING_GETNETLOGONBITS_ON, L" %s.\n", wszComputerDisplay);
        { 
            W32TIME_NTP_PROVIDER_DATA *ProviderInfo = NULL; 
            
            dwResult=W32TimeQueryNTPProviderStatus(wszComputer, 0, L"NtpClient", &ProviderInfo);
            if (S_OK==dwResult) {
                PrintNtpProviderData(ProviderInfo); 
            } else {
                hr=GetSystemErrorString(HRESULT_FROM_WIN32(dwResult), &wszError);
                _JumpIfError(hr, error, "GetSystemErrorString");
                 
                LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
            }
        }

    } else {
        hr=VerifyAllArgsUsed(pca);
        _JumpIfError(hr, error, "VerifyAllArgsUsed");

        LocalizedWPrintf(IDS_W32TM_ERRORGENERAL_NOINTERFACE);
        hr=E_INVALIDARG;
        _JumpError(hr, error, "command line parsing");
    }
    

    hr=S_OK;
error:
    if (NULL!=hmW32Time) {
        FreeLibrary(hmW32Time);
    }
    if (NULL!=wszError) {
        LocalFree(wszError);
    }
    return hr;
}

//--------------------------------------------------------------------
HRESULT ShowTimeZone(CmdArgs * pca) {
    DWORD                  dwTimeZoneID;
    HRESULT                hr;
    LPWSTR                 pwsz_IDS_W32TM_SIMPLESTRING_UNSPECIFIED   = NULL; 
    LPWSTR                 pwsz_IDS_W32TM_TIMEZONE_CURRENT_TIMEZONE  = NULL; 
    LPWSTR                 pwsz_IDS_W32TM_TIMEZONE_DAYLIGHT          = NULL; 
    LPWSTR                 pwsz_IDS_W32TM_TIMEZONE_STANDARD          = NULL; 
    LPWSTR                 pwsz_IDS_W32TM_TIMEZONE_UNKNOWN           = NULL; 
    LPWSTR                 wszDaylightDate                           = NULL;
    LPWSTR                 wszStandardDate                           = NULL;
    LPWSTR                 wszTimeZoneId                             = NULL; 
    TIME_ZONE_INFORMATION  tzi;
    unsigned int           nChars; 

    // Load the strings we'll need
    struct LocalizedStrings { 
        UINT     id; 
        LPWSTR  *ppwsz; 
    } rgStrings[] = { 
        { IDS_W32TM_SIMPLESTRING_UNSPECIFIED,   &pwsz_IDS_W32TM_SIMPLESTRING_UNSPECIFIED }, 
        { IDS_W32TM_TIMEZONE_CURRENT_TIMEZONE,  &pwsz_IDS_W32TM_TIMEZONE_CURRENT_TIMEZONE }, 
        { IDS_W32TM_TIMEZONE_DAYLIGHT,          &pwsz_IDS_W32TM_TIMEZONE_DAYLIGHT },
        { IDS_W32TM_TIMEZONE_STANDARD,          &pwsz_IDS_W32TM_TIMEZONE_STANDARD }, 
        { IDS_W32TM_TIMEZONE_UNKNOWN,           &pwsz_IDS_W32TM_TIMEZONE_UNKNOWN }
    }; 
       
    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgStrings); dwIndex++) { 
        if (!WriteMsg(FORMAT_MESSAGE_FROM_HMODULE, rgStrings[dwIndex].id, rgStrings[dwIndex].ppwsz)) {
            hr = HRESULT_FROM_WIN32(GetLastError()); 
            _JumpError(hr, error, "WriteMsg"); 
        }
    }
    
    hr=VerifyAllArgsUsed(pca);
    _JumpIfError(hr, error, "VerifyAllArgsUsed");

    dwTimeZoneID=GetTimeZoneInformation(&tzi);
    switch (dwTimeZoneID)
    {
    case TIME_ZONE_ID_DAYLIGHT: wszTimeZoneId = pwsz_IDS_W32TM_TIMEZONE_DAYLIGHT;  break; 
    case TIME_ZONE_ID_STANDARD: wszTimeZoneId = pwsz_IDS_W32TM_TIMEZONE_STANDARD; break; 
    case TIME_ZONE_ID_UNKNOWN:  wszTimeZoneId = pwsz_IDS_W32TM_TIMEZONE_UNKNOWN; break; 
    default: 
        hr = HRESULT_FROM_WIN32(GetLastError());
        LocalizedWPrintfCR(IDS_W32TM_ERRORTIMEZONE_INVALID);
        _JumpError(hr, error, "GetTimeZoneInformation")
    }

    // Construct a string representing the "StandardDate" field of the TimeZoneInformation: 
    if (0==tzi.StandardDate.wMonth) {
        wszStandardDate = pwsz_IDS_W32TM_SIMPLESTRING_UNSPECIFIED; 
    } else if (tzi.StandardDate.wMonth>12 || tzi.StandardDate.wDay>5 || 
               tzi.StandardDate.wDay<1 || tzi.StandardDate.wDayOfWeek>6) {
        if (!WriteMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_W32TM_INVALID_TZ_DATE, &wszStandardDate, 
                      tzi.StandardDate.wMonth, tzi.StandardDate.wDay, tzi.StandardDate.wDayOfWeek)) { 
            _JumpLastError(hr, error, "WriteMsg"); 
        }
    } else {
        if (!WriteMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_W32TM_VALID_TZ_DATE, &wszStandardDate, 
                      tzi.StandardDate.wMonth, tzi.StandardDate.wDay, tzi.StandardDate.wDayOfWeek)) { 
            _JumpLastError(hr, error, "WriteMsg"); 
        }
    }

    // Construct a string representing the "DaylightDate" field of the TimeZoneInformation: 
    if (0==tzi.DaylightDate.wMonth) {
        wszDaylightDate = pwsz_IDS_W32TM_SIMPLESTRING_UNSPECIFIED; 
    } else if (tzi.DaylightDate.wMonth>12 || tzi.DaylightDate.wDay>5 || 
               tzi.DaylightDate.wDay<1 || tzi.DaylightDate.wDayOfWeek>6) {
        if (!WriteMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_W32TM_INVALID_TZ_DATE, &wszDaylightDate, 
                      tzi.DaylightDate.wMonth, tzi.DaylightDate.wDay, tzi.DaylightDate.wDayOfWeek)) { 
            _JumpLastError(hr, error, "WriteMsg"); 
        }
    } else {
        if (!WriteMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_W32TM_VALID_TZ_DATE, &wszDaylightDate, 
                      tzi.DaylightDate.wMonth, tzi.DaylightDate.wDay, tzi.DaylightDate.wDayOfWeek)) { 
            _JumpLastError(hr, error, "WriteMsg"); 
        }
    }

    DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_W32TM_TIMEZONE_INFO, 
               wszTimeZoneId,    tzi.Bias, 
               tzi.StandardName, tzi.StandardBias, wszStandardDate, 
               tzi.DaylightName, tzi.DaylightBias, wszDaylightDate); 

    hr=S_OK;
error:
    // Free our localized strings: 
    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgStrings); dwIndex++) { 
        if (NULL != *(rgStrings[dwIndex].ppwsz)) { LocalFree(*(rgStrings[dwIndex].ppwsz)); }
    }
    if (NULL != wszDaylightDate) { 
        LocalFree(wszDaylightDate); 
    }
    if (NULL != wszStandardDate) { 
        LocalFree(wszStandardDate); 
    }
    if (FAILED(hr) && E_INVALIDARG!=hr) {
        WCHAR * wszError;
        HRESULT hr2=GetSystemErrorString(hr, &wszError);
        if (FAILED(hr2)) {
            _IgnoreError(hr2, "GetSystemErrorString");
        } else {
            LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
            LocalFree(wszError);
        }
    }
    return hr;
}

//--------------------------------------------------------------------
HRESULT PrintRegLine(IN  HANDLE  hOut, 
                     IN  DWORD   dwValueNameOffset, 
                     IN  LPWSTR  pwszValueName, 
                     IN  DWORD   dwValueTypeOffset, 
                     IN  LPWSTR  pwszValueType, 
                     IN  DWORD   dwValueDataOffset, 
                     IN  LPWSTR  pwszValueData)
{
    DWORD    dwCurrentOffset = 0; 
    HRESULT  hr;
    WCHAR    pwszLine[1024]; 
    WCHAR    wszNULL[] = L"<NULL>"; 

    if (NULL == pwszValueName) { pwszValueName = &wszNULL[0]; } 
    if (NULL == pwszValueType) { pwszValueType = &wszNULL[0]; } 
    if (NULL == pwszValueData) { pwszValueData = &wszNULL[0]; } 

    // Ensure no buffer overflow:
    _Verify(1024 > dwValueDataOffset + wcslen(pwszValueData), hr, error);

    dwCurrentOffset  = dwValueNameOffset; 
    dwCurrentOffset  = wsprintf(&pwszLine[0] + dwCurrentOffset, L"%s", pwszValueName);
    
    while (dwCurrentOffset < dwValueTypeOffset) { 
        dwCurrentOffset += wsprintf(&pwszLine[0] + dwCurrentOffset, L" "); 
    }
    dwCurrentOffset += wsprintf(&pwszLine[0] + dwCurrentOffset, L"%s", pwszValueType);

    while (dwCurrentOffset < dwValueDataOffset) { 
        dwCurrentOffset += wsprintf(&pwszLine[0] + dwCurrentOffset, L" "); 
    }
    wsprintf(&pwszLine[0] + dwCurrentOffset, L"%s\n", pwszValueData); 

    // 
    PrintStr(hOut, &pwszLine[0]); 

    hr = S_OK;
    
 error:
    return hr; 
}


HRESULT DumpReg(CmdArgs * pca)
{
    BOOL          fLoggedFailure      = FALSE; 
    DWORD         dwMaxValueNameLen   = 0;      // Size in TCHARs.
    DWORD         dwMaxValueDataLen   = 0;      // Size in bytes.
    DWORD         dwNumValues         = 0; 
    DWORD         dwRetval            = 0;
    DWORD         dwType              = 0;
    DWORD         dwValueNameLen      = 0;      // Size in TCHARs.
    DWORD         dwValueDataLen      = 0;      // Size in bytes.
    HANDLE        hOut                = NULL;
    HKEY          hKeyConfig          = NULL;
    HKEY          HKLM                = HKEY_LOCAL_MACHINE; 
    HKEY          HKLMRemote          = NULL; 
    HRESULT       hr                  = E_FAIL;
    LPWSTR        pwszValueName       = NULL; 
    LPBYTE        pbValueData         = NULL; 
    LPWSTR        pwszSubkeyName      = NULL; 
    LPWSTR        pwszComputerName    = NULL; 
    unsigned int  nArgID              = 0;
    WCHAR         rgwszKeyName[1024];

    // Variables to display formatted output:
    DWORD    dwCurrentOffset     = 0;
    DWORD    dwValueNameOffset   = 0;
    DWORD    dwValueTypeOffset   = 0; 
    DWORD    dwValueDataOffset   = 0; 

    // Localized strings: 
    LPWSTR  pwsz_VALUENAME            = NULL;
    LPWSTR  pwsz_VALUETYPE            = NULL; 
    LPWSTR  pwsz_VALUEDATA            = NULL;
    LPWSTR  pwsz_REGTYPE_DWORD        = NULL; 
    LPWSTR  pwsz_REGTYPE_SZ           = NULL; 
    LPWSTR  pwsz_REGTYPE_MULTISZ      = NULL; 
    LPWSTR  pwsz_REGTYPE_EXPANDSZ     = NULL; 
    LPWSTR  pwsz_REGTYPE_UNKNOWN      = NULL; 
    LPWSTR  pwsz_REGDATA_UNPARSABLE   = NULL; 

    // Load the strings we'll need
    struct LocalizedStrings { 
        UINT     id; 
        LPWSTR  *ppwsz; 
    } rgStrings[] = { 
        { IDS_W32TM_VALUENAME,           &pwsz_VALUENAME }, 
        { IDS_W32TM_VALUETYPE,           &pwsz_VALUETYPE }, 
        { IDS_W32TM_VALUEDATA,           &pwsz_VALUEDATA },
        { IDS_W32TM_REGTYPE_DWORD,       &pwsz_REGTYPE_DWORD }, 
        { IDS_W32TM_REGTYPE_SZ,          &pwsz_REGTYPE_SZ }, 
        { IDS_W32TM_REGTYPE_MULTISZ,     &pwsz_REGTYPE_MULTISZ }, 
        { IDS_W32TM_REGTYPE_EXPANDSZ,    &pwsz_REGTYPE_EXPANDSZ }, 
        { IDS_W32TM_REGTYPE_UNKNOWN,     &pwsz_REGTYPE_UNKNOWN }, 
        { IDS_W32TM_REGDATA_UNPARSABLE,  &pwsz_REGDATA_UNPARSABLE }
    }; 
       
    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgStrings); dwIndex++) { 
        if (!WriteMsg(FORMAT_MESSAGE_FROM_HMODULE, rgStrings[dwIndex].id, rgStrings[dwIndex].ppwsz)) {
            hr = HRESULT_FROM_WIN32(GetLastError()); 
            _JumpError(hr, error, "WriteMsg"); 
        }
    }
    
    dwCurrentOffset = wsprintf(&rgwszKeyName[0], wszW32TimeRegKeyRoot); 
    
    if (true==FindArg(pca, L"subkey", &pwszSubkeyName, &nArgID)) { 
        MarkArgUsed(pca, nArgID); 

        if (NULL == pwszSubkeyName) { 
            LocalizedWPrintfCR(IDS_W32TM_ERRORDUMPREG_NO_SUBKEY_SPECIFIED);
            fLoggedFailure = TRUE;
            hr = E_INVALIDARG; 
            _JumpError(hr, error, "command line parsing");
        }
        dwCurrentOffset += wsprintf(&rgwszKeyName[0] + dwCurrentOffset, L"\\"); 
        wsprintf(&rgwszKeyName[0] + dwCurrentOffset, pwszSubkeyName); 
    }

    if (true==FindArg(pca, L"computer", &pwszComputerName, &nArgID)) { 
        MarkArgUsed(pca, nArgID); 
        
        dwRetval = RegConnectRegistry(pwszComputerName, HKEY_LOCAL_MACHINE, &HKLMRemote);
        if (ERROR_SUCCESS != dwRetval) { 
            hr = HRESULT_FROM_WIN32(dwRetval); 
            _JumpErrorStr(hr, error, "RegConnectRegistry", L"HKEY_LOCAL_MACHINE");
        }

        HKLM = HKLMRemote;
    }
    
    hr = VerifyAllArgsUsed(pca); 
    _JumpIfError(hr, error, "VerifyAllArgsUsed"); 
        

    dwRetval = RegOpenKeyEx(HKLM, rgwszKeyName, 0, KEY_QUERY_VALUE, &hKeyConfig);
    if (ERROR_SUCCESS != dwRetval) { 
        hr = HRESULT_FROM_WIN32(dwRetval); 
        _JumpErrorStr(hr, error, "RegOpenKeyEx", rgwszKeyName); 
    }
    
    dwRetval = RegQueryInfoKey
        (hKeyConfig,
         NULL,                // class buffer
         NULL,                // size of class buffer
         NULL,                // reserved
         NULL,                // number of subkeys
         NULL,                // longest subkey name
         NULL,                // longest class string
         &dwNumValues,        // number of value entries
         &dwMaxValueNameLen,  // longest value name
         &dwMaxValueDataLen,  // longest value data
         NULL, 
         NULL
         );
    if (ERROR_SUCCESS != dwRetval) { 
        hr = HRESULT_FROM_WIN32(dwRetval);
        _JumpErrorStr(hr, error, "RegQueryInfoKey", rgwszKeyName);
    } else if (0 == dwNumValues) { 
        hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS); 
        _JumpErrorStr(hr, error, "RegQueryInfoKey", rgwszKeyName);
    }

    dwMaxValueNameLen += sizeof(WCHAR);  // Include space for NULL character
    pwszValueName = (LPWSTR)LocalAlloc(LPTR, dwMaxValueNameLen * sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, pwszValueName);

    pbValueData = (LPBYTE)LocalAlloc(LPTR, dwMaxValueDataLen);
    _JumpIfOutOfMemory(hr, error, pbValueData); 
        
    dwValueNameOffset  = 0;
    dwValueTypeOffset  = dwValueNameOffset + dwMaxValueNameLen + 3; 
    dwValueDataOffset += dwValueTypeOffset + 20;  
     
    // Print table header:
    hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    if (INVALID_HANDLE_VALUE==hOut) {
        _JumpLastError(hr, error, "GetStdHandle");
    }

    PrintStr(hOut, L"\n"); 
    PrintRegLine(hOut, dwValueNameOffset, pwsz_VALUENAME, dwValueTypeOffset, pwsz_VALUETYPE, dwValueDataOffset, pwsz_VALUEDATA); 

    // Next line:
    dwCurrentOffset = dwValueNameOffset; 
    for (DWORD dwIndex = dwCurrentOffset; dwIndex < (dwValueDataOffset + (dwMaxValueDataLen / 2)); dwIndex++) { 
        PrintStr(hOut, L"-"); 
    }
    PrintStr(hOut, L"\n\n"); 
    
    for (DWORD dwIndex = 0; dwIndex < dwNumValues; dwIndex++) { 
        dwValueNameLen = dwMaxValueNameLen;
        dwValueDataLen = dwMaxValueDataLen; 

        memset(reinterpret_cast<LPBYTE>(pwszValueName), 0, dwMaxValueNameLen * sizeof(WCHAR)); 
        memset(pbValueData, 0, dwMaxValueDataLen);

        dwRetval = RegEnumValue
            (hKeyConfig,       // handle to key to query
             dwIndex,          // index of value to query
             pwszValueName,    // value buffer
             &dwValueNameLen,  // size of value buffer  (in TCHARs)
             NULL,             // reserved
             &dwType,          // type buffer
             pbValueData,      // data buffer
             &dwValueDataLen   // size of data buffer
             ); 
        if (ERROR_SUCCESS != dwRetval) { 
            hr = HRESULT_FROM_WIN32(dwRetval);
            _JumpErrorStr(hr, error, "RegEnumValue", wszW32TimeRegKeyConfig);
        }

        _Verify(dwValueNameLen <= dwMaxValueNameLen, hr, error);
        _Verify(dwValueDataLen <= dwMaxValueDataLen, hr, error); 

        {
            LPWSTR pwszRegType = NULL; 
            LPWSTR pwszRegData = NULL; 

            switch (dwType) { 
            
            case REG_DWORD:  
                { 
                    WCHAR  rgwszDwordData[20]; 

                    _ltow(*(reinterpret_cast<long *>(pbValueData)), rgwszDwordData, 10);
                    pwszRegType = pwsz_REGTYPE_DWORD; 
                    pwszRegData = &rgwszDwordData[0]; 
                }
                break;

            case REG_MULTI_SZ:
                {
                    WCHAR  wszDelimiter[]        = { L'\0', L'\0', L'\0' };
                    WCHAR  rgwszMultiSzData[1024] = { L'\0' }; 
                    LPWSTR pwsz; 

                    dwCurrentOffset = 0; 
                    for (pwsz = (LPWSTR)pbValueData; L'\0' != *pwsz; pwsz += wcslen(pwsz)+1) { 
                        dwCurrentOffset += wsprintf(&rgwszMultiSzData[0] + dwCurrentOffset, wszDelimiter); 
                        dwCurrentOffset += wsprintf(&rgwszMultiSzData[0] + dwCurrentOffset, pwsz); 
                        wszDelimiter[0] = L',';  wszDelimiter[1] = L' '; 
                    }

                    pwszRegType = pwsz_REGTYPE_MULTISZ; 
                    pwszRegData = &rgwszMultiSzData[0]; 
                }
                break;

            case REG_EXPAND_SZ:
                {
                    pwszRegType = pwsz_REGTYPE_EXPANDSZ; 
                    pwszRegData = reinterpret_cast<WCHAR *>(pbValueData); 
                }
                break;

            case REG_SZ: 
                { 
                    pwszRegType = pwsz_REGTYPE_SZ; 
                    pwszRegData = reinterpret_cast<WCHAR *>(pbValueData); 
                } 
                break; 

            default:
                // Unrecognized reg type...
                pwszRegType = pwsz_REGTYPE_UNKNOWN; 
                pwszRegData = pwsz_REGDATA_UNPARSABLE; 
            }

            PrintRegLine(hOut, dwValueNameOffset, pwszValueName, dwValueTypeOffset, pwszRegType, dwValueDataOffset, pwszRegData); 
        }
    }

    PrintStr(hOut, L"\n"); 
    hr = S_OK; 

 error:
    // Free our localized strings: 
    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgStrings); dwIndex++) { 
        if (NULL != *(rgStrings[dwIndex].ppwsz)) { LocalFree(*(rgStrings[dwIndex].ppwsz)); }
    }
    if (NULL != hKeyConfig)    { RegCloseKey(hKeyConfig); }
    if (NULL != HKLMRemote)    { RegCloseKey(HKLMRemote); } 
    if (NULL != pwszValueName) { LocalFree(pwszValueName); } 
    if (NULL != pbValueData)   { LocalFree(pbValueData); } 
    if (FAILED(hr) && !fLoggedFailure) {
        WCHAR * wszError;
        HRESULT hr2=GetSystemErrorString(hr, &wszError);
        if (FAILED(hr2)) {
            _IgnoreError(hr2, "GetSystemErrorString");
        } else {
            LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
            LocalFree(wszError);
        }
    }
    return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32tm\servicehost.h ===
//--------------------------------------------------------------------
// ServiceHost - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 9-9-99
//
// Stuff for hosting a service dll
//

#ifndef SERVICE_HOST_H
#define SERVICE_HOST_H

HRESULT RunAsService(void);
HRESULT RunAsTestService(void);
HRESULT RegisterDll(void);
HRESULT UnregisterDll(void);

#endif //SERVICE_HOST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32tm\timemonitor.cpp ===
//--------------------------------------------------------------------
// TimeMonitor - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 10-4-99
//
// Monitor time servers
//

#include "pch.h" // precompiled headers

//####################################################################

struct ComputerRecord {
    WCHAR * wszName;
    bool bIsPdc;

    // DNS
    in_addr * rgiaLocalIpAddrs;
    in_addr * rgiaRemoteIpAddrs;
    unsigned int nIpAddrs;
    HRESULT hrIPs;

    // ICMP
    HRESULT hrIcmp;
    DWORD dwIcmpDelay;

    // NTP
    NtTimeOffset toOffset;
    HRESULT hrNtp;
    NtpRefId refid;
    unsigned int nStratum;
    ComputerRecord * pcrReferer;
    WCHAR * wszReferer;
    unsigned int nTimeout; 

    // SERVICE
    bool bDoingService;
    HRESULT hrService;
    DWORD dwStartType;
    DWORD dwCurrentState;
};

struct NameHolder {
    WCHAR * wszName;
    bool bIsDomain;
    NameHolder * pnhNext;
};

enum AlertType {
    e_MaxSpreadAlert,
    e_MinServersAlert,
};

struct AlertRecord {
    AlertType eType;
    unsigned int nParam1;
    DWORD dwError;
    AlertRecord * parNext;
};

struct ThreadSharedContext {
    ComputerRecord ** rgpcrList;
    unsigned int nComputers;
    volatile unsigned int nNextComputer;
    volatile unsigned int nFinishedComputers;
};

struct ThreadContext {
    HANDLE hThread;
    volatile unsigned int nCurRecord;
    ThreadSharedContext * ptsc;
};


MODULEPRIVATE const DWORD gc_dwTimeout=1000;

//####################################################################
//--------------------------------------------------------------------
MODULEPRIVATE inline void ClearLine(void) {
    wprintf(L"                                                                      \r");
}


//--------------------------------------------------------------------
MODULEPRIVATE void FreeComputerRecord(ComputerRecord * pcr) {
    if (NULL==pcr) {
        return;
    }
    if (NULL!=pcr->wszName) {
        LocalFree(pcr->wszName);
    }
    if (NULL!=pcr->rgiaLocalIpAddrs) {
        LocalFree(pcr->rgiaLocalIpAddrs);
    }
    if (NULL!=pcr->rgiaRemoteIpAddrs) {
        LocalFree(pcr->rgiaRemoteIpAddrs);
    }
    if (NULL!=pcr->wszReferer) {
        LocalFree(pcr->wszReferer);
    }
    LocalFree(pcr);
};

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT AnalyzeComputer(ComputerRecord * pcr) {
    HRESULT hr;
    NtpPacket npPacket;
    NtTimeEpoch teDestinationTimestamp;

    DebugWPrintf1(L"%s:\n", pcr->wszName);

    // look up Ip addrs if necessary
    if (0==pcr->nIpAddrs) {
        hr=MyGetIpAddrs(pcr->wszName, &pcr->rgiaLocalIpAddrs, &pcr->rgiaRemoteIpAddrs, &pcr->nIpAddrs, NULL);
        pcr->hrIPs=hr;
        _JumpIfError(hr, error, "MyGetIpAddrs");
    }

    // do an ICMP ping
    DebugWPrintf0(L"  ICMP: ");
    hr=MyIcmpPing(&(pcr->rgiaRemoteIpAddrs[0]), gc_dwTimeout, &pcr->dwIcmpDelay);
    pcr->hrIcmp=hr;
    // Some machines do not have ping servers, but still serve time.  We can still try an NTP ping
    // if this fails.  
    _IgnoreIfError(hr, "MyIcmpPing");

    // do an NTP ping
    DebugWPrintf0(L"    NTP: ");
    hr=MyNtpPing(&(pcr->rgiaRemoteIpAddrs[0]), pcr->nTimeout, &npPacket, &teDestinationTimestamp);
    pcr->hrNtp=hr;
    _JumpIfError(hr, error, "MyNtpPing");

    {
        // calculate the offset
        NtTimeEpoch teOriginateTimestamp=NtTimeEpochFromNtpTimeEpoch(npPacket.teOriginateTimestamp);
        NtTimeEpoch teReceiveTimestamp=NtTimeEpochFromNtpTimeEpoch(npPacket.teReceiveTimestamp);
        NtTimeEpoch teTransmitTimestamp=NtTimeEpochFromNtpTimeEpoch(npPacket.teTransmitTimestamp);
        NtTimeOffset toLocalClockOffset=
            (teReceiveTimestamp-teOriginateTimestamp)
            + (teTransmitTimestamp-teDestinationTimestamp);
        toLocalClockOffset/=2;
        pcr->toOffset=toLocalClockOffset;

        // new referer?
        if (pcr->refid.value!=npPacket.refid.value || pcr->nStratum!=npPacket.nStratum) {
            // clean out the old values
            if (NULL!=pcr->wszReferer) {
                LocalFree(pcr->wszReferer);
                pcr->wszReferer=NULL;
            }
            pcr->pcrReferer=NULL;
            pcr->refid.value=npPacket.refid.value;
            pcr->nStratum=npPacket.nStratum;
        }
    }
    
    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE DWORD WINAPI AnalysisThread(void * pvContext) {
    ThreadContext * ptc=(ThreadContext *)pvContext;

    while (true) {
        ptc->nCurRecord=InterlockedIncrement((LONG *)&(ptc->ptsc->nNextComputer))-1;
        if (ptc->nCurRecord<ptc->ptsc->nComputers) {
            AnalyzeComputer(ptc->ptsc->rgpcrList[ptc->nCurRecord]);
            ptc->ptsc->nFinishedComputers++; // atomic
        } else {
            break;
        }
    }

    return S_OK;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT ResolveReferer(ComputerRecord ** rgpcrList, unsigned int nComputers, unsigned int nCur) {
    HRESULT hr;
    unsigned int nIndex;
    HOSTENT * phe;
    int nChars;

    // see if it is nobody
    if (0==rgpcrList[nCur]->refid.value || 1>=rgpcrList[nCur]->nStratum) {
        // no referer
    } else if (NULL==rgpcrList[nCur]->wszReferer && NULL==rgpcrList[nCur]->pcrReferer) {
        // referer not yet determined

        // first, see if it is someone we are checking
        for (nIndex=0; nIndex<nComputers; nIndex++) {
            if (rgpcrList[nIndex]->nIpAddrs>0 && 
                rgpcrList[nIndex]->rgiaRemoteIpAddrs[0].S_un.S_addr==rgpcrList[nCur]->refid.value) {
                rgpcrList[nCur]->pcrReferer=rgpcrList[nIndex];
            }
        }

        // if we still don't know, do a reverse DNS lookup
        if (NULL==rgpcrList[nCur]->pcrReferer) {
            phe=gethostbyaddr((char *)&(rgpcrList[nCur]->refid.value), 4, AF_INET);
            if (NULL==phe) {
                // not worth aborting over.
                _IgnoreLastError("gethostbyaddr");
            } else {

                // save the result as a unicode string
                nChars=MultiByteToWideChar(CP_ACP, 0, phe->h_name, -1, NULL, 0);
                if (0==nChars) {
                    _JumpLastError(hr, error, "MultiByteToWideChar(1)");
                }
                rgpcrList[nCur]->wszReferer=(WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*nChars);
                _JumpIfOutOfMemory(hr, error, rgpcrList[nCur]->wszReferer);
                nChars=MultiByteToWideChar(CP_ACP, 0, phe->h_name, -1, rgpcrList[nCur]->wszReferer, nChars);
                if (0==nChars) {
                    _JumpLastError(hr, error, "MultiByteToWideChar(2)");
                }

            } // <- end if lookup successful
        } // <- end if need to to reverse DNS lookup
    } // <- end if need to determine referer

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT ParseCmdLineForComputerNames(CmdArgs * pca, NameHolder ** ppnhList) {
    HRESULT hr;
    NameHolder * pnhTemp;
    WCHAR * wszComputerList;
    WCHAR * wszDomainName;
    unsigned int nComputerIndex;
    unsigned int nDomainIndex;

    // must be cleaned up
    NameHolder * pnhList=NULL;

    NameHolder ** ppnhTail=&pnhList;

    // check for list of computers
    while (FindArg(pca, L"computers", &wszComputerList, &nComputerIndex)) {
        // allocate
        pnhTemp=(NameHolder *)LocalAlloc(LPTR, sizeof(NameHolder));
        _JumpIfOutOfMemory(hr, error, pnhTemp);
        // link to tail of list
        *ppnhTail=pnhTemp;
        ppnhTail=&(pnhTemp->pnhNext);
        // remember the arg we found
        pnhTemp->bIsDomain=false;
        pnhTemp->wszName=wszComputerList;
        // mark arg as used
        MarkArgUsed(pca, nComputerIndex);
    }

    // check for domain
    while (FindArg(pca, L"domain", &wszDomainName, &nDomainIndex)) {
        // allocate
        pnhTemp=(NameHolder *)LocalAlloc(LPTR, sizeof(NameHolder));
        _JumpIfOutOfMemory(hr, error, pnhTemp);
        // link to tail of list
        *ppnhTail=pnhTemp;
        ppnhTail=&(pnhTemp->pnhNext);
        // remember the arg we found
        pnhTemp->bIsDomain=true;
        pnhTemp->wszName=wszDomainName;
        // mark arg as used
        MarkArgUsed(pca, nDomainIndex);
    }

    // put in the default domain if nothing specified
    if (NULL==pnhList) {
        // allocate
        pnhTemp=(NameHolder *)LocalAlloc(LPTR, sizeof(NameHolder));
        _JumpIfOutOfMemory(hr, error, pnhTemp);
        // link to tail of list
        *ppnhTail=pnhTemp;
        ppnhTail=&(pnhTemp->pnhNext);
        // add default
        pnhTemp->bIsDomain=true;
        pnhTemp->wszName=L"";
    }

    // successful
    hr=S_OK;
    *ppnhList=pnhList;
    pnhList=NULL;

error:
    while (NULL!=pnhList) {
        pnhTemp=pnhList;
        pnhList=pnhTemp->pnhNext;
        LocalFree(pnhTemp);
    }
    return hr;
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT BuildComputerList(NameHolder * pnhList, ComputerRecord *** prgpcrList, unsigned int * pnComputers, unsigned int nTimeout)
{
    HRESULT hr;
    unsigned int nComputers=0;
    unsigned int nDcs;
    unsigned int nPrevComputers;
    unsigned int nIndex;

    // must be cleaned up
    ComputerRecord ** rgpcrList=NULL;
    DcInfo * rgdiDcList=NULL;
    ComputerRecord ** rgpcrPrev=NULL;


    // for each set of names in our list
    while (NULL!=pnhList) {

        if (pnhList->bIsDomain) {

            // get the dc list
            if (L'\0'==pnhList->wszName[0]) {
                LocalizedWPrintf2(IDS_W32TM_STATUS_GETTING_DC_LIST_FOR_DEFAULT_DOMAIN, L"\r");
            } else {
                LocalizedWPrintf2(IDS_W32TM_STATUS_GETTING_DC_LIST_FOR, L" %s...\r", pnhList->wszName);
            }
            DebugWPrintf0(L"\n");
            hr=GetDcList(pnhList->wszName, false, &rgdiDcList, &nDcs);
            ClearLine();
            if (FAILED(hr)) {
                LocalizedWPrintf2(IDS_W32TM_ERRORTIMEMONITOR_GETDCLIST_FAILED, L" 0x%08X.\n", hr);
            }
            _JumpIfError(hr, error, "GetDcList");

            // allow for previous list
            nPrevComputers=nComputers;
            rgpcrPrev=rgpcrList;
            rgpcrList=NULL;

            nComputers+=nDcs;

            // allocate memory
            rgpcrList=(ComputerRecord **)LocalAlloc(LPTR, nComputers*sizeof(ComputerRecord *));
            _JumpIfOutOfMemory(hr, error, rgpcrList);
            for (nIndex=nPrevComputers; nIndex<nComputers; nIndex++) {
                rgpcrList[nIndex]=(ComputerRecord *)LocalAlloc(LPTR, sizeof(ComputerRecord));
                _JumpIfOutOfMemory(hr, error, rgpcrList[nIndex]);
            }

            // move the computers from the previous list
            if (0!=nPrevComputers) {
                for (nIndex=0; nIndex<nPrevComputers; nIndex++) {
                    rgpcrList[nIndex]=rgpcrPrev[nIndex];
                }
                LocalFree(rgpcrPrev);
                rgpcrPrev=NULL;
            }

            // steal the data from the DC list
            for (nIndex=0; nIndex<nDcs; nIndex++) {
                rgpcrList[nIndex+nPrevComputers]->wszName=rgdiDcList[nIndex].wszDnsName;
                rgpcrList[nIndex+nPrevComputers]->nIpAddrs=rgdiDcList[nIndex].nIpAddresses;
                rgpcrList[nIndex+nPrevComputers]->rgiaLocalIpAddrs=rgdiDcList[nIndex].rgiaLocalIpAddresses;
                rgpcrList[nIndex+nPrevComputers]->rgiaRemoteIpAddrs=rgdiDcList[nIndex].rgiaRemoteIpAddresses;
                rgpcrList[nIndex+nPrevComputers]->bIsPdc=rgdiDcList[nIndex].bIsPdc;
                rgdiDcList[nIndex].wszDnsName=NULL;
                rgdiDcList[nIndex].rgiaLocalIpAddresses=NULL;
                rgdiDcList[nIndex].rgiaRemoteIpAddresses=NULL;
            }
        } else {

            // allow for previous list
            nPrevComputers=nComputers;
            rgpcrPrev=rgpcrList;
            rgpcrList=NULL;

            // count the number of computers in the computer list
            WCHAR * wszTravel=pnhList->wszName;
            nComputers=1;
            while (NULL!=(wszTravel=wcschr(wszTravel, L','))) {
                nComputers++;
                wszTravel++;
            }

            nComputers+=nPrevComputers;

            // allocate memory
            rgpcrList=(ComputerRecord **)LocalAlloc(LPTR, nComputers*sizeof(ComputerRecord *));
            _JumpIfOutOfMemory(hr, error, rgpcrList);
            for (nIndex=nPrevComputers; nIndex<nComputers; nIndex++) {
                rgpcrList[nIndex]=(ComputerRecord *)LocalAlloc(LPTR, sizeof(ComputerRecord));
                _JumpIfOutOfMemory(hr, error, rgpcrList[nIndex]);
            }

            // move the computers from the previous list
            if (0!=nPrevComputers) {
                for (nIndex=0; nIndex<nPrevComputers; nIndex++) {
                    rgpcrList[nIndex]=rgpcrPrev[nIndex];
                }
                LocalFree(rgpcrPrev);
                rgpcrPrev=NULL;
            }

            // fill in each record
            wszTravel=pnhList->wszName;
            for (nIndex=nPrevComputers; nIndex<nComputers; nIndex++) {
                WCHAR * wszComma=wcschr(wszTravel, L',');
                if (NULL!=wszComma) {
                    wszComma[0]=L'\0';
                }
                if (L'*'==wszTravel[0]) {
                    rgpcrList[nIndex]->bIsPdc=true;
                    wszTravel++;
                }
                rgpcrList[nIndex]->wszName=(WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(wszTravel)+1));
                _JumpIfOutOfMemory(hr, error, rgpcrList[nIndex]->wszName);
                wcscpy(rgpcrList[nIndex]->wszName, wszTravel);
                wszTravel=wszComma+1;
            }
        }

        pnhList=pnhList->pnhNext;
    }

    // Fill in shared computer data:
    for (nIndex=0; nIndex<nComputers; nIndex++) { 
        rgpcrList[nIndex]->nTimeout = nTimeout; 
    }

    // success
    hr=S_OK;
    *pnComputers=nComputers;
    *prgpcrList=rgpcrList;
    rgpcrList=NULL;

error:
    if (NULL!=rgpcrPrev) {
        for (nIndex=0; nIndex<nPrevComputers; nIndex++) {
            FreeComputerRecord(rgpcrPrev[nIndex]);
        }
        LocalFree(rgpcrPrev);
    }
    if (NULL!=rgdiDcList) {
        for (nIndex=0; nIndex<nDcs; nIndex++) {
            FreeDcInfo(&(rgdiDcList[nIndex]));
        }
        LocalFree(rgdiDcList);
    }
    if (NULL!=rgpcrList) {
        for (nIndex=0; nIndex<nComputers; nIndex++) {
            FreeComputerRecord(rgpcrList[nIndex]);
        }
        LocalFree(rgpcrList);
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE void FreeAlertRecords(AlertRecord * parList) {
    while (NULL!=parList) {
        AlertRecord * parTemp=parList;
        parList=parList->parNext;
        LocalFree(parTemp);
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT ParseCmdLineForAlerts(CmdArgs * pca, AlertRecord ** pparList) {
    HRESULT hr;
    WCHAR * rgwszAlertParams[10];
    WCHAR * wszAlert;
    unsigned int nAlertIndex;
    AlertRecord * parTemp;
    unsigned int nIndex;

    // must be cleaned up
    AlertRecord * parList=NULL;

    AlertRecord ** pparTail=&parList;

    // check for list of computers
    while (FindArg(pca, L"alert", &wszAlert, &nAlertIndex)) {

        // parse out comma separates params
        nIndex=0;
        rgwszAlertParams[0]=wszAlert;
        while (nIndex<10 && NULL!=(rgwszAlertParams[nIndex]=wcschr(rgwszAlertParams[nIndex], L','))) {
            rgwszAlertParams[nIndex][0]=L'\0';
            rgwszAlertParams[nIndex]++;
            rgwszAlertParams[nIndex+1]=rgwszAlertParams[nIndex];
            nIndex++;
        }
        
        // is it "maxspread"
        if (0==_wcsicmp(wszAlert, L"maxspread")) {
            // quick validy check on params
            if (NULL==rgwszAlertParams[0] || NULL==rgwszAlertParams[1] || NULL!=rgwszAlertParams[2]) {
                LocalizedWPrintf2(IDS_W32TM_ERRORPARAMETER_INCORRECT_NUMBER_FOR_ALERT, L" '%s'.\n", wszAlert);
                hr=E_INVALIDARG;
                _JumpError(hr, error, "command line parsing");
            }
            // allocate
            parTemp=(AlertRecord *)LocalAlloc(LPTR, sizeof(AlertRecord));
            _JumpIfOutOfMemory(hr, error, parTemp);
            // link to tail of list
            *pparTail=parTemp;
            pparTail=&(parTemp->parNext);
            // remember the args we found
            parTemp->eType=e_MaxSpreadAlert;
            parTemp->nParam1=wcstoul(rgwszAlertParams[0],NULL,0);
            parTemp->dwError=wcstoul(rgwszAlertParams[1],NULL,0);

        // is it "minservers
        } else if (0==_wcsicmp(wszAlert, L"minservers")) {
            // quick validy check on params
            if (NULL==rgwszAlertParams[0] || NULL==rgwszAlertParams[1] || NULL!=rgwszAlertParams[2]) {
                LocalizedWPrintf2(IDS_W32TM_ERRORPARAMETER_INCORRECT_NUMBER_FOR_ALERT, L" '%s'.\n", wszAlert);
                hr=E_INVALIDARG;
                _JumpError(hr, error, "command line parsing");
            }
            // allocate
            parTemp=(AlertRecord *)LocalAlloc(LPTR, sizeof(AlertRecord));
            _JumpIfOutOfMemory(hr, error, parTemp);
            // link to tail of list
            *pparTail=parTemp;
            pparTail=&(parTemp->parNext);
            // remember the args we found
            parTemp->eType=e_MinServersAlert;
            parTemp->nParam1=wcstoul(rgwszAlertParams[0],NULL,0);
            parTemp->dwError=wcstoul(rgwszAlertParams[1],NULL,0);
        } else {
            wprintf(L"Alert '%s' unknown.\n", wszAlert);
            hr=E_INVALIDARG;
            _JumpError(hr, error, "command line parsing");
        }

        if (!(parTemp->dwError&0x80000000)) { // check sign bit
            wprintf(L"Retval not negative for alert '%s'.\n", wszAlert);
            hr=E_INVALIDARG;
            _JumpError(hr, error, "command line parsing");
        }

        // mark arg as used
        MarkArgUsed(pca, nAlertIndex);

    } // <- end FindArg loop

    // success
    hr=S_OK;
    *pparList=parList;
    parList=NULL;

error:
    if (NULL!=parList) {
        FreeAlertRecords(parList);
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT CheckForAlerts(ComputerRecord ** rgpcrList, unsigned int nComputers, AlertRecord * parList) {
    HRESULT hr;
    unsigned int nIndex;
    
    for (; NULL!=parList; parList=parList->parNext) {

        if (e_MaxSpreadAlert==parList->eType) {

            // see how big the spread is
            NtTimeOffset toMax;
            NtTimeOffset toMin;
            bool bFirst=true;
            for (nIndex=0; nIndex<nComputers; nIndex++) {
                if (S_OK==rgpcrList[nIndex]->hrIPs && 
                    S_OK==rgpcrList[nIndex]->hrIcmp &&
                    S_OK==rgpcrList[nIndex]->hrNtp) {
                    if (bFirst) {
                        toMin=toMax=rgpcrList[nIndex]->toOffset;
                        bFirst=false;
                    } else {
                        if (toMin>rgpcrList[nIndex]->toOffset) {
                            toMin=rgpcrList[nIndex]->toOffset;
                        }
                        if (toMax<rgpcrList[nIndex]->toOffset) {
                            toMax=rgpcrList[nIndex]->toOffset;
                        }
                    }
                }
            }
            if (bFirst) {
                // no valid data!
                // ignore this alert
                continue;
            }
            unsigned __int64 qwSpread=(unsigned __int64)(toMax.qw-toMin.qw);
            if (qwSpread>((unsigned __int64)(parList->nParam1))*10000000) {
                DWORD dwFraction=(DWORD)(qwSpread%10000000);
                qwSpread/=10000000;
                wprintf(L"** ALERT: Current spread %I64u.%07us is greater than maximum\n"
                        L"          spread %us. Returning 0x%08X\n",
                        qwSpread, dwFraction, parList->nParam1, parList->dwError);
                hr=parList->dwError;
                _JumpError(hr, error, "maxspread alert evaluation");
            }

        } else if (e_MinServersAlert==parList->eType) {

            // see how many usable servers there are
            unsigned int nServers=0;
            for (nIndex=0; nIndex<nComputers; nIndex++) {
                if (S_OK==rgpcrList[nIndex]->hrIPs && 
                    S_OK==rgpcrList[nIndex]->hrIcmp &&
                    S_OK==rgpcrList[nIndex]->hrNtp) {
                    nServers++;
                }
            }
            if (nServers<parList->nParam1) {
                wprintf(L"** ALERT: Current usable servers (%u) is less than the minimum\n"
                        L"          usable servers (%u). Returning 0x%08X\n",
                        nServers, parList->nParam1, parList->dwError);
                hr=parList->dwError;
                _JumpError(hr, error, "e_MinServersAlert alert evaluation");
            }

        } else {
            // unknown alert type
            _MyAssert(false);
        }
    } // <- end alert checking loop

    hr=S_OK;
error:
    return hr;
}

//####################################################################
//--------------------------------------------------------------------
void PrintHelpTimeMonitor(void) {
    UINT idsText[] = { 
        IDS_W32TM_MONITORHELP_LINE1,  IDS_W32TM_MONITORHELP_LINE2,
        IDS_W32TM_MONITORHELP_LINE3,  IDS_W32TM_MONITORHELP_LINE4,
        IDS_W32TM_MONITORHELP_LINE5,  IDS_W32TM_MONITORHELP_LINE6,
        IDS_W32TM_MONITORHELP_LINE7,  IDS_W32TM_MONITORHELP_LINE8,
        IDS_W32TM_MONITORHELP_LINE9,  IDS_W32TM_MONITORHELP_LINE10,
        IDS_W32TM_MONITORHELP_LINE11, IDS_W32TM_MONITORHELP_LINE12,
        IDS_W32TM_MONITORHELP_LINE13, IDS_W32TM_MONITORHELP_LINE14,
        IDS_W32TM_MONITORHELP_LINE15, IDS_W32TM_MONITORHELP_LINE16,
        IDS_W32TM_MONITORHELP_LINE17, IDS_W32TM_MONITORHELP_LINE18,
        IDS_W32TM_MONITORHELP_LINE19, IDS_W32TM_MONITORHELP_LINE20,
        IDS_W32TM_MONITORHELP_LINE21, IDS_W32TM_MONITORHELP_LINE22,
        IDS_W32TM_MONITORHELP_LINE23, IDS_W32TM_MONITORHELP_LINE24,
        IDS_W32TM_MONITORHELP_LINE25
    };  

    for (int n=0; n<ARRAYSIZE(idsText); n++) {
        LocalizedWPrintf(idsText[n]); 
    }
}

//--------------------------------------------------------------------
HRESULT TimeMonitor(CmdArgs * pca) {
    HRESULT hr;

    unsigned int nComputers;
    unsigned int nIndex;
    unsigned int nThreads;
    unsigned int nTimeout; 
    ComputerRecord * pcrOffsetsFrom;
    WCHAR * wszNumThreads;
    WCHAR * wszTimeout; 
    ThreadSharedContext tscContext;

    // must be cleaned up
    ComputerRecord ** rgpcrList=NULL;
    NameHolder * pnhList=NULL;
    AlertRecord * parList=NULL;
    bool bSocketLayerOpen=false;
    ThreadContext * rgtcThreads=NULL;

    // init winsock
    hr=OpenSocketLayer();
    _JumpIfError(hr, error, "OpenSocketLayer");
    bSocketLayerOpen=true;

    //
    // parse command line
    //

    hr=ParseCmdLineForComputerNames(pca, &pnhList);
    _JumpIfError(hr, error, "ParseTimeMonCmdLineForComputerNames");


    hr=ParseCmdLineForAlerts(pca, &parList);
    _JumpIfError(hr, error, "ParseCmdLineForAlerts");

    // get number of threads to use
    if (FindArg(pca, L"threads", &wszNumThreads, &nThreads)) {
        MarkArgUsed(pca, nThreads);
        nThreads=wcstoul(wszNumThreads, NULL, 0);
        if (nThreads<1 || nThreads>50) {
            LocalizedWPrintf2(IDS_W32TM_ERRORTIMEMONITOR_INVALID_NUMBER_THREADS, L" (%u).\n", nThreads);
            hr=E_INVALIDARG;
            _JumpError(hr, error, "command line parsing");
        }
    } else {
        nThreads=3;
    }

    // get timeout to use for NTP ping
    if (FindArg(pca, L"timeout", &wszTimeout, &nTimeout)) { 
        MarkArgUsed(pca, nTimeout); 
        nTimeout=wcstoul(wszTimeout, NULL, 0); 
	nTimeout*=1000; 
    } else { 
        nTimeout = gc_dwTimeout; 
    }

    // all args should be parsed
    if (pca->nArgs!=pca->nNextArg) {
        LocalizedWPrintf(IDS_W32TM_ERRORGENERAL_UNEXPECTED_PARAMS);
        for(; pca->nArgs!=pca->nNextArg; pca->nNextArg++) {
            wprintf(L" %s", pca->rgwszArgs[pca->nNextArg]);
        }
        wprintf(L"\n");
        hr=E_INVALIDARG;
        _JumpError(hr, error, "command line parsing");
    }

    //
    // build list of computers to analyze
    //

    hr=BuildComputerList(pnhList, &rgpcrList, &nComputers, nTimeout);
    _JumpIfError(hr, error, "BuildComputerList");


    //
    // Do Analysis
    //

    // analyze each of the computers
    if (nThreads>nComputers) {
        nThreads=nComputers;
    }
    if (nThreads<=1) {
        for (nIndex=0; nIndex<nComputers; nIndex++) {
            ClearLine();
            wprintf(L"Analyzing %s (%u of %u)...\r", rgpcrList[nIndex]->wszName, nIndex+1, nComputers);
            DebugWPrintf0(L"\n");
            hr=AnalyzeComputer(rgpcrList[nIndex]);
            // errors are saved in the ComputerRecord and reported later
        }
    } else {

        // get ready to use threads
        DWORD dwThreadID;
        tscContext.nComputers=nComputers;
        tscContext.rgpcrList=rgpcrList;
        tscContext.nNextComputer=0;
        tscContext.nFinishedComputers=0;
        rgtcThreads=(ThreadContext *)LocalAlloc(LPTR, nThreads*sizeof(ThreadContext));
        _JumpIfOutOfMemory(hr, error, rgtcThreads);
        for (nIndex=0; nIndex<nThreads; nIndex++) {
            rgtcThreads[nIndex].ptsc=&tscContext;
            rgtcThreads[nIndex].nCurRecord=-1;
            rgtcThreads[nIndex].hThread=CreateThread(NULL, 0, AnalysisThread, &(rgtcThreads[nIndex]), 0, &dwThreadID);
            if (NULL==rgtcThreads[nIndex].hThread) {
                _JumpLastError(hr, error, "CreateThread");
            }
        }

        // wait for the threads to finish
        while (tscContext.nFinishedComputers<nComputers) {
            wprintf(L"Analyzing:");
            for (nIndex=0; nIndex<nThreads && nIndex<16; nIndex++) {
                unsigned int nCurRecord=rgtcThreads[nIndex].nCurRecord;
                if (nCurRecord<nComputers) {
                    wprintf(L" %2u", nCurRecord+1);
                } else {
                    wprintf(L" --");
                }
            }
            wprintf(L" (%u of %u)\r", tscContext.nFinishedComputers, nComputers);
            Sleep(250);
        }
    }

    // resolve referers
    for (nIndex=0; nIndex<nComputers; nIndex++) {
        ClearLine();
        wprintf(L"resolving referer %u.%u.%u.%u (%u of %u)...\r", 
            rgpcrList[nIndex]->refid.rgnIpAddr[0], 
            rgpcrList[nIndex]->refid.rgnIpAddr[1], 
            rgpcrList[nIndex]->refid.rgnIpAddr[2], 
            rgpcrList[nIndex]->refid.rgnIpAddr[3], 
            nIndex+1, nComputers);
        DebugWPrintf0(L"\n");
        hr=ResolveReferer(rgpcrList, nComputers, nIndex);
        _JumpIfError(hr, error, "ResolveReferer"); // only fatal errors are returned
    }


    ClearLine();
    
    // if there is a PDC, base the offsets from that
    pcrOffsetsFrom=NULL;
    for (nIndex=0; nIndex<nComputers; nIndex++) {
        if (rgpcrList[nIndex]->bIsPdc) {
            pcrOffsetsFrom=rgpcrList[nIndex];
            unsigned int nSubIndex;
            NtTimeOffset toPdc=rgpcrList[nIndex]->toOffset;
            for (nSubIndex=0; nSubIndex<nComputers; nSubIndex++) {
                rgpcrList[nSubIndex]->toOffset-=toPdc;
            }
            break;
        }
    }

    //
    // print the results
    //

    for (nIndex=0; nIndex<nComputers; nIndex++) {

        // print who we are looking at
        wprintf(L"%s%s", rgpcrList[nIndex]->wszName, rgpcrList[nIndex]->bIsPdc?L" *** PDC ***":L"");
        if (0==rgpcrList[nIndex]->nIpAddrs) {
            if (HRESULT_FROM_WIN32(WSAHOST_NOT_FOUND)==rgpcrList[nIndex]->hrIPs) {
                wprintf(L" [error WSAHOST_NOT_FOUND]\n");
            } else {
                wprintf(L" [error 0x%08X]\n", rgpcrList[nIndex]->hrIPs);
            }
            // don't bother with anything else if this doesn't work
            continue;
        } else {
            wprintf(L" [%u.%u.%u.%u]:\n", 
                rgpcrList[nIndex]->rgiaRemoteIpAddrs[0].S_un.S_un_b.s_b1,
                rgpcrList[nIndex]->rgiaRemoteIpAddrs[0].S_un.S_un_b.s_b2,
                rgpcrList[nIndex]->rgiaRemoteIpAddrs[0].S_un.S_un_b.s_b3,
                rgpcrList[nIndex]->rgiaRemoteIpAddrs[0].S_un.S_un_b.s_b4
                );
        }

        // display an ICMP ping
        wprintf(L"    ICMP: ");
        if (FAILED(rgpcrList[nIndex]->hrIcmp)) {
            if (HRESULT_FROM_WIN32(IP_REQ_TIMED_OUT)==rgpcrList[nIndex]->hrIcmp) {
                wprintf(L"error IP_REQ_TIMED_OUT - no response in %ums\n", gc_dwTimeout);
            } else {
                wprintf(L"error 0x%08X\n",rgpcrList[nIndex]->hrIcmp);
            }
	    
	    // NOTE: we could still have successfully done an NTP ping, even if an ICMP
	    //       ping fails, as some servers disable ICMP.  
        } else {
            wprintf(L"%ums delay.\n", rgpcrList[nIndex]->dwIcmpDelay);
        }

        // display an NTP ping
        wprintf(L"    NTP: ");
        if (FAILED(rgpcrList[nIndex]->hrNtp)) {
            if (HRESULT_FROM_WIN32(WSAECONNRESET)==rgpcrList[nIndex]->hrNtp) {
                wprintf(L"error WSAECONNRESET - no server listening on NTP port\n");
            } else if (HRESULT_FROM_WIN32(ERROR_TIMEOUT)==rgpcrList[nIndex]->hrNtp) {
		wprintf(L"error ERROR_TIMEOUT - no response from server in %ums\n", rgpcrList[nIndex]->nTimeout); 
            } else {
                wprintf(L"error 0x%08X\n" ,rgpcrList[nIndex]->hrNtp);
            }
        } else {

            // display the offset
            DWORD dwSecFraction;
            NtTimeOffset toLocalClockOffset=rgpcrList[nIndex]->toOffset;
            WCHAR * wszSign;

            if (toLocalClockOffset.qw<0) {
                toLocalClockOffset=-toLocalClockOffset;
                wszSign=L"-";
            } else {
                wszSign=L"+";
            }
            dwSecFraction=(DWORD)(toLocalClockOffset.qw%10000000);
            toLocalClockOffset/=10000000;
            wprintf(L"%s%I64u.%07us offset from %s\n", wszSign, toLocalClockOffset.qw, dwSecFraction,
                ((NULL!=pcrOffsetsFrom)?pcrOffsetsFrom->wszName:L"local clock"));

            // deterine and display the referer
            WCHAR * wszReferer;
            WCHAR wszRefName[7];
            if (0==rgpcrList[nIndex]->refid.value) {
                wszReferer=L"unspecified / unsynchronized";
            } else if (1>=rgpcrList[nIndex]->nStratum) {
                wszReferer=wszRefName;
                wszRefName[0]=L'\'';
                wszRefName[1]=rgpcrList[nIndex]->refid.rgnName[0];
                wszRefName[2]=rgpcrList[nIndex]->refid.rgnName[1];
                wszRefName[3]=rgpcrList[nIndex]->refid.rgnName[2];
                wszRefName[4]=rgpcrList[nIndex]->refid.rgnName[3];
                wszRefName[5]=L'\'';
                wszRefName[6]=0;
            } else if (NULL!=rgpcrList[nIndex]->pcrReferer) {
                wszReferer=rgpcrList[nIndex]->pcrReferer->wszName;
            } else if (NULL!=rgpcrList[nIndex]->wszReferer) {
                wszReferer=rgpcrList[nIndex]->wszReferer;
            } else {
                wszReferer=L"(unknown)";
            }
            wprintf(L"        RefID: %s [%u.%u.%u.%u]\n",
                wszReferer,
                rgpcrList[nIndex]->refid.rgnIpAddr[0],
                rgpcrList[nIndex]->refid.rgnIpAddr[1],
                rgpcrList[nIndex]->refid.rgnIpAddr[2],
                rgpcrList[nIndex]->refid.rgnIpAddr[3]
                );

            // BUGBUG: change not approved for beta2, checkin to beta 3:
            // wprintf(L"        Stratum: %d\n", rgpcrList[nIndex]->nStratum);
        }
    } // <- end ComputerRecord display loop

    hr=CheckForAlerts(rgpcrList, nComputers, parList);
    _JumpIfError(hr, error, "CheckForAlerts");


    hr=S_OK;
error:
    if (NULL!=rgpcrList) {
        for (nIndex=0; nIndex<nComputers; nIndex++) {
            FreeComputerRecord(rgpcrList[nIndex]);
        }
        LocalFree(rgpcrList);
    }
    while (NULL!=pnhList) {
        NameHolder * pnhTemp=pnhList;
        pnhList=pnhList->pnhNext;
        LocalFree(pnhTemp);
    }
    if (true==bSocketLayerOpen) {
        CloseSocketLayer();
    }
    if (NULL!=parList) {
        FreeAlertRecords(parList);
    }

    if (NULL!=rgtcThreads) {
        // clean up threads
        tscContext.nNextComputer=tscContext.nComputers; // indicate to stop
        for (nIndex=0; nIndex<nThreads; nIndex++) {
            if (NULL!=rgtcThreads[nIndex].hThread) {
                WaitForSingleObject(rgtcThreads[nIndex].hThread, INFINITE);
                CloseHandle(rgtcThreads[nIndex].hThread);
            }
        }
        LocalFree(rgtcThreads);
    }

    if (S_OK!=hr) {
        wprintf(L"Exiting with error 0x%08X\n", hr);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32tm\servicehost.cpp ===
//--------------------------------------------------------------------
// ServiceHost - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 9-9-99
//
// Stuff for hosting a service dll
//

#include "pch.h" // precompiled headers
#include "wchar.h"

//####################################################################
// module private

//--------------------------------------------------------------------
// module globals
MODULEPRIVATE HANDLE g_hServiceThread=NULL;
MODULEPRIVATE HANDLE g_hCtrlHandlerAvailEvent=NULL;
MODULEPRIVATE void * g_pvServiceContext=NULL;
MODULEPRIVATE LPHANDLER_FUNCTION_EX g_fnServiceCtrlHandler=NULL;
MODULEPRIVATE HWND g_hwServiceCtrlDlg=NULL;

MODULEPRIVATE SERVICE_STATUS g_ssLastStatus;

#define MYSERVICESTATUSHANDLE ((SERVICE_STATUS_HANDLE)3)

//--------------------------------------------------------------------
MODULEPRIVATE SERVICE_STATUS_HANDLE WINAPI W32TmRegisterServiceCtrlHandlerEx(const WCHAR * wszServiceName, LPHANDLER_FUNCTION_EX fnServiceCtrlHandler, void * pvContext) {
    DWORD dwWaitResult;

    DebugWPrintf3(L"RegisterServiceCtrlHandlerEx(0x%p, 0x%p, 0x%p) called.\n",wszServiceName, fnServiceCtrlHandler, pvContext);
    
    // make sure we haven't set this already
    _MyAssert(NULL!=g_hCtrlHandlerAvailEvent);
    dwWaitResult=WaitForSingleObject(g_hCtrlHandlerAvailEvent, 0);
    if (WAIT_FAILED==dwWaitResult) {
        _IgnoreLastError("WaitForSingleObject");
    }
    _MyAssert(WAIT_TIMEOUT==dwWaitResult);

    // check the service name, just for kicks
    _MyAssert(NULL!=wszServiceName);
    _MyAssert(NULL==wszServiceName || 0==wcscmp(wszServiceName, wszSERVICENAME));

    // save the context
    g_pvServiceContext=pvContext;

    // save the handler
    _MyAssert(NULL!=fnServiceCtrlHandler);
    g_fnServiceCtrlHandler=fnServiceCtrlHandler;

    if (!SetEvent(g_hCtrlHandlerAvailEvent)) {
        _IgnoreLastError("SetEvent");
    }

    return MYSERVICESTATUSHANDLE;
}

//--------------------------------------------------------------------
MODULEPRIVATE void MyAppendString(WCHAR ** pwszString, const WCHAR * wszAdd) {
    // calculate the length
    DWORD dwLen=1;
    if (NULL!=*pwszString) {
        dwLen+=wcslen(*pwszString);
    }
    dwLen+=wcslen(wszAdd);

    // allocate space
    WCHAR * wszResult;
    wszResult=(WCHAR *)LocalAlloc(LPTR, dwLen*sizeof(WCHAR));
    if (NULL==wszResult) {
        DebugWPrintf0(L"Out Of Memory in MyAppendString\n");
        return;
    }

    // build the new string
    if (NULL==*pwszString) {
        wszResult[0]=L'\0';
    } else {
        wcscpy(wszResult, *pwszString);
    }
    wcscat(wszResult, wszAdd);

    // replace the old one
    if (NULL!=*pwszString) {
        LocalFree(*pwszString);
    }
    *pwszString=wszResult;
}

//--------------------------------------------------------------------
MODULEPRIVATE void UpdateServiceCtrlDlg(void) {
    if (NULL!=g_hwServiceCtrlDlg) {
        WCHAR * wszDesc=NULL;


        //SERVICE_STATUS::dwServiceType
        MyAppendString(&wszDesc, L"Type: ");
        switch (g_ssLastStatus.dwServiceType&(~SERVICE_INTERACTIVE_PROCESS)) {
        case SERVICE_WIN32_OWN_PROCESS:
            MyAppendString(&wszDesc, L"SERVICE_WIN32_OWN_PROCESS");
            break;
        case SERVICE_WIN32_SHARE_PROCESS:
            MyAppendString(&wszDesc, L"SERVICE_WIN32_SHARE_PROCESS");
            break;
        case SERVICE_KERNEL_DRIVER:
            MyAppendString(&wszDesc, L"SERVICE_KERNEL_DRIVER");
            break;
        case SERVICE_FILE_SYSTEM_DRIVER:
            MyAppendString(&wszDesc, L"SERVICE_FILE_SYSTEM_DRIVER");
            break;
        default:
            MyAppendString(&wszDesc, L"(unknown)");
            break;
        }
        if (g_ssLastStatus.dwServiceType&SERVICE_INTERACTIVE_PROCESS) {
            MyAppendString(&wszDesc, L" | SERVICE_INTERACTIVE_PROCESS");
        }

        //SERVICE_STATUS::dwCurrentState,
        MyAppendString(&wszDesc, L"\r\nState: ");
        switch (g_ssLastStatus.dwCurrentState) {
        case SERVICE_STOPPED:
            MyAppendString(&wszDesc, L"SERVICE_STOPPED");
            break;
        case SERVICE_START_PENDING:
            MyAppendString(&wszDesc, L"SERVICE_START_PENDING");
            break;
        case SERVICE_STOP_PENDING:
            MyAppendString(&wszDesc, L"SERVICE_STOP_PENDING");
            break;
        case SERVICE_RUNNING:
            MyAppendString(&wszDesc, L"SERVICE_RUNNING");
            break;
        case SERVICE_CONTINUE_PENDING:
            MyAppendString(&wszDesc, L"SERVICE_CONTINUE_PENDING");
            break;
        case SERVICE_PAUSE_PENDING:
            MyAppendString(&wszDesc, L"SERVICE_PAUSE_PENDING");
            break;
        case SERVICE_PAUSED:
            MyAppendString(&wszDesc, L"SERVICE_PAUSED");
            break;
        default:
            MyAppendString(&wszDesc, L"(unknown)");
            break;
        }

        //SERVICE_STATUS::dwControlsAccepted,
        MyAppendString(&wszDesc, L"\r\nControls Accepted: ");
        EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_DEVICEEVENT), false);
        bool bFirst=true;
        //-----
        if (g_ssLastStatus.dwControlsAccepted&SERVICE_ACCEPT_STOP) {
            bFirst=false;
            MyAppendString(&wszDesc, L"SERVICE_ACCEPT_STOP");
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_STOP), true);
        } else {
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_STOP), false);
        }
        //-----
        if (g_ssLastStatus.dwControlsAccepted&SERVICE_ACCEPT_PAUSE_CONTINUE) {
            if (bFirst) {
                bFirst=false;
            } else {
                MyAppendString(&wszDesc, L" | ");
            }
            MyAppendString(&wszDesc, L"SERVICE_ACCEPT_PAUSE_CONTINUE");
            if (SERVICE_PAUSE_PENDING==g_ssLastStatus.dwCurrentState || SERVICE_PAUSED==g_ssLastStatus.dwCurrentState) {
                EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_PAUSE), false);
                EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_CONTINUE), true);
            } else {
                EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_PAUSE), true);
                EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_CONTINUE), false);
            }
        } else {
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_PAUSE), false);
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_CONTINUE), false);
        }
        //-----
        if (g_ssLastStatus.dwControlsAccepted&SERVICE_ACCEPT_SHUTDOWN) {
            if (bFirst) {
                bFirst=false;
            } else {
                MyAppendString(&wszDesc, L" | ");
            }
            MyAppendString(&wszDesc, L"SERVICE_ACCEPT_SHUTDOWN");
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_SHUTDOWN), true);
        } else {
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_SHUTDOWN), false);
        }
        //-----
        if (g_ssLastStatus.dwControlsAccepted&SERVICE_ACCEPT_PARAMCHANGE) {
            if (bFirst) {
                bFirst=false;
            } else {
                MyAppendString(&wszDesc, L" | ");
            }
            MyAppendString(&wszDesc, L"SERVICE_ACCEPT_PARAMCHANGE");
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_PARAMCHANGE), true);
        } else {
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_PARAMCHANGE), false);
        }
        //-----
        if (g_ssLastStatus.dwControlsAccepted&SERVICE_ACCEPT_NETBINDCHANGE) {
            if (bFirst) {
                bFirst=false;
            } else {
                MyAppendString(&wszDesc, L" | ");
            }
            MyAppendString(&wszDesc, L"SERVICE_ACCEPT_NETBINDCHANGE");
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_NETBINDADD), true);
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_NETBINDREMOVE), true);
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_NETBINDENABLE), true);
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_NETBINDDISABLE), true);
        } else {
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_NETBINDADD), false);
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_NETBINDREMOVE), false);
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_NETBINDENABLE), false);
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_NETBINDDISABLE), false);
        }
        //-----
        if (g_ssLastStatus.dwControlsAccepted&SERVICE_ACCEPT_HARDWAREPROFILECHANGE) {
            if (bFirst) {
                bFirst=false;
            } else {
                MyAppendString(&wszDesc, L" | ");
            }
            MyAppendString(&wszDesc, L"SERVICE_ACCEPT_HARDWAREPROFILECHANGE");
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_HARDWAREPROFILECHANGE), true);
        } else {
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_HARDWAREPROFILECHANGE), false);
        }
        //-----
        if (g_ssLastStatus.dwControlsAccepted&SERVICE_ACCEPT_POWEREVENT) {
            if (bFirst) {
                bFirst=false;
            } else {
                MyAppendString(&wszDesc, L" | ");
            }
            MyAppendString(&wszDesc, L"SERVICE_ACCEPT_POWEREVENT");
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_POWEREVENT), true);
        } else {
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_POWEREVENT), false);
        }
        //-----
        if (bFirst) {
            MyAppendString(&wszDesc, L"<none>");
        }
                
        //SERVICE_STATUS::dwWin32ExitCode,
        //SERVICE_STATUS::dwServiceSpecificExitCode,
        //SERVICE_STATUS::dwCheckPoint,
        //SERVICE_STATUS::dwWaitHint
        WCHAR wszBuf[256];
        _snwprintf(wszBuf, 256, L"\r\nWin32 Exit Code: 0x%08X\r\nService Specific Exit Code: 0x%08X\r\nCheckpoint: 0x%08X\r\nWait Hint: 0x%08X",
            g_ssLastStatus.dwWin32ExitCode,
            g_ssLastStatus.dwServiceSpecificExitCode,
            g_ssLastStatus.dwCheckPoint,
            g_ssLastStatus.dwWaitHint);
        MyAppendString(&wszDesc, wszBuf);

        SendDlgItemMessage(g_hwServiceCtrlDlg, IDC_STATUS, WM_SETTEXT, 0, (LPARAM) wszDesc);
        LocalFree(wszDesc);
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE BOOL WINAPI W32TmSetServiceStatus(SERVICE_STATUS_HANDLE ssh, SERVICE_STATUS * pss) {

    const WCHAR * wszState;
    switch (pss->dwCurrentState) {
    case SERVICE_STOPPED:
        wszState=L"SERVICE_STOPPED";
        break;
    case SERVICE_START_PENDING:
        wszState=L"SERVICE_START_PENDING";
        break;
    case SERVICE_STOP_PENDING:
        wszState=L"SERVICE_STOP_PENDING";
        break;
    case SERVICE_RUNNING:
        wszState=L"SERVICE_RUNNING";
        break;
    case SERVICE_CONTINUE_PENDING:
        wszState=L"SERVICE_CONTINUE_PENDING";
        break;
    case SERVICE_PAUSE_PENDING:
        wszState=L"SERVICE_PAUSE_PENDING";
        break;
    case SERVICE_PAUSED:
        wszState=L"SERVICE_PAUSED";
        break;
    default:
        wszState=L"(unknown)";
        break;
    }
    switch (pss->dwCurrentState) {
    case SERVICE_STOPPED:
        DebugWPrintf4(L"SetServiceStatus called; %s Accept:0x%08X Ret:0x%08X(0x%08X)\n",
            wszState,
            pss->dwControlsAccepted,
            pss->dwWin32ExitCode,
            pss->dwServiceSpecificExitCode,
                );
        break;
    case SERVICE_START_PENDING:
    case SERVICE_STOP_PENDING:
    case SERVICE_PAUSE_PENDING:
    case SERVICE_CONTINUE_PENDING:
        DebugWPrintf4(L"SetServiceStatus called; %s Accept:0x%08X ChkPt:0x%08X Wait:0x%08X\n",
            wszState,
            pss->dwControlsAccepted,
            pss->dwCheckPoint,
            pss->dwWaitHint
                );
        break;
    case SERVICE_RUNNING:
    case SERVICE_PAUSED:
    default:
        DebugWPrintf2(L"SetServiceStatus called; %s Accept:0x%08X\n",
            wszState,
            pss->dwControlsAccepted
                );
        break;
     }

    _MyAssert(MYSERVICESTATUSHANDLE==ssh);

    memcpy(&g_ssLastStatus, pss, sizeof(SERVICE_STATUS));
    UpdateServiceCtrlDlg();
    return true;
}

//--------------------------------------------------------------------
MODULEPRIVATE DWORD WINAPI MyServiceThread(void * pvServiceMain) {
    DebugWPrintf0(L"Starting service thread.\n");
    ((LPSERVICE_MAIN_FUNCTION)pvServiceMain)(0, NULL);
    DebugWPrintf0(L"Service thread exited.\n"); // service may still be running!
    return S_OK;
}

//--------------------------------------------------------------------
MODULEPRIVATE INT_PTR CALLBACK ServiceCtrlDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    DWORD dwError;
    HRESULT hrExit;

    if (NULL==g_hwServiceCtrlDlg) {
        g_hwServiceCtrlDlg=hwndDlg;
    }

    switch (uMsg) {

    case WM_INITDIALOG:
        UpdateServiceCtrlDlg();
        return true;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDCANCEL:
            if (g_ssLastStatus.dwCurrentState!=SERVICE_STOPPED) {
                hrExit=HRESULT_FROM_WIN32(ERROR_CANCELLED);
                DebugWPrintf1(L"Aborting with error 0x%08X\n", hrExit);
            } else {
                hrExit=g_ssLastStatus.dwServiceSpecificExitCode;
                DebugWPrintf1(L"Exiting with service return value 0x%08X\n", hrExit);
            }
            EndDialog(hwndDlg, hrExit); 
            return true;
        case IDC_SC_STOP:
            DebugWPrintf0(L"Passing SERVICE_CONTROL_STOP to service's control handler.\n");
            dwError=g_fnServiceCtrlHandler(SERVICE_CONTROL_STOP, NULL, NULL, g_pvServiceContext);
            DebugWPrintf1(L"Service's control handler returns 0x%08X.\n", dwError);
            return false;
        case IDC_SC_PAUSE:
            DebugWPrintf0(L"Passing SERVICE_CONTROL_PAUSE to service's control handler.\n");
            dwError=g_fnServiceCtrlHandler(SERVICE_CONTROL_PAUSE, NULL, NULL, g_pvServiceContext);
            DebugWPrintf1(L"Service's control handler returns 0x%08X.\n", dwError);
            return false;
        case IDC_SC_CONTINUE:
            DebugWPrintf0(L"Passing SERVICE_CONTROL_CONTINUE to service's control handler.\n");
            dwError=g_fnServiceCtrlHandler(SERVICE_CONTROL_CONTINUE, NULL, NULL, g_pvServiceContext);
            DebugWPrintf1(L"Service's control handler returns 0x%08X.\n", dwError);
            return false;
        case IDC_SC_INTERROGATE:
            DebugWPrintf0(L"Passing SERVICE_CONTROL_INTERROGATE to service's control handler.\n");
            dwError=g_fnServiceCtrlHandler(SERVICE_CONTROL_INTERROGATE, NULL, NULL, g_pvServiceContext);
            DebugWPrintf1(L"Service's control handler returns 0x%08X.\n", dwError);
            return false;
        case IDC_SC_SHUTDOWN:
            DebugWPrintf0(L"IDC_SC_SHUTDOWN\n");
            return false;
        case IDC_SC_PARAMCHANGE:
            DebugWPrintf0(L"Passing SERVICE_CONTROL_PARAMCHANGE to service's control handler.\n");
            dwError=g_fnServiceCtrlHandler(SERVICE_CONTROL_PARAMCHANGE, NULL, NULL, g_pvServiceContext);
            DebugWPrintf1(L"Service's control handler returns 0x%08X.\n", dwError);
            return false;
        case IDC_SC_NETBINDADD:
            DebugWPrintf0(L"Passing SERVICE_CONTROL_NETBINDADD to service's control handler.\n");
            dwError=g_fnServiceCtrlHandler(SERVICE_CONTROL_NETBINDADD, NULL, NULL, g_pvServiceContext);
            DebugWPrintf1(L"Service's control handler returns 0x%08X.\n", dwError);
            return false;
        case IDC_SC_NETBINDREMOVE:
            DebugWPrintf0(L"Passing SERVICE_CONTROL_NETBINDREMOVE to service's control handler.\n");
            dwError=g_fnServiceCtrlHandler(SERVICE_CONTROL_NETBINDREMOVE, NULL, NULL, g_pvServiceContext);
            DebugWPrintf1(L"Service's control handler returns 0x%08X.\n", dwError);
            return false;
        case IDC_SC_NETBINDENABLE:
            DebugWPrintf0(L"Passing SERVICE_CONTROL_NETBINDENABLE to service's control handler.\n");
            dwError=g_fnServiceCtrlHandler(SERVICE_CONTROL_NETBINDENABLE, NULL, NULL, g_pvServiceContext);
            DebugWPrintf1(L"Service's control handler returns 0x%08X.\n", dwError);
            return false;
        case IDC_SC_NETBINDDISABLE:
            DebugWPrintf0(L"Passing SERVICE_CONTROL_NETBINDDISABLE to service's control handler.\n");
            dwError=g_fnServiceCtrlHandler(SERVICE_CONTROL_NETBINDDISABLE, NULL, NULL, g_pvServiceContext);
            DebugWPrintf1(L"Service's control handler returns 0x%08X.\n", dwError);
            return false;
        case IDC_SC_DEVICEEVENT:
            DebugWPrintf0(L"IDC_SC_DEVICEEVENT NYI\n");
            return false;
        case IDC_SC_HARDWAREPROFILECHANGE:
            DebugWPrintf0(L"IDC_SC_HARDWAREPROFILECHANGE NYI\n");
            return false;
        case IDC_SC_POWEREVENT:
            DebugWPrintf0(L"IDC_SC_POWEREVENT NYI\n");
            return false;
        default:
            //DebugWPrintf2(L"Unknown WM_COMMAND: wParam:0x%08X  lParam:0x%08X\n", wParam, lParam);
            return false; // unhandled
        }
        return false; // unhandled
    // end case WM_COMMAND

    default:
        return false; // unhandled
    }

    return false; // unhandled
}
 
//--------------------------------------------------------------------
MODULEPRIVATE HRESULT MyServiceCtrlDispatcher(LPSERVICE_MAIN_FUNCTION fnW32TmServiceMain) {
    HRESULT hr;
    DWORD dwThreadID;
    DWORD dwWaitResult;
    INT_PTR nDialogError;

    g_hCtrlHandlerAvailEvent=CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL==g_hCtrlHandlerAvailEvent) {
        _JumpLastError(hr, error, "CreateEvent");
    }

    // 'start' the service
    g_hServiceThread=CreateThread(NULL, 0, MyServiceThread, (void *)fnW32TmServiceMain, 0, &dwThreadID);
    if (NULL==g_hServiceThread) {
        _JumpLastError(hr, error, "CreateThread");
    }

    DebugWPrintf0(L"Waiting for service to register ctrl handler.\n");
    _Verify(WAIT_FAILED!=WaitForSingleObject(g_hCtrlHandlerAvailEvent, INFINITE), hr, error);

    // do dialog box
    nDialogError=DialogBox(GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_SERVICECTRL), NULL, ServiceCtrlDialogProc);
    if (-1==nDialogError) {
        _JumpLastError(hr, error, "DialogBox");
    }
    hr=(HRESULT)nDialogError;
    _JumpIfError(hr, error, "DialogBox");

    // confirm that the thread exited
    dwWaitResult=WaitForSingleObject(g_hServiceThread, 0);
    if (WAIT_FAILED==dwWaitResult) {
        _IgnoreLastError("WaitForSingleObject");
    }
    _Verify(WAIT_TIMEOUT!=dwWaitResult, hr, error);
    
    // When this exits, everything ends.
    hr=S_OK;
error:
    if (NULL!=g_hServiceThread) {
        CloseHandle(g_hServiceThread);
        g_hServiceThread=NULL;
    }
    if (NULL!=g_hCtrlHandlerAvailEvent) {
        CloseHandle(g_hCtrlHandlerAvailEvent);
        g_hCtrlHandlerAvailEvent=NULL;
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetDllName(WCHAR ** pwszDllName) {
    HRESULT hr;
    DWORD dwError;
    DWORD dwSize;
    DWORD dwType;

    // must be cleaned up
    HKEY hkParams=NULL;
    WCHAR * wszDllName=NULL;
    WCHAR * wszDllExpandedName=NULL;

    // get our config key
    dwError=RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyParameters, 0, KEY_READ, &hkParams);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegOpenKeyEx", wszW32TimeRegKeyParameters);
    }

    // read the value containing the DLL name
    dwSize=0;
    dwError=RegQueryValueEx(hkParams, wszW32TimeRegValueServiceDll, NULL, &dwType, NULL, &dwSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegQueryValueEx", wszW32TimeRegValueServiceDll);
    } 
    _Verify(REG_EXPAND_SZ==dwType, hr, error);
    wszDllName=(WCHAR *)LocalAlloc(LPTR, dwSize);
    _JumpIfOutOfMemory(hr, error, wszDllName);
    dwError=RegQueryValueEx(hkParams, wszW32TimeRegValueServiceDll, NULL, &dwType, (BYTE *)wszDllName, &dwSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegQueryValueEx", wszW32TimeRegValueServiceDll);
    }

    // expand environment string
    dwSize=ExpandEnvironmentStrings(wszDllName, NULL, 0);
    if (0==dwSize) {
        _JumpLastError(hr, error, "ExpandEnvironmentStrings");
    }
    wszDllExpandedName=(WCHAR *)LocalAlloc(LPTR, dwSize*sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, wszDllExpandedName);
    dwSize=ExpandEnvironmentStrings(wszDllName, wszDllExpandedName, dwSize);
    if (0==dwSize) {
        _JumpLastError(hr, error, "ExpandEnvironmentStrings");
    }

    // success
    *pwszDllName=wszDllExpandedName;
    wszDllExpandedName=NULL;

error:
    if (NULL!=wszDllExpandedName) {
        LocalFree(wszDllExpandedName);
    }
    if (NULL!=wszDllName) {
        LocalFree(wszDllName);
    }
    if (NULL!=hkParams) {
        RegCloseKey(hkParams);
    }
    return hr;
}

//####################################################################
// module public

//--------------------------------------------------------------------
// run W32Time as a real service under the SCM
HRESULT RunAsService(void) {
    HRESULT hr;
    SERVICE_STATUS_HANDLE (WINAPI ** pfnW32TmRegisterServiceCtrlHandlerEx)(LPCWSTR, LPHANDLER_FUNCTION_EX, LPVOID);
    BOOL (WINAPI ** pfnW32TmSetServiceStatus)(SERVICE_STATUS_HANDLE, LPSERVICE_STATUS);

    SERVICE_TABLE_ENTRY rgsteDispatchTable[]= { 
        { wszSERVICENAME, NULL}, 
        {NULL, NULL} 
    }; 

    // must be cleaned up
    HINSTANCE hW32Time=NULL;
    WCHAR * wszDllName=NULL;

    // load the library
    hr=GetDllName(&wszDllName);
    _JumpIfError(hr, error, "GetDllName");
    hW32Time=LoadLibrary(wszDllName);
    if (NULL==hW32Time) {
        _JumpLastError(hr, error, "LoadLibrary");
    }

    // get the entry point
    rgsteDispatchTable[0].lpServiceProc=(LPSERVICE_MAIN_FUNCTION)GetProcAddress(hW32Time, "W32TmServiceMain");
    if (NULL==rgsteDispatchTable[0].lpServiceProc) {
        _JumpLastErrorStr(hr, error, "GetProcAddress", L"W32TmServiceMain");
    }

    // adjust the function pointers
    pfnW32TmRegisterServiceCtrlHandlerEx=(SERVICE_STATUS_HANDLE (WINAPI **)(LPCWSTR, LPHANDLER_FUNCTION_EX, LPVOID))GetProcAddress(hW32Time, "fnW32TmRegisterServiceCtrlHandlerEx");
    if (NULL==pfnW32TmRegisterServiceCtrlHandlerEx) {
        _JumpLastErrorStr(hr, error, "GetProcAddress", L"fnW32TmRegisterServiceCtrlHandlerEx");
    }
    *pfnW32TmRegisterServiceCtrlHandlerEx=RegisterServiceCtrlHandlerExW;

    pfnW32TmSetServiceStatus=(BOOL (WINAPI **)(SERVICE_STATUS_HANDLE, LPSERVICE_STATUS))GetProcAddress(hW32Time, "fnW32TmSetServiceStatus");
    if (NULL==pfnW32TmSetServiceStatus) {
        _JumpLastErrorStr(hr, error, "GetProcAddress", L"fnW32TmSetServiceStatus");
    }
    *pfnW32TmSetServiceStatus=SetServiceStatus;

    // This thread becomes the service control dispatcher.
    if (!StartServiceCtrlDispatcher(rgsteDispatchTable)) {
        _JumpLastError(hr, error, "StartServiceCtrlDispatcher");
    }

    // service is stopped.
    hr=S_OK;
error:
    if (NULL!=wszDllName) {
        LocalFree(wszDllName);
    }
    if (NULL!=hW32Time) {
        FreeLibrary(hW32Time);
    }
    if (FAILED(hr)) {
        WCHAR * wszError;
        HRESULT hr2=GetSystemErrorString(hr, &wszError);
        if (FAILED(hr2)) {
            _IgnoreError(hr2, "GetSystemErrorString");
        } else {
            LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
            LocalFree(wszError);
        }
    }
    return hr;
}

//--------------------------------------------------------------------
// pretend to run as a service for easier debugging
HRESULT RunAsTestService(void) {
    HRESULT hr;
    LPSERVICE_MAIN_FUNCTION fnW32TmServiceMain;
    SERVICE_STATUS_HANDLE (WINAPI ** pfnW32TmRegisterServiceCtrlHandlerEx)(LPCWSTR, LPHANDLER_FUNCTION_EX, LPVOID);
    BOOL (WINAPI ** pfnW32TmSetServiceStatus)(SERVICE_STATUS_HANDLE, LPSERVICE_STATUS);

    // must be cleaned up
    HINSTANCE hW32Time=NULL;
    WCHAR * wszDllName=NULL;

    // load the library
    hr=GetDllName(&wszDllName);
    _JumpIfError(hr, error, "GetDllName");
    hW32Time=LoadLibrary(wszDllName);
    if (NULL==hW32Time) {
        _JumpLastError(hr, error, "LoadLibrary");
    }

    // get the entry point
    fnW32TmServiceMain=(LPSERVICE_MAIN_FUNCTION)GetProcAddress(hW32Time, "W32TmServiceMain");
    if (NULL==fnW32TmServiceMain) {
        _JumpLastErrorStr(hr, error, "GetProcAddress", L"W32TmServiceMain");
    }

    // adjust the function pointers
    pfnW32TmRegisterServiceCtrlHandlerEx=(SERVICE_STATUS_HANDLE (WINAPI **)(LPCWSTR, LPHANDLER_FUNCTION_EX, LPVOID))GetProcAddress(hW32Time, "fnW32TmRegisterServiceCtrlHandlerEx");
    if (NULL==pfnW32TmRegisterServiceCtrlHandlerEx) {
        _JumpLastErrorStr(hr, error, "GetProcAddress", L"fnW32TmRegisterServiceCtrlHandlerEx");
    }
    *pfnW32TmRegisterServiceCtrlHandlerEx=W32TmRegisterServiceCtrlHandlerEx;

    // adjust the function pointers
    pfnW32TmSetServiceStatus=(BOOL (WINAPI **)(SERVICE_STATUS_HANDLE, LPSERVICE_STATUS))GetProcAddress(hW32Time, "fnW32TmSetServiceStatus");
    if (NULL==pfnW32TmSetServiceStatus) {
        _JumpLastErrorStr(hr, error, "GetProcAddress", L"fnW32TmSetServiceStatus");
    }
    *pfnW32TmSetServiceStatus=W32TmSetServiceStatus;

    // This thread becomes the service control dispatcher.
    hr=MyServiceCtrlDispatcher(fnW32TmServiceMain);
    _JumpIfError(hr, error, "MyServiceCtrlDispatcher");

    // service is stopped.
    hr=S_OK;
error:
    if (NULL!=wszDllName) {
        LocalFree(wszDllName);
    }
    if (NULL!=hW32Time) {
        FreeLibrary(hW32Time);
    }
    if (FAILED(hr)) {
        WCHAR * wszError;
        HRESULT hr2=GetSystemErrorString(hr, &wszError);
        if (FAILED(hr2)) {
            _IgnoreError(hr2, "GetSystemErrorString");
        } else {
            LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
            LocalFree(wszError);
        }
    }
    return hr;
}

//--------------------------------------------------------------------
HRESULT RegisterDll(void) {
    HRESULT hr;
    HRESULT (__stdcall * pfnDllRegisterServer)(void);

    // must be cleaned up
    HINSTANCE hW32Time=NULL;

    // load the library
    hW32Time=LoadLibrary(wszDLLNAME);
    if (NULL==hW32Time) {
        _JumpLastError(hr, error, "LoadLibrary");
    }

    // get the entry point
    pfnDllRegisterServer=(HRESULT (__stdcall *) (void))GetProcAddress(hW32Time, "DllRegisterServer");
    if (NULL==pfnDllRegisterServer) {
        _JumpLastErrorStr(hr, error, "GetProcAddress", L"DllRegisterServer");
    }

    hr=pfnDllRegisterServer();
    _JumpIfError(hr, error, "DllRegisterServer");

    LocalizedWPrintfCR(IDS_W32TM_STATUS_REGISTER_SUCCESSFUL);
    hr=S_OK;
error:
    if (NULL!=hW32Time) {
        FreeLibrary(hW32Time);
    }
    if (FAILED(hr)) {
        WCHAR * wszError;
        HRESULT hr2=GetSystemErrorString(hr, &wszError);
        if (FAILED(hr2)) {
            _IgnoreError(hr2, "GetSystemErrorString");
        } else {
            LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
            LocalFree(wszError);
        }
    }
    return hr;

};

//--------------------------------------------------------------------
HRESULT UnregisterDll(void) {
    HRESULT hr;
    HRESULT (__stdcall * pfnDllUnregisterServer)(void);

    // must be cleaned up
    HINSTANCE hW32Time=NULL;

    // load the library
    hW32Time=LoadLibrary(wszDLLNAME);
    if (NULL==hW32Time) {
        _JumpLastError(hr, error, "LoadLibrary");
    }

    // get the entry point
    pfnDllUnregisterServer=(HRESULT (__stdcall *) (void))GetProcAddress(hW32Time, "DllUnregisterServer");
    if (NULL==pfnDllUnregisterServer) {
        _JumpLastErrorStr(hr, error, "GetProcAddress", L"DllUnregisterServer");
    }

    hr=pfnDllUnregisterServer();
    _JumpIfError(hr, error, "DllUnregisterServer");

    LocalizedWPrintfCR(IDS_W32TM_STATUS_REGISTER_SUCCESSFUL);
    hr=S_OK;
error:
    if (NULL!=hW32Time) {
        FreeLibrary(hW32Time);
    }
    if (FAILED(hr)) {
        WCHAR * wszError;
        HRESULT hr2=GetSystemErrorString(hr, &wszError);
        if (FAILED(hr2)) {
            _IgnoreError(hr2, "GetSystemErrorString");
        } else {
            LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
            LocalFree(wszError);
        }
    }
    return hr;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32tm\timemonitor.h ===
//--------------------------------------------------------------------
// TimeMonitor - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 10-4-99
//
// Monitor time servers
//

#ifndef TIME_MONITOR_H
#define TIME_MONITOR_H

// forward decalrations
struct CmdArgs;

void PrintHelpTimeMonitor(void);
HRESULT TimeMonitor(CmdArgs * pca);

#endif //TIME_MONITOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32tm\w32tm.cpp ===
//--------------------------------------------------------------------
// w32tm - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 9-8-99
//
// Command line utility
//

#include "pch.h" // precompiled headers


//####################################################################
// module private

HINSTANCE g_hThisModule = NULL;

//--------------------------------------------------------------------
MODULEPRIVATE void PrintHelp(void) {
    UINT idsText[] = { 
        IDS_W32TM_GENERALHELP_LINE1, 
        IDS_W32TM_GENERALHELP_LINE2, 
        IDS_W32TM_GENERALHELP_LINE3, 
        IDS_W32TM_GENERALHELP_LINE4, 
        IDS_W32TM_GENERALHELP_LINE5, 
        IDS_W32TM_GENERALHELP_LINE6, 
        IDS_W32TM_GENERALHELP_LINE7 
    };  

    for (int n=0; n<ARRAYSIZE(idsText); n++)
        LocalizedWPrintf(idsText[n]); 

    PrintHelpTimeMonitor();
    PrintHelpOtherCmds();
}

//####################################################################
// module public

//--------------------------------------------------------------------
// If we are running from the command line, business as usual.
// If we are running under SCM, this is our control dispatcher thread
//  and we need to hook up to the SCM asap.
extern "C" int WINAPI WinMain
(HINSTANCE   hinstExe, 
 HINSTANCE   hinstExePrev, 
 LPSTR       pszCommandLine,
 int         nCommandShow)
{
    g_hThisModule = hinstExe; 

    HRESULT hr;
    CmdArgs caArgs;
    int      nArgs     = 0; 
    WCHAR  **rgwszArgs = NULL; 

    hr = InitializeConsoleOutput(); 
    _JumpIfError(hr, error, "InitializeConsoleOutput"); 

    rgwszArgs = CommandLineToArgvW(GetCommandLineW(), &nArgs);
    if (nArgs < 0 || NULL == rgwszArgs) {
        _JumpError(HRESULT_FROM_WIN32(GetLastError()), error, "GetCommandLineW"); 
    }

    // must be cleaned up
    DebugWPrintf0(L""); // force init of debug window

    // analyze args
    caArgs.nArgs=nArgs;
    caArgs.nNextArg=1;
    caArgs.rgwszArgs=rgwszArgs;

    // check for help command
    if (true==CheckNextArg(&caArgs, L"?", NULL) || caArgs.nNextArg==caArgs.nArgs) {
        PrintHelp();

    // check for service command
    } else if (true==CheckNextArg(&caArgs, L"service", NULL)) {
        hr=VerifyAllArgsUsed(&caArgs);
        _JumpIfError(hr, error, "VerifyAllArgsUsed");

        hr=RunAsService();
        _JumpIfError(hr, error, "RunAsService");

    // check for test command
    } else if (true==CheckNextArg(&caArgs, L"testservice", NULL)) {
        hr=VerifyAllArgsUsed(&caArgs);
        _JumpIfError(hr, error, "VerifyAllArgsUsed");

        hr=RunAsTestService();
        _JumpIfError(hr, error, "RunAsTestService");
       
    // check for monitor command
    } else if (true==CheckNextArg(&caArgs, L"monitor", NULL)) {
        hr=TimeMonitor(&caArgs);
        _JumpIfError(hr, error, "TimeMonitor");

    // check for register command
    } else if (true==CheckNextArg(&caArgs, L"register", NULL)) {
        hr=VerifyAllArgsUsed(&caArgs);
        _JumpIfError(hr, error, "VerifyAllArgsUsed");

        hr=RegisterDll();
        _JumpIfError(hr, error, "RegisterDll");

    // check for unregister command
    } else if (true==CheckNextArg(&caArgs, L"unregister", NULL)) {
        hr=VerifyAllArgsUsed(&caArgs);
        _JumpIfError(hr, error, "VerifyAllArgsUsed");

        hr=UnregisterDll();
        _JumpIfError(hr, error, "UnregisterDll");

    // check for sysexpr command
    } else if (true==CheckNextArg(&caArgs, L"sysexpr", NULL)) {
        hr=SysExpr(&caArgs);
        _JumpIfError(hr, error, "SysExpr");

    // check for ntte command
    } else if (true==CheckNextArg(&caArgs, L"ntte", NULL)) {
        hr=PrintNtte(&caArgs);
        _JumpIfError(hr, error, "PrintNtte");

    // check for ntte command
    } else if (true==CheckNextArg(&caArgs, L"ntpte", NULL)) {
        hr=PrintNtpte(&caArgs);
        _JumpIfError(hr, error, "PrintNtpte");

    // check for resync command
    } else if (true==CheckNextArg(&caArgs, L"resync", NULL)) {
        hr=ResyncCommand(&caArgs);
        _JumpIfError(hr, error, "ResyncCommand");

    // check for stripchart command
    } else if (true==CheckNextArg(&caArgs, L"stripchart", NULL)) {
        hr=Stripchart(&caArgs);
        _JumpIfError(hr, error, "Stripchart");

    // check for config command
    } else if (true==CheckNextArg(&caArgs, L"config", NULL)
        || true==CheckNextArg(&caArgs, L"configure", NULL)) {
        hr=Config(&caArgs);
        _JumpIfError(hr, error, "Config");

    // check for testif command
    } else if (true==CheckNextArg(&caArgs, L"testif", NULL)) {
        hr=TestInterface(&caArgs);
        _JumpIfError(hr, error, "TestInterface");

    // check for tz command
    } else if (true==CheckNextArg(&caArgs, L"tz", NULL)) {
        hr=ShowTimeZone(&caArgs);
        _JumpIfError(hr, error, "ShowTimeZone");

    // dump configuration information in registry:
    } else if (true==CheckNextArg(&caArgs, L"dumpreg", NULL)) { 
        hr=DumpReg(&caArgs);
        _JumpIfError(hr, error, "DumpReg");

    // command is unknown
    } else {
        wprintf(L"The command %s is unknown.\n", caArgs.rgwszArgs[caArgs.nNextArg]);
        hr=E_INVALIDARG;
        _JumpError(hr, error, "(command line processing)");
    }

    hr=S_OK;
error:
    DebugWPrintfTerminate();
    return hr;  
}

void __cdecl SeTransFunc(unsigned int u, EXCEPTION_POINTERS* pExp) { 
    throw SeException(u); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\w32time\w32tm\w32tmrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by w32tm.rc
//

#define IDD_SERVICECTRL                 101

#define IDC_STATUS                      1001
#define IDC_SC_STOP                     1002
#define IDC_SC_PAUSE                    1003
#define IDC_SC_CONTINUE                 1004
#define IDC_SC_INTERROGATE              1005
#define IDC_SC_PARAMCHANGE              1006
#define IDC_SC_NETBINDADD               1007
#define IDC_SC_NETBINDREMOVE            1008
#define IDC_SC_NETBINDENABLE            1009
#define IDC_SC_NETBINDDISABLE           1010
#define IDC_SC_DEVICEEVENT              1011
#define IDC_SC_HARDWAREPROFILECHANGE    1012
#define IDC_SC_POWEREVENT               1013
#define IDC_SC_SHUTDOWN                 1014

#define IDS_W32TM_GENERALHELP_LINE1                              1001 
#define IDS_W32TM_GENERALHELP_LINE2                              1002
#define IDS_W32TM_GENERALHELP_LINE3                              1003
#define IDS_W32TM_GENERALHELP_LINE4                              1004
#define IDS_W32TM_GENERALHELP_LINE5                              1005
#define IDS_W32TM_GENERALHELP_LINE6                              1006
#define IDS_W32TM_GENERALHELP_LINE7                              1007
#define IDS_W32TM_GENERALHELP_LINE8                              1008
#define IDS_W32TM_GENERALHELP_LINE9                              1009
#define IDS_W32TM_GENERALHELP_LINE10                             1010

#define IDS_W32TM_MONITORHELP_LINE1                              1101
#define IDS_W32TM_MONITORHELP_LINE2                              1102
#define IDS_W32TM_MONITORHELP_LINE3                              1103
#define IDS_W32TM_MONITORHELP_LINE4                              1104
#define IDS_W32TM_MONITORHELP_LINE5                              1105
#define IDS_W32TM_MONITORHELP_LINE6                              1106
#define IDS_W32TM_MONITORHELP_LINE7                              1107
#define IDS_W32TM_MONITORHELP_LINE8                              1108
#define IDS_W32TM_MONITORHELP_LINE9                              1109
#define IDS_W32TM_MONITORHELP_LINE10                             1110
#define IDS_W32TM_MONITORHELP_LINE11                             1111
#define IDS_W32TM_MONITORHELP_LINE12                             1112
#define IDS_W32TM_MONITORHELP_LINE13                             1113
#define IDS_W32TM_MONITORHELP_LINE14                             1114
#define IDS_W32TM_MONITORHELP_LINE15                             1115
#define IDS_W32TM_MONITORHELP_LINE16                             1116
#define IDS_W32TM_MONITORHELP_LINE17                             1117
#define IDS_W32TM_MONITORHELP_LINE18                             1118
#define IDS_W32TM_MONITORHELP_LINE19                             1119
#define IDS_W32TM_MONITORHELP_LINE20                             1120
#define IDS_W32TM_MONITORHELP_LINE21                             1121
#define IDS_W32TM_MONITORHELP_LINE22                             1122
#define IDS_W32TM_MONITORHELP_LINE23                             1123
#define IDS_W32TM_MONITORHELP_LINE24                             1124
#define IDS_W32TM_MONITORHELP_LINE25                             1125

#define IDS_W32TM_OTHERCMDHELP_LINE1                             1201                          
#define IDS_W32TM_OTHERCMDHELP_LINE2                             1202
#define IDS_W32TM_OTHERCMDHELP_LINE3                             1203
#define IDS_W32TM_OTHERCMDHELP_LINE4                             1204
#define IDS_W32TM_OTHERCMDHELP_LINE5                             1205
#define IDS_W32TM_OTHERCMDHELP_LINE6                             1206
#define IDS_W32TM_OTHERCMDHELP_LINE7                             1207
#define IDS_W32TM_OTHERCMDHELP_LINE8                             1208
#define IDS_W32TM_OTHERCMDHELP_LINE9                             1209
#define IDS_W32TM_OTHERCMDHELP_LINE10                            1210
#define IDS_W32TM_OTHERCMDHELP_LINE11                            1211
#define IDS_W32TM_OTHERCMDHELP_LINE12                            1212
#define IDS_W32TM_OTHERCMDHELP_LINE13                            1213
#define IDS_W32TM_OTHERCMDHELP_LINE14                            1214
#define IDS_W32TM_OTHERCMDHELP_LINE15                            1215
#define IDS_W32TM_OTHERCMDHELP_LINE16                            1216
#define IDS_W32TM_OTHERCMDHELP_LINE17                            1217
#define IDS_W32TM_OTHERCMDHELP_LINE18                            1218
#define IDS_W32TM_OTHERCMDHELP_LINE19                            1219
#define IDS_W32TM_OTHERCMDHELP_LINE20                            1220
#define IDS_W32TM_OTHERCMDHELP_LINE21                            1221
#define IDS_W32TM_OTHERCMDHELP_LINE22                            1222
#define IDS_W32TM_OTHERCMDHELP_LINE23                            1223
#define IDS_W32TM_OTHERCMDHELP_LINE24                            1224
#define IDS_W32TM_OTHERCMDHELP_LINE25                            1225
#define IDS_W32TM_OTHERCMDHELP_LINE26                            1226
#define IDS_W32TM_OTHERCMDHELP_LINE27                            1227
#define IDS_W32TM_OTHERCMDHELP_LINE28                            1228
#define IDS_W32TM_OTHERCMDHELP_LINE29                            1229
#define IDS_W32TM_OTHERCMDHELP_LINE30                            1230
#define IDS_W32TM_OTHERCMDHELP_LINE31                            1231
#define IDS_W32TM_OTHERCMDHELP_LINE32                            1232
#define IDS_W32TM_OTHERCMDHELP_LINE33                            1233
#define IDS_W32TM_OTHERCMDHELP_LINE34                            1234
#define IDS_W32TM_OTHERCMDHELP_LINE35                            1235
#define IDS_W32TM_OTHERCMDHELP_LINE36                            1236
#define IDS_W32TM_OTHERCMDHELP_LINE37                            1237
#define IDS_W32TM_OTHERCMDHELP_LINE38                            1238
#define IDS_W32TM_OTHERCMDHELP_LINE39                            1239
#define IDS_W32TM_OTHERCMDHELP_LINE40                            1240
#define IDS_W32TM_OTHERCMDHELP_LINE41                            1241
#define IDS_W32TM_OTHERCMDHELP_LINE42                            1242
#define IDS_W32TM_OTHERCMDHELP_LINE43                            1243
#define IDS_W32TM_OTHERCMDHELP_LINE44                            1244
#define IDS_W32TM_OTHERCMDHELP_LINE45                            1245
#define IDS_W32TM_OTHERCMDHELP_LINE46                            1246
#define IDS_W32TM_OTHERCMDHELP_LINE47                            1247
#define IDS_W32TM_OTHERCMDHELP_LINE48                            1248
#define IDS_W32TM_OTHERCMDHELP_LINE49                            1249
#define IDS_W32TM_OTHERCMDHELP_LINE50                            1250
#define IDS_W32TM_OTHERCMDHELP_LINE51                            1251
#define IDS_W32TM_OTHERCMDHELP_LINE52                            1252
#define IDS_W32TM_OTHERCMDHELP_LINE53                            1253
#define IDS_W32TM_OTHERCMDHELP_LINE54                            1254
#define IDS_W32TM_OTHERCMDHELP_LINE55                            1255
#define IDS_W32TM_OTHERCMDHELP_LINE56                            1256
#define IDS_W32TM_OTHERCMDHELP_LINE57                            1257
#define IDS_W32TM_OTHERCMDHELP_LINE58                            1258
#define IDS_W32TM_OTHERCMDHELP_LINE59                            1259
#define IDS_W32TM_OTHERCMDHELP_LINE60                            1260
#define IDS_W32TM_OTHERCMDHELP_LINE61                            1261
#define IDS_W32TM_OTHERCMDHELP_LINE62                            1262
#define IDS_W32TM_OTHERCMDHELP_LINE63                            1263
#define IDS_W32TM_OTHERCMDHELP_LINE64                            1264
#define IDS_W32TM_OTHERCMDHELP_LINE65                            1265
#define IDS_W32TM_OTHERCMDHELP_LINE66                            1266
#define IDS_W32TM_OTHERCMDHELP_LINE67                            1267
#define IDS_W32TM_OTHERCMDHELP_LINE68                            1268
#define IDS_W32TM_OTHERCMDHELP_LINE69                            1269
#define IDS_W32TM_OTHERCMDHELP_LINE70                            1270
#define IDS_W32TM_OTHERCMDHELP_LINE71                            1271
#define IDS_W32TM_OTHERCMDHELP_LINE72                            1272
#define IDS_W32TM_OTHERCMDHELP_LINE73                            1273
#define IDS_W32TM_OTHERCMDHELP_LINE74                            1274
#define IDS_W32TM_OTHERCMDHELP_LINE75                            1275

#define IDS_W32TM_ERRORRESYNC_NO_TIME_DATA                       1300
#define IDS_W32TM_ERRORRESYNC_STALE_DATA                         1301
#define IDS_W32TM_ERRORRESYNC_SHUTTING_DOWN                      1302
#define IDS_W32TM_ERRORRESYNC_CHANGE_TOO_BIG                     1303
 
#define IDS_W32TM_ERRORGENERAL_COMMAND_SUCCESSFUL                1400
#define IDS_W32TM_ERRORGENERAL_ERROR_OCCURED                     1401
#define IDS_W32TM_ERRORGENERAL_INVALID_LOCALTIME                 1402
#define IDS_W32TM_ERRORGENERAL_MISSING_PARAM                     1403
#define IDS_W32TM_ERRORGENERAL_NOINTERFACE                       1404
#define IDS_W32TM_ERRORGENERAL_TOO_MANY_PARAMS                   1405
#define IDS_W32TM_ERRORGENERAL_UNEXPECTED_PARAMS                 1406

#define IDS_W32TM_ERRORPARAMETER_COMPUTER_MISSING                1500
#define IDS_W32TM_ERRORPARAMETER_INCORRECT_NUMBER_FOR_ALERT      1501
#define IDS_W32TM_ERRORPARAMETER_UNKNOWN_PARAMETER_SYNCFROMFLAGS 1502

#define IDS_W32TM_ERRORCONFIG_NO_CHANGE_SPECIFIED                1600
#define IDS_W32TM_ERRORDUMPREG_NO_SUBKEY_SPECIFIED               1601
#define IDS_W32TM_ERRORTIMEMONITOR_GETDCLIST_FAILED              1602
#define IDS_W32TM_ERRORTIMEMONITOR_INVALID_NUMBER_THREADS        1603

#define IDS_W32TM_ERRORTIMEZONE_INVALID                          1704

#define IDS_W32TM_STATUS_SENDING_RESYNC_TO                       1800
#define IDS_W32TM_STATUS_CALLING_GETNETLOGONBITS_ON              1801
#define IDS_W32TM_STATUS_CALLING_JOINCONFIG                      1802
#define IDS_W32TM_STATUS_CALLING_UNJOINCONFIG	                 1803
#define IDS_W32TM_STATUS_GETTING_DC_LIST_FOR_DEFAULT_DOMAIN      1804
#define IDS_W32TM_STATUS_GETTING_DC_LIST_FOR                     1805
#define IDS_W32TM_STATUS_REGISTER_SUCCESSFUL                     1806

#define IDS_W32TM_WARN_IGNORE_SOFT                               1900

// Do not declare resource IDs greater than this number: 
#define W32TM_RESOURCEID_MAX 7999

#define IDC_STATIC                        -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\cacls2\common\caclscom.c ===
/*--

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    calcscom.c

Abstract:

    Support routines for dacls/sacls exes

Author:

    14-Dec-1996 (macm)

Environment:

    User mode only.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <caclscom.h>
#include <dsysdbg.h>
#include <aclapi.h>
#include <stdio.h>
#include <wcstr.h>

#include <seopaque.h>
#include <sertlp.h>


DWORD
ConvertCmdlineRights(
    IN  PSTR                pszCmdline,
    IN  PCACLS_STR_RIGHTS   pRightsTable,
    IN  INT                 cRights,
    OUT DWORD              *pConvertedRights
    )
/*++

Routine Description:

    Parses the given command line string that corresponds to a given rights
    list.  The individual righs entry are looked up in the rights table and
    added to the list of converted rights

Arguments:

    pszCmdline - The list of string rights to convert

    pRightsTable - The mapping from the string rights to the new win32 rights.
        It is expected that the rights table string tags will all be in upper
        case upon function entry.

    cRights - The number of items in the rights table

    pConvertedRights - Where the converted access mask is returned

Return Value:

    ERROR_SUCCESS   --  Success
    ERROR_INVALID_PARAMETER -- An unexpected string right was encountered


--*/
{
    DWORD   dwErr = ERROR_SUCCESS;
    PSTR    pszCurrent = pszCmdline;
    INT     i;
#if DBG
    INT     j;
#endif

    *pConvertedRights = 0;

    //
    // Allow empty lists
    //
    if (pszCurrent == NULL) {

        return(ERROR_SUCCESS);

    }

    //
    // Assert that the table is upper case as expected
    //
#if DBG
    for (i = 0; i < cRights; i++) {

        for (j = 0; j < 2; j++) {

            if(toupper(pRightsTable[i].szRightsTag[j]) != pRightsTable[i].szRightsTag[j]) {

                dwErr = ERROR_INVALID_PARAMETER;
                break;

            }
        }
    }
#endif


    while (dwErr == ERROR_SUCCESS && *pszCurrent != '\0') {

        dwErr = ERROR_INVALID_PARAMETER;

        for (i = 0; i < cRights; i++ ) {

            if (pRightsTable[i].szRightsTag[0] ==
                                                toupper(*pszCurrent) &&
                pRightsTable[i].szRightsTag[1] ==
                                                toupper(*(pszCurrent + 1))) {

                dwErr = ERROR_SUCCESS;
                *pConvertedRights |= pRightsTable[i].Right;
                break;

            }
        }

        pszCurrent++;

        if (*pszCurrent != '\0') {

            pszCurrent++;
        }
    }

    return(dwErr);
}




DWORD
ParseCmdline (
    IN  PSTR               *ppszArgs,
    IN  INT                 cArgs,
    IN  INT                 cSkip,
    IN  PCACLS_CMDLINE      pCmdValues,
    IN  INT                 cCmdValues
    )
/*++

Routine Description:

    Parses the command line against the given cmd values.

Arguments:

    ppszArgs - The argument list

    cArgs - Count of arguments in the list

    cSkip - Number of initial arguments to skip

    pCmdValues - Command values list to process the command line against

    cCmdValues - Number of command values in the list

Return Value:

    ERROR_SUCCESS   --  Success
    ERROR_INVALID_PARAMETER -- An unexpected command line value was found


--*/
{
    DWORD   dwErr = ERROR_SUCCESS;
    INT     i,j;

    i = cSkip;

    while (i < cArgs && dwErr == ERROR_SUCCESS) {

        if( *ppszArgs[i] == '/' || *ppszArgs[i] == '-') {

            for (j = 0; j < cCmdValues; j++) {

                if (_stricmp(ppszArgs[i] + 1, pCmdValues[j].pszSwitch) == 0) {

                    if (pCmdValues[j].iIndex != -1) {

                        dwErr = ERROR_INVALID_PARAMETER;

                    } else {

                        pCmdValues[j].iIndex = i;

                        //
                        // See if we need to skip some number of values
                        //

                        if (pCmdValues[j].fFindNextSwitch == TRUE ) {

                            pCmdValues[j].cValues = 0;

                            while (i + 1 < cArgs) {

                                if (*ppszArgs[i + 1] != '/' &&
                                    *ppszArgs[i + 1] != '-') {

                                    pCmdValues[j].cValues++;
                                    i++;
                                } else {

                                    break;
                                }
                            }
                        }
                    }


                    break;
                }
            }

            if (j == cCmdValues) {

                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

        } else {

            dwErr = ERROR_INVALID_PARAMETER;
        }

        i++;
    }

    return(dwErr);
}




DWORD
ProcessOperation (
    IN  PSTR               *ppszCmdline,
    IN  PCACLS_CMDLINE      pCmdInfo,
    IN  ACCESS_MODE         AccessMode,
    IN  PCACLS_STR_RIGHTS   pRightsTable,
    IN  INT                 cRights,
    IN  DWORD               fInherit,
    IN  PACL                pOldAcl      OPTIONAL,
    OUT PACL               *ppNewAcl
    )
/*++

Routine Description:

    Performs an "operation", such as Grant, Revoke, Deny.  It parses the given command values
    into User/Permission pairs, and then creates a new security descriptor.  The returned
    security descriptor needs to be freed via LocalFree.

Arguments:

    ppszCmdline - The command line argument list

    pCmdInfo - Information about where this operation lives in the comand line

    AccessMode - Type of operation (Grant/Revoke/Deny) to do

    pRightsTable - The mapping from the string rights to the new win32 rights.
        It is expected that the rights table string tags will all be in upper
        case upon function entry.

    cRights - The number of items in the rights table

    fInherit - Inheritance flags to apply

    pOldAcl - Optional.  If present, this is the ACL off of the object in the edit case.

    ppNewAcl - Where the new ACL is returned.


Return Value:

    ERROR_SUCCESS   --  Success
    ERROR_INVALID_PARAMETER -- The switch was specified, but no user/perms pairs were found
    ERROR_NOT_ENOUGH_MEMORY -- A memory allocation failed.

--*/
{
    DWORD   dwErr = ERROR_SUCCESS;
    PEXPLICIT_ACCESS_A  pNewAccess = NULL;
    PSTR    pszRights;
    INT     i;
    DWORD   dwRights;

    //
    // Make sure we have valid parameters
    //
    if (pCmdInfo->iIndex != -1 && pCmdInfo->cValues == 0) {

        return(ERROR_INVALID_PARAMETER);
    }

    pNewAccess = (PEXPLICIT_ACCESS_A)LocalAlloc(LMEM_FIXED,
                                                sizeof(EXPLICIT_ACCESS_A) * pCmdInfo->cValues);
    if (pNewAccess == NULL) {

        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Otherwise, start parsing and converting...
    //
    for (i = 0; i < (INT)pCmdInfo->cValues && dwErr == ERROR_SUCCESS; i++) {

        pszRights = strchr(ppszCmdline[pCmdInfo->iIndex + i + 1], ':');

        if (pszRights == NULL && AccessMode != REVOKE_ACCESS) {

            dwErr = ERROR_INVALID_PARAMETER;

        } else {

            if (pszRights != NULL) {

                *pszRights = '\0';
                pszRights++;

            }

            dwErr = ConvertCmdlineRights(pszRights,
                                         pRightsTable,
                                         cRights,
                                         &dwRights);

            if (dwErr == ERROR_SUCCESS) {

                BuildExplicitAccessWithNameA(&pNewAccess[i],
                                             ppszCmdline[pCmdInfo->iIndex + i + 1],
                                             dwRights,
                                             AccessMode,
                                             fInherit);
            }

        }
    }

    //
    // If all of that worked, we'll apply it to the new security descriptor
    //
    if (dwErr == ERROR_SUCCESS) {

        dwErr = SetEntriesInAclA(pCmdInfo->cValues,
                                 pNewAccess,
                                 pOldAcl,
                                 ppNewAcl);
    }


    LocalFree(pNewAccess);
    return(dwErr);
}




DWORD
SetAndPropagateFileRights (
    IN  PSTR                    pszFilePath,
    IN  PACL                    pAcl,
    IN  SECURITY_INFORMATION    SeInfo,
    IN  BOOL                    fPropagate,
    IN  BOOL                    fContinueOnDenied,
    IN  BOOL                    fBreadthFirst,
    IN  DWORD                   fInherit
    )
/*++

Routine Description:

    This function will set [and propagate] the given acl to the specified path and optionally all
    of its children.  In the event of an access denied error, this function may or may not
    terminate, depending on the state of the fContinueOnDenied flag. This function does a depth
    first search with a write on return.  This function is recursive.

Arguments:

    pszFilePath - The file path to set the ACL on

    pAcl - The acl to set

    SeInfo - Whether the DACL or SACL is being set

    fPropagate - Determines whether the function should propagate or not

    fContinueOnDenied - Determines the behavior when an access denied is encountered.

    fBreadthFirst - If TRUE, do a breadth first propagation.  Otherwise, do a depth first

    fInherit - Optional inheritance flags to apply

Return Value:

    ERROR_SUCCESS   --  Success
    ERROR_NOT_ENOUGH_MEMORY -- A memory allocation failed.

--*/
{
    DWORD               dwErr = ERROR_SUCCESS;

    PSTR                pszFullPath = NULL;
    PSTR                pszSearchPath = NULL;
    HANDLE              hFind = INVALID_HANDLE_VALUE;
    DWORD               cPathLen = 0;
    WIN32_FIND_DATAA    FindData;
    BOOL                fRestoreWhack = FALSE;
    PACE_HEADER         pAce;
    DWORD               iAce;


    if ( fInherit != 0 ) {

        pAce = (PACE_HEADER)FirstAce(pAcl);

        for ( iAce = 0;
              iAce < pAcl->AceCount && dwErr == ERROR_SUCCESS;
              iAce++, pAce = (PACE_HEADER)NextAce(pAce) ) {

              pAce->AceFlags |= (UCHAR)fInherit;
        }
    }

    //
    // If we're doing a breadth first propagation, set the security first
    //
    if ( fBreadthFirst == TRUE ) {

        dwErr = SetNamedSecurityInfoA(pszFilePath, SE_FILE_OBJECT, SeInfo, NULL, NULL,
                                      SeInfo == DACL_SECURITY_INFORMATION ?
                                                                        pAcl :
                                                                        NULL,
                                      SeInfo == SACL_SECURITY_INFORMATION ?
                                                                        pAcl :
                                                                        NULL);
    }

    if (fPropagate == TRUE) {

        cPathLen = strlen(pszFilePath);

        pszSearchPath = (PSTR)LocalAlloc(LMEM_FIXED, cPathLen + 1 + 4);

        if (pszSearchPath == NULL) {

            dwErr = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            if (pszFilePath[cPathLen - 1] == '\\') {

                pszFilePath[cPathLen - 1] = '\0';
                cPathLen--;
                fRestoreWhack = TRUE;
            }

            sprintf(pszSearchPath, "%s\\%s", pszFilePath, "*.*");

            hFind = FindFirstFileA(pszSearchPath,
                                   &FindData);
            if (hFind == INVALID_HANDLE_VALUE) {

                dwErr = GetLastError();

            }
        }


        //
        // Start processing all the files
        //
        while (dwErr == ERROR_SUCCESS) {

            //
            // Ignore the . and ..
            //
            if (strcmp(FindData.cFileName, ".") != 0 &&
                strcmp(FindData.cFileName, "..") != 0) {

                //
                // Now, build the full path...
                //
                pszFullPath = (PSTR)LocalAlloc(LMEM_FIXED,
                                               cPathLen + 1 + strlen(FindData.cFileName) + 1);
                if (pszFullPath == NULL) {

                    dwErr = ERROR_NOT_ENOUGH_MEMORY;

                } else  {

                    sprintf(pszFullPath, "%s\\%s", pszFilePath, FindData.cFileName);

                    //
                    // Call ourselves
                    //
                    dwErr = SetAndPropagateFileRights(pszFullPath, pAcl, SeInfo,
                                                      fPropagate, fContinueOnDenied, fBreadthFirst,
                                                      fInherit);

                    if (dwErr == ERROR_ACCESS_DENIED && fContinueOnDenied == TRUE) {

                        dwErr = ERROR_SUCCESS;
                    }

                }
            }


            if (dwErr == ERROR_SUCCESS && FindNextFile(hFind, &FindData) == FALSE) {

                dwErr = GetLastError();
            }
        }

        if(dwErr == ERROR_NO_MORE_FILES)
        {
            dwErr = ERROR_SUCCESS;
        }
    }

    //
    // Cover the case where it is a file
    //
    if (dwErr == ERROR_DIRECTORY) {

        dwErr = ERROR_SUCCESS;
    }


    //
    // Now, do the set
    //
    if (dwErr == ERROR_SUCCESS && fBreadthFirst == FALSE) {

        dwErr = SetNamedSecurityInfoA(pszFilePath, SE_FILE_OBJECT, SeInfo, NULL, NULL,
                                      SeInfo == DACL_SECURITY_INFORMATION ?
                                                                        pAcl :
                                                                        NULL,
                                      SeInfo == SACL_SECURITY_INFORMATION ?
                                                                        pAcl :
                                                                        NULL);

    }

    if (fRestoreWhack == TRUE) {

        pszFilePath[cPathLen - 1] = '\\';
        pszFilePath[cPathLen] = '\0';

    }

    //
    // If necessary, restore the inheritance flags
    //
    if ( fInherit != 0 ) {

        pAce = (PACE_HEADER)FirstAce(pAcl);

        for ( iAce = 0;
              iAce < pAcl->AceCount && dwErr == ERROR_SUCCESS;
              iAce++, pAce = (PACE_HEADER)NextAce(pAce) ) {

              pAce->AceFlags &= (UCHAR)~fInherit;
        }
    }


    return(dwErr);
}




DWORD
DisplayAcl (
    IN  PSTR                pszPath,
    IN  PACL                pAcl,
    IN  PCACLS_STR_RIGHTS   pRightsTable,
    IN  INT                 cRights
    )
/*++

Routine Description:

    This function will display the given acl to the screen

Arguments:

    pszPath - The file path to be displayed

    pAcl - The Acl to display

    pRightsTable - List of available rights

    cRights - Number of rights in the list

Return Value:

    ERROR_SUCCESS   --  Success

--*/
{
    DWORD   dwErr = ERROR_SUCCESS;

    ACL_SIZE_INFORMATION        AclSize;
    ACL_REVISION_INFORMATION    AclRev;
    PKNOWN_ACE                  pAce;
    PSID                        pSid;
    DWORD                       iIndex;
    PSTR                        pszName;
    INT                         i,cPathLen, iSkip, j;
    PSTR                        pszAceTypes[] = {"ACCESS_ALLOWED_ACE_TYPE",
                                                 "ACCESS_DENIED_ACE_TYPE",
                                                 "SYSTEM_AUDIT_ACE_TYPE",
                                                 "SYSTEM_ALARM_ACE_TYPE",
                                                 "ACCESS_ALLOWED_COMPOUND_ACE_TYPE",
                                                 "ACCESS_ALLOWED_OBJECT_ACE_TYPE",
                                                 "ACCESS_DENIED_OBJECT_ACE_TYPE",
                                                 "SYSTEM_AUDIT_OBJECT_ACE_TYPE",
                                                 "SYSTEM_ALARM_OBJECT_ACE_TYPE"};
    PSTR                        pszInherit[] = {"OBJECT_INHERIT_ACE",
                                                "CONTAINER_INHERIT_ACE",
                                                "NO_PROPAGATE_INHERIT_ACE",
                                                "INHERIT_ONLY_ACE",
                                                "INHERITED_ACE"};

    fprintf(stdout, "%s: ", pszPath);
    cPathLen = strlen(pszPath) + 2;

    if (pAcl == NULL) {

        fprintf(stdout, "NULL acl\n");

    } else {

        if (GetAclInformation(pAcl, &AclRev, sizeof(ACL_REVISION_INFORMATION),
                              AclRevisionInformation) == FALSE) {

            return(GetLastError());
        }

        if(GetAclInformation(pAcl, &AclSize, sizeof(ACL_SIZE_INFORMATION),
                             AclSizeInformation) == FALSE) {

            return(GetLastError());
        }

        fprintf(stdout, "AclRevision: %lu\n", AclRev.AclRevision);

        fprintf(stdout, "%*sAceCount: %lu\n", cPathLen, " ", AclSize.AceCount);
        fprintf(stdout, "%*sInUse: %lu\n", cPathLen, " ", AclSize.AclBytesInUse);
        fprintf(stdout, "%*sFree: %lu\n", cPathLen, " ", AclSize.AclBytesFree);
        fprintf(stdout, "%*sFlags: %lu\n", cPathLen, " ", pAcl->Sbz1);


        //
        // Now, dump all of the aces
        //
        pAce = FirstAce(pAcl);
        for(iIndex = 0; iIndex < pAcl->AceCount; iIndex++) {

            cPathLen = strlen(pszPath) + 2;

            fprintf(stdout, "  %*sAce [%3lu]: ", cPathLen, " ", iIndex);

            cPathLen += 13;

            fprintf(stdout, "Type:  %s\n", pAce->Header.AceType > ACCESS_MAX_MS_ACE_TYPE ?
                                                        "UNKNOWN ACE TYPE" :
                                                        pszAceTypes[pAce->Header.AceType]);
            fprintf(stdout, "%*sFlags: ", cPathLen, " ");
            if ( pAce->Header.AceFlags == 0 ) {

                fprintf(stdout, "0\n");

            } else {

                if (( pAce->Header.AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG) != 0 ) {

                    fprintf( stdout,"SUCCESSFUL_ACCESS_ACE_FLAG  " );
                }

                if (( pAce->Header.AceFlags & FAILED_ACCESS_ACE_FLAG) != 0 ) {

                    if (( pAce->Header.AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG) != 0 ) {

                        fprintf( stdout, "| " );

                    }

                    fprintf( stdout,"FAILED_ACCESS_ACE_FLAG" );
                }

                iSkip = 0;

                if ( ( pAce->Header.AceFlags &
                                    (FAILED_ACCESS_ACE_FLAG | SUCCESSFUL_ACCESS_ACE_FLAG)) != 0 &&
                     ( pAce->Header.AceFlags & VALID_INHERIT_FLAGS) != 0 ) {

                    iSkip = cPathLen + 7;
                }

                //
                // Now, the inheritance flags
                //
                for (j = 0; j < sizeof(pszInherit) / sizeof(PSTR) ; j++) {

                    if ((pAce->Header.AceFlags & (1 << j)) != 0 ) {

                        if (iSkip != 0) {

                            fprintf(stdout, "   |  \n");
                            fprintf(stdout, "%*s", iSkip, " ");
                        }

                        fprintf(stdout, "%s", pszInherit[j]);

                        if (iSkip == 0) {

                            iSkip = cPathLen + 7;

                        }

                    }
                }

                fprintf( stdout,"\n" );
            }

            fprintf(stdout, "%*sSize:  0x%lx\n", cPathLen, " ", pAce->Header.AceSize);

            fprintf(stdout, "%*sMask:  ", cPathLen, " ");

            if (pAce->Mask == 0) {
                fprintf(stdout, "%*sNo access\n", cPathLen, " ");
            } else {

                iSkip = 0;
                for (i = 1 ;i < cRights ;i++ ) {

                    if ((pAce->Mask & pRightsTable[i].Right) != 0) {

                        if (iSkip != 0) {

                            fprintf(stdout, "%*s", iSkip, " ");

                        } else {

                            iSkip = cPathLen + 7;
                        }

                        fprintf(stdout, "%s\n", pRightsTable[i].pszDisplayTag);
                    }
                }

            }

            //
            // Lookup the account name and return it...
            //
            //
            // If it's an object ace, dump the guids
            //
            dwErr = TranslateAccountName((PSID)&(pAce->SidStart), &pszName);
            if (dwErr == ERROR_SUCCESS) {

                fprintf(stdout, "%*sUser:  %s\n", cPathLen, " ", pszName);
                LocalFree(pszName);
            }

            fprintf( stdout, "\n" );

            pAce = NextAce(pAce);

        }
    }

    return(dwErr);
}




DWORD
TranslateAccountName (
    IN  PSID    pSid,
    OUT PSTR   *ppszName
    )
/*++

Routine Description:

    This function will "translate" a sid into a name by doing a LookupAccountSid on the sid

Arguments:

    pSid - The sid to convert to a name

    ppszName - Where the name is returned.  Must be freed via a call to LocalFree.

Return Value:

    ERROR_SUCCESS   --  Success
    ERROR_NOT_ENOUGH_MEMORY -- A memory allocation failed

--*/
{
    DWORD           dwErr = ERROR_SUCCESS;
    SID_NAME_USE    esidtype;
    LPSTR           pszDomain = NULL;
    LPSTR           pszName = NULL;
    ULONG           cName = 0;
    ULONG           cDomain = 0;


    if (LookupAccountSidA(NULL, pSid, NULL, &cName, NULL,  &cDomain, &esidtype) == FALSE) {

        dwErr = GetLastError();

        if (dwErr == ERROR_INSUFFICIENT_BUFFER) {

            dwErr = ERROR_SUCCESS;

            //
            // Allocate for the name and the domain
            //
            pszName = (PSTR)LocalAlloc(LMEM_FIXED, cName);
            if (pszName != NULL) {

                pszDomain = (PSTR)LocalAlloc(LMEM_FIXED, cDomain);

                if (pszDomain == NULL) {

                    LocalFree(pszName);
                    pszName = NULL;
                }
            }


            if (pszName == NULL) {

                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }

            if (dwErr == ERROR_SUCCESS) {

                if(LookupAccountSidA(NULL, pSid, pszName, &cName, pszDomain, &cDomain,
                                     &esidtype) == FALSE) {

                    dwErr = GetLastError();
                    LocalFree(pszName);
                    LocalFree(pszDomain);
                }
            }

        } else if (dwErr == ERROR_NONE_MAPPED) {

            UCHAR           String[256];
            UNICODE_STRING  SidStr;
            NTSTATUS        Status;

            dwErr = ERROR_SUCCESS;
            pszName = NULL;

            //
            // Ok, return the sid as a name
            //
            SidStr.Buffer = (PWSTR)String;
            SidStr.Length = SidStr.MaximumLength = 256;

            Status = RtlConvertSidToUnicodeString(&SidStr, pSid, FALSE);

            if (NT_SUCCESS(Status)) {

                pszName = (PSTR)LocalAlloc(LMEM_FIXED,
                                          wcstombs(NULL, SidStr.Buffer,
                                                   wcslen(SidStr.Buffer) + 1) + 1);
                if (pszName == NULL) {

                    dwErr = ERROR_NOT_ENOUGH_MEMORY;

                } else {

                    wcstombs(pszName, SidStr.Buffer, wcslen(SidStr.Buffer) + 1);
                }

            } else {

                dwErr = RtlNtStatusToDosError(Status);
            }

        }
    }


    if(dwErr == ERROR_SUCCESS)
    {
        ULONG   cLen;

        if(pszDomain != NULL && *pszDomain != '\0')
        {
            cLen = strlen(pszDomain) + 1;
            cLen += strlen(pszName) + 1;

            *ppszName = (PSTR)LocalAlloc(LMEM_FIXED, cLen);

            if (*ppszName == NULL) {

                dwErr = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                sprintf(*ppszName, "%s\\%s", pszDomain, pszName);
            }

        } else {

            *ppszName = pszName;
            pszName = NULL;
        }
    }


    LocalFree(pszDomain);
    LocalFree(pszName);

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\cacls2\common\caclscom.h ===
/*--

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    calcscom.h

Abstract:

    Support routines for dacls/sacls exes

Author:

    14-Dec-1996 (macm)

Environment:

    User mode only.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/
#ifndef __CACLSCOM_H__
#define __CACLSCON_H__

#include <accctrl.h>

typedef struct _CACLS_STR_RIGHTS_
{
    CHAR    szRightsTag[2];
    DWORD   Right;
    PSTR    pszDisplayTag;

} CACLS_STR_RIGHTS, *PCACLS_STR_RIGHTS;


typedef struct _CACLS_CMDLINE
{
    PSTR    pszSwitch;
    INT     iIndex;
    BOOL    fFindNextSwitch;
    DWORD   cValues;
} CACLS_CMDLINE, *PCACLS_CMDLINE;

//
// Function prototypes
//
DWORD
ConvertCmdlineRights (
    IN  PSTR                pszCmdline,
    IN  PCACLS_STR_RIGHTS   pRightsTable,
    IN  INT                 cRights,
    OUT DWORD              *pConvertedRights
    );

DWORD
ParseCmdline (
    IN  PSTR               *ppszArgs,
    IN  INT                 cArgs,
    IN  INT                 cSkip,
    IN  PCACLS_CMDLINE      pCmdValues,
    IN  INT                 cCmdValues
    );

DWORD
ProcessOperation (
    IN  PSTR               *ppszCmdline,
    IN  PCACLS_CMDLINE      pCmdInfo,
    IN  ACCESS_MODE         AccessMode,
    IN  PCACLS_STR_RIGHTS   pRightsTable,
    IN  INT                 cRights,
    IN  DWORD               fInherit,
    IN  PACL                pOldAcl      OPTIONAL,
    OUT PACL               *ppNewAcl
    );

DWORD
SetAndPropagateFileRights (
    IN  PSTR                    pszFilePath,
    IN  PACL                    pAcl,
    IN  SECURITY_INFORMATION    SeInfo,
    IN  BOOL                    fPropagate,
    IN  BOOL                    fContinueOnDenied,
    IN  BOOL                    fBreadthFirst,
    IN  DWORD                   fInherit
    );

DWORD
DisplayAcl (
    IN  PSTR                pszPath,
    IN  PACL                pAcl,
    IN  PCACLS_STR_RIGHTS   pRightsTable,
    IN  INT                 cRights
    );

DWORD
TranslateAccountName (
    IN  PSID    pSid,
    OUT PSTR   *ppszName
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\cacls2\dacls\dacls.c ===
/*--

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    dacls.c

Abstract:

    Extended version of cacls.exe

Author:

    14-Dec-1996 (macm)

Environment:

    User mode only.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include <windows.h>
#include <caclscom.h>
#include <dsysdbg.h>
#include <stdio.h>
#include <aclapi.h>

#define CMD_PRESENT(index, list)    ((list)[index].iIndex != -1)

#define NO_INHERIT_ONLY

//
// Enumeration of command tags
//
typedef enum _CMD_TAGS {
    CmdTree = 0,
    CmdEdit,
    CmdContinue,
    CmdGrant,
    CmdRevoke,
    CmdReplace,
    CmdDeny,
    CmdICont,
    CmdIObj,
#ifndef NO_INHERIT_ONLY
    CmdIOnly,
#endif
    CmdIProp
} CMD_TAGS, *PCMD_TAGS;


VOID
Usage (
    IN  PCACLS_STR_RIGHTS   pStrRights,
    IN  INT                 cStrRights,
    IN  PCACLS_CMDLINE      pCmdVals
    )
/*++

Routine Description:

    Displays the expected usage

Arguments:

Return Value:

    VOID

--*/
{
    INT i;

    printf("Displays or modifies access control lists (ACLs) of files\n\n");
    printf("DACLS filename [/T] [/E] [/C] [/G user:perm] [/R user [...]]\n");
    printf("               [/P user:perm [...]] [/D user [...]]\n");
    printf("   filename      Displays ACLs.\n");
    printf("   /%s            Changes ACLs of specified files in\n", pCmdVals[CmdTree].pszSwitch);
    printf("                 the current directory and all subdirectories.\n");
    printf("   /%s            Edit ACL instead of replacing it.\n", pCmdVals[CmdEdit].pszSwitch);
    printf("   /%s            Continue on access denied errors.\n", pCmdVals[CmdContinue].pszSwitch);
    printf("   /%s user:perms Grant specified user access rights .\n", pCmdVals[CmdGrant].pszSwitch);
    printf("   /%s user       Revoke specified user's access rights (only valid with /E).\n", pCmdVals[CmdRevoke].pszSwitch);
    printf("   /%s user:perms Replace specified user's access rights.\n", pCmdVals[CmdReplace].pszSwitch);
    printf("   /%s user:perms Deny specified user access.\n", pCmdVals[CmdDeny].pszSwitch);
    printf("   /%s            Mark the ace as CONTAINER_INHERIT (folder or directory inherit)\n", pCmdVals[CmdICont].pszSwitch);
    printf("   /%s            Mark the ace as OBJECT_INHERIT\n", pCmdVals[CmdIObj].pszSwitch);
#ifndef NO_INHERIT_ONLY
    printf("   /%s            Mark the ace as INHERIT_ONLY\n", pCmdVals[CmdIOnly].pszSwitch);
#endif
    printf("   /%s            Mark the ace as INHERIT_NO_PROPAGATE\n", pCmdVals[CmdIProp].pszSwitch);
    printf("The list of supported perms for the Grant and Replace operations are:\n");

    for (i = 0; i < cStrRights; i++) {

        printf("              %c%c  %s\n",
               pStrRights[i].szRightsTag[0],
               pStrRights[i].szRightsTag[1],
               pStrRights[i].pszDisplayTag);
    }


    printf("\nMultiple perms can be specified per user\n");

    printf("Wildcards can be used to specify more that one file in a command.\n");
    printf("You can specify more than one user in a command.\n\n");

    printf("Example: DACLS c:\\temp /G user1:GRGW user2:SDRC\n");
}


INT
__cdecl main (
    int argc,
    char *argv[])
/*++

Routine Description:

    The main the for this executable

Arguments:

    argc - Count of arguments
    argv - List of arguments

Return Value:

    VOID

--*/
{
    DWORD   dwErr = 0;
    CACLS_STR_RIGHTS   pStrRights[] = {
         "NA", 0, "No Access",
         "GR", GENERIC_READ, "Read",
         "GC", GENERIC_WRITE, "Change (write)",
         "GF", GENERIC_ALL, "Full control",
         "SD", DELETE, "Delete",
         "RC", READ_CONTROL, "Read Control",
         "WP", WRITE_DAC, "Write DAC",
         "WO", WRITE_OWNER, "Write Owner",
         "RD", FILE_READ_DATA, "Read Data (on file) / List Directory (on Dir)",
         "WD", FILE_WRITE_DATA, "Write Data (on file) / Add File (on Dir)",
         "AD", FILE_APPEND_DATA, "Append Data (on file) / Add SubDir (on Dir)",
         "FE", FILE_EXECUTE, "Execute (on file) / Traverse (on Dir)",
         "DC", FILE_DELETE_CHILD, "Delete Child (on Dir only)",
         "RA", FILE_READ_ATTRIBUTES, "Read Attributes",
         "WA", FILE_WRITE_ATTRIBUTES, "Write Attributes",
         "RE", FILE_READ_EA, "Read Extended Attributes",
         "WE", FILE_WRITE_EA, "Write Extended Attributes"
        };
    INT cStrRights = sizeof(pStrRights) / sizeof(CACLS_STR_RIGHTS);
    CACLS_CMDLINE   pCmdVals[] = {
        "T", -1, FALSE, 0,      // CmdTree
        "E", -1, FALSE, 0,      // CmdEdit
        "C", -1, FALSE, 0,      // CmdContinue
        "G", -1, TRUE,  0,      // CmdGrant
        "R", -1, TRUE,  0,      // CmdRevoke
        "P", -1, TRUE,  0,      // CmdReplace
        "D", -1, TRUE,  0,      // CmdDeny
        "F", -1, FALSE, 0,      // CmdICont
        "O", -1, FALSE, 0,      // CmdIObj
#ifndef NO_INHERIT_ONLY
        "I", -1, FALSE, 0,     // CmdIOnly
#endif
        "N", -1, FALSE, 0,      // CmdIProp
        };
    INT cCmdVals = sizeof(pCmdVals) / sizeof(CACLS_CMDLINE);
    INT i;
    PSECURITY_DESCRIPTOR    pInitialSD = NULL, pFinalSD;
    PACL                    pOldAcl = NULL, pNewAcl = NULL;
    DWORD                   fInherit = 0;
    BOOL                    fFreeAcl = FALSE;


    if (argc < 2) {

        Usage(pStrRights, cStrRights, pCmdVals);
        return(1);

    } else if (argc == 2 && (strcmp(argv[1], "-?") == 0 || strcmp(argv[1], "/?") == 0)) {

        Usage(pStrRights, cStrRights, pCmdVals);
        return(0);

    }


    //
    // Parse the command line
    //
    dwErr = ParseCmdline(argv, argc, 2, pCmdVals, cCmdVals);

    if (dwErr != ERROR_SUCCESS) {

        Usage(pStrRights, cStrRights, pCmdVals);
        return(1);

    }

    //
    // Set our inheritance flags
    //
    if (CMD_PRESENT(CmdICont, pCmdVals)) {

        fInherit |= CONTAINER_INHERIT_ACE;
    }

    if (CMD_PRESENT(CmdIObj, pCmdVals)) {

        fInherit |= OBJECT_INHERIT_ACE;
    }

#ifndef NO_INHERIT_ONLY
    if (CMD_PRESENT(CmdIOnly, pCmdVals)) {

        fInherit |= INHERIT_ONLY_ACE;
    }
#endif

    if (CMD_PRESENT(CmdIProp, pCmdVals)) {

        fInherit |= NO_PROPAGATE_INHERIT_ACE;
    }



    //
    // Ok, see if we need to read the existing security
    //
    if (CMD_PRESENT(CmdEdit, pCmdVals) || argc == 2) {

        dwErr = GetNamedSecurityInfoA(argv[1], SE_FILE_OBJECT, DACL_SECURITY_INFORMATION,
                                      NULL, NULL, &pOldAcl, NULL, &pInitialSD);
        if (dwErr != ERROR_SUCCESS) {

            fprintf(stderr, "Failed to read the security off of %s: %lu\n", argv[1], dwErr);
        }

    }

    //
    // Either display the existing access or do the sets as requested
    //
    if (dwErr == ERROR_SUCCESS && argc == 2) {

        dwErr = DisplayAcl ( argv[1], pOldAcl, pStrRights, cStrRights );

    } else {

        //
        // Ok, first we do the revokes
        //
        if (dwErr == ERROR_SUCCESS && CMD_PRESENT(CmdRevoke, pCmdVals)) {

            //
            // Make sure we've read it first...
            //
            if (CMD_PRESENT(CmdEdit, pCmdVals)) {

                dwErr = ProcessOperation( argv, &pCmdVals[CmdRevoke], REVOKE_ACCESS, pStrRights,
                                          cStrRights, fInherit, pOldAcl, &pNewAcl );

                if (dwErr == ERROR_SUCCESS) {

                    pOldAcl = pNewAcl;
                }

            } else {

                dwErr = ERROR_INVALID_PARAMETER;
            }

        }

        //
        // Then the grants
        //
        if (dwErr == ERROR_SUCCESS && CMD_PRESENT(CmdGrant, pCmdVals)) {

            //
            // First, see if we need to free the old acl on completion
            //
            if (pOldAcl == pNewAcl) {

                fFreeAcl = TRUE;
            }


            dwErr = ProcessOperation(argv, &pCmdVals[CmdGrant], GRANT_ACCESS, pStrRights,
                                     cStrRights, 0, pOldAcl, &pNewAcl);

            if (dwErr == ERROR_SUCCESS) {

                if (fFreeAcl == TRUE) {

                    LocalFree(pOldAcl);
                }

                pOldAcl = pNewAcl;

                //
                // Now set it and optionally propagate it
                //
                dwErr = SetAndPropagateFileRights(argv[1], pNewAcl, DACL_SECURITY_INFORMATION,
                                                  CMD_PRESENT(CmdTree, pCmdVals),
                                                  CMD_PRESENT(CmdContinue, pCmdVals), TRUE,
                                                  fInherit);
            }
        }

        //
        // Finally, the denieds
        //
        if (dwErr == ERROR_SUCCESS && CMD_PRESENT(CmdDeny, pCmdVals)) {

            //
            // First, see if we need to free the old acl on completion
            //
            if (pOldAcl == pNewAcl) {

                fFreeAcl = TRUE;
            }


            dwErr = ProcessOperation(argv, &pCmdVals[CmdDeny], DENY_ACCESS, pStrRights,
                                     cStrRights, 0, pOldAcl, &pNewAcl);

            if (dwErr == ERROR_SUCCESS) {

                if (fFreeAcl == TRUE) {

                    LocalFree(pOldAcl);
                }

                pOldAcl = pNewAcl;

                //
                // Now set it and optionally propagate it
                //
                dwErr = SetAndPropagateFileRights(argv[1], pNewAcl, DACL_SECURITY_INFORMATION,
                                                  CMD_PRESENT(CmdTree, pCmdVals),
                                                  CMD_PRESENT(CmdContinue, pCmdVals), FALSE,
                                                  fInherit);
            }
        }



        //
        // Finally, do the set if it hasn't already been done
        //
        if (dwErr == ERROR_SUCCESS  && !CMD_PRESENT(CmdGrant, pCmdVals) &&
                                                                !CMD_PRESENT(CmdDeny, pCmdVals)) {

            dwErr = SetAndPropagateFileRights(argv[1], pNewAcl, DACL_SECURITY_INFORMATION,
                                              CMD_PRESENT(CmdTree, pCmdVals),
                                              CMD_PRESENT(CmdContinue, pCmdVals), FALSE,
                                              fInherit);
        }

        if (dwErr == ERROR_INVALID_PARAMETER) {

            Usage(pStrRights, cStrRights, pCmdVals);
        }

        LocalFree(pInitialSD);
    }

    LocalFree(pOldAcl);

    if(dwErr == ERROR_SUCCESS) {

        printf("The command completed successfully\n");

    } else {

        printf("The command failed with an error %lu\n", dwErr);

    }

    return(dwErr == 0 ? 0 : 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\cacls2\sacls\sacls.c ===
/*--

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    sacls.c

Abstract:

    Extended version of cacls.exe

Author:

    14-Dec-1996 (macm)

Environment:

    User mode only.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <seopaque.h>
#include <windows.h>
#include <caclscom.h>
#include <dsysdbg.h>
#include <stdio.h>
#include <aclapi.h>

#define CMD_PRESENT(index, list)    ((list)[index].iIndex != -1)

#define NO_INHERIT_ONLY

//
// Enumeration of command tags
//
typedef enum _CMD_TAGS {
    CmdTree = 0,
    CmdEdit,
    CmdContinue,
    CmdSuccess,
    CmdRevoke,
    CmdFail,
    CmdICont,
    CmdIObj,
#ifndef NO_INHERIT_ONLY
    CmdIOnly,
#endif
    CmdIProp
} CMD_TAGS, *PCMD_TAGS;

VOID
Usage (
    IN  PCACLS_STR_RIGHTS   pStrRights,
    IN  INT                 cStrRights,
    IN  PCACLS_CMDLINE      pCmdVals
    )
/*++

Routine Description:

    Displays the expected usage

Arguments:

Return Value:

    VOID

--*/
{
    INT i;

    printf("Displays or modifies audit control lists (ACLs) of files.  You need \"Manage "
           "auditing and security log\" privilege to run this utility.\n\n" );

    printf("SACLS filename [/T] [/E] [/C] [/G user:perm] [/R user [...]]\n");
    printf("               [/P user:perm [...]] [/D user [...]]\n");
    printf("   filename      Displays ACLs.\n");
    printf("   /%s            Changes ACLs of specified files in\n", pCmdVals[CmdTree].pszSwitch);
    printf("                 the current directory and all subdirectories.\n");
    printf("   /%s            Edit ACL instead of replacing it.\n", pCmdVals[CmdEdit].pszSwitch);
    printf("   /%s            Continue on access denied errors.\n",
           pCmdVals[CmdContinue].pszSwitch);
    printf("   /%s user:perms Add specified user successful access auditing\n",
          pCmdVals[CmdSuccess].pszSwitch);
    printf("   /%s user       Revoke specified user's auditing rights (only valid with /E).\n",
           pCmdVals[CmdRevoke].pszSwitch);
    printf("   /%s user:perms Add specified user failed access auditing.\n",
           pCmdVals[CmdFail].pszSwitch);
    printf("   /%s            Mark the ace as CONTAINER_INHERIT (directory inherit)\n",
           pCmdVals[CmdICont].pszSwitch);
    printf("   /%s            Mark the ace as OBJECT_INHERIT\n", pCmdVals[CmdIObj].pszSwitch);
#ifndef NO_INHERIT_ONLY
    printf("   /%s            Mark the ace as INHERIT_ONLY\n", pCmdVals[CmdIOnly].pszSwitch);
#endif
    printf("   /%s            Mark the ace as INHERIT_NO_PROPAGATE\n",
          pCmdVals[CmdIProp].pszSwitch);
    printf("The list of supported perms for Success and Failure auditing are:\n");

    for (i = 0; i < cStrRights; i++) {

        printf("              %c%c  %s\n",
               pStrRights[i].szRightsTag[0],
               pStrRights[i].szRightsTag[1],
               pStrRights[i].pszDisplayTag);
    }


    printf("\nMultiple perms can be specified per user\n");

    printf("Wildcards can be used to specify more that one file in a command.\n");
    printf("You can specify more than one user in a command.\n\n");

    printf("Example: SACLS c:\\temp /S user1:GRGW user2:SDRC /F user3:GF\n");
}



DWORD
MergeAcls (
    IN  PACL    pOldAcl,
    IN  PACL    pNewAcl
    )
/*++

Routine Description:

    Merges the old acl into the new one, by combining any identical aces.  It is assumed that
    the destintation acl is of sufficient size.  No allocations will be done, but an error will
    be returned if it isn't

Arguments:

    pOldAcl - The acl to be merged

    pNewAcl - The acl to be merged into

Return Value:

    ERROR_SUCCESS -- Success

--*/
{
    DWORD   dwErr = ERROR_SUCCESS;
    PACE_HEADER pNewAce, pOldAce;
    DWORD   iNewAce, iOldAce;
    BOOL    fFound;

    //
    // If the new acl is empty, simply copy the new one over
    //
    if (pNewAcl->AceCount == 0 ) {

        memcpy((PVOID)((PBYTE)pNewAcl + sizeof(ACL)), (PBYTE)pOldAcl + sizeof(ACL),
                                                pOldAcl->AclSize - sizeof(ACL));
        pNewAcl->AceCount = pOldAcl->AceCount;
        return(ERROR_SUCCESS);

    }

    pOldAce = (PACE_HEADER)FirstAce(pOldAcl);

    for ( iOldAce = 0;
          iOldAce < pOldAcl->AceCount && dwErr == ERROR_SUCCESS;
          iOldAce++, pOldAce = (PACE_HEADER)NextAce(pOldAce) ) {

        fFound = FALSE;

        //
        // We'll walk each of the existing acls, and try and compress the new
        // acls out of existance
        //
        pNewAce = (PACE_HEADER)FirstAce(pNewAcl);
        for ( iNewAce = 0;
              iNewAce < pOldAcl->AceCount && dwErr == ERROR_SUCCESS;
              iNewAce++, pNewAce = (PACE_HEADER)NextAce(pNewAce) ) {

            if ( EqualSid ( (PSID)(&((PSYSTEM_AUDIT_ACE)pNewAce)->SidStart),
                            (PSID)(&((PSYSTEM_AUDIT_ACE)pOldAce)->SidStart) ) &&
                 pNewAce->AceType == pOldAce->AceType &&
                 (pNewAce->AceFlags & VALID_INHERIT_FLAGS) == 0 &&
                 (pOldAce->AceFlags & VALID_INHERIT_FLAGS) == 0 &&
                 ((PSYSTEM_AUDIT_ACE)pNewAce)->Mask == ((PSYSTEM_AUDIT_ACE)pOldAce)->Mask) {

                ((PSYSTEM_AUDIT_ACE)pNewAce)->Mask |=
                                         ((PSYSTEM_AUDIT_ACE)pOldAce)->Mask;
                pNewAce->AceFlags |= pOldAce->AceFlags;
                fFound = TRUE;

                break;

            }
        }

        if ( fFound != TRUE ) {

            //
            // We'll have to add it
            //
            if ( !AddAuditAccessAce (
                        pNewAcl,
                        ACL_REVISION2,
                        ((PSYSTEM_AUDIT_ACE)pOldAce)->Mask,
                        (PSID)(&((PSYSTEM_AUDIT_ACE)pOldAce)->SidStart),
                        (pOldAce->AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG),
                        (pOldAce->AceFlags & FAILED_ACCESS_ACE_FLAG) ) ) {

                dwErr = GetLastError();
                break;
            }
        }

    }


    return(dwErr);
}



INT
__cdecl main (
    int argc,
    char *argv[])
/*++

Routine Description:

    The main the for this executable

Arguments:

    argc - Count of arguments
    argv - List of arguments

Return Value:

    VOID

--*/
{
    DWORD   dwErr = 0;
    CACLS_STR_RIGHTS   pStrRights[] = {
         "GR", GENERIC_READ, "Read",
         "GC", GENERIC_WRITE, "Change (write)",
         "GF", GENERIC_ALL, "Full rights",
         "SD", DELETE, "Delete",
         "RC", READ_CONTROL, "Read Control",
         "WP", WRITE_DAC, "Write DAC",
         "WO", WRITE_OWNER, "Write Owner",
         "RD", FILE_READ_DATA, "Read Data (on file) / List Directory (on Dir)",
         "WD", FILE_WRITE_DATA, "Write Data (on file) / Add File (on Dir)",
         "AD", FILE_APPEND_DATA, "Append Data (on file) / Add SubDir (on Dir)",
         "FE", FILE_EXECUTE, "Execute (on file) / Traverse (on Dir)",
         "DC", FILE_DELETE_CHILD, "Delete Child (on Dir only)",
         "RA", FILE_READ_ATTRIBUTES, "Read Attributes",
         "WA", FILE_WRITE_ATTRIBUTES, "Write Attributes",
         "RE", FILE_READ_EA, "Read Extended Attributes",
         "WE", FILE_WRITE_EA, "Write Extended Attributes"
        };
    INT cStrRights = sizeof(pStrRights) / sizeof(CACLS_STR_RIGHTS);
    CACLS_CMDLINE   pCmdVals[] = {
        "T", -1, FALSE, 0,              // CmdTree
        "E", -1, FALSE, 0,              // CmdEdit
        "C", -1, FALSE, 0,              // CmdContinue
        "S", -1, TRUE,  0,              // CmdSuccess
        "R", -1, TRUE,  0,              // CmdRevoke
        "F", -1, TRUE,  0,              // CmdFail
        "D", -1, FALSE, 0,              // CmdICont
        "O", -1, FALSE, 0,              // CmdIObj
#ifndef NO_INHERIT_ONLY
        "I", -1, FALSE, 0,              // CmdIOnly
#endif
        "N", -1, FALSE, 0,              // CmdIProp
        };
    INT cCmdVals = sizeof(pCmdVals) / sizeof(CACLS_CMDLINE);
    INT i;
    PSECURITY_DESCRIPTOR    pInitialSD = NULL, pFinalSD;
    PACL                    pOldAcl = NULL, pSuccessAcl = NULL, pFailAcl = NULL;
    DWORD                   fInherit = 0;
    HANDLE                  hProcessToken;


    if (argc < 2) {

        Usage( pStrRights, cStrRights, pCmdVals );
        return(1);

    } else if (argc == 2 && (strcmp(argv[1], "-?") == 0 || strcmp(argv[1], "/?") == 0)) {

        Usage( pStrRights, cStrRights, pCmdVals );
        return(0);

    }


    //
    // Parse the command line
    //
    dwErr = ParseCmdline(argv, argc, 2, pCmdVals, cCmdVals);

    if (dwErr != ERROR_SUCCESS) {

        Usage( pStrRights, cStrRights, pCmdVals );
        return(1);

    }

    //
    // Set our inheritance flags
    //
    if (CMD_PRESENT(CmdICont, pCmdVals)) {

        fInherit |= CONTAINER_INHERIT_ACE;
    }

    if (CMD_PRESENT(CmdIObj, pCmdVals)) {

        fInherit |= OBJECT_INHERIT_ACE;
    }

#ifndef NO_INHERIT_ONLY
    if (CMD_PRESENT(CmdIOnly, pCmdVals)) {

        fInherit |= INHERIT_ONLY_ACE;
    }
#endif

    if (CMD_PRESENT(CmdIProp, pCmdVals)) {

        fInherit |= NO_PROPAGATE_INHERIT_ACE;
    }


    //
    // Enable the read sacl privs
    //
    if ( OpenProcessToken(GetCurrentProcess(), MAXIMUM_ALLOWED, &hProcessToken ) == FALSE) {

        dwErr = GetLastError();

    } else {

        TOKEN_PRIVILEGES EnableSeSecurity;
        TOKEN_PRIVILEGES Previous;
        DWORD PreviousSize;

        EnableSeSecurity.PrivilegeCount = 1;
        EnableSeSecurity.Privileges[0].Luid.LowPart = SE_SECURITY_PRIVILEGE;
        EnableSeSecurity.Privileges[0].Luid.HighPart = 0;
        EnableSeSecurity.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        PreviousSize = sizeof(Previous);

        if (AdjustTokenPrivileges( hProcessToken, FALSE, &EnableSeSecurity,
                                   sizeof(EnableSeSecurity), &Previous,
                                   &PreviousSize ) == FALSE) {

            dwErr = GetLastError();
        }
    }



    //
    // Ok, see if we need to read the existing security
    //
    if ( dwErr == ERROR_SUCCESS && (CMD_PRESENT(CmdEdit, pCmdVals) || argc == 2 )) {

        dwErr = GetNamedSecurityInfoA( argv[1], SE_FILE_OBJECT, SACL_SECURITY_INFORMATION,
                                       NULL, NULL, NULL, &pOldAcl, &pInitialSD );
        if ( dwErr != ERROR_SUCCESS ) {

            fprintf(stderr, "Failed to read the security off of %s: %lu\n", argv[1], dwErr);
        }

    }

    //
    // Either display the existing access or do the sets as requested
    //
    if (dwErr == ERROR_SUCCESS && argc == 2) {

        dwErr = DisplayAcl ( argv[1], pOldAcl, pStrRights, cStrRights );

    } else {

        //
        // Ok, first we do the revokes
        //
        if (dwErr == ERROR_SUCCESS && CMD_PRESENT(CmdRevoke, pCmdVals)) {

            PACL    pNewAcl;

            //
            // Make sure we've read it first...
            //
            if (CMD_PRESENT(CmdEdit, pCmdVals)) {

                dwErr = ProcessOperation( argv, &pCmdVals[CmdRevoke], REVOKE_ACCESS, pStrRights,
                                          cStrRights, fInherit, pOldAcl, &pNewAcl );

                if (dwErr == ERROR_SUCCESS) {

                    LocalFree(pOldAcl);
                    pOldAcl = pNewAcl;
                }

            } else {

                dwErr = ERROR_INVALID_PARAMETER;
            }

        }

        //
        // Then the audit failures
        //
        if (dwErr == ERROR_SUCCESS && CMD_PRESENT(CmdFail, pCmdVals)) {

            dwErr = ProcessOperation(argv, &pCmdVals[CmdFail], SET_AUDIT_FAILURE, pStrRights,
                                     cStrRights, 0, NULL, &pFailAcl);
        }

        //
        // Finally, the audit success
        //
        if (dwErr == ERROR_SUCCESS && CMD_PRESENT(CmdSuccess, pCmdVals)) {

            dwErr = ProcessOperation(argv, &pCmdVals[CmdSuccess], SET_AUDIT_SUCCESS, pStrRights,
                                     cStrRights, 0, NULL, &pSuccessAcl);

        }



        //
        // Finally, do the set
        //
        if (dwErr == ERROR_SUCCESS) {

            PACL    pNewAcl;
            USHORT  usSize = 0;

            //
            // In order to do this, we'll have to combine any of the up to 3 acls we created
            // above.  The order will be:
            //      FAILURE
            //      SUCCESS
            //      OLD SACL
            //
            if ( pOldAcl != NULL ) {

                usSize += pOldAcl->AclSize;
            }

            if ( pFailAcl != NULL ) {

                usSize += pFailAcl->AclSize;
            }

            if ( pSuccessAcl != NULL ) {

                usSize += pSuccessAcl->AclSize;
            }

            ASSERT(usSize != 0);

            pNewAcl = (PACL)LocalAlloc(LMEM_FIXED, sizeof(ACL) + usSize);

            if ( pNewAcl == NULL ) {

                dwErr = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                pNewAcl->AclRevision = ACL_REVISION2;
                pNewAcl->Sbz1 = 0;
                pNewAcl->AclSize = usSize + sizeof(ACL);
                pNewAcl->AceCount = 0;
                pNewAcl->Sbz2 = 0;

                if( pFailAcl != NULL ) {

                    dwErr = MergeAcls( pFailAcl, pNewAcl );

                }

                if( pSuccessAcl != NULL ) {

                    dwErr = MergeAcls( pSuccessAcl, pNewAcl );

                }


                if( pOldAcl != NULL ) {

                    dwErr = MergeAcls( pOldAcl, pNewAcl );
                }

            }

            if (dwErr == ERROR_SUCCESS ) {

                dwErr = SetAndPropagateFileRights(argv[1], pNewAcl, SACL_SECURITY_INFORMATION,
                                                  CMD_PRESENT(CmdTree, pCmdVals),
                                                  CMD_PRESENT(CmdContinue, pCmdVals), TRUE,
                                                  fInherit);

                LocalFree(pNewAcl);
            }
        }

        if (dwErr == ERROR_INVALID_PARAMETER) {

            Usage( pStrRights, cStrRights, pCmdVals );
        }

        LocalFree(pInitialSD);
    }

    LocalFree(pOldAcl);
    LocalFree(pFailAcl);
    LocalFree(pSuccessAcl);

    if(dwErr == ERROR_SUCCESS) {

        printf("The command completed successfully\n");

    } else {

        printf("The command failed with an error %lu\n", dwErr);

    }

    return(dwErr == 0 ? 0 : 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\delegate\delegate.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    delegate.c

Abstract:

    This Module implements the delegation tool, which allows for the management
    of access to DS objects

Author:

    Mac McLain  (MacM)    10-02-96

Environment:

    User Mode

Revision History:

--*/

#include <delegate.h>



__cdecl main(
    IN  INT     argc,
    IN  CHAR   *argv[]
    )
/*++

Routine Description:

    The MAIN for this executable


Arguments:

    argc - The count of arguments
    argv - The list of arguments

Return Value:

    0 - Success
    1 - Failure

--*/
{

    DWORD               dwErr = ERROR_SUCCESS;
    PWSTR               pwszObjPath = NULL;
    ULONG               fAccessFlags = 0;
    PWSTR               rgwszObjIds[UNKNOWN_ID];
    PACTRL_ACCESSW      rgpDefObjAccess[MAX_DEF_ACCESS_ID + 1];
    PACTRL_ACCESSW      pCurrentAccess = NULL;
    PACTRL_ACCESSW      pAccess = NULL;
    DWORD               i;
    DWORD               cUsed;

    memset(rgwszObjIds, 0, sizeof(rgwszObjIds));
    memset(rgpDefObjAccess, 0, sizeof(rgpDefObjAccess));

    //
    // Temporary inclusion, until the new ADVAPI32.DLL is built
    //
    AccProvInit(dwErr);
    if(dwErr != ERROR_SUCCESS)
    {
        fprintf(stderr,
                "Failed to initialize the security apis: %lu\n",
                dwErr);
    }


    //
    // Ok, parse the command line
    //
    if(argc < 2)
    {
        Usage();
        exit(1);
    }

    //
    // See if we need help
    //
    if(strlen(argv[1]) == 2 && IS_ARG_SWITCH(argv[1]) && argv[1][1] == '?')
    {
        Usage();
        exit(1);
    }

    //
    // Ok, convert our OU parameter into a WIDE string, so we can do what we
    // have to
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = ConvertStringAToStringW(argv[1], &pwszObjPath);
    }

    //
    // Ok, first, we initialize our ID list from the DS schema
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = InitializeIdAndAccessLists(pwszObjPath,
                                           rgwszObjIds,
                                           rgpDefObjAccess);
    }

    //
    // Make sure we're actually dealing with an OU
    //
    if(dwErr == ERROR_SUCCESS)
    {
        BOOL    fIsOU = FALSE;

        dwErr = IsPathOU(pwszObjPath,
                         &fIsOU);
        if(dwErr == ERROR_SUCCESS)
        {
            if(fIsOU == FALSE)
            {
                fprintf(stderr,
                        "%ws is not an Organizational Unit\n",
                        pwszObjPath);
                dwErr = ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            fprintf(stderr,
                    "Failed to determine the status of %ws\n",
                    pwszObjPath);
        }
    }
    else
    {

        fprintf(stderr,"Initialization failed\n");
    }

    //
    // First pass through the command line.  We'll read off our flags.  We
    // need this to determine whether to do the initial read or not
    //
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // First, go through and look for all of our flags
        //
        for(i = 2; i < (DWORD)argc; i++)
        {
            if(IS_ARG_SWITCH(argv[i]))
            {
                if(_stricmp(argv[i] + 1, "T") == 0 ||
                                        _stricmp(argv[i] + 1, "reseT") == 0)
                {
                    fAccessFlags |= D_REPLACE;
                }
                else if(_stricmp(argv[i] + 1, "I") == 0 ||
                                        _stricmp(argv[i] + 1, "Inherit") == 0)
                {
                    fAccessFlags |= D_INHERIT;
                }
                else if(_stricmp(argv[i] + 1, "P") == 0 ||
                                      _stricmp(argv[i] + 1, "Protected") == 0)
                {
                    fAccessFlags |= D_PROTECT;
                }
            }
        }
    }


    //
    // See if we need to read the current access, which is if we are simply
    // displaying the current security, or editing the existing security
    //
    if(dwErr == ERROR_SUCCESS && (argc == 2 ||
                                            (fAccessFlags & D_REPLACE) == 0))
    {
        //
        // GetNamedSecurityInfoEx is a NT 5 API
        //
        dwErr = GetNamedSecurityInfoEx(pwszObjPath,
                                       SE_DS_OBJECT_ALL,
                                       DACL_SECURITY_INFORMATION,
                                       L"Windows NT Access Provider",
                                       NULL,
                                       &pCurrentAccess,
                                       NULL,
                                       NULL,
                                       NULL);

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // See if we were supposed to display it
            //
            if(argc == 2)
            {
                DumpAccess(pwszObjPath,
                           pCurrentAccess,
                           rgwszObjIds);
            }
        }
        else
        {
            fprintf(stderr,
                    "Failed to read the current security from %ws\n",
                    pwszObjPath);
        }
    }

    //
    // Ok, now process the command line again, and do the necessary operations
    //
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // First, go through and look for all of our flags
        //
        i = 2;

        while(dwErr == ERROR_SUCCESS && i < (DWORD)argc)
        {
            if(IS_ARG_SWITCH(argv[i]))
            {
                if(_stricmp(argv[i] + 1, "T") == 0 ||
                                        _stricmp(argv[i] + 1, "reseT") == 0)
                {
                    //
                    // already processed above
                    //
                }
                else if(_stricmp(argv[i] + 1, "I") == 0 ||
                                        _stricmp(argv[i] + 1, "Inherit") == 0)
                {
                    //
                    // already processed above
                    //
                }
                else if(_stricmp(argv[i] + 1, "P") == 0 ||
                                      _stricmp(argv[i] + 1, "Protected") == 0)
                {
                    //
                    // already processed above
                    //
                }
                else if(_stricmp(argv[i] + 1, "R") == 0 ||
                                      _stricmp(argv[i] + 1, "Revoke") == 0)
                {
                    dwErr = ProcessCmdlineUsers(pCurrentAccess,
                                                argv,
                                                argc,
                                                i,
                                                REVOKE,
                                                fAccessFlags,
                                                rgwszObjIds,
                                                rgpDefObjAccess,
                                                &cUsed,
                                                &pAccess);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        LocalFree(pCurrentAccess);
                        pCurrentAccess = pAccess;

                        i += cUsed;
                    }
                }
                else if(_stricmp(argv[i] + 1, "G") == 0 ||
                                      _stricmp(argv[i] + 1, "Grant") == 0)
                {
                    dwErr = ProcessCmdlineUsers(pCurrentAccess,
                                                argv,
                                                argc,
                                                i,
                                                GRANT,
                                                fAccessFlags,
                                                rgwszObjIds,
                                                rgpDefObjAccess,
                                                &cUsed,
                                                &pAccess);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        LocalFree(pCurrentAccess);
                        pCurrentAccess = pAccess;

                        i += cUsed;
                    }
                }
                else if(_stricmp(argv[i] + 1, "D") == 0 ||
                                      _stricmp(argv[i] + 1, "Deny") == 0)
                {
                    dwErr = ProcessCmdlineUsers(pCurrentAccess,
                                                argv,
                                                argc,
                                                i,
                                                DENY,
                                                fAccessFlags,
                                                rgwszObjIds,
                                                rgpDefObjAccess,
                                                &cUsed,
                                                &pAccess);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        LocalFree(pCurrentAccess);
                        pCurrentAccess = pAccess;

                        i += cUsed;
                    }
                }
                else
                {
                    //
                    // Some unknown command line parameter
                    //
                    fprintf(stderr,
                            "Unrecognized command line parameter: %s\n",
                            argv[i]);
                    dwErr = ERROR_INVALID_PARAMETER;
                }
            }

            i++;
        }
    }

    //
    // Finally, set the access as requested
    //
    if(dwErr == ERROR_SUCCESS && pAccess != NULL)
    {
        //
        // SetNamedSecurityInfoEx is a NT 5 API
        //
        dwErr = SetNamedSecurityInfoEx(pwszObjPath,
                                       SE_DS_OBJECT_ALL,
                                       DACL_SECURITY_INFORMATION,
                                       L"Windows NT Access Provider",
                                       pCurrentAccess,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL);
        if(dwErr != ERROR_SUCCESS)
        {
            fprintf(stderr,
                    "Delegate failed to write the new access to %ws\n",
                    pwszObjPath);
        }
    }

    //
    // Last little informative message...
    //
    if(dwErr == ERROR_PATH_NOT_FOUND)
    {
        fprintf(stderr,
                "DELEGATE did not recognize %ws as a DS path\n",
                pwszObjPath);
    }

    //
    // Free all our allocated memory
    //
    FreeIdAndAccessList(rgwszObjIds,
                        rgpDefObjAccess);
    LocalFree(pwszObjPath);
    LocalFree(pCurrentAccess);

    if(dwErr == ERROR_SUCCESS)
    {
        fprintf(stdout,
                "The command completed successfully.\n");
    }

    return(dwErr == ERROR_SUCCESS ? 0 : 1);
}



VOID
DumpAccess (
    IN  PWSTR           pwszObject,
    IN  PACTRL_ACCESSW  pAccess,
    IN  PWSTR          *ppwszIDs
)
/*++

Routine Description:

    This routine will display the given actrl_access list to stdout


Arguments:

    pwszObject - The path to the object being displayed
    pAccess - The access list to display
    ppwszIDs - The list of property/control ids read from the schema.  Used
               to assign a name to the property list.


Return Value:

    VOID

--*/
{
    ULONG           iProp, iEnt, i;
    ULONG           Inherit;
    ACCESS_RIGHTS   Access;
    PWSTR           pwszTag = NULL;
    PWSTR           pwszPropertyTag = L"Object or Property:";
    PWSTR rgwszInheritTags[] = {L"None",
                                L"Object",
                                L"Container",
                                L"Inherit, no propagate",
                                L"Inherit only",
                                L"Inherited"};

    PWSTR rgwszAccessTags[] = {L"None",
                               L"Delete",
                               L"Read Security Information",
                               L"Change Security Information",
                               L"Change owner",
                               L"Synchronize",
                               L"Open Object",
                               L"Create Child",
                               L"Delete Child",
                               L"List contents",
                               L"Write Self",
                               L"Read Property",
                               L"Write Property"};

    ACCESS_RIGHTS   rgAccess[] = {0,
                                  ACTRL_DELETE,
                                  ACTRL_READ_CONTROL,
                                  ACTRL_CHANGE_ACCESS,
                                  ACTRL_CHANGE_OWNER,
                                  ACTRL_SYNCHRONIZE,
                                  ACTRL_DS_OPEN,
                                  ACTRL_DS_CREATE_CHILD,
                                  ACTRL_DS_DELETE_CHILD,
                                  ACTRL_DS_LIST,
                                  ACTRL_DS_SELF,
                                  ACTRL_DS_READ_PROP,
                                  ACTRL_DS_WRITE_PROP};

    PWSTR           rgwszPropTags[] = {L"User object",
                                       L"Group object",
                                       L"Printer object",
                                       L"Volume object",
                                       L"Organizational Unit object",
                                       L"Change group membership property",
                                       L"Change password property",
                                       L"Account control property",
                                       L"Local Group object"};

    //
    // These [currently string versions of valid] IDs are currently planned to
    // be publicly defined for the product.  They are included below only due
    // to the fact that is no current public definition (as it is not
    // necessary for anyone else to need them), and the delegate tool needs
    // to be able to display a friendly name for it.  DO NOT RELY ON THE
    // FOLLOWING DEFINITIONS REMAINING CONSTANT.
    //
    PWSTR           rgwszDSControlIds[] = {
                                    L"ab721a50-1e2f-11d0-9819-00aa0040529b",
                                    L"ab721a51-1e2f-11d0-9819-00aa0040529b"};

    PWSTR           rgwszDSControlTrags[] = {
                                    L"List Domain Accounts",
                                    L"Lookup Domains"
                                    };



    //
    // Don't dump something that doesn't exist...
    //
    if(pAccess == NULL)
    {
        return;
    }

    fprintf(stdout, "Displaying access list for object %ws\n", pwszObject);
    fprintf(stdout, "\tNumber of property lists: %lu\n", pAccess->cEntries);
    for(iProp = 0; iProp < pAccess->cEntries; iProp++)
    {
        if(pAccess->pPropertyAccessList[iProp].lpProperty != NULL)
        {
            pwszTag = NULL;
            //
            // Find it in our list, so we can display the right value
            //
            for(i = 0; i < UNKNOWN_ID; i++)
            {
                if(_wcsicmp(pAccess->pPropertyAccessList[iProp].lpProperty,
                            ppwszIDs[i]) == 0)
                {
                    pwszTag = rgwszPropTags[i];
                    break;
                }
            }

            //
            // Look up the list of DS control rights
            //
            for(i = 0;
                i < sizeof(rgwszDSControlIds) / sizeof(PWSTR) &&
                                                              pwszTag == NULL;
                i++)
            {
                if(_wcsicmp(pAccess->pPropertyAccessList[iProp].lpProperty,
                            rgwszDSControlIds[i]) == 0)
                {
                    pwszTag = rgwszDSControlTrags[i];
                    pwszPropertyTag = L"DS Control right id:";
                    break;
                }
            }

            if(pwszTag == NULL)
            {
                fprintf(stdout,
                        "\t\tUnrecognized property whose id is %ws\n",
                        pAccess->pPropertyAccessList[iProp].lpProperty);
            }
            else
            {
                fprintf(stdout, "\t\t%ws %ws\n", pwszPropertyTag, pwszTag);
            }
        }
        else
        {
            fprintf(stdout, "\t\tObject: %ws\n", pwszObject);
        }

        //
        // Is it protected?
        //
        if(pAccess->pPropertyAccessList[iProp].fListFlags != 0)
        {
            if((pAccess->pPropertyAccessList[iProp].fListFlags &
                                                 ACTRL_ACCESS_PROTECTED) != 0)
            {
                fprintf(stdout,"\t\tAccess list is protected\n");
            }
        }

        if(pAccess->pPropertyAccessList[iProp].pAccessEntryList == NULL)
        {
            fprintf(stdout,"\t\tpAccessEntryList: NULL\n");
        }
        else
        {
            PACTRL_ACCESS_ENTRYW pAE= pAccess->pPropertyAccessList[iProp].
                                            pAccessEntryList->pAccessList;
            fprintf(stdout,
                    "\t\t\t%lu Access Entries for this object or property\n",
                   pAccess->pPropertyAccessList[iProp].pAccessEntryList->
                                                                cEntries);

            for(iEnt = 0;
                iEnt < pAccess->pPropertyAccessList[iProp].
                                               pAccessEntryList->cEntries;
                iEnt++)
            {
                //
                // Type of entry
                //
                if(pAE[iEnt].fAccessFlags == ACTRL_ACCESS_ALLOWED)
                {
                    fprintf(stdout,
                            "\t\t\t[%lu] Access Allowed entry\n",
                            iEnt);
                }
                else if(pAE[iEnt].fAccessFlags == ACTRL_ACCESS_DENIED)
                {
                    fprintf(stdout,
                            "\t\t\t[%lu] Access Denied entry\n",
                            iEnt);
                }
                else
                {
                    fprintf(stdout,"\t\t\t[%lu]", iEnt);
                    if((pAE[iEnt].fAccessFlags & ACTRL_AUDIT_SUCCESS) != 0)
                    {
                        fprintf(stdout,"Success Audit");
                    }
                    if((pAE[iEnt].fAccessFlags & ACTRL_AUDIT_FAILURE) != 0)
                    {
                        if((pAE[iEnt].fAccessFlags & ACTRL_AUDIT_SUCCESS) != 0)
                        {
                            fprintf(stdout," | ");
                        }
                        fprintf(stdout,"Failure Audit");
                    }
                    fprintf(stdout," entry\n");
                }

                //
                //  User name
                //
                fprintf(stdout,"\t\t\t\tUser: %ws\n",
                       pAE[iEnt].Trustee.ptstrName);

                //
                // Access rights
                //
                fprintf(stdout,"\t\t\t\tAccess:  ");
                Access = pAE[iEnt].Access;
                if(Access == 0)
                {
                    fprintf(stdout,"%ws\n", rgwszAccessTags[0]);
                }
                else
                {
                    for(i = 1;
                        i < sizeof(rgwszAccessTags) / sizeof(PWSTR);
                        i++)
                    {
                        if((Access & rgAccess[i]) != 0)
                        {
                            fprintf(stdout,"%ws", rgwszAccessTags[i]);
                            Access &= ~(rgAccess[i]);

                            if(Access != 0)
                            {
                                fprintf(stdout,
                                        "  |\n\t\t\t\t         ");
                            }
                        }
                    }

                    if(Access != 0)
                    {
                        fprintf(stdout,
                                "Unrecognized rights: 0x%lx\n",
                                Access);
                    }

                    fprintf(stdout,"\n");
                }

                //
                // Inheritance
                //
                fprintf(stdout,"\t\t\t\tInheritance:  ");
                Inherit = pAE[iEnt].Inheritance;
                if(Inherit == 0)
                {
                    fprintf(stdout,"%ws\n", rgwszInheritTags[0]);
                }
                else
                {
                    for(i = 0;
                        i < sizeof(rgwszInheritTags) / sizeof(PWSTR);
                        i++)
                    {
                        if((Inherit & 1 << i) != 0)
                        {
                            fprintf(stdout,"%ws", rgwszInheritTags[i + 1]);
                            Inherit &= ~(1 << i);

                            if(Inherit == 0)
                            {
                                fprintf(stdout,"\n");
                            }
                            else
                            {
                                fprintf(stdout,
                                        "  |\n\t\t\t\t              ");
                            }
                        }
                    }
                }

                if(pAE[iEnt].lpInheritProperty != NULL)
                {
                    pwszTag = NULL;
                    //
                    // Find it in our list, so we can display the right value
                    //
                    for(i = 0; i < UNKNOWN_ID; i++)
                    {
                        if(_wcsicmp(pAE[iEnt].lpInheritProperty,
                                    ppwszIDs[i]) == 0)
                        {
                            pwszTag = rgwszPropTags[i];
                            break;
                        }
                    }

                    if(pwszTag == NULL)
                    {
                        fprintf(stdout,
                                "\t\t\t\tUnrecognized inherit to object "
                                "whose id is %ws\n",
                                pAE[iEnt].lpInheritProperty);
                    }
                    else
                    {
                        fprintf(stdout,
                                "\t\t\t\tObject to inherit to: %ws\n",
                                pwszTag);
                    }

                }
            }
        }

        printf("\n");
    }
}




VOID
Usage (
    )
/*++

Routine Description:

    This routine will display the expected command line usage

Arguments:

    None

Return Value:

    VOID

--*/
{

fprintf(stdout,
        "Delegates administrative privileges on a directory OU\n");
fprintf(stdout, "\n");
fprintf(stdout,
        "DELEGATE <ou> [/T] [/I] [/P] [/G user:perm] [/D user:perm [...]] "
        "[/R user [...]]\n");
fprintf(stdout, "\n");
fprintf(stdout,"  <ou>\tOU to modify or display the rights for\n");
fprintf(stdout,"  /T\tReplace the access instead of editing it.\n");
fprintf(stdout,"  /I\tInherit to all subcontainers in the directory.\n");
fprintf(stdout,"  /P\tMark the object as protected following the operation\n");
fprintf(stdout,"  /G  user:perm\tGrant specified user admin access rights.\n");
fprintf(stdout,"  /D  user:perm\tDeny specified user admin access rights.\n");
fprintf(stdout,"  \tPerm can be:\n");
fprintf(stdout,"  \t\tAbility to create/manage objects in this container\n");
fprintf(stdout,"  \t\t\t%2s  Create/Manage All object types\n",D_ALL);
fprintf(stdout,"  \t\t\t%2s  Create/Manage Users\n", D_USER);
fprintf(stdout,"  \t\t\t%2s  Create/Manage Groups\n", D_GROUP);
fprintf(stdout,"  \t\t\t%2s  Create/Manage Printers\n", D_PRINT);
fprintf(stdout,"  \t\t\t%2s  Create/Manage Volumes\n", D_VOL);
fprintf(stdout,"  \t\t\t%2s  Create/Manage OUs\n", D_OU);
fprintf(stdout,"  \t\tAbility to modify specific user or group "
        "properties\n");
fprintf(stdout,"  \t\t\t%2s  Change Group membership for "
        "all groups\n", D_MEMBERS);
fprintf(stdout,"  \t\t\t%2s  Set User Passwords\n", D_PASSWD);
fprintf(stdout,"  \t\t\t%2s  Enable/Disable user accounts\n", D_ENABLE);
fprintf(stdout, "\n");
fprintf(stdout,"  /R user  Revoke\tSpecified user's access rights (only valid "
        "without /E).\n");
fprintf(stdout, "\n");
fprintf(stdout,"You can specify more than one user in a command and "
               "more than one perm per user, seperated by a , (comma).\n");

}




DWORD
ConvertStringAToStringW (
    IN  PSTR            pszString,
    OUT PWSTR          *ppwszString
)
/*++

Routine Description:

    This routine will convert an ASCII string to a UNICODE string.

    The returned string buffer must be freed via a call to LocalFree


Arguments:

    pszString - The string to convert
    ppwszString - Where the converted string is returned

Return Value:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{

    if(pszString == NULL)
    {
        *ppwszString = NULL;
    }
    else
    {
        ULONG cLen = strlen(pszString);
        *ppwszString = (PWSTR)LocalAlloc(LMEM_FIXED,sizeof(WCHAR) *
                                  (mbstowcs(NULL, pszString, cLen + 1) + 1));
        if(*ppwszString  != NULL)
        {
             mbstowcs(*ppwszString,
                      pszString,
                      cLen + 1);
        }
        else
        {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return(ERROR_SUCCESS);
}




DWORD
ConvertStringWToStringA (
    IN  PWSTR           pwszString,
    OUT PSTR           *ppszString
)
/*++

Routine Description:

    This routine will convert a UNICODE string to an ANSI string.

    The returned string buffer must be freed via a call to LocalFree


Arguments:

    pwszString - The string to convert
    ppszString - Where the converted string is returned

Return Value:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{

    if(pwszString == NULL)
    {
        *ppszString = NULL;
    }
    else
    {
        ULONG cLen = wcslen(pwszString);
        *ppszString = (PSTR)LocalAlloc(LMEM_FIXED,sizeof(CHAR) *
                                  (wcstombs(NULL, pwszString, cLen + 1) + 1));
        if(*ppszString  != NULL)
        {
             wcstombs(*ppszString,
                      pwszString,
                      cLen + 1);
        }
        else
        {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return(ERROR_SUCCESS);
}




DWORD
InitializeIdAndAccessLists (
    IN  PWSTR           pwszOU,
    IN  PWSTR          *ppwszObjIdList,
    IN  PACTRL_ACCESS  *ppDefObjAccessList
    )
/*++

Routine Description:

    This routine will read the list of object ids from the schema for the
    object types as indicated by DELEGATE_OBJ_ID enumeration.

    The returned access list needs to be processed by FreeIdList.

Arguments:

    pwszOU - Information on the domain for which to query the schema
    ppwszObjIdList - The list of object ids to initialize.  The list must
                     already exist and must of the proper size



Return Value:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed
    ERROR_INVALID_PARAMETER - The OU given was not correct

--*/
{
    DWORD   dwErr = ERROR_SUCCESS;
    DWORD   i;
    PSTR    pszSchemaPath = NULL;
    PLDAP   pLDAP;

    //
    // Build a list of attributes to read
    //
    PSTR    pszAttribs[] = {"User",                 // USER_ID
                            "Group",                // GROUP_ID
                            "Print-Queue",          // PRINT_ID
                            "Volume",               // VOLUME_ID
                            "Organizational-Unit",  // OU_ID
                            "Member",               // MEMBER_ID
                            "User-Password",        // PASSWD_ID
                            "User-Account-Control", // ACCTCTRL_ID
                            "LocalGroup"            // LOCALGRP_ID
                            };

    //
    // Get the path to the schema
    //
    dwErr = LDAPReadSchemaPath(pwszOU,
                               &pszSchemaPath,
                               &pLDAP);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Ok, now, we need to query the schema for the information
        //
        for(i = 0; i < UNKNOWN_ID && dwErr == ERROR_SUCCESS; i++)
        {
            //
            // Get the info from the schema
            //
            dwErr = LDAPReadSecAndObjIdAsString(pLDAP,
                                                pszSchemaPath,
                                                pszAttribs[i],
                                                &(ppwszObjIdList[i]),
                                                i > MAX_DEF_ACCESS_ID ?
                                                    NULL    :
                                                    &(ppDefObjAccessList[i]));
        }


        LocalFree(pszSchemaPath);
        LDAPUnbind(pLDAP);
    }

    return(dwErr);
}



VOID
FreeIdAndAccessList (
    IN  PWSTR          *ppwszObjIdList,
    IN  PACTRL_ACCESS  *ppDefObjAccessList

    )
/*++

Routine Description:

    This routine will process the list of Ids and determine if any of them
    have been converted to strings.  If so, it deallocates the memory

Arguments:

    pObjIdList - The list of object ids to free


Return Value:

    VOID

--*/
{
    DWORD   i;

    for(i = 0; i < UNKNOWN_ID; i++)
    {
        RpcStringFree(&(ppwszObjIdList[i]));

        if(i <= MAX_DEF_ACCESS_ID)
        {
            LocalFree(ppDefObjAccessList[i]);
        }
    }
}



DWORD
ProcessCmdlineUsers (
    IN  PACTRL_ACCESSW      pAccessList,
    IN  CHAR               *argv[],
    IN  INT                 argc,
    IN  DWORD               iStart,
    IN  DELEGATE_OP         Op,
    IN  ULONG               fFlags,
    IN  PWSTR              *ppwszIDs,
    IN  PACTRL_ACCESS      *ppDefObjAccessList,
    OUT PULONG              pcUsed,
    OUT PACTRL_ACCESSW     *ppNewAccess
    )
/*++

Routine Description:

    This routine will process the command line for any users to have
    access added/denied.  If any entries are found, the access list will be
    appropriately updated.

    The returned access list must be freed via a call to LocalFree


Arguments:

    pAccessList - The current access list
    argv - List of command line arguments
    argc - count of command line arguments
    iStart - Where in the command line does the current argument start
    Op   - Type of operation (grant, revoke, etc) to perform
    fInherit - Whether to do inheritance or not
    fProtected - Whether to mark the entries as protected
    ppwszIDs - List of supported IDs
    pcUsed - Number of items command line items used
    ppNewAccess - Where the new access list is returned.  Only valid if
                  returned count of revoked items is non-0


Return Value:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD                   dwErr = ERROR_SUCCESS;
    DWORD                   i;
    PACTRL_ACCESSW          pListToFree = NULL;

    *pcUsed = 0;
    iStart++;

    //
    // Process all the entries until we find the next seperator or the end of
    // the list
    //
    while(iStart + *pcUsed < (DWORD)argc &&
          !IS_ARG_SWITCH(argv[iStart + *pcUsed]) &&
          dwErr == ERROR_SUCCESS)
    {
        PWSTR       pwszUser = NULL;
        PSTR        pszAccess;
        PSTR        pszAccessStart;

        //
        // Get the user name and the list of arguments, if it exists
        //
        dwErr = GetUserInfoFromCmdlineString(argv[iStart + *pcUsed],
                                             &pwszUser,
                                             &pszAccessStart);
        if(dwErr == ERROR_SUCCESS)
        {
            pszAccess = pszAccessStart;
            //
            // Should we have arguments?  All except for the revoke case, we
            // should
            //
            if(pszAccess == NULL && Op != REVOKE)
            {
                fprintf(stderr,
                        "Missing permissions for %ws\n",
                        pwszUser);
                dwErr = ERROR_INVALID_PARAMETER;
            }
        }


        //
        // Ok, now we'll have to process the list, and actually build the
        // access entries
        //
        if(dwErr == ERROR_SUCCESS)
        {
            DWORD   iIndex = 0;

            //
            // Reset our list of entries...
            //
            pszAccess = pszAccessStart;
            while(dwErr == ERROR_SUCCESS)
            {
                PSTR    pszNext = NULL;

                if(pszAccess != NULL)
                {
                    pszNext = strchr(pszAccess, ',');

                    if(pszNext != NULL)
                    {
                        *pszNext = '\0';
                    }
                }

                dwErr = AddAccessEntry(pAccessList,
                                       pszAccess,
                                       pwszUser,
                                       Op,
                                       ppwszIDs,
                                       ppDefObjAccessList,
                                       fFlags,
                                       ppNewAccess);
                //
                // Restore our string
                //
                if(pszNext != NULL)
                {
                    *pszNext = ',';
                    pszNext++;
                }

                pszAccess = pszNext;

                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // We don't want to free the original list, since that
                    // is what we were given to start with...
                    //
                    LocalFree(pListToFree);
                    pAccessList = *ppNewAccess;
                    pListToFree = pAccessList;
                }
                else
                {
                    if(dwErr == ERROR_NONE_MAPPED)
                    {
                        fprintf(stderr,"Unknown user %ws specified\n",
                                pwszUser);
                    }
                }

                if(Op == REVOKE || pszAccess == NULL)
                {
                    break;
                }
            }
        }

        (*pcUsed)++;
    }

    if(*pcUsed == 0)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        fprintf(stderr,"No user information was supplied!\n");
    }

    return(dwErr);
}




DWORD
GetUserInfoFromCmdlineString (
    IN  PSTR            pszUserInfo,
    OUT PWSTR          *ppwszUser,
    OUT PSTR           *ppszAccessStart
)
/*++

Routine Description:

    This routine will process the command line for any user to convert the
    user name to a wide string, and optionally get the access, if it exists

    The returned user must be freed via a call to LocalFree


Arguments:

    pszUserInfo - The user info to convert.  In the form of username or
                  username:access
    ppwszUser - Where to return the user name
    pAccess - Where the access is returned

Return Value:

    ERROR_SUCCESS - Success

--*/
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, find the seperator, if it exists
    //
    PSTR pszSep = strchr(pszUserInfo, ':');
    if(pszSep != NULL)
    {
        *pszSep = '\0';
    }

    //
    // Convert our user name
    //
    dwErr = ConvertStringAToStringW(pszUserInfo,
                                    ppwszUser);

    if(pszSep != NULL)
    {
        *pszSep = ':';
        pszSep++;
    }

    *ppszAccessStart = pszSep;

    return(dwErr);
}



DWORD
AddAccessEntry (
    IN  PACTRL_ACCESSW      pAccessList,
    IN  PSTR                pszAccess,
    IN  PWSTR               pwszTrustee,
    IN  DELEGATE_OP         Op,
    IN  PWSTR              *ppwszIDs,
    IN  PACTRL_ACCESS      *ppDefObjAccessList,
    IN  ULONG               fFlags,
    OUT PACTRL_ACCESSW     *ppNewAccess
)
/*++

Routine Description:

    This routine will add a new access entry to the list based upon the access
    action string and the operation.  The pointer to the index variable will
    indicate where in the list it goes, and will be updated to point to the
    next entry on return.


Arguments:

    pAccessList - The current access list.  Can be NULL.
    pszAccess - User access string to add
    pwszTrustee - The user for which an entry is being created
    Op   - Type of operation (grant, revoke, etc) to perform
    ppwszIDs - List of object IDs from the DS Schema
    fFlags - Whether to do inheritance, protection, etc
    ppNewAccess - Where the new access list is returned.


Return Value:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD           dwErr = ERROR_SUCCESS;
    DWORD           i,j,k,iIndex = 0;
    PWSTR           pwszProperty = NULL;
    ULONG           cEntries = 0;
    BOOL            fInherit;
    ACCESS_MODE     Access[] = {REVOKE_ACCESS,
                                GRANT_ACCESS,
                                GRANT_ACCESS};
    ULONG           Flags[] = {0,
                               ACTRL_ACCESS_ALLOWED,
                               ACTRL_ACCESS_DENIED};
    //
    // The most we add is 3 entries at a time...  (2 per items, 1 inheritable)
    //
    ACTRL_ACCESS_ENTRYW AccList[3];
    memset(&AccList, 0, sizeof(AccList));

    fInherit =  (BOOL)(fFlags & D_INHERIT);
    if(Op == REVOKE)
    {
        BuildTrusteeWithName(&(AccList[cEntries].Trustee),
                             pwszTrustee);
    }
    else
    {
        //
        // GroupMembership
        //
        if(_stricmp(pszAccess, D_MEMBERS) == 0)
        {
            //
            // This gets 1 access entry: WriteProp
            //
            AccList[cEntries].lpInheritProperty = ppwszIDs[GROUP_ID];
            AccList[cEntries].Inheritance = INHERIT_ONLY | fInherit ?
                                      SUB_CONTAINERS_AND_OBJECTS_INHERIT :
                                      0;
            BuildTrusteeWithName(&(AccList[cEntries].Trustee),
                                 pwszTrustee);

            AccList[cEntries].fAccessFlags = Flags[Op];
            AccList[cEntries].Access = ACTRL_DS_WRITE_PROP;
            pwszProperty = ppwszIDs[MEMBER_ID];
            iIndex = MEMBER_ID;
            fprintf(stderr,
                    "Sorry... delegation for changing Group membership is "
                    "not supported in this alpha release\n");
            dwErr = ERROR_INVALID_PARAMETER;

        }
        //
        // SetPassword
        //
        else if(_stricmp(pszAccess, D_PASSWD) == 0)
        {
            //
            // This gets 1 access entry: WriteProp
            //
            AccList[cEntries].lpInheritProperty = ppwszIDs[USER_ID];
            AccList[cEntries].Inheritance = INHERIT_ONLY | fInherit ?
                                      SUB_CONTAINERS_AND_OBJECTS_INHERIT :
                                      0;
            BuildTrusteeWithName(&(AccList[cEntries].Trustee),
                                 pwszTrustee);

            AccList[cEntries].fAccessFlags = Flags[Op];
            AccList[cEntries].Access = ACTRL_DS_WRITE_PROP;
            pwszProperty = ppwszIDs[PASSWD_ID];
            iIndex = PASSWD_ID;
            fprintf(stderr,
                    "Sorry... delegation for Set Password is "
                    "not supported in this alpha release\n");
            dwErr = ERROR_INVALID_PARAMETER;
        }
        //
        // Enable/Disable accounts
        //
        else if(_stricmp(pszAccess, D_ENABLE) == 0)
        {
            //
            // This gets 1 access entry: WriteProp
            //
            AccList[cEntries].lpInheritProperty = ppwszIDs[USER_ID];
            AccList[cEntries].Inheritance = INHERIT_ONLY | fInherit ?
                                      SUB_CONTAINERS_AND_OBJECTS_INHERIT :
                                      0;
            BuildTrusteeWithName(&(AccList[cEntries].Trustee),
                                 pwszTrustee);

            AccList[cEntries].fAccessFlags = Flags[Op];
            AccList[cEntries].Access = ACTRL_DS_WRITE_PROP;
            pwszProperty = ppwszIDs[ACCTCTRL_ID];
            iIndex = ACCTCTRL_ID;
            fprintf(stderr,
                    "Sorry... delegation for Enabling and Disabling accounts "
                    " is not supported in this alpha release\n");
            dwErr = ERROR_INVALID_PARAMETER;
        }
        else
        {
            //
            // Some object type...
            //
            if(_stricmp(pszAccess, D_ALL) == 0)         // All
            {
                pwszProperty = NULL;
            }
            else if(_stricmp(pszAccess, D_USER) == 0)   // User
            {
                pwszProperty = ppwszIDs[USER_ID];
                iIndex = USER_ID;
                fprintf(stderr,
                        "Sorry... delegation for user objects is "
                        "not supported in this alpha release\n");
                dwErr = ERROR_INVALID_PARAMETER;
            }
            else if(_stricmp(pszAccess, D_GROUP) == 0)  // Group
            {
                pwszProperty = ppwszIDs[USER_ID];
                iIndex = GROUP_ID;
                fprintf(stderr,
                        "Sorry... delegation for group objects is "
                        "not supported in this alpha release\n");
                dwErr = ERROR_INVALID_PARAMETER;
            }
            else if(_stricmp(pszAccess, D_PRINT) == 0)  // Printers
            {
                pwszProperty = ppwszIDs[PRINT_ID];
                iIndex = PRINT_ID;
            }
            else if(_stricmp(pszAccess, D_VOL) == 0)    // Volumes
            {
                pwszProperty = ppwszIDs[VOLUME_ID];
                iIndex = VOLUME_ID;
            }
            else if(_stricmp(pszAccess, D_OU) == 0)     // OUs
            {
                pwszProperty = ppwszIDs[OU_ID];
                iIndex = OU_ID;
            }
            else
            {
                dwErr = ERROR_INVALID_PARAMETER;
                fprintf(stderr,
                        "Unexpected delegation permission %s given for "
                        "user %ws\n",
                        pszAccess,
                        pwszTrustee);
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Add the create/delete for the user
                //
                BuildTrusteeWithName(&(AccList[cEntries].Trustee),
                                     pwszTrustee);

                AccList[cEntries].fAccessFlags = Flags[Op];
                AccList[cEntries].Access = ACTRL_DS_CREATE_CHILD  |
                                                ACTRL_DS_DELETE_CHILD;
                AccList[cEntries].Inheritance = fInherit ?
                                        SUB_CONTAINERS_AND_OBJECTS_INHERIT :
                                        0;
                //
                // If we are inheriting, make sure we inherit only to the
                // proper property
                //
                if(fInherit == TRUE)
                {
                    AccList[cEntries].lpInheritProperty = pwszProperty;
                }

                //
                // Then the inherit on the child object
                //
                cEntries++;
                AccList[cEntries].Inheritance = INHERIT_ONLY |
                                            (fInherit ?
                                          SUB_CONTAINERS_AND_OBJECTS_INHERIT :
                                          0);
                BuildTrusteeWithName(&(AccList[cEntries].Trustee),
                                     pwszTrustee);

                AccList[cEntries].fAccessFlags = Flags[Op];
                AccList[cEntries].Access = ACTRL_DS_WRITE_PROP  |
                                           ACTRL_DS_READ_PROP   |
                                           ACTRL_DS_LIST        |
                                           ACTRL_DS_SELF;

                AccList[cEntries].lpInheritProperty = pwszProperty;
            }

        }
    }

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // SetEntriesInAccessList is a NT5 API
        //
        dwErr = SetEntriesInAccessList(cEntries + 1,
                                       AccList,
                                       Access[Op],
                                       pwszProperty,
                                       pAccessList,
                                       ppNewAccess);
        //
        // Mark it as protected if we were so asked
        //
        if(dwErr == ERROR_SUCCESS && (fFlags & D_PROTECT) != 0)
        {
            (*ppNewAccess)->pPropertyAccessList[0].fListFlags =
                                                      ACTRL_ACCESS_PROTECTED;
        }
    }

    //
    // Finally, if this was the first entry we were asked to add for this
    // property, we'll have to go get the default security information
    // from the schema, so we can figure out what inherited entries should
    // be on the object, and apply them as object inherit entries for the
    // property
    //
    if(dwErr == ERROR_SUCCESS && iIndex <= MAX_DEF_ACCESS_ID && Op != REVOKE)
    {
        PACTRL_ACCESS   pOldAccess = pAccessList;

        //
        // First, find the property in our list of access entries we
        // created above
        //
        for(i = 0; i <= (*ppNewAccess)->cEntries; i++)
        {
            //
            // We'll do this based on property...  In this case, the only
            // entries we'll be adding will have a property, so we don't have
            // to protect against that...
            //
            if(pwszProperty != NULL &&
               (*ppNewAccess)->pPropertyAccessList[i].lpProperty != NULL &&
               _wcsicmp((*ppNewAccess)->pPropertyAccessList[i].lpProperty,
                        pwszProperty) == 0)
            {
                //
                // If it has more entries that we added, we won't have to
                // worry about it, since the information will already
                // have been added.  Note that in this case, we don't have
                // to worry about pAccessEntryList being null, since we know
                // we have added some valid entries.
                //
                if((*ppNewAccess)->pPropertyAccessList[i].
                                                pAccessEntryList->cEntries ==
                    cEntries + 1)
                {
                    PACTRL_ACCESS   pAddAccess = ppDefObjAccessList[iIndex];
                    pAccessList = *ppNewAccess;

                    //
                    // Ok, we'll have to add them...
                    //
                    for(j = 0;
                        j < (DWORD)(pAddAccess->cEntries) &&
                                                        dwErr == ERROR_SUCCESS;
                        j++)
                    {
                        PACTRL_PROPERTY_ENTRY pPPE =
                                        &(pAddAccess->pPropertyAccessList[j]);
                        dwErr = SetEntriesInAccessList(
                                         pPPE->pAccessEntryList->cEntries,
                                         pPPE->pAccessEntryList->pAccessList,
                                         GRANT_ACCESS,
                                         pPPE->lpProperty,
                                         pAccessList,
                                         ppNewAccess);
                        if(dwErr == ERROR_SUCCESS)
                        {
                            pAccessList = *ppNewAccess;
                        }
                    }
                }

                //
                // We don't want to run through the loop anymore
                //
                break;
            }
        }
    }

    return(dwErr);
}




DWORD
IsPathOU (
    IN  PWSTR               pwszOU,
    OUT PBOOL               pfIsOU
)
/*++

Routine Description:

    This routine will determine whether the given path is an OU or not.


Arguments:

    pwszOU - The path into the DS to check on
    ppwszIDs - List of string representations of known IDs
    pfIsOU - Where the results of the test are returned


Return Value:

    ERROR_SUCCESS - Success

--*/
{
    DWORD               dwErr = ERROR_SUCCESS;
    PSTR                pszOU = NULL;
    HANDLE              hDS = NULL;
    PDS_NAME_RESULTA    pNameRes;


    dwErr = ConvertStringWToStringA(pwszOU,
                                    &pszOU);

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = DsBindA(NULL,
                        NULL,
                        &hDS);
    }


    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = DsCrackNamesA(hDS,
                              DS_NAME_NO_FLAGS,
                              DS_UNKNOWN_NAME,
                              DS_FQDN_1779_NAME,
                              1,
                              &pszOU,
                              &pNameRes);

        if(dwErr == ERROR_SUCCESS)
        {
            if(pNameRes->cItems == 0)
            {
                dwErr = ERROR_PATH_NOT_FOUND;
            }
            else
            {
                PSTR    pszName = NULL;
                PLDAP   pLDAP;

                //
                // Now, we'll bind to the object, and then do the read
                //
                dwErr = LDAPBind(pNameRes->rItems[0].pDomain,
                                 &pLDAP);

                if(dwErr == ERROR_SUCCESS)
                {
                    PSTR   *ppszValues;
                    DWORD   cValues;
                    dwErr = LDAPReadAttribute(pszOU,
                                              "objectclass",
                                              pLDAP,
                                              &cValues,
                                              &ppszValues);
                    LDAPUnbind(pLDAP);

                    if(dwErr == ERROR_SUCCESS)
                    {
                        ULONG i;
                        *pfIsOU = FALSE;
                        for(i = 0; i <cValues; i++)
                        {
                            if(_stricmp(ppszValues[i],
                                        "organizationalUnit") == 0)
                            {
                                *pfIsOU = TRUE;
                                break;
                            }
                        }

                        LDAPFreeValues(ppszValues);
                    }
                }
            }

            DsFreeNameResultA(pNameRes);
        }

    }

    if (NULL != pszOU)
    {
        LocalFree(pszOU);
    }
    if (NULL != hDS)
    {
        DsUnBindA(hDS);
    }

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\delegate\delegate.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    delegate.h

Abstract:

    The main header file for the delegate tool

Author:

    Mac McLain  (MacM)    10-02-96

Environment:

    User Mode

Revision History:

--*/

//
// Windows Headers
//
#include <windows.h>
#include <rpc.h>
#include <aclapi.h>
#include <aclapip.h>
#include <winldap.h>
#include <ntdsapi.h>


//
// C-Runtime Header
//
#include <stdio.h>
#include <stdlib.h>


//
// Macro to help determine if a given argument is a swith or not
//
#define IS_ARG_SWITCH(arg)      (arg[0] == '/' || arg[0] == '-')

//
// Type of operation to perform
//
typedef enum _DELEGATE_OP
{
    REVOKE = 0,
    GRANT,
    DENY
} DELEGATE_OP;

//
// Type of object ID we're dealing with
//
typedef enum _DELEGATE_OBJ_ID
{
    USER_ID = 0,
    GROUP_ID,
    PRINT_ID,
    VOLUME_ID,
    OU_ID,
    MEMBER_ID,
    PASSWD_ID,
    ACCTCTRL_ID,
    LOCALGRP_ID,
    UNKNOWN_ID  // This ALWAYS has to be the last item in the enumeration
} DELEGATE_OBJ_ID, *PDELEGATE_OBJ_ID;
#define MAX_DEF_ACCESS_ID   OU_ID       // Last item we need to get the
                                        // default access for


//
// List of permissions to be granted/denied
//
#define D_ALL       "All"
#define D_USER      "User"
#define D_GROUP     "Group"
#define D_PRINT     "Print"
#define D_VOL       "Volume"
#define D_OU        "OU"
#define D_MEMBERS   "Members"
#define D_PASSWD    "Password"
#define D_ENABLE    "EnableAccount"


//
// Options flags
//
#define D_REPLACE   0x00000001L
#define D_INHERIT   0x00000002L
#define D_PROTECT   0x00000004L


//
// Function prototypes (delegate.c)
//
VOID
DumpAccess (
    IN  PWSTR           pwszObject,
    IN  PACTRL_ACCESSW  pAccess,
    IN  PWSTR          *ppwszIDs
    );

VOID
Usage (
    );

DWORD
ConvertStringAToStringW (
    IN  PSTR            pszString,
    OUT PWSTR          *ppwszString
    );

DWORD
ConvertStringWToStringA (
    IN  PWSTR           pwszString,
    OUT PSTR           *ppszString
    );


DWORD
InitializeIdAndAccessLists (
    IN  PWSTR           pwszOU,
    IN  PWSTR          *ppwszObjIdList,
    IN  PACTRL_ACCESS  *ppDefObjAccessList
    );

VOID
FreeIdAndAccessList  (
    IN  PWSTR          *ppwszObjIdList,
    IN  PACTRL_ACCESS  *ppDefObjAccessList
    );

DWORD
ProcessCmdlineUsers (
    IN  PACTRL_ACCESSW      pAccessList,
    IN  CHAR               *argv[],
    IN  INT                 argc,
    IN  DWORD               iStart,
    IN  DELEGATE_OP         Op,
    IN  ULONG               fFlags,
    IN  PWSTR              *ppwszIDs,
    IN  PACTRL_ACCESS      *ppDefObjAccessList,
    OUT PDWORD              pcUsed,
    OUT PACTRL_ACCESSW     *ppNewAccess
    );

DWORD
GetUserInfoFromCmdlineString (
    IN  PSTR            pszUserInfo,
    OUT PWSTR          *ppwszUser,
    OUT PSTR           *ppszAccessStart
    );

DWORD
AddAccessEntry (
    IN  PACTRL_ACCESSW      pAccessList,
    IN  PSTR                pszAccess,
    IN  PWSTR               pwszTrustee,
    IN  DELEGATE_OP         Op,
    IN  PWSTR              *ppwszIDs,
    IN  PACTRL_ACCESS      *ppDefObjAccessList,
    IN  ULONG               fFlags,
    OUT PACTRL_ACCESSW     *ppNewAccess
    );

DWORD
IsPathOU (
    IN  PWSTR               pwszOU,
    OUT PBOOL               pfIsOU
    );



//
// Function prototypes (ldap.c)
//
DWORD
LDAPReadAttribute (
    IN  PSTR        pszOU,
    IN  PSTR        pszAttribute,
    IN  PLDAP       pLDAP,
    OUT PDWORD      pcValues,
    OUT PSTR      **pppszValues
    );

VOID
LDAPFreeValues (
    IN  PSTR       *ppszValues
    );

DWORD
LDAPReadSchemaPath (
    IN  PWSTR       pwszOU,
    OUT PSTR       *ppszSchemaPath,
    OUT PLDAP      *ppLDAP
    );

DWORD
LDAPReadSecAndObjIdAsString (
    IN  PLDAP           pLDAP,
    IN  PSTR            pszSchemaPath,
    IN  PSTR            pszObject,
    OUT PWSTR          *ppwszObjIdAsString,
    OUT PACTRL_ACCESS  *ppAccess
    );

DWORD
LDAPBind (
    IN  PSTR    pszObject,
    OUT PLDAP  *ppLDAP
    );

VOID
LDAPUnbind (
    IN  PLDAP   pLDAP
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\dsacls\dsacls.cpp ===
/*++

Copyright (c) 1996 - 1998  Microsoft Corporation

Module Name:

    dsacls.c

Abstract:

    This Module implements the delegation tool, which allows for the management
    of access to DS objects

Author:

    Mac McLain  (MacM)    10-15-96

Environment:

    User Mode

Revision History:

   Hitesh Raigandhi  (hiteshr  6-29-98)
   1: Changed the code to Old NTMART API's 
   2: Redesigned the structure
   

--*/
#include "stdafx.h"
#include "utils.h"
#include "dsace.h"
#include "dsacls.h"

#define DSACL_DBG   1


//
// Local helper macros
//
#define FLAG_ON(flag,bits)        ((flag) & (bits))
#define IS_CMD_FLAG( string )    (*(string) == L'-' || *(string) == L'/' )


DSACLS_ARG  DsAclsArgs[] = {
   { MSG_TAG_CI,     NULL, 0, 0, MSG_TAG_CI,       0, FALSE, DSACLS_EXTRA_INFO_REQUIRED },
   { MSG_TAG_CN,     NULL, 0, 0, MSG_TAG_CN,       0, FALSE, DSACLS_EXTRA_INFO_NONE },
   { MSG_TAG_CP,     NULL, 0, 0, MSG_TAG_CP,       0, FALSE, DSACLS_EXTRA_INFO_REQUIRED },
   { MSG_TAG_CG,     NULL, 0, 0, MSG_TAG_CG,       0, TRUE, DSACLS_EXTRA_INFO_NONE },
   { MSG_TAG_CD,     NULL, 0, 0, MSG_TAG_CD,       0, TRUE, DSACLS_EXTRA_INFO_NONE },
   { MSG_TAG_CR,     NULL, 0, 0, MSG_TAG_CR,       0, TRUE, DSACLS_EXTRA_INFO_NONE },
   { MSG_TAG_CS,     NULL, 0, 0, MSG_TAG_CS,       0, FALSE, DSACLS_EXTRA_INFO_NONE },
   { MSG_TAG_CT,     NULL, 0, 0, MSG_TAG_CT,       0, FALSE, DSACLS_EXTRA_INFO_NONE },
   { MSG_TAG_CA,     NULL, 0, 0, MSG_TAG_CA,       0, FALSE, DSACLS_EXTRA_INFO_NONE },
   { MSG_TAG_GETSDDL,NULL, 0, 0, MSG_TAG_GETSDDL,  0, FALSE, DSACLS_EXTRA_INFO_OPTIONAL },
   { MSG_TAG_SETSDDL,NULL, 0, 0, MSG_TAG_SETSDDL,  0, FALSE, DSACLS_EXTRA_INFO_REQUIRED }
};

    
DSACLS_INHERIT DsAclsInherit[] = {
   { MSG_TAG_IS, NULL, 0, TRUE, CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE},
   { MSG_TAG_IT, NULL, 0, TRUE, CONTAINER_INHERIT_ACE },
   { MSG_TAG_IP, NULL, 0, TRUE, INHERIT_NO_PROPAGATE },
   { MSG_TAG_ID, NULL, 0, FALSE, INHERITED_ACCESS_ENTRY }
};

DSACLS_RIGHTS DsAclsRights[] = {
   { MSG_TAG_GR, NULL,MSG_TAG_GR_EX,NULL, 0, GENERIC_READ },
   { MSG_TAG_GE, NULL,MSG_TAG_GE_EX,NULL, 0, GENERIC_EXECUTE },
   { MSG_TAG_GW, NULL,MSG_TAG_GW_EX,NULL, 0, GENERIC_WRITE },
   { MSG_TAG_GA, NULL,MSG_TAG_GA_EX,NULL, 0, GENERIC_ALL },
   { MSG_TAG_SD, NULL,MSG_TAG_SD_EX,NULL, 0, DELETE },
   { MSG_TAG_RC, NULL,MSG_TAG_RC_EX,NULL, 0, READ_CONTROL },
   { MSG_TAG_WD, NULL,MSG_TAG_WD_EX,NULL, 0, WRITE_DAC },
   { MSG_TAG_WO, NULL,MSG_TAG_WO_EX,NULL, 0, WRITE_OWNER },
   { MSG_TAG_CC, NULL,MSG_TAG_CC_EX,NULL, 0, ACTRL_DS_CREATE_CHILD },
   { MSG_TAG_DC, NULL,MSG_TAG_DC_EX,NULL, 0, ACTRL_DS_DELETE_CHILD },
   { MSG_TAG_LC, NULL,MSG_TAG_LC_EX,NULL, 0, ACTRL_DS_LIST },
   { MSG_TAG_WS, NULL,MSG_TAG_WS_EX,NULL, 0, ACTRL_DS_SELF },
   { MSG_TAG_WP, NULL,MSG_TAG_WP_EX,NULL, 0, ACTRL_DS_WRITE_PROP },
   { MSG_TAG_RP, NULL,MSG_TAG_RP_EX,NULL, 0, ACTRL_DS_READ_PROP },
   { MSG_TAG_DT, NULL,MSG_TAG_DT_EX,NULL, 0, ACTRL_DS_DELETE_TREE },
   { MSG_TAG_LO, NULL,MSG_TAG_LO_EX,NULL, 0, ACTRL_DS_LIST_OBJECT },
   { MSG_TAG_AC, NULL,MSG_TAG_AC_EX,NULL, 0, ACTRL_DS_CONTROL_ACCESS } //This is only for input
};

DSACLS_PROTECT DsAclsProtect[] = {
   { MSG_TAG_PY, NULL, 0, PROTECTED_DACL_SECURITY_INFORMATION },
   { MSG_TAG_PN, NULL, 0, UNPROTECTED_DACL_SECURITY_INFORMATION }
};




/*
Displays The security Descriptor
*/
DWORD 
DumpAccess (
    IN PSECURITY_DESCRIPTOR pSD,
    IN BOOL bDisplayAuditAndOwner
    )
{

   DWORD dwErr = ERROR_SUCCESS;
	SECURITY_DESCRIPTOR_CONTROL wSDControl = 0;
	DWORD dwRevision;
	PSID psidOwner = NULL;
	PSID psidGroup = NULL;
	PACL pDacl = NULL;
	PACL pSacl = NULL;
	BOOL bDefaulted;
	BOOL bPresent;
   LPWSTR pOwnerName = NULL;
   LPWSTR pGroupName = NULL;
   CAcl * pCSacl = NULL;
   CAcl * pCDacl = NULL;
   UINT nLen1 = 0;
   UINT nLen2 = 0;
   UINT nAllowDeny = 0;
   UINT nAudit = 0;
   WCHAR szLoadBuffer[1024];

	if( !GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision) )
	{
      dwErr = GetLastError();
		goto CLEAN_RETURN;
	}
	if( !GetSecurityDescriptorOwner(pSD, &psidOwner, &bDefaulted) )
	{
      dwErr = GetLastError();
		goto CLEAN_RETURN;
   }
	if( !GetSecurityDescriptorGroup(pSD, &psidGroup, &bDefaulted) )
	{
      dwErr = GetLastError();
		goto CLEAN_RETURN;
	}
	if( !GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefaulted) )
	{
      dwErr = GetLastError();
		goto CLEAN_RETURN;
	}
	if( !GetSecurityDescriptorSacl(pSD, &bPresent, &pSacl, &bDefaulted) )
	{
      dwErr = GetLastError();
		goto CLEAN_RETURN;
	}
   
   //Find out the Max len out of ( ALLOW, DENY ) and ( FAILURE, SUCCESS, BOTH)
   nLen1 = LoadStringW( g_hInstance, MSG_DSACLS_ALLOW, szLoadBuffer, 1023 );
   nLen2 = LoadStringW( g_hInstance, MSG_DSACLS_DENY,  szLoadBuffer, 1023 );
   nAllowDeny = ( nLen1 > nLen2 ) ? nLen1 : nLen2;
   nLen1 = LoadStringW( g_hInstance, MSG_DSACLS_AUDIT_SUCCESS, szLoadBuffer, 1023 );
   nLen2 = LoadStringW( g_hInstance, MSG_DSACLS_AUDIT_FAILURE,  szLoadBuffer, 1023 );
   nAudit = ( nLen1 > nLen2 ) ? nLen1 : nLen2;
   nLen1 = LoadStringW( g_hInstance, MSG_DSACLS_AUDIT_ALL, szLoadBuffer, 1023 );
   nAudit = ( nLen1 > nAudit ) ? nLen1 : nAudit;
   

   if( bDisplayAuditAndOwner )
   {
      pCSacl = new CAcl();
      CHECK_NULL( pCSacl, CLEAN_RETURN );
      dwErr = pCSacl->Initialize(wSDControl & SE_SACL_PROTECTED, 
                                 pSacl, 
                                 nAllowDeny, 
                                 nAudit );      
      if( dwErr != ERROR_SUCCESS )
         return dwErr;
   }
   pCDacl = new CAcl();
   CHECK_NULL( pCDacl,CLEAN_RETURN );
   dwErr = pCDacl->Initialize(wSDControl & SE_DACL_PROTECTED, 
                              pDacl, 
                              nAllowDeny, 
                              nAudit);

   if( dwErr != ERROR_SUCCESS )
      return dwErr;

   if( ( dwErr = g_Cache->BuildCache() ) != ERROR_SUCCESS )
      return dwErr;			

   pCDacl->GetInfoFromCache();
   if( bDisplayAuditAndOwner )
   {
      if( ( dwErr = GetAccountNameFromSid( g_szServerName, psidOwner, &pOwnerName ) ) != ERROR_SUCCESS )
         goto CLEAN_RETURN;
      DisplayMessageEx( 0, MSG_DSACLS_OWNER, pOwnerName );
      if( ( dwErr = GetAccountNameFromSid( g_szServerName, psidGroup, &pGroupName ) ) != ERROR_SUCCESS )
         goto CLEAN_RETURN;
      DisplayMessageEx( 0, MSG_DSACLS_GROUP, pGroupName );
      DisplayNewLine();
      DisplayMessageEx( 0, MSG_DSACLS_AUDIT );
      pCSacl->Display();
      DisplayNewLine();
   }

   
   DisplayMessageEx( 0, MSG_DSACLS_ACCESS );
   pCDacl->Display();

CLEAN_RETURN:
   if( pOwnerName )
      LocalFree( pOwnerName );
   if( pGroupName )
      LocalFree( pGroupName );
   if( pCSacl )
      delete pCSacl;
   if( pCDacl )
      delete pCDacl;
   return dwErr;
}



/*
This Function process the command line argument for /D /R /G
options and add the corresponding aces to pAcl.
*/
DWORD
ProcessCmdlineUsers ( IN WCHAR *argv[],
                      IN PDSACLS_ARG  AclsArg,
                      IN DSACLS_OP Op,
                      IN ULONG Inheritance,
                      IN ULONG RightsListCount,
                      IN PDSACLS_RIGHTS RightsList,
                      OUT CAcl *pAcl )
{
    DWORD dwErr = ERROR_SUCCESS;
    ULONG i, j;
    ULONG AccIndex, Access;
    PEXPLICIT_ACCESS pListOfExplicitEntries = NULL;
    PWSTR pObjectId = NULL;
    PWSTR pTrustee = NULL;
    PWSTR pInheritId = NULL;
    ACCESS_MODE AccessMode;
    CAce * pAce = NULL;
    switch ( Op ) {
    case REVOKE:
        AccessMode = REVOKE_ACCESS;
        break;

    case GRANT:
        AccessMode = GRANT_ACCESS;
        break;

    case DENY:
        AccessMode = DENY_ACCESS;
        break;

    default:
        dwErr = ERROR_INVALID_PARAMETER;
        break;
    }

    if ( dwErr != ERROR_SUCCESS ) 
      goto FAILURE_RETURN;
        
   for ( i = 0; i < AclsArg->SkipCount && dwErr == ERROR_SUCCESS; i++ ) 
   {
      dwErr = ParseUserAndPermissons( argv[AclsArg->StartIndex + 1 + i],
                                         Op,
                                         RightsListCount,
                                         RightsList,
                                         &pTrustee,
                                         &Access,
                                         &pObjectId,
                                         &pInheritId );
      if( dwErr != ERROR_SUCCESS )
         goto FAILURE_RETURN;
   
      pAce = new CAce();
      CHECK_NULL( pAce , FAILURE_RETURN);
      dwErr= pAce->Initialize( pTrustee,
                               pObjectId,
                               pInheritId,
                               AccessMode,
                               Access,
                               Inheritance );

      if( dwErr != ERROR_SUCCESS )
         return dwErr;

      pAcl->AddAce( pAce );
     
      if( pObjectId )
      {
         LocalFree( pObjectId );
         pObjectId = NULL;
      }

      if( pInheritId )
      {
         LocalFree( pInheritId );
         pInheritId = NULL;
      }
      if( pTrustee )
      {
         LocalFree( pTrustee );
         pTrustee = NULL;
      }
   }
    

FAILURE_RETURN:
   if( pObjectId )
   {
      LocalFree( pObjectId );
      pObjectId = NULL;
   }

   if( pInheritId )
   {
      LocalFree( pInheritId );
      pInheritId = NULL;
   }
   if( pTrustee )
   {
      LocalFree( pTrustee );
      pTrustee = NULL;
   }
   
   return( dwErr );
}

//These five are global variables used by the dsacls
LPWSTR g_szSchemaNamingContext;
LPWSTR g_szConfigurationNamingContext;
HMODULE g_hInstance;
LPWSTR g_szServerName;
CCache *g_Cache;

__cdecl
main (
    IN  INT     argc,
    IN  CHAR   *argv[]
)
{   
    DWORD   dwErr = ERROR_SUCCESS;
    ULONG Length, Options = 0;
    PWSTR pszObjectPath = NULL;
    PWSTR pszLDAPObjectPath = NULL;
    PSTR SddlString = NULL,  TempString;
    LPWSTR FileName = NULL;
    CHAR ReadString[ 512 ];
    BOOLEAN Mapped;
    LPWSTR  CurrentInherit = NULL;
    LPWSTR CurrentProtect = NULL;
    ULONG Inheritance = 0;
    SECURITY_INFORMATION Protection = 0;
    ULONG SddlStringLength = 0;
    WCHAR ** wargv = NULL;
    ULONG i = 0;
    ULONG j = 0;
    PSECURITY_DESCRIPTOR pSD = NULL;
    PACL pDacl = NULL;
    SECURITY_INFORMATION SecurityInformation = DACL_SECURITY_INFORMATION;
    PSECURITY_DESCRIPTOR pTempSD = NULL;
    PACL pNewDacl = NULL;
    CAcl * pCAclOld = NULL;
    CAcl *pCAclNew = NULL;
    BOOL bErrorShown = FALSE;

   //Initialize Com Library 
   HRESULT  hr = CoInitialize(NULL);
   CHECK_HR(hr, CLEAN_RETURN);
   //Get Instance Handle
   g_hInstance = GetModuleHandle(NULL);
   //Create global instance of Cache
   g_Cache = new CCache();
   CHECK_NULL(g_Cache,CLEAN_RETURN);
    
   setlocale( LC_CTYPE, "" );
   
   //Initialize Global Arrays   
   if( ( dwErr = InitializeGlobalArrays() ) != ERROR_SUCCESS )
      goto CLEAN_RETURN;


   if ( argc == 1 ) 
   {
      DisplayMessage( 0, MSG_DSACLS_USAGE );
      goto CLEAN_RETURN;
   }

   //Convert argv to Unicode
   wargv = (LPWSTR*)LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, argc * sizeof(LPWSTR) );
   CHECK_NULL(wargv, CLEAN_RETURN );

   if( ( dwErr = ConvertArgvToUnicode( wargv, argv, argc ) ) != ERROR_SUCCESS )
      goto CLEAN_RETURN;

    //First Argument is Object Path or /?
   if( IS_CMD_FLAG( wargv[ 1 ] ) )
   {
      if ( _wcsicmp( wargv[ 1 ] + 1, L"?" ) != 0 ) 
            DisplayMessageEx( 0, MSG_DSACLS_PARAM_UNEXPECTED, wargv[1] );
            
      DisplayMessage(0,MSG_DSACLS_USAGE);
      goto CLEAN_RETURN;
   }

   Length = wcslen( wargv[1] );
   pszObjectPath = (LPWSTR)LocalAlloc( LMEM_FIXED, 
                                       ( Length + 1 ) * sizeof( WCHAR ) );
   if ( !pszObjectPath )
   {
      dwErr = ERROR_NOT_ENOUGH_MEMORY;
      goto CLEAN_RETURN;
   } else 
   {
      wcscpy( pszObjectPath,
              wargv[ 1 ] );
   }            
   //Get the name of server
   dwErr = GetServerName( pszObjectPath, &g_szServerName );
   if( dwErr != ERROR_SUCCESS )
      goto CLEAN_RETURN;

   if( ( dwErr = BuildLdapPath( &pszLDAPObjectPath,
                                g_szServerName,
                                pszObjectPath ) ) != ERROR_SUCCESS )
      goto CLEAN_RETURN;
   //Get Schema and Configuration naming context
   dwErr = GetGlobalNamingContexts(  g_szServerName,
                                     &g_szSchemaNamingContext,
                                     &g_szConfigurationNamingContext );
   
   if( dwErr != ERROR_SUCCESS )
      goto CLEAN_RETURN;

    
   //
   // Parse the command line
   //
   i = 2;
   while ( i < ( ULONG )argc && dwErr == ERROR_SUCCESS )
   {
      if ( IS_CMD_FLAG( wargv[ i ] ) )
      {     
         if ( !_wcsicmp( wargv[ i ] + 1, L"?" ) ) {
            DisplayMessage( 0, MSG_DSACLS_USAGE );
            goto CLEAN_RETURN;
         } 

         Mapped = FALSE;
         for (  j = 0; j < ( sizeof( DsAclsArgs ) / sizeof( DSACLS_ARG ) ); j++ ) 
         {
            if ( !wcsncmp( wargv[ i ] + 1, DsAclsArgs[ j ].String,DsAclsArgs[ j ].Length ) )
            {
               if( DsAclsArgs[ j ].ExtraInfo )
               {
                  if( ( DsAclsArgs[ j ].ExtraInfo == DSACLS_EXTRA_INFO_REQUIRED &&
                        wargv[ i ][ DsAclsArgs[ j ].Length + 1 ] == ':' &&
                        wargv[ i ][ DsAclsArgs[ j ].Length + 2 ] != '\0' ) ||
                        (DsAclsArgs[ j ].ExtraInfo == DSACLS_EXTRA_INFO_OPTIONAL &&
                        ( ( wargv[ i ][ DsAclsArgs[ j ].Length + 1 ] == ':' &&
                        wargv[ i ][ DsAclsArgs[ j ].Length + 2 ] != '\0' ) ||
                        wargv[ i ][ DsAclsArgs[ j ].Length + 1 ] == '\0' ) ) )
                  {
                     Mapped = TRUE;
                  }

               } else 
               {
                  Mapped = TRUE;
               }
               break;
            }
         }//For 


         if ( Mapped ) 
         {
            DsAclsArgs[ j ].StartIndex = i;
            Options |= DsAclsArgs[ j ].Flag;
            if ( DsAclsArgs[ j ].SkipNonFlag )
            {
               while ( i + 1 < ( ULONG )argc && !IS_CMD_FLAG( wargv[ i + 1 ] ) ) 
               {
                     i++;
                     DsAclsArgs[ j ].SkipCount++;
               }

               if ( DsAclsArgs[ j ].SkipCount == 0 ) 
               {
                  DisplayMessageEx( 0, MSG_DSACLS_NO_UA,
                                    wargv[i] );
                  dwErr = ERROR_INVALID_PARAMETER;
                                goto CLEAN_RETURN;
                }
            }        
         }
         else
         {
            DisplayMessageEx( 0, MSG_DSACLS_PARAM_UNEXPECTED, wargv[i] );
            dwErr = ERROR_INVALID_PARAMETER;
            goto CLEAN_RETURN;
         }   

      } else 
      {
            DisplayMessageEx( 0, MSG_DSACLS_PARAM_UNEXPECTED, wargv[i] );
            dwErr = ERROR_INVALID_PARAMETER;
            goto CLEAN_RETURN;
      }

      i++;
   }//While

   //Validate the command line argument

   /*
      if ( !FLAG_ON( Options, MSG_TAG_CR | MSG_TAG_CD | MSG_TAG_CG | MSG_TAG_CT | MSG_TAG_CS ) ) 
      {
         if ( FLAG_ON( Options, MSG_TAG_GETSDDL ) ) 
         {
     
            if ( dwErr == ERROR_SUCCESS ) 
            {

               if ( !ConvertSecurityDescriptorToStringSecurityDescriptorA(      pSD,
                                                                                SDDL_REVISION,
                                                                                SecurityInformation,
                                                                                &SddlString,
                                                                                NULL ) )
               {                  
                  dwErr = GetLastError();
               } else 
               {
                  //
                  // Get the file name to write it to if necessary
                  //
                  for ( j = 0; j < ( sizeof( DsAclsArgs ) / sizeof( DSACLS_ARG ) ); j++ ) 
                  {
                     if ( DsAclsArgs[ j ].Flag == MSG_TAG_GETSDDL ) 
                     {
                        FileName = wcschr( wargv[ DsAclsArgs[ j ].StartIndex ] , L':' );
                        if ( FileName ) 
                        {
                           FileName++;
                        }
                        break;
                      }
                  }

                  if ( FileName ) 
                  {
                     HANDLE FileHandle = CreateFile( FileName,
                                                             GENERIC_WRITE,
                                                             0,
                                                             NULL,
                                                             CREATE_ALWAYS,
                                                             FILE_ATTRIBUTE_NORMAL,
                                                             NULL );

                     if ( FileHandle == INVALID_HANDLE_VALUE ) 
                     {

                                   dwErr = GetLastError();

                     } else 
                     {

                                   ULONG BytesWritten;

                        if ( WriteFile( FileHandle,
                                        ( PVOID )SddlString,
                                        strlen( SddlString ),
                                        &BytesWritten,
                                        NULL ) == FALSE ) 
                        {
                           dwErr = GetLastError();
                        } else 
                        {
                           ASSERT( strlen( SddlString ) == BytesWritten );
                        }
                        CloseHandle( FileHandle );
                     }
                  } else 
                  {

                            printf( "%s\n", SddlString );
                  }
                        LocalFree( SddlString );
                }

                  //LocalFree( SD );
               }

            } else {

                    DumpAccess( pSD,
                                FLAG_ON( Options, MSG_TAG_CA ),
                                sizeof( DsAclsInherit ) / sizeof( DSACLS_INHERIT ),
                                DsAclsInherit,
                                sizeof( DsAclsRights ) / sizeof( DSACLS_RIGHTS ),
                                DsAclsRights );
            }
        }
   */

/*
    //
    // If we are parsing an SDDL file, go ahead and do that now...
    //
    if ( FLAG_ON( Options, MSG_TAG_SETSDDL ) ) 
    {

        //
        // First, open the file
        //
        HANDLE FileHandle = INVALID_HANDLE_VALUE;

        //
        // Get the file name to write it to if necessary
        //
        for ( j = 0; j < ( sizeof( DsAclsArgs ) / sizeof( DSACLS_ARG ) ); j++ ) {

            if ( DsAclsArgs[ j ].Flag == MSG_TAG_SETSDDL ) {

                FileName = wcschr( wargv[ DsAclsArgs[ j ].StartIndex ] , L':' );
                if ( FileName ) {

                    FileName++;
                }
                break;
            }
        }

        if ( !FileName ) {

            dwErr = ERROR_INVALID_PARAMETER;
            goto CLEAN_RETURN;
        }

        FileHandle = CreateFile( FileName,
                                  GENERIC_READ,
                                  FILE_SHARE_READ,
                                  NULL,
                                  OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL );

        if ( FileHandle == INVALID_HANDLE_VALUE ) {

            dwErr = GetLastError();
            goto CLEAN_RETURN;
        }

        //
        // Now, parse it...
        //
        SddlStringLength = 0;
        SddlString = NULL;
        while ( TRUE ) {

            ULONG Read = 0, Len = 0;
            PSTR ReadPtr, TempPtr;

            if ( ReadFile( FileHandle,
                           ReadString,
                           sizeof( ReadString ) / sizeof( CHAR ),
                           &Read,
                           NULL ) == FALSE ) {

                dwErr = GetLastError();
                break;
            }

            if ( Read == 0 ) {

                break;
            }

            if ( *ReadString == ';' ) {

                continue;
            }

            Len = SddlStringLength + ( Read / sizeof( CHAR ) );

            TempString = (LPSTR)LocalAlloc( LMEM_FIXED,
                                     Len + sizeof( CHAR ) );

            if ( TempString ) {

                if ( SddlString ) {

                    strcpy( TempString, SddlString );

                } else {

                    *TempString = '\0';
                }

                TempPtr = TempString + SddlStringLength;
                ReadPtr = ReadString;

                while( Read-- > 0 ) {

                    if ( !isspace( *ReadPtr ) ) {

                        *TempPtr++ = *ReadPtr;
                        SddlStringLength++;
                    }

                    ReadPtr++;
                }

                *TempPtr = '\0';

                LocalFree( SddlString );
                SddlString = TempString;

            } else {

                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

        }

        if ( dwErr == ERROR_SUCCESS ) {

            //
            // Convert it to a security descriptor, then to an access list, then set it.
            //
            if ( ConvertStringSecurityDescriptorToSecurityDescriptorA( SddlString,
                                                                       SDDL_REVISION,
                                                                       &pTempSD,
                                                                       NULL ) == FALSE ) {

                dwErr = GetLastError();

            } else {

                    dwErr = WriteObjectSecurity( pszObjectPath,
                                                    DACL_SECURITY_INFORMATION,
                                                    pTempSD );

                     LocalFree( pTempSD );
            }
        }

        LocalFree( SddlString );

        if ( FileHandle != INVALID_HANDLE_VALUE ) {

            CloseHandle( FileHandle );
        }

        goto CLEAN_RETURN;
    }
*/

   //
   // Get the inheritance flags set
   //
   if ( FLAG_ON( Options, MSG_TAG_CI ) ) 
   {

        for (  j = 0; j < ( sizeof( DsAclsArgs ) / sizeof( DSACLS_ARG ) ); j++ ) 
        {
            if ( DsAclsArgs[ j ].Flag == MSG_TAG_CI ) 
            {
               CurrentInherit = wargv[ DsAclsArgs[ j ].StartIndex ] + 3;
               while ( CurrentInherit && *CurrentInherit && dwErr == ERROR_SUCCESS ) 
               {
                  for ( i = 0; i < ( sizeof( DsAclsInherit ) / sizeof( DSACLS_INHERIT ) ); i++ ) 
                  {
                     if ( !_wcsnicmp( CurrentInherit,
                                      DsAclsInherit[ i ].String,
                                      DsAclsInherit[ i ].Length ) ) 
                     {

                        if ( !DsAclsInherit[ i ].ValidForInput ) 
                        {
                           dwErr = ERROR_INVALID_PARAMETER;
                           break;
                        }
                        Inheritance |= DsAclsInherit[ i ].InheritFlag;
                        CurrentInherit += DsAclsInherit[ i ].Length;
                        break;
                     }
                  }

                  if ( i == ( sizeof( DsAclsInherit ) / sizeof( DSACLS_INHERIT ) ) ) 
                  {
                     dwErr = ERROR_INVALID_PARAMETER;
                     goto CLEAN_RETURN;
                  }
               }
               break;
            }
        }
   }

   //Get the protection flag
   if ( FLAG_ON( Options, MSG_TAG_CP ) ) 
   {

        for (  j = 0; j < ( sizeof( DsAclsArgs ) / sizeof( DSACLS_ARG ) ); j++ ) 
        {
            if ( DsAclsArgs[ j ].Flag == MSG_TAG_CP ) 
            {
               CurrentProtect = wargv[ DsAclsArgs[ j ].StartIndex ] + DsAclsArgs[ j ].Length + 2;
               while ( CurrentProtect && *CurrentProtect ) 
               {
                  for ( i = 0; i < ( sizeof( DsAclsProtect ) / sizeof( DSACLS_PROTECT ) ); i++ ) 
                  {
                     if ( !_wcsnicmp( CurrentProtect,
                                      DsAclsProtect[ i ].String,
                                      DsAclsProtect[ i ].Length ) ) 
                     {

                        Protection |= DsAclsProtect[ i ].Right;
                        CurrentProtect += DsAclsProtect[ i ].Length;
                        break;
                     }
                  }

                  if ( i == ( sizeof( DsAclsProtect ) / sizeof( DSACLS_PROTECT ) ) ) 
                  {
                     dwErr = ERROR_INVALID_PARAMETER;
                     goto CLEAN_RETURN;
                  }
               }
               break;
            }
        }
   }




   //
   // Start processing them in order
   //
   if ( FLAG_ON( Options, MSG_TAG_CR | MSG_TAG_CD | MSG_TAG_CG | MSG_TAG_CP ) ) 
   {
      //
      // Get the current information, if required
      //
      if( !FLAG_ON( Options, MSG_TAG_CN ) )
      {
         SecurityInformation = DACL_SECURITY_INFORMATION;

         dwErr = GetNamedSecurityInfo(   pszLDAPObjectPath,
                                         SE_DS_OBJECT_ALL,
                                         SecurityInformation,
                                         NULL,
                                         NULL,
                                         &pDacl,
                                         NULL,
                                         &pSD );
                                         
         if ( dwErr != ERROR_SUCCESS ) {
            goto CLEAN_RETURN;
         }
         //pCAclOld represents existing ACL
         pCAclOld = new CAcl();
         CHECK_NULL( pCAclOld, CLEAN_RETURN );
         dwErr = pCAclOld->Initialize( FALSE, pDacl,0 ,0 );
         if( dwErr != ERROR_SUCCESS )
            goto CLEAN_RETURN;

         if( !FLAG_ON( Options, MSG_TAG_CP ) )
         {
            dwErr = GetProtection( pSD, &Protection );
            if( dwErr != ERROR_SUCCESS )
               goto CLEAN_RETURN;
         }
      }

      pCAclNew = new CAcl();
      CHECK_NULL( pCAclNew, CLEAN_RETURN );

        //
        // Grant
        //
        if ( dwErr == ERROR_SUCCESS && FLAG_ON( Options, MSG_TAG_CG ) ) {

            for ( j = 0; j < ( sizeof( DsAclsArgs ) / sizeof( DSACLS_ARG ) ); j++ ) {

                if ( DsAclsArgs[ j ].Flag == MSG_TAG_CG ) {

                    dwErr = ProcessCmdlineUsers( wargv,
                                                 &DsAclsArgs[ j ],
                                                 GRANT,
                                                 Inheritance,
                                                 sizeof( DsAclsRights ) / sizeof( DSACLS_RIGHTS ),
                                                 DsAclsRights,
                                                 pCAclNew );

                    if ( dwErr != ERROR_SUCCESS ) {
                        goto CLEAN_RETURN;
                    }
                    break;
                }
            }
        }

        if ( dwErr == ERROR_SUCCESS && FLAG_ON( Options, MSG_TAG_CD ) ) {

            for ( j = 0; j < ( sizeof( DsAclsArgs ) / sizeof( DSACLS_ARG ) ); j++ ) {

                if ( DsAclsArgs[ j ].Flag == MSG_TAG_CD ) {

                    dwErr = ProcessCmdlineUsers( wargv,
                                                 &DsAclsArgs[ j ],
                                                 DENY,
                                                 Inheritance,
                                                 sizeof( DsAclsRights ) / sizeof( DSACLS_RIGHTS ),
                                                 DsAclsRights,
                                                 pCAclNew );

                    if ( dwErr != ERROR_SUCCESS ) {
                        goto CLEAN_RETURN;
                    }
                    break;
                }

            }
        }

        if ( dwErr == ERROR_SUCCESS && FLAG_ON( Options, MSG_TAG_CR ) ) {

            for ( j = 0; j < ( sizeof( DsAclsArgs ) / sizeof( DSACLS_ARG ) ); j++ ) {

                if ( DsAclsArgs[ j ].Flag == MSG_TAG_CR ) {

                    dwErr = ProcessCmdlineUsers( wargv,
                                                    &DsAclsArgs[ j ],
                                                    REVOKE,
                                                    Inheritance,
                                                    sizeof( DsAclsRights ) / sizeof( DSACLS_RIGHTS ),
                                                    DsAclsRights,
                                                    pCAclNew );

                    if ( dwErr != ERROR_SUCCESS ) {
                     goto CLEAN_RETURN;

                    }

                    break;
                }

            }
        }

        //Build Cache
        g_Cache->BuildCache();
        //Verify that we have been able to convert all ObjectType and InheritedObjectType
        // names to GUIDs
        pCAclNew->GetInfoFromCache();
        if( !pCAclNew->VerifyAllNames() )
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto CLEAN_RETURN;
        }
        if( pCAclOld )
         pCAclOld->GetInfoFromCache();
         
        if( pCAclOld )
        {
            pCAclOld->MergeAcl( pCAclNew );
            if(( dwErr = pCAclOld->BuildAcl( &pNewDacl ) ) != ERROR_SUCCESS )
               goto CLEAN_RETURN;
        }
        else
        {
            if( ( dwErr = pCAclNew->BuildAcl( &pNewDacl ) ) != ERROR_SUCCESS )
               goto CLEAN_RETURN;
        }
            SecurityInformation = DACL_SECURITY_INFORMATION | Protection;
            dwErr = SetNamedSecurityInfo  (    pszLDAPObjectPath,
                                               SE_DS_OBJECT_ALL,
                                               SecurityInformation,
                                               NULL,
                                               NULL,
                                               pNewDacl,
                                               NULL );
            if( dwErr != ERROR_SUCCESS )
               goto CLEAN_RETURN;

   }

    //
    // Now, see if we have to restore any security to the defaults
    //
    if ( FLAG_ON( Options, MSG_TAG_CS ) ) {

        dwErr = SetDefaultSecurityOnObjectTree( pszObjectPath,
                                                   ( BOOLEAN )( FLAG_ON( Options, MSG_TAG_CT )  ?
                                                                                 TRUE : FALSE ),Protection );
         if( dwErr != ERROR_SUCCESS )
            goto CLEAN_RETURN;


    }

   

    //Display the security
      if( pSD )
      {
         LocalFree( pSD );
         pSD = NULL;
      }

      SecurityInformation = DACL_SECURITY_INFORMATION;
      if ( FLAG_ON( Options, MSG_TAG_CA ) )
      {
         SecurityInformation |= SACL_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                OWNER_SECURITY_INFORMATION;
      }
      dwErr = GetNamedSecurityInfo(   pszLDAPObjectPath,
                                      SE_DS_OBJECT_ALL,
                                      SecurityInformation,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &pSD );
          
     if( dwErr != ERROR_SUCCESS )
     {
        if( dwErr == ERROR_FILE_NOT_FOUND )
        {
            DisplayMessageEx( 0, MSG_INVALID_OBJECT_PATH );
            bErrorShown = TRUE;
        }                      
         goto CLEAN_RETURN;
    }

    dwErr = DumpAccess( pSD,
                FLAG_ON( Options, MSG_TAG_CA )
              );

CLEAN_RETURN:

    if ( dwErr == ERROR_SUCCESS ) 
    {
        DisplayMessageEx( 0, MSG_DSACLS_SUCCESS );
    } else {
       if(!bErrorShown)
            DisplayErrorMessage( dwErr );
       DisplayMessageEx( 0, MSG_DSACLS_FAILURE );
    }

   //Free Unicode Command Line Arguments
   if( wargv )
   {
      //delete wargv and stuff
      for( j = 0; j < argc; ++ j )
      {
         if( wargv[j] )
            LocalFree(wargv[j] );
      }
      LocalFree( wargv );
   }
      

   if( pszObjectPath )
      LocalFree( pszObjectPath );

   if( pSD )
      LocalFree( pSD );

   if( pNewDacl )
      LocalFree( pNewDacl );

   //Free the Global Stuff
   for ( j = 0; j < ( sizeof( DsAclsArgs ) / sizeof( DSACLS_ARG ) ); j++ ) {
        if( DsAclsArgs[ j ].String )
            LocalFree( DsAclsArgs[ j ].String );
   }

   for ( j = 0; j < ( sizeof( DsAclsInherit ) / sizeof( DSACLS_INHERIT ) ); j++ ) {
        if( DsAclsInherit[ j ].String )
            LocalFree( DsAclsInherit[ j ].String );
   }

   for ( j = 0; j < ( sizeof( DsAclsRights ) / sizeof( DSACLS_RIGHTS ) ); j++ ) {
      if( DsAclsRights[ j ].String )
         LocalFree( DsAclsRights[ j ].String );

      if( DsAclsRights[ j ].StringEx )
         LocalFree( DsAclsRights[ j ].StringEx );

   }

   if( pCAclOld )
      delete pCAclOld ;
   if( pCAclNew )
      delete pCAclNew;

   if( g_szSchemaNamingContext )
      LocalFree( g_szSchemaNamingContext );
   if( g_szConfigurationNamingContext )
      LocalFree( g_szConfigurationNamingContext );
   if( g_szServerName )
      LocalFree( g_szServerName );
   if( g_Cache )
      delete g_Cache;


    return( dwErr );
}




DWORD 
InitializeGlobalArrays()
{

HMODULE hCurrentModule;
WCHAR LoadBuffer[ 1024 ];
int j = 0;

   hCurrentModule = GetModuleHandle( NULL );

   for ( j = 0; j < ( sizeof( DsAclsArgs ) / sizeof( DSACLS_ARG )); j++ )
   {
      long Length = LoadString( hCurrentModule,
                                DsAclsArgs[ j ].ResourceId,
                                LoadBuffer,
                                sizeof( LoadBuffer ) / sizeof ( WCHAR ) - 1 );

      if ( Length == 0 )
      {
         return GetLastError();         
      } else {
         
         DsAclsArgs[ j ].String = (LPWSTR)LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                              ( Length + 1 )*sizeof(WCHAR) );
         if ( !DsAclsArgs[ j ].String )
         {
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         
         DsAclsArgs[ j ].Length = Length;
         wcsncpy( DsAclsArgs[ j ].String, LoadBuffer, Length + 1 );
        }
   }

    //
    // Load the inherit strings
    //
   for (  j = 0; j < ( sizeof( DsAclsInherit ) / sizeof( DSACLS_INHERIT ) ); j++ ) 
   {
      long Length = LoadString( hCurrentModule,
                                DsAclsInherit[ j ].ResourceId,
                                LoadBuffer,
                                sizeof( LoadBuffer ) / sizeof ( WCHAR ) - 1 );

      if ( Length == 0 ) {
         return GetLastError();            
      } else 
      {
         DsAclsInherit[ j ].String = (LPWSTR)LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                                 ( Length + 1 ) * sizeof( WCHAR ) );
         if ( !DsAclsInherit[ j ].String ) 
            return  ERROR_NOT_ENOUGH_MEMORY;

         wcsncpy( DsAclsInherit[ j ].String, LoadBuffer, Length + 1 );
         DsAclsInherit[ j ].Length = Length;

     }
   }

   //
   //Load The protect flags
   //

   for( j = 0; j < ( sizeof( DsAclsProtect ) / sizeof( DSACLS_PROTECT ) ); j++ )
   {
      long Length = LoadString( hCurrentModule,
                                DsAclsProtect[ j ].ResourceId,
                                LoadBuffer,
                                sizeof( LoadBuffer ) / sizeof ( WCHAR ) - 1 );

      if ( Length == 0 ) {
         return GetLastError();            
      } else 
      {
         DsAclsProtect[ j ].String = (LPWSTR)LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                                 ( Length + 1 ) * sizeof( WCHAR ) );
         if ( !DsAclsProtect[ j ].String ) 
            return  ERROR_NOT_ENOUGH_MEMORY;

         wcsncpy( DsAclsProtect[ j ].String, LoadBuffer, Length + 1 );
         DsAclsProtect[ j ].Length = Length;
      }
   }
    //
    // Load the access rights
    //
   for ( j = 0; j < ( sizeof( DsAclsRights ) / sizeof( DSACLS_RIGHTS ) ); j++ ) 
   {
      long Length = LoadString( hCurrentModule,
                                DsAclsRights[ j ].ResourceId,
                                LoadBuffer,
                                sizeof( LoadBuffer ) / sizeof ( WCHAR ) - 1 );
      if ( Length == 0 ) {
         return GetLastError();         
      } else 
      {
         DsAclsRights[ j ].String = (LPWSTR)LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                              ( Length + 1 ) * sizeof( WCHAR ) );
         if ( !DsAclsRights[ j ].String ) {
            return ERROR_NOT_ENOUGH_MEMORY;
         }

         wcsncpy( DsAclsRights[ j ].String, LoadBuffer, Length + 1 );
         DsAclsRights[ j ].Length = Length;

      }

      //Load Ex . Ex String are used for displaying the access rights
      if( DsAclsRights[ j ].ResourceIdEx != -1 )
      {
         Length = LoadString( hCurrentModule,
                     DsAclsRights[ j ].ResourceIdEx,
                     LoadBuffer,
                     sizeof( LoadBuffer ) / sizeof ( WCHAR ) - 1 );
      
         if ( Length == 0 ) {
            return GetLastError();         
         } else 
         {
            DsAclsRights[ j ].StringEx = (LPWSTR)LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                                 ( Length + 1 ) * sizeof( WCHAR ) );
            if ( !DsAclsRights[ j ].StringEx ) {
               return ERROR_NOT_ENOUGH_MEMORY;
            }

            wcsncpy( DsAclsRights[ j ].StringEx, LoadBuffer, Length + 1 );

         }
      }

   }

   return ERROR_SUCCESS;

}

/*******************************************************************

    NAME:       ConvertArgvToUnicode

    SYNOPSIS:   Converts Command Line Arguments to UNICODE
    RETURNS:    ERROR_SUCCESS if success
                ERROR_NOT_ENOUGH_MEMORY

********************************************************************/
DWORD
ConvertArgvToUnicode( LPWSTR * wargv, char ** argv, int argc ) 
{

DWORD dwErr = ERROR_SUCCESS;
int i = 0;

   for ( i = 0; i < argc ; ++i )
      if( ( dwErr = ConvertStringAToStringW( argv[i], wargv + i ) ) != ERROR_SUCCESS )
         return dwErr;

   return ERROR_SUCCESS;
}

/*
Sets Security Descriptor for pszObject
*/
DWORD
WriteObjectSecurity( IN LPWSTR pszObject,
                     IN SECURITY_INFORMATION si,
                     IN PSECURITY_DESCRIPTOR pSD )
{
		DWORD dwErr;
		SECURITY_DESCRIPTOR_CONTROL wSDControl = 0;
		DWORD dwRevision;
		PSID psidOwner = NULL;
		PSID psidGroup = NULL;
		PACL pDacl = NULL;
		PACL pSacl = NULL;
		BOOL bDefaulted;
		BOOL bPresent;
      LPWSTR pszLDAPObjectPath = NULL;

      if( ( dwErr = BuildLdapPath( &pszLDAPObjectPath,
                                   g_szServerName,
                                   pszObject ) ) != ERROR_SUCCESS )
            return dwErr;            
		//
		// Get pointers to various security descriptor parts for
		// calling SetNamedSecurityInfo
		//
		;
		if( !GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision) )
		{
			return GetLastError();
		}
		if( !GetSecurityDescriptorOwner(pSD, &psidOwner, &bDefaulted) )
		{
			return GetLastError();		
      }
		if( !GetSecurityDescriptorGroup(pSD, &psidGroup, &bDefaulted) )
		{
			return GetLastError();
		}
		if( !GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefaulted) )
		{
			return GetLastError();
		}
		if( !GetSecurityDescriptorSacl(pSD, &bPresent, &pSacl, &bDefaulted) )
		{
			return GetLastError();
		}

		if ((si & DACL_SECURITY_INFORMATION) && (wSDControl & SE_DACL_PROTECTED))
				si |= PROTECTED_DACL_SECURITY_INFORMATION;
		if ((si & SACL_SECURITY_INFORMATION) && (wSDControl & SE_SACL_PROTECTED))
				si |= PROTECTED_SACL_SECURITY_INFORMATION;

		return SetNamedSecurityInfo(    (LPWSTR)pszLDAPObjectPath,
													SE_DS_OBJECT_ALL,
													si,
													psidOwner,
													psidGroup,
													pDacl,
													pSacl);

				
}



/*******************************************************************

    NAME:       DisplayAccessRights

    SYNOPSIS:   Displays Access Rights in Acess Mask
    RETURNS:    NONE

********************************************************************/
void DisplayAccessRights( UINT nSpace, ACCESS_MASK m_Mask )
{    
   for (  int j = 0; j < ( sizeof( DsAclsRights ) / sizeof( DSACLS_RIGHTS ) ); j++ ) 
   {
      if( FlagOn( m_Mask,DsAclsRights[j].Right ) )
      {
         DisplayStringWithNewLine( nSpace,DsAclsRights[j].StringEx );
      }
   }
}

/*******************************************************************

    NAME:       ConvertAccessMaskToGenericString

    SYNOPSIS:   Map access mask to FULL CONTROL or SPECIAL
    RETURNS:    NONE

********************************************************************/

void ConvertAccessMaskToGenericString( ACCESS_MASK m_Mask, LPWSTR szLoadBuffer, UINT nBuffer )
{
   szLoadBuffer[0] = 0;
   WCHAR szTemp[1024];
   if( GENERIC_ALL_MAPPING == ( m_Mask & GENERIC_ALL_MAPPING ) )
   {
      LoadString( g_hInstance, MSG_TAG_GA_EX, szLoadBuffer, nBuffer );
   }
   else
   {
      LoadString( g_hInstance, MSG_DSACLS_SPECIAL, szLoadBuffer, nBuffer );
   }
}

/*******************************************************************
    NAME:       MapGeneric
********************************************************************/
void MapGeneric( ACCESS_MASK * pMask )
{
   GENERIC_MAPPING m = DS_GENERIC_MAPPING;
   MapGenericMask( pMask, &m );
}

/*******************************************************************

    NAME:       BuildExplicitAccess

    SYNOPSIS:   Builds Explicit Access 
    RETURNS:    ERROR_SUCCESS if success
                ERROR_NOT_ENOUGH_MEMORY

********************************************************************/

DWORD BuildExplicitAccess( IN PSID pSid,
                           IN GUID* pGuidObject,
                           IN GUID* pGuidInherit,
                           IN ACCESS_MODE AccessMode,
                           IN ULONG Access,
                           IN ULONG Inheritance,
                           OUT PEXPLICIT_ACCESS pExplicitAccess )
{
DWORD dwErr = ERROR_SUCCESS;

PSID pSidLocal = NULL;
DWORD cbSid = 0;
POBJECTS_AND_SID pOAS = NULL;


   cbSid = GetLengthSid( pSid );
   pSidLocal = (PSID) LocalAlloc( LMEM_FIXED, cbSid );
   CHECK_NULL( pSidLocal,FAILURE_RETURN );
   CopySid( cbSid,pSidLocal, pSid );
   if( pGuidObject  || pGuidInherit )
   {
      pOAS = (POBJECTS_AND_SID)LocalAlloc( LMEM_FIXED, sizeof( OBJECTS_AND_SID ) );
      CHECK_NULL( pOAS, FAILURE_RETURN );
      BuildTrusteeWithObjectsAndSid(   &pExplicitAccess->Trustee,
                                       pOAS,
                                       pGuidObject, 
                                       pGuidInherit,
                                       pSidLocal );
   }
   else
      BuildTrusteeWithSid( &pExplicitAccess->Trustee,
                           pSidLocal );
   MapGeneric( &Access );
   pExplicitAccess->grfAccessMode = AccessMode;
   pExplicitAccess->grfAccessPermissions =Access;
   pExplicitAccess->grfInheritance = Inheritance;

   goto SUCCESS_RETURN;

FAILURE_RETURN:
   if(pSidLocal)
      LocalFree(pSidLocal);

   if( pOAS )
      LocalFree( pOAS );

SUCCESS_RETURN:
   return dwErr;
}    

/*******************************************************************

    NAME:       ParseUserAndPermissons

    SYNOPSIS:   Parses <GROUP\USER>:Access;[object\property];[inheritid]
********************************************************************/
DWORD ParseUserAndPermissons( IN LPWSTR pszArgument,
                              IN DSACLS_OP Op,
                              IN ULONG RightsListCount,
                              IN PDSACLS_RIGHTS RightsList,
                              OUT LPWSTR * ppszTrusteeName,
                              OUT PULONG  pAccess,
                              OUT LPWSTR * ppszObjectId,
                              OUT LPWSTR * ppszInheritId )
{

LPWSTR pszTempString = NULL;
LPWSTR pszTempString2 = NULL;
DWORD dwErr = ERROR_SUCCESS;
ULONG j = 0;

   *ppszTrusteeName = NULL;
   *pAccess = 0;
   *ppszObjectId = NULL;
   *ppszInheritId = NULL;

   if ( Op != REVOKE ) 
   {
      pszTempString = wcschr( pszArgument, L':' );
      if ( !pszTempString ) 
      {
         dwErr = ERROR_INVALID_PARAMETER;
         goto FAILURE_RETURN;
      }
      *pszTempString = L'\0';
   }

   dwErr = CopyUnicodeString( ppszTrusteeName, pszArgument );

   if ( dwErr != ERROR_SUCCESS ) 
   {
      goto FAILURE_RETURN;
   }

   if ( Op != REVOKE ) 
   {
      *pszTempString = L':';
      pszTempString++;

      // Now, process all of the user rights
      *pAccess = 0;
      while ( pszTempString && !( *pszTempString == L';' || *pszTempString == L'\0' ) ) 
      {
         for ( j = 0; j < RightsListCount; j++ ) 
         {                 
            if ( !_wcsnicmp( pszTempString,
                             RightsList[ j ].String,
                             RightsList[ j ].Length ) )                 
            {
               *pAccess |= RightsList[ j ].Right;
               pszTempString += RightsList[ j ].Length;
               break;
            }
         }

         if ( j == RightsListCount ) 
         {
            dwErr = ERROR_INVALID_PARAMETER;
            goto FAILURE_RETURN;
         }
      }

      if ( *pAccess == 0 ) 
      {
         dwErr = ERROR_INVALID_PARAMETER;
         goto FAILURE_RETURN;
      }

      //
      // Object id
      //
      if ( pszTempString && *pszTempString != L'\0' ) 
      {
         pszTempString++;           
         if ( pszTempString && *pszTempString != L';' && *pszTempString != L'\0' ) 
         {
            pszTempString2 = wcschr( pszTempString, L';' );
            if ( pszTempString2 ) 
            {
               *pszTempString2 = L'\0';
            }
            dwErr = CopyUnicodeString( ppszObjectId,pszTempString );

            if ( dwErr != ERROR_SUCCESS ) 
            {
               goto FAILURE_RETURN;
            }

            if ( pszTempString2 ) 
            {
               *pszTempString2 = L';';
            }
            pszTempString = pszTempString2;
         }
      }
      else
         *ppszObjectId = NULL;

      //
      // Inherit id
      //
      if ( pszTempString && *pszTempString != L'\0' ) 
      {
         pszTempString++;
         if ( pszTempString &&  *pszTempString != L'\0' ) 
         {
            dwErr = CopyUnicodeString( ppszInheritId,  
                                          pszTempString );

            if ( dwErr != ERROR_SUCCESS ) 
            {
               goto FAILURE_RETURN;
            }
         }

      } else 
         *ppszInheritId = NULL;
                
   }


FAILURE_RETURN:
if( dwErr != ERROR_SUCCESS )
{
   if( *ppszTrusteeName )
   {
      LocalFree( *ppszTrusteeName );
      *ppszTrusteeName = NULL;
   }
   if( *ppszObjectId )
   {
      LocalFree( *ppszObjectId );
      *ppszObjectId = NULL;
   }
   if( *ppszInheritId )
   {
      LocalFree( *ppszInheritId );
      *ppszInheritId = NULL;
   }
   *pAccess = 0;
}

return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\dsacls\dsace.cpp ===
#include "stdafx.h"
#include "utils.h"
#include "dsace.h"
#include "dsacls.h"


//This constructor is used to initialize from an Ace
CAce::CAce( )
            :m_AceFlags( 0 ), 
            m_AceType( ALLOW ),
            m_ObjectTypeType( DSACLS_SELF), 
            m_Flags( 0 ),
            m_Mask( 0 ), 
            m_pSid( NULL ),
            m_szObjectType( NULL ), 
            m_szTrusteeName( NULL ),
            m_szInheritedObjectType( NULL ),
            m_bErased( FALSE ),
            m_GuidObjectType( GUID_NULL ),
            m_GuidInheritedObjectType( GUID_NULL )
{}

CAce::~CAce()
{
   if( m_pSid )
      LocalFree( m_pSid );
   if( m_szTrusteeName )
      LocalFree( m_szTrusteeName );
   if( m_szInheritedObjectType )
      LocalFree( m_szInheritedObjectType );
   if( m_szObjectType )
      LocalFree( m_szObjectType );
}


DWORD CAce::Initialize( PACE_HEADER pAceHeader, UINT nAllowDeny, UINT nAudit )
{
   DWORD dwErr = ERROR_SUCCESS;
   ASSERT( pAceHeader != NULL );

   m_nAllowDeny = nAllowDeny;
   m_nAudit = nAudit;
   
   m_AceFlags = pAceHeader->AceFlags;   
   m_Mask = ((PKNOWN_ACE)pAceHeader)->Mask;
   MapGeneric(&m_Mask);
   
   // Is this an object ACE?
   if (IsObjectAceType(pAceHeader))
   {
      GUID *pGuid;

      // Copy the object type guid if present
      pGuid = RtlObjectAceObjectType(pAceHeader);
      if (pGuid)
      {  
         m_Flags |= ACE_OBJECT_TYPE_PRESENT;
         m_GuidObjectType = *pGuid;
      }

      // Copy the inherit type guid if present
      pGuid = RtlObjectAceInheritedObjectType(pAceHeader);
      if (pGuid)
      {
         m_Flags |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
         m_GuidInheritedObjectType = *pGuid;
      }
   }

   // Copy the SID
   PSID psidT = GetAceSid(pAceHeader);
   DWORD nSidLength = GetLengthSid(psidT);

   m_pSid = (PSID)LocalAlloc(LPTR, nSidLength);
   if (m_pSid)
      CopyMemory(m_pSid, psidT, nSidLength);
   else
      return ERROR_NOT_ENOUGH_MEMORY;

   //Get the Trustee Name from the SID
   dwErr = GetAccountNameFromSid( g_szServerName, m_pSid, &m_szTrusteeName );
   if( dwErr != ERROR_SUCCESS )
      return dwErr;
   m_AceType = GetAceType( pAceHeader );

   if( m_AceType == ALLOW )
      m_AccessMode = GRANT_ACCESS;
   else
      m_AccessMode = DENY_ACCESS;
   

   //Get LDAP display name of ObjectType
   if( FlagOn( m_Flags, ACE_OBJECT_TYPE_PRESENT) )
   {  
      PDSACL_CACHE_ITEM pItemCache = NULL;
      pItemCache = g_Cache->LookUp( &m_GuidObjectType );
      //Found in Cache, copy the name
      if( pItemCache )
      {
         if( ( dwErr = CopyUnicodeString( &m_szObjectType, pItemCache->pszName ) ) != ERROR_SUCCESS )
            return dwErr;
         m_ObjectTypeType = pItemCache->ObjectTypeType;
      }
      //Add to cache, Guid will be resolved when cache is build
      else
         g_Cache->AddItem( &m_GuidObjectType );
   }

   //Get the LDAP display name for the InheriteObjectType
   if( FlagOn( m_Flags, ACE_INHERITED_OBJECT_TYPE_PRESENT ) )
   {
      PDSACL_CACHE_ITEM pItemCache = NULL;
      pItemCache = g_Cache->LookUp( &m_GuidInheritedObjectType );
      if( pItemCache )
      {
         if( ( dwErr = CopyUnicodeString( &m_szInheritedObjectType, pItemCache->pszName ) ) != ERROR_SUCCESS )
            return ERROR_SUCCESS;
      }
      else
         g_Cache->AddItem( &m_GuidInheritedObjectType );
   }

   return ERROR_SUCCESS;
}
                  
DWORD CAce::Initialize( LPWSTR pszTrustee,
                        LPWSTR pszObjectId,
                        LPWSTR pszInheritId,
                        ACCESS_MODE AccessMode,
                        ACCESS_MASK Access,
                        BYTE Inheritance 
                        )
{
   DWORD dwErr = ERROR_SUCCESS; 
   m_AceFlags = Inheritance;
   m_Mask = Access;
   MapGeneric(&m_Mask);
   m_AccessMode = AccessMode;
   // Is this an object ACE?
   if ( pszObjectId || pszInheritId )
   {
      if ( pszObjectId )
      {  
         m_Flags |= ACE_OBJECT_TYPE_PRESENT;
         dwErr = CopyUnicodeString( &m_szObjectType,pszObjectId );
         if( dwErr != ERROR_SUCCESS )
            return dwErr;
      }

      // Copy the inherit type guid if present
      if ( pszInheritId )
      {
         m_Flags |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
         dwErr = CopyUnicodeString( &m_szInheritedObjectType ,pszInheritId);
         if( dwErr != ERROR_SUCCESS )
            return dwErr;
      }
   }   
      
   if( ( dwErr = CopyUnicodeString( &m_szTrusteeName, pszTrustee ) ) != ERROR_SUCCESS )
      return dwErr;
   if( ( dwErr = GetSidFromAccountName( g_szServerName,
                                        &m_pSid, 
                                        m_szTrusteeName ) ) != ERROR_SUCCESS )
   {
      DisplayMessageEx( 0, MSG_DSACLS_NO_MATCHING_SID, m_szTrusteeName );
      return dwErr;
   }
   //AceType
   if( m_AccessMode == GRANT_ACCESS )
      m_AceType = ALLOW;
   else if ( m_AccessMode == DENY_ACCESS )
      m_AceType = DENY;
   //else Doesn't Matter


   //Get LDAP display name of ObjectType
   if( FlagOn( m_Flags, ACE_OBJECT_TYPE_PRESENT) )
   {  
      PDSACL_CACHE_ITEM pItemCache = NULL;
      pItemCache = g_Cache->LookUp( m_szObjectType );
      if( pItemCache )
      {
         m_GuidObjectType = pItemCache->Guid;
      }
      else
         g_Cache->AddItem( m_szObjectType );
   }

   //Get the LDAP display name for the InheriteObjectType
   if( FlagOn( m_Flags, ACE_INHERITED_OBJECT_TYPE_PRESENT ) )
   {
      PDSACL_CACHE_ITEM pItemCache = NULL;
      pItemCache = g_Cache->LookUp( m_szInheritedObjectType );
      if( pItemCache )
      {
         m_GuidInheritedObjectType = pItemCache->Guid;
      }
      else
         g_Cache->AddItem( m_szInheritedObjectType );

   }
   return ERROR_SUCCESS;
}


GUID* CAce::GetGuidObjectType()
{ 
   if( !IsEqualGUID( m_GuidObjectType, GUID_NULL ) )
      return &m_GuidObjectType; 
   return NULL;
}

GUID* CAce::GetGuidInheritType() 
{
   if( !IsEqualGUID( m_GuidInheritedObjectType, GUID_NULL ) )
      return &m_GuidInheritedObjectType; 
   return NULL;
}

VOID CAce::Display( UINT nMaxTrusteeLength )
{
WCHAR szLoadBuffer[1024];
WCHAR szDisplayBuffer[1024];
HMODULE hInstance = GetModuleHandle(NULL);
DWORD err=0;
UINT nAccessDisplayLen = 0;
UINT uID = 0;
UINT nLen = 0;

   switch ( m_AceType )
   {
      case ALLOW:
         uID = MSG_DSACLS_ALLOW;
         break;
      case DENY:
         uID = MSG_DSACLS_DENY;
         break;
      case AUDIT_SUCCESS:
         uID = MSG_DSACLS_AUDIT_SUCCESS;
         break;
      case AUDIT_FAILURE:
         uID = MSG_DSACLS_AUDIT_FAILURE;
         break;
      case AUDIT_ALL:
         uID = MSG_DSACLS_AUDIT_ALL;
         break;

   }
   nLen = LoadStringW( hInstance, uID, szLoadBuffer, 1023 );
   
   if( m_AceType == ALLOW || m_AceType == DENY )
      nLen = m_nAllowDeny - nLen;
   else
      nLen = m_nAudit - nLen;
    
   wcscpy(szDisplayBuffer,szLoadBuffer );

   StringWithNSpace(1 + nLen ,szLoadBuffer );

   wcscat( szDisplayBuffer, szLoadBuffer );
   wcscat( szDisplayBuffer, m_szTrusteeName );

   nLen = wcslen( m_szTrusteeName );
   StringWithNSpace(2 + ( nMaxTrusteeLength - nLen ), szLoadBuffer );
   wcscat( szDisplayBuffer, szLoadBuffer );
   if( m_ObjectTypeType == DSACLS_EXTENDED_RIGHTS )
   {
      wcscat( szDisplayBuffer, GetObjectType() );
   }
   else
   {
      nAccessDisplayLen = wcslen( szDisplayBuffer );

      ConvertAccessMaskToGenericString( m_Mask, szLoadBuffer, 1023 );

      if( m_ObjectTypeType == DSACLS_CHILD_OBJECTS || 
          m_ObjectTypeType == DSACLS_PROPERTY  ||
          m_ObjectTypeType == DSACLS_VALIDATED_RIGHTS )
      {
         LPWSTR szTemp = NULL;
         if( ERROR_SUCCESS == ( err = LoadMessage( MSG_DSACLS_ACCESS_FOR, &szTemp, szLoadBuffer, GetObjectType() ) ) )
         {
            wcscat( szDisplayBuffer, szTemp );
            LocalFree(szTemp);
         }

      }
      else  
         wcscat( szDisplayBuffer, szLoadBuffer );
   }

   if( IsInheritedFromParent() )
   {
      StringWithNSpace(3, szLoadBuffer );
      wcscat( szDisplayBuffer, szLoadBuffer );
      LoadString( hInstance, MSG_DSACLS_INHERITED_FROM_PARENT, szLoadBuffer, 1023 );
      wcscat( szDisplayBuffer, szLoadBuffer );
   }
   
   DisplayStringWithNewLine(0, szDisplayBuffer );

   if( m_ObjectTypeType != DSACLS_EXTENDED_RIGHTS && 
       ( GENERIC_ALL_MAPPING != ( m_Mask & GENERIC_ALL_MAPPING ) ) )
      DisplayAccessRights( nAccessDisplayLen, m_Mask );
}


CAcl::~CAcl()
{
   CAce *pAce= NULL;
   for( list<CAce*>::iterator i = listAces.begin(); i != listAces.end(); ++i )
   {
      pAce = (*i);
      pAce->~CAce();
      //delete (*i);
   }
}

DWORD CAcl::Initialize( BOOL bProtected, PACL pAcl, UINT nAllowDeny, UINT nAudit )
{
   DWORD dwErr = ERROR_SUCCESS;

   bAclProtected = bProtected;

   if( pAcl == NULL )
      return ERROR_SUCCESS;
   UINT nMaxTrusteeLength = 0;
   PACE_HEADER pAceHeader = (PACE_HEADER) FirstAce(pAcl);
   for ( int j = 0; j < pAcl->AceCount; j++, pAceHeader = (PACE_HEADER) NextAce(pAceHeader))
   {
      CAce * pAce = new CAce();
      if( !pAce )
         return ERROR_NOT_ENOUGH_MEMORY;
      dwErr = pAce->Initialize( pAceHeader, nAllowDeny, nAudit );
      if( dwErr != ERROR_SUCCESS )
      {
         delete pAce;
         return dwErr;
       }
      if( nMaxTrusteeLength < pAce->GetTrusteeLength() )
         nMaxTrusteeLength = pAce->GetTrusteeLength();

      listAces.push_back( pAce );

      if( pAce->IsEffective() )
         listEffective.push_back( pAce );

      if( pAce->IsInheritedToAll() )
         listInheritedAll.push_back( pAce );

      if( pAce->IsInheritedToSpecific() )
         listInheritedSpecific.push_back( pAce );

   }

   m_nMaxTrusteeLength = nMaxTrusteeLength;
   return ERROR_SUCCESS;
}


VOID CAcl::AddAce( CAce *pAce )
{
   listAces.push_back(pAce);
}

VOID CAcl::MergeAcl( CAcl * pAcl )
{
   for( list<CAce*>::iterator i = pAcl->listAces.begin(); i != pAcl->listAces.end(); ++i )
   {
      if( (*i)->GetAccessMode() == REVOKE_ACCESS )
      {
         //Remove all Aces from this->listAces which have same sid
         for( list<CAce*>::iterator j = listAces.begin(); j != listAces.end(); ++j )
         {
            if( EqualSid( (*i)->GetSID(), (*j)->GetSID() ) )
               (*j)->SetErased(TRUE);
         }        
      }
      else
      {  
         AddAce( (*i) );
      }     
   }
   //After Merging pAcl should be empty()
   for( i = pAcl->listAces.begin(); i != pAcl->listAces.end(); ++i )
   {
      if( (*i)->GetAccessMode() == REVOKE_ACCESS )
      {
         delete (*i);
      }
   }
   while( !pAcl->listAces.empty() )
   {
      pAcl->listAces.pop_back();
   }
}

DWORD CAcl::BuildAcl( PACL *ppAcl )
{
   ULONG cAceCount = 0;
   PEXPLICIT_ACCESS pListOfExplicitEntries = NULL;
   DWORD dwErr = ERROR_SUCCESS;
   for( list<CAce*>::iterator j = listAces.begin(); j != listAces.end(); ++j )
   {
     if( !(*j)->IsErased() )
         ++cAceCount;
   }
   pListOfExplicitEntries = (PEXPLICIT_ACCESS)LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                               cAceCount * sizeof( EXPLICIT_ACCESS ) );
   if ( pListOfExplicitEntries == NULL ) 
   {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        return dwErr;
   }   
   
   cAceCount = 0;
   for(  j = listAces.begin(); j != listAces.end(); ++j )
   {
     if( !(*j)->IsErased() )
     {
         dwErr = BuildExplicitAccess( (*j)->GetSID(),
                                      (*j)->GetGuidObjectType(),
                                      (*j)->GetGuidInheritType(),
                                      (*j)->GetAccessMode(),
                                      (*j)->GetAccessMask(),
                                      (*j)->GetAceFlags(),
                                      &pListOfExplicitEntries[cAceCount] );
         if( dwErr != ERROR_SUCCESS )
            break;

         ++cAceCount;
      }
   }
   
   if( dwErr == ERROR_SUCCESS )
   {
      dwErr = SetEntriesInAcl( cAceCount, 
                               pListOfExplicitEntries,
                               NULL,
                               ppAcl );
   }
    //
    // Free the memory from the access entry list
    //
   for ( int i = 0; i < cAceCount; i++ ) 
   {
      if( pListOfExplicitEntries[i].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID )
      {
         POBJECTS_AND_SID pOAS = (POBJECTS_AND_SID)pListOfExplicitEntries[i].Trustee.ptstrName;
         if( pOAS  && pOAS->pSid )
            LocalFree( pOAS->pSid );
         if( pOAS )
            LocalFree( pOAS );
      }
      else
         LocalFree( pListOfExplicitEntries[i].Trustee.ptstrName );
   }
   LocalFree( pListOfExplicitEntries );

   return dwErr;
}

VOID CAcl::GetInfoFromCache()
{

LPWSTR pszTemp = NULL;
GUID * pGuid = NULL;
PDSACL_CACHE_ITEM pItem = NULL;
DWORD dwErr = ERROR_SUCCESS;
WCHAR szGuid[39];

   for ( list<CAce*>::iterator i = listAces.begin(); i != listAces.end(); i++ )
   {
      if( (*i)->IsObjectTypePresent() )
      {
         if( (*i)->GetGuidObjectType() == NULL )
         {
               pItem = g_Cache->LookUp( (*i)->GetObjectType() );
               if( pItem )
               {
                  (*i)->SetGuidObjectType( &pItem->Guid );
                  (*i)->SetObjectTypeType( pItem->ObjectTypeType );
               }
            //else is fatal error since we cannot get guid this is taken care in verify
            
         }
         else if( (*i)->GetObjectType() == NULL )
         {

               pItem = g_Cache->LookUp( (*i)->GetGuidObjectType() );
               if( pItem )
               {
                  (*i)->SetObjectType( pItem->pszName );
                  (*i)->SetObjectTypeType( pItem->ObjectTypeType );
               }
               else
               {    
                  FormatStringGUID( szGuid, 38, (*i)->GetGuidObjectType() );
                  (*i)->SetObjectType( szGuid );
                  (*i)->SetObjectTypeType( DSACLS_UNDEFINED );
               }
         }
      }
      if( (*i)->IsInheritedTypePresent() )
      {
         if( (*i)->GetGuidInheritType() == NULL )
         {               
               pItem = g_Cache->LookUp( (*i)->GetInheritedObjectType() );
               if( pItem )
               {
                  (*i)->SetGuidInheritType( &pItem->Guid );
               }
            //else is fatal error since we cannot get guid this is taken care in verify
         }
         else if( (*i)->GetInheritedObjectType() == NULL )
         {
               pItem = g_Cache->LookUp( (*i)->GetGuidInheritType() );
               if( pItem )
               {
                  (*i)->SetInheritedObjectType( pItem->pszName );
               }
               else
               {    
                  FormatStringGUID( szGuid, 38, (*i)->GetGuidInheritType() );
                  (*i)->SetInheritedObjectType( szGuid );
               }
            
         }
      }
      
   }
}

BOOL CAcl::VerifyAllNames()
{
   for ( list<CAce*>::iterator i = listAces.begin(); i != listAces.end(); i++ )
   {
      if( (*i)->IsObjectTypePresent() )
      {
         if( (*i)->GetGuidObjectType() == NULL )
         {
            DisplayMessageEx(0, MSG_DSACLS_NO_MATCHING_GUID, (*i)->GetObjectType() );
            return FALSE;
         }
         if ( (*i)->GetObjectTypeType() == DSACLS_PROPERTY &&
              (((*i)->GetAccessMask() & (~(ACTRL_DS_WRITE_PROP|ACTRL_DS_READ_PROP))) != 0 ) )
         {
            DisplayMessageEx(0,MSG_DSACLS_PROPERTY_PERMISSION_MISMATCH, (*i)->GetObjectType() );
            return FALSE;
         }
         if ( (*i)->GetObjectTypeType() == DSACLS_EXTENDED_RIGHTS &&
              (((*i)->GetAccessMask() & (~ACTRL_DS_CONTROL_ACCESS)) != 0 ) )
         {
            DisplayMessageEx(0,MSG_DSACLS_EXTENDED_RIGHTS_PERMISSION_MISMATCH, (*i)->GetObjectType() );
            return FALSE;
         }
         if ( (*i)->GetObjectTypeType() == DSACLS_VALIDATED_RIGHTS &&
              (((*i)->GetAccessMask() & (~ACTRL_DS_SELF)) != 0 ) )
         {
            DisplayMessageEx(0,MSG_DSACLS_VALIDATED_RIGHTS_PERMISSION_MISMATCH, (*i)->GetObjectType() );
            return FALSE;
         }
         if ( (*i)->GetObjectTypeType() == DSACLS_CHILD_OBJECTS &&
              (((*i)->GetAccessMask() & (~(ACTRL_DS_CREATE_CHILD|ACTRL_DS_DELETE_CHILD))) != 0 ) )
         {
            DisplayMessageEx(0,MSG_DSACLS_CHILD_OBJECT_PERMISSION_MISMATCH, (*i)->GetObjectType() );
            return FALSE;
         }
      }
      if( (*i)->IsInheritedTypePresent() )
      {
         if( (*i)->GetGuidInheritType() == NULL )
         {
            DisplayMessageEx(0, MSG_DSACLS_NO_MATCHING_GUID, (*i)->GetInheritedObjectType() );
            return FALSE;
         }

         if( (*i)->GetAceFlags() != (CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE) )
         {
            DisplayMessageEx(0, MSG_DSACLS_INCORRECT_INHERIT, (*i)->GetInheritedObjectType() );
            return FALSE;
         }
      }
   }
   return TRUE;
}  

void CAcl::Display()
{
   if( bAclProtected )
      DisplayMessageEx( 0, MSG_DSACLS_PROTECTED );
   if( listAces.empty() )
   {
      DisplayMessageEx( 0, MSG_DSACLS_NO_ACES );
   }
   //Display Effective permissons on this object
   if ( !listEffective.empty() )
   {
      DisplayMessageEx( 0, MSG_DSACLS_EFFECTIVE );
      for ( list<CAce*>::iterator i = listEffective.begin(); i != listEffective.end(); i++ )
      {
         if( !(*i)->IsObjectTypePresent() )
            (*i)->Display( m_nMaxTrusteeLength );
      }
      for (  i = listEffective.begin(); i != listEffective.end(); i++ )
      {
         if( (*i)->GetObjectTypeType() == DSACLS_CHILD_OBJECTS )
            (*i)->Display( m_nMaxTrusteeLength );
      }
      for ( i = listEffective.begin(); i != listEffective.end(); i++ )
      {
         if( (*i)->GetObjectTypeType() == DSACLS_PROPERTY )
            (*i)->Display( m_nMaxTrusteeLength );
      }
      for ( i = listEffective.begin(); i != listEffective.end(); i++ )
      {
         if( (*i)->GetObjectTypeType() == DSACLS_VALIDATED_RIGHTS )
            (*i)->Display( m_nMaxTrusteeLength );
      }
      for ( i = listEffective.begin(); i != listEffective.end(); i++ )
      {
         if( (*i)->GetObjectTypeType() == DSACLS_EXTENDED_RIGHTS )
            (*i)->Display( m_nMaxTrusteeLength );
      }
      DisplayNewLine();
   }
   if( !listInheritedAll.empty() || !listInheritedSpecific.empty() )
      DisplayMessageEx( 0, MSG_DSACLS_INHERITED );

   //Display permissons inherited by all subobjects
   if( !listInheritedAll.empty() )
   {
      DisplayMessageEx( 0, MSG_DSACLS_INHERITED_ALL );
      for ( list<CAce*>::iterator i = listInheritedAll.begin(); i != listInheritedAll.end(); i++ )
      {
         if( !(*i)->IsObjectTypePresent() )
            (*i)->Display( m_nMaxTrusteeLength );
      }
      for ( i = listInheritedAll.begin(); i != listInheritedAll.end(); i++ )
      {
         if( (*i)->GetObjectTypeType() == DSACLS_CHILD_OBJECTS )
            (*i)->Display( m_nMaxTrusteeLength );
      }
      for (  i = listInheritedAll.begin(); i != listInheritedAll.end(); i++ )
      {
         if( (*i)->GetObjectTypeType() == DSACLS_PROPERTY )
            (*i)->Display( m_nMaxTrusteeLength );
      }
      for (  i = listInheritedAll.begin(); i != listInheritedAll.end(); i++ )
      {
         if( (*i)->GetObjectTypeType() == DSACLS_VALIDATED_RIGHTS )
            (*i)->Display( m_nMaxTrusteeLength );
      }

      for ( i = listInheritedAll.begin(); i != listInheritedAll.end(); i++ )
      {
         if( (*i)->GetObjectTypeType() == DSACLS_EXTENDED_RIGHTS )
            (*i)->Display( m_nMaxTrusteeLength );
      }
      DisplayNewLine();

   }
   
   LPWSTR pszInherit = NULL;
   //Display permissons inherited to Inherited Object Class
   if( !listInheritedSpecific.empty() )
   {
      listInheritedSpecific.sort(CACE_SORT());
      for ( list<CAce*>::iterator i = listInheritedSpecific.begin(); i != listInheritedSpecific.end(); i++ )
      {
         if( !pszInherit )
         {
            pszInherit = (*i)->GetInheritedObjectType();
            DisplayMessageEx( 0, MSG_DSACLS_INHERITED_SPECIFIC, pszInherit );
         }
         else if( wcscmp( pszInherit,(*i)->GetInheritedObjectType() )  )
         {
               pszInherit = (*i)->GetInheritedObjectType();
               DisplayMessageEx( 0, MSG_DSACLS_INHERITED_SPECIFIC, pszInherit );
         }  
         (*i)->Display( m_nMaxTrusteeLength );
     }
   }
}





DWORD CCache::AddItem( GUID *pGuid,
                       DSACLS_SEARCH_IN s )
{
   ASSERT( pGuid );
   PDSACL_CACHE_ITEM pItem = NULL;

   pItem = (PDSACL_CACHE_ITEM)LocalAlloc( LMEM_FIXED, sizeof( DSACL_CACHE_ITEM ) );
   if( pItem == NULL )
      return ERROR_NOT_ENOUGH_MEMORY;

   pItem->Guid = *pGuid;
   pItem->pszName = NULL;
   pItem->bResolved = FALSE;
   pItem->resolve = RESOLVE_GUID;
   pItem->searchIn = s;
   m_listItem.push_back( pItem );

   return ERROR_SUCCESS;
}

DWORD CCache::AddItem( LPWSTR pName,
                       DSACLS_SEARCH_IN s  )
{
   ASSERT( pName );
   PDSACL_CACHE_ITEM pItem = NULL;
   DWORD dwErr = ERROR_SUCCESS;

   pItem = (PDSACL_CACHE_ITEM)LocalAlloc( LMEM_FIXED, sizeof( DSACL_CACHE_ITEM ) );
   if( pItem == NULL )
      return ERROR_NOT_ENOUGH_MEMORY;

   dwErr = CopyUnicodeString(&pItem->pszName, pName );
   if( dwErr != ERROR_SUCCESS )
   {
      LocalFree( pItem );
      return ERROR_NOT_ENOUGH_MEMORY;
   }
   
   pItem->bResolved = FALSE;
   pItem->resolve = RESOLVE_NAME;
   pItem->searchIn = s;

   m_listItem.push_back( pItem );

   return ERROR_SUCCESS;
}

DWORD CCache::BuildCache()
{
   SearchConfiguration();
   SearchSchema();
   
   PDSACL_CACHE_ITEM pItem = NULL;
   //Empty m_listItem
   while( !m_listItem.empty() )
   {
      pItem = m_listItem.back();
      m_listItem.pop_back();
      if( pItem->pszName)
         LocalFree( pItem->pszName );
      LocalFree( pItem );
   }

   return ERROR_SUCCESS;
}
   
   
   
DWORD CCache::SearchConfiguration()
{
   ULONG nTotalFilterSize = 1024;
   ULONG nCurrentFilterSize = 0;
   LPWSTR lpszFilter = NULL;
   LPWSTR lpszFilterTemp = NULL;
   WCHAR szTempBuffer[1024];
   WCHAR szTempString[1024];
   DWORD dwErr = 0;
   HRESULT hr = S_OK;
   IDirectorySearch * IDs = NULL;
   ADS_SEARCH_HANDLE hSearchHandle=NULL;  
   LPWSTR lpszConfigGuidFilter = L"(rightsGuid=%s)";
   LPWSTR lpszConfigNameFilter = L"(displayName=%s)";    
   LPWSTR pszAttr[] = { L"rightsGuid",L"displayName", L"validAccesses" };
   ADS_SEARCH_COLUMN col,col1,col2;
   ULONG uLen = 0;
   list<PDSACL_CACHE_ITEM>::iterator i;
   PDSACL_CACHE_ITEM pCacheItem = NULL;
   if( m_listItem.empty() )
      return ERROR_SUCCESS;
   
   
   lpszFilter = (LPWSTR)LocalAlloc( LMEM_FIXED, nTotalFilterSize*sizeof(WCHAR) );
   if( lpszFilter == NULL )
   {
      dwErr = ERROR_NOT_ENOUGH_MEMORY;
      goto FAILURE_RETURN;
   }

   
   wcscpy(lpszFilter, L"(|" );
   nCurrentFilterSize = 4; //One for closing (

   for (  i = m_listItem.begin(); i != m_listItem.end(); i++ )
   {
      if( (*i)->resolve == RESOLVE_GUID && 
          ( ( (*i)->searchIn == BOTH ) || ( (*i)->searchIn == CONFIGURATION ) ) )
      {
         FormatStringGUID( szTempString, 1024, &(*i)->Guid );
         wsprintf(szTempBuffer, lpszConfigGuidFilter,szTempString);
         nCurrentFilterSize += wcslen(szTempBuffer);
      }
      else if( (*i)->resolve == RESOLVE_NAME && 
             ( ( (*i)->searchIn == BOTH ) || ( (*i)->searchIn == SCHEMA ) ) )
      {
         wsprintf( szTempBuffer, lpszConfigNameFilter,(*i)->pszName );
         nCurrentFilterSize += wcslen(szTempBuffer);
      }

      if( nCurrentFilterSize > nTotalFilterSize )
      {
         nTotalFilterSize = nTotalFilterSize * 2;
         lpszFilterTemp = (LPWSTR)LocalAlloc( LMEM_FIXED, nTotalFilterSize * sizeof( WCHAR ) );
         if( lpszFilterTemp == NULL )
         {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto FAILURE_RETURN;
         }
         wcscpy( lpszFilterTemp, lpszFilter );
         LocalFree(lpszFilter);
         lpszFilter = lpszFilterTemp;
         lpszFilterTemp = NULL;
      }
      wcscat(lpszFilter,szTempBuffer);
      
   }
   wcscat(lpszFilter,L")");
   
   //We have Filter Now

   //Search in Configuration Contianer
   hr = ::ADsOpenObject( g_szConfigurationNamingContext,
                         NULL,
                         NULL,
                         ADS_SECURE_AUTHENTICATION,
                         IID_IDirectorySearch,
                         (void **)&IDs );

   if( hr != S_OK )
   {
      dwErr = HRESULT_CODE( hr );
   }

   hr = IDs->ExecuteSearch(lpszFilter,
                           pszAttr,
                           3,
                           &hSearchHandle );

   if( hr != S_OK )
   {  
      dwErr = HRESULT_CODE( hr );
      goto FAILURE_RETURN;
   }


   hr = IDs->GetFirstRow(hSearchHandle);
   if( hr == S_OK )
   {  
      while( hr != S_ADS_NOMORE_ROWS )
      {
         pCacheItem = (PDSACL_CACHE_ITEM) LocalAlloc( LMEM_FIXED, sizeof( DSACL_CACHE_ITEM ) );
         if( pCacheItem == NULL )
         {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto FAILURE_RETURN;
         }
         
         //Get Guid
         hr = IDs->GetColumn( hSearchHandle, pszAttr[0], &col );
         if( hr != S_OK )
         {
            dwErr = HRESULT_CODE( hr );
            goto FAILURE_RETURN;
         }

         GuidFromString( &pCacheItem->Guid, col.pADsValues->CaseIgnoreString);
         IDs->FreeColumn( &col );
         
         //Get Display Name                     
         hr = IDs->GetColumn( hSearchHandle, pszAttr[1], &col1 );
         if( hr != S_OK )
         {
            dwErr = HRESULT_CODE( hr );
            goto FAILURE_RETURN;
         }
         uLen = wcslen( (LPWSTR) col1.pADsValues->CaseIgnoreString );
         pCacheItem->pszName = (LPWSTR)LocalAlloc( LMEM_FIXED, ( uLen + 1 ) * sizeof( WCHAR) );
         if( pCacheItem->pszName == NULL )
         {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto FAILURE_RETURN;
         }
         wcscpy( pCacheItem->pszName, col1.pADsValues->CaseIgnoreString );
         IDs->FreeColumn( &col1 );

         //Get validAccesses
         hr = IDs->GetColumn( hSearchHandle, pszAttr[2], &col2 );
         if( hr != S_OK )
         {
            dwErr = HRESULT_CODE( hr );
            goto FAILURE_RETURN;
         }
         pCacheItem->ObjectTypeType = GetObjectTypeType( col2.pADsValues->Integer );
         IDs->FreeColumn( &col2 );
         //Add item to cache
         m_listCache.push_back( pCacheItem );
         pCacheItem = NULL;
         hr = IDs->GetNextRow(hSearchHandle);
      }

   }
   if( hr == S_ADS_NOMORE_ROWS )
      dwErr = ERROR_SUCCESS;
   


   
FAILURE_RETURN:
   if( lpszFilter )
      LocalFree( lpszFilter );
   if( IDs )
   {
      if( hSearchHandle )
         IDs->CloseSearchHandle( hSearchHandle );
      IDs->Release();
   }
   if( pCacheItem )
      LocalFree( pCacheItem );

   return dwErr;
}   
 
DWORD CCache::SearchSchema()
{
   ULONG nTotalFilterSize = 1024;
   ULONG nCurrentFilterSize = 0;
   LPWSTR lpszFilter = NULL;
   LPWSTR lpszFilterTemp = NULL;
   WCHAR szTempBuffer[1024];
   WCHAR szTempString[1024];
   LPWSTR pszDestData = NULL;
   DWORD dwErr = 0;
   HRESULT hr = S_OK;
   IDirectorySearch * IDs = NULL;
   ADS_SEARCH_HANDLE hSearchHandle=NULL;  
   LPWSTR lpszSchemaGuidFilter = L"(schemaIdGuid=%s)";
   LPWSTR lpszSchemaNameFilter = L"(LDAPdisplayName=%s)";    
   LPWSTR pszAttr[] = {L"schemaIdGuid",L"LDAPdisplayName", L"objectClass"};
   ADS_SEARCH_COLUMN col,col1,col2;
   ULONG uLen = 0;
   list<PDSACL_CACHE_ITEM>::iterator i;
   PDSACL_CACHE_ITEM pCacheItem = NULL;
   if( m_listItem.empty() )
      return ERROR_SUCCESS;
   

   lpszFilter = (LPWSTR)LocalAlloc( LMEM_FIXED, nTotalFilterSize*sizeof(WCHAR) );
   if( lpszFilter == NULL )
   {
      dwErr = ERROR_NOT_ENOUGH_MEMORY;
      goto FAILURE_RETURN;
   }

   
   wcscpy(lpszFilter, L"(|" );
   nCurrentFilterSize = 4; //One for closing (

   for (  i = m_listItem.begin(); i != m_listItem.end(); i++ )
   {
      if( (*i)->resolve == RESOLVE_GUID && 
          ( ( (*i)->searchIn == BOTH ) || ( (*i)->searchIn == SCHEMA ) ) )
      {
         ADsEncodeBinaryData( (PBYTE)&((*i)->Guid),
                              sizeof(GUID),
                              &pszDestData  );

         wsprintf(szTempBuffer, lpszSchemaGuidFilter,pszDestData);
         nCurrentFilterSize += wcslen(szTempBuffer);
         LocalFree( pszDestData );
         pszDestData = NULL;
      }
      else if( (*i)->resolve == RESOLVE_NAME && 
             ( ( (*i)->searchIn == BOTH ) || ( (*i)->searchIn == SCHEMA ) ) )
      {
         wsprintf( szTempBuffer, lpszSchemaNameFilter,(*i)->pszName );
         nCurrentFilterSize += wcslen(szTempBuffer);
      }
      if( nCurrentFilterSize > nTotalFilterSize )
      {
         nTotalFilterSize = nTotalFilterSize * 2;
         lpszFilterTemp = (LPWSTR)LocalAlloc( LMEM_FIXED, nTotalFilterSize * sizeof( WCHAR ) );
         if( lpszFilterTemp == NULL )
         {
               dwErr = ERROR_NOT_ENOUGH_MEMORY;
               goto FAILURE_RETURN;
         }
         wcscpy( lpszFilterTemp, lpszFilter );
         LocalFree( lpszFilter );
         lpszFilter = lpszFilterTemp;
         lpszFilterTemp = NULL;
      }
      wcscat(lpszFilter,szTempBuffer);
   }
   wcscat(lpszFilter,L")");
   
   //We have Filter Now

   //Search in Configuration Contianer
   hr = ::ADsOpenObject( g_szSchemaNamingContext,
                         NULL,
                         NULL,
                         ADS_SECURE_AUTHENTICATION,
                         IID_IDirectorySearch,
                         (void **)&IDs );

   if( hr != S_OK )
   {
      dwErr = HRESULT_CODE( hr );
   }

   hr = IDs->ExecuteSearch(lpszFilter,
                           pszAttr,
                           3,
                           &hSearchHandle );

   if( hr != S_OK )
   {  
      dwErr = HRESULT_CODE( hr );
      goto FAILURE_RETURN;
   }


   hr = IDs->GetFirstRow(hSearchHandle);
   if( hr == S_OK )
   {  
      while( hr != S_ADS_NOMORE_ROWS )
      {
         pCacheItem = (PDSACL_CACHE_ITEM) LocalAlloc( LMEM_FIXED, sizeof( DSACL_CACHE_ITEM ) );
         if( pCacheItem == NULL )
         {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto FAILURE_RETURN;
         }
         
         //Get Guid
         hr = IDs->GetColumn( hSearchHandle, pszAttr[0], &col );
         if( hr != S_OK )
         {
            dwErr = HRESULT_CODE( hr );
            goto FAILURE_RETURN;
         }

         memcpy( &pCacheItem->Guid, 
                  col.pADsValues->OctetString.lpValue,
                  col.pADsValues->OctetString.dwLength);
         IDs->FreeColumn( &col );
         
         //Get Display Name                     
         hr = IDs->GetColumn( hSearchHandle, pszAttr[1], &col1 );
         if( hr != S_OK )
         {
            dwErr = HRESULT_CODE( hr );
            goto FAILURE_RETURN;
         }
         uLen = wcslen( (LPWSTR) col1.pADsValues->CaseIgnoreString );
         pCacheItem->pszName = (LPWSTR)LocalAlloc( LMEM_FIXED, ( uLen + 1 ) * sizeof( WCHAR) );
         if( pCacheItem->pszName == NULL )
         {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto FAILURE_RETURN;
         }
         wcscpy( pCacheItem->pszName, col1.pADsValues->CaseIgnoreString );
         IDs->FreeColumn( &col1 );

         //Get Object Class
         hr = IDs->GetColumn( hSearchHandle, pszAttr[2], &col2 );
         if( hr != S_OK )
         {
            dwErr = HRESULT_CODE( hr );
            goto FAILURE_RETURN;
         }
         pCacheItem->ObjectTypeType = GetObjectTypeType( col2.pADsValues[1].CaseIgnoreString );
         IDs->FreeColumn( &col2 );
         //Add item to cache
         m_listCache.push_back( pCacheItem );
         pCacheItem = NULL;
         hr = IDs->GetNextRow(hSearchHandle);
      }

   }
   if( hr == S_ADS_NOMORE_ROWS )
      dwErr = ERROR_SUCCESS;
   


   
FAILURE_RETURN:
   if( lpszFilter )
      LocalFree( lpszFilter );
   if( IDs )
   {
      if( hSearchHandle )
         IDs->CloseSearchHandle( hSearchHandle );
      IDs->Release();
   }
   if( pCacheItem )
      LocalFree( pCacheItem );

   return dwErr;
}   
 
PDSACL_CACHE_ITEM CCache::LookUp( LPWSTR pszName )
{
   if( m_listCache.empty() )
      return NULL;

   for( list<PDSACL_CACHE_ITEM>::iterator i = m_listCache.begin(); i != m_listCache.end(); ++i )
   {
      if( wcscmp( (*i)->pszName, pszName ) == 0 )
         return (*i);
   }

   return NULL;
}



PDSACL_CACHE_ITEM CCache::LookUp( GUID *pGuid )
{
  if( m_listCache.empty() )
      return NULL;

   for( list<PDSACL_CACHE_ITEM>::iterator i = m_listCache.begin(); i != m_listCache.end(); ++i )
   {
      if( IsEqualGUID( (*i)->Guid, *pGuid ) )
         return (*i);
   }
   return NULL;
}

CCache::~CCache()
{
   for( list<PDSACL_CACHE_ITEM>::iterator i = m_listCache.begin(); i != m_listCache.end(); ++i )
   {
      if( (*i)->pszName )
         LocalFree( (*i)->pszName );
      LocalFree(*i);
   }

   for( i = m_listItem.begin(); i != m_listItem.end(); ++i )
   {
      if( (*i)->pszName )
         LocalFree( (*i)->pszName );
      LocalFree(*i);
   }
}



//Some Utility Functions
DSACLS_OBJECT_TYPE_TYPE GetObjectTypeType( INT validAccesses )
{
   if( FLAG_ON( validAccesses , ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP ) )
      return DSACLS_PROPERTY;
   if( FLAG_ON( validAccesses , ACTRL_DS_CONTROL_ACCESS ) )
      return DSACLS_EXTENDED_RIGHTS;
   if( FLAG_ON( validAccesses , ACTRL_DS_SELF ) )
      return DSACLS_VALIDATED_RIGHTS;
   
   return DSACLS_UNDEFINED;
}

DSACLS_OBJECT_TYPE_TYPE GetObjectTypeType( LPWSTR szObjectCategory )
{
   if( wcscmp( szObjectCategory, L"attributeSchema" ) == 0 )
      return DSACLS_PROPERTY;
   if( wcscmp( szObjectCategory, L"classSchema" ) == 0 )
      return DSACLS_CHILD_OBJECTS;
   return DSACLS_UNDEFINED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\delegate\ldap.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ldap.c

Abstract:

    This Module implements the utility LDAP functions to read information
    from the DS schema

Author:

    Mac McLain  (MacM)    10-02-96

Environment:

    User Mode

Revision History:

--*/

#define LDAP_UNICODE 0

#include <delegate.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>



DWORD
LDAPBind (
    IN  PSTR    pszObject,
    OUT PLDAP  *ppLDAP
    )
/*++

Routine Description:

    This routine will bind to the appropriate server for the path

Arguments:

    pszObject - Object server to bind to
    ppLDAP - Where the ldap binding is returned

Return Value:

    ERROR_SUCCESS - Success

--*/
{
    DWORD   dwErr = ERROR_SUCCESS;

    PDOMAIN_CONTROLLER_INFOA pDCI;

    //
    // First, get the address of our server.  Note that we are binding to
    // a machine in a local domain.  Normally, a valid DNS domain name
    // would be passed in.
    //
    dwErr = DsGetDcNameA(NULL,
                         NULL,
                         NULL,
                         NULL,
                         DS_IP_REQUIRED,
                         &pDCI);


    if(dwErr == ERROR_SUCCESS)
    {
        PSTR    pszDomain = pDCI[0].DomainControllerAddress;
        if(*pszDomain == '\\')
        {
            pszDomain += 2;
        }
        *ppLDAP = ldap_open(pszDomain,
                            LDAP_PORT);

        if(*ppLDAP == NULL)
        {
            dwErr = ERROR_PATH_NOT_FOUND;
        }
        else
        {
            //
            // Do a bind...
            //
            dwErr = ldap_bind(*ppLDAP,
                              NULL,
                              NULL,
                              LDAP_AUTH_SSPI);
        }

        NetApiBufferFree(pDCI);
    }



    return(dwErr);
}




VOID
LDAPUnbind (
    IN  PLDAP   pLDAP
    )
/*++

Routine Description:

    This routine will unbind a previously bound connection

Arguments:

    pLDAP - LDAP connection to unbind


Return Value:

    void

--*/
{
    if(pLDAP != NULL)
    {
        ldap_unbind(pLDAP);
    }
}




DWORD
LDAPReadAttribute (
    IN  PSTR        pszBase,
    IN  PSTR        pszAttribute,
    IN  PLDAP       pLDAP,
    OUT PDWORD      pcValues,
    OUT PSTR      **pppszValues
    )
/*++

Routine Description:

    This routine will read the specified attribute from the base path

Arguments:

    pszBase - Base object path to read from
    pszAttribute - Attribute to read
    pcValues - Where the count of read items is returned
    pppszValues - Where the list of items is returned
    ppLDAP - LDAP connection handle to use/initialize

Return Value:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed
    ERROR_INVALID_PARAMETER - The LDAP connection that was given is not
                              correct

Notes:

    The returned values list should be freed via a call to LDAPFreeValues

--*/
{
    DWORD           dwErr = ERROR_SUCCESS;
    PLDAPMessage    pMessage = NULL;
    PSTR            rgAttribs[2];

    rgAttribs[0] = NULL;

    //
    // Ensure that our LDAP connection is valid
    //
    if(pLDAP == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }

    //
    // Then, do the search...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        rgAttribs[0] = pszAttribute;
        rgAttribs[1] = NULL;

        dwErr = ldap_search_s(pLDAP,
                              pszBase,
                              LDAP_SCOPE_BASE,
                              "(objectClass=*)",
                              rgAttribs,
                              0,
                              &pMessage);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        LDAPMessage *pEntry = NULL;
        pEntry = ldap_first_entry(pLDAP,
                                  pMessage);

        if(pEntry == NULL)
        {
            dwErr = pLDAP->ld_errno;
        }
        else
        {
            //
            // Now, we'll have to get the values
            //
            *pppszValues = ldap_get_values(pLDAP,
                                           pEntry,
                                           rgAttribs[0]);
            if(*pppszValues == NULL)
            {
                dwErr = pLDAP->ld_errno;
            }
            else
            {
                *pcValues = ldap_count_values(*pppszValues);
            }
        }

        ldap_msgfree(pMessage);
    }

    return(dwErr);
}




VOID
LDAPFreeValues (
    IN  PSTR       *ppszValues
    )
/*++

Routine Description:

    Frees the results of an LDAPReadAttribute call

Arguments:

    ppwszValues - List to be freed

Return Value:

    Void

--*/
{
    ldap_value_free(ppszValues);
}




DWORD
LDAPReadSchemaPath (
    IN  PWSTR       pwszOU,
    OUT PSTR       *ppszSchemaPath,
    OUT PLDAP      *ppLDAP
    )
/*++

Routine Description:

    Reads the path to the schema from the DS

Arguments:

    pwszOU - OU path for which the schema path needs to be obtained
    ppszSchemaPath - Where the schema path is returned
    ppLDAP - LDAP connection to be returned following the successful
             completion of this routine

Return Value:

    ERROR_SUCCESS - Success
    ERROR_INVALID_PARAMETER - The OU given was not correct
    ERROR_PATH_NOT_FOUND - The path to the schema could not be found
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

Notes:

    The returned schema path should be free via a call to LocalFree.
    The LDAP connection should be freed via a call to LDAPUnbind

--*/
{
    DWORD               dwErr = ERROR_SUCCESS;
    PSTR               *ppszValues = NULL;
    ULONG               cValues;
    PSTR                pszOU = NULL;
    HANDLE              hDS = NULL;
    PDS_NAME_RESULTW    pNameRes = NULL;

    *ppLDAP = NULL;

    //
    // Get our OU name into a form we can recognize
    //
    dwErr = DsBindW(NULL,
                    NULL,
                    &hDS);

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = DsCrackNamesW(hDS,
                              DS_NAME_NO_FLAGS,
                              DS_UNKNOWN_NAME,
                              DS_FQDN_1779_NAME,
                              1,
                              &pwszOU,
                              &pNameRes);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        if(pNameRes->cItems == 0 || pNameRes->rItems[0].status != 0)
        {

            dwErr = ERROR_PATH_NOT_FOUND;
        }
        else
        {
            PSTR    pszDomain = NULL;

            dwErr = ConvertStringWToStringA(pNameRes->rItems[0].pDomain,
                                            &pszDomain);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Now, we'll bind to the object, and then do the read
                //
                dwErr = LDAPBind(pszDomain,
                                 ppLDAP);
                LocalFree(pszDomain);
            }
        }
    }

    if(hDS != NULL)
    {
        DsUnBindW(&hDS);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = ConvertStringWToStringA(pNameRes->rItems[0].pName,
                                        &pszOU);
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = LDAPReadAttribute(pszOU,
                                      "subschemaSubentry",
                                      *ppLDAP,
                                      &cValues,
                                      &ppszValues);
        }
    }

    if(dwErr == ERROR_SUCCESS)
    {
        PSTR    pszSchemaPath = NULL;
        PWSTR   pwszSchemaPath = NULL;

        pszSchemaPath = strstr(ppszValues[0],
                               "CN=Schema");
        if(pszSchemaPath == NULL)
        {
            dwErr = ERROR_PATH_NOT_FOUND;
        }
        else
        {
            //
            // Now that we have the proper schema path, we'll return it
            //
            *ppszSchemaPath = (PSTR)LocalAlloc(LMEM_FIXED,
                                               strlen(pszSchemaPath) + 1);
            if(*ppszSchemaPath == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                strcpy(*ppszSchemaPath,
                       pszSchemaPath);
            }

        }

        //
        // Don't need the LDAP returned schema path anymore...
        //
        LDAPFreeValues(ppszValues);
    }

    if(dwErr != ERROR_SUCCESS)
    {
        LDAPUnbind(*ppLDAP);
        *ppLDAP = NULL;
    }


    DsFreeNameResultW(pNameRes);

    return(dwErr);
}




DWORD
LDAPReadSecAndObjIdAsString (
    IN  PLDAP           pLDAP,
    IN  PSTR            pszSchemaPath,
    IN  PSTR            pszObject,
    OUT PWSTR          *ppwszObjIdAsString,
    OUT PACTRL_ACCESS  *ppAccess
    )
/*++

Routine Description:

    Reads the schemaID off of the specified object type and converts it
    to a string

Arguments:

    pLDAP - LDAP connection to use for attribute read
    pszSchemaPath - Path to the schema for this object
    pszObject - LDAP name of the object for which to get the GUID
    ppwszObjIdAsString - Where the string representation of the GUID
                         is returned

Return Value:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

Notes:

    The returned string should be freed via a call to RpcFreeString (or as
    part of the whole list, by FreeIdList)

--*/
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, first, build the new schema path...
    //
    PSTR    pszBase = NULL;
    PSTR   *ppszValues = NULL;
    ULONG   cValues;
    DWORD   i,j;

    pszBase = (PSTR)LocalAlloc(LMEM_FIXED,
                               3                        +   // strlen("CN=")
                               strlen(pszObject)        +
                               1                        +   // strlen(",")
                               strlen(pszSchemaPath)    +
                               1);
    if(pszBase == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        sprintf(pszBase,
                "CN=%s,%s",
                pszObject,
                pszSchemaPath);


        //
        // We may not always want the object name
        //
        if(ppwszObjIdAsString != NULL)
        {
            dwErr = LDAPReadAttribute(pszBase,
                                      "SchemaIdGUID",
                                      pLDAP,
                                      &cValues,
                                      &ppszValues);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // The object we get back is actually a GUID
                //
                GUID   *pGuid = (GUID *)ppszValues[0];

                dwErr = UuidToStringW((GUID *)ppszValues[0],
                                      ppwszObjIdAsString);


                LDAPFreeValues(ppszValues);
            }
        }

        //
        // Then, if that worked, and we need to, we'll read the default
        // security
        //
        if(dwErr == ERROR_SUCCESS && ppAccess != NULL)
        {
            dwErr = LDAPReadAttribute(pszBase,
                                      "defaultSecurityDescriptor",
                                      pLDAP,
                                      &cValues,
                                      &ppszValues);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Get it as a security descriptor
                //
                PSECURITY_DESCRIPTOR pSD =
                                        (PSECURITY_DESCRIPTOR)ppszValues[0];
                //
                // This is an NT5 security API
                //
                dwErr = ConvertSecurityDescriptorToAccessNamedW
                                (NULL,               // There is no object
                                 SE_DS_OBJECT,
                                 pSD,
                                 ppAccess,
                                 NULL,
                                 NULL,
                                 NULL);
                LDAPFreeValues(ppszValues);
            }
            else
            {
                //
                // If the attribute wasn't found, try looking up the chain
                //
                if(dwErr == LDAP_NO_SUCH_ATTRIBUTE)
                {
                    dwErr = LDAPReadAttribute(pszBase,
                                              "subClassOf",
                                              pLDAP,
                                              &cValues,
                                              &ppszValues);
                    //
                    // Ok, if that worked, we'll call ourselves.  Note that
                    // we don't care about the object name
                    //
                    if(dwErr == ERROR_SUCCESS)
                    {
                        dwErr = LDAPReadSecAndObjIdAsString(pLDAP,
                                                            ppszValues[0],
                                                            pszSchemaPath,
                                                            NULL,
                                                            ppAccess);
                        LDAPFreeValues(ppszValues);
                    }
                }
            }

            //
            // If it worked in that we read the access, we'll go through
            // and create all these as inherit entries
            //
            if(dwErr == ERROR_SUCCESS)
            {
                for(i = 0; i < (DWORD)((*ppAccess)->cEntries); i++)
                {
                    for(j = 0;
                        j < (DWORD)((*ppAccess)->pPropertyAccessList[i].
                                                  pAccessEntryList->cEntries);
                        j++)
                    {
                        (*ppAccess)->pPropertyAccessList[i].
                                pAccessEntryList->pAccessList[j].
                                      lpInheritProperty = *ppwszObjIdAsString;
                        (*ppAccess)->pPropertyAccessList[i].
                              pAccessEntryList->pAccessList[j].Inheritance |=
                                           SUB_CONTAINERS_AND_OBJECTS_INHERIT;
                    }
                }
            }

            //
            // If it failed, don't forget to deallocate our memory
            //
            if(dwErr != ERROR_SUCCESS && ppwszObjIdAsString != NULL)
            {
                RpcStringFree(ppwszObjIdAsString);
            }
        }

        //
        // Free our memory
        //
        LocalFree(pszBase);
    }
    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\dsacls\dsace.h ===
#ifndef _DSACLS_DSACE_H
#define _DSACLS_DSACE_H

#include <iostream>
#include <algorithm>
#include <functional>
#include <list>
using namespace std;

typedef enum _DSACLS_OBJECT_TYPE_TYPE
{
    DSACLS_SELF = 0,     
    DSACLS_CHILD_OBJECTS,
    DSACLS_PROPERTY,
    DSACLS_EXTENDED_RIGHTS,
    DSACLS_VALIDATED_RIGHTS,
    DSACLS_UNDEFINED
        
} DSACLS_OBJECT_TYPE_TYPE;

class CAce
{

typedef enum _DSACLS_ACE_TYPE
{
   ALLOW = 0,
   DENY,
   AUDIT_SUCCESS,
   AUDIT_FAILURE,
   AUDIT_ALL
}DSACLS_ACE_TYPE;


private:
   //Members Present in Ace
   BYTE              m_AceFlags;
   ACCESS_MASK       m_Mask;
   GUID              m_GuidObjectType;
   GUID              m_GuidInheritedObjectType;
   PSID              m_pSid;

   //Data given by users to build an Ace
   ACCESS_MODE       m_AccessMode;
   LPWSTR            m_szTrusteeName;
   LPWSTR            m_szObjectType;               //LDAP display name of CHILD_OBJECT, 
   LPWSTR            m_szInheritedObjectType;

   //Misc Info
   ULONG             m_Flags;                      // ACE_OBJECT_TYPE_PRESENT, etc.   
   DSACLS_OBJECT_TYPE_TYPE m_ObjectTypeType;   
   DSACLS_ACE_TYPE   m_AceType;
   BOOL              m_bErased;                    //This flag is used to mark the ace as deleted.
   //These two are used for format of display
   UINT m_nAllowDeny;              
   UINT m_nAudit;

protected:
   //Is ACE Allow or DENY
   DSACLS_ACE_TYPE  GetAceType( PACE_HEADER pAceHeader )
   {
      if( pAceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE )
      {
         if( pAceHeader->AceFlags &  SUCCESSFUL_ACCESS_ACE_FLAG 
             && pAceHeader->AceFlags & FAILED_ACCESS_ACE_FLAG ) 
            return AUDIT_ALL;
         else if( pAceHeader->AceFlags &  SUCCESSFUL_ACCESS_ACE_FLAG )
            return AUDIT_SUCCESS;
         else if( pAceHeader->AceFlags & FAILED_ACCESS_ACE_FLAG ) 
            return AUDIT_FAILURE;
         else
            ASSERT(FALSE);
      }
      if( pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE ||
          pAceHeader->AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE )
          return ALLOW;
      else 
         return DENY;
   }
public:
   BYTE GetAceFlags(){ return m_AceFlags; }
   ACCESS_MASK GetAccessMask(){ return m_Mask; }
   GUID* GetGuidObjectType();
   VOID SetGuidObjectType( GUID * guid ){ m_GuidObjectType = *guid; }
   GUID* GetGuidInheritType();
   VOID SetGuidInheritType( GUID *guid ){ m_GuidInheritedObjectType = *guid; }
	PSID GetSID(){ return m_pSid; }

   ACCESS_MODE  GetAccessMode() { return m_AccessMode; }
   LPWSTR GetObjectType(){ return m_szObjectType; };
   VOID SetObjectType( LPWSTR pszName ) { CopyUnicodeString( &m_szObjectType, pszName ); }
   LPWSTR GetInheritedObjectType(){ return m_szInheritedObjectType; }
   VOID SetInheritedObjectType( LPWSTR pszName ) { CopyUnicodeString( &m_szInheritedObjectType, pszName ); }

   BOOL IsObjectTypePresent(){ return m_Flags & ACE_OBJECT_TYPE_PRESENT; }
   BOOL IsInheritedTypePresent(){ return m_Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT; }
   VOID SetObjectTypeType( DSACLS_OBJECT_TYPE_TYPE ot ){ m_ObjectTypeType = ot; }
   DSACLS_OBJECT_TYPE_TYPE GetObjectTypeType() { return m_ObjectTypeType; }

	UINT GetTrusteeLength()
   {
    if( m_szTrusteeName )
      return wcslen( m_szTrusteeName ); 
    else
      return 0;
   }

   
   VOID SetErased( BOOL bErase ){ m_bErased = bErase; }
   BOOL IsErased( ){ return m_bErased; }
   //Is ACE Effective on the object
   BOOL CAce::IsEffective(){ return !FlagOn( m_AceFlags, INHERIT_ONLY_ACE ); }
   //Is ACE Inherited to all child Objects
   BOOL CAce::IsInheritedToAll()
   {
      return ( FlagOn( m_AceFlags, CONTAINER_INHERIT_ACE ) && 
               !FlagOn( m_Flags, ACE_INHERITED_OBJECT_TYPE_PRESENT ) );
   }
   //Is Ace Inherited to Specific child object
   BOOL CAce::IsInheritedToSpecific()
   {
      return ( FlagOn( m_AceFlags, INHERIT_ONLY_ACE ) && 
               FlagOn( m_Flags, ACE_INHERITED_OBJECT_TYPE_PRESENT ) );
   }
   //Is Ace inherited from parent
   BOOL CAce::IsInheritedFromParent(){ return FlagOn( m_AceFlags, INHERITED_ACE );}

   VOID Display( UINT nMaxTrusteeLength );

   //Constructor
   CAce();
   ~CAce();
   DWORD Initialize( PACE_HEADER ace,
                     UINT nAllowDeny,
                     UINT nAudit 
                     );   
   DWORD Initialize( LPWSTR pszTrustee,
                     LPWSTR pszObjectId,
                     LPWSTR pszInheritId,
                     ACCESS_MODE AccessMode,
                     ACCESS_MASK Access,
                     BYTE Inheritance
                   );

};

class CACE_SORT:public greater<CAce*>
{
   bool operator()( CAce * a, CAce * b )
   {
      if( wcscmp( a->GetInheritedObjectType(),
                     b->GetInheritedObjectType() ) > 0 )
                     return true;
      else
         return false;
                     
   }
};

class CAcl
{
public:
   VOID AddAce( CAce * pAce );
   VOID MergeAcl( CAcl * pAcl );
   DWORD BuildAcl( PACL * pAcl );

	VOID Display();
   DWORD Initialize( BOOL bProtected, PACL pAcl, UINT nAllowDeny, UINT nAudit); 
   BOOL VerifyAllNames();
   VOID GetInfoFromCache();
   
   UINT m_nMaxTrusteeLength;     //This length is maintained for formating the display
   ~CAcl();
private:
   list<CAce*> listAces;               //List represnting an ACL

   //These three used only for display purposes
   list<CAce *> listEffective;         //List of Aces Effective directly on the object;
   list<CAce *> listInheritedAll;      //List of Aces Inherited to all sub objects;
   list<CAce *> listInheritedSpecific; //List of Aces Inherited to <Inherited Object Class>

   BOOL bAclProtected;                 //Is Acl protected
};


/*
CCache mainitains a cache of GUIDs And Display Name
*/
typedef enum _DSACLS_SERACH_IN
{
    BOTH = 0,
    SCHEMA,
    CONFIGURATION
} DSACLS_SEARCH_IN;

typedef enum _DSACLS_RESOLVE
{
   RESOLVE_NAME = 0,
   RESOLVE_GUID
}DSACLS_RESOLVE;

typedef struct _DSACL_CACHE_ITEM
{
   GUID Guid;
   LPWSTR pszName;
   DSACLS_OBJECT_TYPE_TYPE ObjectTypeType;
   DSACLS_SEARCH_IN searchIn;
   DSACLS_RESOLVE resolve;
   BOOL bResolved;
}DSACL_CACHE_ITEM, * PDSACL_CACHE_ITEM;

class CCache
{
public:
   DWORD AddItem( IN GUID *pGuid,
                  IN DSACLS_SEARCH_IN s = BOTH );

   DWORD AddItem( IN LPWSTR pszName,
                  IN DSACLS_SEARCH_IN s = BOTH );
   
   DWORD BuildCache();

   PDSACL_CACHE_ITEM LookUp( LPWSTR pszName );
   PDSACL_CACHE_ITEM LookUp( GUID* pGuid );
   ~CCache();


private:
   list<PDSACL_CACHE_ITEM> m_listItem;
   list<PDSACL_CACHE_ITEM> m_listCache;
   
   //Methods
   DWORD SearchSchema();
   DWORD SearchConfiguration();
};

DSACLS_OBJECT_TYPE_TYPE GetObjectTypeType( INT validAccesses );
DSACLS_OBJECT_TYPE_TYPE GetObjectTypeType( LPWSTR szObjectCategory );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\dsacls\stdafx.cpp ===
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\dsacls\stdafx.h ===
/*
This is predefined header file.

*/

#ifndef _STDAFX_H
#define _STDAFX_H

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <lm.h>
#include <lmapibuf.h>
#include <objbase.h>
#include <ntdsapi.h>
#include "rpc.h"
#include "rpcndr.h"
#include <windows.h>
#include "ole2.h"
#include <activeds.h>
#include "dsgetdc.h"
#include "sddl.h"
#include "seopaque.h"
#include "adshlp.h"
#include <aclapi.h>
//#include <permit.h>
#include <activeds.h>
#include <ntlsa.h>
#include <winldap.h>
#include <sddlp.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\dsacls\dsacls.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dsacls.h

Abstract:

    The main header file for the dsacls tool

Author:

    Mac McLain  (MacM)    10-02-96

Environment:

    User Mode

Revision History:


--*/

#ifndef _DSACLS_H
#define _DSACLS_H

#include <caclsmsg.h>
#include "accctrl.h"

#define FLAG_ON(flags,bit)        ((flags) & (bit))
//Some Error Checking Macros
#define CHECK_NULL( ptr, jump_loc )  \
if( ptr == NULL ) \
{  \
   dwErr = ERROR_NOT_ENOUGH_MEMORY; \
   goto jump_loc; \
}  


#define CHECK_HR( hr, jump_loc ) \
if( hr != S_OK )  \
{  \
   dwErr = HRESULT_CODE( hr );   \
   goto jump_loc; \
}  \

//
// Local prototypes
//
#if DSACL_DBG
ULONG gfDebug;
#endif

//
// Type of operation to perform
//
typedef enum _DSACLS_OP
{
    REVOKE = 0,
    GRANT,
    DENY
} DSACLS_OP;

#define DSACLS_EXTRA_INFO_NONE      0
#define DSACLS_EXTRA_INFO_REQUIRED  1
#define DSACLS_EXTRA_INFO_OPTIONAL  2

typedef struct _DSACLS_ARG {
    ULONG ResourceId;
    PWSTR String;
    ULONG Length;
    ULONG StartIndex;
    ULONG Flag;
    ULONG SkipCount;
    BOOLEAN SkipNonFlag;
    WORD ExtraInfo;
} DSACLS_ARG, *PDSACLS_ARG;

typedef struct _DSACLS_INHERIT {
    ULONG ResourceId;
    PWSTR String;
    ULONG Length;
    BOOLEAN ValidForInput;
    ULONG InheritFlag;

} DSACLS_INHERIT, *PDSACLS_INHERIT;

typedef struct _DSACLS_RIGHTS {
    ULONG ResourceId;
    PWSTR String;
    ULONG ResourceIdEx;
    PWSTR StringEx;
    ULONG Length;
    ULONG Right;

} DSACLS_RIGHTS, *PDSACLS_RIGHTS;

typedef struct _DSACLS_PROTECT {
   ULONG ResourceId;
   PWSTR String;
   ULONG Length;
   ULONG Right;
} DSACLS_PROTECT, *PDSACLS_PROTECT;

extern LPWSTR g_szSchemaNamingContext;
extern LPWSTR g_szConfigurationNamingContext;
extern HMODULE g_hInstance;
extern LPWSTR g_szServerName;
extern CCache *g_Cache;

//
// Prototypes from dsacls.c
//


DWORD 
InitializeGlobalArrays();

DWORD
ConvertArgvToUnicode( LPWSTR * wargv, 
                      char ** argv, 
                      int argc ) ;

DWORD
WriteObjectSecurity( IN LPWSTR pszObject,
                     IN SECURITY_INFORMATION si,
                     IN PSECURITY_DESCRIPTOR pSD );





//
// prototypes from refresh.c
//
DWORD
SetDefaultSecurityOnObjectTree(
    IN PWSTR ObjectPath,
    IN BOOLEAN Propagate,
	IN SECURITY_INFORMATION Protection
    );


void MapGeneric( ACCESS_MASK * pMask );
void DisplayAccessRights( UINT nSpace, ACCESS_MASK m_Mask );

void ConvertAccessMaskToGenericString( ACCESS_MASK m_Mask, LPWSTR szLoadBuffer, UINT nBuffer );
DWORD BuildExplicitAccess( IN PSID pSid,
                           IN GUID* pGuidObject,
                           IN GUID* pGuidInherit,
                           IN ACCESS_MODE AccessMode,
                           IN ULONG Access,
                           IN ULONG Inheritance,
                           OUT PEXPLICIT_ACCESS pExplicitAccess );


DWORD ParseUserAndPermissons( IN LPWSTR pszArgument,
                              IN DSACLS_OP Op,
                              IN ULONG RightsListCount,
                              IN PDSACLS_RIGHTS RightsList,
                              OUT LPWSTR * ppszTrusteeName,
                              OUT PULONG  pAccess,
                              OUT LPWSTR * ppszObjectId,
                              OUT LPWSTR * ppszInheritId );

//
// Define the rights used in the DS
//

#define RIGHT_DS_CREATE_CHILD     ACTRL_DS_CREATE_CHILD
#define RIGHT_DS_DELETE_CHILD     ACTRL_DS_DELETE_CHILD
#define RIGHT_DS_DELETE_SELF      DELETE
#define RIGHT_DS_LIST_CONTENTS    ACTRL_DS_LIST
#define RIGHT_DS_WRITE_PROPERTY_EXTENDED  ACTRL_DS_SELF
#define RIGHT_DS_READ_PROPERTY    ACTRL_DS_READ_PROP
#define RIGHT_DS_WRITE_PROPERTY   ACTRL_DS_WRITE_PROP
#define RIGHT_DS_DELETE_TREE      ACTRL_DS_DELETE_TREE
#define RIGHT_DS_LIST_OBJECT      ACTRL_DS_LIST_OBJECT
#ifndef ACTRL_DS_CONTROL_ACCESS
#define ACTRL_DS_CONTROL_ACCESS   ACTRL_PERM_9
#endif
#define RIGHT_DS_CONTROL_ACCESS   ACTRL_DS_CONTROL_ACCESS
//
// Define the generic rights
//

// generic read
#define GENERIC_READ_MAPPING     ((STANDARD_RIGHTS_READ)     | \
                                  (RIGHT_DS_LIST_CONTENTS)   | \
                                  (RIGHT_DS_READ_PROPERTY)   | \
                                  (RIGHT_DS_LIST_OBJECT))

// generic execute
#define GENERIC_EXECUTE_MAPPING  ((STANDARD_RIGHTS_EXECUTE)  | \
                                  (RIGHT_DS_LIST_CONTENTS))
// generic right
#define GENERIC_WRITE_MAPPING    ((STANDARD_RIGHTS_WRITE)    | \
                                  (RIGHT_DS_WRITE_PROPERTY_EXTENDED)  | \
                  (RIGHT_DS_WRITE_PROPERTY))
// generic all

#define GENERIC_ALL_MAPPING      ((STANDARD_RIGHTS_REQUIRED) | \
                                  (RIGHT_DS_CREATE_CHILD)    | \
                                  (RIGHT_DS_DELETE_CHILD)    | \
                                  (RIGHT_DS_DELETE_TREE)     | \
                                  (RIGHT_DS_READ_PROPERTY)   | \
                                  (RIGHT_DS_WRITE_PROPERTY)  | \
                                  (RIGHT_DS_LIST_CONTENTS)   | \
                                  (RIGHT_DS_LIST_OBJECT)     | \
                                  (RIGHT_DS_CONTROL_ACCESS)  | \
                                  (RIGHT_DS_WRITE_PROPERTY_EXTENDED))

//
// Standard DS generic access rights mapping
//

#define DS_GENERIC_MAPPING {GENERIC_READ_MAPPING,    \
                GENERIC_WRITE_MAPPING,   \
                GENERIC_EXECUTE_MAPPING, \
                GENERIC_ALL_MAPPING}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\dsacls\refresh.cpp ===
/*++

Copyright (c) 1998 - 1998  Microsoft Corporation

Module Name:

    refresh.c

Abstract:

    This Module implements the delegation tool, which allows for the management
    of access to DS objects

Author:

    Mac McLain  (MacM)    10-15-96

Environment:

    User Mode

Revision History:

--*/
#include "stdafx.h"
#include "utils.h"
#include "dsace.h"
#include "dsacls.h"


typedef struct _DEFAULT_SD_NODE  {

    PWSTR ObjectClass;
    PSECURITY_DESCRIPTOR DefaultSd;
    struct _DEFAULT_SD_NODE *Next;

} DEFAULT_SD_NODE, *PDEFAULT_SD_NODE;

typedef struct _DEFAULT_SD_INFO {

    LDAP *Ldap;
    PWSTR SchemaPath;
    PSID DomainSid;
    PDEFAULT_SD_NODE SdList;
} DEFAULT_SD_INFO, *PDEFAULT_SD_INFO;

#define DSACL_ALL_FILTER        L"(ObjectClass=*)"
#define DSACL_SCHEMA_NC         L"schemaNamingContext"
#define DSACL_OBJECT_CLASS      L"objectClass"
#define DSACL_LDAP_DN           L"(ldapDisplayName="
#define DSACL_LDAP_DN_CLOSE     L")"
#define DSACL_DEFAULT_SD        L"defaultSecurityDescriptor"




DWORD
FindDefaultSdForClass(
    IN PWSTR ClassId,
    IN PDEFAULT_SD_INFO SdInfo,
    IN OUT PDEFAULT_SD_NODE *DefaultSdNode
    )
/*++

Routine Description:

    This routine will search the SD_INFO list for an existing entry that matches the current
    class type.  If no such entry is found, one will be created from information from the schema

Arguments:

    ClassId - ClassId to find the default SD node for
    SdInfo - Current list of default SDs and associated information
    DefaultSdNode - Where the locted node is returned

Returns:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR Attributes[] = {
        NULL,
        NULL
        };
    LDAPMessage *Message = NULL, *Entry;
    PWSTR Filter = NULL, SchemaObjectDn = NULL, DefaultSd = NULL, *DefaultSdList = NULL;
    PDEFAULT_SD_NODE Node;

    *DefaultSdNode = NULL;

    Node = SdInfo->SdList;

    while ( Node ) {

        if ( !_wcsicmp( Node->ObjectClass, ClassId ) ) {

            *DefaultSdNode = Node;
            break;
        }

        Node = Node->Next;
    }

    //
    // If it wasn't found, we'll have to go out and load it out of the Ds.
    //
    if ( !Node ) {

        Filter = (LPWSTR)LocalAlloc( LMEM_FIXED,
                             sizeof( DSACL_LDAP_DN ) - sizeof( WCHAR ) +
                                ( wcslen( ClassId ) * sizeof( WCHAR ) ) +
                                sizeof( DSACL_LDAP_DN_CLOSE ) );
        if ( !Filter ) {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
            goto FindDefaultExit;
        }

        swprintf( Filter,
                  L"%ws%ws%ws",
                  DSACL_LDAP_DN,
                  ClassId,
                  DSACL_LDAP_DN_CLOSE );

        //
        // Now, do the search
        //
        Win32Err = LdapMapErrorToWin32( ldap_search_s( SdInfo->Ldap,
                                                       SdInfo->SchemaPath,
                                                       LDAP_SCOPE_SUBTREE,
                                                       Filter,
                                                       Attributes,
                                                       0,
                                                       &Message ) );

        if ( Win32Err != ERROR_SUCCESS ) {

            goto FindDefaultExit;
        }

        Entry = ldap_first_entry( SdInfo->Ldap, Message );

        if ( Entry ) {

            SchemaObjectDn = ldap_get_dn( SdInfo->Ldap, Entry );
            ldap_msgfree( Message );

            if ( !SchemaObjectDn ) {

                Win32Err = ERROR_NOT_ENOUGH_MEMORY;
                goto FindDefaultExit;

            }
        } else {

            Win32Err = LdapMapErrorToWin32( SdInfo->Ldap->ld_errno );
            goto FindDefaultExit;
        }

        //
        // Ok, now we can read the default security descriptor
        //
        Attributes[ 0 ] = DSACL_DEFAULT_SD;
        Win32Err = LdapMapErrorToWin32( ldap_search_s( SdInfo->Ldap,
                                                       SchemaObjectDn,
                                                       LDAP_SCOPE_BASE,
                                                       DSACL_ALL_FILTER,
                                                       Attributes,
                                                       0,
                                                       &Message ) );
        Entry = ldap_first_entry( SdInfo->Ldap, Message );

        if ( Entry ) {

            //
            // Now, we'll have to get the values
            //
            DefaultSdList = ldap_get_values( SdInfo->Ldap, Entry, Attributes[ 0 ] );

            if ( DefaultSdList ) {

                DefaultSd = DefaultSdList[ 0 ];

            } else {

                Win32Err = LdapMapErrorToWin32( SdInfo->Ldap->ld_errno );
                goto FindDefaultExit;
            }

            ldap_msgfree( Message );
        }


        //
        // Find a new node and insert it
        //
        Node = (DEFAULT_SD_NODE*)LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                           sizeof( DEFAULT_SD_NODE ) );
        if ( !Node ) {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
            goto FindDefaultExit;
        }


        if ( !ConvertStringSDToSDRootDomain( SdInfo->DomainSid,
                                             DefaultSd,
                                             SDDL_REVISION,
                                             &Node->DefaultSd,
                                             NULL ) ) {


            Win32Err = GetLastError();
        }

        if ( Win32Err == ERROR_SUCCESS ) {

            Node->ObjectClass =(LPWSTR) LocalAlloc( LMEM_FIXED,
                                            ( wcslen( ClassId ) + 1 ) * sizeof( WCHAR ) );

            if ( Node->ObjectClass == NULL ) {

                Win32Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                wcscpy( Node->ObjectClass, ClassId );

                Node->Next = SdInfo->SdList;
                SdInfo->SdList = Node;
            }
        }

        if ( Win32Err != ERROR_SUCCESS ) {

            LocalFree( Node->DefaultSd );
            LocalFree( Node->ObjectClass );
            LocalFree( Node );

        } else {

            *DefaultSdNode = Node;
        }




    }



FindDefaultExit:

    LocalFree( Filter );

    if ( SchemaObjectDn ) {

        ldap_memfree( SchemaObjectDn );
    }

    if ( DefaultSdList ) {

        ldap_value_free( DefaultSdList );
    }
    return( Win32Err );
}




DWORD
SetDefaultSdForObject(
    IN LDAP *Ldap,
    IN PWSTR ObjectPath,
    IN PDEFAULT_SD_INFO SdInfo,
	IN SECURITY_INFORMATION Protection
    )
/*++

Routine Description:

    This routine set the default security descriptor on the indicated object

Arguments:

    Ldap - Ldap connect to the server holding the object
    ObjectPath - 1779 style path to the object
    SdInfo - Current list of default SDs and associated information

Returns:

    ERROR_SUCCESS - Success
    ERROR_DS_NAME_TYPE_UNKNOWN - Unable to determine the class id of the object

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR Attributes[] = {
        DSACL_OBJECT_CLASS,
        NULL
        };
    LDAPMessage *Message = NULL, *Entry;
    PWSTR ClassId = NULL;
    PWSTR *ClassList = NULL;
    ULONG i;
    PDEFAULT_SD_NODE DefaultSdNode = NULL;
    PACTRL_ACCESS NewAccess = NULL;
    PACTRL_AUDIT NewAudit = NULL;

    //
    // First, get the class id off of the object
    //
    Win32Err = LdapMapErrorToWin32( ldap_search_s( Ldap,
                                                   ObjectPath,
                                                   LDAP_SCOPE_BASE,
                                                   DSACL_ALL_FILTER,
                                                   Attributes,
                                                   0,
                                                   &Message ) );

    if ( Win32Err != ERROR_SUCCESS ) {

        goto SetDefaultExit;
    }

    Entry = ldap_first_entry( Ldap, Message );

    if ( Entry ) {

        //
        // Now, we'll have to get the values
        //
        ClassList = ldap_get_values( Ldap, Entry, Attributes[ 0 ] );

        if ( ClassList ) {

            //
            // Get the class id
            //
            i = 0;
            while ( TRUE ) {

                if ( ClassList[ i ] ) {

                    i++;

                } else {

                    break;
                }
            }

//            ASSERT( i > 0 );
            if ( i == 0 ) {

                Win32Err = ERROR_DS_NAME_TYPE_UNKNOWN;
                goto SetDefaultExit;
            }
            ClassId = ClassList[ i - 1 ];

        } else {

            Win32Err = LdapMapErrorToWin32( Ldap->ld_errno );
            goto SetDefaultExit;
        }

        ldap_msgfree( Message );
        Message = NULL;
    }

    if ( !ClassId ) {

        Win32Err = ERROR_DS_NAME_TYPE_UNKNOWN;
                goto SetDefaultExit;
    }
    //
    // Now, see if we have a cache entry for that...
    //
    Win32Err =  FindDefaultSdForClass( ClassId,
                                       SdInfo,
                                       &DefaultSdNode );

    if ( Win32Err != ERROR_SUCCESS ) {

        goto SetDefaultExit;
    }


    //
    // Ok, we have everything we need, so let's go ahead and set it all
    //
/*    Win32Err = ConvertSecurityDescriptorToAccessNamed(  ObjectPath,
                                                        SE_DS_OBJECT_ALL,
                                                        DefaultSdNode->DefaultSd,
                                                        &NewAccess,
                                                        &NewAudit,
                                                        NULL,
                                                        NULL );
*/
    if ( Win32Err == ERROR_SUCCESS ) {


          Win32Err = WriteObjectSecurity(ObjectPath,
                                         DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION | Protection,
                                         DefaultSdNode->DefaultSd
                                          );
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        DisplayMessageEx( 0, MSG_DSACLS_PROCESSED, ObjectPath );
    }


SetDefaultExit:

    if ( ClassList ) {

        ldap_value_free( ClassList );
    }

    if ( Message ) {

        ldap_msgfree( Message );
    }

    LocalFree( NewAccess );
    LocalFree( NewAudit );

    return( Win32Err );
}




DWORD
SetDefaultSdForObjectAndChildren(
    IN LDAP *Ldap,
    IN PWSTR ObjectPath,
    IN PDEFAULT_SD_INFO SdInfo,
    IN BOOLEAN Propagate,
	IN SECURITY_INFORMATION Protection
    )
/*++

Routine Description:

    This routine will set the security descriptor on the object and potentially all of its
    children to the default security as obtained from the schema

Arguments:

    Ldap - Ldap connect to the server holding the object
    ObjectPath - 1779 style path to the object
    SdInfo - Current list of default SDs and associated information
    Propagate - If TRUE, reset the security on the children as well

Returns:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR Attributes[] = {
        NULL
        };
    LDAPMessage *Message = NULL, *Entry;
    PWSTR ChildName = NULL;
    PLDAPSearch SearchHandle = NULL;
    ULONG Count;

    //
    // First, get the class id off of the object
    //
    SearchHandle = ldap_search_init_pageW( Ldap,
                                           ObjectPath,
                                           Propagate ? LDAP_SCOPE_SUBTREE : LDAP_SCOPE_BASE,
                                           DSACL_ALL_FILTER,
                                           Attributes,
                                           FALSE,
                                           NULL,
                                           NULL,
                                           0,
                                           2000,
                                           NULL );

    if ( SearchHandle == NULL ) {

        Win32Err = LdapMapErrorToWin32( LdapGetLastError( ) );

    } else {

        while ( Win32Err == ERROR_SUCCESS ) {

            Count = 0;

            //
            // Get the next page
            //
            Win32Err = ldap_get_next_page_s( Ldap,
                                             SearchHandle,
                                             NULL,
                                             100,
                                             &Count,
                                             &Message );

            if ( Message ) {

                Entry = ldap_first_entry( Ldap, Message );

                while ( Entry ) {

                    ChildName = ldap_get_dn( SdInfo->Ldap, Entry );

                    if ( !ChildName ) {

                        Win32Err = ERROR_NOT_ENOUGH_MEMORY;
                        break;

                    }


                    Win32Err = SetDefaultSdForObject( Ldap,
                                                      ChildName,
                                                      SdInfo,
													  Protection);

                    ldap_memfree( ChildName );
                    if ( Win32Err != ERROR_SUCCESS ) {

                        break;
                    }

                    Entry = ldap_next_entry( Ldap, Entry );
                }

                Win32Err = Ldap->ld_errno;
                ldap_msgfree( Message );
                Message = NULL;
            }

            if ( Win32Err == LDAP_NO_RESULTS_RETURNED ) {

                Win32Err = ERROR_SUCCESS;
                break;
            }

        }

        ldap_search_abandon_page( Ldap,
                                  SearchHandle );
    }

    return( Win32Err );
}




DWORD
BindToDsObject(
    IN PWSTR ObjectPath,
    OUT PLDAP *Ldap,
    OUT PSID *DomainSid OPTIONAL
    )
/*++

Routine Description:

    This routine will bind to the ldap server on a domain controller that holds the specified
    object path.  Optionally, the sid of the domain hosted by that domain controller is returned

Arguments:

    ObjectPath - 1779 style path to the object
    Ldap - Where the ldap connection handle is returned
    DomainSid - Sid of the domain hosted by the domain controller.

Returns:

    ERROR_SUCCESS - Success
    ERROR_PATH_NOT_FOUND - A domain controller for this path could not be located
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR ServerName = NULL;
    PWSTR Separator = NULL;
    PDOMAIN_CONTROLLER_INFO DcInfo = NULL;
    PWSTR Path = NULL;
    HANDLE DsHandle = NULL;
    PDS_NAME_RESULT NameRes = NULL;
    BOOLEAN NamedServer = FALSE;
    UNICODE_STRING ServerNameU;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE LsaHandle;
    PPOLICY_PRIMARY_DOMAIN_INFO PolicyPDI = NULL;
    NTSTATUS Status;

    //
    // Get a server name
    //
/*    if ( wcslen( ObjectPath ) > 2 && *ObjectPath == L'\\' && *( ObjectPath + 1 ) == L'\\' ) {

        Separator = wcschr( ObjectPath + 2, L'\\' );

        if ( Separator ) {

            *Separator = L'\0';
            Path = Separator + 1;
        }

        ServerName = ObjectPath + 2;
        NamedServer = TRUE;

    } else {

        Path = ObjectPath;

        Win32Err = DsGetDcName( NULL,
                                NULL,
                                NULL,
                                NULL,
                                DS_IP_REQUIRED |
                                    DS_DIRECTORY_SERVICE_REQUIRED,
                                &DcInfo );
        if ( Win32Err == ERROR_SUCCESS ) {

            ServerName = DcInfo[ 0 ].DomainControllerName + 2;
        }

    }

    //
    // Do the bind and crack
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsBind( ServerName,
                           NULL,
                           &DsHandle );

        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = DsCrackNames( DsHandle,
                                     DS_NAME_NO_FLAGS,
                                     DS_FQDN_1779_NAME,
                                     DS_FQDN_1779_NAME,
                                     1,
                                     &Path,
                                     &NameRes );

            if ( Win32Err == ERROR_SUCCESS ) {

                if ( NameRes->cItems != 0  && !NamedServer &&
                     NameRes->rItems[ 0 ].status == DS_NAME_ERROR_DOMAIN_ONLY ) {

                    NetApiBufferFree( DcInfo );
                    DcInfo = NULL;

                    Win32Err = DsGetDcNameW( NULL,
                                             NameRes->rItems[ 0 ].pDomain,
                                             NULL,
                                             NULL,
                                             DS_IP_REQUIRED |
                                                DS_DIRECTORY_SERVICE_REQUIRED,
                                             &DcInfo );

                    if ( Win32Err == ERROR_SUCCESS ) {

                        DsUnBindW( &DsHandle );
                        DsHandle = NULL;

                        ServerName = DcInfo->DomainControllerName + 2;

                        //Win32Err = DsBind( DcInfo->DomainControllerAddress,
                        //                   NULL,
                        //                   &DsHandle );
                        //

                        Win32Err = DsBind( ServerName,
                                           NULL,
                                           &DsHandle );
                        
                        if ( Win32Err == ERROR_SUCCESS ) {

                            Win32Err = DsCrackNames( DsHandle,
                                                     DS_NAME_NO_FLAGS,
                                                     DS_FQDN_1779_NAME,
                                                     DS_FQDN_1779_NAME,
                                                     1,
                                                     &Path,
                                                     &NameRes);
                        }

                    }

                }
            }

        }
    }
*/
    //
    // Now, do the bind
    //



            *Ldap = ldap_open( g_szServerName,
                               LDAP_PORT );

            if ( *Ldap == NULL ) {

                Win32Err = ERROR_PATH_NOT_FOUND;

            } else {

                Win32Err = LdapMapErrorToWin32( ldap_bind_s( *Ldap,
                                                             NULL,
                                                             NULL,
                                                             LDAP_AUTH_SSPI ) );
            }




    //
    // If specified, get the sid for the domain
    //
    if ( DomainSid ) {

        RtlInitUnicodeString( &ServerNameU, g_szServerName );
        InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, NULL );

        //
        // Get the sid of the domain
        //
        Status = LsaOpenPolicy( &ServerNameU,
                                &ObjectAttributes,
                                POLICY_VIEW_LOCAL_INFORMATION,
                                &LsaHandle );

        if ( NT_SUCCESS( Status ) ) {

            Status = LsaQueryInformationPolicy( LsaHandle,
                                                PolicyPrimaryDomainInformation,
                                                ( PVOID * )&PolicyPDI );

            if ( NT_SUCCESS( Status ) ) {

                *DomainSid = (PSID)LocalAlloc( LMEM_FIXED,
                                         RtlLengthSid( PolicyPDI->Sid ) );

                if ( *DomainSid == NULL ) {

                    Status = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    RtlCopySid( RtlLengthSid( PolicyPDI->Sid ), *DomainSid, PolicyPDI->Sid );
                }

                LsaFreeMemory( PolicyPDI );
            }
            LsaClose( LsaHandle );
        }

        if ( !NT_SUCCESS( Status ) ) {

            Win32Err = RtlNtStatusToDosError( Status );
            ldap_unbind( *Ldap );
            *Ldap = NULL;
        }

    }



    return( Win32Err );
}




DWORD
SetDefaultSecurityOnObjectTree(
    IN PWSTR ObjectPath,
    IN BOOLEAN Propagate,
	IN SECURITY_INFORMATION Protection
    )
/*++

Routine Description:

    This routine will set the security descriptor on the object and potentially all of its
    children to the default security as obtained from the schema

Arguments:

    ObjectPath - 1779 style path to the object
    Propagate - If TRUE, reset the security on the children as well

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR Attributes[] = {
        DSACL_SCHEMA_NC,
        NULL
        };
    LDAPMessage *Message, *Entry;
    PWSTR *PathList = NULL;
    DEFAULT_SD_INFO SdInfo = {
        NULL,
        NULL,
        NULL,
        NULL
        };
    PDEFAULT_SD_NODE CleanupNode;

    //
    // Bind to the ds object
    //
    Win32Err = BindToDsObject( ObjectPath,
                               &SdInfo.Ldap,
                               &SdInfo.DomainSid );

    if ( Win32Err != ERROR_SUCCESS ) {

        goto SetDefaultExit;
    }

    //
    // Get the schema path
    //

    Win32Err = LdapMapErrorToWin32( ldap_search_s( SdInfo.Ldap,
                                                   NULL,
                                                   LDAP_SCOPE_BASE,
                                                   DSACL_ALL_FILTER,
                                                   Attributes,
                                                   0,
                                                   &Message ) );

    if ( Win32Err == ERROR_SUCCESS ) {

        Entry = ldap_first_entry( SdInfo.Ldap, Message );

        if ( Entry ) {

            //
            // Now, we'll have to get the values
            //
            PathList = ldap_get_values( SdInfo.Ldap, Entry, Attributes[ 0 ] );

            if ( PathList ) {

                SdInfo.SchemaPath = PathList[ 0 ];

            } else {

                Win32Err = LdapMapErrorToWin32( SdInfo.Ldap->ld_errno );
            }

            ldap_msgfree( Message );
        }
    }

    if( SdInfo.Ldap )
    {
        Win32Err = SetDefaultSdForObjectAndChildren( SdInfo.Ldap,
                                                     ObjectPath,
                                                     &SdInfo,
                                                     Propagate,
													 Protection);
    }

SetDefaultExit:

    //
    // Unbind from the DS
    //
    if ( SdInfo.Ldap ) {

        ldap_unbind( SdInfo.Ldap );
    }

    if ( PathList ) {

        ldap_value_free( PathList );
    }

    //
    // Clean up the Default SD Info list
    //
    LocalFree( SdInfo.DomainSid );


    while ( SdInfo.SdList ) {

        CleanupNode = SdInfo.SdList;
        LocalFree( CleanupNode->ObjectClass );
        LocalFree( CleanupNode->DefaultSd );
        SdInfo.SdList = SdInfo.SdList->Next;
        LocalFree( CleanupNode );
    }

    return( Win32Err );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\dsacls\utils.h ===
/*++

Copyright (c) 1998 - 1998  Microsoft Corporation

Module Name: utils.h
Abstract: This Module implements the utility routines for dsacls
Author: hitesh raigandhi (hiteshr )
Environment:User Mode
Revision History:

--*/
#ifndef _DSACLS_UTIL_H
#define _DSACLS_UTIL_H
#include "accctrl.h"

DWORD GetAccountNameFromSid( LPWSTR pszServerName,
                             PSID pSid, 
                             LPWSTR *pszName );
DWORD GetSidFromAccountName( LPWSTR pszServerName,
                             PSID *ppSid, 
                             LPWSTR  pszName );


DWORD GetGlobalNamingContexts( LPWSTR szObjectPath,
                               LPWSTR * pszSchemaNamingContext ,
                               LPWSTR * pszConfigurationNamingContext );


BOOL FormatStringGUID( LPWSTR lpszBuf, 
                       UINT nBufSize, 
                       const GUID* pGuid);

PSID GetAceSid(PACE_HEADER pAce);



BOOL GuidFromString( GUID* pGuid, 
                     LPCWSTR lpszGuidString);

DWORD GetServerName( IN LPWSTR pszObjectName, 
                     OUT LPWSTR *pszServerName );

DWORD LoadMessage( IN DWORD MessageId,
                   LPWSTR *ppszLoadString,
                   ... );
DWORD BuildLdapPath( LPWSTR * ppszLdapPath,
                     LPWSTR pszServerName,
                     LPWSTR pszPath );


void StringWithNSpace( UINT n, 
                       LPWSTR szSpace );


VOID DisplayString( UINT nIdent, 
                    LPWSTR pszDisplay );


VOID DisplayStringWithNewLine( UINT nIdent, 
                               LPWSTR pszDisplay );
VOID DisplayNewLine();


DWORD DisplayMessageEx( IN DWORD Indent,
                       IN DWORD MessageId,
                       ... );

VOID DisplayMessage( IN DWORD Indent,
                     IN DWORD MessageId,
                     ... );

VOID DisplayErrorMessage( IN DWORD Error );

DWORD ConvertStringAToStringW ( IN  PSTR            AString,
                                OUT PWSTR          *WString );

DWORD CopyUnicodeString( LPWSTR * strDst, 
                         LPWSTR strSrc );
DWORD GetProtection( PSECURITY_DESCRIPTOR pSD, 
                     SECURITY_INFORMATION * pSI );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\dsacls\utils.cpp ===
/*++

Copyright (c) 1998 - 1998  Microsoft Corporation

Module Name: utils.cpp
Abstract: This Module implements the utility routines for dsacls
Author: hitesh raigandhi (hiteshr )
Environment:User Mode
Revision History:

--*/


#include "stdafx.h"
#include "utils.h"
#include "dsace.h"
#include "dsacls.h"

/*******************************************************************
    NAME:       GetAccountNameFromSid

    SYNOPSIS:   Convert Sid to Account Name

    ENTRY:      pszServerName: Server name at which to look for
                pSid : Pointer to Sid
                
    EXIT:       ppszName : Gets pointer to Account Name

    RETURNS:    ERROR_SUCCESS if Successful
                ERROR_NOT_ENOUGH_MEMORY 


    NOTES:      If LookupAccountName resolve the sid, it is
                converted in to string and returned
                
    HISTORY:
        hiteshr    July-1999     Created

********************************************************************/
DWORD GetAccountNameFromSid( LPWSTR pszServerName,
                             PSID pSid, 
                             LPWSTR * ppszName )
{
LPWSTR pszAccountName = NULL;
LPWSTR pszDomainName = NULL;
DWORD cbAccountName = 0 ;
DWORD cbDomainName = 0;
SID_NAME_USE Use ;
DWORD dwErr = ERROR_SUCCESS;

   *ppszName = NULL;
    
   if(  LookupAccountSid( pszServerName,  // name of local or remote computer
                          pSid,              // security identifier
                          NULL,           // account name buffer
                          &cbAccountName,
                          NULL ,
                          &cbDomainName ,
                          &Use ) == FALSE )
   {
      dwErr = GetLastError();
      if( dwErr != ERROR_INSUFFICIENT_BUFFER )
      {
         //Convert Sid to String
         if( !ConvertSidToStringSid( pSid, ppszName ) )
            dwErr = GetLastError();
         else
            dwErr = ERROR_SUCCESS;

         goto FAILURE_RETURN;
      }
      else
         dwErr = ERROR_SUCCESS;
   }

   pszAccountName = (LPWSTR)LocalAlloc( LMEM_FIXED, ( cbAccountName +1 ) * sizeof( WCHAR ) );
   if( pszAccountName == NULL )
   {
      dwErr = ERROR_NOT_ENOUGH_MEMORY;
      goto FAILURE_RETURN;
   }

   pszDomainName = (LPWSTR)LocalAlloc( LMEM_FIXED, ( cbDomainName + 1 )* sizeof( WCHAR ) );
   if( pszDomainName == NULL )
   {
      dwErr = ERROR_NOT_ENOUGH_MEMORY;
      goto FAILURE_RETURN;
   }

   if(  LookupAccountSid( pszServerName,  // name of local or remote computer
                          pSid,              // security identifier
                          pszAccountName,           // account name buffer
                          &cbAccountName,
                          pszDomainName ,
                          &cbDomainName ,
                          &Use ) == FALSE )
   {
      dwErr = GetLastError();
      goto FAILURE_RETURN;
   }

   *ppszName = (LPWSTR)LocalAlloc( LMEM_FIXED, ( cbAccountName + cbDomainName + 2 ) * sizeof( WCHAR ) );
   if( *ppszName == NULL )
   {
      dwErr = ERROR_NOT_ENOUGH_MEMORY;
      goto FAILURE_RETURN;
   }

   *ppszName[0] = NULL;
   if( cbDomainName )
   {
      wcscpy( *ppszName, pszDomainName );
      wcscat( *ppszName, L"\\" );
   }
   wcscat( *ppszName, pszAccountName );
   

FAILURE_RETURN:
   if( pszDomainName )
      LocalFree( pszDomainName );
   if( pszAccountName )
      LocalFree( pszAccountName );
   return dwErr;
}
   
/*******************************************************************

    NAME:       GetSidFromAccountName

    SYNOPSIS:   Converts AccountName into SID
********************************************************************/
DWORD GetSidFromAccountName( LPWSTR pszServerName,
                             PSID *ppSid, 
                             LPWSTR  pszName )
{
LPWSTR pszDomainName = NULL;
DWORD cbSid = 0 ;
DWORD cbDomainName = 0;
SID_NAME_USE Use ;
DWORD dwErr = ERROR_SUCCESS;

    
   if(  LookupAccountName(pszServerName,  // name of local or remote computer
                          pszName,              // security identifier
                          NULL,           // account name buffer
                          &cbSid,
                          NULL ,
                          &cbDomainName ,
                          &Use ) == FALSE )
   {
      dwErr = GetLastError();
      if( dwErr != ERROR_INSUFFICIENT_BUFFER )
         goto FAILURE_RETURN;
      else
         dwErr = ERROR_SUCCESS;
   }

   *ppSid = (PSID)LocalAlloc( LMEM_FIXED, cbSid );
   CHECK_NULL( *ppSid, FAILURE_RETURN );


   pszDomainName = (LPWSTR)LocalAlloc( LMEM_FIXED, ( cbDomainName + 1 )* sizeof( WCHAR ) );
   CHECK_NULL( pszDomainName, FAILURE_RETURN );

   if(  LookupAccountName( pszServerName,  // name of local or remote computer
                          pszName,              // security identifier
                          *ppSid,           // account name buffer
                          &cbSid,
                          pszDomainName ,
                          &cbDomainName ,
                          &Use ) == FALSE )
   {
      dwErr = GetLastError();
      goto FAILURE_RETURN;
   }
  
   goto SUCCESS_RETURN;

FAILURE_RETURN:
   if( pszDomainName )
      LocalFree( pszDomainName );
   if( *ppSid )
      LocalFree( *ppSid );
SUCCESS_RETURN:
   return dwErr;
}
 

/*******************************************************************

    NAME:       GetAceSid

    SYNOPSIS:   Gets pointer to SID from an ACE

    ENTRY:      pAce - pointer to ACE

    EXIT:

    RETURNS:    Pointer to SID if successful, NULL otherwise

    NOTES:

    HISTORY:
        JeffreyS    08-Oct-1996     Created

********************************************************************/
PSID
GetAceSid(PACE_HEADER pAce)
{
    switch (pAce->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
        return (PSID)&((PKNOWN_ACE)pAce)->SidStart;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        return RtlObjectAceSid(pAce);
    }

    return NULL;
}


/*******************************************************************

    NAME:       GetGlobalNamingContexts

    SYNOPSIS:   Gets LDAP path for Schema and Extendend-Rights

    ENTRY:      pszServerName, Server to bind to for query

    EXIT:       pszSchemaNamingContext: Schema name in 
                "LDAP:\\cn=schema,cn=..." format
                pszConfigurationNamingContext: Extendend rights path
                in "LDAP:\\CN=Extended-Rights,CN=Configuration..formats

    RETURNS:    WIN32 Error Code

********************************************************************/
DWORD GetGlobalNamingContexts( LPWSTR pszServerName,
                               LPWSTR * pszSchemaNamingContext,
                               LPWSTR * pszConfigurationNamingContext )
{
HRESULT hr = S_OK;
DWORD dwErr = ERROR_SUCCESS;
LPWSTR szSNC = NULL;

ULONG uLen = 0;
IADs *spRootDSE = NULL;
LPWSTR pszRootDsePath = NULL;

   *pszSchemaNamingContext = NULL;
   *pszConfigurationNamingContext = NULL;
   
   if( pszServerName )
      uLen = wcslen(L"LDAP://")  +
             wcslen( pszServerName ) + 
             wcslen( L"/RootDSE") + 1;
             

   else
      uLen = wcslen(L"LDAP://RootDSE");


   pszRootDsePath = (LPWSTR)LocalAlloc( LMEM_FIXED, uLen * sizeof(WCHAR) );
   CHECK_NULL( pszRootDsePath,FAILURE_RETURN );
   wcscpy(pszRootDsePath, L"LDAP://");
   if( pszServerName )
   {
      wcscat( pszRootDsePath, pszServerName );
      wcscat( pszRootDsePath, L"/" );
   }
   wcscat( pszRootDsePath, L"RootDSE" );

   /*hr = ::ADsOpenObject( pszRootDsePath,
                        NULL,
                        NULL,
                        ADS_SECURE_AUTHENTICATION,
                        IID_IADs,
                        (void**)&spRootDSE
                      );

*/

   hr = ::ADsGetObject( pszRootDsePath,
                        IID_IADs,
                        (void**)&spRootDSE );

   CHECK_HR( hr, FAILURE_RETURN );

   VARIANT varSchemaNamingContext;
   hr = spRootDSE->Get(L"schemaNamingContext",
                        &varSchemaNamingContext);

   CHECK_HR( hr, FAILURE_RETURN );

   szSNC = (LPWSTR)varSchemaNamingContext.bstrVal;
   uLen = wcslen( szSNC ) + 8  ; //For "LDAP:// + 1
   *pszSchemaNamingContext = (LPWSTR) LocalAlloc( LMEM_FIXED, uLen* sizeof(WCHAR) );
   CHECK_NULL( *pszSchemaNamingContext, FAILURE_RETURN );

   wcscpy( *pszSchemaNamingContext, L"LDAP://");
   wcscat( *pszSchemaNamingContext, szSNC );

   hr = spRootDSE->Get(L"configurationNamingContext",
                           &varSchemaNamingContext);

   CHECK_HR( hr, FAILURE_RETURN );   
   
   szSNC = (LPWSTR)varSchemaNamingContext.bstrVal;
   uLen = wcslen( szSNC ) + 27 + 1  ;
   *pszConfigurationNamingContext = (LPWSTR) LocalAlloc( LMEM_FIXED, uLen* sizeof(WCHAR) );

   CHECK_NULL( *pszConfigurationNamingContext,FAILURE_RETURN );
   
   wcscpy( *pszConfigurationNamingContext, L"LDAP://CN=Extended-Rights,");
   wcscat( *pszConfigurationNamingContext, szSNC );

   goto SUCCESS_RETURN;

FAILURE_RETURN:
   if( *pszSchemaNamingContext )
      LocalFree( *pszSchemaNamingContext );
   if( *pszConfigurationNamingContext )
      LocalFree( *pszConfigurationNamingContext );

SUCCESS_RETURN:
   if( spRootDSE )
        spRootDSE->Release();
   if( pszRootDsePath )
      LocalFree( pszRootDsePath );
    
   return dwErr;
}





/*******************************************************************

    NAME:       FormatStringGUID

    SYNOPSIS:   Given a GUID struct, it returns a GUID in string format,
                without {}
    //Function copied from marcoc code 
********************************************************************/
BOOL FormatStringGUID(LPWSTR lpszBuf, UINT nBufSize, const GUID* pGuid)
{
  lpszBuf[0] = NULL;

  // if it is a NULL GUID*, just return an empty string
  if (pGuid == NULL)
  {
    return FALSE;
  }

/*
typedef struct _GUID {
    unsigned long  Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char  Data4[ 8 ];
}

  int _snwprintf( wchar_t *buffer, size_t count, const wchar_t *format [, argume
nt] ... );
*/
  return (_snwprintf(lpszBuf, nBufSize,
            L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
            pGuid->Data1, pGuid->Data2, pGuid->Data3,
            pGuid->Data4[0], pGuid->Data4[1],
            pGuid->Data4[2], pGuid->Data4[3], pGuid->Data4[4], pGuid->Data4[5],
pGuid->Data4[6], pGuid->Data4[7]) > 0);
}

/*
Returns A string with n spaces
*/
void StringWithNSpace( UINT n, LPWSTR szSpace )
{
   for( UINT i = 0; i < n ; ++ i )
      szSpace[i] = L' ';
   szSpace[n] = 0;
}

/*
Loads the string from Resource Table and 
Formats it 
*/
DWORD
LoadMessage( IN DWORD MessageId, LPWSTR *ppszLoadString,...)
{

    va_list ArgList;
    DWORD dwErr = ERROR_SUCCESS;
    
    va_start( ArgList, ppszLoadString );
   
    WCHAR szBuffer[1024];
    if( LoadString( g_hInstance, 
                    MessageId, 
                    szBuffer,
                    1023 ) == 0 )
   {
      dwErr = GetLastError();
      goto CLEAN_RETURN;
   }

   if( FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                      szBuffer,
                      MessageId,
                      0,
                      ( PWSTR )ppszLoadString,
                      0,
                      &ArgList ) == 0 )
   {
      dwErr = GetLastError();
      goto CLEAN_RETURN;
   }

CLEAN_RETURN:
   va_end( ArgList );
   return dwErr;

}

/*******************************************************************

    NAME:       DisplayString

    SYNOPSIS:   Displays a string after inserting nIdent spaces
********************************************************************/
VOID DisplayString( UINT nIdent, LPWSTR pszDisplay )
{
   for ( UINT i = 0; i < nIdent; i++ )
      wprintf( L" " );

   wprintf(L"%s",pszDisplay);
}

VOID DisplayStringWithNewLine( UINT nIdent, LPWSTR pszDisplay )
{
   DisplayString( nIdent, pszDisplay );
   wprintf(L"\n");
}
VOID DisplayNewLine()
{
   wprintf(L"\n");
}

/*******************************************************************

    NAME:       DisplayMessageEx

    SYNOPSIS:   Loads Message from Resource and Formats its 
    IN          Indent - Number of tabs to indent
                MessageId - Id of the message to load
                ... - Optional list of parameters

    RETURNS:    NONE

********************************************************************/
DWORD
DisplayMessageEx( DWORD nIndent, IN DWORD MessageId,...)
{

   va_list ArgList;
   LPWSTR pszLoadString = NULL;

   va_start( ArgList, MessageId );
   
   WCHAR szBuffer[1024];
   if( LoadString( g_hInstance, 
                   MessageId, 
                   szBuffer,
                   1023 ) == 0 )
   {
      va_end( ArgList );
      return GetLastError();
   }


    if( FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            szBuffer,
                            MessageId,
                            0,
                            ( PWSTR )&pszLoadString,
                            0,
                            &ArgList ) == 0 )
   {
      va_end( ArgList );
      return GetLastError();
   }
   
   DisplayStringWithNewLine( nIndent, pszLoadString );
   LocalFree( pszLoadString );
   return ERROR_SUCCESS;
}


BOOL GuidFromString(GUID* pGuid, LPCWSTR lpszGuidString)
{
  ZeroMemory(pGuid, sizeof(GUID));
  if (lpszGuidString == NULL)
  {
    return FALSE;
  }

  int nLen = lstrlen(lpszGuidString);
  // the string length should be 36
  if (nLen != 36)
    return FALSE;

  // add the braces to call the Win32 API
  LPWSTR lpszWithBraces = (LPWSTR)LocalAlloc(LMEM_FIXED,((nLen+1+2)*sizeof(WCHAR)) ); // NULL plus {}
  
 if(!lpszWithBraces)
    return FALSE;
  wsprintf(lpszWithBraces, L"{%s}", lpszGuidString);

  return SUCCEEDED(::CLSIDFromString(lpszWithBraces, pGuid));
}

/*******************************************************************

    NAME:       GetServerName

    SYNOPSIS:   Get the name of the server. If Obeject Path is in form
                \\ADSERVER\CN=John..., then it gets the server name
                from Object Path and changes Object Path to CN=John...
********************************************************************/

DWORD GetServerName( IN LPWSTR ObjectPath, 
                     OUT LPWSTR * ppszServerName )
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR Separator = NULL;
    PDOMAIN_CONTROLLER_INFO DcInfo = NULL;
    PDOMAIN_CONTROLLER_INFO DcInfo1 = NULL;
    PWSTR Path = NULL;
    HANDLE DsHandle = NULL;
    PDS_NAME_RESULT NameRes = NULL;
    BOOLEAN NamedServer = FALSE;
    NTSTATUS Status;
    LPWSTR ServerName = NULL;
    //
    // Get a server name
    //
    if ( wcslen( ObjectPath ) > 2 && *ObjectPath == L'\\' && *( ObjectPath + 1 ) == L'\\' ) {

        Separator = wcschr( ObjectPath + 2, L'\\' );

        if ( Separator ) {

            *Separator = L'\0';
            Path = Separator + 1;
        }
        else
            return ERROR_INVALID_PARAMETER;

        ServerName = ObjectPath + 2;
        *ppszServerName = (LPWSTR)LocalAlloc(LMEM_FIXED, 
                                     sizeof(WCHAR) * (wcslen(ServerName) + 1) );
        if( *ppszServerName == NULL )
        {
            if( Separator )
               *Separator = L'\\';
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        wcscpy( *ppszServerName, ServerName );
        //Remove server name from object path
        memmove( ObjectPath, Path, ( wcslen(Path) + 1) * sizeof(WCHAR) );
        return ERROR_SUCCESS;

    } else {

        Path = ObjectPath;

        Win32Err = DsGetDcName( NULL,
                                NULL,
                                NULL,
                                NULL,
                                DS_DIRECTORY_SERVICE_REQUIRED,
                                &DcInfo );
        if ( Win32Err == ERROR_SUCCESS ) {

            ServerName = DcInfo[ 0 ].DomainControllerName + 2;
        }

    }

    //
    // Do the bind and crack
    //
    if ( Win32Err == ERROR_SUCCESS	) {

		  Win32Err = DsBind( ServerName,
									NULL,
									&DsHandle );

		  if ( Win32Err == ERROR_SUCCESS ) {

				Win32Err = DsCrackNames( DsHandle,
												 DS_NAME_NO_FLAGS,
												 DS_FQDN_1779_NAME,
												 DS_FQDN_1779_NAME,
												 1,
												 &Path,
												 &NameRes );

				if ( Win32Err == ERROR_SUCCESS ) {

					 if ( NameRes->cItems != 0   &&
							NameRes->rItems[ 0 ].status == DS_NAME_ERROR_DOMAIN_ONLY ) {

	
						  Win32Err = DsGetDcNameW( NULL,
															NameRes->rItems[ 0 ].pDomain,
															NULL,
															NULL,
															DS_DIRECTORY_SERVICE_REQUIRED,
															&DcInfo1 );

						  if ( Win32Err == ERROR_SUCCESS ) {


								ServerName = DcInfo1->DomainControllerName + 2;
							}

                            if( Win32Err == ERROR_INVALID_DOMAINNAME ||
                                Win32Err == ERROR_NO_SUCH_DOMAIN  )
                                ServerName = NULL;
						}
					}
				}
			}
         
         
         if( ServerName )      
         {
            *ppszServerName = (LPWSTR)LocalAlloc(LMEM_FIXED, 
                                           sizeof(WCHAR) * (wcslen(ServerName) + 1) );
            if( *ppszServerName == NULL )
               return ERROR_NOT_ENOUGH_MEMORY;
            wcscpy( *ppszServerName, ServerName );
            Win32Err = ERROR_SUCCESS;
         }


        if( DcInfo )
 		      NetApiBufferFree( DcInfo );
        if( DcInfo1 )
 		      NetApiBufferFree( DcInfo1 );
        if( DsHandle )
            DsUnBindW( &DsHandle );
  	     if ( NameRes )
            DsFreeNameResult( NameRes );

         return Win32Err;
}

/*******************************************************************

    NAME:       DisplayMessage

    SYNOPSIS:   Loads Message from Message Table and Formats its 
    IN          Indent - Number of tabs to indent
                MessageId - Id of the message to load
                ... - Optional list of parameters

    RETURNS:    NONE

********************************************************************/
VOID
DisplayMessage(
    IN DWORD Indent,
    IN DWORD MessageId,
    ...
    )
/*++

Routine Description:

    Loads the resource out of the executable and displays it.

Arguments:

    Indent - Number of tabs to indent
    MessageId - Id of the message to load
    ... - Optional list of parameters

Return Value:

    VOID

--*/
{
    PWSTR MessageDisplayString;
    va_list ArgList;
    ULONG Length, i;

    va_start( ArgList, MessageId );

    Length = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            NULL,
                            MessageId,
                            0,
                            ( PWSTR )&MessageDisplayString,
                            0,
                            &ArgList );

    if ( Length != 0 ) {

        for ( i = 0; i < Indent; i++ ) {

            printf( "\t" );
        }
        printf( "%ws", MessageDisplayString );
        LocalFree( MessageDisplayString );

    }

    va_end( ArgList );
}


/*******************************************************************

    NAME:       DisplayErrorMessage

    SYNOPSIS:   Displays Error Message corresponding to Error
    RETURNS:    NONE

********************************************************************/
VOID
DisplayErrorMessage(
    IN DWORD Error
    )
{
    ULONG Size = 0;
    PWSTR DisplayString;
    ULONG Options = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM;


    Size = FormatMessage( Options,
                          NULL,
                          Error,
                          MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                          ( LPTSTR )&DisplayString,
                          0,
                          NULL );

    if ( Size != 0 ) {

        printf( "%ws\n", DisplayString );
        LocalFree( DisplayString );
    }

}


/*******************************************************************

    NAME:       ConvertStringAToStringW

    SYNOPSIS:   Converts MBYTE stirng to UNICODE
    RETURNS:    ERROR_SUCCESS if success
                ERROR_NOT_ENOUGH_MEMORY

********************************************************************/
DWORD
ConvertStringAToStringW (
    IN  PSTR            AString,
    OUT PWSTR          *WString
    )
{
    DWORD Win32Err = ERROR_SUCCESS, Length;
    if ( AString == NULL ) {

        *WString = NULL;

    } else {

        Length = strlen( AString );

        *WString = ( PWSTR )LocalAlloc( LMEM_FIXED,
                                        ( mbstowcs( NULL, AString, Length + 1 ) + 1 ) *
                                                                                sizeof( WCHAR ) );
        if(*WString != NULL ) {

            mbstowcs( *WString, AString, Length + 1);

        } else {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return( Win32Err );
}

/*******************************************************************

    NAME:       CopyUnicodeString

    SYNOPSIS:   Copy Unicode string from Source to Destination
    RETURNS:    ERROR_SUCCESS if success
                ERROR_NOT_ENOUGH_MEMORY
********************************************************************/
DWORD CopyUnicodeString( LPWSTR * strDst, LPWSTR strSrc )
{
            *strDst = (LPWSTR)LocalAlloc( LMEM_FIXED , ( wcslen(strSrc) + 1 ) * sizeof(WCHAR ) );
            if ( !*strDst ) {

                    return ERROR_NOT_ENOUGH_MEMORY;                    
            }            
            
            wcscpy( *strDst, strSrc );
            return ERROR_SUCCESS;
}

/*******************************************************************

    NAME:       GetProtection

    SYNOPSIS:   Sets PROTECTED_DACL_SECURITY_INFORMATION in pSI,
                if SE_DACL_PROTECTED is set pSD
    RETURNS:    ERROR_SUCCESS if success
                
********************************************************************/

DWORD GetProtection( PSECURITY_DESCRIPTOR pSD, SECURITY_INFORMATION * pSI )
{

		SECURITY_DESCRIPTOR_CONTROL wSDControl = 0;
		DWORD dwRevision;
		//
		;
		if( !GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision) )
		{
			return GetLastError();
		}
		if ( wSDControl & SE_DACL_PROTECTED )
				*pSI |= PROTECTED_DACL_SECURITY_INFORMATION;
		
      return ERROR_SUCCESS;
}
/*******************************************************************

    NAME:       BuildLdapPath

    SYNOPSIS:   Builds a LDAP path using servername and path
    RETURNS:    ERROR_SUCCESS if success
                
********************************************************************/

DWORD BuildLdapPath( LPWSTR * ppszLdapPath,
                     LPWSTR pszServerName,
                     LPWSTR pszPath )
{

ULONG uLen = 0;

   if( pszServerName )
      uLen = wcslen( pszServerName ) + wcslen( pszPath );
   else
      uLen = wcslen( pszPath );

   uLen += 9;    //LDAP://ServerName/path

   *ppszLdapPath = (LPWSTR)LocalAlloc( LMEM_FIXED, uLen * sizeof(WCHAR) );
   if( NULL == *ppszLdapPath )
      return ERROR_NOT_ENOUGH_MEMORY;


   wcscpy( * ppszLdapPath, L"LDAP://" );
   if( pszServerName )
   {
   wcscat( * ppszLdapPath, pszServerName );
   wcscat( * ppszLdapPath, L"/");
   }

   wcscat(* ppszLdapPath, pszPath );

return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\dssetdc\dssetdc.c ===
/*--

Copyright (c) 1997-1997  Microsoft Corporation

Module Name:

    dssetdc.c

Abstract:

    Command line tool for promoting/demoting servers into and out of the Ds

Author:

    1-Apr-1997   Mac McLain (macm)   Created

Environment:

    User mode only.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntlsa.h>
#include <stdio.h>
#include <stdlib.h>
#include <dsrole.h>
#include <dsrolep.h>

#define TAG_DNS         "dns"
#define TAG_FLAT        "flat"
#define TAG_SITE        "site"
#define TAG_DB          "db"
#define TAG_LOG         "log"
#define TAG_SYSVOL      "sysvol"
#define TAG_PARENT      "parent"
#define TAG_REPLICA     "replica"
#define TAG_USER        "user"
#define TAG_PASSWORD    "password"
#define TAG_SERVER      "server"
#define TAG_OPTIONS     "options"
#define TAG_LEVEL       "level"
#define TAG_ROLE        "role"
#define TAG_LASTDC      "lastdc"
#define TAG_ADMINPWD    "adminpwd"
#define TAG_WAIT        "wait"
#define TAG_FIXDC       "fixdc"

//
// Macro to help command line parsing...
//
#define PARSE_CMD_VALUE_AND_CONTINUE( tag, value, buff, ptr )                   \
if ( !_strnicmp( value, tag, sizeof( tag ) - 1 ) ) {                            \
    value += sizeof(tag) - 1;                                                   \
    if ( *value == ':' ) {                                                      \
        value++;                                                                \
        mbstowcs(buff, value, strlen(value) + 1);                               \
        ptr = buff;                                                             \
        continue;                                                               \
    }                                                                           \
}

VOID
Usage (
    PWSTR DefaultDns,
    PWSTR DefaultFlat,
    PWSTR DefaultSite,
    PWSTR DefaultPath
    )
/*++

Routine Description:

    Displays the expected usage

Arguments:

Return Value:

    VOID

--*/
{
    printf("dssetdc -promote <parameters>\n");
    printf("        -info <parameters>\n");
    printf("        -demote <parameters>\n");
    printf("        -save\n");
    printf("        -abort <parameters>\n");
    printf("        -upgrade <parameters>\n");
    printf("        -fixdc <parameters>\n");
    printf("     where:\n");
    printf("        promote parameters are:\n");
    printf("            -%s:dns domain name of the new domain/domain to install as replica "
           "of.  Defaults to %ws\n", TAG_DNS, DefaultDns);
    printf("            -%s:NetBIOS domain name.  Defaults to %ws\n", TAG_FLAT, DefaultFlat);
    printf("            -%s:site name.  Defaults to %ws\n", TAG_SITE, DefaultSite);
    printf("            -%s:db path  Defaults to %ws.\n", TAG_DB, DefaultPath);
    printf("            -%s:log path  Defaults to %ws.\n", TAG_LOG, DefaultPath);
    printf("            -%s:sysvol path.  Defaults to %ws. [Must be NT5 NTFS]\n", TAG_SYSVOL, DefaultPath);
    printf("            [-%s:parent dns domain name if this is a child domain]\n", TAG_PARENT);
    printf("            [-%s:replica partner]\n", TAG_REPLICA);
    printf("            [-%s:account]\n", TAG_USER);
    printf("            [-%s:password]\n", TAG_PASSWORD);
    printf("            [-%s:options]\n", TAG_OPTIONS);
    printf("            [-%s:if 1, block until the call has completed\n",TAG_WAIT);
    printf("        info parameters are:\n");
    printf("            -%s:Remote server to obtain the information for\n", TAG_SERVER);
    printf("            -%s:info level\n", TAG_LEVEL);
    printf("                Valid info levels are:\n");
    printf("                    1   -   PrimaryDomainInformation\n");
    printf("                    2   -   Upgrade State information\n");
    printf("        demote parameters are:\n");
    printf("            -%s:server role\n", TAG_ROLE);
    printf("                Valid server roles are:\n");
    printf("                    2   -   Member server\n");
    printf("                    3   -   Standalone server\n");
    printf("            [-%s:account]\n", TAG_USER);
    printf("            [-%s:password]\n", TAG_PASSWORD);
    printf("            [-%s:options]\n", TAG_OPTIONS);
    printf("            [-%s:Whether this is the last dc in the domain]\n", TAG_LASTDC);
    printf("                Valid options are:\n");
    printf("                    0   -   Not the last dc in the domain\n");
    printf("                    1   -   Last DC in the domain\n");
    printf("            [-%s:if 1, block until the call has completed\n",TAG_WAIT);
    printf("        -abort parameters are:\n");
    printf("            -%s:new administrator password.  Defaults to NULL\n", TAG_ADMINPWD );
    printf("        -upgrade parameters are:\n");
    printf("            -%s:dns domain name of the new domain.  Defaults to %ws\n", TAG_DNS, DefaultDns);
    printf("            -%s:site name.  Defaults to %ws\n", TAG_SITE, DefaultSite);
    printf("            -%s:db path  Defaults to %ws.\n", TAG_DB, DefaultPath);
    printf("            -%s:log path  Defaults to %ws.\n", TAG_LOG, DefaultPath);
    printf("            -%s:sysvol path.  Defaults to %ws. [Must be NT5 NTFS]\n", TAG_SYSVOL, DefaultPath);
    printf("            [-%s:parent dns domain]\n", TAG_PARENT);
    printf("            [-%s:account]\n", TAG_USER);
    printf("            [-%s:password]\n", TAG_PASSWORD);
    printf("            [-%s:options]\n", TAG_OPTIONS);
    printf("        -fixdc parameters are:\n");
    printf("            [-%s:server]Remote server to obtain the information for\n", TAG_SERVER);
    printf("            [-%s:server]Remote server to sync with\n", TAG_REPLICA);
    printf("            [-%s:account]\n", TAG_USER);
    printf("            [-%s:password]\n", TAG_PASSWORD);
    printf("            [-%s:options]\n", TAG_OPTIONS);
    printf("                Valid options (in HEX) are:\n");
    printf("                    0x00000001   -   Create the machine account if necessary\n");
    printf("                    0x00000002   -   Sync the machine password\n");
    printf("                    0x00000004   -   Change the account time\n");
    printf("                    0x00000008   -   Re-init the time service\n");
    printf("                    0x00000010   -   Reconfigure the default services\n");
    printf("                    0x00000020   -   Force a DS replication cycle\n");
    printf("                    0x00000040   -   Fixup NTFRS\n");
}


DWORD
GetAndDumpInfo(
    IN PWSTR Server,
    IN ULONG Level
    )
{
    DWORD Win32Error = ERROR_SUCCESS;
    PDSROLE_UPGRADE_STATUS_INFO UpgradeInfo = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC DomainInfo = NULL;
    PBYTE Buffer = NULL;
    PWSTR Roles[ ] = {
        L"DsRole_RoleStandaloneWorkstation",
        L"DsRole_RoleMemberWorkstation",
        L"DsRole_RoleStandaloneServer",
        L"DsRole_RoleMemberServer",
        L"DsRole_RoleBackupDomainController",
        L"DsRole_RolePrimaryDomainController"
        };
    PWSTR ServerRoles[ ] = {
        L"Unknown",
        L"Primary",
        L"Backup"
        };


    Win32Error = DsRoleGetPrimaryDomainInformation( Server,
                                                    Level,
                                                    ( PBYTE * )&Buffer );
    if ( Win32Error == ERROR_SUCCESS ) {

        switch ( Level ) {
        case DsRolePrimaryDomainInfoBasic:

            DomainInfo = ( PDSROLE_PRIMARY_DOMAIN_INFO_BASIC )Buffer;
            printf( "Machine Role: %lu ( %ws )\n", DomainInfo->MachineRole,
                     Roles[ DomainInfo->MachineRole ] );
            printf( "Flags: 0x%lx\n", DomainInfo->Flags );
            printf( "Flat name: %ws\n", DomainInfo->DomainNameFlat );
            printf( "Dns Domain name: %ws\n", DomainInfo->DomainNameDns );
            printf( "Dns Forest name: %ws\n", DomainInfo->DomainForestName );
            break;

        case DsRoleUpgradeStatus:
            UpgradeInfo = ( PDSROLE_UPGRADE_STATUS_INFO )Buffer;

            printf( "Upgrade: %s\n",
                     ( UpgradeInfo->OperationState & DSROLE_UPGRADE_IN_PROGRESS ) ?
                                                                            "TRUE" : "FALSE" );
            printf( "Previous server role: %ws\n", ServerRoles[ UpgradeInfo->PreviousServerState ] );

        }

        DsRoleFreeMemory( DomainInfo );

    } else {

        printf( "DsRoleGetPrimaryDomainInformation failed with %lu\n", Win32Error );
    }


    return( Win32Error );
}




DWORD
BuildDefaults(
    IN PWSTR Dns,
    IN PWSTR Flat,
    IN PWSTR Site,
    IN PWSTR Path
    )
{
    DWORD Win32Error = ERROR_SUCCESS;
    PWSTR Scratch;
    ULONG Options;

    //
    // First, the easy ones
    //
    wcscpy( Site, L"First Site" );

    ExpandEnvironmentStrings( L"%systemroot%\\ntds", Path, MAX_PATH );

    return( Win32Error );
}


DWORD
CopyDsDitFiles(
    IN LPWSTR DsPath
    )
{
    DWORD Win32Error = ERROR_SUCCESS;
    WCHAR Source[MAX_PATH + 1];
    WCHAR Dest[MAX_PATH + 1];
    ULONG SrcLen, DestLen = 0;
    PWSTR DsDitFiles[] = {
        L"ntds.dit",
        L"schema.ini"
        };
    PWSTR CleanupFiles[] = {
        L"edb.chk",
        L"edb.log",
        L"hierarch.dat",
        L"ntds.dit",
        L"res1.log",
        L"res2.log",
        L"schema.ini",
        L"edb00001.log",
        L"edb00002.log",
        L"edb00003.log"
        L"edb00004.log"
        L"edb00005.log"
        L"edb00006.log"
        };
    PWSTR Current;
    ULONG i;



    if( ExpandEnvironmentStrings( L"%WINDIR%\\system32\\", Source, MAX_PATH ) == FALSE ) {

        Win32Error = GetLastError();

    } else {

        SrcLen = wcslen( Source );
        wcscpy( Dest, DsPath );

        if ( *(Dest + (wcslen( DsPath ) - 1 )) != L'\\' ) {

            wcscat( Dest, L"\\" );
        }

        DestLen = wcslen( Dest );

    }


    //
    // See if the source directory exists...
    //
    if ( Win32Error == ERROR_SUCCESS && GetFileAttributes( DsPath ) == 0x10 ) {

        for ( i = 0; i < sizeof( CleanupFiles) / sizeof( PWSTR ); i++ ) {

            wcscpy( Dest + DestLen, CleanupFiles[i] );

            if ( DeleteFile( Dest ) == FALSE ) {

                Win32Error = GetLastError();

                if ( Win32Error == ERROR_FILE_NOT_FOUND ) {

                    Win32Error = ERROR_SUCCESS;

                } else {

                    printf("Failed to remove %ws: %lu\n", Dest, Win32Error );
                    break;
                }
            }
        }

    }

    //
    // Then, create the destination directory
    //
    if ( Win32Error == ERROR_SUCCESS ) {

        Current = wcschr( DsPath + 4, L'\\' );

        while ( Win32Error == ERROR_SUCCESS ) {

            if ( Current != NULL ) {

                *Current = UNICODE_NULL;

            }

            if ( CreateDirectory( DsPath, NULL ) == FALSE ) {

                Win32Error = GetLastError();

                if ( Win32Error == ERROR_ALREADY_EXISTS) {

                    Win32Error = ERROR_SUCCESS;
                }
            }

            if ( Current != NULL ) {

                *Current = L'\\';

                Current = wcschr( Current + 1, L'\\' );

            } else {

                break;

            }

        }
    }

    return( Win32Error );
}


DWORD
Promote( LPWSTR Dns, LPWSTR Flat, LPWSTR Site, LPWSTR Db, LPWSTR Log,
         LPWSTR SysVol, LPWSTR Parent, LPWSTR Replica, LPWSTR User,
         LPWSTR Password, LPWSTR Server, ULONG Options, BOOL Block
         )
{
    DWORD Win32Error = ERROR_SUCCESS;
    DSROLE_SERVEROP_HANDLE Handle;
    PDSROLE_SERVEROP_STATUS Status;
    PDSROLE_SERVEROP_RESULTS Results;

    if ( !Server ) {
        Win32Error = CopyDsDitFiles( Db );

        if ( Win32Error != ERROR_SUCCESS ) {

            return( Win32Error );
        }
    }

    //
    // Now, do the install
    //
    if ( Replica != NULL ) {

        Win32Error = DsRoleDcAsReplica( Server,
                                        Dns,
                                        Replica,
                                        Site,
                                        Db,
                                        Log,
                                        NULL,
                                        SysVol,
                                        NULL,
                                        User,
                                        Password,
                                        NULL,
                                        Options,
                                        &Handle );

    } else {

        Win32Error = DsRoleDcAsDc( Server,
                                   Dns,
                                   Flat,
                                   NULL,
                                   Site,
                                   Db,
                                   Log,
                                   SysVol,
                                   Parent,
                                   NULL,
                                   User,
                                   Password,
                                   NULL,
                                   Options,
                                   &Handle );
    }

    if ( Win32Error == ERROR_SUCCESS ) {

        if ( !Block ) {
            do {

                Sleep( 6000 );

                Win32Error = DsRoleGetDcOperationProgress( NULL,
                                                           Handle,
                                                           &Status );

                if ( Win32Error == ERROR_SUCCESS || Win32Error == ERROR_IO_PENDING ) {

                    printf("%ws\n", Status->CurrentOperationDisplayString );
                    DsRoleFreeMemory( Status );
                }


            } while( Win32Error == ERROR_IO_PENDING);

            if ( Win32Error != ERROR_SUCCESS ) {

                printf("Failed determining the operation progress: %lu\n", Win32Error );
            }

        } else {

            printf( "Block on DsRoleGetDcOperationResutls call\n" );
        }

    } else {

        printf( "Failed to install as a Dc: %lu\n", Win32Error );
    }

    if ( Win32Error == ERROR_SUCCESS ) {

        Win32Error = DsRoleGetDcOperationResults( NULL,
                                                  Handle,
                                                  &Results );

        if ( Win32Error == ERROR_SUCCESS ) {

            Win32Error = Results->OperationStatus;;
            printf( "OperationResults->OperationStatusDisplayString: %ws\n",
                    Results->OperationStatusDisplayString );

            printf( "OperationResults->ServerInstalledSite: %ws\n",
                    Results->ServerInstalledSite );

            DsRoleFreeMemory( Results );

        } else {

            printf( "Failed to determine the operation results: %lu\n", Win32Error );
        }
    }

    return( Win32Error );
}

DWORD
Demote( LPWSTR User, LPWSTR Password, ULONG Role, ULONG Options, BOOL LastDc )
{
    DWORD Win32Error = ERROR_SUCCESS;
    DSROLE_SERVEROP_HANDLE Handle;
    PDSROLE_SERVEROP_STATUS Status;
    PDSROLE_SERVEROP_RESULTS Results;

    Win32Error = DsRoleDemoteDc( NULL, NULL, Role, User, Password, Options,
                                 LastDc, NULL, &Handle );

    if ( Win32Error == ERROR_SUCCESS ) {

        do {

            Sleep( 6000 );

            Win32Error = DsRoleGetDcOperationProgress( NULL,
                                                       Handle,
                                                       &Status );

            if ( Win32Error == ERROR_SUCCESS || Win32Error == ERROR_IO_PENDING ) {

                printf("%ws\n", Status->CurrentOperationDisplayString );
                DsRoleFreeMemory( Status );
            }


        } while( Win32Error == ERROR_IO_PENDING);

        if ( Win32Error != ERROR_SUCCESS ) {

            printf("Failed determining the operation progress: %lu\n", Win32Error );
        }

    } else {

        printf( "Failed to demote a Dc: %lu\n", Win32Error );
    }

    if ( Win32Error == ERROR_SUCCESS ) {

        Win32Error = DsRoleGetDcOperationResults( NULL,
                                                  Handle,
                                                  &Results );

        if ( Win32Error == ERROR_SUCCESS ) {

            Win32Error = Results->OperationStatus;;
            printf( "OperationResults->OperationStatusDisplayString: %ws\n",
                    Results->OperationStatusDisplayString );

            printf( "OperationResults->ServerInstalledSite: %ws\n",
                    Results->ServerInstalledSite );

            DsRoleFreeMemory( Results );

        } else {

            printf( "Failed to determine the operation results: %lu\n", Win32Error );
        }
    }

    return( Win32Error );
}

DWORD
Save( VOID )
{
    DWORD Win32Error = ERROR_SUCCESS;

    Win32Error = DsRoleServerSaveStateForUpgrade( NULL );

    if ( Win32Error != ERROR_SUCCESS ) {

        printf("DsRoleServerSaveStateForUpgrade failed with %lu\n", Win32Error );
    }

    return( Win32Error );
}

DWORD
Abort(
    PWSTR AdminPwd
    )
{
    DWORD Win32Error = ERROR_SUCCESS;

    Win32Error = DsRoleAbortDownlevelServerUpgrade( AdminPwd, NULL, NULL, 0 );

    if ( Win32Error != ERROR_SUCCESS ) {

        printf("DsRoleAbortDownlevelServerUpgrade failed with %lu\n", Win32Error );
    }


    return( Win32Error );
}

DWORD
Upgrade( LPWSTR Dns, LPWSTR Site, LPWSTR Db, LPWSTR Log, LPWSTR SysVol,
         LPWSTR Parent, LPWSTR User, LPWSTR Password, ULONG Options )
{
    DWORD Win32Error = ERROR_SUCCESS;
    DSROLE_SERVEROP_HANDLE Handle;
    PDSROLE_SERVEROP_STATUS Status;
    PDSROLE_SERVEROP_RESULTS Results;

    Win32Error = DsRoleUpgradeDownlevelServer( ( LPCWSTR )Dns, ( LPCWSTR )Site, ( LPCWSTR )Db,
                                               ( LPCWSTR )Log, ( LPCWSTR )SysVol,
                                               ( LPCWSTR )Parent, NULL, ( LPCWSTR )User,
                                               ( LPCWSTR )Password, NULL, Options, &Handle );

    if ( Win32Error == ERROR_SUCCESS ) {

        do {

            Sleep( 6000 );

            Win32Error = DsRoleGetDcOperationProgress( NULL,
                                                       Handle,
                                                       &Status );

            if ( Win32Error == ERROR_SUCCESS || Win32Error == ERROR_IO_PENDING ) {

                printf("%ws\n", Status->CurrentOperationDisplayString );
                DsRoleFreeMemory( Status );
            }


        } while( Win32Error == ERROR_IO_PENDING);

        if ( Win32Error != ERROR_SUCCESS ) {

            printf("Failed determining the operation progress: %lu\n", Win32Error );
        }

    } else {

        printf( "Failed to install as a Dc: %lu\n", Win32Error );
    }

    if ( Win32Error == ERROR_SUCCESS ) {

        Win32Error = DsRoleGetDcOperationResults( NULL,
                                                  Handle,
                                                  &Results );

        if ( Win32Error == ERROR_SUCCESS ) {

            Win32Error = Results->OperationStatus;;
            printf( "OperationResults->OperationStatusDisplayString: %ws\n",
                    Results->OperationStatusDisplayString );

            printf( "OperationResults->ServerInstalledSite: %ws\n",
                    Results->ServerInstalledSite );

            DsRoleFreeMemory( Results );

        } else {

            printf( "Failed to determine the operation results: %lu\n", Win32Error );
        }
    }


    return( Win32Error );
}

INT
__cdecl main (
    int argc,
    char *argv[])
/*++

Routine Description:

    The main the for this executable

Arguments:

    argc - Count of arguments
    argv - List of arguments

Return Value:

    VOID

--*/
{
    DWORD Win32Error = ERROR_SUCCESS, OpErr;
    WCHAR DnsBuff[MAX_PATH + 1], SiteBuff[MAX_PATH + 1];
    WCHAR DbBuff[MAX_PATH + 1], LogBuff[MAX_PATH + 1], ParentBuff[MAX_PATH + 1];
    WCHAR ReplicaBuff[MAX_PATH + 1], UserBuff[MAX_PATH + 1], PasswordBuff[MAX_PATH + 1];
    WCHAR ScratchBuff[MAX_PATH], ServerBuff[MAX_PATH], FlatBuff[MAX_PATH + 1];
    WCHAR SysVolBuff[MAX_PATH + 1], RoleBuff[ 10 ], LastDCBuff[ 10 ], WaitBuff[ 10 ];
    WCHAR AdminPwdBuff[ MAX_PATH + 1 ];
    ULONG Options = 0, Level = 0, Role = 0, FailedOperation, CompletedOperations;
    PWSTR Parent = NULL, Replica = NULL, User = NULL, Password = NULL, Dns = NULL, Flat = NULL;
    PWSTR Site = NULL, Db = NULL, Log = NULL, Scratch = NULL, Server = NULL;
    PWSTR SysVol = NULL, RoleScratch = NULL, LastDCScratch = NULL, AdminPwd = NULL, Wait = NULL;
    INT i = 1;
    BOOL LastDC = FALSE, BuildDefaultsFailed = FALSE, Block = FALSE;
    PSTR Current;

    Win32Error = BuildDefaults( DnsBuff, FlatBuff, SiteBuff, DbBuff );

    if ( Win32Error == ERROR_SUCCESS ) {

        Dns = DnsBuff;
        Site = SiteBuff;
        Db = DbBuff;
        Log = DbBuff;
        Flat = FlatBuff;

    } else {

        BuildDefaultsFailed = TRUE;

    }


    if (argc > 1 && (_stricmp( argv[1], "-?") == 0 || _stricmp( argv[1], "/?") == 0 ) ) {

        if ( BuildDefaultsFailed ) {

            printf( "Failed to get the defaults: %lu\n", Win32Error );
        }
        Usage( Dns, Flat, Site, Db );
        goto Done;


    } else if (argc > 1 && ( _stricmp( argv[ 1 ], "-info" ) == 0 || _stricmp( argv[ 1 ], "/info" ) == 0 ) ) {

        for (i = 2; i < argc; i++ ) {

            Current = argv[i];

            if ( !( *Current == '-' || *Current == '/' ) ) {

                Win32Error = ERROR_INVALID_PARAMETER;
                break;
            }

            Current++;

            PARSE_CMD_VALUE_AND_CONTINUE( TAG_SERVER, Current, ServerBuff, Server );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_LEVEL, Current, ScratchBuff, Scratch );
        }

        if ( Win32Error == ERROR_SUCCESS && Scratch ) {

            Level = wcstol( Scratch, &Scratch, 10 );
        }

        Win32Error = GetAndDumpInfo( Server, Level );
        goto Done;

    } else if (argc > 1 && ( _stricmp( argv[ 1 ], "-promote" ) == 0 || _stricmp( argv[ 1 ], "/promote" ) == 0) ) {

        if ( BuildDefaultsFailed ) {

            printf( "Failed to get the defaults: %lu\n", Win32Error );
            goto Done;

        }

        for (i = 2; i < argc; i++ ) {

            Current = argv[i];

            if ( !( *Current == '-' || *Current == '/' ) ) {

                Win32Error = ERROR_INVALID_PARAMETER;
                break;
            }

            Current++;

            PARSE_CMD_VALUE_AND_CONTINUE( TAG_DNS, Current, DnsBuff, Dns );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_FLAT, Current, FlatBuff, Flat );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_SITE, Current, SiteBuff, Site );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_DB, Current, DbBuff, Db );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_LOG, Current, LogBuff, Log );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_SYSVOL, Current, SysVolBuff, SysVol );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_PARENT, Current, ParentBuff, Parent );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_REPLICA, Current, ReplicaBuff, Replica );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_USER, Current, UserBuff, User );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_PASSWORD, Current, PasswordBuff, Password );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_SERVER, Current, ServerBuff, Server );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_OPTIONS, Current, ScratchBuff, Scratch );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_WAIT, Current, WaitBuff, Wait );

            printf("Unexpected command line value %s\n\n", argv[i] );
            Win32Error = ERROR_INVALID_PARAMETER;

            break;
        }

        if ( Scratch != NULL ) {

            Options = wcstoul( Scratch, &Scratch, 0 );
        }

        //
        // Validate the parameters
        //
        if ( Dns == NULL || Db == NULL || Log == NULL || Flat == NULL ) {

            Win32Error = ERROR_INVALID_PARAMETER;
        }

        if( Win32Error == ERROR_INVALID_PARAMETER ) {

            Usage( Dns, Flat, Site, Db );
            goto Done;
        }

        if ( Wait && wcscmp( Wait, L"1" ) ) {

            Block = TRUE;
        }

        Win32Error = Promote( Dns, Flat, Site, Db, Log, SysVol, Parent,
                              Replica, User, Password, Server, Options, Block );
    } else if (argc > 1 && ( _stricmp( argv[ 1 ], "-demote" ) == 0 || _stricmp( argv[ 1 ], "/demote" ) == 0 ) ) {

        for (i = 2; i < argc; i++ ) {

            Current = argv[i];

            if ( !( *Current == '-' || *Current == '/' ) ) {

                Win32Error = ERROR_INVALID_PARAMETER;
                break;
            }

            Current++;

            PARSE_CMD_VALUE_AND_CONTINUE( TAG_USER, Current, UserBuff, User );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_PASSWORD, Current, PasswordBuff, Password );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_ROLE, Current, RoleBuff, RoleScratch );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_OPTIONS, Current, ScratchBuff, Scratch );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_LASTDC, Current, LastDCBuff, LastDCScratch );

            printf("Unexpected command line value %s\n\n", argv[i] );
            Win32Error = ERROR_INVALID_PARAMETER;

            break;
        }

        if ( Scratch != NULL ) {

            Options = wcstoul( Scratch, &Scratch, 0 );
        }

        if ( RoleScratch == NULL ) {

            Win32Error = ERROR_INVALID_PARAMETER;

        } else {

            Role = wcstoul( RoleScratch, &RoleScratch, 0);
        }

        if ( LastDCScratch != NULL ) {

            LastDC = ( BOOL )wcstoul( LastDCScratch, &LastDCScratch, 0);
        }

        if( Win32Error == ERROR_INVALID_PARAMETER ) {

            Usage( Dns, Flat, Site, Db );
            goto Done;
        }

        Win32Error = Demote( User, Password, Role, Options, LastDC );

    } else if (argc > 1 && ( _stricmp( argv[ 1 ], "-save" ) == 0 || _stricmp( argv[ 1 ], "/save" ) == 0 ) ) {

        Win32Error = Save();

    } else if (argc > 1 && ( _stricmp( argv[ 1 ], "-abort" ) == 0 || _stricmp( argv[ 1 ], "/abort" ) == 0 ) ) {

        for (i = 2; i < argc; i++ ) {

            Current = argv[i];

            if ( !( *Current == '-' || *Current == '/' ) ) {

                Win32Error = ERROR_INVALID_PARAMETER;
                break;
            }

            Current++;

            PARSE_CMD_VALUE_AND_CONTINUE( TAG_ADMINPWD, Current, AdminPwdBuff, AdminPwd );

            printf("Unexpected command line value %s\n\n", argv[i] );
            Win32Error = ERROR_INVALID_PARAMETER;

            break;
        }


        Win32Error = Abort( AdminPwd );

    } else if (argc > 1 && ( _stricmp( argv[ 1 ], "-upgrade" ) == 0 || _stricmp( argv[ 1 ], "/upgrade" ) == 0) ) {

        if ( BuildDefaultsFailed ) {

            printf( "Failed to get the defaults: %lu\n", Win32Error );
            goto Done;

        }

        for (i = 2; i < argc; i++ ) {

            Current = argv[i];

            if ( !( *Current == '-' || *Current == '/' ) ) {

                Win32Error = ERROR_INVALID_PARAMETER;
                break;
            }

            Current++;

            PARSE_CMD_VALUE_AND_CONTINUE( TAG_DNS, Current, DnsBuff, Dns );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_SITE, Current, SiteBuff, Site );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_DB, Current, DbBuff, Db );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_LOG, Current, LogBuff, Log );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_SYSVOL, Current, SysVolBuff, SysVol );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_PARENT, Current, ParentBuff, Parent );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_USER, Current, UserBuff, User );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_PASSWORD, Current, PasswordBuff, Password );
            PARSE_CMD_VALUE_AND_CONTINUE( TAG_OPTIONS, Current, ScratchBuff, Scratch );

            printf("Unexpected command line value %s\n\n", argv[i] );
            Win32Error = ERROR_INVALID_PARAMETER;

            break;
        }

        if ( Scratch != NULL ) {

            Options = wcstoul( Scratch, &Scratch, 0 );
        }

        //
        // Validate the parameters
        //
        if ( Dns == NULL || Db == NULL || Log == NULL ) {

            Win32Error = ERROR_INVALID_PARAMETER;
        }

        if( Win32Error == ERROR_INVALID_PARAMETER ) {

            Usage( Dns, Flat, Site, Db );
            goto Done;
        }

        Win32Error = Upgrade( Dns, Site, Db, Log, SysVol, Parent, User,
                              Password, Options );
    }


Done:
    if( Win32Error == ERROR_SUCCESS ) {

        printf("The command completed successfully\n");

    } else {

        printf("The command failed with an error %lu\n", Win32Error );

    }

    return( Win32Error );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\expired\expired.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1992
//
// File:        expired.cxx
//
// Contents:    Program to test if a NT account is about to expire.
//
//
// History:     10-Nov-94   Created         MikeSw
//
//------------------------------------------------------------------------


extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntsam.h>
#include <ntlsa.h>
#include <lmaccess.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
}


VOID
DoMsvStuff(
    PWSTR Domain
    )
{
    HKEY hKey ;
    DWORD dwType, dwSize ;
    int err ;
    WCHAR DomainBuffer[ 64 ];

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        TEXT("System\\CurrentControlSet\\Control\\Lsa\\MSV1_0" ),
                        0,
                        KEY_READ | KEY_WRITE,
                        &hKey );

    if ( err == 0 )
    {
        dwSize = sizeof( DomainBuffer );

        err = RegQueryValueEx( hKey,
                               TEXT("PreferredDomain"),
                               NULL,
                               &dwType,
                               (PBYTE) DomainBuffer,
                               &dwSize );

        if ( err == 0 )
        {
            //
            // Already set, we're done.
            //

            RegCloseKey( hKey );

            return ;
        }

        dwSize = wcslen( Domain ) * sizeof( WCHAR ) + 2;

        err = RegSetValueEx( hKey,
                             TEXT("PreferredDomain"),
                             NULL,
                             REG_SZ,
                             (PBYTE) Domain,
                             dwSize );

        err = RegSetValueEx( hKey,
                             TEXT("MappedDomain"),
                             NULL,
                             REG_SZ,
                             (PBYTE) TEXT("NTDEV"),
                             sizeof( TEXT("NTDEV") ) );

        RegCloseKey( hKey );

        return ;

    }

    if ( err = ERROR_ACCESS_DENIED )
    {
        err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            TEXT("System\\CurrentControlSet\\Control\\Lsa\\MSV1_0" ),
                            0,
                            KEY_READ,
                            &hKey );

        if ( err == 0 )
        {
            err = RegQueryValueEx( hKey,
                                   TEXT("PreferredDomain"),
                                   NULL,
                                   &dwType,
                                   (PBYTE) DomainBuffer,
                                   &dwSize );

            if ( err == 0 )
            {
                //
                // Already set, we're done.
                //

                RegCloseKey( hKey );

                return ;
            }

            OutputDebugStringW( TEXT("[SECURITY] Unable to set IDW Domain Mapping") );

            RegCloseKey( hKey );

            return ;
        }
    }
}

void _cdecl
main(int argc, char *argv[])
{
    WCHAR DomainName[100];
    WCHAR UserBuffer[100];
    WCHAR TestDCName[100];
    LPWSTR UserName = NULL;
    LPWSTR DCName = NULL;
    NTSTATUS Status;
    ULONG BufSize = 100;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING UnicodeName;
    SAM_HANDLE SamHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;
    SAM_HANDLE UserHandle = NULL;
    LSA_HANDLE LsaHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo = NULL;
    PULONG RelativeIds = NULL;
    PSID_NAME_USE Use = NULL;
    PUSER_LOGON_INFORMATION LogonInfo = NULL;
    LARGE_INTEGER CurrentTime;
    ULONG CurrentSeconds;
    ULONG ExpireSeconds;
    ULONG DiffSeconds;
    ULONG ExpiryDays;
    WCHAR TextBuffer[100];

    if (argc != 2)
    {
        printf("Usage: %s domainname\n",argv[0]);
        return;
    }
    mbstowcs(DomainName,argv[1],100);

    DoMsvStuff( DomainName );

    if (!GetUserName(UserBuffer,&BufSize))
    {
        printf("Failed to get user name: %d\n",GetLastError());
        return;

    }
    UserName = wcsrchr(UserBuffer,L'\\');
    if (UserName != NULL)
    {
        UserName++;
    }
    else UserName = UserBuffer;
//    printf("Checking account %ws\\%ws\n",DomainName,UserName);

    Status = NetGetDCName(
                    NULL,
                    DomainName,
                    (PBYTE *) &DCName
                    );
    if (Status != 0)
    {
        printf("Failed to find a DC: %d\n",Status);
        return;
    }

    //
    // Connect to the LSA on the DC
    //

    RtlInitUnicodeString(&UnicodeName,DCName);

//    printf("Connecting to DC %wZ\n",&UnicodeName);

    InitializeObjectAttributes(&oa,NULL,0,NULL,NULL);

    Status = LsaOpenPolicy(
                &UnicodeName,
                &oa,
                POLICY_VIEW_LOCAL_INFORMATION,
                &LsaHandle
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to open lsa: 0x%x\n",Status);
        goto Cleanup;
    }

    Status = LsaQueryInformationPolicy(
                LsaHandle,
                PolicyAccountDomainInformation,
                (PVOID *) &DomainInfo
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to query information policy: 0x%x\n",Status);
        goto Cleanup;
    }

//    printf("Found account domain %wZ\n",&DomainInfo->DomainName);


    Status = SamConnect(
                &UnicodeName,
                &SamHandle,
                SAM_SERVER_LOOKUP_DOMAIN,
                &oa);
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to connect to sam: 0x%x\n",Status);
        goto Cleanup;
    }

    Status = SamOpenDomain(
                SamHandle,
                DOMAIN_LOOKUP,
                DomainInfo->DomainSid,
                &DomainHandle
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to open domain: 0x%x\n",Status);
        goto Cleanup;
    }

    RtlInitUnicodeString(
        &UnicodeName,
        UserName
        );

    Status = SamLookupNamesInDomain(
                DomainHandle,
                1,
                &UnicodeName,
                &RelativeIds,
                &Use
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup names in domain: 0x%x\n",Status);
        goto Cleanup;
    }
    if (Use[0] != SidTypeUser)
    {
        printf("Sid type for user %wZ is not user, is %d\n",&UnicodeName,Use[0]);
        goto Cleanup;
    }

    Status = SamOpenUser(
                DomainHandle,
                USER_READ_GENERAL | USER_READ_LOGON | USER_READ_ACCOUNT | USER_READ_PREFERENCES,
                RelativeIds[0],
                &UserHandle
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to open user: 0x%x\n",Status);
        goto Cleanup;
    }

    Status = SamQueryInformationUser(
                UserHandle,
                UserLogonInformation,
                (PVOID *) &LogonInfo
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to query logon information: 0x%x\n",Status);
        goto Cleanup;
    }

    //
    // We got the PasswordMustChange field.  Now do something with it.
    //

    Status = NtQuerySystemTime( &CurrentTime );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to query system time: 0x%x\n",Status);
        goto Cleanup;
    }

    if (!RtlTimeToSecondsSince1980(&CurrentTime,&CurrentSeconds))
    {
        printf("Cannot convert current time to seconds since 1980\n");
        goto Cleanup;
    }
    if (!RtlTimeToSecondsSince1980(&LogonInfo->PasswordMustChange,&ExpireSeconds))
    {
        printf("No password expiry date\n");
        goto Cleanup;
    }
    if (ExpireSeconds < CurrentSeconds)
    {
        DiffSeconds = 0;
        printf("Password has expired\n");
    }
    else
    {

#define SECONDS_PER_DAY (60 * 60 * 24)
        DiffSeconds = ExpireSeconds - CurrentSeconds;
        ExpiryDays = DiffSeconds/SECONDS_PER_DAY;
        wsprintf(TextBuffer,L"Password will expire in %d days\n",ExpiryDays);
        if (ExpiryDays <= 14)
        {
            MessageBox(NULL,TextBuffer,L"Password Will Expire",MB_OK );
        }
        else
        {
            printf("%ws",TextBuffer);
        }
    };




Cleanup:
    if (LsaHandle != NULL)
    {
        LsaClose(LsaHandle);
    }
    if (UserHandle != NULL)
    {
        SamCloseHandle(UserHandle);
    }
    if (DomainHandle != NULL)
    {
        SamCloseHandle(DomainHandle);
    }
    if (SamHandle != NULL)
    {
        SamCloseHandle(SamHandle);
    }
    if (DomainInfo != NULL)
    {
        LsaFreeMemory(DomainInfo);
    }
    if (RelativeIds != NULL)
    {
        SamFreeMemory(RelativeIds);
    }
    if (Use != NULL)
    {
        SamFreeMemory(Use);
    }
    if (LogonInfo != NULL)
    {
        SamFreeMemory(LogonInfo);
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\getcerts\getcerts.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1992
//
// File:        secret.cxx
//
// Contents:    test program to check the setup of a Cairo installation
//
//
// History:     22-Dec-92       Created         MikeSw
//
//------------------------------------------------------------------------


extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <stdio.h>
#include <windef.h>
#include <winbase.h>
#include <winreg.h>
#include <string.h>
#include <stdlib.h>

}

void _cdecl
main(int argc, char *argv[])
{
    LPSTR KeyName;
    LPSTR ValueName;
    FILE * File;
    DWORD RegStatus;
    HKEY Key = NULL;
    PBYTE Buffer = NULL;
    ULONG Size;
    ULONG Type;
    CHAR FileName[20];
    ULONG Index;
    ULONG CertCount;
    CHAR NameBuffer[10];
    ULONG NameBufferSize;
    BYTE VerisignCert[] = {
        0x30, 0x82, 0x02, 0x79, 0x30, 0x82, 0x01, 0xE2,
        0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x35,
        0x11, 0xA5, 0x52, 0x90, 0x6F, 0xE7, 0xD0, 0x29,
        0xA4, 0x40, 0x19, 0xD4, 0x11, 0xFC, 0x3E, 0x30
        };


    //
    // Open the key with the list of certificates
    //


    RegStatus = RegOpenKeyExA(
                    HKEY_CURRENT_USER,
                    "Software\\Microsoft\\Cryptography\\PersonalCertificates\\ClientAuth\\Certificates",
                    0,
                    KEY_QUERY_VALUE,
                    &Key
                    );
    if (RegStatus != ERROR_SUCCESS)
    {
        printf("No certificates found\n");
        return;
    }

    //
    // Enumerate throught the values
    //

    CertCount = 1;
    for (Index = 0; ; Index++ )
    {

        NameBufferSize = sizeof(NameBuffer);
        RegStatus = RegEnumValueA(
                        Key,
                        Index,
                        NameBuffer,
                        &NameBufferSize,
                        0,
                        &Type,
                        NULL,
                        &Size );
        if ((RegStatus != STATUS_SUCCESS) &&
            (RegStatus != ERROR_MORE_DATA))
        {
            break;
        }

        //
        // We only want binary values
        //

        if (Type != REG_BINARY)
        {
            continue;
        }

        Buffer = (PBYTE) LocalAlloc(LMEM_ZEROINIT, Size);
        if (Buffer == NULL)
        {
            goto Cleanup;
        }

        NameBufferSize = sizeof(NameBuffer);

        RegStatus = RegEnumValueA(
                        Key,
                        Index,
                        NameBuffer,
                        &NameBufferSize,
                        0,
                        &Type,
                        Buffer,
                        &Size );

        if (RegStatus != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

        //
        // Skip the verisign certificate.
        //

        if (memcmp(Buffer,VerisignCert, sizeof(VerisignCert)) == 0)
        {
            LocalFree(Buffer);
            Buffer = NULL;
            continue;
        }
        if (CertCount == 1)
        {
            sprintf(FileName,"mycerts.cer");
        }
        else
        {
            sprintf(FileName,"mycerts%d.cer",CertCount);
        }
        File = fopen(FileName,"wb");
        if (File == NULL)
        {
            printf("Error opening file %s\n",FileName);
            goto Cleanup;
        }

        fwrite(Buffer, Size, 1, File);
        fclose(File);
        LocalFree(Buffer);
        Buffer = NULL;
        CertCount++;
    }

Cleanup:
    if (Key != NULL)
    {
        RegCloseKey(Key);
    }
    if (Buffer != NULL)
    {
        LocalFree(Buffer);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\joindom\joindom.c ===
/*++

Copyright (c) 1997 - 1997  Microsoft Corporation

Module Name:

    joindom.c

Abstract:

    Unit test for NetJoinDomain and NetUnjoinDomain APIs

Author:

    Mac McLain   (MacM)     19-Feb-1997

Environment:

    User mode only.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmjoin.h>
#include <lmapibuf.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define JOIN_TAG    "join"
#define UNJOIN_TAG  "unjoin"
#define NAME_TAG    "name"
#define RENAME_TAG  "rename"
#define INFO_TAG    "info"
#define OU_TAG      "ous"
#define ADD_ALT_NAME "addaltname"
#define DEL_ALT_NAME "delaltname"
#define SET_PRI_NAME "setpriname"
#define GET_PRI_NAME "getpriname"
#define GET_ALT_NAMES "getaltnames"
#define GET_ALL_NAMES "getallnames"

NET_API_STATUS
NET_API_FUNCTION
NetpGetListOfJoinableOUs(
    IN LPWSTR Domain,
    IN LPWSTR Account,
    IN LPWSTR Password,
    OUT PULONG Count,
    OUT PWSTR **OUs
    );

    NET_API_STATUS
NET_API_FUNCTION
NetpCreateComputerObjectInOU(
    IN LPWSTR DC,
    IN LPWSTR OU,
    IN LPWSTR ComputerName,
    IN LPWSTR Account,
    IN LPWSTR Password,
    IN LPWSTR MachinePassword
    );

void
Usage(
    VOID
    )
/*++

Routine Description:

    Displays the expected usage

Arguments:

    None

Return Value:

    VOID

--*/
{
    printf("joindom -operation options domain/server [account] [password] [new/alt name] [OU]\n");
    printf("   where:\n");
    printf("        operation indicates what joindom should do:\n");
    printf("            -%s  Joins a workstation to a domain/workgroup\n", JOIN_TAG);
    printf("            -%s  Unjoins a workstation from a domain\n", UNJOIN_TAG);
    printf("            -%s  Renames the machine to a new name\n", RENAME_TAG);
    printf("            -%s  Validates the give name for validity\n", NAME_TAG);
    printf("            -%s  Returns information about the state of the join\n", INFO_TAG );
    printf("            -%s  Returns information about the joinable ous\n", OU_TAG );
    printf("            -%s  Add alternative computer name\n", ADD_ALT_NAME );
    printf("            -%s  Delete alternative computer name\n", DEL_ALT_NAME );
    printf("            -%s  Set primary computer name\n", SET_PRI_NAME );
    printf("            -%s  Get primary computer name\n", GET_PRI_NAME );
    printf("            -%s  Get altername computer names\n", GET_ALT_NAMES );
    printf("            -%s  Get all computer names\n", GET_ALL_NAMES );
    printf("        options specifies the flags for the command\n");
    printf("                0x000000001     Joins a domain instead of workgroup\n");
    printf("                0x000000002     Creates the account on the domain\n");
    printf("                0x000000004     Deletes the account when leaving a domain\n");
    printf("        domain/server specifies the domain (or server for alt name APIs) path to operate on\n" );
    printf("        [account] is the name of the account to use for accessing domain objects\n");
    printf("        [password] is the password of the account to use while "
           "accessing domain objects\n");
    printf("        [newname] is the new computer name \n");
    printf("        [OU] is the name of the ou to create the machine account in\n");
}



int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    See main comment.

Arguments:

    argc - the number of command-line arguments.

    argv - an array of pointers to the arguments.

Return Value:

    Exit status

--*/
{
    NET_API_STATUS  NetStatus = NERR_Success;
    WCHAR           wszDomain[MAX_PATH + 1];
    WCHAR           rgwszOpts[3][MAX_PATH + 1];
    PWSTR           ppwszOpts[3] = { NULL, NULL, NULL };
    PWSTR           ppwszJoinTypes[ ] = { L"NetSetupUnknownStatus",
                                          L"NetSetupUnjoined",
                                          L"NetSetupWorkgroupName",
                                          L"NetSetupDomainName" };
    WCHAR           wszMachine[MAX_COMPUTERNAME_LENGTH + 1];
    PWSTR           pwszJoinInfo;
    WCHAR           wszInfo[256];
    ULONG           i, Options = 0, cLen, Count;
    PWSTR           *OUs;
    PSTR            pszNext;
    NETSETUP_JOIN_STATUS JoinType;

    BOOLEAN EnumerateComputerName = FALSE;
    NET_COMPUTER_NAME_TYPE ComputerNameType;
    LPSTR ComputerNameTypeString = NULL;
    BOOLEAN PrintUsage = FALSE;


    if (argc < 4) {

        PrintUsage = TRUE;
        goto Cleanup;

    } else {

        cLen  = MAX_COMPUTERNAME_LENGTH + 1;
        if ( GetComputerNameW( wszMachine, &cLen ) == FALSE ) {

            NetStatus = GetLastError();
            printf("Failed to get the local computer name: %lu\n", NetStatus );
        }

    }

    if ( NetStatus == NERR_Success) {

        //
        // Process the command line
        //
        Options = strtoul( argv[2], &pszNext, 0 );
        mbstowcs( wszDomain, argv[3], strlen(argv[3]) + 1 );

        for ( i = 4 ; i < (ULONG)argc && i < 7 ; i++ ) {

            mbstowcs(rgwszOpts[i - 4], argv[i], strlen( argv[i] ) + 1 );
            ppwszOpts[i - 4] = rgwszOpts[i - 4];
        }

    }

    //
    // Now, do the operations
    //
    if ( NetStatus == NERR_Success && (*argv[1] == '/' || *argv[1] == '-' ) ) {

        if ( _stricmp( argv[1] + 1, JOIN_TAG ) == 0 ) {

            //
            // Do the call
            //
            NetStatus = NetJoinDomain( wszMachine, wszDomain, ppwszOpts[2],
                                       ppwszOpts[0], ppwszOpts[1],
                                       Options );

            if ( NetStatus != NERR_Success ) {

                printf( "NetJoinDomain [%ws] [%ws] [%ws] [0x%lx] failed with %lu\n",
                        wszDomain,
                        ppwszOpts[0] == NULL ? L"NULL" : ppwszOpts[0],
                        ppwszOpts[1] == NULL ? L"NULL" : ppwszOpts[1],
                        Options,
                        NetStatus );
            }


        } else if ( _stricmp( argv[1] + 1, UNJOIN_TAG ) == 0 ) {

            NetStatus = NetUnjoinDomain( NULL, ppwszOpts[0], ppwszOpts[1], Options );

            if ( NetStatus != NERR_Success ) {

                printf( "NetUnjoinDomain [%ws] [%ws] [0x%lx] failed with %lu\n",
                        ppwszOpts[0] == NULL ? L"NULL" : ppwszOpts[0],
                        ppwszOpts[1] == NULL ? L"NULL" : ppwszOpts[1],
                        Options,
                        NetStatus );
            }

        } else if ( _stricmp( argv[1] + 1, RENAME_TAG ) == 0 ) {

            //
            // First, set the computer name
            //
            if ( ppwszOpts[2] == NULL ) {

                PrintUsage = TRUE;
                goto Cleanup;

            } else {

                if( SetComputerName( ppwszOpts[2] ) == FALSE ) {

                    NetStatus = GetLastError();

                } else {

                    NetStatus = NetRenameMachineInDomain( NULL, ppwszOpts[ 2 ],
                                                          ppwszOpts[0], ppwszOpts[1],
                                                          Options );
                    if ( NetStatus != NERR_Success ) {

                        printf( "NetRenameMachineInDomain [%ws] [%ws] [%ws] [%ws] [0x%lx] failed with %lu\n",
                                ppwszOpts[2],
                                wszDomain,
                                ppwszOpts[0] == NULL ? L"NULL" : ppwszOpts[0],
                                ppwszOpts[1] == NULL ? L"NULL" : ppwszOpts[1],
                                Options,
                                NetStatus );

                    }

                }

            }

        } else if ( _stricmp( argv[1] + 1, NAME_TAG ) == 0 ) {

            //
            // Validate name as all four types
            //
            if ( NetStatus == NERR_Success ) {

                NetStatus = NetValidateName( wszMachine, wszDomain, ppwszOpts[0], ppwszOpts[1],
                                             NetSetupMachine );

                if( NetStatus == NERR_Success ) {

                    printf( "Name %ws valid as machine name\n", wszDomain );

                } else {

                    printf( "Name %ws invalid as machine name: %lu\n",
                            wszDomain, NetStatus );

                }

                //
                // workgroup name
                //
                NetStatus = NetValidateName( wszMachine, wszDomain, ppwszOpts[0], ppwszOpts[1],
                                             NetSetupWorkgroup );

                if( NetStatus == NERR_Success ) {

                    printf( "Name %ws valid as workgroup name\n", wszDomain );

                } else {

                    printf( "Name %ws invalid as workgroup name: %lu\n",
                            wszDomain, NetStatus );

                }

                //
                // Domain name
                //

                NetStatus = NetValidateName( wszMachine, wszDomain, ppwszOpts[0], ppwszOpts[1],
                                             NetSetupDomain );

                if( NetStatus == NERR_Success ) {

                    printf( "Name %ws valid as domain name\n", wszDomain );

                } else {

                    printf( "Name %ws invalid as domain name: %lu\n",
                            wszDomain, NetStatus );

                }

                //
                // Domain name
                //

                NetStatus = NetValidateName( wszMachine, wszDomain, ppwszOpts[0], ppwszOpts[1],
                                             NetSetupNonExistentDomain );

                if( NetStatus == NERR_Success ) {

                    printf( "Name %ws valid as non existent domain name\n", wszDomain );

                } else {

                    printf( "Name %ws invalid as nonexistent domain name: %lu\n",
                            wszDomain, NetStatus );

                }
            }


        } else if ( _stricmp( argv[1] + 1, INFO_TAG ) == 0 ) {

            //
            // Call it 3 times, 1: NULL buffer, 2: valid ptr, 3: remotely
            //
#if 0
            NetStatus = NetGetJoinInformation( NULL, NULL, &JoinType );

            if ( NetStatus == ERROR_INVALID_PARAMETER ) {

                NetStatus = NERR_Success;
                printf( "JoinInfo with NULL buffer returned correctly\n" );

            } else {

                printf( "JoinInfo with NULL buffer incorrectly returned %lu\n", NetStatus );
                NetStatus = ERROR_INVALID_DATA;
            }
#endif

            NetStatus = NetGetJoinInformation( NULL, &pwszJoinInfo, &JoinType );
            if ( NetStatus == NERR_Success ) {

                printf( "Join type: %ws\n", ppwszJoinTypes[ JoinType ] );
                printf( "Joined to %ws\n", pwszJoinInfo );
                NetApiBufferFree( pwszJoinInfo );

            } else {

                printf(" NetGetJoinInformation,  failed with %lu\n", NetStatus );

            }

#if 0
            NetStatus = NetGetJoinInformation( wszMachine, &pwszJoinInfo, &JoinType );
            if ( NetStatus == NERR_Success ) {

                printf( "Joined to %ws\n", pwszJoinInfo );
                NetApiBufferFree( pwszJoinInfo );

            } else {

                printf(" NetGetJoinInformation, remotely, failed with %lu\n", NetStatus );

            }
#endif

        } else if ( _stricmp( argv[1] + 1, OU_TAG ) == 0 ) {

            NetStatus =  NetGetJoinableOUs( NULL, ( LPCWSTR )wszDomain, ( LPCWSTR )ppwszOpts[0],
                                            ( LPCWSTR )ppwszOpts[1], &Count, &OUs );

            if ( NetStatus != NERR_Success ) {

                printf( "NetGetJoinableOUs returned %lu\n", NetStatus );

            } else {

                printf( "NetGetJoinableOUs returned %lu ous\n", Count );
                for ( i = 0; i < Count; i++ ) {

                    printf("  %ws\n", OUs[ i ] );
                }

                NetApiBufferFree( OUs );
            }

        } else if ( _stricmp( argv[1] + 1, ADD_ALT_NAME ) == 0 ) {

            printf( "\nAdding alternate computer name with following parameters:\n" );
            printf( "   Server:         %ws\n", wszDomain );
            printf( "   Alternate name: %ws\n", ppwszOpts[2] );
            printf( "   Options:        0x%lx\n", Options );
            printf( "   Account:        %ws\n", ppwszOpts[0] );
            printf( "   Password:       %ws\n\n", ppwszOpts[1] );

            NetStatus = NetAddAlternateComputerName(
                                wszDomain,     // treated as server name
                                ppwszOpts[2],  // alternate name
                                ppwszOpts[0],  // domain account
                                ppwszOpts[1],  // domain account pwd
                                Options );

            if ( NetStatus != NERR_Success ) {
                printf( "NetAddAlternateComputerName failed: 0x%lx\n", NetStatus );
            }

        } else if ( _stricmp( argv[1] + 1, DEL_ALT_NAME ) == 0 ) {

            printf( "\nDeleting alternate computer name with following parameters:\n" );
            printf( "   Server:         %ws\n", wszDomain );
            printf( "   Alternate name: %ws\n", ppwszOpts[2] );
            printf( "   Options:        0x%lx\n", Options );
            printf( "   Account:        %ws\n", ppwszOpts[0] );
            printf( "   Password:       %ws\n\n", ppwszOpts[1] );

            NetStatus = NetRemoveAlternateComputerName(
                                wszDomain,     // treated as server name
                                ppwszOpts[2],  // alternate name
                                ppwszOpts[0],  // domain account
                                ppwszOpts[1],  // domain account pwd
                                Options );

            if ( NetStatus != NERR_Success ) {
                printf( "NetRemoveAlternateComputerName failed: 0x%lx\n", NetStatus );
            }

        } else if ( _stricmp( argv[1] + 1, SET_PRI_NAME ) == 0 ) {

            printf( "\nSetting primary computer name with following parameters:\n" );
            printf( "   Server:       %ws\n", wszDomain );
            printf( "   Primary name: %ws\n", ppwszOpts[2] );
            printf( "   Options:      0x%lx\n", Options );
            printf( "   Account:      %ws\n", ppwszOpts[0] );
            printf( "   Password:     %ws\n\n", ppwszOpts[1] );

            NetStatus = NetSetPrimaryComputerName(
                                wszDomain,     // treated as server name
                                ppwszOpts[2],  // alternate name
                                ppwszOpts[0],  // domain account
                                ppwszOpts[1],  // domain account pwd
                                Options );

            if ( NetStatus != NERR_Success ) {
                printf( "NetSetPrimaryComputerName failed: 0x%lx\n", NetStatus );
            }

        } else if ( _stricmp( argv[1] + 1, GET_PRI_NAME ) == 0 ) {
            EnumerateComputerName = TRUE;
            ComputerNameType = NetPrimaryComputerName;
            ComputerNameTypeString = "primary";

        } else if ( _stricmp( argv[1] + 1, GET_ALT_NAMES ) == 0 ) {
            EnumerateComputerName = TRUE;
            ComputerNameType = NetAlternateComputerNames;
            ComputerNameTypeString = "alternate";

        } else if ( _stricmp( argv[1] + 1, GET_ALL_NAMES ) == 0 ) {
            EnumerateComputerName = TRUE;
            ComputerNameType = NetAllComputerNames;
            ComputerNameTypeString = "all";

        } else {

            PrintUsage = TRUE;
            goto Cleanup;
        }

    } else {

        PrintUsage = TRUE;
        goto Cleanup;
    }

    if ( EnumerateComputerName ) {
        ULONG EntryCount = 0;
        LPWSTR *ComputerNames = NULL;

        printf( "\nGetting %s computer name(s) for server %ws with options 0x%lx:\n",
                ComputerNameTypeString,
                wszDomain,  // treated as server name
                Options );

        NetStatus = NetEnumerateComputerNames(
                        wszDomain,        // treated as server name
                        ComputerNameType, // name type
                        Options,
                        &EntryCount,
                        &ComputerNames );

        if ( NetStatus != NERR_Success ) {
            printf( "NetEnumerateComputerNames failed: 0x%lx\n", NetStatus );
        } else {
            ULONG i;

            if ( EntryCount > 0 ) {
                for ( i = 0; i < EntryCount; i++ ) {
                    printf( "%ws\n", ComputerNames[i] );

                }
            } else {
                printf( "No names returned.\n" );
            }
            NetApiBufferFree( ComputerNames );
        }
    }

Cleanup:

    if ( PrintUsage ) {
        Usage();
    }

    if ( NetStatus == NERR_Success ) {

        printf( "The command completed successfully\n" );

    } else {

        printf( "The command failed with error %lu\n", NetStatus );
    }


    return( NetStatus == NERR_Success );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\k5import\k5import.cxx ===
#define UNICODE
#define INC_OLE2
#include <windows.h>
#include <activeds.h>
#include <ntsecapi.h>
#include <stdio.h>      // printf
#include <stdlib.h>     // strtoul
#include <assert.h>
#define SECURITY_WIN32
#include <security.h>   // General definition of a Security Support Provider
#include <shlwapi.h>

typedef	int	krb5_int32;
typedef	short	krb5_int16;

typedef	unsigned int krb5_kvno;	
typedef	unsigned char	krb5_octet;
typedef unsigned int 	krb5_enctype;

typedef krb5_int32	krb5_deltat;
typedef	krb5_int32	krb5_flags;
typedef krb5_int32	krb5_timestamp;
typedef	krb5_int32	krb5_error_code;

typedef	char FAR * krb5_principal;
typedef	void FAR * krb5_pointer;

/*
 * Note --- these structures cannot be modified without changing the
 * database version number in libkdb.a, but should be expandable by
 * adding new tl_data types.
 */
typedef struct _krb5_tl_data {
    struct _krb5_tl_data* tl_data_next;		/* NOT saved */
    krb5_int16 		  tl_data_type;		
    krb5_int16		  tl_data_length;	
    krb5_octet 	        * tl_data_contents;	
} krb5_tl_data;

/* 
 * If this ever changes up the version number and make the arrays be as
 * big as necessary.
 *
 * Currently the first type is the enctype and the second is the salt type.
 */
typedef struct _krb5_key_data {
    krb5_int16 		  key_data_ver;		/* Version */
    krb5_int16		  key_data_kvno;	/* Key Version */
    krb5_int16		  key_data_type[2];	/* Array of types */
    krb5_int16		  key_data_length[2];	/* Array of lengths */
    krb5_octet 	        * key_data_contents[2];	/* Array of pointers */
} krb5_key_data;

#define KRB5_KDB_V1_KEY_DATA_ARRAY	2	/* # of array elements */

typedef struct _krb5_db_entry_new {
    krb5_int16		  len;			
    krb5_flags 		  attributes;
    krb5_deltat		  max_life;
    krb5_deltat		  max_renewable_life;
    krb5_timestamp 	  expiration;	  	/* When the client expires */
    krb5_timestamp 	  pw_expiration;  	/* When its passwd expires */
    krb5_timestamp 	  last_success;		/* Last successful passwd */
    krb5_timestamp 	  last_failed;		/* Last failed passwd attempt */
    krb5_kvno 	 	  fail_auth_count; 	/* # of failed passwd attempt */
    krb5_int16 		  n_tl_data;
    krb5_int16 		  n_key_data;
    krb5_int16		  e_length;		/* Length of extra data */
    krb5_octet		* e_data;		/* Extra data to be saved */

    krb5_principal 	  princ;		/* Length, data */	
    krb5_tl_data	* tl_data;		/* Linked list */
    krb5_key_data       * key_data;		/* Array */
} krb5_db_entry;

typedef struct _krb5_keyblock {
    krb5_enctype enctype;
    int length;
    krb5_octet FAR *contents;
} krb5_keyblock;

krb5_keyblock mkey;


/* Strings */

static const char k5_dump_header[] = "kdb5_util load_dump version 4\n";

/* Message strings */
static const char regex_err[] = "%s: regular expression error - %s\n";
static const char regex_merr[] = "%s: regular expression match error - %s\n";
static const char pname_unp_err[] = "%s: cannot unparse principal name (%s)\n";
static const char mname_unp_err[] = "%s: cannot unparse modifier name (%s)\n";
static const char nokeys_err[] = "%s: cannot find any standard key for %s\n";
static const char sdump_tl_inc_err[] = "%s: tagged data list inconsistency for %s (counted %d, stored %d)\n";
static const char stand_fmt_name[] = "Kerberos version 5";
static const char old_fmt_name[] = "Kerberos version 5 old format";
static const char b6_fmt_name[] = "Kerberos version 5 beta 6 format";
static const char ofopen_error[] = "%s: cannot open %s for writing (%s)\n";
static const char oflock_error[] = "%s: cannot lock %s (%s)\n";
static const char dumprec_err[] = "%s: error performing %s dump (%s)\n";
static const char dumphdr_err[] = "%s: error dumping %s header (%s)\n";
static const char trash_end_fmt[] = "%s(%d): ignoring trash at end of line: ";
static const char read_name_string[] = "name string";
static const char read_key_type[] = "key type";
static const char read_key_data[] = "key data";
static const char read_pr_data1[] = "first set of principal attributes";
static const char read_mod_name[] = "modifier name";
static const char read_pr_data2[] = "second set of principal attributes";
static const char read_salt_data[] = "salt data";
static const char read_akey_type[] = "alternate key type";
static const char read_akey_data[] = "alternate key data";
static const char read_asalt_type[] = "alternate salt type";
static const char read_asalt_data[] = "alternate salt data";
static const char read_exp_data[] = "expansion data";
static const char store_err_fmt[] = "%s(%d): cannot store %s(%s)\n";
static const char add_princ_fmt[] = "%s\n";
static const char parse_err_fmt[] = "%s(%d): cannot parse %s (%s)\n";
static const char read_err_fmt[] = "%s(%d): cannot read %s\n";
static const char no_mem_fmt[] = "%s(%d): no memory for buffers\n";
static const char rhead_err_fmt[] = "%s(%d): cannot match size tokens\n";
static const char err_line_fmt[] = "%s: error processing line %d of %s\n";
static const char head_bad_fmt[] = "%s: dump header bad in %s\n";
static const char read_bytecnt[] = "record byte count";
static const char read_encdata[] = "encoded data";
static const char n_name_unp_fmt[] = "%s(%s): cannot unparse name\n";
static const char n_dec_cont_fmt[] = "%s(%s): cannot decode contents\n";
static const char read_nint_data[] = "principal static attributes";
static const char read_tcontents[] = "tagged data contents";
static const char read_ttypelen[] = "tagged data type and length";
static const char read_kcontents[] = "key data contents";
static const char read_ktypelen[] = "key data type and length";
static const char read_econtents[] = "extra data contents";
static const char k5beta_fmt_name[] = "Kerberos version 5 old format";
static const char standard_fmt_name[] = "Kerberos version 5 format";
static const char no_name_mem_fmt[] = "%s: cannot get memory for temporary name\n";
static const char ctx_err_fmt[] = "%s: cannot initialize Kerberos context\n";
static const char stdin_name[] = "standard input";
static const char restfail_fmt[] = "%s: %s restore failed\n";
static const char close_err_fmt[] = "%s: cannot close database (%s)\n";
static const char dbinit_err_fmt[] = "%s: cannot initialize database (%s)\n";
static const char dblock_err_fmt[] = "%s: cannot initialize database lock (%s)\n";
static const char dbname_err_fmt[] = "%s: cannot set database name to %s (%s)\n";
static const char dbdelerr_fmt[] = "%s: cannot delete bad database %s (%s)\n";
static const char dbunlockerr_fmt[] = "%s: cannot unlock database %s (%s)\n";
static const char dbrenerr_fmt[] = "%s: cannot rename database %s to %s (%s)\n";
static const char dbcreaterr_fmt[] = "%s: cannot create database %s (%s)\n";
static const char dfile_err_fmt[] = "%s: cannot open %s (%s)\n";

static const char oldoption[] = "-old";
static const char b6option[] = "-b6";
static const char verboseoption[] = "-verbose";
static const char updateoption[] = "-update";
static const char ovoption[] = "-ov";
static const char dump_tmptrail[] = "~";

#define	ENCTYPE_NULL		0x0000
#define	ENCTYPE_DES_CBC_CRC	0x0001	/* DES cbc mode with CRC-32 */
#define	ENCTYPE_DES_CBC_MD4	0x0002	/* DES cbc mode with RSA-MD4 */
#define	ENCTYPE_DES_CBC_MD5	0x0003	/* DES cbc mode with RSA-MD5 */
#define	ENCTYPE_DES_CBC_RAW	0x0004	/* DES cbc mode raw */
#define	ENCTYPE_DES3_CBC_SHA	0x0005	/* DES-3 cbc mode with NIST-SHA */
#define	ENCTYPE_DES3_CBC_RAW	0x0006	/* DES-3 cbc mode raw */
#define ENCTYPE_RC4_MD4          -128
#define ENCTYPE_RC4_PLAIN2       -129
#define ENCTYPE_RC4_LM           -130
#define ENCTYPE_RC4_SHA          -131
#define ENCTYPE_DES_PLAIN        -132
#define ENCTYPE_RC4_HMAC_OLD     -133
#define ENCTYPE_RC4_PLAIN_OLD    -134
#define ENCTYPE_RC4_HMAC_OLD_EXP -135
#define ENCTYPE_RC4_PLAIN_OLD_EXP -136
#define ENCTYPE_DES_CBC_MD5_EXP  -137
#define ENCTYPE_DES_PLAIN_EXP    -138
#define ENCTYPE_RC4_PLAIN        -140
#define ENCTYPE_RC4_PLAIN_EXP    -141
#define ENCTYPE_UNKNOWN		0x01ff

/* Salt types */
#define KRB5_KDB_SALTTYPE_NORMAL	0
#define KRB5_KDB_SALTTYPE_V4		1
#define KRB5_KDB_SALTTYPE_NOREALM	2
#define KRB5_KDB_SALTTYPE_ONLYREALM	3
#define KRB5_KDB_SALTTYPE_SPECIAL	4
#define KRB5_KDB_SALTTYPE_AFS3		5

/* Attributes */
#define	KRB5_KDB_DISALLOW_POSTDATED	0x00000001
#define	KRB5_KDB_DISALLOW_FORWARDABLE	0x00000002
#define	KRB5_KDB_DISALLOW_TGT_BASED	0x00000004
#define	KRB5_KDB_DISALLOW_RENEWABLE	0x00000008
#define	KRB5_KDB_DISALLOW_PROXIABLE	0x00000010
#define	KRB5_KDB_DISALLOW_DUP_SKEY	0x00000020
#define	KRB5_KDB_DISALLOW_ALL_TIX	0x00000040
#define	KRB5_KDB_REQUIRES_PRE_AUTH	0x00000080
#define KRB5_KDB_REQUIRES_HW_AUTH	0x00000100
#define	KRB5_KDB_REQUIRES_PWCHANGE	0x00000200
#define KRB5_KDB_DISALLOW_SVR		0x00001000
#define KRB5_KDB_PWCHANGE_SERVICE	0x00002000
#define KRB5_KDB_SUPPORT_DESMD5         0x00004000
#define	KRB5_KDB_NEW_PRINC		0x00008000

//
// SALT flags for encryption, from rfc1510 update 3des enctype
//

#define KERB_ENC_TIMESTAMP_SALT         1
#define KERB_TICKET_SALT                2
#define KERB_AS_REP_SALT                3
#define KERB_TGS_REQ_SESSKEY_SALT       4
#define KERB_TGS_REQ_SUBKEY_SALT        5
#define KERB_TGS_REQ_AP_REQ_AUTH_CKSUM_SALT     6
#define KERB_TGS_REQ_AP_REQ_AUTH_SALT   7
#define KERB_TGS_REP_SALT               8
#define KERB_TGS_REP_SUBKEY_SALT        9
#define KERB_AP_REQ_AUTH_CKSUM_SALT     10
#define KERB_AP_REQ_AUTH_SALT           11
#define KERB_AP_REP_SALT                12
#define KERB_PRIV_SALT                  13
#define KERB_CRED_SALT                  14
#define KERB_SAFE_SALT                  15
#define KERB_NON_KERB_SALT              16
#define KERB_NON_KERB_CKSUM_SALT        17
#define KERB_KERB_ERROR_SALT            18
#define KERB_KDC_ISSUED_CKSUM_SALT      19
#define KERB_MANDATORY_TKT_EXT_CKSUM_SALT       20
#define KERB_AUTH_DATA_TKT_EXT_CKSUM_SALT       21

LPSTR
get_error_text(DWORD dwError)
{
    PCHAR pBuf = NULL;
    DWORD cMsgLen = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM |
				  FORMAT_MESSAGE_ALLOCATE_BUFFER | 40,
				  NULL,
				  dwError,
				  MAKELANGID(0, SUBLANG_ENGLISH_US),
				  (LPSTR) &pBuf,
				  128,
				  NULL);
    if (!cMsgLen) {
	pBuf = (LPSTR)malloc(30);
	sprintf(pBuf, "(%d)", dwError);
    }
    return(pBuf);
}

void
print_salt_string(
    int stype,
    int len,
    char *str
)
{
    int i;
    
    switch (stype) {
    case KRB5_KDB_SALTTYPE_NORMAL:
	printf("Normal\n");
	break;
	
    case KRB5_KDB_SALTTYPE_V4:
	printf("V4\n");
	break;
	
    case KRB5_KDB_SALTTYPE_NOREALM:
	printf("No Realm : \"%*s\"\n", len, str);
	break;
	
    case KRB5_KDB_SALTTYPE_ONLYREALM:
	printf("Only Realm : \"%*s\"\n", len, str);
	break;
	
    case KRB5_KDB_SALTTYPE_AFS3:
	printf("AFS3 : \"%*s\"\n", len, str);
	break;
	
    case KRB5_KDB_SALTTYPE_SPECIAL:
	printf("Special [%d]:", len);
	goto dump;

    default:
	printf("salttype %d [%d]:", stype, len);
    dump:;
	for (i=0; i < len; i++)
	    printf(" %02x", str[i]);
	printf("\n");
	break;
    }
}

char *
etype_string(
    int enctype
)
{
    static char buf[32];
    
    switch (enctype) {
    case ENCTYPE_DES_CBC_CRC:
	return "DES-CBC-CRC";
	break;
    case ENCTYPE_DES_CBC_MD4:
	return "DES-CBC-MD4";
	break;
    case ENCTYPE_DES_CBC_MD5:
	return "DES-CBC-MD5";
	break;
    case ENCTYPE_DES3_CBC_SHA:
	return "DES3-CBC-SHA";
	break;
    case ENCTYPE_RC4_MD4:
	return "RC4-MD4";
	break;
    case ENCTYPE_RC4_PLAIN2:
	return "RC4-PLAIN2";
	break;
    case ENCTYPE_RC4_LM:
	return "RC4-LM";
	break;
    case ENCTYPE_RC4_SHA:
	return "RC4-SHA";
	break;
    case ENCTYPE_DES_PLAIN:
	return "DES-PLAIN";
	break;
    case ENCTYPE_RC4_HMAC_OLD:
	return "RC4-HMAC-OLD";
	break;
    case ENCTYPE_RC4_PLAIN_OLD:
	return "RC4-PLAIN-OLD";
	break;
    case ENCTYPE_RC4_HMAC_OLD_EXP:
	return "RC4-HMAC-OLD-EXP";
	break;
    case ENCTYPE_RC4_PLAIN_OLD_EXP:
	return "RC4-PLAIN-OLD-EXP";
	break;
    case ENCTYPE_DES_CBC_MD5_EXP:
	return "DES-CBC-MD5-40bit";
	break;
    case ENCTYPE_DES_PLAIN_EXP:
	return "DES-PLAIN-40bit";
	break;
    case ENCTYPE_RC4_PLAIN:
	return "RC4-PLAIN";
	break;
    case ENCTYPE_RC4_PLAIN_EXP:
	return "RC4-PLAIN-EXP";
	break;
	
    default:
	sprintf(buf, "etype %d", enctype);
	return buf;
	break;
    }
}

void
print_tl_data(
    int n_data,
    krb5_tl_data *tl_data
)
{
    krb5_tl_data *tlp;
    int i;
    
    if (n_data) {
	printf("\ttl_data:\n");
	
	for (tlp = tl_data; tlp; tlp = tlp->tl_data_next) {
	    printf("\t\ttype=%d len=%d ",
		   tlp->tl_data_type, tlp->tl_data_length);
	    for (i = 0; i < tlp->tl_data_length; i++)
		printf(" %02x", tlp->tl_data_contents[i]);
	    printf("\n");
	}
    }
}

int
decrypt_key(
    krb5_keyblock *key,
    void *indata,
    int inlen,
    void *outdata,
    int *outlen
)
{
#define SEC_SUCCESS(Status) ((Status) >= 0)
    static const UCHAR iVec[8] = {0};
    static HANDLE lsaHandle = NULL;
    static ULONG packageId = 0;
    NTSTATUS Status, SubStatus;
    LSA_STRING Name;
    PKERB_DECRYPT_REQUEST DecryptRequest;
    ULONG OutLen, DecryptReqLength;
    PUCHAR OutBuf;
    int retval = 0;

    if (!lsaHandle) {
	Status = LsaConnectUntrusted(&lsaHandle);
	if (!SEC_SUCCESS(Status)) {
	    fprintf(stderr, "Failed to create LsaHandle - 0x%x\n", Status);
	    exit(3);
	}

	Name.Buffer = MICROSOFT_KERBEROS_NAME_A;
	Name.Length = (USHORT)strlen(Name.Buffer);
	Name.MaximumLength = Name.Length + 1;

	Status = LsaLookupAuthenticationPackage(lsaHandle,
						&Name,
						&packageId);
	if (!SEC_SUCCESS(Status)) {
	    LsaDeregisterLogonProcess(lsaHandle);
	    fprintf(stderr, "Failed to register LsaHandle - 0x%x\n", Status);
	    exit(3);
	}
    }

    DecryptReqLength = 
	sizeof(KERB_DECRYPT_REQUEST) + key->length + 8 + inlen;
    DecryptRequest = (PKERB_DECRYPT_REQUEST)LocalAlloc(LMEM_ZEROINIT, DecryptReqLength);

    DecryptRequest->MessageType = KerbDecryptDataMessage;
    DecryptRequest->LogonId.LowPart = 0;
    DecryptRequest->LogonId.HighPart = 0;
    DecryptRequest->Flags = 0;
    DecryptRequest->KeyUsage = KERB_TICKET_SALT;
    DecryptRequest->CryptoType = key->enctype;
    DecryptRequest->Key.KeyType = key->enctype;
    DecryptRequest->Key.Length = key->length;
    DecryptRequest->Key.Value = (PUCHAR) (DecryptRequest + 1);
    memcpy(DecryptRequest->Key.Value, key->contents, key->length);
    DecryptRequest->InitialVectorSize = 8;
    DecryptRequest->InitialVector = (PUCHAR)
	((PUCHAR)DecryptRequest->Key.Value + DecryptRequest->Key.Length);
    memcpy(DecryptRequest->InitialVector, iVec, 8);
    DecryptRequest->EncryptedDataSize = inlen;
    DecryptRequest->EncryptedData = (PUCHAR)
	((PUCHAR)DecryptRequest->InitialVector + DecryptRequest->InitialVectorSize);
    memcpy(DecryptRequest->EncryptedData, indata, inlen);

    Status = LsaCallAuthenticationPackage(lsaHandle,
					  packageId,
					  DecryptRequest,
					  DecryptReqLength,
					  (PVOID *)&OutBuf,
					  &OutLen,
					  &SubStatus);

    if (!SEC_SUCCESS(Status) || !SEC_SUCCESS(SubStatus)) {
	fprintf(stderr, "Decrypt: LsaCallAuthPackage failed: %s\n",
		get_error_text(SubStatus));
	exit(4);
    }

    if ((long)OutLen > *outlen) {
	fprintf(stderr, "Decrypt: outbuf too small (%d < %d)\n",
		OutLen, *outlen);
	*outlen = OutLen;
	retval = -1;
    }
    else if (outdata) {
	*outlen = OutLen;
	memcpy(outdata, OutBuf, OutLen);
    }
    
    LsaFreeReturnBuffer(OutBuf);

    return(retval);
}


void
print_key_data(
    int n_key_data,
    krb5_key_data *kd
)
{
    int n, i;
    krb5_keyblock key;
    krb5_octet *ptr;
    int tmplen;
    
    for (n = 0; n < n_key_data; n++) {
	ptr = kd[n].key_data_contents[0];
	key.enctype = kd[n].key_data_type[0];
	key.length = *(short *)ptr;
	ptr += 2;

	printf("\tkey[%d]: ver=%d kvno=%d\n",
	       n, kd[n].key_data_ver,
	       kd[n].key_data_kvno);
	printf("\t\tetype=%s [%d]: ", 
	       etype_string(key.enctype),
	       key.enctype);
	printf(" keylength=%d ", key.length);

	printf("\n\t\tEncrypted key: ");
	for (i = 0; i < kd[n].key_data_length[0]; i++)
	    printf(" %02x", kd[n].key_data_contents[0][i]);

	if (mkey.length) {
	    // First get the length needed
	    decrypt_key(&mkey, ptr, (kd[n].key_data_length[0] - 2),
			NULL, &tmplen);
	    key.contents = (krb5_octet *)malloc(tmplen);
	    assert(key.contents != 0);

	    // Now decrypt it
	    decrypt_key(&mkey, ptr, (kd[n].key_data_length[0] - 2),
			key.contents, &tmplen);

	    printf("\n\t\tDecrypted key: ");
	    for (i = 0; i < key.length; i++)
		printf(" %02x", key.contents[i]);
	}
	
	printf("\n\t\tsalt=");
	print_salt_string(kd[n].key_data_type[1], kd[n].key_data_length[1],
			  (char *)kd[n].key_data_contents[1]);
    }
}


int 
ds_put_principal(
    IADs *ds,
    krb5_db_entry &dbentry
    )
{
    // Check for accounts that we can't import
    if ((strncmp(dbentry.princ, "K/M", 3) == 0) ||
	(strncmp(dbentry.princ, "krbtgt/", 7) == 0) ||
	(strncmp(dbentry.princ, "kadmin/", 7) == 0)) {

	return -1;
    }
    
    char *cp;
    char *SAMName = StrDupA(dbentry.princ);
    
    // Zap the realm
    if (cp = strrchr(SAMName, '@'))
	*cp = '\0';
    
    // Check if this princ has an instance - likely SPN
    if (cp = strchr(SAMName, '/')) {
	// We don't do anything with SPN's right now
	return (-1);
    }

    printf(add_princ_fmt, SAMName);
    
    // Search for the entry in the domain

    // If this is to be an SPN; create the base account
    // (or use an existing one)

    // Now create the user

    return 0;
}


/*
 * Read a string of bytes while counting the number of lines passed.
 */
static int
read_string(
    FILE	*f,
    char	*buf,
    int		len,
    int		*lp
)
{
    int c;
    int i, retval;

    retval = 0;
    for (i=0; i<len; i++) {
	c = fgetc(f);
	if (c < 0) {
	    retval = 1;
	    break;
	}
	if (c == '\n')
	    (*lp)++;
	buf[i] = (char) c;
    }
    buf[len] = '\0';
    return(retval);
}

/*
 * Read a string of two character representations of bytes.
 */
static int
read_octet_string(
    FILE	*f,
    krb5_octet	*buf,
    int		len
)
{
    int c;
    int i, retval;

    retval = 0;
    for (i=0; i<len; i++) {
	if (fscanf(f, "%02x", &c) != 1) {
	    retval = 1;
	    break;
	}
	buf[i] = (krb5_octet) c;
    }
    return(retval);
}

/*
 * Find the end of an old format record.
 */
static void
find_record_end(
    FILE	*f,
    const char	*fn,
    int		lineno
)
{
    int	ch;

    if (((ch = fgetc(f)) != ';') || ((ch = fgetc(f)) != '\n')) {
	fprintf(stderr, trash_end_fmt, fn, lineno);
	while (ch != '\n') {
	    putc(ch, stderr);
	    ch = fgetc(f);
	}
	putc(ch, stderr);
    }
}

/*
 * process_k5beta6_record()	- Handle a dump record in krb5b6 format.
 *
 * Returns -1 for end of file, 0 for success and 1 for failure.
 */
static int
process_k5beta6_record(
    const char		*fname,
    IADs 	*ds,
    FILE		*filep,
    int			verbose,
    int			*linenop
)
{
    int			retval;
    krb5_db_entry	dbentry;
    krb5_int32		t1, t2, t3, t4, t5, t6, t7, t8, t9;
    int			nread;
    int			error;
    int			i, j;
    char		*name;
    krb5_key_data	*kp, *kdatap;
    krb5_tl_data	**tlp, *tl;
    krb5_octet 		*op;
    krb5_error_code	kret;
    const char		*try2read;

    try2read = (char *) NULL;
    memset((char *) &dbentry, 0, sizeof(dbentry));
    (*linenop)++;
    retval = 1;
    name = (char *) NULL;
    kp = (krb5_key_data *) NULL;
    op = (krb5_octet *) NULL;
    error = 0;
    kret = 0;
    nread = fscanf(filep, "%d\t%d\t%d\t%d\t%d\t", &t1, &t2, &t3, &t4, &t5);
    if (nread == 5) {
	/* Get memory for flattened principal name */
	if (!(name = (char *) malloc((size_t) t2 + 1)))
	    error++;

	/* Get memory for and form tagged data linked list */
	tlp = &dbentry.tl_data;
	for (i=0; i<t3; i++) {
	    if ((*tlp = (krb5_tl_data *) malloc(sizeof(krb5_tl_data)))) {
		memset(*tlp, 0, sizeof(krb5_tl_data));
		tlp = &((*tlp)->tl_data_next);
		dbentry.n_tl_data++;
	    }
	    else {
		error++;
		break;
	    }
	}

	/* Get memory for key list */
	if (t4 && !(kp = (krb5_key_data *) malloc((size_t)
						  (t4*sizeof(krb5_key_data)))))
	    error++;

	/* Get memory for extra data */
	if (t5 && !(op = (krb5_octet *) malloc((size_t) t5)))
	    error++;

	if (!error) {
	    dbentry.len = (krb5_int16)t1;
	    dbentry.n_key_data = (krb5_int16)t4;
	    dbentry.e_length = (krb5_int16)t5;
	    if (kp) {
		memset(kp, 0, (size_t) (t4*sizeof(krb5_key_data)));
		dbentry.key_data = kp;
		kp = (krb5_key_data *) NULL;
	    }
	    if (op) {
		memset(op, 0, (size_t) t5);
		dbentry.e_data = op;
		op = (krb5_octet *) NULL;
	    }

	    /* Read in and parse the principal name */
	    if (!read_string(filep, name, t2, linenop)) {

		dbentry.princ = StrDupA(name);
		
		/* Get the fixed principal attributes */
		nread = fscanf(filep, "%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t",
			       &t2, &t3, &t4, &t5, &t6, &t7, &t8, &t9);
		if (nread == 8) {
		    dbentry.attributes = (krb5_flags) t2;
		    dbentry.max_life = (krb5_deltat) t3;
		    dbentry.max_renewable_life = (krb5_deltat) t4;
		    dbentry.expiration = (krb5_timestamp) t5;
		    dbentry.pw_expiration = (krb5_timestamp) t6;
		    dbentry.last_success = (krb5_timestamp) t7;
		    dbentry.last_failed = (krb5_timestamp) t8;
		    dbentry.fail_auth_count = (krb5_kvno) t9;
		} else {
		    try2read = read_nint_data;
		    error++;
		}

		/*
		 * Get the tagged data.
		 *
		 * Really, this code ought to discard tl data types
		 * that it knows are special to the current version
		 * and were not supported in the previous version.
		 * But it's a pain to implement that here, and doing
		 * it at dump time has almost as good an effect, so
		 * that's what I did.  [krb5-admin/89/
		 */
		if (!error && dbentry.n_tl_data) {
		    for (tl = dbentry.tl_data; tl; tl = tl->tl_data_next) {
			nread = fscanf(filep, "%d\t%d\t", &t1, &t2);
			if (nread == 2) {
			    tl->tl_data_type = (krb5_int16) t1;
			    tl->tl_data_length = (krb5_int16) t2;
			    if (tl->tl_data_length) {
				if (!(tl->tl_data_contents =
				      (krb5_octet *) malloc((size_t) t2+1)) ||
				    read_octet_string(filep,
						      tl->tl_data_contents,
						      t2)) {
				    try2read = read_tcontents;
				    error++;
				    break;
				}
			    }
			    else {
				/* Should be a null field */
				nread = fscanf(filep, "%d", &t9);
				if ((nread != 1) || (t9 != -1)) {
				    error++;
				    try2read = read_tcontents;
				    break;
				}
			    }
			}
			else {
			    try2read = read_ttypelen;
			    error++;
			    break;
			}
		    }
		}

		/* Get the key data */
		if (!error && dbentry.n_key_data) {
		    for (i=0; !error && (i<dbentry.n_key_data); i++) {
			kdatap = &dbentry.key_data[i];
			nread = fscanf(filep, "%d\t%d\t", &t1, &t2);
			if (nread == 2) {
			    kdatap->key_data_ver = (krb5_int16) t1;
			    kdatap->key_data_kvno = (krb5_int16) t2;

			    for (j=0; j<t1; j++) {
				nread = fscanf(filep, "%d\t%d\t", &t3, &t4);
				if (nread == 2) {
				    kdatap->key_data_type[j] = (krb5_int16)t3;
				    kdatap->key_data_length[j] = (krb5_int16)t4;
				    if (t4) {
					if (!(kdatap->key_data_contents[j] =
					      (krb5_octet *)
					      malloc((size_t) t4+1)) ||
					    read_octet_string(filep,
							      kdatap->key_data_contents[j],
							      t4)) {
					    try2read = read_kcontents;
					    error++;
					    break;
					}
				    }
				    else {
					/* Should be a null field */
					nread = fscanf(filep, "%d", &t9);
					if ((nread != 1) || (t9 != -1)) {
					    error++;
					    try2read = read_kcontents;
					    break;
					}
				    }
				}
				else {
				    try2read = read_ktypelen;
				    error++;
				    break;
				}
			    }
			}
		    }
		}

		/* Get the extra data */
		if (!error && dbentry.e_length) {
		    if (read_octet_string(filep,
					  dbentry.e_data,
					  (int) dbentry.e_length)) {
			try2read = read_econtents;
			error++;
		    }
		}
		else {
		    nread = fscanf(filep, "%d", &t9);
		    if ((nread != 1) || (t9 != -1)) {
			error++;
			try2read = read_econtents;
		    }
		}

		/* Finally, find the end of the record. */
		if (!error)
		    find_record_end(filep, fname, *linenop);

		/*
		 * We have either read in all the data or choked.
		 */
		if (!error) {
		    retval = 0;
		    if (verbose == 2) {
			printf("%s\n", dbentry.princ);
			printf("\tattr=0x%x\n", dbentry.attributes);
			printf("\tmax_life=%d, max_renewable_life=%d\n",
			       dbentry.max_life, dbentry.max_renewable_life);
			printf("\texpiration=%d, pw_exp=%d\n",
			       dbentry.expiration, dbentry.pw_expiration);
			printf("\te_length=%d n_tl_data=%d, n_key_data=%d\n",
			       dbentry.e_length, dbentry.n_tl_data,
			       dbentry.n_key_data);
			print_tl_data(dbentry.n_tl_data, dbentry.tl_data);
			print_key_data(dbentry.n_key_data, dbentry.key_data);
		    }
		    
		    if ((kret = ds_put_principal(ds,
						 dbentry))) {
			fprintf(stderr, store_err_fmt,
				fname, *linenop,
				name, ""/*error_message(kret)*/);
		    }
		    else
		    {
			retval = 0;
		    }
		}
		else {
		    fprintf(stderr, read_err_fmt, fname, *linenop, try2read);
		}
	    }
	    else {
		if (kret)
		    fprintf(stderr, parse_err_fmt,
			    fname, *linenop, name, ""/*error_message(kret)*/);
		else
		    fprintf(stderr, no_mem_fmt, fname, *linenop);
	    }
	}
	else {
	    fprintf(stderr, rhead_err_fmt, fname, *linenop);
	}

	if (op)
	    free(op);
	if (kp)
	    free(kp);
	if (name)
	    free(name);
	if (dbentry.princ)
	    free(dbentry.princ);
    }
    else {
	if (nread == EOF)
	    retval = -1;
    }
    return(retval);
}

int process_k5beta7_policy(
    const char		*fname,
    IADs 	*ds,
    FILE		*filep,
    int			verbose,
    int			*linenop,
    void *pol_db
)
{
    char namebuf[1024];
    int nread;
    struct krb5_policy {
	char *name;
	int pw_min_life;
	int pw_max_life;
	int pw_min_length;
	int pw_min_classes;
	int pw_history_num;
	int policy_refcnt;
    } rec;
    
    (*linenop)++;
    rec.name = namebuf;

    nread = fscanf(filep, "%1024s\t%d\t%d\t%d\t%d\t%d\t%d", rec.name,
		   &rec.pw_min_life, &rec.pw_max_life,
		   &rec.pw_min_length, &rec.pw_min_classes,
		   &rec.pw_history_num, &rec.policy_refcnt);
    if (nread == EOF)
	 return -1;
    else if (nread != 7) {
	 fprintf(stderr, "cannot parse policy on line %d (%d read)\n",
		 *linenop, nread);
	 return 1;
    }

#if 0
    if (ret = osa_adb_create_policy(pol_db, &rec)) {
	 if (ret == OSA_ADB_DUP &&
	     (ret = osa_adb_put_policy(pol_db, &rec))) {
	      fprintf(stderr, "cannot create policy on line %d: %s\n",
		      *linenop, error_message(ret));
	      return 1;
	 }
    }
#else
    fprintf(stderr, "Policy %s : min_life=%d max_life=%d min_len=%d min_classes=%d histnum=%d refcnt=%d\n",
	    rec.name,
	    rec.pw_min_life, rec.pw_max_life,
	    rec.pw_min_length, rec.pw_min_classes,
	    rec.pw_history_num, rec.policy_refcnt);
#endif
    if (verbose)
	 fprintf(stderr, "created policy %s - \n", rec.name);
    
    return 0;
}

/*
 * process_k5beta7_record()	- Handle a dump record in krb5b6 format.
 *
 * Returns -1 for end of file, 0 for success and 1 for failure.
 */
static int
process_k5beta7_record(
    const char		*fname,
    IADs 	*ds,
    FILE		*filep,
    int			verbose,
    int			*linenop,
    void *pol_db
)
{
     int nread;
     char rectype[100];

     nread = fscanf(filep, "%100s\t", rectype);
     if (nread == EOF)
	  return -1;
     else if (nread != 1)
	  return 1;
     if (strcmp(rectype, "princ") == 0)
	  process_k5beta6_record(fname, ds, filep, verbose,
				 linenop);
     else if (strcmp(rectype, "policy") == 0)
	  process_k5beta7_policy(fname, ds, filep, verbose,
				 linenop, pol_db);
     else {
	  fprintf(stderr, "unknown record type \"%s\" on line %d\n",
		  rectype, *linenop);
	  return 1;
     }

     return 0;
}

/*
 * restore_dump()	- Restore the database from a standard dump file.
 */
static int
restore_dump(
    const char		*programname,
    const char		*dumpfile,
    IADs 	*ds,
    FILE		*f,
    FILE		*k,
    int			verbose
)
{
    int		error;	
    int		lineno;
    char	buf[2*sizeof(k5_dump_header)];
    short	enctype;
    int		i;
    int pol_db;
    
    if (k) {
	/*
     * Read the master key file
     */
	if (fread(&enctype, 2, 1, k) != 1) {
	    perror("Unable to read master key file");
	    exit(2);
	}
	mkey.enctype = enctype;
	if (fread((krb5_pointer) &mkey.length,
		  sizeof(mkey.length), 1, k) != 1) {
	    perror("Cannot read master key length");
	    exit(2);
	}
	if (!mkey.length || mkey.length < 0) {
	    fprintf(stderr, "Bad stored master key.\n");
	    exit(2);
	}
	if (!(mkey.contents = (krb5_octet *)malloc(mkey.length))) {
	    fprintf(stderr, "Read mkey memory allocation failure.\n");
	    exit(2);
	}
	if (fread(mkey.contents,
		  sizeof(mkey.contents[0]), mkey.length, k) != mkey.length) {
	    memset(mkey.contents, 0, mkey.length);
	    perror("Cannot read master key");
	    exit(2);
	}
	fclose(k);

	printf("Master key: etype=%s [%d]: ",
	       etype_string(mkey.enctype), mkey.enctype);
	for (i = 0; i < mkey.length; i++)
	    printf(" %02x", mkey.contents[i]);
	printf("\n");
    }
    
    /*
     * Get/check the header.
     */
    error = 0;
    fgets(buf, sizeof(buf), f);
    if (!strcmp(buf, k5_dump_header)) {
	lineno = 1;
	/*
	 * Process the records.
	 */
	while (!(error = process_k5beta7_record(dumpfile,
						ds,
						f,
						verbose,
						&lineno, (void *)&pol_db)))
	    ;
	if (error != -1)
	    fprintf(stderr, err_line_fmt, programname, lineno, dumpfile);
	else
	    error = 0;

	/*
	 * Close the input file.
	 */
	if (f != stdin)
	    fclose(f);
    }
    else {
	printf("buf=\"%s\"\n", buf);
	fprintf(stderr, head_bad_fmt, programname, dumpfile);
	error++;
    }
    return(error);
}

void __cdecl
main(int argc, char *argv[])
{
    FILE *kdbFile, *mkeyFile = NULL;
    int retval;
    IADs *pDS;
    int n = 1;
    int	verbose = 1;
    HRESULT hr;
    
    if (argc < 2 || argc > 5) {
	printf("Usage: %s [-m <mkey>] <dumpfile>\n", argv[0]);
	exit(1);
    }

    if (argc == 4) {
	if (strcmp(argv[1], "-m") == 0) {
	    mkeyFile = fopen(argv[2], "rb");
	    if (!mkeyFile) {
		perror("Unable to open master key file");
		exit(1);
	    }
	    n = 3;
	}
    }
    
    kdbFile = fopen(argv[n], "rb");
    if (!kdbFile) {
	perror("Unable to open dump file");
	exit(1);
    }

    // need to open DS and pass that in
    hr = CoInitialize(NULL);
    if (FAILED(hr)) {
	fprintf(stderr, "Unable to init com - %s\n", get_error_text(hr));
	exit(2);
    }
    
    hr = ADsGetObject(TEXT("LDAP://rootDSE"), IID_IADs,
		      (void **)&pDS);
    if (FAILED(hr)) {
	fprintf(stderr, "Unable to bind to DS - %s\n", get_error_text(hr));
	exit(2);
    }
    
    retval = restore_dump(argv[0], argv[1], pDS, kdbFile, mkeyFile, verbose);

    fclose(kdbFile);
    exit(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\kerbconf\kerbconf.h ===
#define STRDEF(s, d) (s && (s)[0] != '\0')?(s):(d)

#define LIST_HEAD(name, type)						\
struct name {								\
	struct type *lh_first;	/* first element */			\
}

#define LIST_ENTRY(type)						\
struct {								\
	struct type *le_next;	/* next element */			\
	struct type **le_prev;	/* address of previous next element */	\
}

#define	LIST_INIT(head) {						\
	(head)->lh_first = NULL;					\
}

#define LIST_INSERT_HEAD(head, elm, field) {				\
	if (((elm)->field.le_next = (head)->lh_first) != NULL)		\
		(head)->lh_first->field.le_prev = &(elm)->field.le_next;\
	(head)->lh_first = (elm);					\
	(elm)->field.le_prev = &(head)->lh_first;			\
}

#define LIST_REMOVE(elm, field) {					\
	if ((elm)->field.le_next != NULL)				\
		(elm)->field.le_next->field.le_prev = 			\
		    (elm)->field.le_prev;				\
	*(elm)->field.le_prev = (elm)->field.le_next;			\
}

struct name_list {
    LIST_ENTRY(name_list) list;
    LPTSTR name;
};
typedef struct name_list name_list_t;
#define NewNameList()							\
		(name_list_t *)calloc(sizeof(name_list_t), 1)

struct krb5_realm {
    LIST_ENTRY(krb5_realm) list;
    LIST_HEAD(kdc, name_list) kdc;
    LIST_HEAD(kpasswd, name_list) kpasswd;
    LIST_HEAD(altname, name_list) altname;
    DWORD realm_flags;
    DWORD ap_req_chksum;
    DWORD preauth_type;
    TCHAR name[1];
};
typedef struct krb5_realm krb5_realm_t;
#define NewRealm(l) (krb5_realm_t *)calloc(sizeof(krb5_realm_t) + (l*sizeof(TCHAR)), 1)

struct krb5_rgy {
    LIST_HEAD(realms, krb5_realm) realms;
};
typedef struct krb5_rgy krb5_rgy_t;

struct enctype_entry 
{
    const struct enctype_lookup_entry *ktt;
    BOOL used;
};
typedef struct enctype_entry enctype_entry_t;


#define REGKEY TEXT("system\\currentcontrolset\\control\\lsa\\kerberos")

#ifndef REG_SZ
#define REG_SZ		0x0001
#endif

#ifndef REG_BINARY
#define REG_BINARY	0x0003
#endif

#ifndef REG_DWORD
#define REG_DWORD       0x0004
#endif

#ifndef REG_MULTI_SZ
#define REG_MULTI_SZ    0x0007
#endif

#ifndef HKEY_LOCAL_MACHINE
#define HKEY_LOCAL_MACHINE	0x80000002
#define HKEY_DYN_DATA		0x80000006
#endif

UINT Krb5NdiCreate(void);
UINT Krb5NdiInstall(krb5_rgy_t*);
UINT Krb5NdiDestroy(krb5_rgy_t*);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\kerbconf\kerbconfres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by kerbconf.rc
//
#define IDD_REALM_ADD                   104
#define IDB_CHECK                       106
#define IDD_ADD_DOMAIN                  107
#define IDB_NOCHECK                     111
#define IDD_LIB_DEFAULTS                1001
#define IDD_REALMS                      1002
#define IDD_DOMAIN_REALM                1003
#define IDC_CKSUM_TYPES                 1005
#define IDC_ENC_TYPES                   1006
#define IDC_DCE_COMPAT                  1007
#define IDC_CCACHE_1                    1008
#define IDC_CCACHE_2                    1009
#define IDC_CCACHE_3                    1010
#define IDC_CCACHE_4                    1011
#define IDC_REALM_ADD                   1012
#define IDC_REALM_REMOVE                1013
#define IDC_REALM_KDC                   1014
#define IDC_REALM_ADMIN                 1015
#define IDC_REALM_K4_CONVERT            1016
#define IDC_REALM_ALT_NAMES             1016
#define IDC_REALM_DEF_DOMAIN            1017
#define IDC_REALMS                      1018
#define IDC_NEW_REALM                   1019
#define IDC_DEFAULT_REALM               1020
#define IDC_DOMAINS                     1021
#define IDC_DOMAIN_ADD                  1022
#define IDC_DOMAIN_REMOVE               1023
#define IDC_TKT_ENCTYPE                 1024
#define IDC_TGS_ENCTYPE                 1025
#define IDC_KDC_CKSUM                   1027
#define IDC_AP_CKSUM                    1028
#define IDC_SAFE_CKSUM                  1029
#define IDC_CLOCK_SKEW                  1031
#define IDC_CKSUM_SAFE                  1032
#define IDC_CKSUM_AP                    1033
#define IDC_CKSUM_KDC                   1034
#define IDC_CLOCK_SKEW_SPIN             1035
#define IDC_KDC_TIMESYNC                1036
#define IDC_DOMAIN_REALM                1037
#define IDC_ADD_DOM_HOST                1038
#define IDC_ADD_DOM_REALM               1039
#define IDC_ADDRREQ                     1041
#define IDC_KDC_TCP                     1042
#define IDC_CHKSUM                      1043
#define IDC_KDC_DELEG                   1044
#define IDC_KDC_CANONICALIZE            1045
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        112
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1044
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\kerbconf\kerbconf.c ===
/*
 * Registry keys for compat:
 *	HKLM\System\CurrentControlSet\Control\Lsa\Kerberos\Domains
 *	Keys:
 *		<Realm>
 *		Values:
 *			REG_MULTI_SZ KdcNames
 *				Names of KDCs for realm
 *			REG_MULTI_SZ KpasswdNames
 *				Names of Kpasswd servers for realm
 *			REG_MULTI_SZ AlternateDomainNames
 *				Other names for realm (aliases)
 *			REG_DWORD RealmFlags
 *				Send address = 1
 *				TCP Supported = 2
 *				Delegate ok = 4
 *			REG_DWORD ApReqChecksumType
 *				Default AP-REQ checksum type for this realm
 *			REG_DWORD PreAuthType
 *				Default preauth type for this realm
 *
 *	HKLM\System\CurrentControlSet\Control\Lsa\Kerberos\UserList
 *	Each value represents a Kerberos principal to be mapped to
 *	a local user.
 *	Values:
 *		<principal name> :  <local user>
 *			Specific principal to this local user
 *		<domain name> :  <local user>
 *			All users in this domain to this local user
 *		'*' : <local user>
 *			All users to this local user
 *		'*' : '*'
 *			All users to a corresponding local user by name
 *
 *	HKLM\System\CurrentControlSet\Control\Lsa\Kerberos
 *	Values:
 *		REG_DWORD SkewTime (5 min)
 *			Clock skew time
 *		REG_DWORD MaxPacketSize (4000)
 *			KerbGlobalMaxDatagramSize
 *		REG_DWORD StartupTime (120 sec)
 *		REG_DWORD KdcWaitTime (5 sec)
 *		REG_DWORD KdcBackoffTime (5 sec)
 *		REG_DWORD KdcSendRetries (3)
 *		REG_DWORD UseSidCache (False)
 *		REG_DWORD LogLevel (o)
 *			KerbGlobalLoggingLevel
 *		REG_DWORD DefaultEncryptionType (RC4_HMAC)
 *			KerbGlobalDefaultPreauthEtype - Use this etype
 *				for preauth data
 *		REG_DWORD FarKdcTimeout (10 min)
 *		REG_DWORD StronglyEncryptDatagram (False)
 *			KerbGlobalUseStrongEncryptionForDatagram
 *		REG_DWORD MaxReferralCount (6)
 *		REG_DWORD SupportNewPkinit (True)
 */
//#define UNICODE
//#define _UNICODE
#define STRICT
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <memory.h>
#include <stdlib.h>
#include <string.h>
#define ERR_NDI_LOW_MEM ERROR_NOT_ENOUGH_MEMORY
#define OK ERROR_SUCCESS
#include <commctrl.h>
//#include <winnetwk.h>
#include <stdarg.h>
#define SECURITY_WIN32
#include <security.h>
//#include <ntsecapi.h>
#include <wincrypt.h>
#include <kerbcon.h>
#include <kerbcomm.h>
#include <secpkg.h>
#include <kerbdefs.h>
#include <mitutil.h>

#include "kerbconf.h"
#include "kerbconfres.h"

HINSTANCE hInstance;
krb5_rgy_t *rgy;
LPTSTR default_domain;

BOOL CALLBACK Krb5NdiRealmsProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK AddRealmProc(HWND, UINT, WPARAM, LPARAM);

#define Message(s) \
	MessageBox(NULL, s, TEXT("Error"), MB_OK)

#ifdef DBG
#define DPRINTF(s) dprintf s

int debug = 0;

void dprintf(const TCHAR *fmt, ...)
{
    static TCHAR szTemp[512];
    va_list ap;
    
    va_start (ap, fmt);
    wvsprintf(szTemp, fmt, ap);
    OutputDebugString(szTemp);
    if (debug)
	MessageBox(NULL, szTemp, TEXT("Debug"), MB_OK);
    va_end (ap);
}
#else
#define DPRINTF(s)
#endif

#define PFREE(p) \
    if ((p)) { \
	free((p)); \
       (p) = NULL; \
    }
    

void
FreeRealm(krb5_realm_t *rp)
{
    name_list_t *np, *cp;
    
    np = rp->kdc.lh_first; 
    while(np) {
	cp = np;
	np = np->list.le_next;
	if (cp->name)
	    free(cp->name);
	free(cp);
    }
    np = rp->kpasswd.lh_first; 
    while(np) {
	cp = np;
	np = np->list.le_next;
	if (cp->name)
	    free(cp->name);
	free(cp);
    }
    np = rp->altname.lh_first; 
    while(np) {
	cp = np;
	np = np->list.le_next;
	if (cp->name)
	    free(cp->name);
	free(cp);
    }
    free(rp);
}

void
FreeRgy(krb5_rgy_t *rgy)
{
    krb5_realm_t *rp, *crp;
    
    if (rgy) {
	rp = rgy->realms.lh_first;
	while(rp) {
	    crp = rp;
	    rp = rp->list.le_next;	
	    FreeRealm(crp);
	}
	free(rgy);
    }
}

DWORD
RegGetInt(const HKEY hKey, LPCTSTR value)
{
    DWORD retCode;
    DWORD dwType;
    DWORD dataLen;
    DWORD keyData;
    
    dataLen = sizeof(keyData);
    retCode = RegQueryValueEx(hKey, value, 0,
				&dwType, (LPBYTE)&keyData, &dataLen);
    if (retCode == ERROR_SUCCESS &&
	dwType == REG_DWORD) {
	return(keyData);
    }
    return((DWORD)-1);
}

DWORD
RegSetInt(LPCTSTR key, const DWORD val)
{
    HKEY hKey;
    DWORD retCode = (DWORD)-1;

    retCode = RegCreateKey(HKEY_LOCAL_MACHINE,
			     REGKEY,
			     &hKey);
    if (retCode == ERROR_SUCCESS) {
	retCode = RegSetValueEx(hKey, key, 0,
				REG_DWORD, (LPBYTE)&val, sizeof(val));
	if (retCode == ERROR_SUCCESS) {
	    RegCloseKey(hKey);
	    return(0);
	}
    }

    RegCloseKey(hKey);
    return(retCode);
}

LPTSTR
RegGetStr(const HKEY hKey, LPCTSTR value)
{
    DWORD retCode;
    DWORD dwType;
    DWORD dataLen;
    LPBYTE keyData = NULL;

    dataLen = 0;
    retCode = RegQueryValueEx(hKey, value, 0,
				&dwType, (LPBYTE)NULL, &dataLen);
    if (retCode == ERROR_SUCCESS) {
	keyData = malloc(dataLen);
	if (!keyData)
	    return(NULL);
	
	retCode = RegQueryValueEx(hKey, value, 0,
				    &dwType, keyData, &dataLen);
	if (retCode == ERROR_SUCCESS) {
	    return((LPTSTR)keyData);
	}
    }
    if (keyData)
	free(keyData);
    return(NULL);
}

DWORD
RegSetStr(LPCTSTR key, LPCTSTR val, INT len)
{
    HKEY hKey;
    DWORD retCode = (DWORD)-1;

    if (len == 0)
	len = lstrlen(val) + 1;
    retCode = RegCreateKey(HKEY_LOCAL_MACHINE,
			     REGKEY,
			     &hKey);
    if (retCode == ERROR_SUCCESS) {
	retCode = RegSetValueEx(hKey, key, 0,
				((lstrlen(val)+1) != len)?
				REG_MULTI_SZ:REG_SZ,
				  (LPBYTE)val, len);
	if (retCode == ERROR_SUCCESS) {
	    RegCloseKey(hKey);
	    return(0);
	}
    }

    RegCloseKey(hKey);
    return(retCode);
}

DWORD
RegDelete(LPCTSTR key)
{
    HKEY hKey;
    DWORD retCode;

    retCode = RegOpenKey(HKEY_LOCAL_MACHINE,
			   REGKEY,
			   &hKey);
    if (retCode == ERROR_SUCCESS)
	retCode = RegDeleteValue(hKey, key);

    RegCloseKey(hKey);
    return(retCode);
}

LPTSTR
lstrdup(LPCTSTR s)
{
    LPTSTR sp;

    sp = malloc(lstrlen(s)*sizeof(TCHAR));
    if (sp) {
	lstrcpy(sp, s);
    }
    return sp;
}


// Read in krb5 conf properties and attach to ndi object
UINT
Krb5NdiCreate(void)
{
    LPTSTR pStr, key;
    HKEY hKey, hKeyRealm;
    DWORD retCode;
    DWORD i, dwVal;
    static TCHAR FAR keyValue[255], valData[255];
    DWORD keyLen;
    PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;
    
    rgy = (krb5_rgy_t *)malloc(sizeof(krb5_rgy_t));
    if (!rgy)
	return ERR_NDI_LOW_MEM;
    memset(rgy, 0, sizeof(krb5_rgy_t));

    retCode = RegOpenKey(HKEY_LOCAL_MACHINE,
			 KERB_DOMAINS_KEY,
			 &hKey);
    if (retCode == ERROR_SUCCESS) {
	krb5_realm_t *pRealm;
	name_list_t *pName;
	for (i = 0; retCode == ERROR_SUCCESS; i++) {
	    keyLen = sizeof(keyValue);
	    retCode = RegEnumKey(hKey, i, keyValue, keyLen);
	    if (retCode != ERROR_SUCCESS)
		continue;
	    pRealm = NewRealm(lstrlen(keyValue)+1);
	    if (!pRealm) {
		RegCloseKey(hKey);
		return ERR_NDI_LOW_MEM;
	    }
	    lstrcpy((LPTSTR)&pRealm->name, keyValue);
	    key = (LPTSTR)malloc(lstrlen(REGKEY)+10+lstrlen(keyValue));
	    if (!key) {
		RegCloseKey(hKey);
		return ERR_NDI_LOW_MEM;
	    }
	    lstrcpy(key, KERB_DOMAINS_KEY TEXT("\\"));
	    lstrcat((LPTSTR)key, keyValue);
	    retCode = RegOpenKey(HKEY_LOCAL_MACHINE,
				   key,
				   &hKeyRealm);
	    if (retCode == ERROR_SUCCESS) {
		pStr = RegGetStr(hKeyRealm, KERB_DOMAIN_KDC_NAMES_VALUE);
		while (pStr && *pStr) {
		    pName = NewNameList();
		    if (!pName) {
			RegCloseKey(hKeyRealm);
			RegCloseKey(hKey);
			return ERR_NDI_LOW_MEM;
		    }
		    pName->name = lstrdup(pStr);
		    LIST_INSERT_HEAD(&pRealm->kdc, pName, list);
		    pStr += lstrlen(pStr)+1;
		}
		pStr = RegGetStr(hKeyRealm, KERB_DOMAIN_KPASSWD_NAMES_VALUE);
		while (pStr && *pStr) {
		    pName = NewNameList();
		    if (!pName) {
			RegCloseKey(hKeyRealm);
			RegCloseKey(hKey);
			return ERR_NDI_LOW_MEM;
		    }
		    pName->name = lstrdup(pStr);
		    LIST_INSERT_HEAD(&pRealm->kpasswd, pName, list);
		    pStr += lstrlen(pStr)+1;
		}
		pStr = RegGetStr(hKeyRealm, KERB_DOMAIN_ALT_NAMES_VALUE);
		while (pStr && *pStr) {
		    pName = NewNameList();
		    if (!pName) {
			RegCloseKey(hKeyRealm);
			RegCloseKey(hKey);
			return ERR_NDI_LOW_MEM;
		    }
		    pName->name = lstrdup(pStr);
		    LIST_INSERT_HEAD(&pRealm->altname, pName, list);
		    pStr += lstrlen(pStr)+1;
		}
		dwVal = RegGetInt(hKeyRealm, KERB_DOMAIN_FLAGS_VALUE);
		if (dwVal == -1) {
		    dwVal = 0;
		}
		pRealm->realm_flags = dwVal;
		dwVal = RegGetInt(hKeyRealm, KERB_DOMAIN_AP_REQ_CSUM_VALUE);
		if (dwVal == -1) {
		    dwVal = KERB_DEFAULT_AP_REQ_CSUM;
		}
		pRealm->ap_req_chksum = dwVal;
		dwVal = RegGetInt(hKeyRealm, KERB_DOMAIN_PREAUTH_VALUE);
		if (dwVal == -1) {
		    dwVal = KERB_DEFAULT_PREAUTH_TYPE;
		}
		pRealm->preauth_type = dwVal;
		RegCloseKey(hKeyRealm);
		free(key);
	    }
	    LIST_INSERT_HEAD(&rgy->realms, pRealm, list);
	}
	RegCloseKey(hKey);

	// 
    }
#if 1
    retCode = RegOpenKey(HKEY_LOCAL_MACHINE,
			 TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
			 &hKey);
    if (retCode == ERROR_SUCCESS) {
	default_domain = RegGetStr(hKey, TEXT("Domain"));
	RegCloseKey(hKey);
    }
#else
    retCode = LsaQueryInformationPolicy(
                LsaHandle,
                PolicyDnsDomainInformation,
                (PVOID *) &DnsDomainInfo
                );
    if (!NT_SUCCESS(retCode))
    {
        printf("Failed to query dns domain info: 0x%x\n",Status);
        goto Cleanup;
    }

    if ( DnsDomainInfo->DnsDomainName.Length == 0 ) {

        printf("Machine is not configured to log on to an external KDC.  Probably a workgroup member\n");
        goto Cleanup;

    } else { // nonempty dns domain, but no sid.  Assume we're in an RFC1510 domain.

      printf( "default realm = %wZ ",
		&DnsDomainInfo->DnsDomainName );

      if ( DnsDomainInfo->Sid != NULL ) {

	printf( "(NT Domain)\n" );

      } else {

	printf( "(external)\n" );

      }

#endif    
    return OK;
}

/* Write out any conf parameters */

static void
SaveRealm(krb5_realm_t *rp)
{
    name_list_t *np;
    
    DPRINTF((TEXT("\n%s: %s\n\t"), rp->name, KERB_DOMAIN_KDC_NAMES_VALUE));
    for (np = rp->kdc.lh_first; np; np = np->list.le_next) {
	DPRINTF((TEXT("%s "), np->name));
    }

    DPRINTF((TEXT("\n%s: %s\n\t"), rp->name, KERB_DOMAIN_KPASSWD_NAMES_VALUE));
    for (np = rp->kpasswd.lh_first; np; np = np->list.le_next) {
	DPRINTF((TEXT("%s "), np->name));
    }

    DPRINTF((TEXT("\n%s: %s\n\t"), rp->name, KERB_DOMAIN_ALT_NAMES_VALUE));
    for (np = rp->altname.lh_first; np; np = np->list.le_next) {
	DPRINTF((TEXT("%s "), np->name));
    }
    DPRINTF((TEXT("\n%s: 0x%x\n"), KERB_DOMAIN_FLAGS_VALUE,
	     rp->realm_flags));
    DPRINTF((TEXT("\n%s: 0x%x\n"), KERB_DOMAIN_AP_REQ_CSUM_VALUE,
	     rp->ap_req_chksum));
    DPRINTF((TEXT("\n%s: 0x%x\n"), KERB_DOMAIN_PREAUTH_VALUE,
	     rp->preauth_type));
}

UINT
Krb5NdiInstall(krb5_rgy_t *rgy)
{
    krb5_realm_t *rp;
    
    if (rgy) {
	DPRINTF((TEXT("Realms\n")));
	for (rp = rgy->realms.lh_first; rp; rp = rp->list.le_next) {
	    DPRINTF((TEXT("%s\n"), rp->name));
	    SaveRealm(rp);
	}
    }

    return OK;
}

/* Destroy any conf parameters */
UINT
Krb5NdiDestroy(krb5_rgy_t *rgy)
{
    FreeRgy(rgy);
    
    return OK;
}

void
ShowRealm(HWND hDlg)
{
    int idx;
    krb5_realm_t *pRealm;
    name_list_t *pNlist;
    
    SendDlgItemMessage(hDlg, IDC_REALM_KDC, CB_RESETCONTENT, 0, 0L);
    SendDlgItemMessage(hDlg, IDC_REALM_ADMIN, CB_RESETCONTENT, 0, 0L);
    SendDlgItemMessage(hDlg, IDC_REALM_ALT_NAMES, CB_RESETCONTENT, 0, 0L);
    SetDlgItemText(hDlg, IDC_REALM_DEF_DOMAIN, TEXT(""));

    idx = (int)SendDlgItemMessage(hDlg, IDC_REALMS, LB_GETCURSEL, 0, 0L);
    if (idx == LB_ERR)
	return;
    
    pRealm = (krb5_realm_t FAR *)SendDlgItemMessage(hDlg, IDC_REALMS,
						    LB_GETITEMDATA, idx, 0L);
    for (pNlist = pRealm->kdc.lh_first; pNlist; pNlist = pNlist->list.le_next) {
	idx = SendDlgItemMessage(hDlg, IDC_REALM_KDC, CB_ADDSTRING, 0,
			   (LPARAM)pNlist->name);
	SetDlgItemText(hDlg, IDC_REALM_KDC, pNlist->name);
	SendDlgItemMessage(hDlg, IDC_REALM_KDC, CB_SETITEMDATA, idx,
			   (LPARAM)(name_list_t FAR *)pNlist);
    }
    for (pNlist = pRealm->kpasswd.lh_first; pNlist; pNlist = pNlist->list.le_next) {
	idx = SendDlgItemMessage(hDlg, IDC_REALM_ADMIN, CB_ADDSTRING, 0,
			   (LPARAM)pNlist->name);
	SetDlgItemText(hDlg, IDC_REALM_ADMIN, pNlist->name);
	SendDlgItemMessage(hDlg, IDC_REALM_ADMIN, CB_SETITEMDATA, idx,
			   (LPARAM)(name_list_t FAR *)pNlist);
    }
    for (pNlist = pRealm->altname.lh_first; pNlist; pNlist = pNlist->list.le_next) {
	idx = SendDlgItemMessage(hDlg, IDC_REALM_ALT_NAMES, CB_ADDSTRING, 0,
			   (LPARAM)pNlist->name);
	SetDlgItemText(hDlg, IDC_REALM_ALT_NAMES, pNlist->name);
	SendDlgItemMessage(hDlg, IDC_REALM_ALT_NAMES, CB_SETITEMDATA, idx,
			   (LPARAM)(name_list_t FAR *)pNlist);
    }
    CheckDlgButton(hDlg, IDC_KDC_TCP,
		   (pRealm->realm_flags & KERB_MIT_REALM_TCP_SUPPORTED)?
		   BST_CHECKED:BST_UNCHECKED);
    CheckDlgButton(hDlg, IDC_ADDRREQ,
		   (pRealm->realm_flags & KERB_MIT_REALM_SEND_ADDRESS)?
		   BST_CHECKED:BST_UNCHECKED);
    CheckDlgButton(hDlg, IDC_KDC_DELEG,
		   (pRealm->realm_flags & KERB_MIT_REALM_TRUSTED_FOR_DELEGATION)?
		   BST_CHECKED:BST_UNCHECKED);
    CheckDlgButton(hDlg, IDC_KDC_CANONICALIZE,
		   (pRealm->realm_flags & KERB_MIT_REALM_DOES_CANONICALIZE)?
		   BST_CHECKED:BST_UNCHECKED);
    SetDlgItemInt(hDlg, IDC_CHKSUM, pRealm->ap_req_chksum, FALSE);
    SetDlgItemText(hDlg, IDC_REALM_DEF_DOMAIN,
		   STRDEF(default_domain, TEXT("")));
}

BOOL CALLBACK
AddRealmProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR realm_name[255];
    krb5_realm_t *pRealm;
    
    switch (message) {
    case WM_INITDIALOG:
	SetFocus(GetDlgItem(hDlg, IDC_NEW_REALM));
	return 0;

    case WM_COMMAND:
	switch (LOWORD(wParam)) {
	case IDOK:
	    GetDlgItemText(hDlg, IDC_NEW_REALM,
			   realm_name, sizeof(realm_name));
	    pRealm = NewRealm(lstrlen(realm_name));
	    if (pRealm)
		lstrcpy(pRealm->name, realm_name);
	    EndDialog(hDlg, (int)pRealm);
	    return TRUE;
	
	case IDCANCEL:
	    EndDialog(hDlg, 0);
	    return TRUE;
	}
	break;
    }
	
    return FALSE;
}

void
AddRealm(HWND hDlg, krb5_rgy_t *rgy)
{
    krb5_realm_t *pRealm;
    
    if (pRealm = (krb5_realm_t *) DialogBox(hInstance,
					    MAKEINTRESOURCE(IDD_REALM_ADD),
					    hDlg,
					    AddRealmProc)) {
	int idx;
	LIST_INSERT_HEAD(&rgy->realms, pRealm, list);
	idx = SendDlgItemMessage(hDlg, IDC_REALMS, LB_ADDSTRING, 0,
				 (LPARAM)(LPSTR)pRealm->name);
	SendDlgItemMessage(hDlg, IDC_REALMS, LB_SETITEMDATA, idx,
			   (LPARAM)(krb5_realm_t FAR *)pRealm);
	SendDlgItemMessage(hDlg, IDC_REALMS, LB_SETCURSEL, idx, 0L);
	ShowRealm(hDlg);
    }
}

void
RemoveRealm(HWND hDlg)
{
    TCHAR *msg;
    int idx;
    krb5_realm_t *pRealm;

    idx = (int) SendDlgItemMessage(hDlg, IDC_REALMS, LB_GETCURSEL, 0, 0L);
    pRealm = (krb5_realm_t FAR *)SendDlgItemMessage(hDlg, IDC_REALMS,
						    LB_GETITEMDATA, idx, 0L);
#define FMT TEXT("You are about to remove the realm \"%s\"\n\rDo you want to continue ?")
    msg = malloc(lstrlen(FMT) + lstrlen(pRealm->name));
    if (!msg)
	return;
    wsprintf(msg, FMT, pRealm->name);
#undef FMT
    if (MessageBox(hDlg, msg, TEXT("Confirm Delete"),
		   MB_YESNO|MB_ICONEXCLAMATION|MB_DEFBUTTON2|MB_SETFOREGROUND) == IDYES) {
	idx = SendDlgItemMessage(hDlg, IDC_REALMS, LB_DELETESTRING, idx, 0L);
	LIST_REMOVE(pRealm, list);
	FreeRealm(pRealm);
	SendDlgItemMessage(hDlg, IDC_REALMS, CB_SETCURSEL, 0, 0L);
	ShowRealm(hDlg);
    }
    free(msg);
}

BOOL CALLBACK
Krb5NdiRealmsProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static PROPSHEETPAGE *ps;
    krb5_realm_t *pRealm;
    
    switch (message) {
    case WM_INITDIALOG:
	for (pRealm = rgy->realms.lh_first; pRealm; pRealm = pRealm->list.le_next) {
	    int idx = SendDlgItemMessage(hDlg, IDC_REALMS, LB_ADDSTRING, 0,
					 (LPARAM)(LPSTR)pRealm->name);
	    SendDlgItemMessage(hDlg, IDC_REALMS, LB_SETITEMDATA, idx,
			       (LPARAM)(krb5_realm_t FAR *)pRealm);
	}
	SendDlgItemMessage(hDlg, IDC_REALMS, LB_SETCURSEL, 0, 0L);
	ShowRealm(hDlg);
	ps = (PROPSHEETPAGE *)lParam;
	return TRUE;

    case WM_COMMAND:
	switch (LOWORD(wParam)) {
        case IDC_REALMS:
	    switch (HIWORD(wParam)) {
	    case LBN_SELCHANGE:
		ShowRealm(hDlg);
		break;
            }
            return 0;
            /* NOTREACHED */

	case IDC_REALM_ADD:
	    AddRealm(hDlg, rgy);
	    break;
	    
	case IDC_REALM_REMOVE:
	    RemoveRealm(hDlg);
	    break;
	}
	break;
	    
    case WM_NOTIFY:
	switch (((NMHDR *)lParam)->code) {

	case PSN_SETACTIVE:
	case PSN_RESET:
	    /* reset button states */
	    if (((NMHDR *)lParam)->code == PSN_RESET)
		SetWindowLong(hDlg, DWL_MSGRESULT, FALSE);
	    break;
	    
	case PSN_APPLY:
	    /* Save the settings */
	    SetWindowLong(hDlg, DWL_MSGRESULT, TRUE);
	    break;

	case PSN_KILLACTIVE:
	    SetWindowLong(hDlg, DWL_MSGRESULT, FALSE);
	    return 1;
	}
	break;
    }

    return FALSE;
}

int WINAPI
WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpszCmdLn, int nShowCmd)
{
    PROPSHEETHEADER psh;
    PROPSHEETPAGE psp[1];
    int err = 0;
    
    hInstance = hInst;
    
    if ((err = Krb5NdiCreate()) != OK)
	return err;

    psp[0].dwSize = sizeof(PROPSHEETPAGE);
    psp[0].dwFlags = 0;
    psp[0].hInstance = hInst;
    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_REALMS);
    psp[0].pszIcon = NULL;
    psp[0].pfnDlgProc = (DLGPROC)Krb5NdiRealmsProc;
    psp[0].lParam = (LPARAM)rgy;

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = NULL;
    psh.hInstance = hInst;
    psh.pszIcon = NULL;
    psh.pszCaption = (LPTSTR)TEXT("Kerberos v5 Configuration");
    psh.pStartPage = 0;
    psh.nPages = sizeof(psp)/sizeof(psp[0]);
    psh.ppsp = (LPCPROPSHEETPAGE)&psp;

    if (PropertySheet(&psh))
	Krb5NdiInstall(rgy);

    Krb5NdiDestroy(rgy);

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\kerbtray\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by kerbtray.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        127
#define _APS_NEXT_COMMAND_VALUE         40007
#define _APS_NEXT_CONTROL_VALUE         1036
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\kerbpol\kerbpol.c ===
/*++

Managing user privileges can be achieved programmatically using the
following steps:

1. Open the policy on the target machine with LsaOpenPolicy(). To grant
   privileges, open the policy with POLICY_CREATE_ACCOUNT and
   POLICY_LOOKUP_NAMES access. To revoke privileges, open the policy with
   POLICY_LOOKUP_NAMES access.

2. Obtain a SID (security identifier) representing the user/group of
   interest. The LookupAccountName() and LsaLookupNames() APIs can obtain a
   SID from an account name.

3. Call LsaAddAccountRights() to grant privileges to the user(s)
   represented by the supplied SID.

4. Call LsaRemoveAccountRights() to revoke privileges from the user(s)
   represented by the supplied SID.

5. Close the policy with LsaClose().

To successfully grant and revoke privileges, the caller needs to be an
administrator on the target system.

The LSA API LsaEnumerateAccountRights() can be used to determine which
privileges have been granted to an account.

The LSA API LsaEnumerateAccountsWithUserRight() can be used to determine
which accounts have been granted a specified privilege.

Documentation and header files for these LSA APIs is provided in the
Windows 32 SDK in the MSTOOLS\SECURITY directory.

NOTE: These LSA APIs are currently implemented as Unicode only.

This sample will grant the privilege SeServiceLogonRight to the account
specified on argv[1].

This sample is dependant on these import libs

   advapi32.lib (for LsaXxx)
   user32.lib (for wsprintf)

This sample will work properly compiled ANSI or Unicode.



You can use domain\account as argv[1]. For instance, mydomain\scott will
grant the privilege to the mydomain domain account scott.

The optional target machine is specified as argv[2], otherwise, the
account database is updated on the local machine.

The LSA APIs used by this sample are Unicode only.

Use LsaRemoveAccountRights() to remove account rights.

Scott Field (sfield)    12-Jul-95

--*/

#ifndef UNICODE
#define UNICODE
#endif // UNICODE

#include <windows.h>
#include <stdio.h>

#include "ntsecapi.h"

NTSTATUS
OpenPolicy(
    LPWSTR ServerName,          // machine to open policy on (Unicode)
    DWORD DesiredAccess,        // desired access to policy
    PLSA_HANDLE PolicyHandle    // resultant policy handle
    );

LPTSTR
ConvertTimeToString(
    LARGE_INTEGER time		// Kerberos time value
    );

void
InitLsaString(
    PLSA_UNICODE_STRING LsaString, // destination
    LPWSTR String                  // source (Unicode)
    );

void
DisplayNtStatus(
    LPSTR szAPI,                // pointer to function name (ANSI)
    NTSTATUS Status             // NTSTATUS error value
    );

void
DisplayWinError(
    LPSTR szAPI,                // pointer to function name (ANSI)
    DWORD WinError              // DWORD WinError
    );

#define RTN_OK 0
#define RTN_USAGE 1
#define RTN_ERROR 13

//
// If you have the ddk, include ntstatus.h.
//
#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS  ((NTSTATUS)0x00000000L)
#endif

static LPCTSTR dt_output_dhms	= TEXT("%d %s %02d:%02d:%02d");
static LPCTSTR dt_day_plural	= TEXT("days");
static LPCTSTR dt_day_singular	= TEXT("day");
static LPCTSTR dt_output_donly	= TEXT("%d %s");
static LPCTSTR dt_output_hms	= TEXT("%d:%02d:%02d");

LPTSTR
ConvertTimeToString(LARGE_INTEGER time)
{
    int days, hours, minutes, seconds;
    DWORD tt;
    static TCHAR buf2[40];
#define TPS (10*1000*1000)
    DWORD dt = (long)(time.QuadPart / TPS);

    days = (int) (dt / (24*3600l));
    tt = dt % (24*3600l);
    hours = (int) (tt / 3600);
    tt %= 3600;
    minutes = (int) (tt / 60);
    seconds = (int) (tt % 60);

    if (days) {
	if (hours || minutes || seconds) {
	    wsprintf(buf2, dt_output_dhms, days,
		     (days > 1) ? dt_day_plural : dt_day_singular,
		     hours, minutes, seconds);
	}
	else {
	    wsprintf(buf2, dt_output_donly, days,
		     (days > 1) ? dt_day_plural : dt_day_singular);
	}
    }
    else {
	wsprintf(buf2, dt_output_hms, hours, minutes, seconds);
    }
    return(buf2);
}

int _cdecl
main(int argc, char *argv[])
{
    LSA_HANDLE PolicyHandle;
    WCHAR wComputerName[256]=L"";   // static machine name buffer
    NTSTATUS Status;
    int iRetVal=RTN_ERROR;          // assume error from main
    PPOLICY_DOMAIN_KERBEROS_TICKET_INFO KerbInfo;
    
    if(argc > 2)
    {
        fprintf(stderr,"Usage: %s [TargetMachine]\n",
            argv[0]);
        return RTN_USAGE;
    }

    //
    // Pick up machine name on argv[2], if appropriate
    // assumes source is ANSI. Resultant string is Unicode.
    //
    if(argc == 2) wsprintfW(wComputerName, L"%hS", argv[1]);

    //
    // Open the policy on the target machine.
    //
    if((Status=OpenPolicy(
                wComputerName,      // target machine
                MAXIMUM_ALLOWED,
                &PolicyHandle       // resultant policy handle
                )) != STATUS_SUCCESS) {
        DisplayNtStatus("OpenPolicy", Status);
        return RTN_ERROR;
    }

    //
    // Get the Kerberos policy
    //
    if ((Status=LsaQueryDomainInformationPolicy(
	PolicyHandle,
	PolicyDomainKerberosTicketInformation,
	&KerbInfo)) != STATUS_SUCCESS)
    {
	DisplayNtStatus("LsaQueryDomainInformationPolicy", Status);
        return RTN_ERROR;
    }
	
    //
    // Print out the Kerberos information
    //
    printf("Authentication options: 0x%x\n", KerbInfo->AuthenticationOptions);
    printf("MaxServiceTicketAge: %S\n",
	   ConvertTimeToString(KerbInfo->MaxServiceTicketAge));
    printf("MaxTicketAge: %S\n", ConvertTimeToString(KerbInfo->MaxTicketAge));
    printf("MaxRenewAge: %S\n", ConvertTimeToString(KerbInfo->MaxRenewAge));
    printf("MaxClockSkew: %S\n", ConvertTimeToString(KerbInfo->MaxClockSkew));

    //
    // Free buffer
    //
    LsaFreeMemory(KerbInfo);
    
    //
    // Close the policy handle.
    //
    LsaClose(PolicyHandle);

    return iRetVal;
}

void
InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPWSTR String
    )
{
    DWORD StringLength;

    if (String == NULL) {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = wcslen(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
}

NTSTATUS
OpenPolicy(
    LPWSTR ServerName,
    DWORD DesiredAccess,
    PLSA_HANDLE PolicyHandle
    )
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server = NULL;

    //
    // Always initialize the object attributes to all zeroes.
    //
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    if (ServerName != NULL) {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        InitLsaString(&ServerString, ServerName);
        Server = &ServerString;
    }

    //
    // Attempt to open the policy.
    //
    return LsaOpenPolicy(
                Server,
                &ObjectAttributes,
                DesiredAccess,
                PolicyHandle
                );
}

void
DisplayNtStatus(
    LPSTR szAPI,
    NTSTATUS Status
    )
{
    //
    // Convert the NTSTATUS to Winerror. Then call DisplayWinError().
    //
    DisplayWinError(szAPI, LsaNtStatusToWinError(Status));
}

void
DisplayWinError(
    LPSTR szAPI,
    DWORD WinError
    )
{
    LPSTR MessageBuffer;
    DWORD dwBufferLength;

    //
    // TODO: Get this fprintf out of here!
    //
    fprintf(stderr,"%s error! (0x%x)\n", szAPI, WinError);

    if(dwBufferLength=FormatMessageA(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        WinError,
                        GetUserDefaultLangID(),
                        (LPSTR) &MessageBuffer,
                        0,
                        NULL
                        ))
    {
        DWORD dwBytesWritten; // unused

        //
        // Output message string on stderr.
        //
        WriteFile(
            GetStdHandle(STD_ERROR_HANDLE),
            MessageBuffer,
            dwBufferLength,
            &dwBytesWritten,
            NULL
            );

        //
        // Free the buffer allocated by the system.
        //
        LocalFree(MessageBuffer);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\kerbtray\kerbtray.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by kerbtray.rc
//
#define IDS_KRB5_NAME                   1
#define IDS_VER_INFO_LANG               2
#define IDS_NO_CREDS			3
#define IDS_EXPIRED			4
#define IDS_INFINITE			5
#define IDS_PURGED			6
#define IDS_NO_NET_CREDS		7
#define IDS_LTIMES			8
#define IDS_LEXPIRES			9
#define IDS_LFLAGS			10
#define IDS_LENCTYPE			11
#define IDS_INVALID			12
#define IDS_DOMAIN			13
#define IDS_SERVICE_PRINCIPAL           14
#define IDS_TARGET_NAME                 15
#define IDS_LNAMES                      16
#define IDR_MENU                        101
#define IDD_PROP_TKT_FLAGS              102
#define IDD_ABOUT                       103
#define IDD_TICKETS                     104
#define IDD_PROP_ENCTYPES               105
#define IDD_PROP_TIMES                  106
#define IDD_PROP_NAMES                  107

#define IDI_KWIN                        103
#define IDI_0_MIN                       104
#define IDI_5_MIN                       105
#define IDI_10_MIN                      106
#define IDI_15_MIN                      107
#define IDI_20_MIN                      108
#define IDI_25_MIN                      109
#define IDI_30_MIN                      110
#define IDI_35_MIN                      111
#define IDI_40_MIN                      112
#define IDI_45_MIN                      113
#define IDI_50_MIN                      114
#define IDI_55_MIN                      115
#define IDI_60_MIN                      116
#define IDI_EXPIRED                     117
#define IDI_TICKET                      118
#define IDI_DOMAIN                      119

#define IDD_REAUTH                      121
#define IDD_SETUP                       122
#define IDC_TICKETS                     122
#define IDI_KDC                         124
#define IDI_CHECK                       126
#define IDC_REAUTH_PRINC                1001
#define IDC_AUTO_REAUTH                 1003
#define IDC_FILEDESC                    1004
#define IDC_PRODVER                     1005
#define IDC_COPYRIGHT                   1006
#define IDC_OSVERSION                   1007
#define IDC_TRADEMARK                   1008
#define IDC_FORWARDABLE                 1009
#define IDC_PROXIABLE                   1010
#define IDC_COMPANY                     1011
#define IDC_CLOSE                       1011
#define IDC_LABEL                       1012
#define IDC_MAY_POSTDATE                1012
#define IDC_PRINC_LABEL                 1013
#define IDC_PRINC_START                 1014
#define IDC_INVALID                     1014
#define IDC_RENEWABLE                   1015
#define IDC_PREAUTH                     1016
#define IDC_FORWARDED                   1017
#define IDC_PROXY                       1018
#define IDC_POSTDATED                   1019
#define IDC_INITIAL                     1020
#define IDC_HWAUTH                      1021
#define IDC_OK_AS_DELEGATE              1022
#define IDC_TAB_ATTRIBUTES              1023
#define IDC_STARTTIME                   1024
#define IDC_ENDTIME                     1025
#define IDC_RENEW_UNTIL                 1026
#define IDC_TKT_ENCTYPE                 1027
#define IDC_KEY_ENCTYPE                 1028
#define IDC_SERVICE_PRINC               1030
#define IDC_SERVICE_PRINC_LABEL         1031
#define IDC_SERVICENAME                 1032
#define IDC_TARGETNAME                  1033
#define IDC_CLIENTNAME                  1034
#define ID_NEW                          40001
#define ID_ABOUT                        40002
#define ID_EXIT                         40003
#define ID_TICKETS                      40004
#define ID_PURGE                        40005
#define IDL_RENEW_UNTIL                 40006

// Next default values for new objects
// 
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        127
#define _APS_NEXT_COMMAND_VALUE         40007
#define _APS_NEXT_CONTROL_VALUE         1035
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\kerbtray\kerbtray.c ===
/*--

Copyright (c) 1998  Microsoft Corporation

Module Name:

    kerbtray.c

Abstract:

    Displays a dialog with list of Kerberos tickets for the current user.

Author:

    14-Dec-1998 (jbrezak)

Environment:

    User mode only.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#define UNICODE
#define _UNICODE
#define STRICT
#include <windows.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <commctrl.h>
#include <commdlg.h>
#include <time.h>
#include <assert.h>
#include <string.h>
#include <malloc.h>
#define SECURITY_WIN32
#include <security.h>
#include <ntsecapi.h>

#ifndef NO_CRYPTDLL
#include "cryptdll.h"
#endif
#include "kerbtray.h"

#define SEC_SUCCESS(Status) ((Status) >= 0)
#define TSIZE(b) (sizeof(b)/sizeof(TCHAR))

#define IDI_FIRST_CLOCK IDI_0_MIN
#define IDI_LAST_CLOCK  IDI_TICKET
#define MAX_ICONS (IDI_LAST_CLOCK - IDI_FIRST_CLOCK + 1)

#define KWIN_UPDATE_PERIOD 60000       // Every 60 seconds update the screen

#define PPAGE_NAMES     0
#define PPAGE_TIMES     1
#define PPAGE_FLAGS     2
#define PPAGE_ETYPES    3
#define C_PAGES 4

#define CX_ICON 20
#define CY_ICON 20

#define TPS (10*1000*1000)

typedef struct
{
    HWND hwndTab;
    HWND hwndDisplay;
    RECT rcDisplay;
    DLGTEMPLATE *apRes[C_PAGES];
    PKERB_QUERY_TKT_CACHE_RESPONSE Tickets;
} DLGTABHDR;

OSVERSIONINFO osvers;
HWND hWnd, hDlgTickets;
HINSTANCE hInstance;
HANDLE hModule;
#define SHORTSTRING 40
#define LONGSTRING 256
TCHAR progname[SHORTSTRING];
ULONG PackageId;
HANDLE LogonHandle = NULL;
HWND hWndUsers;
HIMAGELIST himl;
HTREEITEM tgt = NULL;

static HICON kwin_icons[MAX_ICONS];    // Icons depicting time
static INT domain_icon;
static LPCTSTR dt_output_dhms   = TEXT("%d %s %02d:%02d:%02d");
static LPCTSTR dt_day_plural    = TEXT("days");
static LPCTSTR dt_day_singular  = TEXT("day");
static LPCTSTR dt_output_donly  = TEXT("%d %s");
static LPCTSTR dt_output_hms    = TEXT("%d:%02d:%02d");
static LPCTSTR ftime_default_fmt        = TEXT("%02d/%02d/%02d %02d:%02d");

#define WM_NOTIFY_ICON  (WM_APP+100)

#ifndef NO_CRYPTDLL
typedef NTSTATUS (NTAPI *CDLOCATECSYSTEM)(ULONG dwEtype, PCRYPTO_SYSTEM * ppcsSystem);

CDLOCATECSYSTEM pCDLocateCSystem;
#endif

LRESULT CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK AboutProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK TicketsProc(HWND, UINT, WPARAM, LPARAM);
void About(void);
void Tickets(void);
void PurgeCache(void);
void PropsheetDisplay(HWND hDlg);
void SelectTicket(HWND hDlg);
void FillinTicket(HWND hDlg);
LPTSTR etype_string(int enctype);
LPTSTR GetStringRes(int);

#ifdef DEBUG
#define DPRINTF(s) dprintf s

int debug = 1;

void dprintf(LPCTSTR fmt, ...)
{
    TCHAR szTemp[512];
    va_list ap;

    if (!debug)
        return;

    va_start (ap, fmt);
    wvsprintf(szTemp, fmt, ap);
    OutputDebugString(szTemp);
    va_end (ap);
}
#else
#define DPRINTF(s)
#endif

void
ShowMessage(int level, LPCTSTR msg)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    if (level)
        MessageBeep(level);
    MessageBox(NULL, msg, progname,
               level | MB_OK | MB_TASKMODAL | MB_SETFOREGROUND);
}

void
Error(LPCTSTR fmt, ...)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    TCHAR szTemp[512];

    va_list ap;
    va_start (ap, fmt);
#ifdef UNICODE
    _vsnwprintf(szTemp, sizeof(szTemp), fmt, ap);
#else
    _vsnprintf(szTemp, sizeof(szTemp), fmt, ap);
#endif
    OutputDebugString(szTemp);
    ShowMessage(MB_ICONINFORMATION, szTemp);
    va_end (ap);
}

void
ErrorExit(LPCTSTR lpszMessage)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    MessageBox(hWnd, lpszMessage, TEXT("Error"), MB_OK);
    ExitProcess(0);
}

int
GetIconIndex(long dt)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    int ixicon;

    dt = dt / 60;                       // convert to minutes
    if (dt <= 0)
        ixicon = IDI_EXPIRED - IDI_FIRST_CLOCK;
    else if (dt > 60)
        ixicon = IDI_TICKET - IDI_FIRST_CLOCK;
    else
        ixicon = (int)(dt / 5);

    return ixicon;
}

void
SetTray(
    HWND hwnd,
    HICON hIcon,
    LPCTSTR tip
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    static tray_inited = 0;
    NOTIFYICONDATA tnd;

    tnd.cbSize = sizeof(NOTIFYICONDATA);
    tnd.hWnd = hwnd;
    tnd.uID = IDI_KDC;
    tnd.uFlags = NIF_MESSAGE|NIF_ICON|NIF_TIP;
    tnd.uCallbackMessage = WM_NOTIFY_ICON;
    tnd.hIcon = hIcon;
    StrNCpy(tnd.szTip, tip, TSIZE(tnd.szTip));
    Shell_NotifyIcon((tray_inited)?NIM_MODIFY:NIM_ADD, &tnd);
    if (tray_inited == 0)
        tray_inited++;
    DestroyIcon(tnd.hIcon);
}

void
DeleteTray(HWND hwnd)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NOTIFYICONDATA tnd;

    tnd.cbSize = sizeof(NOTIFYICONDATA);
    tnd.hWnd = hwnd;
    tnd.uID = IDI_KDC;
    tnd.uFlags = NIF_MESSAGE|NIF_ICON|NIF_TIP;
    tnd.uCallbackMessage = WM_NOTIFY_ICON;
    tnd.hIcon = NULL;
    tnd.szTip[0] = '\0';
    Shell_NotifyIcon(NIM_DELETE, &tnd);
}

int
UpdateTray(HWND hwnd)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    HICON hicon;
    TCHAR buf[SHORTSTRING];
    int expired = FALSE;
    long dt = 0L;
    NTSTATUS Status, SubStatus;
    KERB_QUERY_TKT_CACHE_REQUEST CacheRequest;
    PKERB_RETRIEVE_TKT_RESPONSE TicketEntry = NULL;
    PKERB_EXTERNAL_TICKET Ticket;
    ULONG ResponseSize;
    FILETIME CurrentFileTime;
    LARGE_INTEGER Quad;

    CacheRequest.MessageType = KerbRetrieveTicketMessage;
    CacheRequest.LogonId.LowPart = 0;
    CacheRequest.LogonId.HighPart = 0;

    StrNCpy(buf, progname, TSIZE(buf));

    Status = LsaCallAuthenticationPackage(LogonHandle,
                                          PackageId,
                                          &CacheRequest,
                                          sizeof(CacheRequest),
                                          (PVOID *) &TicketEntry,
                                          &ResponseSize,
                                          &SubStatus);
    if (!SEC_SUCCESS(Status) || !SEC_SUCCESS(SubStatus)) {
        hicon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_KDC));
        StrCatBuff(buf, GetStringRes(IDS_NO_CREDS), TSIZE(buf));
    }
    else {
        Ticket = &(TicketEntry->Ticket);

        GetSystemTimeAsFileTime(&CurrentFileTime);

        Quad.LowPart = CurrentFileTime.dwLowDateTime;
        Quad.HighPart = CurrentFileTime.dwHighDateTime;

        dt = (long)((Ticket->EndTime.QuadPart - Quad.QuadPart) / TPS);

        LsaFreeReturnBuffer(TicketEntry);

        hicon = kwin_icons[GetIconIndex(dt)];

        StrCatBuff(buf, TEXT(" - "), TSIZE(buf));

        if (dt <= 0) {
            StrCatBuff(buf, GetStringRes(IDS_EXPIRED), TSIZE(buf));
            expired = TRUE;
        }
        else {
            int days, hours, minutes, seconds;
            DWORD tt;
            TCHAR buf2[SHORTSTRING];

            days = (int) (dt / (24*3600l));
            tt = dt % (24*3600l);
            hours = (int) (tt / 3600);
            tt %= 3600;
            minutes = (int) (tt / 60);
            seconds = (int) (tt % 60);

            if (days) {
                if (hours || minutes || seconds) {
                    _snwprintf(buf2, TSIZE(buf2), dt_output_dhms, days,
			       (days > 1) ? dt_day_plural : dt_day_singular,
			       hours, minutes, seconds);
                }
                else {
                    _snwprintf(buf2, TSIZE(buf2), dt_output_donly, days,
			       (days > 1) ? dt_day_plural : dt_day_singular);
                }
            }
            else {
                _snwprintf(buf2, TSIZE(buf2), dt_output_hms,
			   hours, minutes, seconds);
            }
            _snwprintf(buf, TSIZE(buf), TEXT("%s %s"), progname, buf2);
        }
    }
    SetTray(hwnd, hicon, buf);
    return(expired);
}


BOOL
InitializeApp(
    HANDLE hInstance,
    int nCmdShow
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    LSA_STRING Name;
    NTSTATUS Status;
    WNDCLASSEX wc;
    HWND hwnd;
    int i;

    // Check for an existing instance
    hwnd = FindWindow(TEXT("MainWindowClass"), TEXT("KerbTray"));
    if (hwnd) {
	// Popup the tickets dialog, if one found
	// Run only one instance of kerbtray
	SendMessage(hwnd, WM_NOTIFY_ICON, 0, WM_LBUTTONDBLCLK);
	ExitProcess(0);
    }

    hModule = GetModuleHandle(NULL);
    InitCommonControls();

    LoadString(hInstance, IDS_KRB5_NAME, progname, TSIZE(progname));

    Status = LsaConnectUntrusted(&LogonHandle);
    if (!SEC_SUCCESS(Status)) {
        Error(TEXT("Failed to register as a logon process: 0x%x"), Status);
        return FALSE;
    }

    Name.Buffer = MICROSOFT_KERBEROS_NAME_A;
    Name.Length = (USHORT) strlen(Name.Buffer);
    Name.MaximumLength = Name.Length + 1;

    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!SEC_SUCCESS(Status)){
        printf("Failed to lookup package %Z: 0x%x\n",&Name, Status);
        return FALSE;
    }

    // Create the image list.
    if ((himl = ImageList_Create(CX_ICON, CY_ICON, ILC_COLOR, MAX_ICONS, 0)) == NULL)
        return FALSE;

    ImageList_SetBkColor(himl, CLR_NONE);

    for (i = IDI_FIRST_CLOCK; i <= IDI_LAST_CLOCK; i++) {
#if 1
        kwin_icons[i - IDI_FIRST_CLOCK] = LoadIcon(hInstance,
                                                   MAKEINTRESOURCE(i));
#else
        kwin_icons[i - IDI_FIRST_CLOCK] = LoadImage(hInstance,
						    MAKEINTRESOURCE(i),
						    IMAGE_ICON, 0, 0,
						    LR_DEFAULTCOLOR|LR_DEFAULTSIZE|LR_LOADTRANSPARENT|LR_LOADMAP3DCOLORS);
#endif
        (void) ImageList_AddIcon(himl, kwin_icons[i - IDI_FIRST_CLOCK]);
    }

#if 1
    domain_icon =  ImageList_AddIcon(himl,
                       LoadIcon(hInstance, MAKEINTRESOURCE(IDI_DOMAIN)));
#else
    domain_icon =  ImageList_AddIcon(himl,
                       LoadImage(hInstance, MAKEINTRESOURCE(IDI_DOMAIN),
				 IMAGE_ICON, 0, 0,
				 LR_DEFAULTCOLOR|LR_DEFAULTSIZE|LR_LOADTRANSPARENT|LR_LOADMAP3DCOLORS));
#endif

    // Register a window class for the main window.
    wc.cbSize           = sizeof(WNDCLASSEX);
    wc.style            = CS_HREDRAW|CS_VREDRAW;
    wc.lpfnWndProc      = MainWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = hInstance;
    wc.hIcon            = LoadIcon(hModule, MAKEINTRESOURCE(IDI_EXPIRED));
    wc.hIconSm          = LoadIcon(hModule, MAKEINTRESOURCE(IDI_EXPIRED));
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_WINDOW+1);
    wc.lpszMenuName     = 0;
    wc.lpszClassName    = TEXT("MainWindowClass");

    if (! RegisterClassEx(&wc)) {
        Error(TEXT("RegisterClassEx failed"));
        return FALSE;
    }

    /* Create the main window. */
    hWnd = CreateWindowEx(WS_EX_APPWINDOW,
                          TEXT("MainWindowClass"),
                          TEXT("KerbTray"),
                          WS_OVERLAPPEDWINDOW,
                          0, 0,
                          5, 5,
                          NULL,
                          NULL,
                          hModule,
                          NULL);
    if (hWnd == NULL) {
        Error(TEXT("CreateWindowEx failed"));
        return FALSE;
    }

    ShowWindow(hWnd, SW_HIDE);

    return TRUE;
}

int WINAPI
WinMain(
    HINSTANCE hInst,
    HINSTANCE hPrevInst,
    LPSTR lpszCmdLn,
    int nShowCmd
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    MSG msg;
    HANDLE hAccelTable, hCryptDll;

    hInstance = hInst;
    hModule = GetModuleHandle(NULL);

    osvers.dwOSVersionInfoSize = sizeof(osvers);
    GetVersionEx(&osvers);

#ifndef NO_CRYPTDLL
    hCryptDll = LoadLibrary(TEXT("CRYPTDLL.DLL"));
    if (!hCryptDll)
        ErrorExit(TEXT("Unable to load cryptdll.dll"));

    pCDLocateCSystem = (CDLOCATECSYSTEM) GetProcAddress(hCryptDll, "CDLocateCSystem");
    if (!pCDLocateCSystem)
        ErrorExit(TEXT("Unable to link cryptdll.dll::CDLocateCSystem"));
#endif

    if (! InitializeApp(hInst, nShowCmd))
        ErrorExit(TEXT("InitializeApp failure"));

    hAccelTable = LoadAccelerators(hInst, TEXT("KerbTray"));

    while (GetMessage(&msg, NULL, 0, 0)) {
        if (!IsDialogMessage(hDlgTickets, &msg)) {
            if (!TranslateAccelerator (msg.hwnd, hAccelTable, &msg)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }
    return 1;

    UNREFERENCED_PARAMETER(hPrevInst);
    UNREFERENCED_PARAMETER(lpszCmdLn);
}

LRESULT CALLBACK
MainWndProc(HWND hwnd, UINT uiMessage, WPARAM wParam, LPARAM lParam)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    POINT pos;
    static HMENU hPopupMenu;

    switch (uiMessage) {

    case WM_NOTIFY_ICON:
        switch (lParam) {

        case WM_LBUTTONDBLCLK:
            Tickets();
            return 0L;

        case WM_RBUTTONDOWN:
            if (hPopupMenu) {
                if (GetCursorPos(&pos)) {
                    if (TrackPopupMenu(hPopupMenu,
				       TPM_RIGHTALIGN|TPM_LEFTBUTTON,
				       pos.x, pos.y,
				       0, hwnd, NULL) == 0)
			Error(TEXT("TrackPopupMenuFailed: 0x%x"),
			      GetLastError());
		}
            }
            return 0L;
        }
        break;

        /* Create a client windows */

    case WM_CREATE:
        hPopupMenu = LoadMenu(hInstance, MAKEINTRESOURCE(IDR_MENU));
        if (!hPopupMenu)
            Error(TEXT("LoadMenu failed %d"), GetLastError());
        hPopupMenu = GetSubMenu(hPopupMenu, 0);
        if (!hPopupMenu)
            Error(TEXT("LoadMenu failed %d"), GetLastError());

        (void) UpdateTray(hwnd);

        /* Start timer for watching the TGT */
        if (!SetTimer(hwnd, 1, KWIN_UPDATE_PERIOD, NULL)) {
            ErrorExit(TEXT("SetTimer failed"));
        }
        return 0L;


    case WM_TIMER:
        (void) UpdateTray(hwnd);
        return(0L);

    case WM_ENDSESSION:
        return(0L);

        /*
         * Close the main window.  First set fKillAll to TRUE to
         * terminate all threads.  Then wait for the threads to exit
         * before passing a close message to a default handler.  If you
         * don't wait for threads to terminate, process terminates
         * with no chance for thread cleanup.
         */

    case WM_CLOSE:
    exit:;
    {
        DeleteTray(hWnd);
        KillTimer(hWnd, 1);
        PostQuitMessage(0);
        return 0L;
    }

    /* Terminate the process. */

    case WM_DESTROY:
        PostQuitMessage(0);
        return 0L;


        /* Handle the menu commands. */

    case WM_COMMAND:
        switch (LOWORD(wParam)) {

        case ID_ABOUT:
            About();
            return 0L;

        case ID_TICKETS:
            Tickets();
            return 0L;

        case ID_PURGE:
            PurgeCache();
            return 0L;

        case ID_EXIT:
            goto exit;
        }
    }
    return DefWindowProc(hwnd, uiMessage, wParam, lParam);
}

LPTSTR
GetStringRes(int id)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
  static TCHAR buffer[MAX_PATH];

  buffer[0] = 0;
  LoadString (GetModuleHandle (NULL), id, buffer, MAX_PATH);
  return buffer;
}

LRESULT CALLBACK
AboutProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    static  HFONT hfontDlg;             // Font for dialog text
    DWORD   dwVerInfoSize;              // Size of version information block
    LPTSTR  lpVersion;                  // String pointer to 'version' text
    DWORD   dwVerHnd = 0;               // An 'ignored' parameter, always '0'
    UINT    uVersionLen;
    DWORD   wRootLen;
    BOOL    bRetCode;
    int     i;
    TCHAR    szFullPath[LONGSTRING];
    TCHAR    szResult[LONGSTRING];
    TCHAR    szGetName[LONGSTRING];
    TCHAR    szVersion[SHORTSTRING];
    DWORD   dwResult;
    int     resmap[6] = {
        IDC_COMPANY,
        IDC_FILEDESC,
        IDC_PRODVER,
        IDC_COPYRIGHT,
        IDC_OSVERSION,
    };

    switch (message) {
    case WM_INITDIALOG:
        ShowWindow(hDlg, SW_HIDE);
        hfontDlg = CreateFont(14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                              VARIABLE_PITCH | FF_SWISS, TEXT(""));
        GetModuleFileName(hInstance, szFullPath, TSIZE(szFullPath));

        /* Now lets dive in and pull out the version information: */
        dwVerInfoSize = GetFileVersionInfoSize(szFullPath, &dwVerHnd);
        if (dwVerInfoSize) {
            LPSTR   lpstrVffInfo;
            HANDLE  hMem;

            hMem = GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize);
	    if (!hMem) {
		ErrorExit(TEXT("Unable to allocate memory"));
	    }
            lpstrVffInfo  = GlobalLock(hMem);
	    if (!lpstrVffInfo) {
		ErrorExit(TEXT("Unable to lock memory"));
	    }
	
            GetFileVersionInfo(szFullPath, dwVerHnd, dwVerInfoSize, lpstrVffInfo);
            /*
             * The below 'hex' value looks a little confusing, but
             * essentially what it is, is the hexidecimal representation
             * of a couple different values that represent the language
             * and character set that we are wanting string values for.
             * 040904E4 is a very common one, because it means:
             * US English, Windows MultiLingual characterset
             * Or to pull it all apart:
             * 04------        = SUBLANG_ENGLISH_USA
             * --09----        = LANG_ENGLISH
             * ----04E4 = 1252 = Codepage for Windows:Multilingual
             */

            StrNCpy(szGetName, GetStringRes(IDS_VER_INFO_LANG), TSIZE(szGetName));

            wRootLen = lstrlen(szGetName); /* Save this position */

            /* Set the title of the dialog: */
            StrCatBuff(szGetName, TEXT("ProductName"), TSIZE(szGetName));
            bRetCode = VerQueryValue((LPVOID)lpstrVffInfo,
                                     (LPTSTR)szGetName,
                                     (LPVOID)&lpVersion,
                                     (UINT *)&uVersionLen);
            StrNCpy(szResult, TEXT("About "), TSIZE(szResult));
            StrCatBuff(szResult, lpVersion, TSIZE(szResult));
            SetWindowText(hDlg, szResult);

            /* Walk through the dialog items that we want to replace: */
            for (i = 0; i <= 6; i++) {
                GetDlgItemText(hDlg, resmap[i], szResult, TSIZE(szResult));
                szGetName[wRootLen] = TEXT('\0');
                StrCatBuff(szGetName, szResult, TSIZE(szGetName));
                uVersionLen = 0;
                lpVersion = NULL;
                bRetCode =  VerQueryValue((LPVOID)lpstrVffInfo,
                                          (LPTSTR)szGetName,
                                          (LPVOID)&lpVersion,
                                          (UINT *)&uVersionLen);

                if ( bRetCode && uVersionLen && lpVersion) {
                    /* Replace dialog item text with version info */
                    StrNCpy(szResult, lpVersion, TSIZE(szResult));
                    SetDlgItemText(hDlg, resmap[i], szResult);
                } else {
                    dwResult = GetLastError();
                    _snwprintf(szResult, TSIZE(szResult),
			       TEXT("Error %lu"), dwResult);
                    SetDlgItemText (hDlg, resmap[i], szResult);
                }
                SendMessage(GetDlgItem(hDlg, resmap[i]), WM_SETFONT,
                            (WPARAM)hfontDlg,
                            TRUE);
            }
            GlobalUnlock(hMem);
            GlobalFree(hMem);

        } else {
            /* No version information available. */
        }

        SendMessage(GetDlgItem (hDlg, IDC_LABEL), WM_SETFONT,
                    (WPARAM)hfontDlg,(LPARAM)TRUE);

        _snwprintf(szVersion, TSIZE(szVersion),
		   TEXT("Microsoft Windows %u.%u (Build: %u)"),
		   osvers.dwMajorVersion,
		   osvers.dwMinorVersion,
		   osvers.dwBuildNumber);

        SetWindowText(GetDlgItem(hDlg, IDC_OSVERSION), szVersion);
        ShowWindow(hDlg, SW_SHOW);
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg, 0);
            break;
        }
    }
    return FALSE;
}

void
About(void)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    DialogBox(hInstance, MAKEINTRESOURCE(IDD_ABOUT), hWnd, AboutProc);
}

#define CheckDlgButtonFlag(b, f) \
    CheckDlgButton(hDlg, b, (flags & f)?BST_CHECKED:BST_UNCHECKED)

VOID
ShowFlags(HWND hDlg, ULONG flags)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    CheckDlgButtonFlag(IDC_FORWARDABLE, KERB_TICKET_FLAGS_forwardable);
    CheckDlgButtonFlag(IDC_FORWARDED, KERB_TICKET_FLAGS_forwarded);
    CheckDlgButtonFlag(IDC_PROXIABLE, KERB_TICKET_FLAGS_proxiable);
    CheckDlgButtonFlag(IDC_PROXY, KERB_TICKET_FLAGS_proxy);
    CheckDlgButtonFlag(IDC_MAY_POSTDATE, KERB_TICKET_FLAGS_may_postdate);
    CheckDlgButtonFlag(IDC_POSTDATED, KERB_TICKET_FLAGS_postdated);
    CheckDlgButtonFlag(IDC_INVALID, KERB_TICKET_FLAGS_invalid);
    CheckDlgButtonFlag(IDC_RENEWABLE, KERB_TICKET_FLAGS_renewable);
    CheckDlgButtonFlag(IDC_INITIAL, KERB_TICKET_FLAGS_initial);
    CheckDlgButtonFlag(IDC_HWAUTH, KERB_TICKET_FLAGS_hw_authent);
    CheckDlgButtonFlag(IDC_PREAUTH, KERB_TICKET_FLAGS_pre_authent);
    CheckDlgButtonFlag(IDC_OK_AS_DELEGATE, KERB_TICKET_FLAGS_ok_as_delegate);
}

LPTSTR
etype_string(
    int enctype
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
#ifndef NO_CRYPTDLL
    static PCRYPTO_SYSTEM pcsSystem;
    static TCHAR buf[12];

    if (pCDLocateCSystem(enctype, &pcsSystem) == S_OK)
        return pcsSystem->Name;
    else {
        _snwprintf(buf, TSIZE(buf), TEXT("etype %d"), enctype);
        return buf;
    }
#else
    static TCHAR buf[12];

    switch (enctype) {
    case KERB_ETYPE_NULL:
        return TEXT("NULL");
        break;
    case KERB_ETYPE_DES_CBC_CRC:
        return TEXT("Kerberos DES-CBC-CRC");
        break;
    case KERB_ETYPE_DES_CBC_MD5:
        return TEXT("Kerberos DES-CBC-MD5");
        break;
    case KERB_ETYPE_RC4_MD4:
        return TEXT("RSADSI RC4-MD4");
        break;
    case KERB_ETYPE_RC4_PLAIN2:
        return TEXT("RSADSI RC4-PLAIN");
        break;
    case KERB_ETYPE_RC4_LM:
        return TEXT("RSADSI RC4-LM");
        break;
    case KERB_ETYPE_DES_PLAIN:
        return TEXT("Kerberos DES-Plain");
        break;
#ifdef KERB_ETYPE_RC4_HMAC
    case KERB_ETYPE_RC4_HMAC:
        return TEXT("RSADSI RC4-HMAC");
        break;
#endif
    case KERB_ETYPE_RC4_PLAIN:
        return TEXT("RSADSI RC4");
        break;
#ifdef KERB_ETYPE_RC4_HMAC_EXP
    case KERB_ETYPE_RC4_HMAC_EXP:
        return TEXT("RSADSI RC4-HMAC(Export)");
        break;
#endif
    case KERB_ETYPE_RC4_PLAIN_EXP:
        return TEXT("RSADSI RC4(Export)");
        break;
    case KERB_ETYPE_DES_CBC_MD5_EXP:
        return TEXT("Kerberos DES-CBC-MD5-EXP(Export)");
        break;
    case KERB_ETYPE_DES_PLAIN_EXP:
        return TEXT("Kerberos DES-Plain(Export)");
        break;
    default:
        _snwprintf(buf, TSIZE(buf), TEXT("etype %d"), enctype);
        return buf;
        break;
    }
#endif
}

LPTSTR
timestring(TimeStamp ConvertTime)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    SYSTEMTIME SystemTime;
    FILETIME LocalFileTime;
    static TCHAR buf[LONGSTRING];

    if (ConvertTime.HighPart == 0x7FFFFFFF &&
        ConvertTime.LowPart == 0xFFFFFFFF) {
        return(GetStringRes(IDS_INFINITE));
    }

    if (FileTimeToLocalFileTime(
        (PFILETIME) &ConvertTime,
        &LocalFileTime) &&
        FileTimeToSystemTime(
            &LocalFileTime,
            &SystemTime)) {
        _snwprintf(buf, TSIZE(buf), ftime_default_fmt,
		   SystemTime.wMonth,
		   SystemTime.wDay,
		   SystemTime.wYear,
		   SystemTime.wHour,
		   SystemTime.wMinute);
    }
    else
        return(GetStringRes(IDS_INVALID));

    return(buf);
}

// DoLockDlgRes - loads and locks a dialog template resource.
// Returns the address of the locked resource.
// lpszResName - name of the resource

DLGTEMPLATE * WINAPI
DoLockDlgRes(LPCTSTR lpszResName)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    HRSRC hrsrc;
    HGLOBAL hglb;
    DLGTEMPLATE *pDlg;

    hrsrc = FindResource(NULL, lpszResName, RT_DIALOG);
    if (!hrsrc) {
        Error(TEXT("Unable to locate resource '%s'"), lpszResName);
	ExitProcess(0);
    }

    hglb = LoadResource(hInstance, hrsrc);
    if (!hglb) {
        Error(TEXT("Unable to load resource '%s'"), lpszResName);
	ExitProcess(0);
    }

    pDlg = (DLGTEMPLATE *)LockResource(hglb);
    if (!pDlg) {
        Error(TEXT("Unable to lock resource '%s'"), lpszResName);
	ExitProcess(0);
    }

    return pDlg;
}


void
PurgeCache(void)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    KERB_PURGE_TKT_CACHE_REQUEST CacheRequest;
    PVOID Response;
    ULONG ResponseSize;
    NTSTATUS Status, SubStatus;

    memset(&CacheRequest, 0, sizeof(CacheRequest));

    CacheRequest.MessageType = KerbPurgeTicketCacheMessage;

    Status = LsaCallAuthenticationPackage(LogonHandle,
                                          PackageId,
                                          &CacheRequest,
                                          sizeof(CacheRequest),
                                          &Response,
                                          &ResponseSize,
                                          &SubStatus);

    if (SEC_SUCCESS(Status) && SEC_SUCCESS(SubStatus)) {
        ShowMessage(MB_ICONINFORMATION, GetStringRes(IDS_PURGED));
    }
    else {
        Error(TEXT("Failed to purge ticket cache - 0x%x"), Status);
    }

    if (Response != NULL) {
        LsaFreeReturnBuffer(Response);
    }
}

HTREEITEM
AddOneItem(
    HTREEITEM hParent,
    LPTSTR szText,
    HTREEITEM hInsAfter,
    int iImage,
    HWND hwndTree,
    LPARAM lParam
)
{
    HTREEITEM hItem;
    TV_ITEM tvI;
    TV_INSERTSTRUCT tvIns;

    tvI.mask = TVIF_TEXT|TVIF_IMAGE|TVIF_SELECTEDIMAGE|TVIF_PARAM;
    tvI.pszText = szText;
    tvI.cchTextMax = lstrlen(szText);
    tvI.lParam = lParam;
    tvI.iImage = iImage;
    tvI.iSelectedImage = iImage;

    tvIns.item = tvI;
    tvIns.hInsertAfter = hInsAfter;
    tvIns.hParent = hParent;

    hItem = TreeView_InsertItem(hwndTree, &tvIns);
    return(hItem);
}

HTREEITEM
FindDomainByName(LPTSTR name)
{
    HTREEITEM dom = NULL;
    TVITEM item;
    TCHAR buf[LONGSTRING];

    dom = TreeView_GetRoot(hWndUsers);
    if (!dom)
        return NULL;

    do {

        item.mask = TVIF_TEXT;
        item.pszText = buf;
        item.cchTextMax = sizeof(buf);
        item.hItem = dom;
        if (TreeView_GetItem(hWndUsers, &item)) {
            if (wcscmp(name, buf) == 0) {
                return dom;
            }
        }
    } while (dom = TreeView_GetNextSibling(hWndUsers, dom));

    return NULL;
}

HTREEITEM
AddDomain(
    LPTSTR name
)
{
    HTREEITEM hItem;

    if (!(hItem = FindDomainByName(name))) {
        hItem = AddOneItem(NULL, _wcsdup(name), TVI_ROOT,
                                        domain_icon, hWndUsers, 0);
    }
    return(hItem);
}

HTREEITEM
FindTicketByName(HTREEITEM lip, LPTSTR name)
{
    HTREEITEM tick = NULL;
    TVITEM item;
    TCHAR buf[LONGSTRING];

    tick = TreeView_GetChild(hWndUsers, lip);
    if (!tick)
        return NULL;

    do {
        item.mask = TVIF_TEXT;
        item.pszText = buf;
        item.cchTextMax = sizeof(buf);
        item.hItem = tick;
        if (TreeView_GetItem(hWndUsers, &item)) {
            if (wcscmp(name, buf) == 0) {
                return tick;
            }
        }
    } while (tick = TreeView_GetNextSibling(hWndUsers, tick));

    return NULL;
}

HTREEITEM
AddTicket(
    HTREEITEM dom,
    LPTSTR name,
    int idx,
    LPARAM lParam
)
{
    HTREEITEM hItem;

    hItem = AddOneItem(dom, name, TVI_SORT, idx, hWndUsers, lParam);
    TreeView_Expand(hWndUsers, dom, TVE_EXPAND);
    return(hItem);
}

void
ShowTicket(
    HWND hDlg,
    PKERB_TICKET_CACHE_INFO tix,
    int i
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    TCHAR sname[LONGSTRING];
    HTREEITEM dom, tick;
    FILETIME CurrentFileTime;
    LARGE_INTEGER Quad;
    long dt = 0L;

    memset(sname, 0, sizeof(sname));

    swprintf(sname, TEXT("%wZ"), &tix->RealmName);
    dom = AddDomain(sname);
    swprintf(sname, TEXT("%wZ"), &tix->ServerName);

    GetSystemTimeAsFileTime(&CurrentFileTime);

    Quad.LowPart = CurrentFileTime.dwLowDateTime;
    Quad.HighPart = CurrentFileTime.dwHighDateTime;

    dt = (long)((tix->EndTime.QuadPart - Quad.QuadPart) / TPS);

    // 14
    tick = AddTicket(dom, sname, GetIconIndex(dt), (LPARAM)tix);
    if (tix->TicketFlags & KERB_TICKET_FLAGS_initial)
        tgt = tick;
}

void
DisplayCreds(
    HWND hDlg
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    KERB_QUERY_TKT_CACHE_REQUEST CacheRequest;
    PKERB_RETRIEVE_TKT_RESPONSE TicketEntry = NULL;
    PKERB_EXTERNAL_TICKET Ticket;
    NTSTATUS Status, SubStatus;
    ULONG ResponseSize;
    DWORD i;
    DLGTABHDR *pHdr;
    TCITEM tie;
    DWORD dwDlgBase = GetDialogBaseUnits();
    int cxMargin = LOWORD(dwDlgBase) / 4;
    int cyMargin = HIWORD(dwDlgBase) / 8;
    RECT rcTab;

    pHdr  = (DLGTABHDR *) LocalAlloc(LPTR|LMEM_ZEROINIT, sizeof(DLGTABHDR));
    if (!pHdr)
	ErrorExit(TEXT("Unable to allocate memory"));

    // Save a pointer to the DLGHDR structure.
    SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pHdr);

    pHdr->hwndTab = GetDlgItem(hDlg, IDC_TAB_ATTRIBUTES);

    hWndUsers = GetDlgItem(hDlg, IDC_TICKETS);

    // Associate the image list with the tree view control.
    //TreeView_SetImageList(hWndUsers, himl, TVSIL_NORMAL);

    CacheRequest.MessageType = KerbRetrieveTicketMessage;
    CacheRequest.LogonId.LowPart = 0;
    CacheRequest.LogonId.HighPart = 0;

    Status = LsaCallAuthenticationPackage(LogonHandle,
                                          PackageId,
                                          &CacheRequest,
                                          sizeof(CacheRequest),
                                          (PVOID *) &TicketEntry,
                                          &ResponseSize,
                                          &SubStatus);

    if (SEC_SUCCESS(Status) && SEC_SUCCESS(SubStatus)) {
        static TCHAR princ[LONGSTRING];

        Ticket = &(TicketEntry->Ticket);
        memset(princ, 0, sizeof(princ));
        swprintf(princ, TEXT("%wZ@%wZ"),
                 &Ticket->ClientName->Names[0],
                 &Ticket->DomainName);
        SetDlgItemText(hDlg, IDC_PRINC_LABEL, princ);
    }
    else {
        SetDlgItemText(hDlg, IDC_PRINC_LABEL,
                       GetStringRes(IDS_NO_NET_CREDS));
        SetDlgItemText(hDlg, IDC_PRINC_START,
                       TEXT(""));

        if (TicketEntry)
            LsaFreeReturnBuffer(TicketEntry);

        return;
    }

    // Add a tab for each of the three child dialog boxes.
    tie.mask = TCIF_TEXT | TCIF_IMAGE;
    tie.iImage = -1;
    tie.pszText = GetStringRes(IDS_LNAMES);
    TabCtrl_InsertItem(pHdr->hwndTab, PPAGE_NAMES, &tie);
    tie.pszText = GetStringRes(IDS_LTIMES);
    TabCtrl_InsertItem(pHdr->hwndTab, PPAGE_TIMES, &tie);
    tie.pszText = GetStringRes(IDS_LFLAGS);
    TabCtrl_InsertItem(pHdr->hwndTab, PPAGE_FLAGS, &tie);
    tie.pszText = GetStringRes(IDS_LENCTYPE);
    TabCtrl_InsertItem(pHdr->hwndTab, PPAGE_ETYPES, &tie);

    // Lock the resources for the three child dialog boxes.
    pHdr->apRes[PPAGE_NAMES] = DoLockDlgRes(MAKEINTRESOURCE(IDD_PROP_NAMES));
    pHdr->apRes[PPAGE_TIMES] = DoLockDlgRes(MAKEINTRESOURCE(IDD_PROP_TIMES));
    pHdr->apRes[PPAGE_FLAGS] = DoLockDlgRes(MAKEINTRESOURCE(IDD_PROP_TKT_FLAGS));
    pHdr->apRes[PPAGE_ETYPES] = DoLockDlgRes(MAKEINTRESOURCE(IDD_PROP_ENCTYPES));

    // Determine the bounding rectangle for all child dialog boxes.
    SetRectEmpty(&rcTab);
    for (i = 0; i < C_PAGES; i++) {
        if (pHdr->apRes[i]->cx > rcTab.right)
            rcTab.right = pHdr->apRes[i]->cx;
        if (pHdr->apRes[i]->cy > rcTab.bottom)
            rcTab.bottom = pHdr->apRes[i]->cy;
    }
    rcTab.right = rcTab.right * LOWORD(dwDlgBase) / 4;
    rcTab.bottom = rcTab.bottom * HIWORD(dwDlgBase) / 8;

    // Calculate how large to make the tab control, so
    // the display area can accommodate all the child dialog boxes.
    TabCtrl_AdjustRect(pHdr->hwndTab, TRUE, &rcTab);
    OffsetRect(&rcTab, cxMargin - rcTab.left,
            cyMargin - rcTab.top);

    // Calculate the display rectangle.
    CopyRect(&pHdr->rcDisplay, &rcTab);
    TabCtrl_AdjustRect(pHdr->hwndTab, FALSE, &pHdr->rcDisplay);

    CacheRequest.MessageType = KerbQueryTicketCacheMessage;
    CacheRequest.LogonId.LowPart = 0;
    CacheRequest.LogonId.HighPart = 0;

    Status = LsaCallAuthenticationPackage(LogonHandle,
                                          PackageId,
                                          &CacheRequest,
                                          sizeof(CacheRequest),
                                          (PVOID *) &pHdr->Tickets,
                                          &ResponseSize,
                                          &SubStatus);
    if (SEC_SUCCESS(Status) && SEC_SUCCESS(SubStatus)) {
        for (i = 0; i < pHdr->Tickets->CountOfTickets; i++) {
            ShowTicket(hDlg, &pHdr->Tickets->Tickets[i], i);
        }
        LsaFreeReturnBuffer(TicketEntry);
    }
    if (tgt)
        TreeView_SelectItem(hWndUsers, tgt);
    PropsheetDisplay(hDlg);
    SelectTicket(hDlg);
}

LRESULT CALLBACK
PropSheetProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    DLGTABHDR *pHdr;
    HWND hwndParent = GetParent(hDlg);

    hwndParent = GetParent(hwndParent);
    pHdr = (DLGTABHDR *) GetWindowLongPtr(hwndParent, GWLP_USERDATA);

    switch (message) {
    case WM_INITDIALOG:
        SetWindowPos(hDlg, HWND_TOP,
                     pHdr->rcDisplay.left, pHdr->rcDisplay.top,
                     0, 0, SWP_NOSIZE);
        return TRUE;
    }

    return FALSE;
}

void
PropsheetDisplay(HWND hDlg)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    DLGTABHDR *pHdr = (DLGTABHDR *) GetWindowLongPtr(hDlg, GWLP_USERDATA);
    int iSel = TabCtrl_GetCurSel(pHdr->hwndTab);

    // Destroy the current child dialog box, if any.
    if (pHdr->hwndDisplay != NULL)
        DestroyWindow(pHdr->hwndDisplay);

    // Create the new child dialog box.
    pHdr->hwndDisplay = CreateDialogIndirect(hInstance, pHdr->apRes[iSel],
                                             pHdr->hwndTab, PropSheetProc);

}

INT
UnparseExternalName(
    PKERB_EXTERNAL_NAME iName,
    PUNICODE_STRING *np
)
{
    int len, cnt;
    PUNICODE_STRING name;

    for (len = 0, cnt = 0; cnt < iName->NameCount; cnt++) {
        len += iName->Names[cnt].Length;
        if ((cnt + 1) < iName->NameCount)
            len += 2;
    }

    name = malloc(sizeof(UNICODE_STRING));
    if (!name)
        return -1;

    name->Buffer = malloc(len + 2);
    if (!name->Buffer) {
        free(name);
        return -1;
    }
    name->Length = 0;
    name->MaximumLength = len+2;
    memset(name->Buffer, 0, len + 2);

    for (cnt = 0; cnt < iName->NameCount; cnt++) {
        wcsncat(name->Buffer, iName->Names[cnt].Buffer, iName->Names[cnt].Length/2);
        name->Length += iName->Names[cnt].Length;
        if ((cnt + 1) < iName->NameCount) {
            wcsncat(name->Buffer, L"/", 1);
            name->Length += 2;
        }
    }
    *np = name;

    return 0;
}

VOID
FreeUnicodeString(
    PUNICODE_STRING ustr
)
{
    if (ustr) {
        free(ustr->Buffer);
        free(ustr);
    }
}

void
SelectTicket(HWND hDlg)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    DLGTABHDR *pHdr = (DLGTABHDR *) GetWindowLongPtr(hDlg, GWLP_USERDATA);
    int iSel = TabCtrl_GetCurSel(pHdr->hwndTab);
    HTREEITEM hItem = TreeView_GetSelection(hWndUsers);
    TVITEM item;
    TCHAR sname[LONGSTRING];
    PKERB_TICKET_CACHE_INFO tix;
    FILETIME CurrentFileTime;
    LARGE_INTEGER Quad;
    long dt = 0L;

    if (!hItem)
        return;

    item.hItem = hItem;
    item.mask = TVIF_PARAM;
    item.lParam = 0;

    TreeView_GetItem(hWndUsers, &item);

    if (!item.lParam) {
        SetDlgItemText(hDlg, IDC_SERVICE_PRINC_LABEL,
                       GetStringRes(IDS_DOMAIN));
        SetDlgItemText(hDlg, IDC_SERVICE_PRINC, TEXT(""));
        FillinTicket(hDlg);
        return;
    }

    SetDlgItemText(hDlg, IDC_SERVICE_PRINC_LABEL,
                   GetStringRes(IDS_SERVICE_PRINCIPAL));

    tix = (PKERB_TICKET_CACHE_INFO)item.lParam;

    GetSystemTimeAsFileTime(&CurrentFileTime);

    Quad.LowPart = CurrentFileTime.dwLowDateTime;
    Quad.HighPart = CurrentFileTime.dwHighDateTime;

    dt = (long)((tix->EndTime.QuadPart - Quad.QuadPart) / TPS);

    if (dt > 0) {
	swprintf(sname, TEXT("%wZ@%wZ"),
		 &tix->ServerName,
		 &tix->RealmName);

	SetDlgItemText(hDlg, IDC_SERVICE_PRINC, sname);
    }
    else {
	SetDlgItemText(hDlg, IDC_SERVICE_PRINC_LABEL, GetStringRes(IDS_EXPIRED));
        SetDlgItemText(hDlg, IDC_SERVICE_PRINC, TEXT(""));
    }

    FillinTicket(hDlg);
}


void
FillinTicket(HWND hDlg)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PKERB_TICKET_CACHE_INFO tix;
    DLGTABHDR *pHdr = (DLGTABHDR *) GetWindowLongPtr(hDlg, GWLP_USERDATA);
    int iSel = TabCtrl_GetCurSel(pHdr->hwndTab);
    HTREEITEM hItem = TreeView_GetSelection(hWndUsers);
    TVITEM item;
    PKERB_RETRIEVE_TKT_REQUEST TicketRequest;
    ULONG ResponseSize;
    NTSTATUS Status, SubStatus;
    PKERB_EXTERNAL_TICKET ticket;
    int sz;
    TCHAR sname[LONGSTRING];
    PUNICODE_STRING svc;

    if (!hItem)
        return;

    item.hItem = hItem;
    item.mask = TVIF_PARAM;
    item.lParam = 0;

    TreeView_GetItem(hWndUsers, &item);

    switch(iSel) {
    case PPAGE_NAMES:
        SetDlgItemText(pHdr->hwndDisplay, IDC_SERVICENAME,
                       TEXT(""));
        SetDlgItemText(pHdr->hwndDisplay, IDC_TARGETNAME,
                       TEXT(""));
        SetDlgItemText(pHdr->hwndDisplay, IDC_CLIENTNAME,
                       TEXT(""));
        break;

    case PPAGE_TIMES:
        SetDlgItemText(pHdr->hwndDisplay, IDC_STARTTIME,
                       TEXT(""));
        SetDlgItemText(pHdr->hwndDisplay, IDC_ENDTIME,
                       TEXT(""));
        SetDlgItemText(pHdr->hwndDisplay, IDC_RENEW_UNTIL,
                       TEXT(""));
        break;

    case PPAGE_ETYPES:
        SetDlgItemText(pHdr->hwndDisplay, IDC_TKT_ENCTYPE,
                       TEXT(""));
        SetDlgItemText(pHdr->hwndDisplay, IDC_KEY_ENCTYPE,
                       TEXT(""));
        break;

    case PPAGE_FLAGS:
        ShowFlags(pHdr->hwndDisplay, 0);
        break;
    }

    if (!item.lParam) {
        return;
    }

    tix = (PKERB_TICKET_CACHE_INFO)item.lParam;

    swprintf(sname, TEXT("%wZ@%wZ"),
             &tix->ServerName,
             &tix->RealmName);

    sz = sizeof(WCHAR)*(wcslen(sname) + 1);
    TicketRequest = LocalAlloc(LMEM_ZEROINIT,
                               sizeof(KERB_RETRIEVE_TKT_REQUEST) + sz);

    if (!TicketRequest)
	ErrorExit(TEXT("Unable to allocate memory"));

    TicketRequest->MessageType = KerbRetrieveEncodedTicketMessage;
    TicketRequest->LogonId.LowPart = 0;
    TicketRequest->LogonId.HighPart = 0;
    TicketRequest->TargetName.Length = wcslen(sname) * sizeof(WCHAR);
    TicketRequest->TargetName.MaximumLength = TicketRequest->TargetName.Length + sizeof(WCHAR);
    TicketRequest->TargetName.Buffer = (LPWSTR) (TicketRequest + 1);
    wcsncpy(TicketRequest->TargetName.Buffer, sname, wcslen(sname));
    TicketRequest->CacheOptions = KERB_RETRIEVE_TICKET_USE_CACHE_ONLY;
    TicketRequest->EncryptionType = 0L;
    TicketRequest->TicketFlags = 0L;

    Status = LsaCallAuthenticationPackage(LogonHandle,
                                          PackageId,
                                          TicketRequest,
                                          (sizeof(KERB_RETRIEVE_TKT_REQUEST) + sz),
                                          (PVOID *)&ticket,
                                          &ResponseSize,
                                          &SubStatus);
    LocalFree(TicketRequest);
    if (SEC_SUCCESS(Status) && SEC_SUCCESS(SubStatus)) {

#if 0
        if (ticket->TargetName && ticket->TargetDomainName.Length &&
            !UnparseExternalName(ticket->TargetName, &svc)) {
            swprintf(sname, TEXT("%wZ@%wZ"),
                     svc,
                     &ticket->TargetDomainName);
            SetDlgItemText(hDlg, IDC_SERVICE_PRINC, sname);
            SetDlgItemText(hDlg, IDC_SERVICE_PRINC_LABEL,
                           GetStringRes(IDS_TARGET_NAME));
            FreeUnicodeString(svc);
        }
#endif
        switch(iSel) {
        case PPAGE_NAMES:
            if (ticket->ServiceName && ticket->DomainName.Length &&
                !UnparseExternalName(ticket->ServiceName, &svc)) {
                swprintf(sname, TEXT("%wZ@%wZ"),
                         svc,
                         &ticket->DomainName);
                SetDlgItemText(pHdr->hwndDisplay, IDC_SERVICENAME,
                               sname);
                FreeUnicodeString(svc);
            }
            if (ticket->ClientName && ticket->DomainName.Length &&
                !UnparseExternalName(ticket->ClientName, &svc)) {
                swprintf(sname, TEXT("%wZ@%wZ"),
                         svc,
                         &ticket->DomainName);
                SetDlgItemText(pHdr->hwndDisplay, IDC_CLIENTNAME,
                               sname);
                FreeUnicodeString(svc);
            }
            if (ticket->TargetName && ticket->TargetDomainName.Length &&
                !UnparseExternalName(ticket->TargetName, &svc)) {
                swprintf(sname, TEXT("%wZ@%wZ"),
                         svc,
                         &ticket->TargetDomainName);
                SetDlgItemText(pHdr->hwndDisplay, IDC_TARGETNAME,
                               sname);
                FreeUnicodeString(svc);
            }
            break;

        case PPAGE_TIMES:
            SetDlgItemText(pHdr->hwndDisplay, IDC_STARTTIME,
                           timestring(tix->StartTime));
            SetDlgItemText(pHdr->hwndDisplay, IDC_ENDTIME,
                           timestring(tix->EndTime));
            if (tix->TicketFlags & KERB_TICKET_FLAGS_renewable) {
                SetDlgItemText(pHdr->hwndDisplay, IDC_RENEW_UNTIL,
                               timestring(tix->RenewTime));
                ShowWindow(GetDlgItem(pHdr->hwndDisplay, IDC_RENEW_UNTIL),
                           SW_SHOW);
            }
            else {
                ShowWindow(GetDlgItem(pHdr->hwndDisplay, IDC_RENEW_UNTIL),
                           SW_HIDE);
            }
            break;

        case PPAGE_ETYPES:
            SetDlgItemText(pHdr->hwndDisplay, IDC_TKT_ENCTYPE,
                           etype_string(tix->EncryptionType));
            SetDlgItemText(pHdr->hwndDisplay, IDC_KEY_ENCTYPE,
                           etype_string(ticket->SessionKey.KeyType));
            break;

        case PPAGE_FLAGS:
            ShowFlags(pHdr->hwndDisplay, tix->TicketFlags);
            break;
        }

        LsaFreeReturnBuffer(ticket);
    }
}

LRESULT CALLBACK
TicketsProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    LPNMHDR nm;
    DLGTABHDR *pHdr;

    switch (message) {
    case WM_INITDIALOG:
        DisplayCreds(hDlg);
        ShowWindow(hDlg, SW_SHOW);
        return TRUE;

    case WM_NOTIFY: {
        nm = (LPNMHDR)lParam;
        switch (nm->code) {
        case TCN_SELCHANGING:
            return FALSE;

        case TCN_SELCHANGE:
            PropsheetDisplay(hDlg);
            FillinTicket(hDlg);
            return TRUE;

        case TVN_SELCHANGED:
            SelectTicket(hDlg);
            break;
        }
    }
    break;

    case WM_SYSCOMMAND:
        switch (wParam) {
        case SC_CLOSE:
            goto close_tix;
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_CLOSE:
        close_tix:
            pHdr = (DLGTABHDR *) GetWindowLongPtr(hDlg, GWLP_USERDATA);
            if (pHdr->hwndDisplay != NULL)
                DestroyWindow(pHdr->hwndDisplay);
            DestroyWindow(hDlgTickets);
            LsaFreeReturnBuffer(pHdr->Tickets);
            LocalFree(pHdr);
            hDlgTickets = NULL;
            break;
        }
        break;
    }

    return FALSE;
}

void
Tickets(void)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    if (!hDlgTickets)
        hDlgTickets = CreateDialog(hInstance,
                                   MAKEINTRESOURCE(IDD_TICKETS),
                                   hWnd,
                                   TicketsProc);
    else {
        ShowWindow(hDlgTickets, SW_SHOW);
        SetForegroundWindow(hDlgTickets);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\inc\common.h ===
/*++
  
  COMMON.H

  General routines shared between sserver and sclient.

  Copyright (C) 1997 Microsoft Corporation
  
  Created 01-08-1997 by DavidCHR

  --*/

#ifdef _KERBCOMM_H_

/* we want kerberos stuff */

typedef KERB_AP_REPLY   *PKERB_AP_REPLY;
typedef KERB_AP_REQUEST *PKERB_AP_REQUEST;

#endif

#ifdef CPLUSPLUS
extern "C" {
#endif

/* if remote_host is NULL, start as a server, listening on "port".  */
BOOL
ConfigureNetwork( IN OPTIONAL PCHAR            remote_host,
		  IN          SHORT            port, /* must be host short */
		  OUT         SOCKET          *ReturnedSocket,
		  OUT         struct sockaddr *sockname,
		  OUT         int             *szSockaddr,
		  OUT         WSADATA         *wsaData );
	
BOOL
NetWrite( IN SOCKET connection_to_write_on,
	  IN PVOID  data_to_send,
	  IN ULONG  how_much_data );

BOOL
NetRead(  IN          SOCKET listening_connection,
	  OUT         PVOID  buffer_for_inbound_data,
	  IN          PULONG sizes, /* IN: how big is buffer, 
				       OUT: how many bytes were really read */
	  IN OPTIONAL ULONG  seconds_to_wait_before_timeout
#ifdef CPLUSPLUS
	  =0L
#endif
	  );


#ifdef CPLUSPLUS
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\inc\keytab.h ===
/*++

  KEYTAB.H

  Unix Keytab routines and data structures

  Copyright(C) 1997 Microsoft Corporation

  Created, 01-10-1997 DavidCHR

  --*/

typedef unsigned char  krb5_octet,     K5_OCTET,     *PK5_OCTET;
typedef unsigned short krb5_int16,     K5_INT16,     *PK5_INT16;
typedef unsigned long  krb5_timestamp, K5_TIMESTAMP, *PK5_TIMESTAMP;
typedef unsigned long  krb5_int32,     K5_INT32,     *PK5_INT32;

typedef struct _raw_ktcomp {

  K5_INT16 szComponentData; /* string length (including NULL) of component */
  PCHAR    Component;       /* key component name, like "host" */

} KTCOMPONENT, *PKTCOMPONENT;

/* this is the structure of a single kerberos service key entry */

typedef struct _raw_ktent {

  K5_INT32     keySize;    /* I am guessing that this is the keysize */
  K5_INT16     cEntries;   /* number of KTCOMPONENTs */
  K5_INT16     szRealm;    /* string length of Realm (including null) */
  PCHAR        Realm;      /* Kerberos realm in question */
  PKTCOMPONENT Components; /* kerberos key components.  For example:
			      host/davidchr_unix1.microsoft.com -->
			      host and davidchr_unix1.microsoft.com are
			      separate key components. */
  K5_INT32     PrincType;  /* Principal type-- not sure what this is */
  K5_TIMESTAMP TimeStamp;  /* Timestamp (seconds since the epoch) */
  K5_OCTET     Version;    /* key version number */
  K5_INT16     KeyType;    /* Key Type -- not sure what this is either */

#if 0                      /* For some reason, the documentation I was reading
			      erroneously listed this as a 32-bit value. */

  K5_INT32     KeyLength;  /* size of key data (next field) */
#else
  K5_INT16     KeyLength;  /* size of key data (next field) */
  K5_INT16     foo_padding;  // padding for alpha compilers.
#endif

  PK5_OCTET    KeyData;    /* raw key data-- might as well be an LPBYTE */

  struct _raw_ktent *nextEntry;

} KTENT, *PKTENT;

/* this is the rough structure of the keytab file */

typedef struct _raw_keytab {

  K5_INT16 Version;

#if 0
  ULONG    cEntries; /* this is not actually stored.  It's the number of
			pktents we have in memory (below) */
  PKTENT   KeyEntries;
#else

  PKTENT   FirstKeyEntry; /* This is a pointer to the first key in the
			     linked list.  In the file, they're just there,
			     in no particular order though. */
  PKTENT   LastKeyEntry;  /* This is the list tail. */

#endif

} KTFILE, *PKTFILE;



VOID 
FreeKeyTab( PKTFILE pktfile_to_free );

BOOL
ReadKeytabFromFile( PKTFILE *ppktfile, // free with FreeKeyTab when done
		    PCHAR    filename );

BOOL
WriteKeytabToFile(  PKTFILE ktfile,
		    PCHAR   filename );

/* These are the values to use for the OPTION_MASK to DisplayKeytab : */

#define KT_COMPONENTS 0x001 /* key components (key's name) */
#define KT_REALM      0x002 /* key realm-- useful */
#define KT_PRINCTYPE  0x004 /* Principal type */
#define KT_VNO        0x008 /* Key version number */
#define KT_KTVNO      0x010 /* Keytab version number */
#define KT_KEYTYPE    0x020 /* type of key (encryption type) */
#define KT_KEYLENGTH  0x040 /* length of key-- not useful */
#define KT_KEYDATA    0x080 /* key data -- not generally useful */
#define KT_TIMESTAMP  0x100 /* timestamp (unix timestamp) */
#define KT_RESERVED   0x200 /* wierd ULONG at the beginning of every key */

#define KT_ENCTYPE    KT_KEYTYPE
#define KT_EVERYTHING 0x3ff
#define KT_DEFAULT (KT_COMPONENTS | KT_REALM | KT_VNO | KT_KTVNO | KT_KEYTYPE | KT_PRINCTYPE )


#ifdef __cplusplus
#define OPTIONAL_PARAMETER( param, default_value ) param=default_value
#else
#define OPTIONAL_PARAMETER( param, default_value ) param
#endif

VOID
DisplayKeytab( FILE   *stream,
	       PKTFILE ktfile,
	       OPTIONAL_PARAMETER( ULONG   options, KT_DEFAULT) );

PVOID 
KEYTAB_ALLOC ( ULONG numBytes );

VOID
KEYTAB_FREE  ( PVOID toFree );

K5_INT32
ComputeKeytabLength ( PKTENT thisKeyEntry );

/* base linklist operations */

BOOL
AddEntryToKeytab( PKTFILE Keytab, 
		  PKTENT  Entry,
		  OPTIONAL_PARAMETER( BOOL copy, FALSE ));

BOOL
RemoveEntryFromKeytab( PKTFILE Keytab,
		       PKTENT  Entry,
		       OPTIONAL_PARAMETER( BOOL dealloc, FALSE ) );


VOID 
FreeKeyEntry( PKTENT pEntry );

PKTENT
CloneKeyEntry( PKTENT pEntry );


BOOL
KtCreateKey( PKTENT  *ppKeyEntry,
	     PCHAR    principal,
	     PCHAR    password,
	     PCHAR    realmname,
	     
	     K5_OCTET keyVersionNumber,  
	     ULONG    principalType,
	     ULONG    keyType,
	     ULONG    cryptosystem  );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\keytab\inc\keyfunc.h ===
/*++

  KEYFUNC.H

  function reference for the keytab library

  created 4/22/1997 by DavidCHR 

  --*/

VOID
FreeKeyEntry( PKTENT pEntry );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\inc\macros.h ===
/*++             Copyright (c) 1996-1997 Microsoft Corporation          --*/
/*++

  MACROS.H

  useful macros I didn't want to declare in every file. 

  first incarnation in EXTENDED: DAVIDCHR 11/4/1996
  next incarnation in k5 compat: DAVIDCHR 1/8/1997
  modified to be more portable:  DAVIDCHR 4/8/1997

  --*/


/* Note that all of these macros use "HopefullyUnusedVariableName" 
   for a local variable to prevent the unintentional "capture" of 
   a passed parameter by the same name.  Hopefully, we'll never use
   a variable by that name.  If so, the variable can be made even
   more longer and less convenient to use.  :-)  */

#define EQUALS TRUE
#define NOT_EQUALS FALSE

/* BREAK_AND_LOG_IF is for use with actual test results.  When you
   absolutely must have the results logged... */

#define BREAK_AND_LOG_IF( variable, loglevel, data, message, label ) {  \
    BOOL   HopefullyUnusedVariableName;                                 \
    unsigned long HopefullyUnusedVariableName_SaveData;                 \
                                                                        \
    HopefullyUnusedVariableName          = (variable);                  \
    HopefullyUnusedVariableName_SaveData = data;                        \
                                                                        \
    if (HopefullyUnusedVariableName) {                                  \
      if ( HopefullyUnusedVariableName_SaveData == 0 ) {                \
         HopefullyUnusedVariableName_SaveData =                         \
	   HopefullyUnusedVariableName;                                 \
      }                                                                 \
      LOGMSG( loglevel, HopefullyUnusedVariableName_SaveData, message );\
      goto label;                                                       \
    }}

#define BREAK_EXPR( variable, operator, test, message, label ) BREAK_HOOK_EXPR( variable, operator, test, "%hs", message, label)

#ifdef USE_NTLOG /* the other macros MAY or MAY NOT use the logger */

#ifndef BREAK_LOG_LEVEL
#define BREAK_LOG_LEVEL LOGLEVEL_INFO
#endif

#define BREAK_HOOK_EXPR( variable, operator, test, formatmessage, hook, label ) {\
    BOOL          HopefullyUnusedVariableName;\
    unsigned long HopefullyUnusedVariableName_Save;\
    CHAR          HopefullyUnusedVariableName_Buffer[1024];\
   /*    unsigned long HopefullyUnusedVariableName_szBuffer = 1024; */\
\
    HopefullyUnusedVariableName_Save = (ULONG) (variable);\
    HopefullyUnusedVariableName = (operator == EQUALS) ? \
      (HopefullyUnusedVariableName_Save == (ULONG) test) :\
      (HopefullyUnusedVariableName_Save != (ULONG) test);\
\
    if (HopefullyUnusedVariableName) {\
      sprintf( HopefullyUnusedVariableName_Buffer, formatmessage, hook );\
      LOGMSG(BREAK_LOG_LEVEL, HopefullyUnusedVariableName_Save,  HopefullyUnusedVariableName_Buffer );\
      goto label;\
    }}

#else

#define BREAK_HOOK_EXPR( variable, operator, test, formatmessage, hook, label ) {\
    BOOL  HopefullyUnusedVariableName;\
    ULONG HopefullyUnusedVariableName_Save;\
\
    HopefullyUnusedVariableName_Save = (ULONG) (variable);\
    HopefullyUnusedVariableName = (operator == EQUALS) ? \
      (HopefullyUnusedVariableName_Save == (ULONG) test) :\
      (HopefullyUnusedVariableName_Save != (ULONG) test);\
\
    if (HopefullyUnusedVariableName) {\
      fprintf(stderr, "\n** 0x%x \t ", HopefullyUnusedVariableName_Save );\
      fprintf(stderr, formatmessage, hook);\
      fprintf(stderr, "\n");\
      goto label;\
    }}

#endif



#define BREAK_IF( variable, message, label ) BREAK_EXPR((variable), NOT_EQUALS, 0L, message, label)

#define BREAK_EQ( variable, equals, message, label ) \
     BREAK_EXPR(variable, EQUALS, equals, message, label )

#define WSA_BREAK( variable, invalidator, message, label ) \
     BREAK_HOOK_EXPR( variable, EQUALS, invalidator, \
		      message "\n\tWSAGetLastError() returns (dec) %d.",\
		      WSAGetLastError(),  label )

#define NT_BREAK_ON BREAK_IF

/*++ MYALLOC

  used 

  whom:     variable to put the memory into.  
  what:     what kind of memory it points to.. the integral denomination of 
            memory we are allocating (char for a string, int for an int *...)
  howmany:  integral size of "what"s we are allocating (see below)
  withwhat: routine to use in allocation (eg malloc, LocalAlloc...).
            this routine must return NULL on failure to allocate.

  EXAMPLE:  I want to allocate a string of 15 characters with malloc

  {
   PCHAR mystring;
   
   if (! MYALLOC( mystring, CHAR, 15, malloc )) {
      fprintf(stderr, "failed to allocate!");
      exit(0);
   }
  }
  --*/

#define MYALLOC( whom, what, howmany, withwhat ) \
( ( (whom) = (what *) (withwhat)( (howmany) * sizeof(what)) ) != NULL )


  /* ONEALLOC is a special case of MYALLOC, where howmany is 1 */

#define ONEALLOC( whom, what, withwhat ) MYALLOC( whom, what, 1, withwhat)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\inc\master.h ===
/*++

  MASTER.H

  master include file for this project.

  Created by Davidchr 1/8/1997, 
  Copyright (C) 1997 Microsoft Corporation

  --*/


#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>

/* These contortions work around an irritation in asn1code.h, where
   DEBUG gets defined.  Uhhh, hello... that's kind of a common word
   to just define for use in a header not relating to debuggers... 

   (just My Humble Opinion) */

#ifdef DEBUG
#define DEBUGOLD DEBUG
#undef DEBUG
#endif

#include <sspi.h>
#include <kerberos.h>
  /* #include "krb5.h" */


#undef DEBUG
#ifdef DEBUGOLD 
#define DEBUG DEBUGOLD

#if DBG || CHECKED_BUILD // WASBUG 73896 
#define debug printf
#else
#define debug // nothing
#endif

#undef DEBUGOLD

#else

#define debug /* nothing */

#endif /* end of asn1code.h hackaround */

#include ".\macros.h"
#include ".\common.h"
#include "common.h"

#define ASSERT_NOTREACHED( message ) /* nothing */
#define Verbage( flag, printflist ) if ( flag ) { printf( printflist ); }

#ifdef __cplusplus
} /* extern "C" */

// #include ".\globals.hxx"

#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\keytab\ldlib\delegation.c ===
/*++

  The original filename was created in RuiM's EFS common library.
  I have since changed it severely.

 *	FileName: delegation.c
 *	Author:   RuiM
 *	Copyright (c) 1998 Microsoft Corp.
 *
  CONTENTS: U(QueryAccountControlFlags)
            U(SetAccountControlFlags)
            U(LdapFindAttributeInMessage)
            U(LdapSearchForUniqueDn)

--*/


#pragma warning(disable:4057) /* indirection to slightly different
				 base types.  Useless warning that hits
				 thousands of times in this file. */
#pragma warning(disable:4221) /* allow nonstandard extension (automatic 
				 initialization of a variable with 
				 address of another automatic variable) */

#include "unimacro.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdef.h>   // required to keep winbase.h from breaking
#include <ntpoapi.h> // required to keep winbase.h from breaking
#include <windows.h>
#include <winbase.h>
#include <lmaccess.h>
#include <winldap.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include "delegation.h"
#include "delegtools.h"

// These constants are required for queries below.

TCHAR U(SamAccountAttribute)   [] = TEXT("samAccountName");
TCHAR U(UserAccountAttribute)  [] = TEXT("userAccountControl");
TCHAR U(NamingContextAttribute)[] = TEXT("defaultNamingContext");

/*++**************************************************************
  NAME:      U(LdapFindAttributeInMessage)

  This searches for a given attribute in a message (via 
  ldap_get_values_len) and returns the value.  Note that this function
  will fail if the attribute has multiple values.

  MODIFIES:  pcbData      -- receives length of the data (in bytes)
             ppvData      -- receives pointer to the data

  TAKES:     pLdap        -- ldap connection handle
             pMessage     -- message to search
             PropertyName -- property to find in the message


  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LASTERROR: not set

  LOGGING:   printf on error

  CALLED BY: anyone
  FREE WITH: ppvdata should be freed with free()
  
 **************************************************************--*/

BOOL
U(LdapFindAttributeInMessage)( IN  PLDAP            pLdap,
			       IN  PLDAPMessage     pMessage,
			       IN  LPTSTR           PropertyName,
			       OUT OPTIONAL PULONG  pcbData,
			       OUT OPTIONAL PVOID  *ppvData ) {

    PLDAP_BERVAL *ppBerVals;
    BOOL          ret = FALSE;

    ppBerVals = ldap_get_values_len( pLdap,
				     pMessage,
				     PropertyName );

    if ( ppBerVals ) {
      
      if ( ppBerVals[ 0 ] == NULL ) {

	printf( "ERROR: empty berval structure returned when parsing "
		STRING_FMTA " attribute.\n",

		PropertyName );

	SetLastError( ERROR_INVALID_DATA );

      } else if ( ppBerVals[ 1 ] != NULL ) {

	printf( "ERROR: nonunique berval structure returned "
		"when parsing "	STRING_FMTA " attribute.\n",

		PropertyName );

	SetLastError( ERROR_DS_NAME_ERROR_NOT_UNIQUE );

      } else {

	/* this sequence is arranged in such a way that
	   the important stuff comes last, keeping us
	   from having to free ppvData after we've alloc'd it. */

	ret = TRUE;

	if ( pcbData ) {

	  *pcbData = ppBerVals[ 0 ]->bv_len;

	}

	if ( ppvData ) {

	  *ppvData = malloc( ppBerVals[ 0 ]->bv_len );

	  if ( *ppvData ) {

	    memcpy( *ppvData,
		    ppBerVals[ 0 ]->bv_val,
		    ppBerVals[ 0 ]->bv_len );

	  } else {

	    printf( "Failed to allocate %ld bytes.\n",
		    ppBerVals[ 0 ]->bv_len );

	    SetLastError( ERROR_NOT_ENOUGH_MEMORY );

	    ret = FALSE;

	  }
	}
      }

      ldap_value_free_len( ppBerVals );

    } else {

      printf( "Failed to retrieve values for property " STRING_FMTA 
	      ": 0x%x.\n",

	      PropertyName,
	      pLdap->ld_errno );

      SetLastError( pLdap->ld_errno );

    }
    

    return ret;
}

/*++**************************************************************
  NAME:      U(LdapSearchForUniqueDn)

  Searches the DS for a DN with a match for the given search term.

  MODIFIES:  pDnOfObject -- if requested, receives the object's DN
             ppMessage   -- if requested, receives the message data

  TAKES:     pLdap                 -- ldap handle returned by ldap_open
             SearchTerm            -- what to search, e.g. "(foo=bar)"
             rzRequestedAttributes -- attributes to return in ppMessage


  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise or if the result is nonunique (WASBUG 73899).
  LASTERROR: not set

  LOGGING:   printf on failure

  CALLED BY: anyone
  FREE WITH: free pDnOfObject with ldap_memfree
             free ppMessage   with ldap_msgfree
  
 **************************************************************--*/

BOOL
U(LdapSearchForUniqueDn)( IN  PLDAP                  pLdap,
			  IN  LPTSTR                 SearchTerm,
			  IN  LPTSTR                *rzRequestedAttributes,
			  OUT OPTIONAL LPTSTR       *pDnOfObject,
			  OUT OPTIONAL PLDAPMessage *ppMessage ) {

    DWORD        dwErr;
    PLDAPMessage pMessage  = NULL;
    PLDAPMessage pResult   = NULL;
    LPTSTR       pDn       = NULL;
    LPTSTR       *ppAttrs  = NULL;
    BOOL         ret       = FALSE;
    LPTSTR       Attrs[]   = { U(NamingContextAttribute), NULL };

    /* First, determine the default naming context property for the base
       of the DSA. */

    dwErr = ldap_search_s( pLdap,
			   NULL,
			   LDAP_SCOPE_BASE,
			   TEXT("objectClass=*"),
			   Attrs,
			   FALSE,
			   &pResult );

    if ( dwErr == LDAP_SUCCESS ) {

      ppAttrs = ldap_get_values( pLdap,
				 pResult,
				 U(NamingContextAttribute) );

      if ( ppAttrs ) {

	dwErr = ldap_search_s( pLdap,
			       ppAttrs[ 0 ],
			       LDAP_SCOPE_SUBTREE, // search the whole tree
			       SearchTerm,
			       rzRequestedAttributes,
			       FALSE, // don't only return attr names
			       &pMessage );

	/* ldap_search_s can return a whole bunch of potential
	   "success" errors.  So, I'll check to see that pMessage
	   is nonnull.  This may or may not be a good thing to do,
	   but it's bound to be safer than checking the error output. */

	if ( pMessage != NULL ) {

	  // make sure the response is unique

	  if ( !ldap_first_entry( pLdap,
				  pMessage ) ) {
	    
	    printf( "WARNING: search term \"" STRING_FMTA "\" "
		    "produced no results.\n",
		    SearchTerm );

	  } else if ( ldap_next_entry( pLdap,
				       ldap_first_entry( pLdap,
							 pMessage ) ) ) {

	    /* Nonunique search result.  Warn the user and 
	       drop out. */

	    PLDAPMessage p = pMessage;
	    ULONG        i = 1;

	    printf( "WARNING: search term \"" STRING_FMTA "\" returns "
		    "multiple results (should be unique).\n"
		    "\n"
		    "The results follow:\n",
		    SearchTerm );


	    for ( p = ldap_first_entry( pLdap,
					pMessage );
		  p != NULL ;
		  p = ldap_next_entry( pLdap,
				       p ),
		    i++ ) {

	      pDn = ldap_get_dn( pLdap,
				 p );

	      if ( !pDn ) {

		printf( "%2ld. <Unknown DN: 0x%x>\n",
			i,
			pLdap->ld_errno );

	      } else {
		
		printf( "%2ld. %hs\n",
			i,
			pDn );


		ldap_memfreeA( pDn );
	      }

	    }

	  } else {

	    ret = TRUE; // go optimistic

	    if ( pDnOfObject ) {
	    
	      pDn = ldap_get_dn( pLdap,
				 pMessage );
	    
	      if ( pDn ) {
	      
		*pDnOfObject = pDn;
	      
	      } else {
	      
		printf( "Failed to get DN from search result: 0x%x\n",
			pLdap->ld_errno );
	      
		SetLastError( pLdap->ld_errno );
	      
		ret = FALSE;
	      
	      }
	    }
	  
	    if ( ret && ppMessage ) {

	      *ppMessage = pMessage;

	    } else {

	      ldap_msgfree( pMessage );

	    }

	  }

	} else {

	  printf( "FAILED: ldap_search_s failed for search term \""
		  STRING_FMTA "\": 0x%x",
		  SearchTerm,
		  dwErr );

	  SetLastError( dwErr );

	}

      } else {

	printf( "FAILED: default naming context does not include"
		" requisite attribute " STRING_FMTA ".\n",

		U(NamingContextAttribute) );

	SetLastError( ERROR_CLASS_DOES_NOT_EXIST );

      }

      ldap_msgfree( pResult );

    } else {

      printf( "FAILED: unable to query default naming context: 0x%x.\n",
	      dwErr );

      SetLastError( dwErr );

    }

    return ret;

}


#pragma warning(disable:4100) /* unreferenced formal parameter */

/*++**************************************************************
  NAME:      U(QueryAccountControlFlags)

  Opens a user and retrieves the user account control flags for it,
  using the DS.

  MODIFIES:  pulControlFlags - returned control flags on the user.

  TAKES:     pLdap          -- optional LDAP connection; if null, we'll
                               make our own and close it when finished.
             DomainName     -- domain in which to search for that account.
	                       This is not currently implemented-- for
			       future use in order to support nonunique
			       accountnames that differ only by domain name.
             SamAccountName -- accountname to query (with $ for computers)

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LASTERROR: set.

  LOGGING:   printf on failure.

  CALLED BY: anyone
  FREE WITH: n/a
  
 **************************************************************--*/

BOOL
U(QueryAccountControlFlags)( IN OPTIONAL PLDAP  pLdap,
			     IN OPTIONAL LPTSTR DomainName, // ignored
			     IN          LPTSTR SamAccountName,
			     OUT         PULONG pulControlFlags ) {
    BOOL         CloseLdap  = FALSE;
    BOOL         ret        = FALSE;
    LPTSTR       Query      = NULL;
    LPTSTR       StringAttr = NULL;
    LPTSTR       ArrayOfAttributes[] = { U(UserAccountAttribute), NULL };
    PLDAPMessage pMessage   = NULL;

    if ( !pLdap ) {

      CloseLdap = ConnectAndBindToDefaultDsa( &pLdap );

    }

    if ( pLdap ) {
#define EXTRA_STUFF TEXT("(objectClass=*)")

      Query = (LPTSTR) malloc( ( lstrlen( SamAccountName ) + 
				 sizeof( "( & (=) )") /* remaining 
							 components */ )
			       * sizeof( TCHAR ) +
			       sizeof( U(SamAccountAttribute )) +
                   sizeof( EXTRA_STUFF ) );
				       

      if ( Query ) {

	wsprintf( Query,
		  TEXT("(& ")
          EXTRA_STUFF
		  TEXT("(%s=%s))"),

		  U(SamAccountAttribute),
		  SamAccountName );

	if ( U(LdapSearchForUniqueDn)( pLdap,
				       Query,
				       ArrayOfAttributes,
				       NULL, // don't need the DN back.
				       &pMessage )) {

	  if ( U(LdapFindAttributeInMessage)( pLdap,
					      pMessage,
					      U(UserAccountAttribute),
					      NULL, // don't care about length
					      &StringAttr ) ) {
	    
	    *pulControlFlags = _tcstoul( StringAttr, 
					 NULL, // no endpoint
					 0     /* use hex or dec as 
						  appropriate */ );
	    
	    ret = TRUE;
	    
	  }  // else message already printed

	  ldap_msgfree( pMessage );

	} // else message already printed.
	
	free( Query );
  
      } else {

	printf( "FAILED: couldn't allocate memory.\n" );
	SetLastError( ERROR_NOT_ENOUGH_MEMORY );

      }
      
      // close the ldap handle if we opened it.

      if ( CloseLdap ) ldap_unbind( pLdap );

    } // else printf'd already.

    return ret;

}


/*++**************************************************************
  NAME:      U(SetAccountControlFlags)

  Sets the accountcontrolflags on a specified account.
  Pretty much what the function name says.

  MODIFIES:  account's control flags

  TAKES:     pLdap               -- if specified, DS handle to use
             DomainName          -- account's domain (mbz)
             SamAccountName      -- account for which to search
             AccountControlFlags -- flags to set on the account

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LASTERROR: set

  LOGGING:   printf on failure

  CALLED BY: anyone
  FREE WITH: n/a
  
 **************************************************************--*/

BOOL
U(SetAccountControlFlags)( IN OPTIONAL PLDAP  pLdap,
			   IN OPTIONAL LPTSTR DomainName,
			   IN          LPTSTR SamAccountName,
			   IN          ULONG  AccountControlFlags ) {

    BOOL         CloseLdap  = FALSE;
    BOOL         ret        = FALSE;
    LPTSTR       Query      = NULL;
    LPTSTR       StringAttr = NULL;
    LPTSTR       ArrayOfAttributes[] = { U(UserAccountAttribute), NULL };
    LPTSTR       Dn;
    DWORD        dwErr;

    if ( !pLdap ) {

      CloseLdap = ConnectAndBindToDefaultDsa( &pLdap );

    }

    if ( pLdap ) {

      Query = (LPTSTR) malloc( ( lstrlen( SamAccountName ) + 
				 sizeof( "( & (=) )") /* remaining 
							 components */ )
			       * sizeof( TCHAR ) +
			       sizeof( U(SamAccountAttribute )) +
                   sizeof( EXTRA_STUFF ) );
				       
      if ( Query ) {

	wsprintf( Query,
		  TEXT("(& ")
          EXTRA_STUFF
		  TEXT("(%s=%s))"),
		  U(SamAccountAttribute),
		  SamAccountName );

	if ( U(LdapSearchForUniqueDn)( pLdap,
				       Query,
				       ArrayOfAttributes,
				       &Dn,
				       NULL /* don't need the message
					       back */ ) ) {

#pragma warning(disable:4204) /* nonstandard extension:
				 non-constant aggregate initializer
				 (e.g. assign an array in the initialization
				 of a structure) */

	  TCHAR   Buffer[ 50 ]; // arbitrary
	  LPTSTR  Strings[] = { Buffer, NULL };
	  LDAPMod TheMod   = {
	    LDAP_MOD_REPLACE,
	    U(UserAccountAttribute),
	    Strings,
	  };
	  PLDAPMod rzMods[] = {
	    &TheMod,
	    NULL
	  };

	  wsprintf( Buffer, 
		    TEXT("%ld"),
		    AccountControlFlags );

	  dwErr = ldap_modify_s( pLdap,
				 Dn,
				 rzMods );

	  if ( dwErr == LDAP_SUCCESS ) {

	    ret = TRUE;

	  } else {

	    printf( "Failed to modify " STRING_FMTA
		    " attribute to %ld (0x%x)"
		    " on " STRING_FMTA 
		    ": 0x%x\n",

		    U(UserAccountAttribute),
		    AccountControlFlags,
		    AccountControlFlags,

		    Dn,
		    
		    dwErr );

	    SetLastError( dwErr );

	  }

	  ldap_memfree( Dn );

	} // else message already printed.
	
	free( Query );
  
      } else {

	printf( "FAILED: couldn't allocate memory.\n" );
	SetLastError( ERROR_NOT_ENOUGH_MEMORY );

      }
      
      // close the ldap handle if we opened it.

      if ( CloseLdap ) ldap_unbind( pLdap );

    } // else printf'd already.

    return ret;



    

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\keytab\ktpass\main.c ===
/*++

  MAIN.C

  main program for the ktPass program

  Copyright (C) 1998 Microsoft Corporation, all rights reserved.

  Created, Jun 18, 1998 by DavidCHR.

--*/

#include "master.h"
#include <winldap.h>
#include "keytab.h"
#include "keytypes.h"
#include "secprinc.h"
#include <kerbcon.h>
#include <lm.h>
#include "options.h"
#include "delegtools.h"
#include "delegation.h"
#include <dsgetdc.h>

PVOID
MIDL_user_allocate( size_t size ) {

    return malloc( size );

}

VOID
MIDL_user_free( PVOID pvFree ) {

    free( pvFree );

}

// this global is set by the command line options.

K5_INT16 ktvno = 0x0502; // kerberos 5, keytab v.2

PKTFILE
NewKt() {

    PKTFILE ret;

    ret = (PKTFILE) malloc (sizeof(KTFILE));

    if (!ret) {
      return NULL;
    }

    memset(ret, 0L, sizeof(KTFILE));

    ret->Version = ktvno;

    return ret;


}

BOOL
UserWantsToDoItAnyway( IN LPSTR fmt,
		       ... ) {
    
    va_list va;
    CHAR    Buffer[ 5 ] = { '\0' }; /* == %c\r\n\0 */
    INT     Response;
    BOOL    ret = FALSE;
    BOOL    keepGoing = TRUE;

    do {

      va_start( va, fmt );
      
      fprintf( stderr, "\n" );
      vfprintf( stderr,
		fmt,
		va );

      fprintf( stderr, " [y/n]?  " );

      if ( !fgets( Buffer,
		   sizeof( Buffer ),
		   stdin ) ) {

	fprintf( stderr,
		 "EOF on stdin.  Assuming you mean no.\n" );

	return FALSE;

      }
      
      Response = Buffer[ 0 ];

      switch( Response ) {

       case 'Y':
       case 'y':
	 
	 ret = TRUE;
	 keepGoing = FALSE;
	 break;

       case EOF:

	 fprintf( stderr,
		  "EOF at console.  I assume you mean no.\n" );
	 
	 // fallthrough

       case 'N':
       case 'n':

	 ret = FALSE;
	 keepGoing = FALSE;
	 break;

       default:

	 printf( "Your response, %02x ('%c'), doesn't make sense.\n"
		 "'Y' and 'N' are the only acceptable responses.",

		 Response,
		 Response );

      }

    } while ( keepGoing );

    if ( !ret ) {

      printf( "Exiting.\n" );

      exit( -1 );

    }

    return ret;
}
    
    

extern BOOL KtDumpSalt; // in ..\lib\mkkey.c
extern LPWSTR RawHash; // in mkkey.c

// #include "globals.h"
// #include "commands.h"

int __cdecl
main( int   argc,
      PCHAR argv[] ) {

    LPSTR    Principal     = NULL;
    LPSTR    UserName      = NULL;
    LPSTR    Password      = NULL;
    PLDAP    pLdap         = NULL;
    LPSTR    UserDn        = NULL;

    BOOL     SetUpn        = TRUE;
    K5_OCTET kvno          = 1;
    ULONG    Crypto        = KERB_ETYPE_DES_CBC_MD5;
    ULONG    ptype         = KRB5_NT_PRINCIPAL;
    ULONG    uacFlags      = 0;
    PKTFILE  pktFile       = NULL;
    PCHAR    KtReadFile    = NULL;
    PCHAR    KtWriteFile   = NULL;
    BOOL     DesOnly       = TRUE;
    ULONG    LdapOperation = LDAP_MOD_ADD;
    HANDLE   hConsole      = NULL;
    BOOL     SetPassword   = TRUE;
    BOOL     WarnedAboutAccountStrangeness = FALSE;
    PVOID    pvTrash       = NULL;
    DWORD    dwConsoleMode;

    optEnumStruct CryptoSystems[] = {

      { "DES-CBC-CRC", (PVOID) KERB_ETYPE_DES_CBC_CRC, "for compatibility" },
      { "DES-CBC-MD5", (PVOID) KERB_ETYPE_DES_CBC_MD5, "default" },

      TERMINATE_ARRAY

    };

#define DUPE( type, desc ) { "KRB5_NT_" # type, 	\
			     (PVOID) KRB5_NT_##type,	\
			     desc }

    optEnumStruct PrincTypes[] = {

      DUPE( PRINCIPAL, "The general ptype-- recommended" ),
      DUPE( SRV_INST,  "user service instance" ),
      DUPE( SRV_HST,   "host service instance" ),
      DUPE( SRV_XHST,  NULL ),

      TERMINATE_ARRAY

    };

    optEnumStruct MappingOperations[] = {

      { "add", (PVOID) LDAP_MOD_ADD,     "add value (default)" },
      { "set", (PVOID) LDAP_MOD_REPLACE, "set value" },

      TERMINATE_ARRAY
      
    };
#if DBG
#undef  OPT_HIDDEN
#define OPT_HIDDEN 0 /* no hidden options on debug builds. */
#endif
	

    optionStruct Options[] = {

      { "?",      NULL, OPT_HELP | OPT_HIDDEN },
      { "h",      NULL, OPT_HELP | OPT_HIDDEN },
      { "help",   NULL, OPT_HELP | OPT_HIDDEN },

      { NULL,      NULL,         OPT_DUMMY,   "most useful args" },

      { "out",     &KtWriteFile, OPT_STRING,  "Keytab to produce" },
      { "princ",   &Principal,   OPT_STRING, "Principal name (user@REALM)" },
      { "pass",    &Password,    OPT_STRING,   "password to use" },
      { NULL,      NULL,         OPT_CONTINUE, 
	"use \"*\" to prompt for password." },

      { NULL,      NULL,         OPT_DUMMY,   "less useful stuff" },

      { "mapuser", &UserName,    OPT_STRING,
	"map princ (above) to this user account (default: don't)" },

      { "mapOp",   &LdapOperation, OPT_ENUMERATED,
	"how to set the mapping attribute (default: add it)",
	MappingOperations },

      { "DesOnly", &DesOnly,     OPT_BOOL,
	"Set account for des-only encryption (default:do)" },

      { "in",      &KtReadFile,  OPT_STRING,  "Keytab to read/digest" },

      { NULL,      NULL,         OPT_DUMMY,   "options for key generation" },

      { "crypto",  &Crypto,   OPT_ENUMERATED, "Cryptosystem to use",
	CryptoSystems },
      { "ptype",   &ptype,    OPT_ENUMERATED, "principal type in question",
	PrincTypes },
      { "kvno",    &kvno,        OPT_INT,     "Key Version Number (def:1)"},
      { "ktvno",   &ktvno,       OPT_INT,     "keytab version (def 0x502)" },

      // { "Debug",   &DebugFlag, OPT_BOOL | OPT_HIDDEN },
      { "RawSalt", &RawHash,     OPT_WSTRING | OPT_HIDDEN,
	"raw MIT salt.  For use when generated salt is suspect (1877)." },

      { "DumpSalt", &KtDumpSalt, OPT_BOOL | OPT_HIDDEN,
	"show us the MIT salt being used to generate the key" },

      { "SetUpn",   &SetUpn,     OPT_BOOL | OPT_HIDDEN,
	"Set the UPN in addition to the SPN.  Default DO." },

      { "SetPass",  &SetPassword, OPT_BOOL | OPT_HIDDEN,
	"Set the user's password if supplied." },

      TERMINATE_ARRAY

    };

    FILE *f;

    // DebugFlag = 0;

    ParseOptionsEx( argc-1,
		    argv+1,
		    Options,
		    OPT_FLAG_TERMINATE,
		    &pvTrash,
		    NULL,
		    NULL );

    if ( Principal && 
	 ( strlen( Principal ) > BUFFER_SIZE ) ) {

      fprintf( stderr,
	       "Please submit a shorter principal name.\n" );

      return 1;
      
    }

    if ( Password && 
	 ( strlen( Password ) > BUFFER_SIZE ) ) {

      fprintf( stderr,
	       "Please submit a shorter password.\n" );

      return 1;
      
    }

    if ( KtReadFile ) {

      if ( ReadKeytabFromFile( &pktFile, KtReadFile ) ) {

	fprintf( stderr,
		 "Tacking on to existing keytab: \n\n" );

	DisplayKeytab( stderr, pktFile, 0xFFFFFFFF );

      } else {

	fprintf( stderr,
		 "Keytab read failed!\n" );
	return 5;

      }
			

    }

    if ( Principal ) {

      LPSTR realm, cp;
      CHAR tempBuffer[ 255 ];

      realm = strchr( Principal, '@' );

      if ( realm ) {

	ULONG length;

	realm++;

	length = lstrlenA( realm );

	memcpy( tempBuffer, realm, ( length +1 ) * sizeof( realm[0] )  );

	CharUpperBuffA( realm, length );

	if ( lstrcmpA( realm, tempBuffer ) != 0 ) {

	  fprintf( stderr,
		   "WARNING: realm \"%hs\" has lowercase characters in it.\n"
		   "         We only currently support realms in UPPERCASE.\n"
		   "         assuming you mean \"%hs\"...\n",

		   tempBuffer, realm );

	  // now "realm" will be all uppercase.

	}

	*(realm-1) = '\0'; // separate the realm from the principal

	if ( UserName ) {

	  // connect to the DSA.

	  if ( pLdap ||
	       ConnectAndBindToDefaultDsa( &pLdap ) ) {

	    // locate the User

	    if ( UserDn ||
		 FindUser( pLdap,
			   UserName,
			   &uacFlags,
			   &UserDn ) ) {

	      if ( ( LdapOperation == LDAP_MOD_REPLACE ) &
		   !( uacFlags & UF_NORMAL_ACCOUNT ) ) {

		/* 97282: the user is not UF_NORMAL_ACCOUNT, so 
		   check to see that the caller *really* wants to
		   blow away the non-user's SPNs. */

		if ( uacFlags ) {

		  fprintf( stderr, 
			   "WARNING: Account %hs is not a normal user "
			   "account (uacFlags=0x%x).\n",
			   UserName,
			   uacFlags );
		  
		} else {

		  fprintf( stderr,
			   "WARNING: Cannot determine the account type"
			   " for %hs.\n",
			   UserName );

		}

		WarnedAboutAccountStrangeness = TRUE;

		if ( !UserWantsToDoItAnyway( 
		   "Do you really want to delete any previous "
		   "servicePrincipalName values on %hs",
		   UserName ) ) {

		  /* Abort the operation, but try to do whatever
		     else the user asked us to do. */

		  goto abortedMapping;

		}

	      }

	      /* 97279: check to see if there are other SPNs
		 by the same name already registered.  If so,
		 we don't want to blow away those accounts. 

		 If/when we decide to do this, we'd do it here. */
	      
	      // set/add the user property

	      if ( SetStringProperty( pLdap,
				      UserDn,
				      "servicePrincipalName",
				      Principal,
				      LdapOperation ) ) {
		
		if ( SetUpn ) {

		  *(realm-1) = '@'; // UPN includes the '@'

		  if ( !SetStringProperty( pLdap,
					   UserDn,
					   "userPrincipalName",
					   Principal,
					   LDAP_MOD_REPLACE ) ) {

		    fprintf( stderr, 
			     "WARNING: Failed to set UPN %hs on %hs.\n"
			     "  kinits to '%hs' will fail.\n",
			     Principal,
			     UserDn,
			     Principal );
		  }

		  *(realm -1 ) = '\0'; // where it was before
		}

		fprintf( stderr,
			 "Successfully mapped %hs to %hs.\n",
			 Principal,
			 UserName );

 abortedMapping:

		; /* Need a semicolon so we can goto here. */

	      } else {

		fprintf( stderr,
			 "WARNING: Unable to set SPN mapping data.\n"
			 "  If %hs already has an SPN mapping installed for "
			 " %hs, this is no cause for concern.\n",
			 
			 UserName,
			 Principal );

	      }
	    } // else a message will be printed.
	  }   // else a message will be printed.
	}
	
	if ( Password ) {

	  PKTENT pktEntry;
	  CHAR   TempPassword[ 255 ], ConfirmPassword[ 255 ];

	  if ( lstrcmpA( Password, "*" ) == 0 ) {

	    hConsole = GetStdHandle( STD_INPUT_HANDLE );

	    if ( GetConsoleMode( hConsole,
				 &dwConsoleMode ) ) {

	      if ( SetConsoleMode( hConsole,
				   dwConsoleMode & ~ENABLE_ECHO_INPUT ) ) {

		do {

		  fprintf( stderr,
			   "Type the password for %hs: ",
			   Principal );
		  
		  gets( TempPassword );
		  
		  fprintf( stderr,
			   "\nType the password again to confirm:" );
		  
		  gets( ConfirmPassword );
		  
		  if ( lstrcmpA( ConfirmPassword,
				 TempPassword ) == 0 ) {
		    
		    printf( "\n" );

		    break;

		  } else {

		    fprintf( stderr, 
			     "The passwords you type must match exactly.\n" );

		  }

		} while ( TRUE );

		Password = TempPassword;

		SetConsoleMode( hConsole, dwConsoleMode );

	      } else { 

		fprintf( stderr,
			 "Failed to turn off echo input for password entry:"
			 " 0x%x\n",

			 GetLastError() );

		return -1;

	      }
	    } else {

	      fprintf( stderr,
		       "Failed to retrieve console mode settings: 0x%x.\n",
		       GetLastError() );

	      return -1;
	    }
	  }

	  if ( SetPassword && UserName ) {

	    DWORD          err;
	    NET_API_STATUS nas;
	    PUSER_INFO_1   pUserInfo;
	    WCHAR          wUserName[ MAX_PATH ];
	    DOMAIN_CONTROLLER_INFOW * DomainControllerInfo = NULL;

	    /* WASBUG 369: converting ascii to unicode
	       This is safe, because RFC1510 doesn't do
	       UNICODE, and this tool is specifically for 
	       unix interop support; unix machines don't
	       do unicode. */

	    wsprintfW( wUserName,
		       L"%hs",
		       UserName );

        /* 372818: must first detect if we're not on a DC
           and connect to one prior to calling NetUserGetInfo */

        err = DsGetDcNameW(
                  NULL,
                  NULL,
                  NULL,
                  NULL,
                  DS_RETURN_DNS_NAME,
                  &DomainControllerInfo
                  );

        if ( err != NO_ERROR ) {

            err = DsGetDcNameW(
                      NULL,
                      NULL,
                      NULL,
                      NULL,
                      DS_RETURN_FLAT_NAME,
                      &DomainControllerInfo
                      );
        }

        if ( err != NO_ERROR ) {

            fprintf( stderr,
                "ERROR: Can not locate a domain controller, "
                "error %d).\n", err );

            return -1;
        }

	    nas = NetUserGetInfo(
				  DomainControllerInfo->DomainControllerName,
				  wUserName,
				  1, // level 1
				  (PBYTE *) &pUserInfo );

        NetApiBufferFree( DomainControllerInfo );

	    if ( nas == NERR_Success ) {

	      WCHAR wPassword[ PWLEN ];

	      uacFlags = pUserInfo->usri1_flags;

	      if ( !( uacFlags & UF_NORMAL_ACCOUNT ) ) {
		
		/* 97282: For abnormal accounts (these include
		   workstation trust accounts, interdomain
		   trust accounts, server trust accounts),
		   ask the user if he/she really wants to
		   perform this operation. */

		if ( !WarnedAboutAccountStrangeness ) {

		  fprintf( stderr,
			   "WARNING: Account %hs is not a user account"
			   " (uacflags=0x%x).\n",
			   UserName,
			   uacFlags );
		  
		  WarnedAboutAccountStrangeness = TRUE;

		}

		fprintf( stderr,
			 "WARNING: Resetting %hs's password may"
			 " cause authentication problems if %hs"
			 " is being used as a server.\n",
			 
			 UserName,
			 UserName );

		if ( !UserWantsToDoItAnyway( "Reset %hs's password",
					     UserName ) ) {

		  /* Skip it, but try to do anything else the user
		     requested. */

		  goto skipSetPassword;

		}
	      }

	      wsprintfW( wPassword,
			 L"%hs",
			 Password );

	      pUserInfo->usri1_password = wPassword;

	      nas = NetUserSetInfo( NULL, // local
				    wUserName,
				    1, // level 1
				    (LPBYTE) pUserInfo,
				    NULL );

	      if ( nas == NERR_Success ) {

 skipSetPassword:
		NetApiBufferFree( pUserInfo );
		goto skipout;

	      } else {

		fprintf( stderr,
			 "Failed to set password for %ws: 0x%x.\n",
			 wUserName,
			 nas );

	      }
	    } else {

	      fprintf( stderr,
		       "Failed to retrieve user info for %ws: 0x%x.\n",
		       wUserName,
		       nas );

	    }

	    fprintf( stderr,
		     "Aborted.\n" );

	    return nas;
	  }

 skipout:

	  ASSERT( realm != NULL );

	  // physically separate the realm data.
	
	  ASSERT( *( realm -1 ) == '\0' );

	  if ( KtCreateKey( &pktEntry,
			    Principal,
			    Password,
			    realm,
			    kvno,
			    ptype,
			    Crypto, // this is the "fake" etype
			    Crypto ) ) {

	    if ( pktFile == NULL ) {

	      pktFile = NewKt();

	      if ( !pktFile ) {

		fprintf( stderr,
			 "Failed to allocate keytable.\n" );
		
		return 4;

	      }

	    }

	    if ( AddEntryToKeytab( pktFile,
				   pktEntry,
				   FALSE ) ) {

	      fprintf( stderr,
		       "Key created.\n" );

	    } else {

	      fprintf( stderr,
		       "Failed to add entry to keytab.\n" );
	      return 2;

	    }
	
	    if ( KtWriteFile ) {

	      fprintf( stderr,
		       "Output keytab to %hs:\n\n",
		       KtWriteFile );
	
	      DisplayKeytab( stderr, pktFile, 0xFFFFFFFF );

	      if ( !WriteKeytabToFile( pktFile, KtWriteFile ) ) {

		fprintf( stderr, "\n\n"
			 "Failed to write keytab file %hs.\n",
			 KtWriteFile );

		return 6;

	      }


	      // write keytab.
	
	    }
	  } else {

	    fprintf( stderr,
		     "Failed to create key for keytab.  Quitting.\n" );

	    return 7;

	  }

	  if ( UserName && DesOnly ) {

	    ASSERT( pLdap  != NULL );
	    ASSERT( UserDn != NULL );

	    // set the DES_ONLY flag

	    // first, query the account's account flags.

	    if ( uacFlags /* If we already queried the user's
			     AccountControl flags, no need to do it
			     again */
		 || QueryAccountControlFlagsA( pLdap,
					       NULL, // domain name is ignored
					       UserName,
					       &uacFlags ) ) {

	      uacFlags |= UF_USE_DES_KEY_ONLY;

	      if ( SetAccountControlFlagsA( pLdap,
					    NULL, // domain name is ignored
					    UserName,
					    uacFlags ) ) {

		fprintf( stderr, 
			 "Account %hs has been set for DES-only encryption.\n",
			 UserName );

		if ( !SetPassword ) {

		  fprintf( stderr,
			   "To make this take effect, you must change "
			   "%hs's password manually.\n",
			   
			   UserName );

		}

	      } // else message printed.
	    } // else message printed
	  }

	} // else user doesn't want me to make a key
	
	if ( !Password && !UserName ) {

	  fprintf( stderr,
		   "doing nothing.\n"
		   "specify /pass and/or /mapuser to either \n"
		   "make a key with the given password or \n"
		   "map a user to a particular SPN, respectively.\n" );

	}

	
      } else {

	fprintf( stderr,
		 "principal %hs doesn't contain an '@' symbol.\n"
		 "Looking for something of the form:\n"
		 "  foo@BAR.COM  or  xyz/foo@BAR.COM \n"
		 "     ^                    ^\n"
		 "     |                    |\n"
		 "     +--------------------+---- I didn't find these.\n",

		 Principal );

	return 1;
	
      }

    }
    else {
	printf("Type \"%s /help\" for usage\n", argv[0]);
    }

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\keytab\ldlib\delegtools.h ===
/*++

  DELEGTOOLS.H

  Copyright (C) 1998 Microsoft Corporation, all rights reserved.

  DESCRIPTION: tools for delegation.  These are required to make
               the delegation library work, and should make for
	       useful tools, so I separated the header in case
	       others wanted to use them.

  Created, Dec 22, 1998 by DavidCHR.

--*/ 

BOOL
ConnectAndBindToDefaultDsa( OUT PLDAP *ppLdap );


BOOL
LdapSearchForUniqueDnA( IN  PLDAP                  pLdap,
			IN  LPSTR                 SearchTerm,
			IN  LPSTR                *rzRequestedAttributes,
			OUT OPTIONAL LPSTR       *pDnOfObject,
			OUT OPTIONAL PLDAPMessage *ppMessage );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\keytab\ldlib\secprinc.c ===
/*++

  SECPRINC.C

  Code for setting security principal data in the DS--
  specifically, the UPN, SPN, and AltSecurityIdentity

  Copyright (C) 1998 Microsoft Corporation, all rights reserved.

  Created, Jun 18, 1998 by DavidCHR.

  CONTENTS: SetStringProperty
            FindUser
            SetUserData

--*/

#include "master.h"
#include "keytab.h"

#include <winldap.h>
#include <malloc.h>
#include "secprinc.h"
#include "delegtools.h"

extern BOOL /* delegation.c */
LdapFindAttributeInMessageA( IN  PLDAP            pLdap,
			     IN  PLDAPMessage     pMessage,
			     IN  LPSTR            PropertyName,
			     OUT OPTIONAL PULONG  pcbData,
			     OUT OPTIONAL PVOID  *ppvData );

/*****************************************************************
  NAME:      ConnectToDsa

  connects to the DSA, binds, and searches for the base DN.
  
  TAKES:     nothing
  RETURNS:   TRUE ( and a pLdap and wide-string baseDn ) on success
             FALSE and a stderr message on failure.
  CALLED BY: 
  FREE WITH: BaseDN should be freed with free(),
             the ldap handle should be closed with ldap_unbind.
  
 *****************************************************************/


BOOL
ConnectToDsa( OUT PLDAP  *ppLdap,
	      OUT LPSTR *BaseDN ) { // free with free()
	      
    PLDAP pLdap;
    BOOL  ret = FALSE;
    ULONG lderr;

    pLdap = ldap_open( NULL, LDAP_PORT );
    
    if ( pLdap ) {

      lderr = ldap_bind_s( pLdap, NULL, NULL, LDAP_AUTH_SSPI );

      if ( lderr == LDAP_SUCCESS ) {

	LPSTR       Context      = "defaultNamingContext";
	LPSTR       Attributes[] = { Context, NULL };
	PLDAPMessage pMessage, pEntry;
	LPSTR      *pValue;

	// now, guess the DSA Base:

	lderr = ldap_search_sA( pLdap,
				NULL,
				LDAP_SCOPE_BASE,
				"objectClass=*",
				Attributes,
				FALSE, // just return attributes
				&pMessage );

	if ( lderr == LDAP_SUCCESS ) {

	  pEntry = ldap_first_entry( pLdap, pMessage );

	  if ( pEntry ) {
	    
	    pValue = ldap_get_valuesA( pLdap, pEntry, Context );

	    if ( pValue ) {

	      ULONG size;

	      size = ldap_count_valuesA( pValue );

	      if ( 1 == size ) {
		
		LPSTR dn;
		size = ( lstrlenA( *pValue ) +1 /*null*/) * sizeof( WCHAR );

		dn = (LPSTR) malloc( size );
		
		if ( dn ) {

		  memcpy( dn, *pValue, size );
		  
		  *BaseDN = dn;
		  *ppLdap = pLdap;
		  ret     = TRUE;

		} else fprintf( stderr,
				"failed to malloc to duplicate \"%ws\".\n",
				*pValue );

	      } else fprintf( stderr,
			      "too many values (expected one, got %ld) for"
			      " %ws.\n",
			      size,
			      Context );

	      ldap_value_freeA( pValue );

	    } else fprintf( stderr,
			    "ldap_get_values failed: 0x%x.\n",
			    GetLastError() );

	  } else fprintf( stderr,
			  "ldap_first_entry failed: 0x%x.\n",
			  GetLastError() );

	  ldap_msgfree( pMessage );

	} else fprintf( stderr,
			"ldap_search failed (0x%x).  "
			"Couldn't search for base DN.\n",
			lderr );

	if ( !ret ) ldap_unbind_s( pLdap );

      } else fprintf( stderr,
		      "Failed to bind to DSA: 0x%x.\n",
		      lderr );

      // there is no ldap_disconnect.

    } else fprintf( stderr,
		    "Failed to contact DSA: 0x%x.\n",
		    GetLastError() );

    return ret;

}
	      
/*++**************************************************************
  NAME:      SetStringProperty

  sets the given property of the given object to the given string

  MODIFIES:  object's property value

  TAKES:     pLdap        -- ldap connection handle
             Dn           -- FQDN of the object whose property is munged
             PropertyName -- property to modify
             Property     -- value to put in the property
             Operation    -- set / add / delete, etc.


  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LASTERROR: set

  LOGGING:   on failure
  CREATED:   Jan 22, 1999
  LOCKING:   none
  CALLED BY: anyone
  FREE WITH: n/a  -- no resources are returned
  
 **************************************************************--*/

BOOL
SetStringProperty( IN PLDAP  pLdap,
		   IN LPSTR Dn,
		   IN LPSTR PropertyName,
		   IN LPSTR Property,
		   IN ULONG  Operation ) {

    LPSTR    Vals[] = { Property, NULL };
    LDAPModA  Mod    = { Operation,
			 PropertyName,
			 Vals };
    PLDAPModA Mods[] = { &Mod, NULL };
    ULONG     lderr;


    lderr = ldap_modify_sA( pLdap,
			    Dn,
			    Mods );

    if ( lderr == LDAP_SUCCESS ) {

      return TRUE;

    } else {
      
      fprintf( stderr, 
	       "Failed to set property \"%hs\" to \"%hs\" on Dn \"%hs\": "
	       "0x%x.\n",

	       PropertyName, 
	       Property,
	       Dn,
	       lderr );

      SetLastError( lderr );

    }
    
    return FALSE;
    
}

/*++**************************************************************
  NAME:      FindUser

  searches the DS for the given user.

  MODIFIES:  pDn       -- returned DN for that user.
	     puacflags -- receives the user's AccountControl flags

  TAKES:     pLdap     -- LDAP handle
             UserName  -- user samaccountname for which to search

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LASTERROR: not explicitly set
  LOGGING:   on failure
  CREATED:   Jan 22, 1999
  LOCKING:   none
  CALLED BY: anyone
  FREE WITH: free the dn with ldap_memfree
  
 **************************************************************--*/

BOOL
FindUser( IN  PLDAP pLdap,
	  IN  LPSTR UserName,
	  OUT PULONG puacFlags,
	  OUT LPSTR *pDn ) {

    LPSTR Query;
    BOOL  ret = FALSE;
    LPSTR Attributes[] = { "userAccountControl", 
			   NULL }; // what attributes to fetch; none
    PLDAPMessage pMessage = NULL;
    LPSTR        StringUac;

    Query = (LPSTR) malloc( lstrlenA( UserName ) + 100 ); // arbitrary

    if ( Query ) {

      wsprintfA( Query,
		 "(& (objectClass=person) (samaccountname=%hs))",
		 UserName );

      if( LdapSearchForUniqueDnA( pLdap,
				  Query,
				  Attributes,
				  pDn,
				  &pMessage ) ) {

	if ( LdapFindAttributeInMessageA( pLdap,
					  pMessage,
					  Attributes[ 0 ],
					  NULL, // length doesn't matter
					  &StringUac ) ) {

	  *puacFlags = strtoul( StringUac,
				NULL,
				0 );

	} else {

	  /* Signal the caller that we don't know the uacflags. */
	  *puacFlags = 0;

	}

	ret = TRUE;

      } else {

	fprintf( stderr, 
		 "Failed to locate user \"%hs\".\n",
		 Query );

      }

      if ( pMessage ) ldap_msgfree( pMessage );
      free( Query );

    } else {

      fprintf( stderr,
	       "allocation failed building query for LDAP search.\n" );

    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\keytab\ldlib\delegation.h ===
/*+
 *	FileName: delegation.h
 *	Author:   RuiM
 *	Copyright (c) 1998 Microsoft Corp.
 *
 *	Description:
 *	Simple API to either turn on or off a computer's
 *	delegation trust flag through ldap.
-*/


#ifdef __cplusplus
extern "C" {
#endif

BOOL
TrustComputerForDelegationW(
        IN LPWSTR lpComputerName,
        IN BOOL   OnOff
    );

BOOL
TrustComputerForDelegationA(
        IN LPSTR  lpComputerName,
        IN BOOL   OnOff
    );

/*++

Routine Description:

    This API turns on or off the computer
    delegation trust value in the domain.
    The computer name is passed in, and the
    operation is performed through the ldap
    provider.

Arguments:

    lpComputerName - computer name to turn on
        off the delegation trust.

    OnOff - boolean to specify whether to turn
        on or off the delegation trust.

Return Value:

    TRUE if the operation succeeded,
    FALSE otherwise.

--*/

#ifdef LDAP_CLIENT_DEFINED /* need to have included <winldap.h>
			      to use these related functions--
			      these are underlying functions for
			      the delegation trust. */

BOOL
SetAccountControlFlagsA( IN OPTIONAL PLDAP  pLdap,
			 IN OPTIONAL LPSTR DomainName,
			 IN          LPSTR SamAccountName,
			 IN          ULONG  AccountControlFlags );

BOOL
SetAccountControlFlagsW( IN OPTIONAL PLDAP  pLdap,
			 IN OPTIONAL LPWSTR DomainName,
			 IN          LPWSTR SamAccountName,
			 IN          ULONG  AccountControlFlags );
			     

BOOL
QueryAccountControlFlagsA( IN OPTIONAL PLDAP  pLdap,
			   IN OPTIONAL LPSTR DomainName, // ignored
			   IN          LPSTR SamAccountName,
			   OUT         PULONG pulControlFlags );


BOOL
QueryAccountControlFlagsW( IN OPTIONAL PLDAP  pLdap,
			   IN OPTIONAL LPWSTR DomainName, // ignored
			   IN          LPWSTR SamAccountName,
			   OUT         PULONG pulControlFlags );

#endif

#ifdef UNICODE
#define QueryAccountControlFlags   QueryAccountControlFlagsW
#define SetAccountControlFlags     SetAccountControlFlagsW
#define TrustComputerForDelegation TrustComputerForDelegationW
#else // ANSI
#define QueryAccountControlFlags   QueryAccountControlFlagsA
#define SetAccountControlFlags     SetAccountControlFlagsA
#define TrustComputerForDelegation TrustComputerForDelegationA
#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\keytab\ldlib\delegtools.c ===
/*++

  DELEGTOOLS.C

  Copyright (C) 1998 Microsoft Corporation, all rights reserved.

  DESCRIPTION: tools required to support the delegation library

  Created, Dec 22, 1998 by DavidCHR.

  CONTENTS: ConnectAndBindToDefaultDsa

--*/ 


#pragma warning(disable:4057) /* indirection to slightly different
				 base types.  Useless warning that hits
				 thousands of times in this file. */
#pragma warning(disable:4221) /* allow nonstandard extension (automatic 
				 initialization of a variable with 
				 address of another automatic variable) */

#include "unimacro.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdef.h>   // required to keep winbase.h from breaking
#include <ntpoapi.h> // required to keep winbase.h from breaking
#include <windows.h>
#include <winbase.h>
#include <lmaccess.h>
#include <winldap.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include "delegtools.h"


/*++**************************************************************
  NAME:      ConnectAndBindToDefaultDsa

  does just what the function name says.  We call the default
  DSA and bind to it.  We then return the ldap handle

  MODIFIES:  ppLdap -- PLDAP returned that describes the connection
                       (now bound) to the DSA as requested

  TAKES:     nothing

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LASTERROR: not set.

  LOGGING:   printf is called on failure

  CALLED BY: anyone
  FREE WITH: ldap_unbind
  
 **************************************************************--*/

BOOL
ConnectAndBindToDefaultDsa( OUT PLDAP *ppLdap ) {

    PLDAP pLdap;
    DWORD dwErr = (DWORD) STATUS_INTERNAL_ERROR;

    pLdap = ldap_open( NULL, LDAP_PORT );

    if ( pLdap ) {

      dwErr = ldap_bind_s( pLdap, NULL, NULL, LDAP_AUTH_NEGOTIATE );

      if ( dwErr == LDAP_SUCCESS ) {

	*ppLdap = pLdap;
	return TRUE;

      } else {

	printf( "FAIL: ldap_bind_s failed: 0x%x.\n",
		dwErr );

	SetLastError( dwErr );

      }

      /* note that there is no ldap_close-- we must unbind, 
	 even though we aren't actually bound.  */

      ldap_unbind( pLdap );
      
    } else {

      // ldap_open() sets lastError on failure. 

      printf( "FAIL: ldap_open failed for default server: 0x%x.\n",
	      GetLastError() );

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\keytab\ldlib\setprop.c ===
/*++

  SETPROP.C

  umappl to set properties.

  Copyright (C) 1998 Microsoft Corporation, all rights reserved.

  Created, Jun 18, 1998 by DavidCHR.

--*/


#include "master.h"
#include "keytab.h"

#include <winldap.h>
#include <malloc.h>
#include "secprinc.h"

#include "options.h"

int __cdecl
main( int argc,
      PCHAR argv[] ) {

    LPSTR TargetDn      = NULL;
    LPSTR PropertyName  = NULL;
    LPSTR PropertyValue = NULL;
    ULONG  Operation     = LDAP_MOD_ADD;

    optEnumStruct Operations[] = {

      { "Add",     (PVOID) LDAP_MOD_ADD,     "Add the value (default)" },
      { "Replace", (PVOID) LDAP_MOD_REPLACE, "change the value" },
      { "Delete",  (PVOID) LDAP_MOD_DELETE,  "Delete the value" },

      TERMINATE_ARRAY

    };

    optionStruct options[] = {

      { "?",  NULL, OPT_HELP },
      { "TargetDn", &TargetDn, OPT_STRING | OPT_NONNULL | OPT_DEFAULT,
	"target to set property of." },
      
      { "PropertyName", &PropertyName, 
	OPT_STRING | OPT_NONNULL | OPT_DEFAULT,
	"Name of the property we're setting." },

      { "PropertyVal",  &PropertyValue,
	OPT_STRING | OPT_NONNULL | OPT_DEFAULT,
	"Value we'll set the property to." },

      { "op", &Operation, OPT_ENUMERATED | OPT_ENUM_IS_MASK,
	"What to do to the object property",
	Operations },

      TERMINATE_ARRAY

    };
    
    PVOID  pvTrash;
    PLDAP  pLdap;
    LPSTR BaseDn;
    int    ret;

    ParseOptionsEx( argc-1,
		    argv+1,
		    options,
		    OPT_FLAG_TERMINATE,
		    &pvTrash,
		    NULL, NULL );

    if ( ConnectToDsa( &pLdap,
		       &BaseDn ) ) {

      free( BaseDn );

      if ( SetStringProperty( pLdap,
			      TargetDn,
			      PropertyName,
			      PropertyValue,
			      Operation ) ) {

	ret = 0;

	fprintf( stderr,
		 "success!\n" );

      } else ret = GetLastError();

      ldap_unbind( pLdap );

    } else ret = 3;

    return ret;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\keytab\ldlib\secprinc.h ===
/*++

  SECPRINC.H

  convenience routines for doing a few useful things

  Copyright (C) 1998 Microsoft Corporation, all rights reserved.

  Created, Jun 18, 1998 by DavidCHR.

--*/

BOOL
ConnectToDsa( OUT PLDAP  *ppLdap,
	      OUT LPSTR *BaseDN );

BOOL
SetStringProperty( IN PLDAP  pLdap,
		   IN LPSTR Dn,
		   IN LPSTR PropertyName,
		   IN LPSTR Property,
		   IN ULONG  Operation );

BOOL
FindUser( IN  PLDAP  pLdap,
	  IN  LPSTR  UserName,
	  OUT PULONG puacFlags,
	  OUT LPSTR *pDn );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\keytab\lib\keytypes.c ===
/*++

  Keytypes.cxx

  mostly large tables and table manipulation functions

  Copyright(C) 1997 Microsoft Corporation

  Created 01-15-1997 DavidCHR

  --*/


#include "master.h"
#include "defs.h"

#ifdef WINNT
#include <kerbcon.h>

#define PREFIX(POSTFIX) KERB_ETYPE_##POSTFIX

#else
#include <krb5.h>

#define PREFIX(POSTFIX) ENCTYPE_##POSTFIX

#endif

#include "keytypes.h"


static TRANSLATE_ENTRY NTKtype_to_MITKtypes[] = {

  PREFIX(NULL),        (PVOID) ENCTYPE_NULL,         
  PREFIX(DES_CBC_CRC), (PVOID) ENCTYPE_DES_CBC_CRC,  
  PREFIX(DES_CBC_MD4), (PVOID) ENCTYPE_DES_CBC_MD4,  
  PREFIX(DES_CBC_MD5), (PVOID) ENCTYPE_DES_CBC_MD5,  

  // ENCTYPE_DES_CBC_RAW,  
  // ENCTYPE_DES3_CBC_SHA, 
  // ENCTYPE_DES3_CBC_RAW, 
};

TRANSLATE_TABLE 
NTK_MITK5_Etypes = {
  
  sizeof( NTKtype_to_MITKtypes ) / sizeof( TRANSLATE_ENTRY ) ,
  NTKtype_to_MITKtypes,

  (PVOID) ENCTYPE_UNKNOWN

};

static TRANSLATE_ENTRY kerberos_NameTypes[] = {

  KRB5_NT_UNKNOWN,   "KRB5_NT_UNKNOWN",
  KRB5_NT_PRINCIPAL, "KRB5_NT_PRINCIPAL",
  KRB5_NT_SRV_INST,  "KRB5_NT_SRV_INST",
  KRB5_NT_SRV_HST,   "KRB5_NT_SRV_HST",
  KRB5_NT_SRV_XHST,  "KRB5_NT_SRV_XHST",
  KRB5_NT_UID,       "KRB5_NT_UID"

};

TRANSLATE_TABLE
K5PType_Strings = {

  sizeof( kerberos_NameTypes ) / sizeof (TRANSLATE_ENTRY),
  kerberos_NameTypes,
  /* DEFAULT */ "**Unknown**"

};

static TRANSLATE_ENTRY kerberos_keystringtypes[] = {

  ENCTYPE_NULL,         "None",
  ENCTYPE_DES_CBC_CRC,  "DES-CBC-CRC",
  ENCTYPE_DES_CBC_MD4,  "DES-CBC-MD4",
  ENCTYPE_DES_CBC_MD5,  "DES-CBC-MD5",
  ENCTYPE_DES_CBC_RAW,  "DES-CBC-RAW",
  ENCTYPE_DES3_CBC_SHA, "DES3-CBC-SHA",
  ENCTYPE_DES3_CBC_RAW, "DES3-CBC-RAW",

};

TRANSLATE_TABLE 
K5EType_Strings = {
  
  sizeof( kerberos_keystringtypes ) / sizeof (TRANSLATE_ENTRY),
  kerberos_keystringtypes,

  /* DEFAULT */ "Unknown"
};


/* LookupTable:

   returns the union in the table we're passed corresponding to
   the passed value.

   the wierd pointer tricks near both the returns are due to C++ being too
   picky with me.  Since I have to store the values as PVOIDs (can't auto-
   initialize a union, apparently), I have to cast a PVOID into a 
   TRANSLATE_VALUE, which is a difference of indirection.  

   So, instead, I cast its deref into a PTRANSLATE_VAL and reference it,
   which is apparently legal enough.  */

TRANSLATE_VAL 
LookupTable( IN KTLONG32            value ,
	     IN PTRANSLATE_TABLE table ) {

    KTLONG32 i;

    for (i = 0;
	 i < table->cEntries ;
	 i ++ ) {
      if (table->entries[i].value == value ) {
	return *( (PTRANSLATE_VAL) &(table->entries[i].Translation) );
      }
    }
	
    return * ( (PTRANSLATE_VAL) &(table->Default) );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\keytab\lib\keytab.c ===
/*++

  KEYTAB.C

  Implementation of the actual keytab routines.

  Copyright (C) 1997 Microsoft Corporation
  Created 01-10-1997 DavidCHR

  --*/

#include "master.h"
#include "keytab.h"
#include "keytypes.h"
#include "defs.h"

/* declaring KEYTAB_ALLOC and KEYTAB_FREE lets me hook into these
   routines whenever I want.  when it's done, I'll just #def them. */

PVOID 
KEYTAB_ALLOC ( KTLONG32 numBytes ) {

    return malloc(numBytes);

}

VOID
KEYTAB_FREE  ( PVOID toFree ) {

    free(toFree);

}

PKTENT
CloneKeyEntry( PKTENT pEntry ) {

    KTLONG32  i;
    PKTENT p=NULL;
    BOOL   ret=FALSE;

    p = (PKTENT) KEYTAB_ALLOC( sizeof( KTENT ) );
    BREAK_IF( p == NULL,
	      "Failed to alloc base key struct",
	      cleanup );
    memcpy(   p, pEntry, sizeof(KTENT) );

    p->Components = NULL; // initialize these in case of failure.
    p->KeyData    = NULL;

    p->Realm = (PCHAR) KEYTAB_ALLOC( p->szRealm );
    BREAK_IF( p->Realm == NULL, "Failed to alloc realm data", cleanup );
    memcpy(   p->Realm, pEntry->Realm, p->szRealm );

    p->Components = (PKTCOMPONENT) KEYTAB_ALLOC( p->cEntries * 
						 sizeof(KTCOMPONENT) );

    BREAK_IF( p->Components == NULL, "Failed to alloc components", cleanup );

    for ( i = 0 ; i < p->cEntries ; i++ ) {

      p->Components[i].szComponentData = 
	pEntry->Components[i].szComponentData;

      memcpy( p     ->Components[i].Component,
	      pEntry->Components[i].Component,
	      p     ->Components[i].szComponentData );
    }

    p->KeyData = (PK5_OCTET) KEYTAB_ALLOC ( p->KeyLength );
    BREAK_IF( p->KeyData == NULL, "Failed to alloc keydata", cleanup );
    memcpy( p->KeyData, pEntry->KeyData, p->KeyLength );

    return p;

cleanup:

    FreeKeyEntry(p);
    return NULL;
}


/* base linklist operations */

BOOL
AddEntryToKeytab( PKTFILE Keytab, 
		  PKTENT  Entry,
		  BOOL    copy ) {

    PKTENT p;

    if (copy) {
      p = CloneKeyEntry( Entry );
    } else {
      p = Entry;
    }

    if (p == NULL ) {
      return FALSE;
    }
	
    if ( NULL == Keytab->FirstKeyEntry ) {

      Keytab->FirstKeyEntry = Keytab->LastKeyEntry = p;

    } else {
      Keytab->LastKeyEntry->nextEntry = p;
      Keytab->LastKeyEntry = p;
    }
    
    return TRUE;
    
}

BOOL
RemoveEntryFromKeytab( PKTFILE Keytab,
		       PKTENT  Entry,
		       BOOL    dealloc ) {

    if ( (NULL == Keytab) || ( NULL == Entry ) ) {
      return FALSE;
    }
    
    if ( Keytab->FirstKeyEntry == Entry ) {
      
      // removing the first key
      
      Keytab->FirstKeyEntry = Entry->nextEntry;

      if ( Entry->nextEntry == NULL ) {
	// we're the ONLY entry.

	Keytab->LastKeyEntry = NULL;

      }

    } else {
      BOOL found=FALSE;
      PKTENT p;

      // scroll through the keys, looking for this one.
      // not very efficient, but keytabs shouldn't get very big.

      for (p =  Keytab->FirstKeyEntry;
	   p != NULL;
	   p =  p->nextEntry ) {
	
	if (p->nextEntry == Entry) {
	  found = TRUE;
	  p->nextEntry = Entry->nextEntry;
	  break;
	}
      }

      if (!found) {

	// wasn't in the linklist.
	return FALSE;
      }

      if (Entry->nextEntry == NULL ) {

	// removing the last key entry.
	Keytab->LastKeyEntry = p;
      }

    }

    if (dealloc) {

      FreeKeyEntry(Entry);

    }

    return TRUE;

}


VOID
FreeKeyEntry( PKTENT pEntry) {
    
    KTLONG32 i;

    if (pEntry != NULL) {

      if (pEntry->Realm != NULL ) {
	KEYTAB_FREE(pEntry->Realm);
      }
      
      if (pEntry->KeyData != NULL) {
	KEYTAB_FREE(pEntry->KeyData);
      }
      
      if (pEntry->Components != NULL) {
	for (i = 0; i < pEntry->cEntries ; i++ ) {
	  if ( pEntry->Components[i].Component != NULL ) {
	    KEYTAB_FREE(pEntry->Components[i].Component);
	  }
	}
	KEYTAB_FREE(pEntry->Components);
      }
      
      KEYTAB_FREE(pEntry );
    }
    
}

VOID 
FreeKeyTab( PKTFILE pktf ) {

    PKTENT pEntry=NULL;
    PKTENT next=NULL;

    if (pktf != NULL) {
      for (pEntry = pktf->FirstKeyEntry ;
	   pEntry != NULL;
	   pEntry = next ) {
	KTLONG32 i;

	next = pEntry->nextEntry; /* must do this, because we're freeing
				     as we go */
	FreeKeyEntry( pEntry );

	KEYTAB_FREE(pEntry );

      }
      KEYTAB_FREE(pktf);
    }

}

/* These macros make this somewhat LESS painful */

#define READ(readwhat, errormsg, statusmsg) { \
    debug(statusmsg); \
    BREAK_IF( !Read(hFile, &(readwhat), sizeof(readwhat), 1), \
	      errormsg, cleanup); \
    debug("ok\n"); \
}

#define READSTRING(readwhat, howlong, errormsg, statusmsg) { \
    debug(statusmsg); \
    BREAK_IF( !Read(hFile, readwhat, sizeof(CHAR), howlong), \
	      errormsg, cleanup); \
    debug("ok\n"); \
}

#define WRITE(writewhat, description) { \
    debug("writing %hs...", description); \
    BREAK_IF( !Write(hFile, &(writewhat), sizeof(writewhat), 1), \
	      "error writing " description, cleanup); \
    debug("ok\n"); \
}

#define WRITE_STRING(writewhat, howlong, description) { \
    debug("writing %hs...", description); \
    BREAK_IF( !Write(hFile, writewhat, sizeof(CHAR), howlong), \
	      "error writing " description, cleanup); \
    debug("ok\n"); \
}

#define WRITE_X( size, marshaller, writewhat, description ) { \
    K5_INT##size k5_marshaller_variable; \
    k5_marshaller_variable = marshaller( writewhat );\
    WRITE( k5_marshaller_variable, description );\
}

// NBO-- Network Byte Order

#define WRITE_NBO( writewhat, description) {\
    switch( sizeof( writewhat ) ) {\
     case 1: /* marshall a char? */\
	 debug("marshalling a char(?)...");\
	 WRITE( writewhat, description );\
	 break;\
     case 2:\
	 debug( #writewhat ": marshalling a short...");\
	 WRITE_X( 16, htons, ((unsigned short)writewhat), description);\
	 break;\
     case 4:\
	 debug( #writewhat ": marshalling a long...");\
	 WRITE_X( 32, htonl, writewhat, description);\
	 break;\
     default:\
      fprintf(stderr, "Not written: argument is of unhandled size (%d)\n",\
	      sizeof(writewhat));\
    }}

			       
    
/* Write:

   helper function to write raw bytes to disk.  Takes:

   hFile:      handle to a file open for writing.
   source:     pointer to data to be written to the file
   szSource:   size of one data element in Source
   numSources: number of data elements in Source

   (basically, it tries to write szSource * numSources of raw bytes
    from source to the file at hFile).

   returns TRUE if it succeeds, and FALSE otherwise.

   */
   
BOOL 
Write( IN HANDLE hFile,
       IN PVOID  source,
       IN KTLONG32  szSource,
       IN KTLONG32  numSources /* =1 */ ) {

#ifdef WINNT /* Windows NT implementation of the file write call */

    KTLONG32 temp;
    KTLONG32 i;

    temp = szSource * numSources;

    debug("(writing %d bytes: ", temp );
    for (i = 0; i < temp ; i++ ) {

      unsigned char byte;

      byte = ((PCHAR) source)[i];

      debug("%02x", byte );
    }
    debug(")");

    return WriteFile( hFile, source, temp, &temp, NULL );

#else

    ssize_t bytesToWrite, bytesWritten;

    bytesToWrite = szSource * numSources;
    bytesWritten = write( hFile, (const void *)source, 
			  bytesToWrite );

    if( bytesWritten == -1 ) {
      debug("WARNING: nothing written to the file!  Errno = 0x%x / %d\n",
	    errno , errno );
      return FALSE;
    }

    if ( bytesWritten != bytesToWrite ) {
      debug("WARNING: not all bytes made it to the file (?)\n"
	    "         errno = 0x%x / %d\n", errno, errno );
      return FALSE;
    }

    return TRUE;

#endif

}

/* Read:

   Semantics and return are the same as for "Write", except that
   target is filled with szTarget*numTargets bytes from hFile, and that
   hFile must be open for read access.

   */

BOOL 
Read( IN  HANDLE hFile,
      OUT PVOID  target,
      IN  KTLONG32  szTarget,
      IN  KTLONG32  numTargets/* =1 */) {

    BOOL ret = FALSE;

#ifdef WINNT /* the SetFilePointer shinanigens are me trying to check on
		how many bytes have ACTUALLY been read/written from the
		file */

    KTLONG32 temp;
    KTLONG32 filepos;
    LONG  zero=0L;

    filepos = SetFilePointer( hFile, 0, &zero, FILE_CURRENT);

    debug("reading %d bytes from pos 0x%x...", szTarget * numTargets,
	  filepos);
    
    ret = ReadFile( hFile, target, (szTarget*numTargets),
		    &temp, NULL );

    temp = SetFilePointer( hFile, 0, &zero, FILE_CURRENT);

    if ( filepos == temp ) {
      debug("WARNING!  file position has not changed!");
      return FALSE;
    }

#else /* UNIX IMPLEMENTATION-- since read() returns the number of bytes
	                       that we actually read from the file, the
			       SetFilePointer (fseek) nonsense is not
			       required. */

    ssize_t bytesRead;
    ssize_t bytesToRead;

    bytesToRead = szTarget * numTargets;
    
    bytesRead = read( hFile, target, bytesToRead );
    
    if ( bytesRead == -1 ) {
      debug("WARNING!  An error occurred while writing to the file!\n"
	    "ERRNO: 0x%x / %d.\n", errno, errno );

    }

    ret = (bytesRead == bytesToRead );

#endif

    return ret;
}

BOOL
ReadKeytabFromFile( PKTFILE *ppktfile, // free with FreeKeyTab when done
		    PCHAR    filename ) {

    PKTFILE  ktfile=NULL;
    HANDLE   hFile;
    BOOL     ret=FALSE;
    KTLONG32    i;

    BREAK_IF( ppktfile == NULL,
	      "passed a NULL save-pointer",
	      cleanup );

    debug("Opening keytab file \"%hs\"...", filename);

#ifdef WINNT
    hFile = CreateFileA( filename, 
			 GENERIC_READ,
			 FILE_SHARE_READ,
			 NULL,
			 OPEN_EXISTING,
			 FILE_ATTRIBUTE_NORMAL,
			 NULL );

    BREAK_IF ( (NULL == hFile) || ( INVALID_HANDLE_VALUE == hFile ),
	       "Failed to open file!", cleanup );

#else
    
    hFile = open( filename, O_RDONLY, 
		  /* file mask is 0x550: read-write by user and group */
		  S_IWUSR | S_IRUSR | S_IWGRP | S_IRGRP );
		  
    BREAK_IF( hFile == -1,
	      "Failed to open file!", cleanup );

#endif

    debug("ok!\n");

    ktfile = (PKTFILE) KEYTAB_ALLOC (sizeof(KTFILE));

    /* Prefix bug 439480 resulted from the below BREAK_IF
       being interchanged with initialization code.  Duhhh. */

    BREAK_IF( ktfile == NULL,
	      "Failed to allocate ktfile",
	      cleanup );

    ktfile->FirstKeyEntry = ktfile->LastKeyEntry = NULL;

    READ( ktfile->Version, "Failed to read KTVNO", 
	  "reading KTVNO");

    /* Version number is stored in network byte order */

    ktfile->Version = ntohs( ktfile->Version); 

    debug("Keytab version 0x%x\n", ktfile->Version );

    do {
      PKTENT entry=NULL;

      entry             = (PKTENT) KEYTAB_ALLOC(sizeof(KTENT));

      // PREFIX bug 439481: not checking the result of KEYTAB_ALLOC.

      BREAK_IF( !entry,
		"Unable to alloc a new KTENT.",
		cleanup );

      entry->Realm      = NULL;
      entry->Components = NULL;
      entry->KeyData    = NULL;
      entry->nextEntry  = NULL;

      BREAK_IF( !Read( hFile, &(entry->keySize), sizeof(entry->keySize), 1),
		"Failed to read leading bytes (probably done)", 
		no_more_entries );

      entry->keySize = htonl(entry->keySize);
      debug("trash bytes: 0x%x\n", entry->keySize );

      /* Quickly perform linklist operation on the new node */

      if (NULL == ktfile->FirstKeyEntry) {
	ktfile->FirstKeyEntry = ktfile->LastKeyEntry = entry;
      } else {
	ktfile->LastKeyEntry->nextEntry = entry;
	ktfile->LastKeyEntry = entry;
      }

      READ( entry->cEntries, 
	    "Failed to read key's number of components",
	    "reading key components...");

      entry->cEntries = ntohs( entry->cEntries );
      debug("components number %d\n", entry->cEntries );

      READ( entry->szRealm,
	    "Failed to read key's realm size",
	    "reading key realm size...");

      entry->szRealm = ntohs( entry->szRealm );
      debug("realm size %d\n", entry->szRealm);

      entry->Realm = (PCHAR) KEYTAB_ALLOC( entry->szRealm * sizeof(CHAR) );

      BREAK_IF ( !entry->Realm,
		 "Could not allocate key's realm storage",
		 cleanup );
      
      READSTRING( entry->Realm, entry->szRealm,
		  "Could not read key's realmname",
		  "reading realmname...");

      debug("realm: \"%hs\"\n", entry->Realm );
      entry->Components = (PKTCOMPONENT) KEYTAB_ALLOC (entry->cEntries * 
						sizeof(KTCOMPONENT));

      BREAK_IF( !entry->Components,
		"Could not allocate key components!",
		cleanup );

      for (i = 0 ; i < entry->cEntries ; i++ ) {

	READ( entry->Components[i].szComponentData,
	      "Failed to read component size for one entry",
	      "reading key component size...");

	entry->Components[i].szComponentData =
	  ntohs( entry->Components[i].szComponentData );

	debug("Component size: %d\n", 	
	      entry->Components[i].szComponentData );

	entry->Components[i].Component = (PCHAR) KEYTAB_ALLOC (
	     entry->Components[i].szComponentData *
	     sizeof(CHAR) );

	BREAK_IF( !entry->Components[i].Component,
		  "Could not allocate entry component storage",
		  cleanup );

	READSTRING( entry->Components[i].Component,
		    entry->Components[i].szComponentData,
		    "Failed to read component data",
		    "reading component data...");

	debug("Component data: \"%hs\"\n",
	      entry->Components[i].Component );

      }

      READ( entry->PrincType,
	    "Failed to read principal type",
	    "reading principal type...");
      
      entry->PrincType = ntohl( entry->PrincType ); // in network byte order
      debug("princtype: %d\n", entry->PrincType);

      READ( entry->TimeStamp,
	    "Failed to read entry timestamp",
	    "reading timestamp...");

      entry->TimeStamp = ntohl( entry->TimeStamp ); // also network bytes.
      debug("Timestamp 0x%x\n", entry->TimeStamp );

      READ( entry->Version,
	    "Failed to read kvno",
	    "reading kvno...");

      // kvno is in host order already.

      READ( entry->KeyType,
	    "Failed to read entry encryption type",
	    "reading encryption type...");

      entry->KeyType = ntohs( entry->KeyType );

      READ( entry->KeyLength,
	    "Failed to read entry keylength",
	    "reading keylength... ");

#if 1
      entry->KeyLength = ntohs ( entry->KeyLength );

#else // I used to think this was 32-bit.

      entry->KeyLength = ntohl ( entry->KeyLength );
#endif

      debug("KeyLength is %d\n", entry->KeyLength);

      entry->KeyData = (PK5_OCTET) KEYTAB_ALLOC (entry->KeyLength * 
					  sizeof(K5_OCTET));

      BREAK_IF( !entry->KeyData,
		"Could not allocate entry keydata storage",
		cleanup );

      READSTRING( entry->KeyData, entry->KeyLength,
		  "Failed to read entry key data",
		  "reading key data")

    } while (1);

no_more_entries:

    ret = TRUE;

cleanup:

#ifdef WINNT
    if ((hFile != NULL) && ( hFile != INVALID_HANDLE_VALUE)) {
      CloseHandle(hFile);
    }
#else
    if (hFile != -1 ) {
      close(hFile);
    }
#endif

    if (ret) {
      *ppktfile = ktfile;
    } else {
      FreeKeyTab( ktfile );
    }
    return ret;

}

/* define this macro only for DisplayKeytab.
   It's a convenience routine to print this field only if the option
   is set. */

#define PRINTFIELD( option, format, value ) { if (options & option) { fprintf(stream, format, value); } }    

/* DisplayKeytab:

   prints out the keytab, using options to define which fields we want
   to actually see.  (see keytab.hxx for what to put in "options") */

VOID
DisplayKeytab( FILE   *stream,
	       PKTFILE ktfile,
	       KTLONG32   options) {

    KTLONG32  i;
    PKTENT ent;



    if (options == 0L) {
      return;
    }

    PRINTFIELD(KT_KTVNO, "Keytab version: 0x%x\n", ktfile->Version);

    for (ent = ktfile->FirstKeyEntry ; 
	 ent != NULL;
	 ent = ent->nextEntry ) {

      PRINTFIELD( KT_RESERVED, "keysize %d ", ent->keySize );

      for (i = 0 ; i < ent->cEntries ; i++ ) {
	PRINTFIELD( KT_COMPONENTS,
		    (i == 0 ? "%hs" : "/%hs"), 
		    ent->Components[i].Component );
      }
      
      PRINTFIELD( KT_REALM, "@%hs", ent->Realm );
      PRINTFIELD( KT_PRINCTYPE, " ptype %d", ent->PrincType );
      PRINTFIELD( KT_PRINCTYPE, " (%hs)", LookupTable( ent->PrincType,
						       &K5PType_Strings ));
      PRINTFIELD( KT_VNO, " vno %d", ent->Version );
      PRINTFIELD( KT_KEYTYPE, " etype 0x%x", ent->KeyType );
      PRINTFIELD( KT_KEYTYPE, " (%hs)", LookupTable( ent->KeyType,
						     &K5EType_Strings ) );
      PRINTFIELD( KT_KEYLENGTH, " keylength %d", ent->KeyLength );
      
      if (options & KT_KEYDATA ) {

	fprintf(stream, " (0x" );
	for ( i = 0 ; i < ent->KeyLength ; i++ ) {
	  fprintf(stream, "%02x", ent->KeyData[i] );
	}
	fprintf(stream, ")" );
      }

      fprintf(stream, "\n");
    }
}

#undef PRINTFIELD // we only need it for that function

/* computes the length of a kerberos keytab for the keySize field */

K5_INT32
ComputeKeytabLength( PKTENT p ) {

    K5_INT32 ret=0L;
    KTLONG32    i;

    // these are the variables within this level

    ret = p->szRealm + p->KeyLength;

    // these are static

    ret += ( sizeof( p->cEntries )  + sizeof(p->szRealm)     +
	     sizeof( p->PrincType ) + sizeof( p->TimeStamp ) +
	     sizeof( p->Version )   + sizeof (p->KeyLength ) +
	     sizeof( p->KeyType )   );

    for (i = 0 ; i < p->cEntries; i++ ) {
      ret += ( p->Components[i].szComponentData + 
	       sizeof(p->Components[i].szComponentData) );
    }

    debug("ComputeKeytabLength: returning %d\n", ret);
    
    return ret;
}

/* This depends very much on the same keytab model that
   the other functions do */

BOOL
WriteKeytabToFile(  PKTFILE ktfile,
		    PCHAR   filename ) {
    
    HANDLE   hFile;
    BOOL     ret=FALSE;
    KTLONG32    i;
    PKTENT   entry;

    BREAK_IF( ktfile == NULL,
	      "passed a NULL save-pointer",
	      cleanup );

    debug("opening keytab file \"%hs\" for write...", filename);

#ifdef WINNT

    hFile = CreateFileA( filename, 
			 GENERIC_WRITE,
			 0L,
			 NULL,
			 CREATE_ALWAYS,
			 FILE_ATTRIBUTE_NORMAL,
			 NULL );

    BREAK_IF( ( hFile == INVALID_HANDLE_VALUE ), 
	      "Failed to create file!", cleanup );

#else
    hFile = open( filename, O_WRONLY | O_CREAT | O_TRUNC, 
		  /* file mask is 0x550: read-write by user and group */
		  S_IWUSR | S_IRUSR | S_IWGRP | S_IRGRP );
		  
    BREAK_IF( hFile == -1,
	      "Failed to create file!", cleanup );

#endif

    debug("ok\n");

    WRITE_NBO( ktfile->Version, "KTFVNO" );

    for( entry = ktfile->FirstKeyEntry ; 
	 entry != NULL ;
	 entry = entry->nextEntry ) {

      WRITE_NBO( entry->keySize, "key size (in bytes)");

      WRITE_NBO( entry->cEntries, "number of components" );
      WRITE_NBO( entry->szRealm,  "Realm length" );
      WRITE_STRING( entry->Realm, entry->szRealm, "Realm data" );
      
      for (i = 0 ; i < entry->cEntries ; i++ ) { 
	WRITE_NBO( entry->Components[i].szComponentData, 
		   "component datasize");
	WRITE_STRING( entry->Components[i].Component, 
		      entry->Components[i].szComponentData,
		      "component data");
      }

      WRITE_NBO( entry->PrincType, "Principal Type");
      WRITE_NBO( entry->TimeStamp, "Timestamp" );
      WRITE( entry->Version,      "Key Version Number" );
      WRITE_NBO( entry->KeyType,   "Key Encryption Type" );

#if 0 // eh?
      /* again, this is a kludge to get around the keylength
	 problem we can't explain */
#endif

      ASSERT( sizeof( entry->KeyLength ) == 2 );

      WRITE_NBO(entry->KeyLength, "key length" );

      WRITE_STRING( entry->KeyData, 
		    entry->KeyLength,
		    "key data itself" );
    }
    
    ret = TRUE;

cleanup:
    CloseHandle(hFile);

    return ret;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\keytab\ldlib\unimacro.h ===
/*++

  UNIMACRO.H

  Macros to handle unicode conversions and naming schemes for 
  unicode independent files.

  4/17/1997 DavidCHR, Created

  --*/

#ifdef UNICODE
#define U(functionName)           functionName##W
#define NU(functionName)          functionName##A
#define NTEXT( text )             text
#define LPNSTR                    LPSTR

#define UAWA                       "W"
#define UAWW                      L"W"
#define STR_FMTA                   "ws"
#define STR_FMTW                  L"ws"
#define STRING_FMTA                "%ws" // "%" STR_FMTA causes problems
#define STRING_FMTW               L"%ws" // L"%" STR_FMTW causes problems
#define WIDE_OR_ASCII( testname ) Wide_##testname 


#else /* NOT UNICODE */

#define U(functionName)           functionName##A
#define NU(functionName)          functionName##W
#define NTEXT( text )             L##text
#define LPNSTR                    LPWSTR

#define UAWA                       "A"
#define UAWW                      L"A"
#define STR_FMTA                   "hs"
#define STR_FMTW                  L"hs"
#define STRING_FMTA                "%hs" // "%" STR_FMTA causes problems
#define STRING_FMTW               L"%hs" // L"%" STR_FMTW causes problems
#define WIDE_OR_ASCII( testname ) Ascii_##testname 


#endif /* UNICODE */

/* define these so that you can use TEXT(UAW) and TEXT(STRING_FMT) */

#define LUAW                      UAWW
#define UAW                       UAWA
#define LSTRING_FMT               STRING_FMTW
#define STRING_FMT                STRING_FMTA

/* evidently someone has failed to put these definitions
   where I could find them.  So I'm putting them all here. */

#define TFGETC                      U(TFGETC_)
#define TFGETC_W                    fgetwc
#define TFGETC_A                    fgetc

#define TFPUTC                      U(TFPUTC_)
#define TFPUTC_W                    fputwc
#define TFPUTC__A                    fputc

#define TGETCHAR                    U(TGETCHAR_)
#define TGETCHAR_A                  getchar
#define TGETCHAR_W                  getwchar

#define TPUTCHAR                    U(TPUTCHAR_)
#define TPUTCHAR_A                  putchar
#define TPUTCHAR_W                  putwchar

#define TFGETS                      U(TFGETS_)
#define TFGETS_A                    fgets
#define TFGETS_W                    fgetws

#define TFPUTS                      U(TFPUTS_)
#define TFPUTS_A                    fputs
#define TFPUTS_W                    fputws

#define TFPRINTF                    U(TFPRINTF_)
#define TFPRINTF_A                  fprintf
#define TFPRINTF_W                  fwprintf

#define TPRINTF                     U(TPRINTF_)
#define TPRINTF_A                   printf
#define TPRINTF_W                   wprintf

#define TSNPRINTF                   U(TSNPRINTF_)
#define TSNPRINTF_A                 snprintf
#define TSNPRINTF_W                 _snwprintf

#define TSPRINTF                    U(TSPRINTF_)
#define TSPRINTF_A                  sprintf
#define TSPRINTF_W                  swprintf

#define TVSNPRINTF                  U(TVSNPRINTF_)
#define TVSNPRINTF_A                _vsnprintf
#define TVSNPRINTF_W                _vsnwprintf

#define TVSPRINTF                   U(TVSPRINTF_)
#define TVSPRINTF_A                 vsprintf
#define TVSPRINTF_W                 vswprintf

#define TFSCANF                     U(TFSCANF_)
#define TFSCANF_A                   fscanf
#define TFSCANF_W                   fwscanf

#define TSSCANF                     U(TSSCANF_)
#define TSSCANF_A                   sscanf
#define TSSCANF_W                   swscanf

#define TSCANF                      U(TSCANF_)
#define TSCANF_A                    scanf
#define TSCANF_W                    wscanf

#define TFOPEN                      U(TFOPEN_)
#define TFOPEN_A                    fopen
#define TFOPEN_W                    _wfopen

#define TFREOPEN                    U(TFREOPEN_)
#define TFREOPEN_A                  freopen
#define TFREOPEN_W                  _wfreopen

#define TATOI                       U(TATOI_)
#define TATOI_A                     atoi
#define TATOI_W                     _wtoi

#define TATOL                       U(TATOL_)
#define TATOL_A                     atol
#define TATOL_W                     _wtol

#define TATOLD                      U(TATOLD_)
#define TATOLD_A                    atold
#define TATOLD_W                    _wtold

#define TSTRTOD                     U(TSTRTOD_)
#define TSTRTOD_A                   strtod
#define TSTRTOD_W                   wcstod

#define TSTRTOL                     U(TSTRTOL_)
#define TSTRTOL_A                   strtol
#define TSTRTOL_W                   wcstol

#define TSTRTOUL                    U(TSTRTOUL_)
#define TSTRTOUL_A                  strtoul
#define TSTRTOUL_W                  wcstoul

#define TVFPRINTF                   U(TVFPRINTF_)
#define TVFPRINTF_A                 vfprintf
#define TVFPRINTF_W                 vfwprintf

#define TVPRINTF                    U(TVPRINTF_)
#define TVPRINTF_A                  vprintf
#define TVPRINTF_W                  vwprintf

#define TSTRCAT                     U(TSTRCAT_)
#define TSTRCAT_A                   strcat
#define TSTRCAT_W                   wcscat

#define TSTRCHR                     U(TSTRCHR_)
#define TSTRCHR_A                   strchr
#define TSTRCHR_W                   wcschr

#define TSTRRCHR                     U(TSTRRCHR_)
#define TSTRRCHR_A                   strrchr
#define TSTRRCHR_W                   wcsrchr

#define TSTRCMP                     U(TSTRCMP_)
#define TSTRCMP_A                   strcmp
#define TSTRCMP_W                   wcscmp

#define TSTRCPY                     U(TSTRCPY_)
#define TSTRCPY_A                   strcpy
#define TSTRCPY_W                   wcscpy

#define TSTRLEN                     U(TSTRLEN_)
#define TSTRLEN_A                   strlen
#define TSTRLEN_W                   wcslen

#define TSTRNCMP                    U(TSTRNCMP_)
#define TSTRNCMP_A                  strncmp
#define TSTRNCMP_W                  wcsncmp

#define TSTRCMPI                    U(TSTRCMPI_)
#define TSTRCMPI_A                  strcmpi
#define TSTRCMPI_W                  wcscmpi

#define TSTRSTR                     U(TSTRSTR_)
#define TSTRSTR_A                   strstr
#define TSTRSTR_W                   wcsstr

#define TSTRTOK                     U(TSTRTOK_)
#define TSTRTOK_A                   strtok
#define TSTRTOK_W                   wcstok

#define TSTRDUP                     U(TSTRDUP_)
#define TSTRDUP_A                   strdup
#define TSTRDUP_W                   wcsdup

#define TSTRICMP                    U(TSTRICMP_)
#define TSTRICMP_A                  strcmpi
#define TSTRICMP_W                  wcscmpi

#define TSTRNICMP                   U(TSTRNICMP_)
#define TSTRNICMP_A                 strnicmp
#define TSTRNICMP_W                 wcsnicmp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\keytab\lib\keytypes.h ===
/*++

  Keytypes.hxx

  mostly large tables and table manipulation functions

  Copyright(C) 1997 Microsoft Corporation

  Created 01-15-1997 DavidCHR

  --*/


/* The following values are taken directly from <krb5.h> of the MIT
   Kerberos Distribution.  */

/* per Kerberos v5 protocol spec */
#define ENCTYPE_NULL            0x0000
#define ENCTYPE_DES_CBC_CRC     0x0001  /* DES cbc mode with CRC-32 */
#define ENCTYPE_DES_CBC_MD4     0x0002  /* DES cbc mode with RSA-MD4 */
#define ENCTYPE_DES_CBC_MD5     0x0003  /* DES cbc mode with RSA-MD5 */
#define ENCTYPE_DES_CBC_RAW     0x0004  /* DES cbc mode raw */
#define ENCTYPE_DES3_CBC_SHA    0x0005  /* DES-3 cbc mode with NIST-SHA */
#define ENCTYPE_DES3_CBC_RAW    0x0006  /* DES-3 cbc mode raw */
#define ENCTYPE_UNKNOWN         0x01ff

#define CKSUMTYPE_CRC32         0x0001
#define CKSUMTYPE_RSA_MD4       0x0002
#define CKSUMTYPE_RSA_MD4_DES   0x0003
#define CKSUMTYPE_DESCBC        0x0004
/* des-mac-k */
/* rsa-md4-des-k */
#define CKSUMTYPE_RSA_MD5       0x0007
#define CKSUMTYPE_RSA_MD5_DES   0x0008
#define CKSUMTYPE_NIST_SHA      0x0009
#define CKSUMTYPE_HMAC_SHA      0x000a

#define KRB5_NT_UNKNOWN   0
#define KRB5_NT_PRINCIPAL 1
#define KRB5_NT_SRV_INST  2
#define KRB5_NT_SRV_HST   3
#define KRB5_NT_SRV_XHST  4
#define KRB5_NT_UID       5

  
// (end of inclusion)


typedef union {

  PVOID raw;
  PCHAR string;
  ULONG integer;

} TRANSLATE_VAL, *PTRANSLATE_VAL;

typedef struct {
  
  ULONG value;
  PVOID Translation;

} TRANSLATE_ENTRY, *PTRANSLATE_ENTRY;

typedef struct {

  ULONG            cEntries;
  PTRANSLATE_ENTRY entries;
  PVOID            Default;

} TRANSLATE_TABLE, *PTRANSLATE_TABLE;

extern TRANSLATE_TABLE NTK_MITK5_Etypes;
extern TRANSLATE_TABLE K5EType_Strings;
extern TRANSLATE_TABLE K5PType_Strings;


TRANSLATE_VAL 
LookupTable( IN ULONG            valueToLookup,
	     IN PTRANSLATE_TABLE tableToLookupIn );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\keytab\lib\utest.c ===
#include "master.h"
#include "keytab.h"

int __cdecl 
main( int argc,
    PCHAR argv[] ) {


    fprintf( stderr, "sizeof K5_INT16 = %d.\n", 
            sizeof( K5_INT16 ));

    return 0;    

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\keytab\lib\utest2.c ===
#include "master.h"
#include "keytab.h"


#define CHECK( what, fieldname ) {         \
    printf( "\n" #what " " #fieldname ".\n" );   \
    printf( "sizeof " #what " is %d.\n", sizeof( what ) );  \
    printf( "sizeof k." #fieldname " is %d.\n", sizeof( k.fieldname ) ); \
    printf( "sizeof pk->" #fieldname " is %d.\n", sizeof( pk->fieldname ) );\
}

int __cdecl
main( int argc, PCHAR argv[] ) {

    KTENT k;
    PKTENT pk;

    pk = &k;

    CHECK( K5_INT32, keySize );
    CHECK( K5_INT16, cEntries );
    CHECK( K5_INT16, szRealm );
    CHECK( K5_INT32, PrincType );
    CHECK( K5_TIMESTAMP, TimeStamp );
    CHECK( K5_INT16, KeyType );
    CHECK( K5_INT16, KeyLength );

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\keytab\lib\mkkey.c ===
/*++

  mkkey.c

  routines to create the key in the keytab.

  3/27/1997 - Created from routines in munge.c,  DavidCHR

  CONTENTS: CreateUnicodeStringFromAnsiString

  --*/

#include "master.h"
#include "defs.h"
#include "keytab.h"
#include "keytypes.h"

/******************************************************************
 * hack to preserve our debugging macro because asn1code.h        *
 *  will redefine it... egads, I thought everyone used DEBUG      *
 *  only for debugging... (it still ends up redefined...)         *
 ******************************************************************/
#ifdef DEBUG
#define OLDDEBUG DEBUG
#endif

#include <kerbcon.h>
#undef _KERBCOMM_H_    /* WASBUG 73905 */
#include "kerbcomm.h"

#undef DEBUG

#ifdef OLDDEBUG
#define DEBUG OLDDEBUG
#endif

/******************************************************************/
BOOL KtDumpSalt = (
#if DBG
     TRUE
#else
     FALSE
#endif
     );

/* This is the character we separate principal components with */

#define COMPONENT_SEPARATOR '/'

/*++**************************************************************
  NAME:      CreateUnicodeStringFromAnsiString

  allocates a unicode string from an ANSI string.

  MODIFIES:  ppUnicodeString -- returned unicode string
  TAKES:     AnsiString      -- ansi string to convert

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LASTERROR: not set

  LOGGING:   fprintf on failure
  CREATED:   Feb 8, 1999
  LOCKING:   none
  CALLED BY: anyone
  FREE WITH: free()

 **************************************************************--*/

BOOL
CreateUnicodeStringFromAnsiString( IN  PCHAR           AnsiString,
				   OUT PUNICODE_STRING *ppUnicodeString ) {

    USHORT          StringLength;
    LPBYTE          pbString;
    PUNICODE_STRING pu;

    StringLength = (USHORT)lstrlen( AnsiString ); // does not include null byte

    pbString = (PBYTE) malloc( ( ( ( StringLength ) +1 ) * sizeof( WCHAR ) ) +
			       sizeof( UNICODE_STRING ) );

    if ( pbString ) {

      pu                = (PUNICODE_STRING) pbString;
      pbString         += sizeof( *pu );
      pu->Buffer        = (LPWSTR) pbString;
      pu->Length        = StringLength * sizeof( WCHAR );
      pu->MaximumLength = pu->Length + sizeof( WCHAR );

      wsprintfW( pu->Buffer,
		 L"%hs",
		 AnsiString );

      *ppUnicodeString = pu;

      return TRUE;

    } else {

      fprintf( stderr,
	       "Failed to make unicode string from \"%hs\".\n",
	       AnsiString );

    }

    return FALSE;

}
			



/*  KtCreateKey:

    create a keytab entry from the given data.
    returns TRUE on success, FALSE on failure.

    *ppKeyEntry must be freed with FreeKeyEntry when you're done with it.

    */

LPWSTR RawHash = NULL;

BOOL
KtCreateKey( PKTENT  *ppKeyEntry,
	     PCHAR    principal,
	     PCHAR    password,
	     PCHAR    realmname,
	
	     K5_OCTET keyVersionNumber,
	     ULONG    principalType,
	     ULONG    keyType,
	     ULONG    cryptosystem
	
	     ) {

    PKTENT              pEntry           = NULL;
    PCHAR               ioBuffer         = NULL;
    ULONG               i;
    ULONG               compCounter      = 0;
    USHORT              buffCounter      = 0;
    BOOL                ret              = FALSE;
    BOOL                FreeUnicodeSalt  = FALSE;

    UNICODE_STRING      UnicodePassword  = { 0 };
    UNICODE_STRING      UnicodePrincipal = { 0 };
    UNICODE_STRING      UnicodeSalt      = { 0 };
    PWCHAR              tmpUnicodeBuffer = NULL;
    KERB_ENCRYPTION_KEY KerbKey          = { 0 };
    WCHAR               wSaltBuffer      [BUFFER_SIZE];

#ifdef BUILD_SALT
    LONG32              saltCounter      = 0;
    CHAR                saltBuffer       [BUFFER_SIZE];
#endif

    /* you must actually provide these parameters */

    ASSERT( ppKeyEntry != NULL );
    ASSERT( principal  != NULL );
    ASSERT( realmname  != NULL );
    ASSERT( password   != NULL );

    ASSERT( strlen( password ) < BUFFER_SIZE );
    ASSERT( strlen( principal ) < BUFFER_SIZE );
    ASSERT( strlen( realmname ) < BUFFER_SIZE );

#ifdef BUILD_SALT
    /* if we're building the salt ourselves, initialize the keysalt */
    sprintf( saltBuffer, "%s", realmname );
    saltCounter = strlen( realmname );
#endif

    BREAK_IF( !ONEALLOC( pEntry, KTENT, KEYTAB_ALLOC),
	      "Failed to allocate base keytab element",
	      cleanup );

    /* zero out the structure, so we know what we have and
       haven't allocated if the function fails */

    memset( pEntry, 0, sizeof( KTENT ) );

    /* first, count the principal components */

    for( i = 0 ; principal[i] != '\0' ; i++ ) {
      if (principal[i] == COMPONENT_SEPARATOR) {
	pEntry->cEntries++;
      }
    }

    pEntry->cEntries++; /* don't forget the final component, which is not
			   bounded by the separator, but by the NULL */

    BREAK_IF( !MYALLOC( pEntry->Components, KTCOMPONENT,
			pEntry->cEntries,   KEYTAB_ALLOC ),
	      "Failed to allocate keytab component vector",
	      cleanup );

    /* allocate the buffer for the principal components.
       We allocate it the same size as the principal, because
       that's the maximum size any single component could be--
       the principal could be a one component princ. */

    BREAK_IF( !MYALLOC( ioBuffer,            CHAR,
			strlen(principal)+1, KEYTAB_ALLOC ),
	      "Failed to allocate local buffer for storage",
	      cleanup );

    /* now, we copy the components themselves, using the iobuffer to
       marshall the individual data elements--

       basically, add a char to the iobuffer for every char in the principal
       until you hit a / (component separator) or the trailing null.

       in those cases, we now know the size of the component and we have
       the text in a local buffer.  allocate a buffer for it, save the size
       and strcpy the data itself.  */

    i = 0;

    do {

      debug( "%c", principal[i] );

      if( (principal[i] == COMPONENT_SEPARATOR) ||
	  (principal[i] == '\0' /* delimit final component */ ) ) {
	
	/* this component is done. Save and reset the buffer. */

	pEntry->Components[compCounter].szComponentData = buffCounter;
	
	debug( " --> component boundary for component %d.\n"
	       " size = %d, value = %s\n",

	       compCounter, buffCounter, ioBuffer );

	BREAK_IF( !MYALLOC( pEntry->Components[compCounter].Component,
			    CHAR,   buffCounter+1,      KEYTAB_ALLOC ),
		  "Failed to allocate marshalled component data",
		  cleanup );

	memcpy( pEntry->Components[compCounter].Component,
		ioBuffer, buffCounter );

	pEntry->Components[compCounter].Component[buffCounter] = '\0';
	buffCounter                                           = 0;
	compCounter ++;

      } else {

	ioBuffer[buffCounter] = principal[i];
	buffCounter++;

#ifdef BUILD_SALT

	/* also send the principal characters WITHOUT SLASHES
	   to the salt initializer.

	   WASBUG 73909: the %wc doesn't look right here.
	   Sure enough, it wasn't.  So we removed it. */
	
	sprintf( saltBuffer+saltCounter,  "%c",  principal[i] );
	ASSERT( saltCounter < BUFFER_SIZE );  /* not a very strong assert,
						 but useful */
	saltCounter ++;
	ASSERT( saltBuffer[saltCounter] == '\0' ); /* assert that it stays
						       null terminated at the
						       saltCounter */
						
#endif

      }

      i++;

    } while ( principal[i-1] != '\0' );


    /* there's still a component in the buffer.  Save that component
       by assigning the pointer, rather than allocating more memory.

       WASBUG 73911: may waste large amounts of memory if the principal is
       really big.  However, it probably won't be-- we're talking about
       strings that humans would generally have to type, so the waste is
       going to be in bytes.  Also, most of the time, the last component
       is the biggest; of the form:

       sample/<hostname>  or host/<hostname>

       ...hostname is generally going to be much larger than sample or host.

       */

    pEntry->Components[compCounter].szComponentData = buffCounter;
    pEntry->Components[compCounter].Component       = ioBuffer;
    ioBuffer[buffCounter]                           = '\0';
    ioBuffer                                        = NULL; /* keep from
							       deallocating */
    pEntry->Version                                 = keyVersionNumber;
    pEntry->szRealm                                 = (K5_INT16) strlen(realmname);
    pEntry->KeyType                                 = (unsigned short)keyType;
    pEntry->PrincType                               = principalType;

    /* copy the realm name */

    BREAK_IF( !MYALLOC( pEntry->Realm, CHAR, pEntry->szRealm+1, KEYTAB_ALLOC),
	      "Failed to allocate destination realm data", cleanup );

    memcpy( pEntry->Realm, realmname, pEntry->szRealm+1 ); /* copy the null */



    /***********************************************************************/
    /***                                                                 ***/
    /***                  Windows NT Key Creation Side                   ***/
    /***                                                                 ***/
    /***********************************************************************/

    /* create unicode variants of the input parameters */

    BREAK_IF( !MYALLOC( tmpUnicodeBuffer,     WCHAR,
			strlen( password )+1, KEYTAB_ALLOC ),
	      "Failed to alloc buffer for password", cleanup );

    wsprintfW( tmpUnicodeBuffer, L"%hs", password );
    RtlInitUnicodeString( &UnicodePassword, tmpUnicodeBuffer );


    BREAK_IF( !MYALLOC( tmpUnicodeBuffer,     WCHAR,
			strlen( principal )+1, KEYTAB_ALLOC ),
	      "Failed to alloc buffer for principal", cleanup );

    wsprintfW( tmpUnicodeBuffer, L"%hs", principal );
    RtlInitUnicodeString( &UnicodePrincipal, tmpUnicodeBuffer );

    wsprintfW( wSaltBuffer, L"%hs", realmname );

    RtlInitUnicodeString( &UnicodeSalt, wSaltBuffer );

    {
      KERB_ACCOUNT_TYPE acctType;

      acctType = UnknownAccount;

      if ( RawHash ) {

	if ( KtDumpSalt ) {

	  fprintf( stderr,
		   "Using supplied salt.\n" );

	}

	RtlInitUnicodeString( &UnicodeSalt,
			      RawHash );

      } else {

	PUNICODE_STRING pRealmString;

	if ( CreateUnicodeStringFromAnsiString( realmname,
						&pRealmString ) ) {

	  KERBERR kerberr;

	  if ( KtDumpSalt ) {

	    fprintf( stderr,
		     "Building salt with principalname %wZ"
		     " and domain %wZ...\n",
		     &UnicodePrincipal,
		     pRealmString );

	  }

	  debug( "KerbBuildKeySalt( Realm    = %wZ\n"
		 "                  Princ    = %wZ\n"
		 "                  acctType = %d.\n",
	
		 pRealmString,
		 &UnicodePrincipal,
		 acctType );

	  kerberr = KerbBuildKeySalt( pRealmString,
				      &UnicodePrincipal,
				      acctType,
				      &UnicodeSalt );

	  free( pRealmString );

	  BREAK_IF( kerberr,
		    "Failed to KerbBuildKeySalt",
		    cleanup );

	  FreeUnicodeSalt = TRUE;

	}
      }
    } // scope block.

    if ( KtDumpSalt ) {

      fprintf( stderr,
	       "Hashing password with salt \"%wZ\".\n",
	       &UnicodeSalt );

    }

    debug( "KerbHashPasswordEx( UnicodePassword = %wZ \n"
	   "                    UnicodeSalt     = %wZ \n"
	   "                    cryptosystem    = 0x%x\n"
	   "                    &KerbKey        = 0x%p )...\n",

	   &UnicodePassword,
	   &UnicodeSalt,
	   cryptosystem,
	   &KerbKey );

    BREAK_IF( KerbHashPasswordEx( &UnicodePassword,
				  &UnicodeSalt,
				  cryptosystem,
				  &KerbKey ),
	      "KerbHashPasswordEx failed.",
	      cleanup );

    pEntry->KeyLength = (USHORT)KerbKey.keyvalue.length;

    BREAK_IF( !MYALLOC( pEntry->KeyData, K5_OCTET,
			pEntry->KeyLength, KEYTAB_ALLOC ),
	      "Failed to allocate keydata", cleanup );

    memcpy( pEntry->KeyData, KerbKey.keyvalue.value,
	    pEntry->KeyLength );

    /* NOTE:  no keyentry changes beyond this line.
              we must compute the key size LAST!  */

    pEntry->keySize = ComputeKeytabLength( pEntry );

    *ppKeyEntry     = pEntry; /* save this */
    pEntry          = NULL;   /* save us from freeing it */

    ret = TRUE;

cleanup:
#define FREE_IF_NOT_NULL( element ) { if ( element != NULL ) { KEYTAB_FREE( element ); } }

    if ( pEntry ) {
      FreeKeyEntry (pEntry );
    }

    WINNT_ONLY( FREE_IF_NOT_NULL( UnicodePassword.Buffer ) );
    WINNT_ONLY( FREE_IF_NOT_NULL( UnicodePrincipal.Buffer ) );

#ifndef BUILD_KEYSALT
    /* WASBUG 73915: how to free UnicodeSalt?
       ...with KerbFreeString. */

    ASSERT( FreeUnicodeSalt );
    KerbFreeString( &UnicodeSalt );

#else

    /* Check my logic. */

    ASSERT( !FreeUnicodeSalt );

#endif

    /* WASBUG 73918: how do I get rid of the data in KerbKey?
       ...with KerbFreeKey. */

    KerbFreeKey( &KerbKey );

    return ret;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\opt\cleanup.c ===
/*++

  CLEANUP.C

  CleanupOptionData code.

  Created, 6/25/1997 when it was impossible to keep making myself believe
  that I could go without allocating any memory in the option parser.

  Now, if you care, you're supposed to call CleanupOptionData().

  --*/


#include "private.h"

/* OptionDealloc:

   same as free() right now.  It should change if/when OptionAlloc
   changes */

VOID
OptionDealloc( IN PVOID pTarget ) {

    ASSERT( pTarget != NULL );

    free ( pTarget );

}


BOOL
OptionAddToList( IN PVOID          pQueue,
		 IN PVOID          pItem,
		 IN DEALLOC_METHOD eDealloc) {

    PSAVENODE pNode;
    PSAVEQUEUE pList;

    if ( !pQueue ) {

      return TRUE; // vacuous

    } else {

      pList = (PSAVEQUEUE) pQueue;

    }

    if( OptionAlloc( NULL, &pNode, sizeof( SAVENODE ) ) ) {

      pNode->DataElement   = pItem;
      pNode->DeallocMethod = eDealloc;
      pNode->next          = NULL;

      if ( pList->FirstNode == NULL ) {
	
	ASSERT( pList->LastNode == NULL );
	
	pList->FirstNode = pNode;

      } else {

	pList->LastNode->next = pNode;

      }

      pList->LastNode = pNode;
      return TRUE;
    }

    return FALSE;

}


BOOL
OptionResizeMemory( IN  PVOID  pSaveQueue,
                    OUT PVOID *ppResizedMemory,
                    IN  ULONG  newSize ) {

    ASSERT( ppResizedMemory != NULL );
    ASSERT( newSize         > 0 );
    // ASSERT( *ppResizedMemory != NULL ); // unuseful assertion.

    if ( *ppResizedMemory ) {

      PSAVENODE  pNode = NULL;
      PVOID      pDataElement;

      pDataElement = *ppResizedMemory;
      
      if ( pSaveQueue ) {

	PSAVEQUEUE pQ;
	pQ = (PSAVEQUEUE) pSaveQueue;
	
	for ( pNode = pQ->FirstNode ;
	      pNode != NULL;
	      pNode = pNode->next ) {
	  
	  if ( pNode->DataElement == pDataElement ) {
	    break;
	  }
	  
	}
	
	if ( !pNode ) {
	  return FALSE;
	}
      }
      
      pDataElement = realloc( pDataElement, newSize ) ;

      if ( pDataElement == NULL ) {
	
	fprintf( stderr, 
		 "OptionResizeMemory failed to realloc for %d bytes.\n",
		 newSize );
	
	// allocation failed.
	
	return FALSE;
	
      } else {

	*ppResizedMemory = pDataElement;
	
	if ( pNode ) {
	  
	  // must change this within the list as well.
	  
	  pNode->DataElement = pDataElement;
	  
	}
	
	return TRUE;

      }

    } else {

      /* just like realloc, if you pass NULL, we'll just malloc the data
	 anyway.  This is just more convenient. */

      return OptionAlloc( pSaveQueue, ppResizedMemory, newSize );

    }
}


/* OptionAlloc:

   currently, malloc.
   
   if you change the method of allocation, you must also change
   OptionDealloc above */
   

BOOL
OptionAlloc( IN  PSAVEQUEUE pQueue,
	     OUT PVOID     *pTarget,
	     IN  ULONG      size ) {

    PVOID ret;

    ASSERT( pTarget != NULL );
    ASSERT( size    >  0 );

    ret = malloc( size );

    if ( ret ) {

      memset( ret, 0, size );

      if ( OptionAddToList( pQueue, ret, DeallocWithOptionDealloc ) ) {

	*pTarget = ret;

	return TRUE;
      } else {

	free( ret );

	// fallthrough

      }
    }

    *pTarget = NULL;
    
    return FALSE;

}


VOID
CleanupOptionDataEx( IN PVOID pVoid ) {

    ULONG      i;
    PSAVEQUEUE pQueue;

    ASSERT( pVoid != NULL );

    pQueue = ( PSAVEQUEUE ) pVoid;

    if ( pQueue->FirstNode != NULL ) {

      PSAVENODE p;
      PSAVENODE q;

      ASSERT( pQueue->LastNode != NULL );
      OPTIONS_DEBUG( "CleanupOptionDataEx: Freelist is nonempty.\n" );

      for ( p = pQueue->FirstNode ;
	    p != NULL ;
	    p = q ) {

	q = p->next;
	
	switch( p->DeallocMethod ) {

	 case DeallocWithFree:
	   
	   free( p->DataElement );
	   break;

	 case DeallocWithLocalFree:
	   LocalFree( p->DataElement );
	   break;
	   
	 case DeallocWithOptionDealloc:
	   
	   OptionDealloc( p->DataElement );
	   break;

	 default:

	   ASSERT_NOTREACHED( "unknown dealloc flag.  Bleah!" );
	   return;

	}
	
	OptionDealloc( p );

      }
      

    } else {

      OPTIONS_DEBUG( "CleanupOptionDataEx: Freelist is empty.\n" );

      ASSERT( pQueue->LastNode == NULL );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\opt\debug.c ===
/*++

  DEBUG.C

  interface to my regular debugging library.

  Created, 9/13/1997 by DavidCHR

  --*/

#ifdef DEBUG_OPTIONS

#include ".\private.h"

VOID
OptionDebugPrint( PCHAR fmt, ... ){

    va_list v;
    va_start( v, fmt );

    vdebug( OPTION_DEBUGGING_LEVEL, fmt, v );

}

VOID
OptionHelpDebugPrint( PCHAR fmt, ... ){

    va_list v;
    va_start( v, fmt );

    vdebug( OPTION_HELP_DEBUGGING_LEVEL, fmt, v );

}

#endif //don't compile it in if the user doesn't specify.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\opt\help.c ===
/*++

  HELP.C
  
  PrintHelp function

  split from options.c, 6/9/1997 by DavidCHR

  --*/

#include "private.h"
#include <malloc.h>

PCHAR SlashVector    = "[- /]"; /* These should all be the same */
PCHAR BoolVector     = "[- +]"; /* size-- for formatting reasons */
PCHAR ColonVector    = " : ";   /* Separator */

#ifdef DEBUG_OPTIONS
VOID OptionHelpDebugPrint( PCHAR fmt, ... );
#define HELPDEBUG OptionHelpDebugPrint
#else
#define HELPDEBUG
#endif


VOID
FillBufferWithRepeatedString( IN  PCHAR  repeated_string,
			      IN  PCHAR  buffer,
			      IN  ULONG  bufferLength /* without null */ ){

    ULONG stringi, bufferj = 0;
    ULONG size;

    size = strlen( repeated_string );

    if ( size == 0 ) {

      memset( buffer, ' ', bufferLength );

    } else {

      for ( stringi = 0 ; stringi < bufferLength ; stringi++, bufferj++ ) {
	
	buffer[ bufferj ] = repeated_string[ bufferj % size ];
	
      }

    }
      
    buffer[ bufferLength ] = '\0';

}



/* PrintUsageEntry:

   formats a single line of text and sends it out.
   This is where all the output goes, so we can be assured that it all ends
   up formatted the same.   It uses the following globals so that clients
   can adjust the values if needed.  */

ULONG OptMaxHeaderLength      = 5;  
ULONG OptMaxCommandLength     = 13;
ULONG OptMaxSeparatorLength   = 3;
ULONG OptMaxDescriptionLength = 58; 

VOID
PrintUsageEntry( FILE  *out,        // output file stream
                 PCHAR  aHeader,    // usually SlashVector, BoolVector or NULL
		 PCHAR  aCommand,   // command name or NULL
		 PCHAR  aSeparator, // between command and description
		 PCHAR  Description, //  NULL-terminated string vector 
		 BOOL   fRepeatSeparator ) {

    PCHAR output_line;                               // sick.  see below
    PCHAR Separator;
    PCHAR Header;
    PCHAR Command;

    HELPDEBUG( "PrintUsageEntry( aHeader = \"%s\"\n"
		   "                 aCommand = \"%s\"\n"
		   "                 aSeparator = \"%s\"\n"
		   "                 Description = \"%s\"\n"
		   "                 fRepeat = %d )...\n",

		   aHeader, aCommand, aSeparator, Description, 
		   fRepeatSeparator );
    
    ASSERT( aSeparator != NULL );
      
    if ( fRepeatSeparator ) {
     
#define EXPAND_TO_SEPARATOR( arg ) {                                        \
      PCHAR local_arg;                                                      \
      arg = aSeparator;                                                     \
      ASSERT( arg != NULL );                                                \
      if ( strlen( arg ) < OptMax##arg##Length ) {                          \
        arg = (PCHAR) alloca( ( OptMax##arg##Length+1 ) * sizeof( CHAR ) ); \
        if ( arg ) {                                                        \
          HELPDEBUG( "filling " #arg " with \"%s\"...", aSeparator );   \
          FillBufferWithRepeatedString( aSeparator, arg,                    \
					OptMax##arg##Length );              \
          HELPDEBUG( "results in \"%s\".\n", arg );                     \
        } else {                                                            \
	  arg = a##arg;                                                     \
	}                                                                   \
      } else {                                                              \
        arg = a##arg;                                                       \
      }                                                                     \
      }  

      /* BEWARE:

	 if you are using emacs, this next statement may not automatically 
	 format correctly.  Set it manually and the other lines will fix 
	 themselves.

	 This is a bug in emacs's macro-handling code.  :-) */
    								   
      EXPAND_TO_SEPARATOR( Separator ); // separator may need expanding anyway
      
      if ( !aHeader) {
	EXPAND_TO_SEPARATOR( Header );
      } else {
	Header = aHeader;
      }
      if ( !aCommand ) {
	EXPAND_TO_SEPARATOR( Command );
      } else {
	Command = aCommand;
      }

    } else {

      Separator = aSeparator;
      Header    = aHeader;
      Command   = aCommand;

      ASSERT( Separator != NULL );
      ASSERT( Header    != NULL );
      ASSERT( Command   != NULL );
    
    }

    /* before we try to do all this sick string manipulation, try to 
       allocate the buffer.  If this fails, well... it'll save us the 
       trouble.  :-) */

    output_line = (PCHAR) alloca( ( OptMaxHeaderLength         +
				    OptMaxCommandLength        +
				    OptMaxSeparatorLength      +
				    OptMaxDescriptionLength    +
				    2 /* NULL-termination */ ) * 
				  sizeof( CHAR ) );
    if ( output_line ) {

      PCHAR index;
      CHAR  outputFormatter[ 10 ] = { 0 }; // "%50hs" and the like

#ifdef WINNT // ugh.  Why can't we support this function?  I can't find it...
#define snprintf _snprintf
#endif

#define FORMAT_FORMAT( arg ) {                                             \
	snprintf( outputFormatter, sizeof( outputFormatter),               \
		  "%%%ds", OptMax##arg##Length );                          \
        HELPDEBUG( #arg ": formatter = \"%s\"\n ", outputFormatter );  \
        HELPDEBUG( "input value = \"%s\"\n", arg );                    \
	snprintf( index, OptMax##arg##Length,                              \
		  outputFormatter, arg );                                  \
	index[ OptMax##arg##Length ] = '\0';                               \
        HELPDEBUG( "output = \"%s\"\n", index );                       \
        index += OptMax##arg##Length;                                      \
      }
	
      index = output_line;
      
      FORMAT_FORMAT( Header );
      FORMAT_FORMAT( Command );
      FORMAT_FORMAT( Separator );

      // the description does not want to be right-justified.

      snprintf( index, OptMaxDescriptionLength, "%s", Description );
      index[OptMaxDescriptionLength] = '\0';

#undef FORMAT_FORMAT

      fprintf( out, "%s\n", output_line );

    } else {

      fprintf( stderr, 
	       "ERROR: cannot format for %s %s %s -- "
	       "STACK SPACE EXHAUSTED\n",
	       Header, Command, Description );

      fprintf( out, "%s%s%s%s\n", Header, Command, 
	       aSeparator, Description );

    }
    
}

VOID
PrintUsage( FILE         *out,
	    ULONG         flags,
	    optionStruct *options,
	    PCHAR         prefix /* can be NULL */) {

    ULONG i;
    BOOL  PrintAnything = TRUE;
    PCHAR Syntax        = NULL;
    PCHAR CommandName   = NULL;
    PCHAR Description   = NULL;
    PCHAR Separator     = NULL;

    fprintf(out, "Command line options:\n\n");


    for (i = 0 ; !ARRAY_TERMINATED( options+i ); i++ ) {

      Description   = options[i].helpMsg;

      HELPDEBUG("option %d has flags 0x%x\n",  i, options[i].flags );

      if ( options[i].flags & OPT_HIDDEN ) {
	continue;
      }

      if ( options[i].flags & OPT_NOSWITCH ) {
	Syntax = "";
      } else {
	Syntax = SlashVector;
      }

      if ( options[i].flags & OPT_NOCOMMAND ) {
	CommandName = "";
      } else {
	CommandName = options[i].cmd;
      }

      if ( options[i].flags & OPT_NOSEPARATOR ) {
	Separator = "";
      } else {
	Separator     = ColonVector;
      }

      switch (options[i].flags & OPT_MUTEX_MASK) {

       case OPT_ENUMERATED:

       {

	 // special case.

	 CHAR HeaderBuffer[ 22 ]; // formatting = 21 chars wide + null

	 HELPDEBUG("[OPT_ENUM]");
	 
	 PrintAnything = FALSE;
	 
	 sprintf( HeaderBuffer, "%5hs%13hs%3hs", SlashVector,
		  CommandName, Separator );

	 fprintf( out, "%hs%hs\n", HeaderBuffer, Description );
	 
	 fprintf( out, "%hs is one of: \n", HeaderBuffer );

	 PrintEnumValues( out, HeaderBuffer, 
			  ( optEnumStruct * ) options[i].optData );
	 
	 break;

       }

       case OPT_PAUSE:

	   HELPDEBUG("[OPT_PAUSE]");

	   PrintAnything = FALSE;

	   if ( !Description ) {
	     Description = "Press [ENTER] to continue";
	   }

	   fprintf( stderr, "%hs\n", Description );

	   getchar();

	   break;
	   
       case OPT_DUMMY:

	 PrintUsageEntry( out, 
			  ( options[i].flags & OPT_NOSWITCH    ) ?
			  ""  : NULL,
			  ( options[i].flags & OPT_NOCOMMAND   ) ? 
			  ""  : NULL,
			  ( options[i].flags & OPT_NOSEPARATOR ) ?
			  "" : "-" , 
			  Description, TRUE  );
	
	   break;
	   
       case OPT_CONTINUE:

	 PrintUsageEntry( out, "", "", "", Description, FALSE );

	   break;


       case OPT_HELP:

	   if ( !Description ) {
	     Description = "Prints this message.";
	   }

	   PrintUsageEntry( out, Syntax, CommandName,
			    ColonVector, Description, FALSE );

	   break;

       case OPT_SUBOPTION:

	   if ( !Description ) {
	     Description = "[ undocumented suboption ]";
	   }

	   PrintUsageEntry( out, Syntax, CommandName,
			    ColonVector, Description, FALSE );

	   break;
	   
       case OPT_BOOL:

	   PrintUsageEntry( out, 
			    ( ( options[i].flags & OPT_NOSWITCH ) ?
			      Syntax : BoolVector ), CommandName,
			    ColonVector, Description, FALSE );

	   break;

       case OPT_STOP_PARSING:

	 if ( !Description ) {
	   Description = "Terminates optionlist.";
	 }
	 goto defaulted;

       case OPT_FUNC2:

	 if ( !Description ) {
	   OPT_FUNC_PARAMETER_DATA optFuncData = { 0 };

	   optFuncData.argv = &( options[i].cmd );

	   HELPDEBUG("Jumping to OPT_FUNC2 0x%x...", 
			 ((POPTU) &options[i].data)->raw_data );

	   ( (POPTU)&options[i].data)->func2( TRUE, &optFuncData );

	   break;
	 }

	 /* fallthrough-- if this one has no description,
	    they both will, so the next if will not be taken. */
	 
       case OPT_FUNC:
	 
	 if ( !Description ) {

	   HELPDEBUG("Jumping to OPTFUNC 0x%x...", 
			 ((POPTU) &options[i].data)->raw_data );

	   ( (POPTU) &options[i].data )->func( 0, NULL );
	   break;
	 }

	 // fallthrough

#ifdef WINNT
       case OPT_WSTRING:
       case OPT_USTRING:
#endif
       case OPT_STRING:
       case OPT_INT:
       case OPT_FLOAT:

	 // fallthrough

       default: // this is the default means.
defaulted:

#if (HIGHEST_OPTION_SUPPORTED != OPT_STOP_PARSING )
#error "new options? update this switch statement or bad things will happen."
#endif

	 PrintUsageEntry( out, Syntax, CommandName,
			  ColonVector, Description, FALSE );

      }

      if ( options[i].flags & OPT_ENVIRONMENT ) {
	  
	CHAR buffer[ MAX_PATH ];
	  
	sprintf( buffer, " (or set environment variable \"%hs\")",
		 options[i].optData );

	PrintUsageEntry( out, "", CommandName, ColonVector,
			 buffer, FALSE );
      }

    } // for-loop
} // function
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\opt\compare.c ===
/*++

  COMPARE.C

  Checks to see if a command line option matches a given expectation.

  Created, DavidCHR 6/9/1997

  --*/

#include "private.h"

/* ParseCompare:

   returns TRUE if the argument matches the expectation of pEntry */

BOOL
ParseCompare( optionStruct *pEntry,
	      ULONG         flags,
	      PCHAR         arg ) {

    CHAR  buffer[ 255 ];

    switch( pEntry->flags & OPT_MUTEX_MASK ) {

     case OPT_CONTINUE:
     case OPT_PAUSE:
     case OPT_DUMMY:
	 
       if ( pEntry->cmd ) {
	 OPTIONS_DEBUG( "ParseCompare: skipping useless option ( %s, 0x%x)\n",
			pEntry->cmd,
			pEntry->flags & OPT_MUTEX_MASK );
       }

       return FALSE;

     case OPT_STRING:
     case OPT_INT:
     case OPT_STOP_PARSING:
     case OPT_LONG:
     case OPT_BOOL:
     case OPT_HELP:
     case OPT_FLOAT:
     case OPT_FUNC:
     case OPT_ENUMERATED:
     case OPT_FUNC2:

#ifdef WINNT
     case OPT_USTRING:
     case OPT_WSTRING:
#endif	 

       if ( pEntry->cmd ) {
	 OPTIONS_DEBUG( "ParseCompare: option ( %s, 0x%x) is \"normal\".\n",
			pEntry->cmd,
			pEntry->flags & OPT_MUTEX_MASK );
       } else {

	 ASSERT_NOTREACHED( "Nobody should EVER specify a NULL command field"
			    " in an option structure.  "
			    "It's just plain dumb." );
	 return FALSE;
       }

       break;

     case OPT_SUBOPTION:

	 /* copy everything before the colon into a buffer, then 
	    string-compare the buffer-- suboptions have the form:

	    [+|-|/]option:suboption:suboption */

	 OPTIONS_DEBUG( "ParseCompare: Suboption... " );

     {
       ULONG i;

       for ( i = 0 ; arg[i] != ':' ; i++ ) {
	 if ( arg[i] == '\0' ) {
	   OPTIONS_DEBUG(" no colon.  This cannot be a suboption.\n" );
	   return FALSE;
	 }
	 OPTIONS_DEBUG("%c", arg[i] );
	 buffer[i] = arg[i];
       }

       buffer[i] = '\0';

       arg = buffer;
       break;
     }


     default:

#if (HIGHEST_OPTION_SUPPORTED != OPT_STOP_PARSING )
#error "new options? update this switch statement or bad things will happen."
#endif

	 ASSERT_NOTREACHED( "unknown option type-- your COMPAT library is "
			    "probably out of date.  ssync security\\compat "
			    "and rebuild, then relink your project." );
	 return FALSE;

    }

    OPTIONS_DEBUG( "Comparing \"%s\" against \"%s\"...",
		   arg, pEntry->cmd );


    if ( STRCASECMP( arg, pEntry->cmd ) == 0 ) {

      OPTIONS_DEBUG( "equal!\n" );
      return TRUE;

    } else {
      
      OPTIONS_DEBUG( "not equal\n" );
      return FALSE;

    }
    
    ASSERT_NOTREACHED( "Should never get here" );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\opt\nonnull.c ===
/*++

  NONNULL.C

  Code for finding unused OPT_NONNULLs

  Copyright (C) 1997 Microsoft Corporation

  Created, 6/10/1997 by DavidCHR

  --*/

#include "private.h"

BOOL
FindUnusedOptions( optionStruct         *options,
		   ULONG                 flags,
		   /* OPTIONAL */ PCHAR  prefix,
		   PSAVEQUEUE            pQueue ) {

    PCHAR  newprefix;
    BOOL   freeprefix;
    BOOL   ret        = TRUE;
    ULONG  i;

    for ( i = 0 ; !ARRAY_TERMINATED( options+i ); i++ ) {

      if ( ( options[i].flags & OPT_MUTEX_MASK ) == OPT_SUBOPTION ) {

	OPTIONS_DEBUG( "%s: OPT_SUBSTRUCT.  ", options[i].cmd );

	if (options[i].flags & OPT_RECURSE ) {
	
	  /* suboptions must be reparsed.  we recurse on this structure,
	     copying the prefix into a newly allocated buffer.  */
	  
	  OPTIONS_DEBUG( "descending into substructure.\n" );
	  
	  /* allocate the new prefix */
	  
	  if ( prefix ) {
	    
	    /* oldprefix:optionname = newprefix */
	    
	    newprefix = (PCHAR) malloc( ( strlen( prefix ) +
					  strlen( options[i].cmd ) +
					  2 /* : and \0 */ ) * 
					sizeof( CHAR ) );
	    
	    if ( !newprefix ) {
	      fprintf( stderr, "Failed to allocate new prefix-- cannot "
		       "parse suboption %s:%s.\n", prefix, options[i].cmd );
	      return FALSE;
	    }
	    
	    sprintf( newprefix, "%s:%s", prefix, options[i].cmd );
	    freeprefix = TRUE;
	    
	  } else {
	    
	    /* optionname = prefix */
	    
	    newprefix  = options[i].cmd;
	    freeprefix = FALSE;
	    
	  }
	  
	  ASSERT( newprefix != NULL );
	  
	  if ( !FindUnusedOptions( POPTU_CAST( options[i] )->optStruct,
				   flags,
				   newprefix,
				   pQueue ) ) {
	    ret = FALSE;
	  }
	  
	  if ( freeprefix ) {
	    free( newprefix );
	  }
	  
	} else {

	  OPTIONS_DEBUG( "!OPT_RECURSE, so not descending.\n" );
	  
	}

	continue;

      }
      
      
      if ( ( options[i].flags & OPT_NONNULL ) || 
	   ( options [i].flags & OPT_ENVIRONMENT ) ) {

	OPTIONS_DEBUG( "%s: OPT_NONNULL or OPT_ENV.  pointer is 0x%x, ", 
		       options[i].cmd,
		       POPTU_CAST( options[i] )->raw_data );
	
	if ( *(POPTU_CAST( options[i] )->raw_data) == NULL ) {

	  OPTIONS_DEBUG( " *= NULL.\n" );

	  if ( ( options[i].flags & OPT_ENVIRONMENT ) &&
	       StoreEnvironmentOption( options+i, flags, pQueue ) ) {


	    OPTIONS_DEBUG( "found environment variable for %s...",
			  options[i].cmd );

	  } else if ( options[i].flags & OPT_NONNULL ) {

	    if ( prefix ) {
	      
	      fprintf( stderr,
		       "option %s:%s must be specified and is missing.\n",
		       prefix, options[i].cmd );

	    } else {
	      
	      fprintf( stderr,
		       "option %s must be specified and is missing.\n",
		       options[i].cmd );

	    }

	    ret = FALSE;

	  }
	  
	} else { 
	  
	  OPTIONS_DEBUG( "data is not null.\n" );
	  
	}
      }  
#if 0 // not really necessary debug info.

      else if ( options[i].cmd ) {

	OPTIONS_DEBUG( "%s is ok.\n", options[i].cmd );

      }
#endif
    }

    return ret;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\opt\obsolete.c ===
/*++

  OBSOLETE.C
  
  functions that are obsolete.

  Created, 8/19/1997 from other files by DavidCHR 

  --*/


#include "private.h"

PSAVEQUEUE OptionsGlobalSaveQueue = NULL;

/* Included for compatibility.  DO NOT USE */

int
ParseOptions( int           argc,
	      char        **argv,
	      optionStruct *options ) {

    PCHAR *newargv;
    int    newargc;

    ASSERT( options != NULL );
    ASSERT( argv    != NULL );

    OptionsGlobalSaveQueue = NULL;
    
    if ( ParseOptionsEx( argc, argv, options,
			 0L,   &OptionsGlobalSaveQueue, 
			 &newargc, &newargv)) {

      OPTIONS_DEBUG( "ParseOptionsEx returns newargc as  %d\n"
		     "                      old argc was %d\n",
		     
		     newargc, argc );

      return argc-newargc;

    } else {
      
      return 0;

    }

}


VOID
CleanupOptionData( VOID ) {

    if ( OptionsGlobalSaveQueue ) {
      CleanupOptionDataEx(  OptionsGlobalSaveQueue );
      OptionsGlobalSaveQueue = NULL;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\opt\enum.c ===
/*++

  ENUM.C

  Option Enumerated Types

  Copyright (C) 1997 Microsoft Corporation, all rights reserved

  Created, 7/29/1997 by DavidCHR

  --*/


#include "private.h"

BOOL
PrintEnumValues( FILE          *out,
		 PCHAR          header,
		 optEnumStruct *pStringTable ) {

    ULONG index;

    for( index = 0 ; pStringTable[index].UserField != NULL ; index++ ) {

      if ( pStringTable[index].DescriptionField ) {
	fprintf( stderr, "%hs%10hs : %hs \n",
		 header,
		 pStringTable[index].UserField,
		 pStringTable[index].DescriptionField );

      }
    }

    return TRUE;

}

BOOL
IsMaskChar( IN CHAR ch ) {

    return ( ch == '|' ) || ( ch == ',' );
	
}


BOOL
ResolveEnumFromStrings( ULONG         cStrings,
			PCHAR        *strings, // remaining args.
			optionStruct *opt,
			PULONG        pcArgsUsed ) {

    optEnumStruct *pStringTable;
    ULONG          TableIndex;
    ULONG          StringIndex;
    ULONG          cArgsUsed  = 0;
    BOOL           wasFound;
    BOOL           moreComing = TRUE;

    pStringTable = ( optEnumStruct *) opt->optData;

#if 1

    for ( StringIndex = 0 ;
	  (StringIndex < cStrings) && moreComing ;
	  StringIndex++ ) {

      PCHAR theString;    // points to the current argument

      theString  = strings[ StringIndex ];

      do {

	OPTIONS_DEBUG( "Start of maskable loop.  theString = %s\n",
		       theString );

	wasFound   = FALSE;
	moreComing = FALSE;

	for( TableIndex = 0 ;
	     pStringTable[ TableIndex ].UserField != NULL;
	     TableIndex ++ ) {
	
	  ULONG StringLength; // set to the string length of the option cmd

	  StringLength = strlen( pStringTable[ TableIndex ].UserField );

	  // string-compare up to the StringLength.

	  if ( STRNCASECMP( pStringTable[ TableIndex ].UserField,
			    theString, StringLength ) != 0  ) {

	    continue; // this entry doesn't match.

	  } // else...

	  // found a partial match!  Verify the remainder if there is any.

	  if ( theString [ StringLength ] != '\0' ) {

	    if ( opt->flags & OPT_ENUM_IS_MASK ) {
		
	      if ( IsMaskChar( theString[ StringLength ] ) ) {
		
		// more are coming.
		moreComing = TRUE;

	      } else continue; // inexact match.
	    } else continue;   // inexact match.
	  }

	  wasFound = TRUE;

	  if ( cArgsUsed ) {
	
	    *(POPTU_CAST( *opt )->integer) |= ( ( ULONG )((ULONG_PTR)
						pStringTable[ TableIndex ].
						VariableField ));

	  } else {

	    *(POPTU_CAST( *opt )->raw_data) = ( pStringTable[ TableIndex ].
						VariableField );

	  }

	  if ( theString == strings[ StringIndex ] ) {
	
	    /* we modify theString if it includes multiple mask values.
	       So, this way we only increase the number of used arguments
	       ONCE per actual argument.  */

	    cArgsUsed++;
	  }
	
	  if ( opt->flags & OPT_ENUM_IS_MASK ) {

	    if ( moreComing ) {

	      // check to see if the user input "xxx|yyy", or just "xxx|"

	      ASSERT( StringLength > 0 );

	      // theString[ StringLength ] == '|' or something.

	      for ( theString += StringLength+1; // +1 to go past '|'
		    theString != NULL ;
		    theString ++ ) {
		
		if ( *theString == '\0' ) {

		  OPTIONS_DEBUG( "Mask is of the form 'XXX|'\n" );
		
		  // case = xxx| -- no more coming.

		  theString = NULL; //
		  break;

		}

		if ( isspace( *theString ) ) {
		  continue;
		}

		OPTIONS_DEBUG( "nonspace character '%c' hit.\n"
			       "mask component is of the form XXX|YYY.\n",
			
			       *theString );
		break;

	      }

	      ASSERT( !theString || ( (*theString != '\0') &&
				      !isspace(*theString) ) );

	      break;

	    } else { // !moreComing

	      theString = NULL;  // no more args in *this* string.

	      /* check to see if the mask character is or is in the NEXT
		 argument: "xxx" "|yyy" or "xxx" "|" "yyy" */
	
	      if ( strings[ StringIndex+1 ] ) {

		if ( IsMaskChar( strings[ StringIndex+1 ][0] ) ) {
		
		  moreComing = TRUE;
		
		  if ( strings[ StringIndex+1 ][1] == '\0' ) {

		    // xxx | yyy

		    cArgsUsed++;
		    StringIndex++;

		  } else {

		    // xxx |yyy

		    strings[ StringIndex +1 ]++;

		  }

		}

	      } // strings[ StringIndex +1 ]

	    } // !moreComing

	    break; // found what we wanted.  stop checking the table.

	  } else { // !OPT_ENUM_IS_MASK

	    // found the only argument we were expecting.  Just return.

	    *pcArgsUsed = cArgsUsed;
	    return TRUE;

	  } // moreComing check

	} // for each table entry

      } while ( ( theString != NULL ) && wasFound );

      if ( !wasFound ) { // option was not recognized.

	fprintf( stderr,
		 "%s: enum value '%s' is not known.\n",
		 opt->cmd, strings[ StringIndex ] );
	break;
		
      }
    }

#else

    for( index = 0 ; pStringTable[index].UserField != NULL; index++ ) {
      if ( STRCASECMP( pStringTable[index].UserField, string ) == 0 ) {
	
	// found a match!
	*(POPTU_CAST( *opt )->raw_data) = pStringTable[index].VariableField;

	OPTIONS_DEBUG( "Enum resolves to #%d, \"%s\" = 0x%x \n",
		       index,
		       pStringTable[index].DescriptionField,
		       pStringTable[index].VariableField  );

	return TRUE;
      }
    }


#endif

    if ( wasFound ) {

      *pcArgsUsed = cArgsUsed;

    } else {

      fprintf( stderr, "Error: argument for option \"%hs\" must be %s:\n",
	       opt->cmd,
	       ( opt->flags & OPT_ENUM_IS_MASK ) ?
	       "one or more of the\n following, separated by '|' or ','" :
	       "one of the following values" );

      PrintEnumValues( stderr, "", pStringTable );

    }

    return wasFound;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\opt\client.h ===
/*++

  CLIENT.H

  header file for OPT_FUNC2 or better functions.

  This file exposes the freelist API used internally by the program.  This
  assures the caller that CleanupDataEx will obliterate any memory used by
  the option system.

  It is important that client code not corrupt the internal freelist, or
  unpredictable results may occur.  

  Created, 9/6/1997 by DavidCHR

  Copyright (C) 1997 Microsoft Corporation, all rights reserved.

  --*/


/* When a FUNC2 function is called, it will be passed a SaveQueue.
   This queue is guaranteed not to be null by the calling function (unless 
   the HELP parameter is TRUE) and should be considered opaque.
   The only means of accessing the queue are with OptionAlloc and
   CleanupOptionDataEx. */

BOOL
OptionAlloc( IN  PVOID   pSaveQueue,  /* if NULL, no list is used, and you
					 must call OptionDealloc to free the
					 memory */
	     OUT PVOID  *ppTarget,
	     IN  ULONG   size );

VOID
OptionDealloc( IN PVOID pTarget );

/* note that ppResizedMemory must have been allocated with OptionAlloc--
   
   e.g.: 

   OptionAlloc( pSave, &pTarget, sizeof( "foo" ) );
   OptionResizeMemory( pSave, &pTarget, sizeof( "fooooooo" ) );

   */

BOOL
OptionResizeMemory( IN  PVOID  pSaveQueue,      // same as in OptionAlloc
		    OUT PVOID *ppResizedMemory, // same as in OptionAlloc
		    IN  ULONG  newSize );       // same as in OptionAlloc

/* PrintUsageEntry:

   formats a single line of text and sends it out.
   This is where all the output goes, so we can be assured that it all ends
   up formatted the same.   It uses the following globals so that clients
   can adjust the values if needed.  The defaults are in comments */

extern ULONG OptMaxHeaderLength      /* 5  */;
extern ULONG OptMaxCommandLength     /* 13 */;
extern ULONG OptMaxSeparatorLength   /* 3  */;
extern ULONG OptMaxDescriptionLength /* 58 */;

VOID
PrintUsageEntry( FILE  *output,      // output file stream (must be stderr)
                 PCHAR  Header,     // usually SlashVector, BoolVector or NULL
		 PCHAR  Command,     // command name or NULL
		 PCHAR  aSeparator,  // between command and description
		 PCHAR  Description, // description string
		 BOOL   fRepeatSeparator );


/* PrintUsage should be used to print the usage data for an option vector.
   Useful if your function takes suboptions. */

VOID
PrintUsage( FILE         *output,   // output file stream (must be stderr)
	    ULONG         flags,    // option flags (as ParseOptionsEx)
	    optionStruct *options,  // option vector, 
	    PCHAR         prefix ); // prefix (optional; currently ignored)


#define OPT_FUNC_PARAMETER_VERSION 1

typedef struct {

  IN  ULONG  optionVersion;    // will be set to OPT_FUNC_PARAMETER_VERSION.
  IN  PVOID  dataFieldPointer; // points to the variable in the optStruct
  IN  INT    argc;             // argc following the option calling the func
  IN  PCHAR *argv;             /* argv (argv[0] is the command invoked)
				  NOTE: this pointer will ALWAYS exist, even
				  if the Help Flag is set.  HOWEVER, it is
				  the only option that's guaranteed to be 
				  there. */
  IN  ULONG  optionFlags;      // as ParseOptionsEx
  IN  PVOID  pSaveQueue;       // input memorylist.  
  OUT INT    argsused;         // set this to the number of args you used.

  /* parameters may be added to the end, depending on the optionVersion.
     an option function should only be concerned if the optionVersion is
     LESS than the optionVersion it knows about.  If greater, no big deal. */
  
} OPT_FUNC_PARAMETER_DATA, *POPT_FUNC_PARAMETER_DATA;

// this is the function expected by OPT_FUNC2
typedef BOOL (OPTFUNC2)( IN BOOL, // if TRUE, just print help.  
			 IN POPT_FUNC_PARAMETER_DATA );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\opt\options.h ===
/*++

  OPTIONS.HXX

  My option parsing system

  Copyright (C) 1997 Microsoft Corporation
  
  Created 01/13/1997 DavidCHR

  --*/
#ifndef INCLUDED_OPTIONS_H

/* IMPORTANT! IMPORTANT! IMPORTANT!

   If you add option types, you MUST change this #define to point at
   your new type.  The symbol used internally for certain assertions and at 
   compile-time to find forgotten areas. 

   IMPORTANT! IMPORTANT! IMPORTANT! */

#define HIGHEST_OPTION_SUPPORTED OPT_STOP_PARSING

#define INCLUDED_OPTIONS_HXX

#define OPTION_DEBUGGING_LEVEL      0x10000000 /* set your DebugFlag to this
						  if you want OPTIONS_DEBUG */
#define OPTION_HELP_DEBUGGING_LEVEL 0x20000000 /* most people REALLY will not
						  want to see this. */

typedef int (OPTFUNC)(int, char **); /* this is what's expected of OPT_FUNC*/

// OPT_FUNC2 and beyond will be defined in client.h

/* NOTE that when defining this structure statically, you MUST use 
   curly braces ({}), since the structure may change in size! */

typedef struct {

  PCHAR cmd;         /* this is what we call from the command line eg "h" 
			for -h  or /h */
  PVOID data;        /* this is where we store the results of that, 
			OR a function
			that can be called to store it (see below), OR null if
			this option is ignored or doesn't need storage */
  ULONG flags;       /* flags describing this option (see below for flags) */
  PCHAR helpMsg;     /* description of this option (example: "prints help 
			screen" or "specifies a file to read") */
  PVOID optData;    /* if we specify OPT_ENVIRONMENT (for example), 
		       this is the environment variable we'll take the 
		       data from */

  /* any/all remaining fields should be left alone */

  BOOL  Initialized; /* initially FALSE */

} optionStruct;


/* use this macro to determine if you're at the end of the array or not--
   it will change if the array termination conditions change. */

#define ARRAY_TERMINATED( poptions ) ( ( (poptions)->cmd     == NULL ) &&  \
                                       ( (poptions)->helpMsg == NULL ) &&  \
				       ( (poptions)->data    == NULL ) &&  \
				       ( (poptions)->flags == 0 ) )

  /* put this as the last element of your array.  It will change if/when
     the termination conditions change */

#define TERMINATE_ARRAY { 0 }

/*  FLAGS

    these tell ParseOptions and PrintHelpMessage what the option is: */

/* These are mutually-exclusive, so they are set in a manner such that
   defining them together causes wierd results. */

#define OPT_HELP      0x01 /* print the help message */
#define OPT_STRING    0x02 /* option is a string */ 
#define OPT_INT       0x03 /* an integer (can be hex) */
#define OPT_LONG      0x04 /* a long integer */
#define OPT_BOOL      0x05 /* boolean */
#define OPT_FLOAT     0x06 /* a float */
#define OPT_FUNC      0x07 /* needs a function to parse and store */
#define OPT_DUMMY     0x08 /* don't store the result anywhere-- basically,
			    a separator that appears in the help message */

#define OPT_CONTINUE  0x09 /* line is a continuation of the previous line--
			     useful for breaking really long descriptions
			     into multiple short lines */

#define OPT_PAUSE     0x0A /* wait for the user to press RETURN */

#ifdef WINNT /* only available under Windows NT */

#define OPT_USTRING   0x0B /* UNICODE_STRING */
#define OPT_WSTRING   0x0C /* string of wide characters */

#ifdef UNICODE /* use OPT_TSTRING for TCHAR strings */
#define OPT_TSTRING OPT_WSTRING
#else
#define OPT_TSTRING OPT_STRING
#endif

#endif /* WINNT-- OPT_{U|W}STRING */

#define OPT_SUBOPTION 0x0D /* suboptions-- format is:
			      [+|-|/](optname):(subopt),
			      
			      optname is the name of THIS OPTION (serves as
			      a kind of "routing option".  This gets converted
			      to:

			      [+|-|/](subopt) 

			      and is reparsed with the optionStruct that is
			      given as data to this parameter within this
			      structure.  Nesting IS supported.

			      Example follows.  */

#if 0 /* EXAMPLE of OPT_SUBOPTION */
  

static optionStruct RoutedOptions[] = {
  
  /* note that each suboption must have its own OPT_HELP-- the help
     code will not browse the substructure. */
  
  { "help",    NULL,           OPT_HELP, NULL },
  { "myroute", &some_variable, OPT_BOOL, "set this to enable routing" },
  { "nofoo",   &defeat_foo,    OPT_BOOL, "down with foo!" },
  
  TERMINATE_ARRAY
  
}

static optionStruct myOptions[] = {
  
  { "help",  NULL,          OPT_HELP,      NULL },
  { "route", RoutedOptions, OPT_SUBOPTION, "Routing options" },
  
  TERMINATE_ARRAY
  
};

/* in this example, to get help with the routing options, one would specify
   
   -route:help 

   to enable routing, the user would do:

   +route:myroute */

#endif
			      
#define OPT_ENUMERATED 0x0E /* Enumerated type.  Depending on what the user
			       enters for the field, we enter a user-defined
			       value for the specified variable.  We
			       deliberately ignore the type of the values,

			       the mapping-vector goes into the optData
			       field, so we can't use OPT_ENVIRONMENT with
			       this.
			       
			       and the array is currently terminated by
			       a NULL UserField.  Since this may change,
			       use TERMINATE_ARRAY as above.  

			       the options are not case-sensitive, but
			       if the user specifies an unknown value,
			       an error will occur. */
typedef struct {

  PCHAR UserField;     
  PVOID VariableField;
  PCHAR DescriptionField;  /* if the description is left blank, the field
			      will not be mentioned in help */

} optEnumStruct;

#if 0 /* Example of OPT_ENUMERATED option */

typedef enum {

  UseUdpToConnect = 1,
  UseTcpToConnect = 2,

} MyEnumType;

optEnumStruct MyEnumerations[] = {

  { "udp", (PVOID) UseUdpToConnect, // casting will likely be needed if
    "Specifies a UDP connection" },
  { "tcp", (PVOID) UseTcpToConnect, // your assignment is not a pointer
    "Specifies a TCP connection" },

  TERMINATE_ARRAY

};

MyEnumType MethodOfConnection;

optionStruct MyOptions[] = {

  /* ... */

  { "MyEnum", OPT_ENUMERATED, &MethodOfConnection, 
    "example of an enumerated type-- -myEnum Tcp for tcp connections",
    MyEnumerations },

  /* ... */

};
#endif

#define OPT_FUNC2 0x0F      /* enhanced function-- goes in the 
			       optData field, instead of the data field.
			       See OPTFUNC2 above.  */

#define OPT_STOP_PARSING 0x10 /* tells the parser to stop here.  This is
				 the equivalent of the ';' argument to 
				 -exec in unix's find command:

				 find . -exec echo {} ; -something.

				 the ; terminates parsing for the -exec 
				 option.  However, parsing for find is 
				 unaffected. */

#define OPT_MUTEX_MASK 0xff /* mask for mutually exclusive options */

#define OPT_NONNULL 0x100 /* option cannot be zero or NULL after parsing--
			     not useful for BOOLs, DUMMYs, or HELP.
			     
			     This is a way of ensuring that an option DOES 
			     get specified. */

#define OPT_DEFAULT 0x200 /* option may be specified without the cmd--
			     multiple OPT_DEFAULTs may be specified.  They
			     get "filled in" in the order they exist in the
			     options array.  See the examples for more */

#define OPT_HIDDEN  0x400 /* option does not appear in help.  I'm not
			     sure if this ends up being useful or not,
			     but I'm including it for completeness. */

#define OPT_ENVIRONMENT 0x800 /* use the optData field as an environment
				 string from which to extract the default */

#define OPT_RECURSE  0x1000 /* define this if you want FindUnusedOptions
			       to reparse the given substructure.

			       Otherwise, it'll be ignored */
#define OPT_NOSWITCH  0x2000 /* do not print the leading [switches] line */
#define OPT_NOCOMMAND 0x4000 /* do not print the command name--
				I don't know if you'd ever really want to do
				JUST this, but here it is.. */
#define OPT_NOALIGN   0x8000 /* don't even print alignment spaces.  This will
				make your output REALLY UGLY if you're not
				careful */
#define OPT_NOSEPARATOR 0x10000 /* don't use a separator sequence (by
				   default, I think it's ": ".  Again, this
				   is REALLY UGLY */

// should have named the below option "OPT_RAW", because that's what it is.
#define OPT_NOHEADER ( OPT_NOSWITCH | OPT_NOCOMMAND | OPT_NOALIGN | \
		       OPT_NOSEPARATOR )

#define OPT_ENUM_IS_MASK 0x20000 /* force enumerated types to also accept
				    enums of the form XXX | YYY | ZZZ  */


#if 0 /* EXAMPLE */

optionStruct my_options[] = {

  { "default1", &myDefaultInt,     OPT_INT | OPT_DEFAULT, "an int value"},
  {"default2", &myOtherInteger,   OPT_INT | OPT_DEFAULT,    "another int" },
  {"required", &myRequiredString, OPT_STRING | OPT_NONNULL, "a must have" },

  TERMINATE_ARRAY
};

/*++

  in the example above, if your app was named "foo", the following would
  be equivalent:
  
  foo -default1 0 -default2 13 -required bleah 
  foo 0 13 -required bleah
  foo 0 -default2 13 -required bleah
  foo -required bleah -default2 13 0
  
  ...and failing to specify "-required" would always result in an error
  if myRequiredString is NULL to begin with.  Note that the options must
  be in order.  If you mix types (if default2 were a string, and you run
  "foo bleah 0 for example"), the results are undefined.

  --*/

#endif

/* ParseOptionsEx:

   initializes the option structure, which is a sentinally-terminated
   vector of optionStructs.  

   argc, argv:       arguments to main() (see K&R)
   pOptionStructure: vector of optionStructs, terminated with TERMINATE_ARRAY
   optionFlags:      optional flags to control api behavior
   ppReturnedMemory: returned handle to a list of memory to be freed before
                     program exit.  Use CleanupOptionDataEx to free it. 

   new_arg[c,v]:     if nonnull, a new argc and argv are returned here.
                     if all the options were used up, argc = 0 and argv is
		     NULL.  Note that it is safe to provide pointers to the
		     original argv/argc if so desired.
   
   The function's behavior is complex:
   
   the function will always return FALSE on any critical error (unable to
   allocate memory, or invalid argument).  On WINNT, Last Error will be
   set to the appropriate error.

   if new_argc AND new_argv are specified, 
      ParseOptionsEx will always return TRUE unless help was called, and
      the two parameters will be updated to reflect new values.

   otherwise:
      ParseOptionsEx will return TRUE if it was able to recognize ALL args
      on the command line given.  It will return FALSE if any of the options
      were unknown.  This will probably be what most people want.

*/

BOOL
ParseOptionsEx( int            argc,
		char         **argv,
		optionStruct  *pOptionStructure,
		
		ULONG          optionFlags,
		void         **ppReturnedMemory,
		int           *new_argc,       // optional
		char        ***new_argv );     // optional

/* These are the flags that ParseOptionsEx accepts: */

#define OPT_FLAG_TERMINATE      0x01 // call exit() on error

// these next two are not yet fully supported and are mutually exclusive.

#define OPT_FLAG_SKIP_UNKNOWNS  0x02 // skip unknown parameters
#define OPT_FLAG_REASSEMBLE     0x04 /* assemble new argv/argc with
					unknown parameters in it-- only
					valid if new_argc and new_argv
					are specified 

					this is useless with SKIP_UNKNOWNS. */
#define OPT_FLAG_MEMORYLIST_OK  0x08 /* this means ParseOptionsEx should not
					return a new memory list-- it should
					use the provided one.  */

#define OPT_FLAG_INTERNAL_RESERVED 0xf0 /* flags 0x80, 0x40, 0x20 and 0x10
					   are reserved for internal use */

// if you add flags, update this #define.

#define HIGHEST_OPT_FLAG        OPT_FLAG_INTERNAL_RESERVED

/* CleanupOptionDataEx:

   frees data in the given list, which may be empty ( but not NULL ) */

VOID
CleanupOptionDataEx( PVOID pMemoryListToFree );


/* UnparseOptions:

   creates an argc/argv-like structure from a flat command.
   This is needed particularly for unix clients, although nt clients
   can use it without pulling in SHELL32.LIB.  :-) */

BOOL
UnparseOptions( PCHAR    flatCommand,
		int     *pargc,
		PCHAR   *pargv[] );

#ifndef OPTIONS_NO_BACKWARD_COMPATIBILITY

/* ParseOptions initializes the option structure-- note that the vector
   (optionStruct *) must be terminated with a sentinal value.

   This function is obsolete and is included for compatibility with older
   code.  Call ParseOptionsEx instead.  */

int
ParseOptions(
    /* IN */     int           argc,
    /* IN */     char        **argv,
    /* IN */ /* OUT */optionStruct *options );
     
/* call cleanupOptionData at the end of your program.  This will clear
   all memory used by the option parsing and returning system. */

VOID
CleanupOptionData( VOID );

#endif


#define ISSWITCH( ch /*character*/ ) ( (ch=='-') || (ch=='+') || (ch=='/') )


#endif // file inclusion check.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\opt\sublist.c ===
/*++

  SUBLIST.C

  Code for parsing a suboption list

  DavidCHR 6/6/1997

  --*/

#include "private.h"


/*
  ParseSublist:

  Handler code for parsing a sublist entry.

  */

BOOL
ParseSublist( POPTU  Option,
	      PCHAR *argv,
	      int    argc,
	      int    theIndex,

	      int        *argsused,
	      ULONG      flags,
	      PBOOL      pbDoneParsing,
	      PSAVEQUEUE pQueue ) {
	
    PCHAR TheOption;
    ULONG i;

    ASSERT( Option   != NULL );
    ASSERT( argv     != NULL );
    ASSERT( argc     != 0    );
    ASSERT( theIndex < argc  );

    OPTIONS_DEBUG( "ParseSublist: Option = 0x%x, argv=0x%x, "
		   "argc=%d, theIndex=%d",
		   Option, argv, argc, theIndex );

    TheOption = argv[ theIndex ];

    OPTIONS_DEBUG( "TheOption = [%d] %s... ", theIndex, TheOption );

    for ( i = 0 ; TheOption[i] != ':' ; i++ ) {
      if ( TheOption[i] == '\0' ) {
	fprintf( stderr,
		 "ParseOptions: %s should be of the form "
		 "%s:option (:option:option...)\n",
		
		 TheOption, TheOption );
	return FALSE;
      }
    }

    ASSERT( TheOption[i] == ':' ); /* algorithm check */

    if ( !ISSWITCH( TheOption[0] ) ) {

      /* The easy side--
	 just send the argc and argv structure in, MANGLING
	 the first option */

      /* we do not deal with pbStopParsing in this branch, because it seems
	 somehow unlikely that deep down in a nested substructure, someone
	 would bury an option like this:

	 opt:foo:bar:baz:terminate

	 to stop the toplevel parser.  */

      OPTIONS_DEBUG( "ISSWITCH: easy case (%c is not a switch)",
		     TheOption[0] );

      ASSERT( argv[ theIndex ][i] == ':' );

      argv[ theIndex ] += i+1;

      ASSERT( argv[ theIndex ][0] != ':' );

      return ParseOptionsEx( argc-theIndex,
			     argv+theIndex,
			     Option->optStruct,
			     flags | OPT_FLAG_MEMORYLIST_OK,
			     &pQueue,
			     NULL, NULL );
    } else {

      /* The Hard part--

	 create a new vector of argv, pointing the first at the local buffer.
	 Since the first buffer PROBABLY won't be used as a string
	 (NOTE: if it's OPT_DEFAULT, it could be), it's safe to use this
	 on the stack. */
		
      PCHAR *newargv;
      ULONG  j;
      ULONG  total; /* total elements in the new list */
      CHAR   LocalBuffer[ 255 ];
      BOOL   ret;
      int    tmp;

      OPTIONS_DEBUG( "Hard case (%c is a switch): ", TheOption[0] );

      sprintf( LocalBuffer, "%c%s",
	       TheOption[0],
	       TheOption+i+1 );

      OPTIONS_DEBUG( "LocalBuffer = %s\n", LocalBuffer );

      total   = argc - theIndex ; /* 2? */
      newargv = malloc( total * sizeof(PCHAR) );

      if (!newargv) {
	fprintf(stderr, "Failed to allocate memory in ParseOptions\n");
	return 0;
      }

      newargv[0] = LocalBuffer;

      for( j = 1 ; j < total ; j++ ) {
	
	OPTIONS_DEBUG( "j == %d, total == %d\n", j, total );

	ASSERT( argv[j]    != NULL );
	ASSERT( (int)(j+theIndex) <  argc );
	
	newargv[j] = argv[j+theIndex ];

	OPTIONS_DEBUG( "assign [%d] %s --> [%d] %s\n",
		       j+theIndex, argv[j+theIndex],
		       j, newargv[j] );
	
      }

      ret = ParseOneOption( total, newargv, 0 /* parse the first option */,
			    flags, Option->optStruct, argsused, pbDoneParsing,
			    pQueue );


      free( newargv );

      OPTIONS_DEBUG( "done.  returning %d...\n", ret );

      return ret;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\opt\utest.c ===
/*++

  UTEST.C

  Test program for the options subsystem.  Must compile under
  NT and UNIX

  Created, 5/24/1997 by DavidCHR

  --*/

#include "private.h"

optEnumStruct enums[] = {

  { "one",    (PVOID) 1,          "should end up 1" },
  { "two",    (PVOID) 2,          "should end up 2" },
  { "beef",   (PVOID) 0xdeadbeef, "should be 0xdeadbeef" },
  { "beefs",  (PVOID) 0xbadf00d,  "should be 0xbadf00d" },
  { "secret", (PVOID) 60,         }, // shouldn't show in help

  TERMINATE_ARRAY

};

ULONG enumTestVariable=0;

PCHAR SubString = NULL;


optionStruct substructOptions[] = {

  { "h",      NULL,       OPT_HELP },
  { "substr", &SubString, OPT_STRING, "Substring option" },

  TERMINATE_ARRAY
};

PCHAR          FuncString1         = NULL;
PCHAR          FuncString2         = NULL;
PCHAR          StringOption        = NULL;
int            IntegerOption       = 0L;
BOOL           BooleanOption       = FALSE;
float          FloatOption         = 0.0;
PCHAR          UndocumentedString  = NULL;
PWCHAR         WideCharOption      = NULL;
UNICODE_STRING UnicodeStringOption = { 0 };

int            MyOptFunc( IN  int argc,
			  IN  PCHAR *argv );
BOOL           MyOptFunc2( IN BOOL fHelp,
			   IN POPT_FUNC_PARAMETER_DATA pData );

optionStruct sampleOptions[ ] = {

  { "help",  NULL, OPT_HELP },
  { "?",     NULL, OPT_HELP },

  { NULL, NULL, OPT_DUMMY,    "-----------------------------" },
  { NULL, NULL, OPT_CONTINUE, "These are the useful options:" },
  { NULL, NULL, OPT_DUMMY,    "-----------------------------" },

  { "enum",      &enumTestVariable, OPT_ENUMERATED,
    "Test enumerated type", enums },

  { "mask",      &enumTestVariable, OPT_ENUMERATED | OPT_ENUM_IS_MASK,
    "Test enumerated type with OPT_ENUM_IS_MASK", enums },

  { "substruct", substructOptions, OPT_SUBOPTION | OPT_RECURSE,
    "substruct:help for help" },
  { "recurse",   sampleOptions,    OPT_SUBOPTION, "recurse:help for help" },

  { "string", &StringOption,  OPT_STRING | OPT_ENVIRONMENT, "String Option",
    "StringOption" },

  { NULL, NULL, OPT_CONTINUE, "Use this option to request a string" },

  { "int",    &IntegerOption,  OPT_INT | OPT_ENVIRONMENT,   "integer option",
    "IntegerOption" },

  { NULL, NULL, OPT_CONTINUE, "Use this option to request an integer" },

  { "func",   MyOptFunc,           OPT_FUNC,   "function option" },
  { NULL, NULL, OPT_CONTINUE, "Use this option to request two strings" },

  { "func2",  &IntegerOption,      OPT_FUNC2,  "FUNC2 option",
    MyOptFunc2 },

  { "bool",   &BooleanOption,      OPT_BOOL,   "boolean option" },
  { NULL, NULL, OPT_CONTINUE, "Use this option to request a boolean" },

  { "float",  &FloatOption,        OPT_FLOAT,  "floating point option" },
  { NULL, NULL, OPT_CONTINUE, "Use this option to request a float" },

  { "wstring",&WideCharOption, OPT_WSTRING | OPT_ENVIRONMENT,
    "Wide Char String option", "WideCharOption" },

  { "ustring",&UnicodeStringOption, OPT_USTRING | OPT_ENVIRONMENT,
    "Unicode String Option",  "UnicodeStringOption" },

  { "hidden", &UndocumentedString, OPT_STRING | OPT_HIDDEN,
    "you should never see this line.  This option is OPT_HIDDEN" },

  { "stop",   NULL,                OPT_STOP_PARSING,
    "halts parsing of the command line." },

  { NULL, NULL, OPT_DUMMY | OPT_NOHEADER, "" },

  { NULL, NULL, OPT_DUMMY | OPT_NOHEADER,
    "Example: utest /string \"foo bar baz\" /int 0x15 +bool /float 3.14" },

  { NULL, NULL, OPT_PAUSE },

  TERMINATE_ARRAY

};

int
MyOptFunc( int argc,
	   PCHAR *argv ) {

    if ( ( argv == NULL ) || (argc < 3 ) ) {
      /* this means the user requested help */
      fprintf( stderr, "func [string1] [string2]\n" );
      return 0;
    }

    printf( "MyOptFunc was called.  argc=%d.\n", argc );

    FuncString1 = argv[1];
    FuncString2 = argv[2];

    return 3; /* number of arguments eaten--
		 -func argv[1] argv[2] == 3 options */

}

VOID
DumpArgs( int argc,
	  PCHAR argv[] ) {

    int i;

    for ( i = 0 ; i < argc ; i++ ) {
      fprintf( stderr, "arg %d = %s\n", i, argv[i] );
    }

}

BOOL
MyOptFunc2( IN BOOL                     fHelp,
	    IN POPT_FUNC_PARAMETER_DATA pData ) {

#if OPT_FUNC_PARAMETER_VERSION != 1
#error "OptFuncParameterVersion has changed.  Update this function."
#endif

    optionStruct OptFunc2Options[] = {

      { "help",        NULL,          OPT_HELP },
      { "FuncString1", &FuncString1,  OPT_INT },
      { "FuncString2", &FuncString2,  OPT_INT },
      { "recurse",     sampleOptions, OPT_SUBOPTION,
	"points back to the toplevel structure.  Very amusing.  :-)" },
      { "STOP",        NULL,          OPT_STOP_PARSING,
	"halts parsing within the Func2." },

      TERMINATE_ARRAY

    };

    if ( fHelp ) {

      CHAR buffer[ 255 ];

      PrintUsageEntry( stderr,
		       "[-/+]",         // switch characters
		       pData->argv[0],  // command GUARANTEED TO EXIST
		       "->",           // separator
		       "Exercises the OPT_FUNC2 interface.  Options follow",
		       FALSE );         // FALSE--> do not repeat switch.

      sprintf( buffer, "-> options %s takes ", pData->argv[0] );

      PrintUsageEntry( stderr,
		       NULL,
		       NULL,
		       "-=",   // the NULLs will fill with this string.
		       buffer,
		       TRUE );

      sprintf( buffer, "(%s) ", pData->argv[0] );

      PrintUsage( stderr,
		  0L, // flags
		  OptFunc2Options,
		  buffer );

      PrintUsageEntry( stderr,
		       NULL,
		       NULL,
		       "-*",
		       "-> (end of OPT_FUNC2 options)",
		       TRUE );

      return TRUE;

    } else {

      if ( pData->optionVersion != OPT_FUNC_PARAMETER_VERSION ) {
	fprintf( stderr,
		 "WARNING: option library out of sync with header\n" );
      }

      fprintf( stderr,
	       "MyOptFunc2 called.  Data follows:\n"
	       "pData->optionVersion = %d\n"
	       "pData->dataField     = 0x%p\n"
	       "pData->argc          = %d\n"
	       "pData->argv          = 0x%p\n"
	       "pData->optionFlags   = 0x%x\n"
	       "pData->pSaveQueue    = 0x%p\n",

	       pData->optionVersion,
	       pData->dataFieldPointer,
	       pData->argc,
	       pData->argv,
	       pData->optionFlags,
	       pData->pSaveQueue );

      fprintf( stderr, "%s arguments are:\n", pData->argv[0] );

      DumpArgs( pData->argc, pData->argv );

      if ( ParseOptionsEx( pData->argc-1,
			   pData->argv+1,
			   OptFunc2Options,
			   pData->optionFlags,
			   &pData->pSaveQueue,
			   &pData->argsused,
			   &pData->argv ) ) {

	fprintf( stderr,
		 "pData->argsused IN   = %d\n", pData->argsused );

	pData->argsused = pData->argc - pData->argsused;

	fprintf( stderr,
		 "pData->argsused OUT  = %d\n", pData->argsused );

      } else return FALSE;

    }

    fprintf( stderr, "\n Leaving OPT_FUNC2. \n\n" );

    return TRUE;

}



int
main( int  argc,
      char *argv[] ) {

    BOOL  foo;
    PVOID pCleanup = NULL;
    optEnumStruct parserOptions[] = {

      { "skip",       (PVOID) OPT_FLAG_SKIP_UNKNOWNS,
	"OPT_FLAG_SKIP_UNKNOWNS" },
      { "reassemble", (PVOID) OPT_FLAG_REASSEMBLE,
	"OPT_FLAG_REASSEMBLE" },
      { "terminate",  (PVOID) OPT_FLAG_TERMINATE,
	"OPT_FLAG_TERMINATE" },

      TERMINATE_ARRAY
    };

    ULONG ParserFlag = OPT_FLAG_REASSEMBLE;

#ifndef DEBUG_OPTIONS
    BOOL DebugFlag = 0; // will be ignored... just here for convenience
#endif
    optionStruct singleOption[] = {

      { "utestHelp",  NULL, OPT_HELP },

      { "parserFlag", &ParserFlag, OPT_ENUMERATED,
	"flags to pass to ParseOptionsEx", parserOptions },
      { "headerlength", &OptMaxHeaderLength, OPT_INT,
	"OptMaxHeaderLength value (formatting)" },
      { "commandLength", &OptMaxCommandLength, OPT_INT,
	"OptMaxCommandLength value (formatting)" },
      { "separatorLength", &OptMaxSeparatorLength, OPT_INT,
	"OptMaxSeparatorLength value (formatting)" },
      { "descriptionLength", &OptMaxDescriptionLength, OPT_INT,
	"OptMaxDescriptionLength value (formatting)" },
      { "debug",      &DebugFlag,  OPT_INT, "Debugger status" },

      TERMINATE_ARRAY

    };

    DebugFlag |= OPTION_DEBUGGING_LEVEL;

    foo = ParseOptionsEx( argc-1, argv+1, singleOption,
			  0, &pCleanup, &argc, &argv );

    ParserFlag |= OPT_FLAG_MEMORYLIST_OK;

    fprintf( stderr,

	     "first ParseOptionsEx returned 0x%x \n"
	     "                    saveQueue 0x%p \n"
	     "             passing in flags 0x%x \n",

	     foo, pCleanup, ParserFlag );

    if ( argc ) {

      ULONG i;

      fprintf( stderr, "%d new options: \n", argc );
      DumpArgs( argc, argv );

      fprintf( stderr, "\n" );
    }

    foo = ParseOptionsEx( argc, argv, sampleOptions, ParserFlag,
			  &pCleanup, &argc, &argv );

    fprintf( stderr,
	     "ParseOptionsEx returns %d\n"
	     "          new argv = 0x%p\n"
	     "          new argc = %d \n",
	     foo, argv, argc );


    DumpArgs( argc, argv );

    printf( "Formatting values were:\n"
	    "\tOptMaxHeaderLength      = %d\n"
	    "\tOptMaxCommandLength     = %d\n"
	    "\tOptMaxSeparatorLength   = %d\n"
	    "\tOptMaxDescriptionLength = %d\n",

	    OptMaxHeaderLength,
	    OptMaxCommandLength,
	    OptMaxSeparatorLength,
	    OptMaxDescriptionLength );

    printf( "\nOptions used:\n"
	    "\tstring           = \"%hs\"\n"
	    "\tint              = %d \n"
	    "\tBool             = 0x%x \n"
	    /* "Float   = %f \n" */
	    "\twstring          = L\"%ws\"\n"
	    "\tustring          = (unicode string) %wZ \n"
	    "\thidden           = \"%hs\"\n"
	    "\tsubstruct:substr = \"%hs\"\n"
	    "\tfuncString1      = \"%hs\"\n"
	    "\tfuncString2      = \"%hs\"\n"
	    "\tenum             = %d (0x%x)\n",

	    StringOption,
	    IntegerOption,
	    BooleanOption,
	    /* FloatOption, */ /* floating point not loaded?
	                          What does that mean?! */
	    WideCharOption,
	    &UnicodeStringOption,
	    UndocumentedString,
	    SubString,
	
	    FuncString1,
	    FuncString2,

	    enumTestVariable, enumTestVariable  );

    CleanupOptionDataEx( pCleanup );

    return foo;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\opt\parse.c ===
/*++

  PARSE.C

  Option parser

  Split from options.c 6/9/1997 by DavidCHR

  --*/

#include "private.h"
#include <malloc.h>

/* ParseOneOption:

   parses a single option from argv.  
   returns: number of arguments eaten, or zero on error */

BOOL
ParseOneOption( int           argc,     // number of arguments, total 
		PCHAR        *argv,     // vector of arguments 
		int           argi,     // which argument we're to parse
		ULONG         flags,    // applicable flags
		optionStruct *options,  // option structure 
		int          *argsused, // arguments we've eaten
		PBOOL         pbStop,   // Stop Parsing 
		PSAVEQUEUE    pQueue    // memory save area
		) {

    PCHAR p;           // argument pointer copy 
    int   opti;        // which option we're examining
    BOOL  ret  = FALSE; // return value 
    int   tmp  = 0;     // temporary inbound value
    int   used = 0;

    ASSERT( argc     >  0    ); // there must be arguments                   
    ASSERT( argv     != NULL ); // the vector must exist                     
    ASSERT( argi     <  argc ); // argument number must be INSIDE the vector 
    ASSERT( options  != NULL ); // passed option structure must be valid     
    ASSERT( argsused != NULL );

    p     = argv[argi];

    if( ISSWITCH( p[0] ) ) {
      p++; /* skip the switch character */
    }

    OPTIONS_DEBUG("Checking option %d: \"%hs\"...", argi, p);

    for (opti = 0 ; !ARRAY_TERMINATED( options+opti ) ; opti++ ) {
	
      OPTIONS_DEBUG("against [%d]%hs...", opti, options[opti].cmd);

      if ( ParseCompare( options+opti, flags, p ) ) {
	  /* we have a match! */
	
	ret = StoreOption( options, argv, argc, argi, opti, 
			   flags, &tmp, TRUE, pbStop, pQueue );

	OPTIONS_DEBUG( "StoreOption returned %d, args=%d, *pbStop = %d\n", 
		       ret, tmp, *pbStop  );

	if ( !ret ) {

	  /* failed to store options for some reason.  This is
	     critical. */

	  PrintUsage( stderr, flags, options, "" );
	  
	  if ( flags & OPT_FLAG_TERMINATE ) {
	    exit( -1 );
	  } else {
	    return FALSE;
	  }

	}

	OPTIONS_DEBUG( "ParseOneOption now returning TRUE, argsused = %d.\n",
		       tmp );

	*argsused = tmp;
	return ret; /* successful StoreOptions parses our one option. */

      } /* if ParseCompare... */

      OPTIONS_DEBUG( "nope.\n" );

    } /* options for-loop */
    
    OPTIONS_DEBUG( "did not find the option.  Checking for OPT_DEFAULTs.\n" );

    for (opti = 0 ; !ARRAY_TERMINATED( options+opti ) ; opti++ ) {

      if ( options[opti].flags & OPT_DEFAULT ) {

	/* WASBUG 73922: should check to see if the option is also an
	   OPT_SUBOPTION, then parse the suboption for OPT_DEFAULTs.
	   However, as it stands, this will just fail for OPT_SUBOPTIONS,
	   because the first pointer will probably be nonnull. 

	   The dev enlistment doesn't contain any OPT_SUBOPTIONS, so
	   this is not an issue. */

	ASSERT( ( options[ opti ].flags & OPT_MUTEX_MASK ) != OPT_SUBOPTION );

	if ( *( ((POPTU) &options[opti].data)->raw_data) == NULL ) {

	  OPTIONS_DEBUG("Storing %hs in unused OPT_DEFAULT %hs\n",
			argv[argi],
			options[opti].cmd );

	  ret = StoreOption( options, argv, argc, argi, opti, 
			     flags, &tmp, FALSE, pbStop, pQueue );
	  OPTIONS_DEBUG("OPT_DEFAULT: StoreOptions returned %d\n", ret);

	  if ( !ret ) {
	    PrintUsage( stderr, flags, options, "" );
	    exit( -1 );
	  }

	  *argsused = tmp;
	  return ret;

	}
      }
    }

    *argsused = 0;

    if ( ( flags & OPT_FLAG_SKIP_UNKNOWNS )  ||
	 ( flags & OPT_FLAG_REASSEMBLE )     ||
	 ( flags & OPT_FLAG_INTERNAL_JUMPOUT )) {

      return TRUE; // skip this option

    } else {

      fprintf(stderr, "unknown option \"%hs\".\n", argv[argi]);
      PrintUsage(stderr, flags,  options, "");

      if ( flags & OPT_FLAG_TERMINATE ) {
	exit( -1 );
      }

      return FALSE;

    }

    ASSERT_NOTREACHED( "should be no path to this code" );

}


/* ParseOptionsEx:

   initializes the option structure, which is a sentinally-terminated
   vector of optionStructs.  

   argc, argv:       arguments to main() (see K&R)
   pOptionStructure: vector of optionStructs, terminated with TERMINATE_ARRAY
   optionFlags:      optional flags to control api behavior
   ppReturnedMemory: returned handle to a list of memory to be freed before
                     program exit.  Use CleanupOptionDataEx to free it. 

   new_arg[c,v]:     if nonnull, a new argc and argv are returned here.
                     if all the options were used up, argc = 0 and argv is
		     NULL.  Note that it is safe to provide pointers to the
		     original argv/argc if so desired.
   
   The function's behavior is complex:
   
   the function will always return FALSE on any critical error (unable to
   allocate memory, or invalid argument).  On WINNT, Last Error will be
   set to the appropriate error.

   if new_argc AND new_argv are specified, 
      ParseOptionsEx will always return TRUE unless help was called, and
      the two parameters will be updated to reflect new values.

   otherwise:
      ParseOptionsEx will return TRUE if it was able to recognize ALL args
      on the command line given.  It will return FALSE if any of the options
      were unknown.  This will probably be what most people want.
*/

BOOL
ParseOptionsEx( int           argc,
		char        **argv,
		optionStruct *options,

		ULONG         flags,
		PVOID         *ppReturnedMemory,
		int           *new_argc,
		char        ***new_argv ) {
    
    BOOL       bStopParsing  = FALSE;
    BOOL       ret           = FALSE;
    LONG       argi;                 // argument index
    LONG       tmp;                  // temporary return variable
    PSAVEQUEUE pSaveQueue    = NULL; // memory save area
    PCHAR     *pUnknowns     = NULL; // will alloc with alloca
    int        cUnknowns     = 0;

    flags = flags & ~OPT_FLAG_INTERNAL_RESERVED; /* mask off flags that
						    the user shouldn't set. */

    if ( new_argc && new_argv &&
	 !( flags & ( OPT_FLAG_SKIP_UNKNOWNS |
		      OPT_FLAG_REASSEMBLE    |
		      OPT_FLAG_TERMINATE ) ) ) {

      OPTIONS_DEBUG( "\nSetting internal jumpout flag.\n" );
      flags |= OPT_FLAG_INTERNAL_JUMPOUT;
    }

    OPTIONS_DEBUG( "ParseOptionsEx( argc  = %d\n"
		   "                argv  = 0x%x\n"
		   "                opts  = 0x%x\n"
		   "                flags = 0x%x\n"
		   "                ppMem = 0x%x\n"
		   "                pargc = 0x%x\n"
		   "                pargv = 0x%x\n",

		   argc, argv, options, flags, ppReturnedMemory, new_argc,
		   new_argv );

    ASSERT( ppReturnedMemory != NULL );
    
    // first, we need to ensure we have a save area.

    if ( flags & OPT_FLAG_MEMORYLIST_OK ) {

      pSaveQueue = (PSAVEQUEUE) *ppReturnedMemory;
      
    } else if ( !OptionAlloc( NULL, &pSaveQueue, sizeof( SAVEQUEUE ) ) ) {
      fprintf( stderr, 
	       "ParseOptionsEx: unable to allocate save area\n" );
      return FALSE;
    }
    
    ASSERT( pSaveQueue != NULL );

    /* We must initialize pUnknowns if the user specified command-line
       reassembly.  Otherwise, it can stay NULL. */

    if ( (flags & OPT_FLAG_REASSEMBLE) && ( argc > 0 ) ) {
     
      pUnknowns = (PCHAR *) alloca( argc * sizeof( PCHAR ) );

      ASSERT( pUnknowns != NULL ); /* yes, this assertion is invalid.  
				      However, there is no clean solution if
				      we run out of stack space.  Something 
				      else will just fail even more
				      spectacularly. */
    }

    OPTIONS_DEBUG("options are at 0x%x\n", options);

#ifdef DEBUG_OPTIONS
    
    if (DebugFlag) {

      for (argi = 0; argi < argc ; argi++  ) {
	OPTIONS_DEBUG("option %d is %hs\n", argi, argv[argi]);
      }
    }

#endif

    for (argi = 0 ; argi < argc ; /* NOTHING */ ) {

      int tmp;

      if ( bStopParsing ) { // this gets set in the PREVIOUS iteration.
	
	OPTIONS_DEBUG( "bStopParsing is TRUE.  Terminating parse run.\n");
	
	/* WASBUG 73924: now what do we do with the unused options?
	   They get leaked.  This is okay, because the app terminates. */
	
	break;
      }

      if ( ParseOneOption( argc, argv, argi, flags, options, &tmp,
			   &bStopParsing, pSaveQueue ) ) {

	OPTIONS_DEBUG( "ParseOneOption succeeded with %d options.\n", tmp );

	if ( tmp > 0 ) {

	  // we were able to successfully parse one or more options.

	  argi += tmp;

	  OPTIONS_DEBUG( "advancing argi by %d to %d\n", tmp, argi );

	  continue;

	} else { 

	  if ( flags & OPT_FLAG_REASSEMBLE ) {

	    ASSERT( pUnknowns != NULL );
	    ASSERT( cUnknowns <  argc );

	    OPTIONS_DEBUG( "OPT_FLAG_REASSEMBLE: this is unknown %d\n",
			   cUnknowns );

	    pUnknowns[ cUnknowns ] = argv[ argi ];
	    cUnknowns              ++;
	    argi                   ++; // skipping this option
	    
	  } else if ( !( flags & OPT_FLAG_SKIP_UNKNOWNS ) ) {

	    if ( new_argv && new_argc ) {
	      
	      OPTIONS_DEBUG( "new argv and argc-- breakout at "
			     "argi=%d\n", argi );

	      break; /* we're not skipping the unknown values or
			reassembling the command line.  We're just
			supposed to quit on unknown options. */
	      
	    }

	  }

	  continue;

	}

      } else {

	/* error or unknown option, depending on our flags.  Regardless,
	   an error message has already been printed. */

	ret = FALSE;
	goto cleanup;

      }

    } /* command-line for-loop */

    /* if we make it this far, all the options were ok.
       Check for unused OPT_NONNULLs... */
    
    OPTIONS_DEBUG( "\n*** Searching for unused options ***\n\n" );

    if (!FindUnusedOptions( options, flags, NULL, pSaveQueue ) ) {
      
      /* unused OPT_NONNULLS are a critical error.  Even if the user
	 specifies OPT_FLAG_SKIP_UNKNOWNS, he/she still told us not to
	 let the user unspecify the option.  We default to returning FALSE.*/

      if ( flags & OPT_FLAG_TERMINATE ) {

	exit( -1 );

      } else {
	  
	ret  = FALSE;
	goto cleanup;

      }
    } 
    
    OPTIONS_DEBUG( "All variables are OK.  Checking reassembly flag:\n" );

    if ( new_argv && new_argc ) {

      int i;

      // we may have skipped some of the options.

      if ( flags & OPT_FLAG_REASSEMBLE ) {
      
	OPTIONS_DEBUG( "REASSEMBLY: " );

	for( i = 0 ; argi + i < argc ; i++ ) {
	  
	  /* tack arguments we never parsed ( OPT_STOP_PARSING can cause 
	     this ) onto the end of the Unknown array */
	 
	  OPTIONS_DEBUG( "Assembling skipped option %d (%s) as unknown %d.\n",
			 i, argv[ argi+i ], cUnknowns+i );
	  
	  pUnknowns[ cUnknowns+i ] = argv[ argi+i ];
	  cUnknowns++;

	}

	if ( cUnknowns > 0 ) {

	  OPTIONS_DEBUG( "There were %d unknowns.\n", cUnknowns);

	  for ( i = 0 ; i < cUnknowns ; i++ ) {
	    
	    ASSERT( pUnknowns != NULL );
	    
	    (*new_argv)[i] = pUnknowns[i];
	    
	  }

	} else OPTIONS_DEBUG( "There were no unknowns. \n" );

	(*new_argv)[cUnknowns] = NULL;
	*new_argc              = cUnknowns;

#if 0 // same outcome as if the flag didn't exist
      } else if ( flags & OPT_FLAG_SKIP_UNKNOWNS ) {

	OPTIONS_DEBUG( "User asked us to skip unknown options.\n"
		       "zeroing argv and argc.\n" );
#endif
	
      } else if ( argi != argc ) {

	/* normal operation-- go until we hit unknown options.

	   argi is the index of the first unknown option, so we add
	   it to argv and subtract it from argc. */

	*new_argv = argv+argi;
	*new_argc = argc-argi;

	OPTIONS_DEBUG( "normal operation-- parsing was halted.\n"
		       "new_argv = %d.  new_argc = 0x%x.\n",

		       *new_argv, *new_argc );
      } else {

	*new_argv = NULL;
	*new_argc = 0;

      }

    } else {

#if 0
      if ( new_argv && new_argc ) {

	OPTIONS_DEBUG( "Catch-all case.  Zeroing argv and argc.\n" );

	*new_argv = NULL;
	*new_argc = 0;

      }
#else

      OPTIONS_DEBUG( "User didn't request new argv or argc.\n" );

#endif

    }

    OPTIONS_DEBUG( "command line survived the parser.\n" );

    ret = TRUE;

cleanup:

    ASSERT( pSaveQueue != NULL );

    if (!( flags & OPT_FLAG_MEMORYLIST_OK ) ) {

      if ( ret ) {
	
	OPTIONS_DEBUG( "Returning SaveQueue = 0x%x\n", pSaveQueue );

	*ppReturnedMemory = (PVOID) pSaveQueue;
	
      } else {
	
	OPTIONS_DEBUG( "function failing.  cleaning up local data..." );
	CleanupOptionDataEx( pSaveQueue );
	OPTIONS_DEBUG( "ok.\n" );

	*ppReturnedMemory  = NULL;
	
      }
    }

    return ret;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\opt\private.h ===
/*++

  PRIVATE.H

  Header files and privates for the options project

  Created, DavidCHR 6/9/1997 

  --*/

#include "..\inc\master.h"
#include ".\options.h"
#include ".\client.h"

#define STRCASECMP  lstrcmpiA
#define STRNCASECMP _strnicmp

#ifdef DEBUG_OPTIONS
#define OPTIONS_DEBUG printf
#else
#define OPTIONS_DEBUG /* nothing */
#endif

typedef struct savenode {

  PVOID            DataElement;
  ULONG            DeallocMethod;
  struct savenode *next;

} SAVENODE, *PSAVENODE;

typedef struct {

  PSAVENODE FirstNode;
  PSAVENODE LastNode;

} SAVEQUEUE, *PSAVEQUEUE;


typedef union _optionUnion {

  PVOID          *raw_data;              
  OPTFUNC        *func;
  OPTFUNC2       *func2;
  int            *integer;
  float          *real;
  PCHAR          *string;
  BOOL           *boolean;
  optionStruct   *optStruct;
  
#ifdef WINNT
  UNICODE_STRING *unicode_string;
  PWCHAR         *wstring;
#endif

} optionUnion, OPTU, *POPTU;


#define OPT_FLAG_INTERNAL_JUMPOUT 0x10 // for internal use only.

/* The DeallocationMethods are: */

typedef enum {

  DEALLOC_METHOD_TOO_SMALL = 0, /* MUST BE FIRST */

  DeallocWithFree,
  DeallocWithLocalFree,
  DeallocWithOptionDealloc,
  
  DEALLOC_METHOD_TOO_LARGE /* MUST BE LAST */

} DEALLOC_METHOD;


BOOL
ParseSublist( POPTU      Option,
	      PCHAR     *argv,
	      int        argc,
	      int        theIndex,

	      int        *argsused,
	      ULONG      flags,
	      PBOOL      pbStopParsing,
	      PSAVEQUEUE pQueue ); /* sublist.c */

BOOL
StoreOption( optionStruct *opt, 
	     PCHAR        *argv,
	     int           argc,
	     int           argi,
	     int           opti,
	     ULONG         flags,
	     int          *argsused,
	     BOOL          includes_arg,
	     PBOOL         pbStopParsing,
	     PSAVEQUEUE    pQueue ); /* store.c */

BOOL
ParseOneOption( int           argc,
		PCHAR        *argv,
		int           argi,
		ULONG         flags,
		optionStruct *options,
		int          *argsused,
		PBOOL         pbStopParsing,
		PSAVEQUEUE    pSaveQueue ); // parse.c

BOOL
ParseCompare( optionStruct *optionEntry,
	      ULONG         flags,
	      PCHAR         argument );  /* compare.c */


/* Use this macro to easily get an option union from the necessarily-
   obscured structure_entry. */

#define POPTU_CAST( structure_entry ) ( (POPTU) &((structure_entry).data) )

// EXAMPLE:    POPTU_CAST( options[opti] )->string 

BOOL
FindUnusedOptions( optionStruct         *options,
		   ULONG                 flags,
		   /* OPTIONAL */ PCHAR  prefix,
		   PSAVEQUEUE            pQueue ) ; // nonnull.c

BOOL
StoreEnvironmentOption( optionStruct *opt,
			ULONG         flags,
			PSAVEQUEUE    pQueue); // store.c

BOOL
ResolveEnumFromStrings( ULONG          cStrings,
			PCHAR         *strings,
			optionStruct  *theOpt,
			ULONG         *pcArgsUsed ); // enum.c

BOOL
PrintEnumValues( FILE          *out,
		 PCHAR          header,
		 optEnumStruct *pStringTable ); // enum.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\opt\unparse.c ===
/*++

  UNPARSE.C

  utility function to convert a flat command back into an argc/argv pair.
  Scavenged from the Keytab subdirectory because it makes more sense here,
  on 8/19/1997 by DavidCHR

  --*/

#include "private.h"

/* UnparseOptions:

   cmd --> argc/argv.  Free argv with free().  */

BOOL
UnparseOptions( PCHAR  cmd,
                int   *pargc,
                PCHAR *pargv[] ) {

    int    argc=0;
    PCHAR *argv=NULL;
    char   prevChar='\0';
    int    szBuffer;
    int    i=0;
    PCHAR  heapBuffer=NULL;

    szBuffer = lstrlenA(cmd);

    for (i = 0; cmd[i] != '\0' ; i++ ) {

      /* count the characters while we count the words.
         could use strlen, but then we'd parse it twice,
         which is kind of unnecessary if the string can
         get fairly long */

      OPTIONS_DEBUG("[%d]'%c' ", i, cmd[i]);

      if (isspace(prevChar) && !isspace(cmd[i]) ) {
        /* ignore multiple spaces */
        OPTIONS_DEBUG("[New word boundary]");
        argc++;
      }

      prevChar = cmd[i];

    }

    if (!isspace(prevChar)) {
      argc++; /* trailing null is also a word boundary if the last
                 character was non-whitespace */
      OPTIONS_DEBUG("Last character is not a space.  Argc = %d.\n", argc);
    }
    OPTIONS_DEBUG("done parsing.  i = %d.  buffer-->%hs\n",
		  i, cmd);

    OPTIONS_DEBUG("saving argc...");

    *pargc = argc; // save argc.

    /* ok, argc is our wordcount, so we must allocate argc+1 
	 (null terminate) pointers and i+1 (null terminate) characters */

    argv = (PCHAR *) malloc( ((argc+1) * sizeof( PCHAR )) +
			     ((i+1) * sizeof(CHAR)) );

    if ( !argv ) {
      return FALSE;
    }
    
    OPTIONS_DEBUG("ok.\nsaving argv (0x%x)...", argv);
    *pargv = argv; // save the argv.

    OPTIONS_DEBUG( "ok.\n"
		   "Assigning heapBuffer as argv[argc+1 = %d] = 0x%x...",
		   argc+1, argv+argc+1);

    /* now we've got this glob of memory, separate the pointers from
	 the characters.  The pointers end at argv[argc], so &(argv[argc+1])
	 should start the rest */

    heapBuffer = (PCHAR) &(argv[argc+1]);

    /* now, copy the string, translating spaces to null characters and
	 filling in pointers at the same time */

    OPTIONS_DEBUG("ok\ncopying the string manually...");

    argc = 0; // reuse argc, since it's saved.

    prevChar = ' ';

    for (i = 0 ; cmd[i] != '\0' ; i++ ) {

      if (isspace(cmd[i])) {

	OPTIONS_DEBUG("[%d]'%c' --> NULL\n", i, cmd[i]);
	heapBuffer[i] = '\0';

      } else { // current char is not a space.

	heapBuffer[i] = cmd[i];

	OPTIONS_DEBUG("[%d]'%c' ", i, cmd[i]);

	if (isspace(prevChar)) {
	  /* beginning of a word.  Set the current word pointer
	     (argv[argc]) in addition to the regular stuff */

	  OPTIONS_DEBUG("[word boundary %d]", argc);

	  argv[argc] = &(heapBuffer[i]);
	  argc++;
	}
      }

      prevChar = cmd[i];

    }

    heapBuffer[i] = '\0'; // copy the null character too.
    OPTIONS_DEBUG("[%d] NULL\n", i );

    OPTIONS_DEBUG("returning:\n");
    for (i = 0 ; i < argc ; i++ ) {
      OPTIONS_DEBUG("[%d]%hs\n", i, argv[i]);
    }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\opt\store.c ===
/*++

  STORE.C

  code for StoreOption

  moved from options.c, 6/9/1997 

  --*/

#include "private.h"

#ifdef WINNT
#include <winuser.h>
#endif

typedef struct {

  PCHAR word;
  BOOL  value;

} SYNONYMS;

static SYNONYMS BoolSynonyms[] = {

  "on", TRUE,
  "off", FALSE

};

static int szBoolSynonyms = sizeof(BoolSynonyms) / sizeof(SYNONYMS);

BOOL
StoreOptionStrings( optionStruct *opt,  /* pointer to the entry */
		    ULONG         argc,  // count of strings to try to store
		    PCHAR         *argv, // argv[0] --> first string to store
		    ULONG         flags,
		    PULONG        pcStored,
		    PSAVEQUEUE    pQueue ) {

    PCHAR tostore;

    *pcStored      = 1;     // default.
    tostore   = argv[0];
    

    OPTIONS_DEBUG( "StoreOptionString: opt=0x%x, toStore=\"%s\"...",
		   opt, tostore );

    if ( !tostore ) {
      fprintf( stderr, "Parser: option \"%s\" is missing its argument.\n",
	       opt->cmd );
      return FALSE;
    }

    switch( opt->flags & OPT_MUTEX_MASK ) {

     case OPT_ENUMERATED:

	 OPTIONS_DEBUG("[OPT_ENUMERATED]");

	 return ResolveEnumFromStrings( argc, argv, opt, pcStored );

     case OPT_STRING:

	 OPTIONS_DEBUG("[OPT_STRING]");

	 *( POPTU_CAST( *opt )->string  ) = tostore;

	 return TRUE;

#ifdef WINNT  /* Wide-Character Strings and UNICODE strings */

	 /* note that we add one (at least) to argi when referencing 
	    wargv.  This is because wargv includes the executable name.

	    This problem is solved in a later drop of the argument lib. */

     case OPT_WSTRING:

     { 
       PWCHAR p;
       ULONG  len;
       
       len = strlen( tostore ) +1;
       
       if ( OptionAlloc( pQueue, &p, len * sizeof( WCHAR ) ) ) {

	 wsprintfW( p, L"%hs", tostore );

	 *(POPTU_CAST( *opt )->wstring ) = p;
		  
	 return TRUE;

       } else {

	 fprintf( stderr, "ERROR: cannot allocate WCHAR memory\n" );
	 return FALSE;
       }

     }

     case OPT_USTRING:
	 
     { 

       PWCHAR p;
       ULONG  len;

       len = strlen( tostore ) +1;
       
       if ( OptionAlloc( pQueue, &p, len * sizeof( WCHAR ) ) ) {

	 wsprintfW( p, L"%hs", tostore );

	 RtlInitUnicodeString( ( POPTU_CAST( *opt ) -> unicode_string ), p );
	 
	 return TRUE;

       } else {

	 fprintf( stderr, "ERROR: cannot allocate Unicode memory\n" );
	 return FALSE;
       }

     }

#endif

     case OPT_INT:
	 OPTIONS_DEBUG("[OPT_INT]");

	 if ( !isxdigit( tostore[0] ) ) {
	   fprintf( stderr, "Parser: argument \"%s\" is not a number.\n",
		    tostore );
	   return FALSE;
	 }

	 *( POPTU_CAST( *opt ) ->integer ) = strtol( tostore, NULL, 0 ) ;

	 return TRUE;

     case OPT_BOOL:

     {

       int i;
	   
       for (i = 0 ; i < szBoolSynonyms ; i++ ) {
	 
	 OPTIONS_DEBUG( "Comparing %hs against synonym %hs...",
			tostore,
			BoolSynonyms[i].word );
	 
	 if (STRCASECMP( BoolSynonyms[i].word,
			 tostore ) == 0 ) {
	   
	   *(POPTU_CAST( *opt )->boolean ) = BoolSynonyms[i].value;
	   
	   return TRUE;
	     
	 }
       }

       // if we get here, we had no idea.  toggle the option.

       *(POPTU_CAST( *opt )->boolean ) = ! *(POPTU_CAST( *opt )->boolean );
       return TRUE;
     }


	 
     default: /* unknown or unspecified option type */

       /* while we don't see all the options in this switch, to store a 
	  single string option, you would have to modify this one, so we
	  hook this switch into all of them. */
	 
#if (HIGHEST_OPTION_SUPPORTED != OPT_STOP_PARSING )
#error "new options? update this switch if your option uses 1 string."
#endif

	 fprintf(stderr, 
		 "Internal error: option \"%hs\" has bad type 0x%x."
		 "  Skipping this option.\n",
		 opt->cmd, opt->flags & OPT_MUTEX_MASK );

	 return FALSE;

    } /* options switch */
    
    
    ASSERT_NOTREACHED( "*Everything* should be handled by the switch" );

}



/*++ StoreOption:
   
   Stores a single option within the structure.

   Returns the number of arguments used (including this one).
   If none were used (or an error occurs), returns zero.

   opt         : pointer to the option vector we're using-- the whole 
                 thing must be passed for OPT_HELP.
   argv, argc  : as in main()
   argi        : current index in argv[].  For example, if our command line 
                 were:
   
		 foo -bar 99 -baz 1
		
		 and we're trying to store the -bar 99 argument, we'd pass 1 
		 for argi, since foo is arg 0.
  opti         : index into opt we're storing

  includes_arg : if argi points to the argument (-bar above) itself, set this
                 to TRUE.  If argi points to the value of the argument (99 in
		 this case), set this to FALSE.


   We only handle the special cases here, and pass the normal cases off
   on StoreOptionString above

		 --*/

#define ARG(x) (includes_arg? (x) : ((x)-1)) /* local to StoreOption only */

BOOL
StoreOption( optionStruct *opt, 
	     PCHAR        *argv,
	     int           argc,
	     int           argi,
	     int           opti,
	     ULONG         flags,
	     int           *argsused,
	     BOOL          includes_arg /* set to true if we include the 
					   command argument (example: -foo BAR
					   would be TRUE but just BAR would 
					   not) */,
	     PBOOL         pbStopParsing,
	     PSAVEQUEUE    pQueue  ) {

    BOOL   ret  = FALSE;
    int    used = 0;
    ULONG  local_argc;
    PCHAR *local_argv;
	 
    *pbStopParsing = FALSE; // default.
    local_argc     = (includes_arg ? argi+1 : argi );
    local_argv     = argv + local_argc;
    local_argc     = argc - local_argc;

    OPTIONS_DEBUG( "StoreOption( opt=0x%x argv=0x%x argc=%d "
		   "argi=%d include=%d)",
		   opt, argv, argc, argi, includes_arg );

    switch( opt[opti].flags & OPT_MUTEX_MASK ) {

     case OPT_HELP:
	 PrintUsage( stderr, flags, opt, "" );

	 if ( flags & OPT_FLAG_TERMINATE ) {
	   exit( -1 );
	 } else {
	   *argsused = 1;
	   return TRUE;
	 }

     case OPT_CONTINUE:
     case OPT_DUMMY:
	 OPTIONS_DEBUG("[OPT_DUMMY or OPT_HELP]");
	 *argsused = ARG(1); /* just eat this parameter */
	 return TRUE;

     case OPT_FUNC:
     case OPT_FUNC2:
	
       {
	 PCHAR       *localargv;
	 unsigned int localargc;
	 int i;

	 if (includes_arg) {
	   localargv = &(argv[argi]);
	   localargc = argc - argi;
	 } else {
	   localargv = &(argv[argi-1]);
	   localargc = argc - argi -1;
	 }

	 if ( (opt[opti].flags & OPT_MUTEX_MASK)  == OPT_FUNC ) {

	   OPTIONS_DEBUG("Jumping to OPTFUNC 0x%x...", 
			 ((POPTU) &opt[opti].data)->raw_data );

	   i = ((POPTU) &opt[opti].data)->func(localargc, localargv);

	   if ( i <= 0 ) {
	     return FALSE;
	   }

	 } else {

	   OPT_FUNC_PARAMETER_DATA ParamData = { 0 };

	   ASSERT( ( opt[opti].flags & OPT_MUTEX_MASK) == OPT_FUNC2 );
	   OPTIONS_DEBUG( " Jumping to OPTFUNC2 0x%x...", 
			  opt[opti].optData );

	   ParamData.optionVersion    = OPT_FUNC_PARAMETER_VERSION;
	   ParamData.dataFieldPointer = POPTU_CAST( opt[opti] )->raw_data;
	   ParamData.argc             = localargc;
	   ParamData.argv             = localargv;
	   ParamData.optionFlags      = ( ( flags & ~OPT_FLAG_REASSEMBLE ) |
					  OPT_FLAG_MEMORYLIST_OK |
					  OPT_FLAG_INTERNAL_JUMPOUT );
	   ParamData.pSaveQueue       = pQueue;

#if OPT_FUNC_PARAMETER_VERSION > 1
#error "New OPT_FUNC_PARAMETERs?  change initialization code here."
#endif	   

	   OPTIONS_DEBUG( "data for OPT_FUNC2 is:\n"
			  "ParamData.optionVersion    = %d\n"
			  "ParamData.dataFieldPointer = 0x%x\n"
			  "ParamData.argc             = %d\n"
			  "ParamData.argv             = 0x%x\n"
			  "ParamData.optionFlags      = 0x%x\n"
			  "ParamData.pSaveQueue       = 0x%x\n",

			  ParamData.optionVersion,
			  ParamData.dataFieldPointer,
			  ParamData.argc,
			  ParamData.argv,
			  ParamData.optionFlags,
			  ParamData.pSaveQueue );			  

	   if ( ! (((OPTFUNC2 *)(opt[opti].optData))( FALSE, &ParamData ))) {
	     return FALSE;
	   }

	   i = ParamData.argsused;

	 }

	 OPTIONS_DEBUG("return from function: %d\n", i );

	 ASSERT( i > 0 );
	 *argsused = ARG( i );
	 return TRUE;

       }

     case OPT_SUBOPTION:

	 OPTIONS_DEBUG("[OPT_SUBOPTION]" );

	 return ParseSublist( ((POPTU) &opt[opti].data),
			      argv, argc, argi,
			      argsused, flags, pbStopParsing, pQueue );

     case OPT_STOP_PARSING:

       *pbStopParsing = TRUE;
       *argsused      = 1;   
       return           TRUE;

     case OPT_INT:
     case OPT_ENUMERATED:
     case OPT_STRING:
	 
#ifdef WINNT
     case OPT_WSTRING:
     case OPT_USTRING:
#endif
       if ( StoreOptionStrings( //argv[ includes_arg ? argi+1: argi],
				opt+opti, 
				local_argc,
				local_argv,
				flags, 
				&local_argc,
				pQueue ) ) {
	 
	 *argsused = ARG( local_argc +1 );
	 return TRUE;
	 
       } else {
	 
	 return FALSE;
       }
       
	       
     case OPT_BOOL:

	 OPTIONS_DEBUG("[OPT_BOOL]");

	 if (includes_arg) {

	   switch (argv[argi][0]) {
	    case '-':
		OPTIONS_DEBUG("option is negative.");
		
		*( ((POPTU) &opt[opti].data)->boolean ) = FALSE;

		*argsused = 1;
		return TRUE;
		
	    case '+':
		OPTIONS_DEBUG("option is positive.");
		*( ((POPTU) &opt[opti].data)->boolean ) = TRUE;

		*argsused = 1;
		return TRUE;

	  default:
	      
	      OPTIONS_DEBUG("skipping bool...");
	      break;
	   }
	 }

	 if (argi < argc-1) {

	   if ( StoreOptionStrings( opt+opti,
				    local_argc,
				    local_argv,
				    flags, 
				    // argv[ includes_arg ? argi+1 : argi ],
				    &local_argc,
				    pQueue) ) {

	     *argsused = ARG( 1 );
	     return TRUE;
	   }
	 }
	 /* else, if nothing else works, just toggle the option */
	 
	 OPTIONS_DEBUG("toggling option.");

	 *( ((POPTU) &opt[opti].data)->boolean ) = 
	   ! *( ((POPTU) &opt[opti].data)->boolean );
	 
	 *argsused = 1; // exactly one.
	 return TRUE;

     default: /* unknown or unspecified option type */
	 

#if (HIGHEST_OPTION_SUPPORTED != OPT_STOP_PARSING )
#error "new options? update this switch statement or bad things will happen."
#endif

	 fprintf(stderr, 
		 "Internal error: option \"%hs\" has unknown type 0x%x."
		 "  Skipping this option.\n",
		 opt[opti].cmd, opt[opti].flags & OPT_MUTEX_MASK );

	 return FALSE;

    } /* options switch */
    
}

BOOL
StoreEnvironmentOption( optionStruct *opt,
			ULONG         flags,
			PSAVEQUEUE    pQueue) {


    PCHAR p;
    ULONG dummy;

    ASSERT( opt->optData != NULL );

    p = getenv( opt->optData );

    if ( !p ) {

      return FALSE;

    }

    return StoreOptionStrings( opt, 1, &p, flags, &dummy, pQueue );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\opt\utest3.c ===
/*++

  UTEST.C

  Test program for the options subsystem.  Must compile under
  NT and UNIX

  Created, 5/24/1997 by DavidCHR

  --*/

#include "private.h"

optEnumStruct enums[] = {

  { "one",    (PVOID) 1,                          "should end up 1" },
  { "two",    (PVOID) 2,                          "should end up 2" },
  { "beef",   (PVOID)(UINT_PTR)(UINT) 0xdeadbeef, "should be 0xdeadbeef" },
  { "beefs",  (PVOID)(UINT_PTR)(UINT) 0xbadf00d,  "should be 0xbadf00d" },
  { "secret", (PVOID) 60,         },              // shouldn't show in help

  TERMINATE_ARRAY

};

ULONG enumTestVariable=0;

PCHAR SubString = NULL;


optionStruct substructOptions[] = {

  { "h",      NULL,       OPT_HELP },
  { "substr", &SubString, OPT_STRING, "Substring option" },

  TERMINATE_ARRAY
};

PCHAR          FuncString1         = NULL;
PCHAR          FuncString2         = NULL;
PCHAR          StringOption        = NULL;
int            IntegerOption       = 0L;
BOOL           BooleanOption       = FALSE;
float          FloatOption         = 0.0;
PCHAR          UndocumentedString  = NULL;
PWCHAR         WideCharOption      = NULL;
UNICODE_STRING UnicodeStringOption = { 0 };

int            MyOptFunc( IN  int argc,
			  IN  PCHAR *argv );
BOOL           MyOptFunc2( IN BOOL fHelp,
			   IN POPT_FUNC_PARAMETER_DATA pData );

optionStruct sampleOptions[ ] = {

  { "help",  NULL, OPT_HELP },
  { "?",     NULL, OPT_HELP },

  { NULL, NULL, OPT_DUMMY,    "-----------------------------" },
  { NULL, NULL, OPT_CONTINUE, "These are the useful options:" },
  { NULL, NULL, OPT_DUMMY,    "-----------------------------" },

  { "enum",      &enumTestVariable, OPT_ENUMERATED,
    "Test enumerated type", enums },

  { "mask",      &enumTestVariable, OPT_ENUMERATED | OPT_ENUM_IS_MASK,
    "Test enumerated type with OPT_ENUM_IS_MASK", enums },

  { "substruct", substructOptions, OPT_SUBOPTION | OPT_RECURSE,
    "substruct:help for help" },
  { "recurse",   sampleOptions,    OPT_SUBOPTION, "recurse:help for help" },

  { "string", &StringOption,  OPT_STRING | OPT_ENVIRONMENT, "String Option",
    "StringOption" },

  { NULL, NULL, OPT_CONTINUE, "Use this option to request a string" },

  { "int",    &IntegerOption,  OPT_INT | OPT_ENVIRONMENT,   "integer option",
    "IntegerOption" },

  { NULL, NULL, OPT_CONTINUE, "Use this option to request an integer" },

  { "func",   MyOptFunc,           OPT_FUNC,   "function option" },
  { NULL, NULL, OPT_CONTINUE, "Use this option to request two strings" },

  { "func2",  &IntegerOption,      OPT_FUNC2,  "FUNC2 option",
    MyOptFunc2 },

  { "bool",   &BooleanOption,      OPT_BOOL,   "boolean option" },
  { NULL, NULL, OPT_CONTINUE, "Use this option to request a boolean" },

  { "float",  &FloatOption,        OPT_FLOAT,  "floating point option" },
  { NULL, NULL, OPT_CONTINUE, "Use this option to request a float" },

  { "wstring",&WideCharOption, OPT_WSTRING | OPT_ENVIRONMENT,
    "Wide Char String option", "WideCharOption" },

  { "ustring",&UnicodeStringOption, OPT_USTRING | OPT_ENVIRONMENT,
    "Unicode String Option",  "UnicodeStringOption" },

  { "hidden", &UndocumentedString, OPT_STRING | OPT_HIDDEN,
    "you should never see this line.  This option is OPT_HIDDEN" },

  { "stop",   NULL,                OPT_STOP_PARSING,
    "halts parsing of the command line." },

  { NULL, NULL, OPT_DUMMY | OPT_NOHEADER, "" },

  { NULL, NULL, OPT_DUMMY | OPT_NOHEADER,
    "Example: utest /string \"foo bar baz\" /int 0x15 +bool /float 3.14" },

  { NULL, NULL, OPT_PAUSE },

  TERMINATE_ARRAY

};

int
MyOptFunc( int argc,
	   PCHAR *argv ) {

    if ( ( argv == NULL ) || (argc < 3 ) ) {
      /* this means the user requested help */
      fprintf( stderr, "func [string1] [string2]\n" );
      return 0;
    }

    printf( "MyOptFunc was called.  argc=%d.\n", argc );

    FuncString1 = argv[1];
    FuncString2 = argv[2];

    return 3; /* number of arguments eaten--
		 -func argv[1] argv[2] == 3 options */

}

VOID
DumpArgs( int argc,
	  PCHAR argv[] ) {

    int i;

    for ( i = 0 ; i < argc ; i++ ) {
      fprintf( stderr, "arg %d = %s\n", i, argv[i] );
    }

}

BOOL
MyOptFunc2( IN BOOL                     fHelp,
	    IN POPT_FUNC_PARAMETER_DATA pData ) {

#if OPT_FUNC_PARAMETER_VERSION != 1
#error "OptFuncParameterVersion has changed.  Update this function."
#endif

    optionStruct OptFunc2Options[] = {

      { "help",        NULL,          OPT_HELP },
      { "FuncString1", &FuncString1,  OPT_INT },
      { "FuncString2", &FuncString2,  OPT_INT },
      { "recurse",     sampleOptions, OPT_SUBOPTION,
	"points back to the toplevel structure.  Very amusing.  :-)" },
      { "STOP",        NULL,          OPT_STOP_PARSING,
	"halts parsing within the Func2." },

      TERMINATE_ARRAY

    };

    if ( fHelp ) {

      CHAR buffer[ 255 ];

      PrintUsageEntry( stderr,
		       "[-/+]",         // switch characters
		       pData->argv[0],  // command GUARANTEED TO EXIST
		       "->",           // separator
		       "Exercises the OPT_FUNC2 interface.  Options follow",
		       FALSE );         // FALSE--> do not repeat switch.

      sprintf( buffer, "-> options %s takes ", pData->argv[0] );

      PrintUsageEntry( stderr,
		       NULL,
		       NULL,
		       "-=",   // the NULLs will fill with this string.
		       buffer,
		       TRUE );

      sprintf( buffer, "(%s) ", pData->argv[0] );

      PrintUsage( stderr,
		  0L, // flags
		  OptFunc2Options,
		  buffer );

      PrintUsageEntry( stderr,
		       NULL,
		       NULL,
		       "-*",
		       "-> (end of OPT_FUNC2 options)",
		       TRUE );

      return TRUE;

    } else {

      if ( pData->optionVersion != OPT_FUNC_PARAMETER_VERSION ) {
	fprintf( stderr,
		 "WARNING: option library out of sync with header\n" );
      }

      fprintf( stderr,
	       "MyOptFunc2 called.  Data follows:\n"
	       "pData->optionVersion = %d\n"
	       "pData->dataField     = 0x%p\n"
	       "pData->argc          = %d\n"
	       "pData->argv          = 0x%p\n"
	       "pData->optionFlags   = 0x%x\n"
	       "pData->pSaveQueue    = 0x%p\n",

	       pData->optionVersion,
	       pData->dataFieldPointer,
	       pData->argc,
	       pData->argv,
	       pData->optionFlags,
	       pData->pSaveQueue );

      fprintf( stderr, "%s arguments are:\n", pData->argv[0] );

      DumpArgs( pData->argc, pData->argv );

      if ( ParseOptionsEx( pData->argc-1,
			   pData->argv+1,
			   OptFunc2Options,
			   pData->optionFlags,
			   &pData->pSaveQueue,
			   &pData->argsused,
			   &pData->argv ) ) {

	fprintf( stderr,
		 "pData->argsused IN   = %d\n", pData->argsused );

	pData->argsused = pData->argc - pData->argsused;

	fprintf( stderr,
		 "pData->argsused OUT  = %d\n", pData->argsused );

      } else return FALSE;

    }

    fprintf( stderr, "\n Leaving OPT_FUNC2. \n\n" );

    return TRUE;

}


int
__cdecl
main( int  argc,
      char *argv[] ) {

    BOOL  foo;
    PVOID pCleanup = NULL;
    optEnumStruct parserOptions[] = {

      { "skip",       (PVOID) OPT_FLAG_SKIP_UNKNOWNS,
	"OPT_FLAG_SKIP_UNKNOWNS" },
      { "reassemble", (PVOID) OPT_FLAG_REASSEMBLE,
	"OPT_FLAG_REASSEMBLE" },
      { "terminate",  (PVOID) OPT_FLAG_TERMINATE,
	"OPT_FLAG_TERMINATE" },

      TERMINATE_ARRAY
    };

    ULONG ParserFlag = OPT_FLAG_REASSEMBLE;

#ifndef DEBUG_OPTIONS
    BOOL DebugFlag = 0; // will be ignored... just here for convenience
#endif
    optionStruct singleOption[] = {

      { "utestHelp",  NULL, OPT_HELP },

      { "parserFlag", &ParserFlag, OPT_ENUMERATED,
	"flags to pass to ParseOptionsEx", parserOptions },
      { "headerlength", &OptMaxHeaderLength, OPT_INT,
	"OptMaxHeaderLength value (formatting)" },
      { "commandLength", &OptMaxCommandLength, OPT_INT,
	"OptMaxCommandLength value (formatting)" },
      { "separatorLength", &OptMaxSeparatorLength, OPT_INT,
	"OptMaxSeparatorLength value (formatting)" },
      { "descriptionLength", &OptMaxDescriptionLength, OPT_INT,
	"OptMaxDescriptionLength value (formatting)" },
      { "debug",      &DebugFlag,  OPT_INT, "Debugger status" },

      TERMINATE_ARRAY

    };

    DebugFlag |= OPTION_DEBUGGING_LEVEL;

    foo = ParseOptionsEx( argc-1, argv+1, singleOption,
			  0, &pCleanup, &argc, &argv );

    ParserFlag |= OPT_FLAG_MEMORYLIST_OK;

    fprintf( stderr,

	     "first ParseOptionsEx returned 0x%x \n"
	     "                    saveQueue 0x%p \n"
	     "             passing in flags 0x%x \n",

	     foo, pCleanup, ParserFlag );

    if ( argc ) {

      ULONG i;

      fprintf( stderr, "%d new options: \n", argc );
      DumpArgs( argc, argv );

      fprintf( stderr, "\n" );
    }

    foo = ParseOptionsEx( argc, argv, sampleOptions, ParserFlag,
			  &pCleanup, &argc, &argv );

    fprintf( stderr,
	     "ParseOptionsEx returns %d\n"
	     "          new argv = 0x%p\n"
	     "          new argc = %d \n",
	     foo, argv, argc );


    DumpArgs( argc, argv );

    printf( "Formatting values were:\n"
	    "\tOptMaxHeaderLength      = %d\n"
	    "\tOptMaxCommandLength     = %d\n"
	    "\tOptMaxSeparatorLength   = %d\n"
	    "\tOptMaxDescriptionLength = %d\n",

	    OptMaxHeaderLength,
	    OptMaxCommandLength,
	    OptMaxSeparatorLength,
	    OptMaxDescriptionLength );

    printf( "\nOptions used:\n"
	    "\tstring           = \"%hs\"\n"
	    "\tint              = %d \n"
	    "\tBool             = 0x%x \n"
	    /* "Float   = %f \n" */
	    "\twstring          = L\"%ws\"\n"
	    "\tustring          = (unicode string) %wZ \n"
	    "\thidden           = \"%hs\"\n"
	    "\tsubstruct:substr = \"%hs\"\n"
	    "\tfuncString1      = \"%hs\"\n"
	    "\tfuncString2      = \"%hs\"\n"
	    "\tenum             = %d (0x%x)\n",

	    StringOption,
	    IntegerOption,
	    BooleanOption,
	    /* FloatOption, */ /* floating point not loaded?
	                          What does that mean?! */
	    WideCharOption,
	    &UnicodeStringOption,
	    UndocumentedString,
	    SubString,
	
	    FuncString1,
	    FuncString2,

	    enumTestVariable, enumTestVariable  );

    CleanupOptionDataEx( pCleanup );

    return foo;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\keytab2\sync\common\defs.h ===
/*++

  DEFS.H

  definitions common to the unix side and the NT side.

  2/9/1997 -DavidCHR

  This file is the interface between the unix compiler and the nt 
  compiler.  It ensures that we can use the same basic stuff under
  both platforms (e.g. do not use ULONG, use LONG32... ).

  This file must build on NT and UNIX systems both.
  DO NOT include NT-specific code without ensuring that it will
  ONLY be seen by the NT compiler.

  --*/

#ifndef DEFS_H_INCLUDED
#define DEFS_H_INCLUDED 1

typedef ULONG KTLONG32, *PKTLONG32;
typedef BYTE  CHAR8,    *PCHAR8;

#ifndef TIMEOUT /* timeout values for all the netreads-- 0 = forever */
#define TIMEOUT 0 
#endif

#define WE_ARE_USELESS 10000 /* collides with some error values, but none that
				we happen to be using */



/* compiling under NT. */

#include "master.h"

#define WINNT_ONLY(statement) statement
#define UNIX_ONLY( statement) /* nothing */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\ksetup\dmpstate.cxx ===
/*++

  DMPSTATE.CXX

  Copyright (C) 1999 Microsoft Corporation, all rights reserved.

  DESCRIPTION: code and support for DumpState()

  Created, May 21, 1999 by DavidCHR.

  --*/

#include "everything.hxx"

extern NTSTATUS // realmflags.cxx
GetRealmFlags( IN  LPWSTR RealmName,
	       OUT PULONG pulRealmFlags );

extern VOID  // realmflags.cxx
PrintRealmFlags( IN ULONG RealmFlags );


DWORD
LoadAndPrintNames( IN LPSTR  KeyName,
		   IN HKEY   DomainKey,
		   IN BOOL   bPrintEmptyIfMissing,
		   IN LPWSTR ValueName ) {

    ULONG  KdcNameSize = 0, i;
    LPWSTR KdcNames;
    DWORD  WinError = STATUS_UNSUCCESSFUL;
    DWORD  Type;
    CMULTISTRING StringClass;

    if ( StringClass.ReadFromRegistry( DomainKey,
				       ValueName ) ) {
      
      if ( StringClass.cEntries != 0 ) {
	
	for ( i = 0 ;
	      i < StringClass.cEntries ;
	      i ++ ) {

	  printf( "\t%hs = %ws\n",
		  KeyName,
		  StringClass.pEntries[ i ] );

	}
	
      } else {

	if ( bPrintEmptyIfMissing ) {
	  
	  printf( "\t(no %hs entries for this realm)\n",
		  KeyName );
	  
	}
      }

    }

    return WinError;
}


NTSTATUS
PrintRealmList( VOID ) {

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG WinError;
    HKEY DomainRootKey = NULL;
    HKEY DomainKey = NULL;
    LPWSTR KdcNames = NULL;
    LPWSTR AlternateRealmNames = NULL;
    TCHAR DomainName[128];              // max domain name length
    ULONG Index,Index2;
    ULONG Type;
    ULONG NameSize;
    ULONG KdcNameSize = 0;
    ULONG AltRealmSize = 0;
    LPWSTR Where;
    ULONG NameCount;
    UNICODE_STRING TempString;
    ULONG          RealmFlags;

    //
    // Open the domains root key - if it is not there, so be it.
    //

    WinError = RegOpenKey(
                HKEY_LOCAL_MACHINE,
                KERB_DOMAINS_KEY,
                &DomainRootKey
                );

    switch( WinError ) {

     case ERROR_FILE_NOT_FOUND:
	printf( "(No RFC1510 Kerberos Realms are defined).\n" );
	goto Cleanup;

     case ERROR_SUCCESS:
       break;

     default:
       printf("Failed to open key %ws: 0x%x\n", KERB_DOMAINS_KEY, WinError );
       goto Cleanup;
    }

    //
    // If it is there, we now want to enumerate all the child keys.
    //

    Index = 0;
    for (Index = 0; TRUE ; Index++ )
    {
        //
        // Enumerate through all the keys
        //
        NameSize = sizeof(DomainName) / sizeof( DomainName[ 0 ] );
        WinError = RegEnumKeyEx(
                    DomainRootKey,
                    Index,
                    DomainName,
                    &NameSize,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

        if (WinError != ERROR_SUCCESS)
        {

	  if ( WinError != ERROR_NO_MORE_ITEMS ) {

	    printf( "Registry error 0x%x while enumerating domains.  Stopping here.\n",
		    WinError );

	  }
            break;
        }

        //
        // Open the domain key to tread the values under it
        //

        WinError = RegOpenKey(
                    DomainRootKey,
                    DomainName,
                    &DomainKey
                    );
        if (WinError != ERROR_SUCCESS)
        {
            printf("Failed to open key %ws \\ %ws: 0x%x\n",
                KERB_DOMAINS_KEY, DomainName, WinError );
            break;
        }

	printf( "%ws:\n",
		DomainName );

	LoadAndPrintNames( "kdc",
			   DomainKey,
			   TRUE,
			   KERB_DOMAIN_KDC_NAMES_VALUE );

	LoadAndPrintNames( "AlternateRealmName",
			   DomainKey,
			   FALSE,
			   KERB_DOMAIN_ALT_NAMES_VALUE );

	LoadAndPrintNames( "kpasswd",
			   DomainKey,
			   FALSE,
			   KERB_DOMAIN_KPASSWD_NAMES_VALUE );
	
	if ( NT_SUCCESS( GetRealmFlags( DomainName,
					&RealmFlags ) ) ) {

	  printf( "\tRealm Flags = 0x%x",
		  RealmFlags );

	  PrintRealmFlags( RealmFlags );
	  printf( "\n" );

	}
    }

Cleanup:

    if (KdcNames != NULL)
    {
        LocalFree(KdcNames);
    }
    if (AlternateRealmNames != NULL)
    {
        LocalFree(AlternateRealmNames);
    }
    return(Status);

}

NTSTATUS
PrintNameMapping( VOID ) 
{
    DWORD RegErr;
    HKEY KerbHandle = NULL;
    HKEY UserListHandle = NULL;

    WCHAR ValueNameBuffer[500];
    WCHAR ValueDataBuffer[500];
    PWSTR ValueName;
    PWSTR ValueData;
    ULONG NameLength;
    ULONG DataLength;
    ULONG Index;
    ULONG Type;
    BOOL  FoundAnyMappings = FALSE;
    CMULTISTRING StringClass;

    RegErr = OpenKerberosKey(&KerbHandle);
    if (RegErr)
    {
        goto Cleanup;
    }

    RegErr = RegOpenKeyEx(
                KerbHandle,
                L"UserList",
                0,              // no options
                KEY_QUERY_VALUE,
                &UserListHandle
                );

    switch( RegErr ) {

     case ERROR_FILE_NOT_FOUND:

       goto NoMappingsWereFound;

     case ERROR_SUCCESS:

       break; // success condition.

     default:

        printf("Failed to create UserList key: 0x%x\n",RegErr);
        goto Cleanup;

    }

    for ( Index = 0;
	  ; // forever
	  Index++ ) {
      
      NameLength = sizeof(ValueNameBuffer); 
      DataLength = sizeof(ValueDataBuffer); 
      ValueName  = ValueNameBuffer;         
      ValueData  = ValueDataBuffer;
      
      RtlZeroMemory(
	   ValueName,
	   NameLength
	   );

      RtlZeroMemory(
            ValueData,
            DataLength
            );

      // 279626: this value should be in bytes 

      NameLength /= sizeof( WCHAR );

      RegErr = RegEnumValue( UserListHandle,
			     Index,
			     ValueName,
			     &NameLength,
			     NULL,
			     &Type,
			     (PBYTE) ValueData,
			     &DataLength
			     );
      if ( RegErr == ERROR_SUCCESS ) {

	if ( _wcsicmp( ValueName , L"*" ) == 0 ) {
	  ValueName = L"all users (*)";
	}

        if (_wcsicmp(ValueData,L"*") == 0) {
	  ValueData = L"a local account by the same name (*)";
	}

	FoundAnyMappings = TRUE;

	printf( "Mapping %ws to %ws.\n",
		ValueName,
		ValueData );
      } else {

	if ( RegErr != ERROR_NO_MORE_ITEMS ) {

	  printf( "Registry error 0x%x while enumerating user mappings.  Stopping here.\n",
		  RegErr );

	}

	break;
      }
    }

    if ( !FoundAnyMappings ) {

 NoMappingsWereFound:

      printf( "No user mappings defined.\n" );

    }


Cleanup:

    if (KerbHandle)
    {
        RegCloseKey(KerbHandle);
    }
    if (UserListHandle)
    {
        RegCloseKey(UserListHandle);
    }
    return(STATUS_SUCCESS);

}



NTSTATUS
DumpState(LPWSTR * Parameters)
{
    NTSTATUS Status;
    PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;

    Status = LsaQueryInformationPolicy(
                LsaHandle,
                PolicyDnsDomainInformation,
                (PVOID *) &DnsDomainInfo
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to query dns domain info: 0x%x\n",Status);
        goto Cleanup;
    }

    if ( DnsDomainInfo->DnsDomainName.Length == 0 ) {

        printf("Machine is not configured to log on to an external KDC.  Probably a workgroup member\n");

        /* goto Cleanup;
	   101055: Don't do this-- not having joined the domain doesn't
	   preclude us from having KDC entries defined. */

    } else { // nonempty dns domain, but no sid.  Assume we're in an RFC1510 domain.

      printf( "default realm = %wZ ",
		&DnsDomainInfo->DnsDomainName );

      if ( DnsDomainInfo->Sid != NULL ) {

	printf( "(NT Domain)\n" );

      } else {

	printf( "(external)\n" );

      }

    }

    PrintRealmList();
    PrintNameMapping();

Cleanup:
    if (DnsDomainInfo != NULL)
    {
        LsaFreeMemory(DnsDomainInfo);
    }
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\ksetup\domain.cxx ===
/*++

  DOMAIN.CXX

  Copyright (C) 1999 Microsoft Corporation, all rights reserved.

  DESCRIPTION: 

  Created, May 21, 1999 by DavidCHR.

  CONTENTS: GetComputerRoleInformation
            DoItAnyway

--*/  

#include "everything.hxx"

extern "C" {
#include "..\keytab2\keytab\ldlib\delegtools.h"
#include <dsgetdc.h>
#include <lm.h>
}

PLDAP  GlobalLdap          = NULL;
LPWSTR GlobalClientName    = NULL;
LPWSTR GlobalDomainSetting = NULL; /* if NULL, we're not doing anything
                                      in the domain.  if Nonnull, this 
                                      is the DNS domain we want. */


BOOL
ConnectedToDsa( VOID ) {

    BOOL   ret            = ( GlobalLdap != NULL );
    LPWSTR TargetComputer = NULL;
    DWORD  dwErr;
    PLDAP  pLdap;

    if ( !ret ) {

      if ( GlobalDomainSetting ) {
        
        PDOMAIN_CONTROLLER_INFOW pDcInfo;

        dwErr = DsGetDcNameW( NULL, // computername (don't care)
                              GlobalDomainSetting,
                              NULL, // guid (don't care)
                              NULL, // site (don't care)
                              
                              DS_DIRECTORY_SERVICE_REQUIRED |
                              DS_IP_REQUIRED |
                              DS_ONLY_LDAP_NEEDED,

                              &pDcInfo );

        if ( ERROR_SUCCESS == dwErr ) {

          TargetComputer = pDcInfo->DomainControllerName; 

          DEBUGPRINT( DEBUG_DOMAIN,
                      ( "Found Domain Controller: %ws\n",
                        TargetComputer ) );
                      
          /* Sometimes, inexplicably, DsGetDcName returns
             a DC name that starts with "\\\\".  It doesn't
             seem to happen all the time, so I'll workaround. */

          while ( TargetComputer[ 0 ] == L'\\' ) {

            TargetComputer++;

            DEBUGPRINT( DEBUG_DOMAIN,
                        ( "Changed to %ws...\n",
                          TargetComputer ) );

            /* assert that we were not given a DCname that's just
               a bunch of slashes. */

            ASSERT( TargetComputer[ 0 ] != L'\0' );

          }

          /* WASBUG 73940: leaks, but we don't care.  it's an app, so
	     any leaked memory will be short-lived. */

        } else {

          printf( "Failed to locate a DC for %ws: 0x%x.\n",
                  GlobalDomainSetting,
                  dwErr );

          return FALSE;

        }

      }

      pLdap = ldap_openW( TargetComputer,
                          LDAP_PORT );

      if ( pLdap ) {

        dwErr = ldap_bind_s( pLdap,
                             NULL,
                             NULL,
                             LDAP_AUTH_NEGOTIATE );

        if ( LDAP_SUCCESS == dwErr ) {

          GlobalLdap = pLdap;
          ret        = TRUE;

        } else {

          ldap_unbind( pLdap );

          printf( "Ldap bind failed for %ws: 0x%x\n",
                  TargetComputer ? TargetComputer : L"default DC",
                  dwErr );

        }

      } else {

        printf( "Ldap open failed for %ws: 0x%x.\n",
                TargetComputer ? TargetComputer : L"default DC",
                GetLastError() ); 

      }
    }
    
    if ( !ret ) {

      GlobalLdap = NULL;

    }

    return ret;

}

NTSTATUS
AssignUnicodeStringToWideString( IN  PUNICODE_STRING pString,
                                 OUT LPWSTR          *Buffer ) {

    LPWSTR p;

    p = (LPWSTR) malloc( pString->Length + sizeof( WCHAR ) );

    if ( p ) {

      memcpy( p,
              pString->Buffer,
              pString->Length );

      p[ pString->Length / sizeof( WCHAR ) ] = L'\0';
      
      *Buffer = p;

      return STATUS_SUCCESS;

    } else {

      printf( "unable to allocate string copy of %wZ.\n",
              pString );

      return STATUS_NO_MEMORY;

    }

}

/*++**************************************************************
  NAME:      ChooseDomain

  specifies to use either the given domain (if Parameter 0 is
  nonnull) or the caller's domain.

  MODIFIES:  the global UserDomain variable (above)

  TAKES:     Parameters -- ripped from argv

  RETURNS:   a status code indicating success or failure
  LOGGING:   printf on failure
  CREATED:   Apr 23, 1999
  LOCKING:   none
  CALLED BY: main
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/

NTSTATUS
ChooseDomain( LPWSTR *Parameters ) {

    NTSTATUS ret = STATUS_UNSUCCESSFUL;
    KERB_QUERY_TKT_CACHE_REQUEST TicketRequest = { 
      KerbRetrieveTicketMessage
    };
    
    PKERB_RETRIEVE_TKT_RESPONSE pTicketResponse;
    ULONG                       cbTicketResponse;
    
    if ( Parameters[ 0 ] ) {

      GlobalDomainSetting = Parameters[ 0 ];
      printf( "Connecting to specified domain %ws...\n",
              GlobalDomainSetting );


    }


    // first, bind to the default DSA for this realm.

    if ( TRUE ) { /* 73944: this was ConnectedToDsa(), but we don't
		     necessarily have to connect to a DSA before
		     calling the package. */

      // now, determine who we are.

      ret = CallAuthPackage( &TicketRequest,
                             sizeof( TicketRequest ),
                             (PVOID *) &pTicketResponse,
                             &cbTicketResponse );
                             
      if ( NT_SUCCESS( ret ) ) {

        /* WASBUG 73946: leaks, but the app doesn't run for more
	   than a second.  "Leaked" memory goes away on exit, so we
	   don't care. */

        if ( !GlobalDomainSetting ) {
          
          /* only set this if we haven't set it ourselves.
             The reason being that the specified domain (above)
             is NOT the same as this one, which came from the cache. */

          AssignUnicodeStringToWideString( 
               &pTicketResponse->Ticket.DomainName,
               &GlobalDomainSetting
               );

        }
        ASSERT( pTicketResponse->Ticket.ClientName->NameCount == 1 );

        AssignUnicodeStringToWideString( 
             &pTicketResponse->Ticket.ClientName->Names[ 0 ],
             &GlobalClientName 
             );

        ret = STATUS_SUCCESS;

      } else {

        printf( "Ticket cache query failed.  Error 0x%x\n",
                ret );

      }

    }

    if ( NT_SUCCESS( ret ) ) {

      ASSERT( GlobalDomainSetting != NULL );
      
      printf( "Using domain %ws.\n",
              GlobalDomainSetting );

    } else {

      printf( "Could not guess user's domain.\n"
              "  Please specify domain on command line and try again.\n" );

    }

    return ret;
}

/*++**************************************************************
  NAME:      GetComputerRoleInformation

  Queries the target server for its role information-- basically,
  we use this to determine whether the machine is a domain
  controller.

  MODIFIES:  pulRoleData

  RETURNS:   a status code indicating success or failure
  LOGGING:   
  CREATED:   Jan 25, 2000
  LOCKING:   
  CALLED BY: anyone
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/

NTSTATUS 
GetComputerRoleInformation( PULONG pulRoleData ) {

    NTSTATUS N;
    NET_API_STATUS NetStatus;
    PSERVER_INFO_101 pServerInfo;

    NetStatus = NetServerGetInfo( ServerName, // global.
                                  101,        // level
                                  (LPBYTE *) &pServerInfo );

    if ( NetStatus != STATUS_SUCCESS ) {

      printf( "Cannot determine %ws's Server Role: 0x%x.\n",
              ServerName ? ServerName : L"this computer",
              NetStatus );

      N = STATUS_UNSUCCESSFUL;

    } else {

      N = STATUS_SUCCESS;

      if ( pulRoleData ) *pulRoleData = pServerInfo->sv101_type;

      NetApiBufferFree( pServerInfo );

    }

    return N;

}

/*++**************************************************************
  NAME:      DoItAnyway

  prompts the user-- "Do it anyway?"

  MODIFIES:  nothing

  RETURNS:   TRUE  if the user decided to do it anyway
             FALSE if the user decided to abort.

  CREATED:   Jan 25, 2000
  CALLED BY: anyone (most notably SetDnsDomain)
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/

BOOL
DoItAnyway( VOID ) {

    int Response;

    while ( TRUE ) {

      printf( "Do it anyway [y/n]? " );
      
      Response = '\0';

      do { 

        Response = getchar();

      } while ( isspace( Response ) );

      switch( Response ) {

       case 'Y':
       case 'y':

         return TRUE;
         break;

       case 'N':
       case 'n':

         return FALSE;
         break;

       case EOF:
         
         printf( "EOF at console.  Assuming no.\n" );
         return FALSE;
         break;

       default:

         printf( "[unknown: %02x '%c']\n",
                 Response,
                 Response );
         break;

      }
    }

    // NOTREACHED
}

NTSTATUS
SetDnsDomain( LPWSTR * Parameter)
{
    NTSTATUS               Status;
    POLICY_DNS_DOMAIN_INFO DnsDomainInformation = {0};
    LPSTR                  Description;
    ULONG                  Index, Role;
    BOOL                   PromptTheUser = FALSE;
    LPWSTR                 Arg;

    //
    // If no parameter is passed, prepare to unjoin from all domains/realms.  
    // Print a scary message, but don't give the user a chance to abort.
    //

    if( Parameter[0] == NULL )
    {
	Arg = L"WORKGROUP";
	fprintf( stderr, "No parameter to /SetRealm - unjoining computer from all domains/realms.\n" );
    }
    else
    {
	Arg = Parameter[0];
    }

    if( !CheckUppercase( Arg ) )
    {
	return STATUS_UNSUCCESSFUL;
    }

    /* 453781: don't fiddle with DNS domain information if the
       machine is a Domain Controller -- results in a dead machine. */

    Status = GetComputerRoleInformation( &Role );

    if ( !NT_SUCCESS( Status ) ) {

      Description = "Cannot verify.  If %ws is a domain controller, ";
      PromptTheUser = TRUE;

      goto WarnMe;

    } else if ( Role & ( SV_TYPE_DOMAIN_CTRL |
                         SV_TYPE_DOMAIN_BAKCTRL ) ) {

      Description = "%ws is a domain controller-- ";
      
 WarnMe:

      printf( "*** WARNING! ***\n" );
      
      printf( Description,
              ServerName ? ServerName : L"this computer" );
              
      printf( "resetting its\n"
              "DNS Domain Information may render it unusable.\n" );

      if ( !PromptTheUser ) {

        printf( "This operation is not supported.\n" );

        return EPT_NT_CANT_PERFORM_OP; // cannot perform.

      } else if ( !DoItAnyway() ) {

        return Status;

      }
    }
        
    Status = STATUS_SUCCESS; // by default

    printf("Setting Dns Domain\n");

    //
    // set the netbios name to be the portion before the first '.' and
    // truncate to 14 characters
    //

    RtlInitUnicodeString(
        &DnsDomainInformation.Name,
        Arg
        );

    for (Index = 0; Index < DnsDomainInformation.Name.Length/sizeof(WCHAR) ; Index++ )
    {
        if (DnsDomainInformation.Name.Buffer[Index] == L'.')
        {
            DnsDomainInformation.Name.Length = (USHORT) (Index * sizeof(WCHAR));
            break;
        }
    }
    if (DnsDomainInformation.Name.Length > DNLEN * sizeof(WCHAR))
    {
        DnsDomainInformation.Name.Length = DNLEN * sizeof(WCHAR);
    }

    RtlInitUnicodeString(
        &DnsDomainInformation.DnsDomainName,
        Arg
        );

    Status = LsaSetInformationPolicy(
                LsaHandle,
                PolicyDnsDomainInformation,
                (PVOID) &DnsDomainInformation
                );


    if (!NT_SUCCESS(Status))
    {
        printf("Failed to set dns domain info: 0x%x\n",Status);
        return(Status);
    }

    //
    // Set the value in tcpip
    //

    if (!SetComputerNameEx(
            ComputerNamePhysicalDnsDomain,
            Arg))
    {
        printf("Failed to update host dns domain: %d (0x%x) \n",
	       GetLastError(), GetLastError() );
        return(STATUS_UNSUCCESSFUL);
    }

    return(Status);
}

BOOL CheckUppercase( LPWSTR wszRealmName )
{
    PWCHAR c = wszRealmName;

    while( *c != L'\0' )
    {
	if( iswalpha(*c) && !iswupper(*c) )
	{
	    fprintf( stderr, "Your realm name \"%ws\" has lowercase letters.\nTraditionally, Kerberos Realms are in UPPERCASE. Please verify.\n", wszRealmName );
	    if( DoItAnyway() )
	    {
		return TRUE;
	    }
	    else
	    {
		return FALSE;
	    }
	}
	c++;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\ksetup\main.cxx ===
/*++

  MAIN.CXX

  Copyright (C) 1999 Microsoft Corporation, all rights reserved.

  DESCRIPTION: main() for ksetup

  Created, May 21, 1999 by DavidCHR.

--*/  

#define EXTERN // nothing
#include "everything.hxx"

extern 
CommandPair Commands[ ANYSIZE_ARRAY ];

extern
ULONG       cCommands;

extern TestFunc DumpState;

extern NTSTATUS
OpenLsa( VOID ); // in support.cxx


BOOL
FindCommand( IN  LPWSTR CommandName,
	     OUT PULONG pulCommandId ) {

    ULONG iCommand;

    for (iCommand = 0; iCommand < cCommands ; iCommand++ ) {
	  
      if ( 0 == lstrcmpi( CommandName,
			  Commands[iCommand].Name) ) {

	// found the command.

	DEBUGPRINT( DEBUG_OPTIONS,
		    ( "Found %ws (command %ld)",
		      CommandName,
		      iCommand ) );

	*pulCommandId = iCommand;

	return TRUE;

      }
    }

    printf( "%ws: no such argument.\n",
	    CommandName );

    return FALSE;
}
	
BOOL
StoreArguments( IN     ULONG   iArg,
		IN     LPWSTR *argv,
		OUT    PULONG  piArg,
		IN OUT PAction pAction ) {


    ULONG        iCommand    = pAction->CommandNumber;
    PCommandPair pCommand    = Commands + iCommand;
    ULONG        iParam      = 0;
    BOOL         ret         = TRUE;
    BOOL         KeepParsing = FALSE;

    DEBUGPRINT( DEBUG_OPTIONS, ( "Building %ld-arg array.\n",
				 Commands[ iCommand ].Parameter ) );

    if ( pCommand->Parameter != 0 ) {

      /* this command has required parameters.
	 Copy them as we go. */

      for ( iParam = 0;
	    ret && argv[ iArg ] && ( iParam < MAX_COMMANDS -1 );
	    iArg++, iParam ++ ) {

	ASSERT( argv[ iArg ] != NULL );
	
	DEBUGPRINT( DEBUG_OPTIONS,
		    ( "Evaluating iParam=%ld, iArg=%ld, \"%ws\"\n",
		      iParam,
		      iArg,
		      argv[ iArg ] ) );

	if ( argv[ iArg ][ 0 ] == L'/' ) {

	  // this parameter is a switch.  We're done.
	
	  break;

	}

	// if we don't need any more arguments, don't consume this one.

	if ( ( iParam > pCommand->Parameter ) &&
	     !( pCommand->flags & CAN_HAVE_MORE_ARGUMENTS ) ) {

	  printf( "%ws only takes %ld arguments.\n",
		  pCommand->Name,
		  pCommand->Parameter );

	  ret = FALSE;
	  break;

	}

	// at this point, the options are consumable.

	pAction->Parameter[ iParam ] = argv[ iArg ];

	DEBUGPRINT( DEBUG_OPTIONS, 
		    ( "%ws's arg %ld is %ws\n",
		      pCommand->Name,
		      iParam,
		      pAction->Parameter[ iParam ] ) );

      } // for loop

      if ( ret ) {

	// left the loop without error

	if ( ( iParam < pCommand->Parameter ) &&
	     !( pCommand->flags & 
		CAN_HAVE_FEWER_ARGUMENTS ) ) {

	  // too few options.

	  printf( "%ws requires %ld options (only %ld supplied).\n",
		  pCommand->Name,
		  pCommand->Parameter,
		  iParam );

	  ret = FALSE;

	}

      }
    } // parameter count check.

    if ( ret ) {
      pAction->Parameter[ iParam ] = NULL; /* null-terminate
					      in all success cases. */
      *piArg = iArg;

#if DBG
      DEBUGPRINT( DEBUG_OPTIONS,
		  ( "Leaving StoreOptions-- %ws with iArg=%ld.  %ld args:\n",
		    pCommand->Name,
		    iArg,
		    iParam ));

      for ( iParam = 0;
	    pAction->Parameter[ iParam ] != NULL ;
	    iParam++ ) {

	DEBUGPRINT( DEBUG_OPTIONS,
		    ( "arg %ld: %ws\n",
		      iParam,
		      pAction->Parameter[ iParam ] ) );

      }
#endif
    }

    return ret;

}

    


/*++**************************************************************
  NAME:      main()

  main() function, the primary entry point into the program.
  When this function exits, the program exits.
  
  TAKES:     argc : count of string entries in argv
             argv : array of space-delimited strings on the command line
  RETURNS:   the exit code (or errorlevel) for the process 
  CALLED BY: the system
  FREE WITH: n/a
  
 **************************************************************--*/

extern "C"
int __cdecl
wmain(ULONG  argc, 
      LPWSTR argv[]) {

    ULONG    Command = 0;
    ULONG    iAction, iArg, iCommand, iParam ;
    BOOLEAN  Found;
    NTSTATUS Status;
    PAction  Actions;
    ULONG    ActionCount = 0;
    BOOL     StuffToDo = FALSE; // used only for debugging

    // GlobalDebugFlags = 0xFF;

    // lazy way to do this.

    Actions = (PAction) malloc( argc * sizeof( *Actions ) );

    if ( !Actions ) {

      printf( "Failed to allocate array.\n" );
      return -1;

    }

    for (iArg = 1; iArg < argc ; ) // iArg++ )
    {
        Found = FALSE;

	DEBUGPRINT( DEBUG_OPTIONS,
		    ( "Searching for iArg=%ld, %ws..\n",
		      iArg,
		      argv[ iArg ] ) );
	
	// first, find the command.

	if ( FindCommand( argv[ iArg ],
			  &iCommand ) ) {

	  iArg++;

	  Actions[ActionCount].CommandNumber = iCommand;
	      
	  if ( StoreArguments( iArg, // starting here
			       argv,
			       &iArg,  // moves past last arg
			       &Actions[ ActionCount ] ) ) {

	    if ( Commands[iCommand].flags & DO_COMMAND_IMMEDIATELY ) {

	      DEBUGPRINT( DEBUG_LAUNCH,
			  ( "Doing %ws immediately:\n",
			    Commands[ iCommand ].Name ) );

	      Status = Commands[iCommand].Function( 
		 Actions[ActionCount].Parameter );

	      DEBUGPRINT( DEBUG_OPTIONS, 
			  ( "%ws returned 0x%x\n",
			    Commands[ iCommand ].Name,
			    Status ) );
		  
	      if ( NT_SUCCESS( Status ) ) {
		if ( Commands[ iCommand ].ConfirmationText ) {

		  printf( "NOTE: %ws %hs\n",
			  Commands[ iCommand ].Name,
			  Commands[ iCommand ].ConfirmationText );

		}
	      } else {

		printf( "%ws failed: 0x%x.\n",
			Commands[iCommand].Name,
			Status);
		goto Cleanup;

	      }
		
	    } else {

	      // need to do this command later.

	      StuffToDo = TRUE;
	      ActionCount++;

	    }
	    
	  } else { // StoreArgs

	    printf( "use %ws /? for help.\n",
		    argv[ 0 ] );
	    return -1;

	  }

        } else {

	  printf( "use %ws /? for help.\n",
		  argv[ 0 ] );
		  
	  return -1;

        }
    } // argument loop.

    Status = OpenLsa();
    if (!NT_SUCCESS(Status))
    {
      printf("Failed to open lsa: 0x%x\n",Status);
      goto Cleanup;
    }

    if ( StuffToDo ) {

      DEBUGPRINT( DEBUG_OPTIONS, 
		  ( "------------------ %hs -------------------\n",
		    "performing delayed actions now" ) );

    }

    for (iAction = 0; iAction < ActionCount ; iAction++ )
    {
      
      if (!( Commands[Actions[iAction].CommandNumber].flags & 
	     DO_COMMAND_IMMEDIATELY )) 
      {

	DEBUGPRINT( DEBUG_LAUNCH,
		    ( "Doing %ws:\n",
		      Commands[ Actions[ iAction ].CommandNumber ].Name ) );

	Status = Commands[Actions[iAction].CommandNumber].Function(
	   Actions[iAction].Parameter);

	DEBUGPRINT( DEBUG_OPTIONS, 
		    ( "%ws: 0x%x\n",
		      Commands[ Actions[ iAction ].CommandNumber ].Name,
		      Status ) );

	if (!NT_SUCCESS(Status))
	{
	  printf("Failed %ws : 0x%x\n",
		 Commands[Actions[iAction].CommandNumber].Name,
		 Status);
	  goto Cleanup;

	} else {

	  if ( Commands[ iCommand ].ConfirmationText ) {
	    
	    printf( "NOTE: %ws %hs\n",
		    Commands[ iCommand ].Name,
		    Commands[ iCommand ].ConfirmationText );
	    
	  }
	}
      }
    }

    if (ActionCount == 0)
    {
      DumpState(NULL);
    }

 Cleanup:
    if (LsaHandle != NULL)
    {
      Status = LsaClose(LsaHandle);
      if (!NT_SUCCESS(Status))
      {
	printf("Failed to close handle: 0x%x\n",Status);
      }
    }

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\ksetup\misccmds.cxx ===
/*++

  MISCCMDS.CXX

  Copyright (C) 1999 Microsoft Corporation, all rights reserved.

  DESCRIPTION: miscellaneous command callbacks and the command vector

  Created, May 21, 1999 by DavidCHR.

--*/

#include "Everything.hxx"

/* these are the callback functions invoked by the option parser.
   We declare them here so that they can be called from the array
   below */

TestFunc
  SetDnsDomain,       // domain.cxx
  AddKdcName,         // servers.cxx
  AddKpasswdName,     // servers.cxx
  MapUser,            // mapuser.cxx
  SetMachinePassword, // below in this file
  DumpState,          // dmpstate.cxx
  ChooseDomain  ,     // domain.cxx
  DeleteKdcName,      // servers.cxx
  DelKpasswdName,     // servers.cxx
  ChangeViaKpasswd,   // support.cxx
  SetRealmFlags,      // realmflags.cxx 
  AddRealmFlags,      // realmflags.cxx 
  DelRealmFlags,      // realmflags.cxx
  ListRealmFlags,     // realmflags.cxx
  RemoveDomainName,   // servers.cxx
  PrintHelp;          // below in this file



NTSTATUS
SetMachinePassword( LPWSTR * Parameter)
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING MachinePassword;
    UNICODE_STRING KeyName;
    LPWSTR         Password;

    if ( !ReadOptionallyStarredPassword( Parameter[ 0 ],
                                         PROMPT_FOR_PASSWORD_TWICE,
                                         L"new computer",
                                         &Password ) ) {

      return STATUS_UNSUCCESSFUL;

    }

    printf("Setting computer password\n");

    RtlInitUnicodeString(
        &MachinePassword,        
        Password
        );

    RtlInitUnicodeString(
        &KeyName,
        L"$MACHINE.ACC"
        );

    Status = LsaStorePrivateData(
                LsaHandle,
                &KeyName,
                &MachinePassword
                );


    if (!NT_SUCCESS(Status))
    {
        printf("Failed to set machine password: 0x%x\n",Status);
    }

    free( Password );


    return(Status);
}


NTSTATUS
SetServer(LPWSTR * Parameter)
{
    printf("Targeting server %ws\n",Parameter[0]);
    wcscpy(ServerBuffer,Parameter[0]);
    ServerName = ServerBuffer;
    return(STATUS_SUCCESS);
}

#if DBG /* This function and its corresponding variable
           are only useful on debug builds. */

ULONG GlobalDebugFlags = ~DEBUG_OPTIONS;

NTSTATUS
SetDebugFlags( LPWSTR *Params ) {

    ASSERT( *Params != NULL );
    GlobalDebugFlags = wcstoul( *Params,
                                0,
                                NULL );

    printf( "Debug Print Flags set to 0x%x.\n",
            GlobalDebugFlags );

    return STATUS_SUCCESS;
}
#endif


/*------------------------------------------------------------

  Here's the array of callbacks.  It's read by the command
  line interpreter in main() 

  ------------------------------------------------------------*/

CommandPair Commands[] = {

  // argument           argc doNow? argFunction   description

  {L"/SetDomain",           1, SetDnsDomain,       NULL, // renamed -- hidden from help
   0,
   NULL, // no arguments
   "requires a reboot to take effect" },

  {L"/SetRealm",            1, SetDnsDomain,       "<DnsDomainName>",
   CAN_HAVE_FEWER_ARGUMENTS,
   "Makes this computer a member of an RFC1510 Kerberos Realm",
   "requires a reboot to take effect" },

  {L"/MapUser",             2, MapUser,            "<Principal> <Account>",
   CAN_HAVE_FEWER_ARGUMENTS,
   "Maps a Kerberos Principal ('*' = any principal)\n"
   "\tto an account ('*' = an account by same name)"
  },

  {L"/AddKdc",              1, AddKdcName,         "<RealmName> [KdcName]",
   CAN_HAVE_MORE_ARGUMENTS,
   "Defines a KDC entry for the given realm.\n"
   "\tIf KdcName omitted, DNS may be used to locate KDCs.",
   "requires a reboot to take effect on pre-SP1 Win2000 computers" },

  {L"/DelKdc",              1, DeleteKdcName,      "<RealmName> [KdcName]",
   CAN_HAVE_MORE_ARGUMENTS,
   "deletes a KDC entry for the realm.\n"
   "\tIf KdcName omitted, the realm entry itself is deleted.",
   "requires a reboot to take effect on pre-SP1 Win2000 computers" },

  {L"/AddKpasswd",          2, AddKpasswdName,     "<Realmname> <KpasswdName>",
   0, // no flags
   "Add Kpasswd server address for a realm",
   "requires a reboot to take effect on pre-SP1 Win2000 computers" },

  {L"/DelKpasswd",          2, DelKpasswdName,     "<Realmname> <KpasswdName>",
   0, // no flags
   "Delete Kpasswd server address for a realm",
   "requires a reboot to take effect on pre-SP1 Win2000 computers" },

  {L"/Server",              1, SetServer,          "<Servername>",
   DO_COMMAND_IMMEDIATELY,
   "specify name of a Windows machine to target the changes."
  },

  {L"/SetMachPassword",     1, SetMachinePassword, NULL, // renamed; hidden from help
   0, // no flags
   NULL, // no description -- this option is depricated.
   "requires a reboot to take effect." },

  {L"/SetComputerPassword", 1, SetMachinePassword, "<Password>",
   0, // no flags
   "Sets the password for the computer's domain account\n"
   "\t(or \"host\" principal)",
   "requires a reboot to take effect." },

  { L"/RemoveRealm",        1, RemoveDomainName,   "<RealmName>",
    0, // no flags
    "delete all information for this realm from the registry.",
    "requires a reboot to take effect on pre-SP1 Win2000 computers" },

  {L"/Domain",              1, ChooseDomain,       "[DomainName]",
   DO_COMMAND_IMMEDIATELY |
   CAN_HAVE_FEWER_ARGUMENTS,
   "use this domain (if DomainName is unspecified, detect it)" },

  {L"/ChangePassword",      2, ChangeViaKpasswd,   "<OldPasswd> <NewPasswd>",
   DO_COMMAND_IMMEDIATELY,
   "Use Kpasswd to change the logged-on user's password.\n"
   "\tUse '*' to be prompted for passwords." },
   
  // realm flag stuff:

  { L"/ListRealmFlags",     0, ListRealmFlags,
    "(no args)",
    DO_COMMAND_IMMEDIATELY,
    "Lists the available Realm flags that ksetup knows"
  },

  { L"/SetRealmFlags",      2, SetRealmFlags,
    "<realm> <flag> [flag] [flag] [...]",
    CAN_HAVE_MORE_ARGUMENTS,
    "Sets RealmFlags for a specific realm" },

  { L"/AddRealmFlags",      2, AddRealmFlags,
    "<realm> <flag> [flag] [flag] [...]",
    CAN_HAVE_MORE_ARGUMENTS,
    "Adds additional RealmFlags to a realm"
  },

  { L"/DelRealmFlags",      2, DelRealmFlags,
    "<realm> <flag> [flag] [flag] [...]",
    CAN_HAVE_MORE_ARGUMENTS,
    "Deletes RealmFlags from a realm." },

  {L"/DumpState",           0, DumpState,          
   "(no args)",
   0,
   "Analyze the kerberos configuration on the given machine." },

  {L"/?",                   0, PrintHelp,          NULL }, // hidden from help
  {L"/help",                0, PrintHelp,          NULL }, // hidden from help

#if DBG
  {L"/debugflag",           1, SetDebugFlags,      "<flags>",
   DO_COMMAND_IMMEDIATELY,
   "Set debugging flags" },
#endif

};

ULONG cCommands = sizeof( Commands ) / sizeof( Commands[ 0 ] );

NTSTATUS
PrintHelp(LPWSTR * Parameter)
{

    ULONG i;
    LPSTR pDesc;

    printf( "\n"
            "USAGE:\n" );

    for ( i = 0 ;
          i < cCommands ;
          i ++ ) {

      if ( Commands[ i ].Arguments ) {

        printf( "%ws %hs\n",
                Commands[ i ].Name,
                Commands[ i ].Arguments );

#if 1
	if ( Commands[ i ].ExtendedDescription ) {

	  printf( "\t%hs\n",
		  Commands[ i ].ExtendedDescription );

	} 
#else

	for ( pDesc = Commands[ i ].ExtendedDescription;
	      pDesc && *pDesc ;
	      /* No increment */
	      ) {

	  printf( "%-20hs %hs\n",
		  "",
		  pDesc );

	  pDesc = strchr( pDesc, '\0' );
	  if ( pDesc ) pDesc++;
	}

#endif


      }
    }
      
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\ksetup\realmflags.cxx ===
/*++

  REALMFLAGS.CXX

  Copyright (C) 1999 Microsoft Corporation, all rights reserved.

  DESCRIPTION: realm-flag manipulation code.

  Created, Jan 10, 2000 by DavidCHR.

  CONTENTS: CompareFlagIds
            VerboselyPrintAndRemoveFlagsById
            LookupRealmFlagByName
            PrintAndRemoveFlagNames
            SearchRealmFlagListByAttribute
            CompareFlagNames

--*/  


#include "everything.hxx"

typedef struct {

  ULONG  Id;          // from kerberos\client2\mitutil.h
  LPWSTR Name;        // short string identifier
  LPSTR  Explanation; // what this flag does.
  LPSTR  MoreExplanation; // if you have to run to the next line.

} KERB_REALM_FLAG_MAPPING, *PKERB_REALM_FLAG_MAPPING;

/* These flags are defined in kerberos\client2\mitutil.h.
   However, there's other gunk in there that I'd rather not
   copy out so I'll just duplicate them.

   I'd consider auto-generating code fragments from the file
   to keep this file instantly up-to-date, but it wouldn't
   be guaranteed to provide human readable information */

KERB_REALM_FLAG_MAPPING
KerbRealmFlagMappings[] = {

  /* The order of "none" in the list is important.  It must be
     before any of the other flags so that code that handles
     multiple flags as a mask will not hit this unless the 
     whole mask is zero. */

  { 0x0,
    L"None",
    "No Realm Flags"
  },

  { 0x1, 
    L"SendAddress",
    "Include IP numbers within tickets.",
    "Useful for solving SOME compatibility issues."
  },

  { 0x2,
    L"TcpSupported",
    "Indicates that this realm supports TCP.",
    "(as opposed to just UDP)" },

  { 0x4,
    L"Delegate",
    "Everyone in this realm is trusted for delegation" },

  { 0x8,
    L"NcSupported",
    "This realm supports Name Canonicalization" },

};

ULONG
RealmFlagCount = ( sizeof( KerbRealmFlagMappings ) / 
                   sizeof( KerbRealmFlagMappings[ 0 ] ) );


/* NOTES on REALMLISTCOMPAREFUNCTION:

   If your REALMLISTCOMPAREFUNCTION is designed to return multiple
   mappings or interpret multiple mappings (e.g. as a mask), then
   you must special case "None" in the array above.  Otherwise,
   your output may include "none", which doesn't make any sense. */

typedef BOOL REALMLISTCOMPAREFUNCTION( IN PVOID, // pvAttribute
                                       IN PKERB_REALM_FLAG_MAPPING );


/*++**************************************************************
  NAME:      CompareFlagIds

  compares a flag map to a flag id.  
  pvAttribute is a pointer to the desired flag id.

  RETURNS:   TRUE  if this is the correct flagid
             FALSE otherwise.
  CREATED:   Jan 10, 2000
  CALLED BY: SearchRealmFlagListByAttribute
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/

BOOL // REALMLISTCOMPAREFUNCTION
CompareFlagIds( IN PVOID                    pvAttribute,
                IN PKERB_REALM_FLAG_MAPPING pMap ) {

    return ( pMap->Id == *(( PULONG ) pvAttribute) );

}


/*++**************************************************************
  NAME:      CompareFlagNames

  Compares a mapping to a string for the flagname.

  RETURNS:   TRUE  if this mapping corresponds to the given string
             FALSE otherwise.
  CREATED:   Jan 10, 2000
  CALLED BY: SearchRealmFlagListByAttribute
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/


BOOL // REALMLISTCOMPAREFUNCTION
CompareFlagNames( IN PVOID                    pvAttribute,
                  IN PKERB_REALM_FLAG_MAPPING pMap ) {

    return ( 0 == _wcsicmp( (LPWSTR) pvAttribute,
                            pMap->Name ) );
}

/*++**************************************************************
  NAME:      PrintAndRemoveFlagsById

  if the flag id matches, it is removed from the passed-in value,
  and the flagname is printed.

  MODIFIES:  pvAttribute -- may be stripped of a bit

  TAKES:     pvAttribute -- flagId to check
             pMap        -- table entry to check against

  RETURNS:   TRUE  if pvAttribute is zero (stop searching)
             FALSE otherwise (keep searching)

  CREATED:   Jan 10, 2000
  CALLED BY: SearchRealmFlagListByAttribute
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/

BOOL
PrintAndRemoveFlagsById( IN PVOID pvAttribute,
                         IN PKERB_REALM_FLAG_MAPPING pMap ) {

    if ( !pMap->Id ) {

      /* We special-case "none" so that we only print it
	 if there are no other flags-- if other flags exist,
	 "none" will be skipped over in the array */

      if ( !*(( PULONG ) pvAttribute ) ) {
	printf( " %ws",
		pMap->Name );

	return TRUE;
      } else {
	return FALSE;
      }
    }

    if ( ( *(( PULONG ) pvAttribute) & pMap->Id )
         == pMap->Id ) {

      *( (PULONG) pvAttribute ) &= ~pMap->Id;
      printf( " %ws",
              pMap->Name );

    }

    return *( (PULONG) pvAttribute ) == 0;

}

/*++**************************************************************
  NAME:      VerboselyPrintAndRemoveFlagsById

  like PrintAndRemoveFlagsById, but it also dumps the
  flag id and explanation field.

  LOGGING:   lots of it.
  CREATED:   Jan 10, 2000
  CALLED BY: SearchRealmFlagListByAttribute
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/

BOOL
VerboselyPrintAndRemoveFlagsById( IN PVOID pvAttribute,
                                  IN PKERB_REALM_FLAG_MAPPING pMap ) {

#if 0
    if ( !pMap->Id ) {

      /* We special-case "none" so that we only print it
	 if there are no other flags-- if other flags exist,
	 "none" will be skipped over in the array */

      if ( !*(( PULONG ) pvAttribute ) ) {
	printf( "0x%02x %ws   \t%hs\n",
		pMap->Id,
		pMap->Name,
		pMap->Explanation );
	
	return TRUE;
      } else {
	return FALSE;
      }
    }
#endif

    if ( ( *(( PULONG ) pvAttribute) & pMap->Id )
         == pMap->Id ) {

      *( (PULONG) pvAttribute ) &= ~pMap->Id;
      printf( "0x%02x %-12ws %hs\n",
              pMap->Id,
              pMap->Name,
              pMap->Explanation );

      if ( pMap->MoreExplanation ) {

	printf( "%-17hs %hs\n",
		"",
		pMap->MoreExplanation );
      }

    }

    return *( (PULONG) pvAttribute ) == 0;

}
      

/*++**************************************************************
  NAME:      SearchRealmFlagListByAttribute

  searches the realmlist for a particular attribute.

  MODIFIES:  ppMapping -- receives the given mapping.

  TAKES:     pvAttribute -- attribute value to search for
             pFunc       -- function to use to find it

  RETURNS:   TRUE  if the value could be found
             FALSE otherwise.
  LASTERROR: not set

  LOGGING:   none
  CREATED:   Jan 10, 2000
  LOCKING:   none
  CALLED BY: anyone
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/


BOOL
SearchRealmFlagListByAttribute( IN  PVOID                     pvAttribute,
                                IN  REALMLISTCOMPAREFUNCTION *pFunc,
                                OUT PKERB_REALM_FLAG_MAPPING *ppMapping ) {

    ULONG i;
    PKERB_REALM_FLAG_MAPPING pMapping = &KerbRealmFlagMappings[ 0 ];

    for ( i = 0 ; 
          i < RealmFlagCount ;
          i ++, pMapping++ ) {

      if ( pFunc( pvAttribute,
                  pMapping ) ) {

        if ( ppMapping ) *ppMapping = pMapping;
        return TRUE;

      }
    }

    return FALSE;

}


/*++**************************************************************
  NAME:      LookupRealmFlagByName

  given a name, maps it to a realm flag mapping structure

  MODIFIES:  ppMapping     -- receives the entry pointer
  TAKES:     RealmFlagName -- name for which to search

  RETURNS:   TRUE  if the realmflag could be found.
             FALSE otherwise.
  LASTERROR: 

  LOGGING:   
  CREATED:   Jan 10, 2000
  LOCKING:   
  CALLED BY: anyone
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/

BOOL
LookupRealmFlagByName( IN  LPWSTR RealmFlagName,
                       OUT PKERB_REALM_FLAG_MAPPING *ppMapping ) {

    return SearchRealmFlagListByAttribute( RealmFlagName,
                                           CompareFlagNames,
                                           ppMapping );

}

VOID
PrintRealmFlags( IN ULONG RealmFlags ) {

    ULONG i;
    ULONG ioFlags = RealmFlags;

    if ( RealmFlags == 0 ) {

      printf( " none" );

    } else {

      if ( !SearchRealmFlagListByAttribute( &ioFlags,
                                            PrintAndRemoveFlagsById,
                                            NULL ) ) {
        printf( " [unknown" );

        if ( ioFlags != RealmFlags ) {

          printf( ": 0x%x",
                  ioFlags );

        }

        printf( "]" );

      }

    }
}
    
    
      

NTSTATUS
ListRealmFlags( LPWSTR * Ignored) {

    ULONG RealmFlags = ~0;

    printf( "\n"
            "Ksetup knows the following realm flags: \n" );
    
    SearchRealmFlagListByAttribute( &RealmFlags,
                                    VerboselyPrintAndRemoveFlagsById,
                                    NULL );
    printf( "\n" );

    exit( 0 ); /* Jump out. */

    return STATUS_SUCCESS;

}

NTSTATUS
GetRealmFlags( IN  LPWSTR RealmName,
               OUT PULONG pulRealmFlags ) {

    HKEY  hKey;
    NTSTATUS N = STATUS_UNSUCCESSFUL;
    DWORD dwErr, Type, Len = sizeof( *pulRealmFlags );

    dwErr = OpenSubKey( &RealmName,
                        &hKey );

    if ( dwErr == ERROR_SUCCESS ) {

      dwErr = RegQueryValueEx( hKey,
                               KERB_DOMAIN_REALM_FLAGS_VALUE,
                               NULL, // mbz
                               &Type,
                               (LPBYTE) pulRealmFlags,
                               &Len );

      switch ( dwErr ) {

       case ERROR_SUCCESS:
         
         N = STATUS_SUCCESS;
         break;

       case ERROR_FILE_NOT_FOUND:
       case ERROR_PATH_NOT_FOUND:

         /*  453545: if the realm flags aren't specified,
             don't complain about it. */

         N = STATUS_SUCCESS;
         *pulRealmFlags = 0;
         break;

       default:
         
         printf( "Failed to query %ws for %ws: 0x%x\n",
                 KERB_DOMAIN_REALM_FLAGS_VALUE,
                 RealmName,
         dwErr );
      }

      RegCloseKey( hKey );

    } // else error has already been printed.

    return N;
}

NTSTATUS
SetRealmFlags( IN LPWSTR RealmName,
               IN ULONG  ulRealmFlags ) {

    HKEY  hKey;
    NTSTATUS N = STATUS_UNSUCCESSFUL;
    DWORD dwErr, Len = sizeof( ulRealmFlags );

    dwErr = OpenSubKey( &RealmName,
                        &hKey );

    if ( dwErr == ERROR_SUCCESS ) {

      dwErr = RegSetValueEx( hKey,
                             KERB_DOMAIN_REALM_FLAGS_VALUE,
                             NULL, // mbz
                             REG_DWORD,
                             (LPBYTE) &ulRealmFlags,
                             Len );
      
      switch ( dwErr ) {

       case ERROR_SUCCESS:

         DEBUGPRINT( DEBUG_REGISTRY,
                     ( "Set Realm Flags for %ws to 0x%x\n",
                       RealmName,
                       ulRealmFlags ) ) ;
         
         N = STATUS_SUCCESS;
         break;

       default:
         
         printf( "Failed to write %ws for %ws: 0x%x\n",
                 KERB_DOMAIN_REALM_FLAGS_VALUE,
                 RealmName,
         dwErr );
      }

      RegCloseKey( hKey );

    } // else error has already been printed.

    return N;
}



NTSTATUS
ResolveRealmFlags( IN     LPWSTR *Params,
                   IN OUT PULONG pulFlags ) {

    ULONG                    id;
    LPWSTR                   Cursor, *pFlagCursor = Params;
    PKERB_REALM_FLAG_MAPPING pMap;
    NTSTATUS                 N = STATUS_SUCCESS;

    do {

      DEBUGPRINT( DEBUG_OPTIONS,
                  ( "Checking realmflag \"%ws\"...\n",
                    *pFlagCursor ) );

      // first, try to convert to hex.  

      id = wcstoul( *pFlagCursor,
                    &Cursor,
                    0 ); // use defaults

      if ( *Cursor != '\0' ) {

        if ( !LookupRealmFlagByName( *pFlagCursor,
                                     &pMap ) ) {

          printf( "Unknown Realm Flag: \"%ws\"\n",
                  *pFlagCursor );

          N = STATUS_INVALID_PARAMETER;
          break;

        } else {

          id = pMap->Id;

        }

      } // otherwise, the work's already been done.

      pFlagCursor++;
      *pulFlags |= id;

    } while( *pFlagCursor != NULL );

    return N;

}

NTSTATUS
SetRealmFlags( IN LPWSTR *Params ) {

    LPWSTR   RealmName  = Params[ 0 ];
    ULONG    RealmFlags = 0;
    NTSTATUS N          = STATUS_SUCCESS; // 279621: this was uninitialized.

    if( Params[1] != NULL )
    {
	N = ResolveRealmFlags( Params+1,
			       &RealmFlags );

	if ( NT_SUCCESS( N ) ) 
	{
	    N = SetRealmFlags( RealmName,
			       RealmFlags );
	}
    }
    else // Clear all realm flags
    {
	SetRealmFlags( RealmName, 0 );
    }
    
    return N;

}

NTSTATUS
AddRealmFlags( IN LPWSTR *Params ) {

    LPWSTR   RealmName  = Params[ 0 ];
    ULONG    RealmFlags = 0;
    NTSTATUS N;

    N = GetRealmFlags( RealmName,
                       &RealmFlags );

    if ( NT_SUCCESS( N ) ) {
      N = ResolveRealmFlags( Params+1,
                             &RealmFlags );

      if ( NT_SUCCESS( N ) ) {
        
        N = SetRealmFlags( RealmName,
                           RealmFlags );

      }
    }

    return N;

}

    

NTSTATUS
DelRealmFlags( IN LPWSTR *Params ) {

    LPWSTR   RealmName  = Params[ 0 ];
    ULONG    RealmFlags = 0;
    ULONG    DeleteFlags = 0;
    NTSTATUS N;

    N = GetRealmFlags( RealmName,
                       &RealmFlags );
    
    if ( NT_SUCCESS( N ) ) {
      N = ResolveRealmFlags( Params+1,
                             &DeleteFlags );

      if ( NT_SUCCESS( N ) ) {
        
        N = SetRealmFlags( RealmName,
                           RealmFlags &~ DeleteFlags );

      }
    }

    return N;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\ksetup\mapuser.cxx ===
/*++

  MAPUSER.CXX

  Copyright (C) 1999 Microsoft Corporation, all rights reserved.

  DESCRIPTION: code for MapUser()

  Created, May 21, 1999 by DavidCHR.

--*/  

#include "everything.hxx"

extern "C" {
#include <malloc.h> // alloca
#include "..\keytab2\keytab\ldlib\delegtools.h"
}

static CHAR AltSecId[]     = "AltSecurityIdentities";
static CHAR AltSecPrefix[] = "KERBEROS:";
static CHAR PreQuery[]     = "(objectClass=user)"; /* For performance
						      reasons, we should
						      query an indexed type */

NTSTATUS
MapUserInDirectory( IN          LPWSTR Principal,
		    IN OPTIONAL LPWSTR Account ) {

    LPSTR     Attributes[]  = { NULL }; // request no attributes
    PCHAR     PrincValues[] = { NULL, NULL };
    LDAPModA  TheMod        = { LDAP_MOD_DELETE,
			       AltSecId,
			       PrincValues };
    PLDAPModA Mods[]        = { &TheMod, NULL };
    CHAR      SearchBuffer  [ UNLEN + 100 ]; /* The most we could have to
						search for is UNLEN (for either
						the principalname or the
						accountname) + 100 for the
						semantics of the query */
    NTSTATUS  ret           = STATUS_INTERNAL_ERROR;
    LPSTR     ObjectDn;
    ULONG     lderr;

    if ( ( lstrcmpW( Principal, L"*" ) == 0 ) ||
	 ( Account && ( lstrcmpW( Account, L"*" ) == 0 ) ) ) {

      printf( "Wildcard account mappings are not supported"
	      " at the domain level.\n" );

      return STATUS_NOT_SUPPORTED;

    }

    if ( ConnectedToDsa() ) {

      if ( Account ) { // changing the attribute -- search for the account

	wsprintfA( SearchBuffer,
		   "(& %hs (samAccountName=%ws))",
		   PreQuery,
		   Account );

      } else {         // deleting the attribute -- search for the attr

	wsprintfA( SearchBuffer,
		   "(& %hs (%hs=%hs%ws))",
		   PreQuery,
		   AltSecId,
		   AltSecPrefix,
		   Principal );

      }

      if ( LdapSearchForUniqueDnA( GlobalLdap,
				   SearchBuffer,
				   Attributes,
				   &ObjectDn,
				   NULL ) ) {
	

	PrincValues[ 0 ] = (PCHAR) alloca( lstrlenW( Principal ) + 30 );
	if ( !PrincValues[ 0 ] ) {
	  
	  return STATUS_NO_MEMORY; /* NOTE: 73954: This leaks, but the
				      app terminates immediately afterwards,
				      so we don't actually care. */
				      
	  
	}
	
	wsprintfA( PrincValues[ 0 ],
		   "%hs%ws",
		   AltSecPrefix,
		   Principal );


	if ( Account ) {
	  
	  TheMod.mod_op = LDAP_MOD_ADD;

	} else {

	  TheMod.mod_op = LDAP_MOD_DELETE;

	}

	lderr = ldap_modify_sA( GlobalLdap,
				ObjectDn,
				Mods );

	// special-case output here:

	switch( lderr ) {

	 case LDAP_SUCCESS:

	   printf( "Mapping %hs successfully.\n",
		   Account ? "created" : "deleted" );

	   ret = STATUS_SUCCESS;
	   break;

	 default:

	   printf( "Failed to %hs %hs on %hs; error 0x%x.\n",
		   Account ? "set" : "delete",
		   AltSecId,
		   ObjectDn,
		   lderr );

	   ret = STATUS_UNSUCCESSFUL;

	   break;

	}
	   

	free( ObjectDn );

      } else {

	printf( "Could not locate the account mapping in the directory.\n" );

      }
	   
    }
    return ret;
}


NTSTATUS
MapUserInRegistry( IN          LPWSTR Principal,
		   IN OPTIONAL LPWSTR Account ) {

    DWORD RegErr;
    HKEY KerbHandle = NULL;
    HKEY UserListHandle = NULL;
    DWORD Disposition;

    RegErr = OpenKerberosKey(&KerbHandle);
    if (RegErr)
    {
        goto Cleanup;
    }

    RegErr = RegCreateKeyEx(
                KerbHandle,
                L"UserList",
                0,
                NULL,
                0,              // no options
                KEY_CREATE_SUB_KEY | KEY_SET_VALUE,
                NULL,
                &UserListHandle,
                &Disposition
                );
    if (RegErr)
    {
        printf("Failed to create UserList key: %d\n",RegErr);
        goto Cleanup;
    }

    if ( Account && Account[0] ) {

      RegErr = RegSetValueEx( UserListHandle,
			      Principal,
			      0,
			      REG_SZ,
			      (PBYTE) Account,
			      (wcslen(Account) + 1) * sizeof(WCHAR)
			      );

      if (RegErr)
	{
	  printf("Failed to set name mapping  value: %d\n",RegErr);
	  goto Cleanup;
	}    

    } else {

      /* if no second parameter was supplied, 
	 delete the mapping. */

      RegErr = RegDeleteValue( UserListHandle,
			       Principal );

      switch( RegErr ) {

       case ERROR_PATH_NOT_FOUND:
       case ERROR_FILE_NOT_FOUND:

	 RegErr = ERROR_SUCCESS; 
	 // fallthrough to success case

       case ERROR_SUCCESS:
	 break;

       default:
	 
	 printf( "Failed to delete mapping for %ws: error 0x%x.\n",
		 Principal,
		 RegErr );

	 goto Cleanup;

      }
    }

Cleanup:
    if (KerbHandle)
    {
        RegCloseKey(KerbHandle);
    }
    if (UserListHandle)
    {
        RegCloseKey(UserListHandle);
    }
    if (RegErr)
    {
        return(STATUS_UNSUCCESSFUL);
    }
    return(STATUS_SUCCESS);

}


NTSTATUS
MapUser( IN LPWSTR * Parameters ) {

    return ( GlobalDomainSetting ? 
	     MapUserInDirectory : 
	     MapUserInRegistry )( Parameters[ 0 ],
				  Parameters[ 1 ] );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\ksetup\servers.cxx ===
/*++

  SERVERS.CXX

  Copyright (C) 1999 Microsoft Corporation, all rights reserved.

  DESCRIPTION: adding/removing servers

  Created, May 21, 1999 by DavidCHR.

--*/ 

#include "everything.hxx"

NTSTATUS
RemoveDomainName( IN LPWSTR *pRealmToRemove ) {

    LPWSTR   TargetRealm = *pRealmToRemove;
    DWORD    dwErr;
    HKEY     hDomainsKey;
    NTSTATUS N = STATUS_UNSUCCESSFUL;

    dwErr = OpenSubKey( NULL,
                        &hDomainsKey );
    
    if ( ERROR_SUCCESS == dwErr ) {

      dwErr = RegDeleteKeyW( hDomainsKey,
                             TargetRealm );

      switch( dwErr ) {

       case ERROR_SUCCESS:

         N = STATUS_SUCCESS;
         break;

       case ERROR_FILE_NOT_FOUND:
       case ERROR_PATH_NOT_FOUND:

         printf( "No realm mappings found for %ws.\n",
                 TargetRealm );
         break;

       default:

         printf( "Failed to delete registry mapping for %ws.  Error 0x%x.\n",
                 TargetRealm,
                 dwErr );

      }

      RegCloseKey( hDomainsKey );

    } // else an error was already logged.

    return N;

}

NTSTATUS 
RemoveServerName( IN  LPWSTR *Parameters,
                  IN  LPWSTR KeyName,
                  OUT PBOOL  pbDeletedLastEntry OPTIONAL ) {

    DWORD RegErr;
    HKEY DomainHandle = NULL;
    DWORD Disposition;
    LPWSTR OldServerNames = NULL;
    LPWSTR NewServerNames = NULL;
    ULONG TotalKdcLength, OldKdcLength = 0;
    ULONG NewKdcLength = 0;
    ULONG Type, Length;
    BOOL  PrintedNewServers = FALSE;
    CMULTISTRING StringClass;

    RegErr = OpenSubKey( Parameters,
                         &DomainHandle );
    if (RegErr)
    {
        goto Cleanup;
    }

    RegErr = STATUS_UNSUCCESSFUL;

    if ( StringClass.ReadFromRegistry( DomainHandle,
                                       KeyName ) ) {

      if ( StringClass.RemoveString( Parameters[ 1 ] ) ) {

        if ( StringClass.WriteToRegistry( DomainHandle,
                                          KeyName ) ) {
          
          RegErr = ERROR_SUCCESS;
          if ( pbDeletedLastEntry ) {
            *pbDeletedLastEntry = ( StringClass.cEntries == 0 );
          }
        }
      }

    }

Cleanup:
    if (NewServerNames)
    {
        LocalFree(NewServerNames);
    }
    if (OldServerNames)
    {
        LocalFree(OldServerNames);
    }
    if (DomainHandle)
    {
        RegCloseKey(DomainHandle);
    }

    if (RegErr)
    {
        return(STATUS_UNSUCCESSFUL);
    }
    return(STATUS_SUCCESS);

}



NTSTATUS
AddServerName(IN LPWSTR * Parameters, 
              IN LPWSTR   KeyName
              )
{
    DWORD RegErr;
    HKEY KerbHandle = NULL;
    HKEY DomainHandle = NULL;
    HKEY DomainRoot = NULL;
    DWORD Disposition;
    LPWSTR OldServerNames = NULL;
    LPWSTR NewServerNames = NULL;
    ULONG OldKdcLength = 0;
    ULONG NewKdcLength = 0;
    ULONG Type;
    CMULTISTRING StringClass;

    RegErr = OpenSubKey( Parameters,
                         &DomainHandle );
    if (RegErr)
    {
        goto Cleanup;
    }

    RegErr = STATUS_UNSUCCESSFUL;

    if ( StringClass.ReadFromRegistry( DomainHandle,
                                       KeyName ) ) {

      StringClass.AddString( Parameters[ 1 ] );
      
      if ( StringClass.WriteToRegistry( DomainHandle,
                                        KeyName ) ) {
        
        RegErr = ERROR_SUCCESS;

      }

    }

Cleanup:
    if (NewServerNames)
    {
        LocalFree(NewServerNames);
    }
    if (OldServerNames)
    {
        LocalFree(OldServerNames);
    }
    if (DomainHandle)
    {
        RegCloseKey(DomainHandle);
    }
    if (DomainRoot)
    {
        RegCloseKey(DomainRoot);
    }
    if (KerbHandle)
    {
        RegCloseKey(KerbHandle);
    }
    if (RegErr)
    {
        return(STATUS_UNSUCCESSFUL);
    }
    return(STATUS_SUCCESS);

}

NTSTATUS
AddKdcName(
    LPWSTR * Parameters
    )
{
    if( !CheckUppercase( Parameters[0] ) )
    {
	return STATUS_UNSUCCESSFUL;
    }    
    
    if( Parameters[1] == NULL )
    {
	HKEY DomainHandle = NULL;
	NTSTATUS Status;
	
	Status = OpenSubKey( Parameters, &DomainHandle );
	if( DomainHandle )
	{
	    RegCloseKey( DomainHandle );
	}
	return Status;
    }
    else
    {
	return(AddServerName(Parameters, KERB_DOMAIN_KDC_NAMES_VALUE));
    }
}

NTSTATUS
DeleteKdcName( IN LPWSTR * Parameters ) {

    NTSTATUS                N;
    BOOL                    bLastOne, bRemoveFromDomain;
    PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;
    UNICODE_STRING          tempDomain;
    
    if( Parameters[1] == NULL )
    {
	return( RemoveDomainName( Parameters ) );
    }

    N = RemoveServerName( Parameters, 
                          KERB_DOMAIN_KDC_NAMES_VALUE,
                          &bLastOne );

    if ( NT_SUCCESS( N ) && bLastOne ) {

      fprintf( stderr,
               "NOTE: no kdc's are currently defined for the %ws realm.\n",
               Parameters[ 0 ] );

      /* we removed the last KDC; check to see if we're directly "joined"
         to this domain. */

      N = LsaQueryInformationPolicy( LsaHandle,
                                     PolicyDnsDomainInformation,
                                     (PVOID *) &DnsDomainInfo
                                     );

      if ( NT_SUCCESS( N ) ) {

        RtlInitUnicodeString( &tempDomain,
                              Parameters[ 0 ] );

        if ( RtlCompareUnicodeString( &tempDomain,
                                      &DnsDomainInfo->DnsDomainName,
                                      TRUE )  // case insensitive
             == 0 ) {

          if ( DnsDomainInfo->Sid != NULL ) {

            fprintf( stderr,
                     "NOTE: %wZ is an NT domain.\n"
                     "  If you want to leave the domain, use the SYSTEM Control Panel applet.\n",
                     &DnsDomainInfo->DnsDomainName );

          } else {

            // this was our primary domain.  Unjoin from it.

          }

        } // else, this was not our primary domain.  Do nothing further.


        LsaFreeMemory( DnsDomainInfo );

      } else {

        fprintf( stderr,
                 "Unable to determine domain membership (error 0x%x).\n",
                 N );

      }

    }

    return N;

}

NTSTATUS
AddKpasswdName(
    LPWSTR * Parameters
    )
{
    return(AddServerName(Parameters, KERB_DOMAIN_KPASSWD_NAMES_VALUE));
}

NTSTATUS
DelKpasswdName( IN LPWSTR * Parameters ) {

    return RemoveServerName( Parameters,
                             KERB_DOMAIN_KPASSWD_NAMES_VALUE,
                             NULL );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\moveme\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-21-94   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__

#include <dsysdbg.h>

// The following Debug Flags can be turned on to trace different areas to
// trace while executing.  Feel free to add more levels.

#define DEB_TRACE_UI        0x00000008

#if DBG

DECLARE_DEBUG2(MoveMe);


#define DebugLog(x) MoveMeDebugPrint x



#else   // Not DBG

#define DebugLog(x)

#endif

VOID
InitDebugSupport(
    VOID );


#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\ksetup\strings.cxx ===
/*++

  STRINGS.CXX

  Copyright (C) 1999 Microsoft Corporation, all rights reserved.

  DESCRIPTION: MultiString class

  Created, Dec 29, 1999 by DavidCHR.

  CONTENTS: CMULTISTRING
            WriteToRegistry
            ReadFromRegistry
            RemoveString
            AddString
            ~CMULTISTRING

--*/  

#include "everything.hxx"

/*++**************************************************************
  NAME:      CMULTISTRING

  constructor for the class.  

 **************************************************************--*/

CMULTISTRING::
CMULTISTRING( VOID ) {

    this->cEntries         = 0;
    this->pEntries         = NULL;
    this->TotalStringCount = 0;

}

/*++**************************************************************
  NAME:      ~CMULTISTRING

  destructor for the class.  Frees any strings still around.
  
 **************************************************************--*/

CMULTISTRING::
~CMULTISTRING( VOID ) {

    ULONG i;

    if ( this->cEntries &&
	 this->pEntries ) {

      for ( i = 0 ;
	    i < this->cEntries ;
	    i ++ ) {

	if ( this->pEntries[ i ] ) {
	  free( this->pEntries[ i ] );
	}

      }

      free( this->pEntries );

    }

}


/*++**************************************************************
  NAME:      AddString

  adds a string to the end of string table

  MODIFIES:  this->pEntries, this->cEntries

  TAKES:     String -- string to add (duplicated)

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.

  LOGGING:   printf on failure
  CREATED:   Dec 29, 1999
  LOCKING:   none
  CALLED BY: anyone
  FREE WITH: ~CMULTISTRING
  
 **************************************************************--*/

BOOL CMULTISTRING::
AddString( IN LPWSTR String ) {

    LPWSTR *tempString;

    tempString = (LPWSTR *) realloc( this->pEntries,
				     ( this->cEntries + 1 ) *
				     sizeof( LPWSTR ) );

    if ( tempString ) {

      this->pEntries               = tempString;
      tempString[ this->cEntries ] = _wcsdup( String );
			  
      if ( tempString[ this->cEntries ] ) {

	this->cEntries         ++;
	this->TotalStringCount += wcslen( String );

	return TRUE;

      } else {

	printf( "Cannot add string %ld (%ws).  Not enough memory.\n",
		this->cEntries,
		String );

	SetLastError( ERROR_NOT_ENOUGH_MEMORY );

      }

      // don't free the string.

    }

    return FALSE;

}

/*++**************************************************************
  NAME:      RemoveString

  removes a string from the list

  MODIFIES:  this->pEntries, this->cEntries

  TAKES:     String -- string to remove (case-insensitive)

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LOGGING:   printf if the string doesn't exist
  CREATED:   Dec 29, 1999
  LOCKING:   none
  CALLED BY: anyone
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/


BOOL CMULTISTRING::
RemoveString( IN LPWSTR String ) {

    ULONG i, DeleteCount = 0;
    BOOL  ret = TRUE;

    // first, go through and free the matches
 
    for ( i = 0 ;
	  i < this->cEntries ;
	  i ++ ) {

      if ( _wcsicmp( String,
		     this->pEntries[ i ] ) == 0 ) {

	// match.  Free it.

	free( this->pEntries[ i ] );
	this->pEntries[ i ] = NULL;
	DeleteCount++;

      } else if ( DeleteCount > 0 ) {

	/* If we've deleted stuff already, and we're not deleting
	   this one, then move this entry earlier in the array. */

	this->pEntries[ i - DeleteCount ] = this->pEntries[ i ];

#if DBG

	/* For the sake of debugging, set this to a known
	   bad value. */
#ifdef _WIN64 // to avoid ia64 compile-time error, give it a qword for a pointer
	this->pEntries[ i ] = (LPWSTR) 0xdeadbeefdeadbeef;
#else	
	this->pEntries[ i ] = (LPWSTR) ULongToPtr( 0xdeadbeef );
#endif // _WIN64

#endif // DBG

      }
    }

    if ( DeleteCount ) {

      this->cEntries         -= DeleteCount;
      this->TotalStringCount -= DeleteCount * wcslen( String );

      /* We could realloc the array down to the correct cEntries now,
	 but there's no pressing need. */

    } else {

      printf( "No match for %ws.\n",
	      String );

      ret = FALSE;

    }

    return ret;

}
	

/*++**************************************************************
  NAME:      ReadFromRegistry

  reads a string vector from a REG_MULTI_SZ in the registry

  MODIFIES:  this, indirectly

  TAKES:     hKey      -- handle to open parent key
             ValueName -- value to read

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LOGGING:   printf on failure
  CREATED:   Dec 29, 1999
  LOCKING:   none
  CALLED BY: anyone
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/


BOOL CMULTISTRING::
ReadFromRegistry( IN HKEY   hKey,
		  IN LPWSTR ValueName ) {
    
    ULONG   RegistrySize = 0;
    ULONG   cEntries     = 0;
    LPWSTR  RegistryStrings;
    LPWSTR *StringTable = NULL;
    LPWSTR *pTempTable, Cursor;
    DWORD   WinError;
    DWORD   Type;
    BOOL    ret = FALSE;

    WinError = RegQueryValueEx( hKey,
				ValueName,
				NULL,
				&Type,
				NULL,
				&RegistrySize );
               
    if (WinError == ERROR_SUCCESS) {
      
      RegistryStrings = (LPWSTR) malloc( RegistrySize );
      
      if ( RegistryStrings ) {

	WinError = RegQueryValueEx( hKey,
				    ValueName,
				    NULL,
				    &Type,
				    (PUCHAR) RegistryStrings,
				    &RegistrySize );

	if (WinError == ERROR_SUCCESS) {

	  ret = TRUE;

	  if ( RegistrySize > 2 * sizeof( WCHAR ) ) { /* 2 == two nulls
							 which would indicate
							 that the value is
							 empty. */

	    /* Now, allocate a string vector, counting the strings
	       as we go. */

	    for ( Cursor = RegistryStrings ;
		  *Cursor != L'\0' ;
		  Cursor = wcschr( Cursor, '\0' ) +1 ) {

	      if ( !this->AddString( Cursor ) ) {

		ret = FALSE;
		break;

	      }

	    }

	  } // else the value was empty -- nothing to do.

	} else {

	  printf("Failed to query value %ws: 0x%x\n",
		 ValueName,
		 WinError );
	}

	free( RegistryStrings );

      } else {

	printf( "Failed to allocate %hs buffer (0x%x)\n",
		ValueName,
		RegistrySize );

      }
    } else if ( WinError == ERROR_FILE_NOT_FOUND ) {

      /* The key doesn't exist-- no mappings. */
      
      // WinError = ERROR_SUCCESS;
      ret = TRUE;

    } else {

      /* an actual error. */

      printf( "Failed to query %ws: 0x%x\n",
	      ValueName,
	      WinError );

    }

    return ret;
}
	


/*++**************************************************************
  NAME:      WriteToRegistry

  dumps the string vector to a REG_MULTI_SZ in the registry

  MODIFIES:  the registry only

  TAKES:     hKey      -- handle to open parent key
             ValueName -- value to write

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LOGGING:   printf on failure
  CREATED:   Dec 29, 1999
  LOCKING:   none
  CALLED BY: anyone
  FREE WITH: n/a -- no resources are allocated
  
 **************************************************************--*/


BOOL CMULTISTRING::
WriteToRegistry( IN HKEY   hKey,
		 IN LPWSTR ValueName ) {

    LPWSTR StringVector;
    ULONG  StringIndex, EntryIndex, Length, VectorLength;
    DWORD  dwErr;
    BOOL   ret = FALSE;

    VectorLength = ( this->TotalStringCount + // string characters
		     this->cEntries +         // null characters
		     2                        // trailing nulls
		     ) * sizeof( WCHAR );


    StringVector = (LPWSTR) malloc( VectorLength );

    if ( !StringVector ) {

      printf( "Failed to allocate string blob to write %ws.\n",
	      ValueName );

    } else {

      for ( StringIndex = EntryIndex = 0 ;
	    EntryIndex < this->cEntries ;
	    EntryIndex++ ) {

	Length = wcslen( this->pEntries[ EntryIndex ] ) +1; /* include the
							       null */

	memcpy( StringVector + StringIndex,   // to
		this->pEntries[ EntryIndex ], // from
		Length * sizeof( WCHAR ) );   // byte count

	StringIndex += Length;

      }

      StringVector[ StringIndex   ] = L'\0';
      StringVector[ StringIndex+1 ] = L'\0';
	
      dwErr = RegSetValueExW( hKey,
			      ValueName,
			      0, // mbz
			      REG_MULTI_SZ,
			      (PBYTE) StringVector,
			      VectorLength );

      free( StringVector );

      if ( dwErr != ERROR_SUCCESS ) {

	printf( "Failed to write %ws value to registry: 0x%x.\n",
		ValueName,
		dwErr );

      } else {

	ret = TRUE;

      }

    }

    return ret;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\moveme\dialogs.h ===
#define IDD_MAIN_DLG                100
#define IDD_GROUPBOX_1              101
#define IDD_PROFILE_CHECK           102
#define IDD_RADIO_MAKECOPY          103
#define IDD_RADIO_REFER_TO_SAME     104
#define IDD_MOVE_MACHINE            105
#define IDD_ABOUT                   106
#define IDD_ABOUT_2                 107
#define IDD_DOMAIN_LINE             108
#define IDD_WKSTA_DOMAIN            109
#define IDD_MAIN_ICON               110
#define IDD_UPDATE_SEC              111
#define IDD_RADIO_MAKE_ROAM         112
#define IDD_MIGRATING               200
#define IDD_MIGRATING_TEXT          201
#define IDD_MIGRATING_PROGRESS      202
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\moveme\moveme.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       moveme.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5-21-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "moveme.h"
#include "dialogs.h"
#include <stdlib.h>

#define APPNAME TEXT("fail")
#define FILENAME TEXT("moveme.ini")

ULONG MoveOptions = MOVE_UPDATE_SECURITY | MOVE_DO_PROFILE ;

WCHAR   MachDomain[ DNLEN * 2 ];
WCHAR   SourceDomain[ DNLEN * 2 ];
WCHAR   DestDomain[ DNLEN * 2 ];
WCHAR   UserName[ UNLEN * 2 ];
PSID    OldSid ;
PSID    NewSid ;
HICON   MyIcon ;
PDOMAIN_CONTROLLER_INFO DcInfo ;
PDOMAIN_CONTROLLER_INFO DestDcInfo ;

OSVERSIONINFOEX VersionInfo ;

DWORD   ProfileSection[] = { IDD_RADIO_MAKECOPY, IDD_RADIO_REFER_TO_SAME, IDD_RADIO_MAKE_ROAM };

VOID
EnableSection(
    HWND hDlg,
    BOOL Enable,
    PDWORD IdList,
    DWORD Count
    )
{
    DWORD i ;
    for ( i = 0 ; i < Count ; i++ )
    {
        EnableWindow( GetDlgItem( hDlg, IdList[ i ]), Enable );
    }
}

VOID
DumpState(
    VOID
    )
{
    UNICODE_STRING Sid ;
    WCHAR PrivateInt[ 16 ];

    swprintf( PrivateInt, L"%d", VersionInfo.dwBuildNumber );

    WritePrivateProfileString( APPNAME, TEXT("Build"), PrivateInt, FILENAME );
    WritePrivateProfileString( APPNAME, TEXT("MachDomain"), MachDomain, FILENAME);
    WritePrivateProfileString( APPNAME, TEXT("SourceDomain"), SourceDomain, FILENAME );
    WritePrivateProfileString( APPNAME, TEXT("DestDomain"), DestDomain, FILENAME );
    WritePrivateProfileString( APPNAME, TEXT("UserName"), UserName, FILENAME );
    if ( DcInfo )
    {
        WritePrivateProfileString( APPNAME, TEXT("DcInfo.name"), DcInfo->DomainControllerName, FILENAME);
        WritePrivateProfileString( APPNAME, TEXT("DcInfo.address"), DcInfo->DomainControllerAddress, FILENAME );
        WritePrivateProfileString( APPNAME, TEXT("DcInfo.domainname"), DcInfo->DomainName, FILENAME );
        WritePrivateProfileString( APPNAME, TEXT("DcInfo.treename"), DcInfo->DnsForestName, FILENAME );
        WritePrivateProfileString( APPNAME, TEXT("DcInfo.dcsite"), DcInfo->DcSiteName, FILENAME );
        WritePrivateProfileString( APPNAME, TEXT("DcInfo.clientsite"), DcInfo->ClientSiteName, FILENAME );
        //WritePrivateProfileInt( APPNAME, TEXT("DcInfo.Flags"), DcInfo->Flags, FILENAME );
    }
    if ( DestDcInfo )
    {
        WritePrivateProfileString( APPNAME, TEXT("DestDcInfo.name"), DestDcInfo->DomainControllerName, FILENAME);
        WritePrivateProfileString( APPNAME, TEXT("DestDcInfo.address"), DestDcInfo->DomainControllerAddress, FILENAME );
        WritePrivateProfileString( APPNAME, TEXT("DestDcInfo.domainname"), DestDcInfo->DomainName, FILENAME );
        WritePrivateProfileString( APPNAME, TEXT("DestDcInfo.treename"), DestDcInfo->DnsForestName, FILENAME );
        WritePrivateProfileString( APPNAME, TEXT("DestDcInfo.dcsite"), DestDcInfo->DcSiteName, FILENAME );
        WritePrivateProfileString( APPNAME, TEXT("DestDcInfo.clientsite"), DestDcInfo->ClientSiteName, FILENAME );

    }
    if ( OldSid )
    {
        RtlConvertSidToUnicodeString( &Sid, OldSid, TRUE );
        WritePrivateProfileString( APPNAME, TEXT("OldSid"), Sid.Buffer, FILENAME );
        RtlFreeUnicodeString( &Sid );
    }
    else
    {
        WritePrivateProfileString( APPNAME, TEXT("OldSid"), TEXT("<none>"), FILENAME );
    }
    if ( NewSid )
    {
        RtlConvertSidToUnicodeString( &Sid, NewSid, TRUE );
        WritePrivateProfileString( APPNAME, TEXT("NewSid"), Sid.Buffer, FILENAME );
        RtlFreeUnicodeString( &Sid );
    }
    else
    {
        WritePrivateProfileString( APPNAME, TEXT("NewSid"), TEXT("<none>"), FILENAME );
    }


}

VOID
Fail(
    HWND hWnd,
    PWSTR Failure,
    PWSTR Description,
    DWORD Code,
    PWSTR Message
    )
{
    UNICODE_STRING Sid ;
    WCHAR Msg[MAX_PATH];
    WCHAR foo[MAX_PATH];

    UpdateUi(0,100);
    StopUiThread();

    DumpState();

    WritePrivateProfileString( APPNAME, TEXT("Failure"), Failure, FILENAME );
    WritePrivateProfileString( APPNAME, TEXT("Desc"), Description, FILENAME );
    wsprintf( Msg, L"%d (%#x)", Code, Code );
    WritePrivateProfileString( APPNAME, TEXT("Code"), Msg, FILENAME );

    ExpandEnvironmentStrings( TEXT("%windir%"), foo, MAX_PATH );
    _snwprintf( Msg, MAX_PATH, TEXT("%ws  Please mail the file %ws in %ws to 'ntdsbug'"),
                    Message ? Message : TEXT("An unrecoverable error occurred, and has prevented you from joining the NTDEV rollout."),
                    FILENAME, foo );
    MessageBox( hWnd, Msg, TEXT("Error"), MB_ICONSTOP | MB_OK );

    ExitProcess( GetLastError() );
}

PSECURITY_DESCRIPTOR
MakeUserSD(
    PSID UserSid,
    ACCESS_MASK Mask
    )
{
    PSECURITY_DESCRIPTOR psd ;
    PACL Dacl ;
    DWORD DaclLen ;
    PACCESS_ALLOWED_ACE Ace ;
    PSID LocalSystem ;
    SID_IDENTIFIER_AUTHORITY NtAuth = SECURITY_NT_AUTHORITY ;

    AllocateAndInitializeSid( &NtAuth, 1,
        SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0,
        &LocalSystem );

    psd = LocalAlloc( LMEM_FIXED, sizeof( SECURITY_DESCRIPTOR ) );

    DaclLen = (sizeof( ACCESS_ALLOWED_ACE ) + RtlLengthSid( UserSid )) * 2 ;

    Dacl = LocalAlloc( LMEM_FIXED, DaclLen );

    if ( !psd || !Dacl)
    {
        return NULL ;
    }

    InitializeSecurityDescriptor( psd, SECURITY_DESCRIPTOR_REVISION );
    InitializeAcl( Dacl, DaclLen, ACL_REVISION );

    SetSecurityDescriptorDacl( psd, TRUE, Dacl, FALSE );

    AddAccessAllowedAce( Dacl, ACL_REVISION, Mask, UserSid );

    GetAce( Dacl, 0, &Ace );

    Ace->Header.AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE ;

    AddAccessAllowedAce( Dacl, ACL_REVISION, Mask, LocalSystem );

    GetAce( Dacl, 1, &Ace );

    Ace->Header.AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE ;

    return psd ;

}

RecurseWhackKey(
    HKEY ParentKey,
    PWSTR SubKey,
    PSECURITY_DESCRIPTOR psd
    )
{
    HKEY Key ;
    int err ;
    NTSTATUS Status ;
    WCHAR SubKeys[ 128 ];
    DWORD dwSize ;
    DWORD dwIndex ;
    FILETIME ftTime ;

    err = RegOpenKeyEx(
            ParentKey,
            SubKey,
            0,
            WRITE_DAC | WRITE_OWNER,
            &Key );

    if ( err == 0 )
    {
        Status = NtSetSecurityObject(   Key,
                                        OWNER_SECURITY_INFORMATION |
                                            DACL_SECURITY_INFORMATION,
                                        psd );

        if ( NT_SUCCESS( Status ) )
        {
            RegCloseKey( Key );

            err = RegOpenKeyEx(
                        ParentKey,
                        SubKey,
                        0,
                        KEY_READ | KEY_WRITE,
                        &Key );

            if ( err )
            {
                return err;
            }

            dwIndex = 0 ;
            dwSize = sizeof( SubKeys ) / sizeof( WCHAR );

            while ( RegEnumKeyEx( Key,
                                dwIndex,
                                SubKeys,
                                &dwSize,
                                NULL,
                                NULL,
                                NULL,
                                &ftTime ) == ERROR_SUCCESS )
            {
                RecurseWhackKey( Key, SubKeys, psd );
                dwIndex++ ;
                dwSize = sizeof( SubKeys ) / sizeof( WCHAR );
            }

        }

        RegCloseKey( Key );
    }

    return err ;
}


VOID
DealWithPstore(
    PSID UserSid
    )
{
    HKEY hKey = NULL;
    int err ;
    BOOLEAN WasEnabled ;
    NTSTATUS Status ;
    PSECURITY_DESCRIPTOR psd ;


    Status = RtlAdjustPrivilege( SE_TAKE_OWNERSHIP_PRIVILEGE, TRUE, FALSE, &WasEnabled );

    if ( !NT_SUCCESS( Status ))
    {
        return ;
    }

    err = RegOpenKeyEx(
                HKEY_CURRENT_USER,
                TEXT("Software\\Microsoft"),
                0,
                KEY_READ | KEY_WRITE,
                &hKey );

    if( err != 0 )
    {
        return ;
    }

    psd = MakeUserSD( UserSid, KEY_ALL_ACCESS );

    SetSecurityDescriptorOwner( psd, UserSid, FALSE );

    RecurseWhackKey( hKey, TEXT("Protected Storage System Provider"), psd );


}

BOOL
MoveMe(
    HWND    hWnd,
    LPWSTR  OldProfile,
    LPWSTR  NewProfile
    )
{
    HKEY hKeyCU ;
    int err ;
    WCHAR TempPath[ MAX_PATH ];
    WCHAR TempFile[ MAX_PATH ];
    WCHAR TempPath2[ MAX_PATH ];
    HANDLE Token ;
    DWORD PathLength ;
    BOOL Ret ;
    WCHAR UserNameEx[ 64 ];
    DWORD Index = 0 ;
    SECURITY_ATTRIBUTES sa ;

    if ( MoveOptions & MOVE_MAKE_ROAM )
    {

        GetTempPath( MAX_PATH, TempPath );

        GetTempFileName( TempPath, TEXT("prf"), GetTickCount() & 0xFFFF, TempFile );

        UpdateUi( IDS_COPYING_USER_HIVE, 30 );

        err = MyRegSaveKey( HKEY_CURRENT_USER,
                            TempFile,
                            NULL );

        if ( err )
        {
            Fail( hWnd, TEXT("Save HKCU failed"), TEXT(""), err, NULL);
            return err ;
        }

        if (OpenProcessToken(GetCurrentProcess(), MAXIMUM_ALLOWED, &Token ))
        {
            PathLength = MAX_PATH ;

            if (!GetUserProfileDirectory( Token, TempPath, &PathLength ))
            {
                Fail( hWnd, TEXT("Can't get current profile dir"), TEXT(""),
                        GetLastError(), NULL );
            }

        }
        else
        {
            Fail( hWnd, TEXT("Can't open process token?"), TEXT(""), GetLastError(), NULL );
        }

        UpdateUi( IDS_CREATING_NEW_PROFILE, 60 );


        Index = 64 ;

        GetUserName( UserNameEx, &Index );

        swprintf( TempPath2, TEXT("\\\\scratch\\scratch\\%ws\\Profile"), UserNameEx );

        sa.nLength = sizeof( sa );

        sa.bInheritHandle = FALSE ;

        sa.lpSecurityDescriptor = MakeUserSD( NewSid, FILE_ALL_ACCESS );

        if ( CreateDirectory( TempPath2, NULL ) )
        {
            UpdateUi( IDS_CREATING_NEW_PROFILE, 70 );

            if  ( ! CopyProfileDirectory( TempPath,
                                          TempPath2,
                                          CPD_FORCECOPY |
                                            CPD_IGNORECOPYERRORS |
                                            CPD_IGNOREHIVE |
                                            CPD_SHOWSTATUS ) )
            {
                if ( GetLastError() == 997 )
                {
                    //
                    // Looks like the dreaded pstore key problem.  Sigh.
                    //

                    DealWithPstore( NewSid );

                    if ( ! CopyProfileDirectory( TempPath,
                                          TempPath2,
                                          CPD_FORCECOPY |
                                            CPD_IGNORECOPYERRORS |
                                            CPD_IGNOREHIVE |
                                            CPD_SHOWSTATUS ) )
                    {
                        //
                        // Terminal, now bail:
                        //

                        Fail( hWnd, TEXT("Can't copy profile dir, even after whacking pstore key"), TempPath2, GetLastError(), NULL );

                        return GetLastError() ;
                    }


                }
                else
                {
                    Fail( hWnd, TEXT("Can't copy profile directory"), TempPath2, GetLastError(), NULL );

                    return GetLastError() ;
                }
            }
        }
        else
        {
            Fail( hWnd, TEXT("Can't create new directory"), TempPath2, GetLastError(), NULL );

            return GetLastError() ;
        }

        wcscat( TempPath2, TEXT("\\ntuser.dat") );

        if ( ! CopyFile( TempFile, TempPath2, FALSE ) )
        {
            Fail( hWnd, TEXT("Can't copy hive"), TempPath2, GetLastError(), NULL );
        }

        DeleteFile( TempFile );

        return GetLastError() ;
    }


    if ( MoveOptions & MOVE_COPY_PROFILE )
    {
        GetTempPath( MAX_PATH, TempPath );

        GetTempFileName( TempPath, TEXT("prf"), GetTickCount() & 0xFFFF, TempFile );

        UpdateUi( IDS_COPYING_USER_HIVE, 30 );

        err = MyRegSaveKey( HKEY_CURRENT_USER,
                            TempFile,
                            NULL );

        if ( err )
        {
            Fail( hWnd, TEXT("Save HKCU failed"), TEXT(""), err, NULL);
            return err ;
        }

        if (OpenProcessToken(GetCurrentProcess(), MAXIMUM_ALLOWED, &Token ))
        {
            PathLength = MAX_PATH ;

            if (!GetUserProfileDirectory( Token, TempPath, &PathLength ))
            {
                Fail( hWnd, TEXT("Can't get current profile dir"), TEXT(""),
                        GetLastError(), NULL );
            }

        }
        else
        {
            Fail( hWnd, TEXT("Can't open process token?"), TEXT(""), GetLastError(), NULL );
        }

        UpdateUi( IDS_CREATING_NEW_PROFILE, 60 );

        Ret = CreateUserProfile( NewSid, UserName, TempFile, NULL, 0 );

        if ( !Ret )
        {
            if ( GetLastError() == 997 )
            {
                //
                // Looks like the dreaded pstore key problem.  Sigh.
                //

                DeleteFile( TempFile );

                DealWithPstore( OldSid );

                err = MyRegSaveKey( HKEY_CURRENT_USER,
                                    TempFile,
                                    NULL );

                if ( ! CreateUserProfile( NewSid, UserName, TempFile, NULL, 0 ) )
                {
                    //
                    // Terminal, now bail:
                    //

                    DeleteFile( TempFile );

                    Fail( hWnd, TEXT("Can't copy profile dir, even after whacking pstore key"), TEXT(""), GetLastError(), NULL );

                    return GetLastError() ;
                }

                Ret = TRUE ;

            }
            else
            {
                DeleteFile( TempFile );

                Fail( hWnd, TEXT( "CreateUserProfile failed"), TEXT(""), GetLastError(), NULL );

            }


        }

        DeleteFile( TempFile );

        UpdateUi( IDS_CREATING_NEW_PROFILE, 65 );

        if ( Ret )
        {
            //
            // Okay, we have created a shell profile based on the current
            // profile.  Now, copy the rest of the gunk over it:
            //

            PathLength = MAX_PATH ;

            GetUserProfileDirectoryFromSid( NewSid, TempPath2, &PathLength );

            UpdateUi( IDS_COPYING_OLD_PROFILE, 90 );

            if ( !CopyProfileDirectory( TempPath,
                                       TempPath2,
                                       CPD_FORCECOPY |
                                        CPD_IGNORECOPYERRORS |
                                        CPD_IGNOREHIVE ) )
            {
                Fail( hWnd, TEXT("CopyProfileDirectory failed"), TEXT(""), GetLastError(), NULL );
            }


        }
        else
        {
            //
            // Failed to create the shell profile.  Why?
            //

            Fail( hWnd, TEXT("Failed to create profile"), TEXT(""), GetLastError(), NULL );
        }

    }
    else
    {
        SetUserProfileDirectory( OldSid, NewSid );
    }


    if ( MoveOptions & MOVE_CHANGE_DOMAIN )
    {
        NET_API_STATUS NetStatus ;

        UpdateUi( IDS_MOVE_DOMAIN, 50 );

        NetStatus = NetJoinDomain( NULL, DestDomain,NULL,
                                   TEXT("ntdev"), TEXT("ntdev"),
                                   NETSETUP_JOIN_DOMAIN |
                                   NETSETUP_ACCT_CREATE );



        UpdateUi( IDS_MOVE_DOMAIN, 95 );


    }




    return TRUE ;
}

VOID
DoSecurity(
    HWND hDlg
    )
{
    int err ;
    HKEY hKey ;
    DWORD Disp ;
    NET_API_STATUS NetStatus ;
    LOCALGROUP_MEMBERS_INFO_0 LocalGroupInfo0 ;

    UpdateUi( IDS_SEC_LOCAL_SETTINGS, 50 );

    err = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                          TEXT("System\\CurrentControlSet\\Control\\Lsa\\MSV1_0"),
                          0,
                          TEXT(""),
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ | KEY_WRITE,
                          NULL,
                          &hKey,
                          &Disp );

    if ( err == 0 )
    {
        err = RegSetValueEx( hKey,
                             TEXT("PreferredDomain"),
                             0,
                             REG_SZ,
                             (PUCHAR) SourceDomain,
                             (wcslen( SourceDomain ) + 1) * 2 );

        if ( err == 0 )
        {
            err = RegSetValueEx( hKey,
                                 TEXT("MappedDomain"),
                                 0,
                                 REG_SZ,
                                 (PUCHAR) DestDomain,
                                 (wcslen( DestDomain ) + 1 ) * 2 );
        }


        RegCloseKey( hKey );
    }
    else
    {
        Fail( hDlg, TEXT("Unable to open LSA key"), TEXT(""), err, TEXT("Unable to update rollout keys, you may not have permission.") );
    }

    UpdateUi( IDS_SEC_LOCAL_ADMIN, 90 );

    LocalGroupInfo0.lgrmi0_sid = NewSid ;

    NetStatus = NetLocalGroupAddMembers(
                        NULL,
                        L"Administrators",
                        0,
                        (LPBYTE) &LocalGroupInfo0,
                        1 );



}



BOOL
Initialize(
    VOID
    )
{
    ULONG Length ;
    HANDLE hToken ;
    PUNICODE_STRING User ;
    PUNICODE_STRING Domain ;
    UNICODE_STRING TargetDomainStr ;
    NTSTATUS Status ;
    PSID Sid ;
    PSID AdminSid ;
    PTOKEN_USER UserSid ;
    DWORD SidLength ;
    PBYTE DCName ;
    NET_API_STATUS NetStatus ;
    WCHAR RefDomain[ DNLEN + 2 ];
    ULONG RefDomainLength ;
    SID_NAME_USE NameUse ;
    BOOL IsMember ;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY ;

    RaiseUi( NULL, L"Initializing..." );

    UpdateUi( IDS_INIT_READ_NAMES, 5 );

    Status = NtOpenProcessToken( NtCurrentProcess(),
                                 TOKEN_QUERY,
                                 &hToken );

    if ( NT_SUCCESS( Status ) )
    {
        UserSid = LocalAlloc( LMEM_FIXED, 64 );

        if ( UserSid )
        {
            Status = NtQueryInformationToken( hToken,
                                              TokenUser,
                                              UserSid,
                                              64,
                                              &SidLength );

            if ( NT_SUCCESS( Status ) )
            {
                OldSid = UserSid->User.Sid ;
            }

        }

        AllocateAndInitializeSid( &NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0 ,0, 0,
                                    &AdminSid );

        if ( CheckTokenMembership( hToken, AdminSid, &IsMember ) )
        {
            if ( !IsMember )
            {
                Fail( NULL, TEXT("Not an administrator"), TEXT(""), GetLastError(),
                        TEXT( "You must be an administrator on this machine to run this utility." ) );
            }
        }

        NtClose( hToken );

    }

    if ( !NT_SUCCESS( Status ) )
    {
        Fail( NULL, TEXT("Reading SID"), TEXT(""), Status, NULL );
    }

    UpdateUi( IDS_INIT_READ_NAMES, 25 );

    Status = LsaGetUserName( &User, &Domain );


    if ( !NT_SUCCESS( Status ) )
    {
        Fail( NULL, TEXT("Getting user name"), TEXT(""), Status, NULL );

        return FALSE ;
    }

    RtlInitUnicodeString( &TargetDomainStr, DestDomain );

    if ( RtlEqualUnicodeString( &TargetDomainStr, Domain, TRUE ) )
    {
        MoveOptions &= ~MOVE_DO_PROFILE ;
        MoveOptions |= MOVE_NO_PROFILE ;
    }

    UpdateUi( IDS_INIT_READ_NAMES, 35 );

    GetPrimaryDomain( MachDomain );

    UpdateUi( IDS_INIT_READ_NAMES, 45 );

    NetStatus = DsGetDcName( NULL, MachDomain, NULL, NULL,
                             DS_FORCE_REDISCOVERY |
                             DS_DIRECTORY_SERVICE_REQUIRED |
                             DS_KDC_REQUIRED,
                             &DcInfo );

    UpdateUi( IDS_INIT_READ_NAMES, 55 );

    if ( (MoveOptions & MOVE_SOURCE_SUPPLIED) == 0)
    {
        CopyMemory( SourceDomain, Domain->Buffer, Domain->Length );
        SourceDomain[ Domain->Length / sizeof(WCHAR) ] = L'\0';
    }

    CopyMemory( UserName, User->Buffer, User->Length );
    UserName[ User->Length / sizeof(WCHAR) ] = L'\0';

    LsaFreeMemory( User );
    LsaFreeMemory( Domain );

    //
    // Dest Domain must be filled in by caller.  So, try to look up
    // the new SID:
    //


    SidLength = RtlLengthRequiredSid( 6 );

    Sid = LocalAlloc( LMEM_FIXED, SidLength );

    if ( !Sid )
    {
        return FALSE ;
    }

    UpdateUi( IDS_INIT_DISCOVER_DCS, 75 );

    RefDomainLength = DNLEN + 2 ;

    NetStatus = DsGetDcName( NULL, DestDomain, NULL, NULL,
                             DS_FORCE_REDISCOVERY |
                             DS_DIRECTORY_SERVICE_REQUIRED |
                             DS_KDC_REQUIRED,
                             &DestDcInfo );


    if ( NetStatus == 0 )
    {
        UpdateUi( IDS_INIT_LOOKUP_ACCOUNTS, 95 );

        if ( LookupAccountName( (PWSTR) DestDcInfo->DomainControllerAddress,
                                UserName,
                                Sid,
                                &SidLength,
                                RefDomain,
                                &RefDomainLength,
                                &NameUse )
                                )
        {
            if (_wcsicmp( RefDomain, DestDomain ) == 0 )
            {
                NewSid = Sid ;
            }
            else
            {
                Fail( NULL, TEXT("No account for user"), UserName, GetLastError(),
                        TEXT( "There is no account for you on the destination domain.  Please contact NUTS for an account." ) );
            }
        }
        else
        {
            Fail( NULL, TEXT("Can't look up account name"), TEXT(""), GetLastError(), NULL );
        }
    }
    else
    {
        Fail( NULL, TEXT("No DC available"), DestDomain, NetStatus,
                    TEXT("No Domain Controllers were available for the destination domain.  Please try again later."));
    }


    UpdateUi( IDS_INIT_LOOKUP_ACCOUNTS, 100 );

    return TRUE ;

}

VOID
Usage(
    VOID
    )
{
    wprintf( TEXT("Usage:\n"));
    wprintf( TEXT("\tmoveme DOMAINNAME\n"));

    exit( 0 );
}

VOID
DoArgs(
    int argc,
    WCHAR * argv[]
    )
{
    int i;
    PWSTR Scan;

    wcscpy( DestDomain, L"NTDEV");

    i = 1 ;

    while ( i < argc )
    {
        if ( (*argv[i] != L'-') &&
             (*argv[i] != L'/') )
        {
            wcscpy( DestDomain, argv[i] );
        }
        else
        {
            switch ( *(argv[i]+1) )
            {
                case L'F':
                case L'f':
                    MoveOptions |= MOVE_NO_UI ;
                    break;

                case L'D':
                case L'd':
                    MoveOptions |= MOVE_SOURCE_SUPPLIED ;

                    Scan = argv[i];
                    while ( *Scan && (*Scan != ':'))
                    {
                        Scan++;
                    }
                    if ( *Scan )
                    {
                        Scan++;
                        wcscpy( SourceDomain, Scan );
                    }
                    break;

                case L'P':
                case L'p':
                    if ( *(argv[i]+2) == L'-' )
                    {
                        MoveOptions &= ~MOVE_DO_PROFILE ;
                    }
                    else
                    {
                        MoveOptions |= MOVE_DO_PROFILE ;
                    }
                    break;

                case L'W':
                case L'w':
                    MoveOptions = MOVE_WHACK_PSTORE ;
                    break;

                default:
                    Usage();
            }
        }

        i++ ;
    }
}

BOOL
DoIt(
    HWND hDlg
    )
{

    RaiseUi( hDlg, L"Migrating User Information...");

    if ( MoveOptions & MOVE_DO_PROFILE )
    {
        MoveMe( hDlg, NULL, NULL );
    }

    if ( MoveOptions & MOVE_UPDATE_SECURITY )
    {
        DoSecurity( hDlg );
    }

    UpdateUi( 0, 100 );

    return TRUE ;
}

INT_PTR
WINAPI
PromptDlg(
    HWND hDlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam)
{
    WCHAR Buffer[ MAX_PATH ];

    switch ( Message )
    {
        case WM_INITDIALOG:

            MyIcon = LoadImage( GetModuleHandle(NULL),
                                MAKEINTRESOURCE( 1 ),
                                IMAGE_ICON,
                                64, 72,
                                LR_DEFAULTCOLOR );

            if ( MyIcon )
            {
                SendMessage( GetDlgItem( hDlg, IDD_MAIN_ICON ),
                             STM_SETICON,
                             (WPARAM) MyIcon, 0 );
            }
            swprintf( Buffer, TEXT("Account Domain:  %ws"), SourceDomain );
            SetDlgItemText( hDlg, IDD_DOMAIN_LINE, Buffer );

            swprintf( Buffer, TEXT("Machine Domain:  %ws"), MachDomain );
            SetDlgItemText( hDlg, IDD_WKSTA_DOMAIN, Buffer );

            swprintf( Buffer, TEXT("This tool will adjust a number of settings on your machine to move to the %ws domain."),
                            DestDomain );
            SetDlgItemText( hDlg, IDD_ABOUT, Buffer );

            CheckDlgButton( hDlg, IDD_RADIO_MAKECOPY, BST_CHECKED );

            if ( MoveOptions & MOVE_NO_PROFILE )
            {
                CheckDlgButton( hDlg, IDD_PROFILE_CHECK, BST_UNCHECKED );

                EnableSection( hDlg, FALSE, ProfileSection,
                                 sizeof( ProfileSection ) /sizeof(DWORD) );
            }
            else
            {
                CheckDlgButton( hDlg, IDD_PROFILE_CHECK, BST_CHECKED );
            }

            CheckDlgButton( hDlg, IDD_UPDATE_SEC, BST_CHECKED );
            EnableWindow( GetDlgItem( hDlg, IDD_UPDATE_SEC ), FALSE );

            //
            // If we're already there, forget it.
            //

            if ( _wcsicmp( MachDomain, DestDomain ) == 0 )
            {
                EnableWindow( GetDlgItem( hDlg, IDD_MOVE_MACHINE), FALSE );
            }

            //
            // If the domain already has a DS DC, forget it.
            //

            if ( DcInfo && DcInfo->Flags & DS_DS_FLAG )
            {
                EnableWindow( GetDlgItem( hDlg, IDD_MOVE_MACHINE), FALSE );
            }

            return FALSE ;

        case WM_COMMAND:
            switch (LOWORD( wParam ) )
            {
                case IDCANCEL:
                    EndDialog( hDlg, IDCANCEL );
                    break;

                case IDOK:
                    //
                    // Gather settings
                    //

                    if ( IsDlgButtonChecked( hDlg, IDD_PROFILE_CHECK ) == BST_CHECKED )
                    {
                        MoveOptions |= MOVE_DO_PROFILE ;

                        if ( IsDlgButtonChecked( hDlg, IDD_RADIO_MAKECOPY ) == BST_CHECKED )
                        {
                            MoveOptions |= MOVE_COPY_PROFILE ;
                        }

                        if ( IsDlgButtonChecked( hDlg, IDD_RADIO_MAKE_ROAM ) == BST_CHECKED )
                        {
                            MoveOptions |= MOVE_MAKE_ROAM ;
                        }
                    }

                    if ( IsDlgButtonChecked( hDlg, IDD_MOVE_MACHINE ) == BST_CHECKED )
                    {
                        MoveOptions |= MOVE_CHANGE_DOMAIN ;
                    }

                    if ( IsDlgButtonChecked( hDlg, IDD_UPDATE_SEC ) == BST_CHECKED )
                    {
                        MoveOptions |= MOVE_UPDATE_SECURITY ;
                    }

                    DumpState();

                    DoIt( hDlg );


                    EndDialog( hDlg, IDOK );
                    break;

                case IDD_PROFILE_CHECK:
                    if ( HIWORD( wParam ) == BN_CLICKED )
                    {
                        if ( IsDlgButtonChecked( hDlg, IDD_PROFILE_CHECK )
                                == BST_CHECKED )
                        {
                            EnableSection( hDlg,
                                           TRUE,
                                           ProfileSection,
                                           sizeof( ProfileSection ) / sizeof(DWORD) );
                        }
                        else
                        {
                            EnableSection( hDlg, FALSE, ProfileSection,
                                            sizeof( ProfileSection ) /sizeof(DWORD) );
                        }
                        return TRUE ;
                    }
                    break;


            }
            return TRUE ;

        default:
            return FALSE ;

    }
}

void
__cdecl
wmain (int argc, WCHAR *argv[])
{
    int Result ;
    NTSTATUS Status ;
    BOOLEAN WasEnabled ;

    VersionInfo.dwOSVersionInfoSize = sizeof( VersionInfo );
    GetVersionEx( (LPOSVERSIONINFOW) &VersionInfo );

#if DBG
    InitDebugSupport();
#endif
    InitCommonControls();

    DoArgs( argc, argv );

    CreateUiThread();

    if (!Initialize())
    {
        StopUiThread();

        ExitProcess( GetLastError() );
    }

    if ( MoveOptions & MOVE_WHACK_PSTORE )
    {
        DealWithPstore( NewSid );
    }

    if ( MoveOptions & MOVE_NO_UI )
    {
        MoveOptions |= MOVE_COPY_PROFILE | MOVE_UPDATE_SECURITY ;

        DoIt( NULL );
    }

    Result = (int)DialogBox( GetModuleHandle( NULL ),
                    MAKEINTRESOURCE( IDD_MAIN_DLG ),
                    NULL,
                    PromptDlg );

    if ( Result == IDOK )
    {
        Result = MessageBox( NULL, L"The changes require a reboot.  Reboot now?",
                    L"Move Tool",
                    MB_ICONINFORMATION | MB_YESNO );

        if ( Result == IDYES )
        {
            Status = RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                                         TRUE, FALSE,
                                         &WasEnabled );

            if ( NT_SUCCESS( Status ) )
            {
                ExitWindowsEx( EWX_FORCE | EWX_REBOOT, 0 );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\moveme\debug.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.c
//
//  Contents:   Debugging support functions
//
//  Classes:
//
//  Functions:
//
//  Note:       This file is not compiled for retail builds
//
//  History:    4-29-93   RichardW   Created
//
//----------------------------------------------------------------------------

#include "moveme.h"

#define ANSI
#include <stdarg.h>

#if DBG         // NOTE:  This file not compiled for retail builds



DEFINE_DEBUG2(MoveMe);
DEBUG_KEY   MoveMeDebugKeys[] = { {DEB_ERROR,            "Error"},
                                 {DEB_WARN,             "Warning"},
                                 {DEB_TRACE,            "Trace"},
                                 {DEB_TRACE_UI,         "UI"},
                                 {0, NULL},
                                 };


// Debugging support functions.

// These two functions do not exist in Non-Debug builds.  They are wrappers
// to the commnot functions (maybe I should get rid of that as well...)
// that echo the message to a log file.



//+---------------------------------------------------------------------------
//
//  Function:   InitDebugSupport
//
//  Synopsis:   Initializes debugging support for the SPMgr
//
//  Effects:
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void
InitDebugSupport(void)
{
    MoveMeInitDebug(MoveMeDebugKeys);

}




#else // DBG

#pragma warning(disable:4206)   // Disable the empty transation unit
                                // warning/error

#endif  // NOTE:  This file not compiled for retail builds
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\ksetup\support.cxx ===
/*++

  SUPPORT.CXX

  Copyright (C) 1999 Microsoft Corporation, all rights reserved.

  DESCRIPTION: support functions for ktpass

  Created, May 21, 1999 by DavidCHR.

  CONTENTS: ReadRegistryStrings

--*/  

#include "everything.hxx"

NTSTATUS
OpenLsa( VOID )
{
    OBJECT_ATTRIBUTES oa;
    NTSTATUS Status;
    UNICODE_STRING ServerString;

    RtlInitUnicodeString(
        &ServerString,
        ServerName
        );

    InitializeObjectAttributes(&oa,NULL,0,NULL,NULL);

    Status = LsaOpenPolicy(&ServerString,&oa,MAXIMUM_ALLOWED,&LsaHandle);
    return(Status);
}

NTSTATUS
OpenLocalLsa( OUT PLSA_HANDLE phLsa ) {

    static LSA_HANDLE hLsa = NULL;
    NTSTATUS          N    = STATUS_SUCCESS;

    if ( !hLsa ) {

      N = LsaConnectUntrusted( &hLsa );

      if ( !NT_SUCCESS( N ) ) {
        
        printf( "Failed to connect to the local LSA: 0x%x\n",
                N );
        
      }

    }

    if ( NT_SUCCESS( N ) ) {

      *phLsa = hLsa;

    } else {

      hLsa = NULL;

    }

    return N;

}
    



/*++**************************************************************
  NAME:      ReadActualPassword

  convenience routine for reading the password for a particular
  account.  Disables command line echo for the duration.

  MODIFIES:  Password  -- receives the new password

  TAKES:     Description -- descriptive string to insert
                            into prompts and error messages.
	     flags       -- see everything.h: 
	                    PROMPT_USING_POSSESSIVE_CASE
			    PROMPT_FOR_PASSWORD_TWICE

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LASTERROR: not set

  LOGGING:   printf on failure
  CREATED:   Apr 7, 1999
  LOCKING:   none
  CALLED BY: anyone
  FREE WITH: n/a -- no resources are allocated
  
  CONTENTS: CallAuthPackage

 **************************************************************--*/

BOOL
ReadActualPassword( IN  LPWSTR Description,
                    IN  ULONG  flags, 
                    OUT LPWSTR Password ) {

    HANDLE hConsole;
    DWORD  dwMode;
    BOOL   ret = FALSE;
    ULONG  Length;
    WCHAR  TempPassword[ MAX_PASSWD_LEN ];

    hConsole = GetStdHandle( STD_INPUT_HANDLE );
    
    if ( hConsole ) {

      // get the old console settings.

      if ( GetConsoleMode( hConsole,
                           &dwMode ) ) {

        // now turn off typing echo

        if ( SetConsoleMode( hConsole,
                             dwMode &~ ENABLE_ECHO_INPUT ) ) {

          fprintf( stderr,
                   ( flags & PROMPT_USING_POSSESSIVE_CASE ) ?
		   "Enter password for %ws: " :
		   "Enter %ws password: ",
                   Description );

          if ( !_getws( Password ) ) {

	    fprintf( stderr, 
		     "EOF on input.  Aborted.\n" );
	    
	    goto restoreConsoleMode;

	  }

	  if ( flags & PROMPT_FOR_PASSWORD_TWICE ) {

	    fprintf( stderr,
		     "\nNow re-enter password to confirm: " );
	    
	    if ( !_getws( TempPassword ) ) {

	      fprintf( stderr, 
		       "EOF on input.  Aborted.\n" );
	      
	      goto restoreConsoleMode;
	      
	    }
          
	  }

	  fprintf( stderr,
		   "\n" );

	  if ( flags & PROMPT_FOR_PASSWORD_TWICE ) {

	    // verify that the two passwords are the same.
	    
	    if ( wcscmp( Password,
			 TempPassword ) == 0 ) {
	      
	      ret = TRUE;
	      
	    } else {
	      
	      fprintf( stderr,
		       "Passwords do not match.\n" );
	      
	    }

	  } else {

	    ret = TRUE;

	  }

 restoreConsoleMode:
          // restore echo
	  
          SetConsoleMode( hConsole,
                          dwMode );
	  

        } else {

          fprintf( stderr, 
                   "Failed to disable line echo for password entry of %ws: 0x%x.\n",
                   Description,
                   GetLastError() );

        }
      } else {

        fprintf( stderr,
                 "Failed to retrieve current console settings: 0x%x\n",
                 GetLastError() );

      }

    } else {

      fprintf( stderr,
               "Failed to obtain console handle so we could disable line input echo: 0x%x\n",
               GetLastError() );

    }

    return ret;

}

/*++**************************************************************
  NAME:      ReadOptionallyStarredPassword

  if the given password is "*", read a new password from stdin.
  Otherwise, return the given password.

  MODIFIES:  pPassword -- receives the real password

  TAKES:     Password  -- password to check for *
             Description, flags -- as ReadActualPassword

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LASTERROR: not set

  LOGGING:   printf on failure
  CREATED:   Apr 7, 1999
  LOCKING:   none
  CALLED BY: anyone
  FREE WITH: free()
  
 **************************************************************--*/

BOOL
ReadOptionallyStarredPassword( IN  LPWSTR  InPassword,
                               IN  ULONG   flags,
                               IN  LPWSTR  Description,
                               OUT LPWSTR *pPassword ) {

    ULONG  Length;
    LPWSTR OutPass;
    BOOL   ReadPass;
    BOOL   ret = FALSE;

    Length = lstrlenW( InPassword );

    if ( ( 1 == Length ) &&
         ( L'*' == InPassword[ 0 ] ) ) {
      
      ReadPass = TRUE;
      Length   = MAX_PASSWD_LEN;
      
    } else {

      ReadPass = FALSE;
      
    }

    Length++; // null character
    Length *= sizeof( WCHAR );

    OutPass = (LPWSTR) malloc( Length );

    if ( OutPass != NULL ) {

      if ( ReadPass ) {

        ret = ReadActualPassword( Description,
                                  flags,
                                  OutPass );

      } else {

        lstrcpyW( OutPass,
                  InPassword );

        ret = TRUE;

      }

      if ( ret ) {

        *pPassword = OutPass;
        
      } else {

        free( OutPass );

      }
    } else {

      fprintf( stderr,
               "Failed to allocate memory for %ws password.\n",
               Description );

    }

    return ret;
}
        
/*++**************************************************************
  NAME:      CallAuthPackage

  convenience routine to centralize calls to LsaCallAuthentication
  Package.

  MODIFIES:  ppvOutput     -- data returned by LsaCallAuthPackage
             pulOutputSize -- returned size of that buffer

  TAKES:     pvData        -- submission data for that same api
             ulInputSize   -- sizeof the given buffer

  RETURNS:   a status code indicating success or failure
  LOGGING:   none
  CREATED:   Apr 13, 1999
  LOCKING:   none
  CALLED BY: anyone, most notably ChangeViaKpasswd
  FREE WITH: ppvOutput with LsaFreeReturnBuffer
  
 **************************************************************--*/

NTSTATUS
CallAuthPackage( IN  PVOID  pvData,
                 IN  ULONG  ulInputSize,
                 OUT PVOID *ppvOutput,
                 OUT PULONG pulOutputSize ) {

    // These are globals that are specific to this function. 

    static STRING     Name      = { 0 };
    static ULONG      PackageId = 0;
    static BOOL       NameSetup = FALSE;
    LSA_HANDLE        hLsa;
    NTSTATUS          N;

    if ( NT_SUCCESS( N = OpenLocalLsa( &hLsa ) ) ) {

      if ( !NameSetup ) {

        RtlInitString( &Name,
                       MICROSOFT_KERBEROS_NAME_A );

        N = LsaLookupAuthenticationPackage( hLsa,
                                            &Name,
                                            &PackageId );

        NameSetup = NT_SUCCESS( N );

      }

      if ( NT_SUCCESS( N ) ) {

        NTSTATUS SubStatus;

        N = LsaCallAuthenticationPackage( hLsa,
                                          PackageId,
                                          pvData,
                                          ulInputSize,
                                          ppvOutput,
                                          pulOutputSize,
                                          &SubStatus );

        if ( !NT_SUCCESS( N ) ||
             !NT_SUCCESS( SubStatus ) ) {

          printf( "CallAuthPackage failed, status 0x%x, substatus 0x%x.\n",
                  N, SubStatus );

        }

        if ( NT_SUCCESS( N ) ) {
          N = SubStatus;
          
        }
      }

    }

    return N;
}

VOID
InitStringAndMoveOn( IN     LPWSTR           RealString,
                     IN OUT LPWSTR          *pCursor,
                     IN OUT PUNICODE_STRING  pString ) {

    ULONG Length;

    Length = lstrlenW( RealString ) +1;

    memcpy( *pCursor,
            RealString,
            Length * sizeof( WCHAR ) );

    RtlInitUnicodeString( pString,
                          *pCursor );


    *pCursor += Length;

    // ASSERT( **pCursor == L'\0' );

}

    


NTSTATUS
ChangeViaKpasswd( LPWSTR * Parameters ) {

    LPWSTR                       OldPassword, NewPassword;
    NTSTATUS                     ret     = STATUS_UNSUCCESSFUL;
    PKERB_CHANGEPASSWORD_REQUEST pPasswd = NULL;
    LPWSTR                       Cursor;
    PVOID                        pvTrash;
    ULONG                        size, ulTrash;

    if ( !GlobalDomainSetting ) {

      printf( "Can't change password without /domain.\n" );
      ret = STATUS_INVALID_PARAMETER;

    } else if ( !( ReadOptionallyStarredPassword( Parameters[ 0 ],
                                                  0, // no flags
                                                  L"your old",
                                                  &OldPassword ) &&
                   
                   ReadOptionallyStarredPassword( Parameters[ 1 ],
						  PROMPT_FOR_PASSWORD_TWICE,
                                                  L"your new",
                                                  &NewPassword ) ) ) {

      printf( "Failed to validate passwords for password change.\n" );
      ret = STATUS_INTERNAL_ERROR;

    } else {

      size  = lstrlenW( GlobalDomainSetting ) + 1;
      size += lstrlenW( GlobalClientName ) + 1;
      size += lstrlenW( OldPassword ) + 1;
      size += lstrlenW( NewPassword ) + 1;

      // all strings above this line

      size *= sizeof( WCHAR );
      size += sizeof( *pPasswd ) ; // buffer

      pPasswd = (PKERB_CHANGEPASSWORD_REQUEST) malloc( size );

      if ( pPasswd ) {

        // start at the end of the password-request buffer
        
        Cursor = (LPWSTR) &( pPasswd[1] );

        pPasswd->MessageType = KerbChangePasswordMessage;

        InitStringAndMoveOn( GlobalDomainSetting,
                             &Cursor, 
                             &pPasswd->DomainName );

        InitStringAndMoveOn( GlobalClientName,
                             &Cursor, 
                             &pPasswd->AccountName );

        InitStringAndMoveOn( OldPassword,
                             &Cursor, 
                             &pPasswd->OldPassword );

        InitStringAndMoveOn( NewPassword,
                             &Cursor, 
                             &pPasswd->NewPassword );

        pPasswd->Impersonating = FALSE; // TRUE; // FALSE;

        ret = CallAuthPackage( pPasswd,
                               size,
                               (PVOID *) &pvTrash,
                               &ulTrash );

        if ( NT_SUCCESS( ret ) ) {

          printf( "Password changed.\n" );

        } else {

          printf( "Failed to change password: 0x%x\n",
                  ret );

        }

        // zero the buffer to minimize exposure of the password.

        memset( pPasswd,
                0,
                size );

        free( pPasswd );

      } else {

        printf( "Failed to allocate %ld-byte password change request.\n",
                size );

        ret = STATUS_NO_MEMORY;

      }

      // zero the buffers to minimize exposure of the passwords

      memset( NewPassword, 0, lstrlenW( NewPassword ) * sizeof( WCHAR ) );
      memset( OldPassword, 0, lstrlenW( OldPassword ) * sizeof( WCHAR ) );

      free( NewPassword );
      free( OldPassword );

    }

    return ret;

}




DWORD
OpenKerberosKey(
    OUT PHKEY KerbHandle
    )
{
    DWORD RegErr;
    HKEY ServerHandle = NULL;
    DWORD Disposition;

    RegErr = RegConnectRegistry(
                ServerName,
                HKEY_LOCAL_MACHINE,
                &ServerHandle
                );
    if (RegErr)
    {
        printf("Failed to connect to registry: %d (0x%x) \n",RegErr, RegErr);
        goto Cleanup;
    }

    RegErr = RegCreateKeyEx(
                ServerHandle,
                KERB_KERBEROS_KEY,
                0,
                NULL,
                0,              // no options
                KEY_CREATE_SUB_KEY,
                NULL,
                KerbHandle,
                &Disposition
                );
    if (RegErr)
    {
        printf("Failed to create Kerberos key: %d (0x%x)\n",RegErr, RegErr);
        goto Cleanup;
    }
Cleanup:
    if (ServerHandle)
    {
        RegCloseKey(ServerHandle);
    }
    return(RegErr);
}


DWORD
OpenSubKey( IN  LPWSTR * Parameters,
            OUT PHKEY    phKey ) {

    DWORD RegErr;
    HKEY KerbHandle = NULL;
    HKEY DomainHandle = NULL;
    HKEY DomainRoot = NULL;
    DWORD Disposition;
    LPWSTR OldServerNames = NULL;
    LPWSTR NewServerNames = NULL;
    ULONG OldKdcLength = 0;
    ULONG NewKdcLength = 0;
    ULONG Type;

    RegErr = OpenKerberosKey(&KerbHandle);

    if ( RegErr == ERROR_SUCCESS ) 
    {
	RegErr = RegCreateKeyEx( KerbHandle,
				 KERB_DOMAINS_SUBKEY,
				 0,
				 NULL,
				 0,              // no options
				 KEY_CREATE_SUB_KEY,
				 NULL,
				 &DomainRoot,
				 &Disposition );

	if ( RegErr == ERROR_SUCCESS ) 
	{
	    if ( Parameters && Parameters[ 0 ] ) 
	    {
		RegErr = RegCreateKeyEx(  DomainRoot,
					  Parameters[0],
					  0,
					  NULL,
					  0,              // no options
					  KEY_CREATE_SUB_KEY | KEY_SET_VALUE | KEY_QUERY_VALUE,
					  NULL,
					  &DomainHandle,
					  &Disposition );

		if ( RegErr == ERROR_SUCCESS ) 
		{
		    *phKey = DomainHandle;
		} 
		else 
		{
		    printf("Failed to create %ws key: 0x%x\n", Parameters[ 0 ], RegErr);          
		}
        
		RegCloseKey( DomainRoot );

	    } 
	    else /* return the domain root if no domain is requested. */         
	    { 
		*phKey = DomainRoot;         
	    }        
	} 
	else 
	{        
	    printf( "Failed to create key %ws: 0x%x\n", Parameters[ 0 ], RegErr );
	}

	RegCloseKey( KerbHandle );
      
    } 
    else 
    {
	printf( "Failed to open Kerberos Key: 0x%x\n", RegErr );
    }

    return RegErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\moveme\moveme.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       moveme.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5-21-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __MOVEME_H__
#define __MOVEME_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>

#include <windows.h>
#include <commctrl.h>
#include <userenv.h>
#include <userenvp.h>

#include <lm.h>
#include <dsgetdc.h>
#include <lmjoin.h>
#include <stdio.h>
#include <string.h>
#include <wchar.h>

#include "debug.h"
#include "strings.h"

#define MOVE_CHANGE_DOMAIN  0x00000001
#define MOVE_COPY_PROFILE   0x00000002
#define MOVE_DO_PROFILE     0x00000004
#define MOVE_UPDATE_SECURITY 0x00000008
#define MOVE_MAKE_ROAM      0x00000010
#define MOVE_NO_UI          0x80000000
#define MOVE_SOURCE_SUPPLIED 0x40000000
#define MOVE_NO_PROFILE     0x20000000
#define MOVE_WHACK_PSTORE   0x10000000

extern DWORD MoveOptions ;


BOOL
WINAPI
GetUserProfileDirectoryFromSid(
    PSID Sid,
    LPTSTR lpProfileDir,
    LPDWORD lpcchSize
    );

BOOL
CreateUiThread(
    VOID
    );


VOID
StopUiThread(
    VOID
    );

VOID
RaiseUi(
    HWND Parent,
    LPWSTR Title
    );

VOID
UpdateUi(
    DWORD   StringId,
    DWORD   Percentage
    );

LONG
MyRegSaveKey(
    HKEY Key,
    LPTSTR File,
    LPSECURITY_ATTRIBUTES lpsa
    );

BOOL
GetPrimaryDomain(
    PWSTR Domain
    );

BOOL
SetUserProfileDirectory(
    PSID Base,
    PSID Copy
    );

VOID
Fail(
    HWND hWnd,
    PWSTR Failure,
    PWSTR Description,
    DWORD Code,
    PWSTR Message
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\moveme\moveui.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       moveui.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5-21-97   RichardW   Created
//
//----------------------------------------------------------------------------


#include "moveme.h"
#include "dialogs.h"

typedef enum _UI_THREAD_STATE {
    ThreadBlock,
    ThreadRunUi,
    ThreadExit
} UI_THREAD_STATE ;

typedef struct _UI_THREAD_INFO {
    HWND    hWnd ;
    HANDLE  UiWait ;
    HANDLE  CallerWait ;
    UI_THREAD_STATE State ;
    ULONG   CurrentString ;
    ULONG   Flags ;
    ULONG   Percentage ;
    PWSTR   Title ;
} UI_THREAD_INFO ;

#define WM_READSTATE    WM_USER + 1

UI_THREAD_INFO UiThreadInfo ;
HINSTANCE Module ;


INT_PTR
CALLBACK
FeedbackDlg(
    HWND hDlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    WCHAR Text[ MAX_PATH ];

    switch ( Message )
    {
        case WM_COMMAND:
            break;

        case WM_INITDIALOG:

            UiThreadInfo.hWnd = hDlg ;

            SetWindowText( hDlg, UiThreadInfo.Title );

            SetDlgItemText( hDlg, IDD_MIGRATING_TEXT, L"" );

            SendMessage( GetDlgItem( hDlg, IDD_MIGRATING_PROGRESS ),
                         PBM_SETSTEP, (WPARAM) 1, 0 );

            SetEvent( UiThreadInfo.CallerWait );

            return TRUE ;

        case WM_READSTATE:
            LoadString( Module, UiThreadInfo.CurrentString, Text, MAX_PATH );
            SetDlgItemText( hDlg, IDD_MIGRATING_TEXT, Text );

            SendMessage( GetDlgItem( hDlg, IDD_MIGRATING_PROGRESS ),
                         PBM_SETPOS, (WPARAM) UiThreadInfo.Percentage, 0 );

            UpdateWindow( GetDlgItem( hDlg, IDD_MIGRATING_PROGRESS ) );
            UpdateWindow( hDlg );

            return TRUE ;

        default:
            break;
    }

    return FALSE ;
}


DWORD
UiThread(
    PVOID Ignored
    )
{
    DebugLog(( DEB_TRACE_UI, "UI Thread starting\n" ));

    SetEvent( UiThreadInfo.CallerWait );

    while ( 1 )
    {
        DebugLog(( DEB_TRACE_UI, "State = %d\n", UiThreadInfo.State ));

        if ( UiThreadInfo.State == ThreadBlock )
        {
            WaitForSingleObjectEx( UiThreadInfo.UiWait, INFINITE, FALSE );
            continue;
        }

        if ( UiThreadInfo.State == ThreadExit )
        {
            ExitThread( 0 );
        }

        if ( UiThreadInfo.State == ThreadRunUi )
        {
            DialogBox( Module,
                       MAKEINTRESOURCE( IDD_MIGRATING ),
                       NULL,
                       FeedbackDlg );

            ResetEvent( UiThreadInfo.UiWait );

            UiThreadInfo.State = ThreadBlock ;
        }
    }

    return 0;
}



BOOL
CreateUiThread(
    VOID
    )
{
    HANDLE hThread ;
    DWORD Tid ;

    if ( MoveOptions & MOVE_NO_UI )
    {
        return TRUE ;
    }

    Module = GetModuleHandle( NULL );

    ZeroMemory( &UiThreadInfo, sizeof( UiThreadInfo ) );

    UiThreadInfo.UiWait = CreateEvent( NULL, FALSE, FALSE, NULL );
    UiThreadInfo.CallerWait = CreateEvent( NULL, FALSE, FALSE, NULL );

    UiThreadInfo.State = ThreadBlock ;

    hThread = CreateThread( NULL, 0,
                    UiThread, 0,
                    0, &Tid );

    if ( hThread )
    {
        CloseHandle( hThread );

        WaitForSingleObjectEx( UiThreadInfo.CallerWait, INFINITE, FALSE );

        return TRUE ;
    }

    return FALSE ;

}

VOID
StopUiThread(
    VOID
    )
{
    if ( MoveOptions & MOVE_NO_UI )
    {
        return ;
    }

    if ( UiThreadInfo.State == ThreadRunUi )
    {
        SendMessage( UiThreadInfo.hWnd, WM_CLOSE, 0, 0 );
    }

    UiThreadInfo.State = ThreadExit ;

    SetEvent( UiThreadInfo.UiWait );
}

VOID
RaiseUi(
    HWND Parent,
    LPWSTR Title
    )
{
    if ( MoveOptions & MOVE_NO_UI )
    {
        return;
    }
    UiThreadInfo.State = ThreadRunUi ;
    UiThreadInfo.Title = Title ;

    DebugLog(( DEB_TRACE_UI, "Raise:  State = %d, pulsing event\n",
                UiThreadInfo.State ));

    ResetEvent( UiThreadInfo.CallerWait );
    SetEvent( UiThreadInfo.UiWait );

    WaitForSingleObjectEx( UiThreadInfo.CallerWait, INFINITE, FALSE );

}

VOID
UpdateUi(
    DWORD   StringId,
    DWORD   Percentage
    )
{
    if ( MoveOptions & MOVE_NO_UI )
    {
        return;
    }
    if ( UiThreadInfo.State == ThreadRunUi )
    {
        UiThreadInfo.CurrentString = StringId ;
        UiThreadInfo.Percentage = Percentage ;

        SendMessage( UiThreadInfo.hWnd, WM_READSTATE, 0, 0 );

    }

    if ( Percentage == 100 )
    {
        EndDialog( UiThreadInfo.hWnd, IDOK );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\syskey\makefile.inc ===
res.rc: dialogs.dlg strings.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\moveme\strings.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       strings.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5-21-97   RichardW   Created
//
//----------------------------------------------------------------------------

#define IDS_COPYING_USER_HIVE       1001
#define IDS_CREATING_NEW_PROFILE    1002
#define IDS_COPYING_OLD_PROFILE     1003

#define IDS_INIT_READ_NAMES         1010
#define IDS_INIT_DISCOVER_DCS       1011
#define IDS_INIT_LOOKUP_ACCOUNTS    1012

#define IDS_MOVE_DOMAIN             1020

#define IDS_SEC_LOCAL_SETTINGS      1030
#define IDS_SEC_LOCAL_ADMIN         1031
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\syskey\miscid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       miscid.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-19-97   RichardW   Created
//
//----------------------------------------------------------------------------

#define LOCK_ICON   1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\syskey\dialogs.h ===
#define IDD_MAIN_DIALOG             100
#define IDD_MAIN_ICON               101
#define IDD_MAIN_TEXT_1             102
#define IDD_MAIN_TEXT_2             103
#define IDD_MAIN_DISABLED           104
#define IDD_MAIN_ENABLED            105
#define IDD_MAIN_UPDATE             106
#define IDD_PASSWORD_DLG            200
#define IDD_PW_GROUP_1              201
#define IDD_PW_PASSWORD_BTN         202
#define IDD_PW_PW_TEXT              203
#define IDD_PW_PW_LABEL             204
#define IDD_PW_PASSWORD             205
#define IDD_PW_CONFIRM_LABEL        206
#define IDD_PW_CONFIRM              207
#define IDD_PW_GROUP_2              208
#define IDD_PW_AUTO                 209
#define IDD_PW_FLOPPY               210
#define IDD_PW_STORE_LOCAL          211
#define IDD_PW_FLOPPY_TEXT          212
#define IDD_PW_LOCAL_TEXT           213

#define IDD_SECURE_BOOT             900
#define IDD_SB_TEXT_1               901
#define IDD_SB_PW_LABEL             902
#define IDD_SB_PASSWORD             903
#define IDD_SB_PW_ICON              904
#define IDD_SECURE_BOOT_DISK        910
#define IDD_SB_DISK_TEXT            911
#define IDD_SB_DISK_TEXT2           912
#define IDD_SB_DISK_ICON            913

#define IDD_SB_ICON_PW              920
#define IDD_SB_ICON_DISK            921
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\stampdns\stampdns.c ===
/*--

Copyright (c) 1997-1997  Microsoft Corporation

Module Name:

    trustdom.c

Abstract:

    Command line tool for linking 2 domains

Author:

    1-Apr-1997   Mac McLain (macm)   Created

Environment:

    User mode only.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntlsa.h>
#include <stdio.h>
#include <stdlib.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <dnsapi.h>

#define PARENT_TAG "-parent:"
#define PARENT_TAG_LEN  (sizeof( PARENT_TAG ) - 1)

typedef struct _TD_DOM_INFO {

    LSA_HANDLE Policy;
    LSA_HANDLE TrustedDomain;
    PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo;

} TD_DOM_INFO, *PTD_DOM_INFO;

BOOLEAN Dbg = FALSE;

VOID
Usage (
    VOID
    )
/*++

Routine Description:

    Displays the expected usage

Arguments:

Return Value:

    VOID

--*/
{
    printf("stampdns [dns_domain_name] [-parent:parent_server_name]\n");
}


NTSTATUS
GetDomainInfoForDomain(
    IN PWSTR    DomainName,
    IN PTD_DOM_INFO Info
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD dwErr;
    UNICODE_STRING Domain;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PDOMAIN_CONTROLLER_INFO DCInfo = NULL;

    if ( DomainName != NULL ) {

        dwErr = DsGetDcName( NULL, (LPCWSTR)DomainName, NULL, NULL,
                             DS_DIRECTORY_SERVICE_REQUIRED, &DCInfo );

        if ( dwErr == ERROR_SUCCESS ) {

            RtlInitUnicodeString( &Domain, DCInfo->DomainControllerName + 2 );

        } else {

            Status = STATUS_UNSUCCESSFUL;

        }

    }

    if ( NT_SUCCESS( Status ) ) {

        RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

        Status = LsaOpenPolicy( DomainName == NULL ? NULL : &Domain,
                                &ObjectAttributes,
                                MAXIMUM_ALLOWED,
                                &Info->Policy
                                );

        if ( NT_SUCCESS( Status ) ) {

            Status = LsaQueryInformationPolicy( Info->Policy,
                                                PolicyDnsDomainInformation,
                                                &(Info->DnsDomainInfo )
                                                );

        }

    #if DBG
        if ( Dbg ) {

            printf( "GetDomainInfoForDomain on %ws returned 0x%lx\n", DomainName, Status );
        }
    #endif

    }

    NetApiBufferFree( DCInfo );

    return( Status );
}


VOID
FreeDomainInfo(
    IN PTD_DOM_INFO Info
    )
{
    if ( Info->DnsDomainInfo != NULL ) {

        LsaFreeMemory( Info->DnsDomainInfo );
    }

    if ( Info->Policy ) {

        LsaClose( Info->Policy );
    }

}


INT
__cdecl main (
    int argc,
    char *argv[])
/*++

Routine Description:

    The main the for this executable

Arguments:

    argc - Count of arguments
    argv - List of arguments

Return Value:

    VOID

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    WCHAR  Buffer[MAX_PATH + 1];
    PWSTR  Server = NULL, DnsName = NULL;
    INT i;
    TD_DOM_INFO Local, Remote;


    RtlZeroMemory( &Local, sizeof( TD_DOM_INFO ) );
    RtlZeroMemory( &Remote, sizeof (TD_DOM_INFO ) );

    if (argc < 2 ) {

        Usage();
        goto Done;

    } else {

        if ( _stricmp( argv[1], "-?") == 0 ) {

            Usage();
            goto Done;

        } else {

            if ( _strnicmp( argv[1], PARENT_TAG, PARENT_TAG_LEN ) == 0 ) {

                mbstowcs( Buffer, argv[1] + PARENT_TAG_LEN , strlen( argv[1] ) - PARENT_TAG_LEN + 1 );
                Server = Buffer;

            } else {

                mbstowcs(Buffer, argv[1], strlen(argv[1]) + 1 );
                DnsName = Buffer;

            }


        }
    }


    Status = GetDomainInfoForDomain( NULL, &Local );

    if ( NT_SUCCESS( Status ) && Server ) {

        Status = GetDomainInfoForDomain( Server, &Remote );
    }

    if ( !NT_SUCCESS( Status ) ) {

        goto Done;
    }

    if ( DnsName ) {

        RtlInitUnicodeString( &Local.DnsDomainInfo->DnsForestName, DnsName );
        RtlInitUnicodeString( &Local.DnsDomainInfo->DnsDomainName, DnsName );

    } else {

        RtlCopyMemory( &Local.DnsDomainInfo->DnsForestName, &Remote.DnsDomainInfo->DnsForestName,
                       sizeof( UNICODE_STRING ) );
    }

    Status = DnsValidateDnsName_W(Local.DnsDomainInfo->DnsForestName.Buffer );
    if ( Status != 0 ) {

        printf( "Stampdns required a valid Dns name.  %wZ is not a valid Dns name\n",
                &Local.DnsDomainInfo->DnsForestName );

    } else {

        printf( "Setting DnsForestName to %wZ\n", &Local.DnsDomainInfo->DnsForestName );
        Status = LsaSetInformationPolicy( Local.Policy,
                                          PolicyDnsDomainInformation,
                                          Local.DnsDomainInfo );

    }

Done:

    FreeDomainInfo( &Local );
    FreeDomainInfo( &Remote );

    if( NT_SUCCESS( Status ) ) {

        printf("The command completed successfully\n");

    } else {

        printf("The command failed with an error 0x%lx\n", Status );

    }

    return( NT_SUCCESS( Status ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\syskey\rng.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 

VOID
STInitializeRNG(VOID);

VOID
STShutdownRNG(VOID);


VOID
STGenerateRandomBits(
    PUCHAR      pRandomData,
    ULONG       cRandomData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\moveme\util.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       util.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5-21-97   RichardW   Created
//
//----------------------------------------------------------------------------




#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>

#include <windows.h>
#include <userenv.h>
#include <userenvp.h>

#include <lm.h>
#include "moveme.h"


#define USER_SHELL_FOLDER         TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders")
#define PROFILE_LIST_PATH         TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList")
#define PROFILE_FLAGS             TEXT("Flags")
#define PROFILE_STATE             TEXT("State")
#define PROFILE_IMAGE_VALUE_NAME  TEXT("ProfileImagePath")
#define PROFILE_CENTRAL_PROFILE   TEXT("CentralProfile")
#define CONFIG_FILE_PATH          TEXT("%SystemRoot%\\Profiles\\")
#define USER_PREFERENCE           TEXT("UserPreference")
#define PROFILE_BUILD_NUMBER      TEXT("BuildNumber")
#define TEMP_PROFILE_NAME_BASE    TEXT("TEMP")
#define DELETE_ROAMING_CACHE      TEXT("DeleteRoamingCache")
#define USER_PROFILE_MUTEX        TEXT("userenv:  User Profile Mutex")

LPTSTR
SidToString(
    PSID Sid
    )
{
    UNICODE_STRING String ;
    NTSTATUS Status ;

    Status = RtlConvertSidToUnicodeString( &String, Sid, TRUE );

    if ( NT_SUCCESS( Status ) )
    {
        return String.Buffer ;
    }
    return NULL ;

}

VOID
FreeSidString(
    LPTSTR SidString
    )
{
    UNICODE_STRING String ;

    RtlInitUnicodeString( &String, SidString );

    RtlFreeUnicodeString( &String );
}

//*************************************************************
//
//  GetUserProfileDirectory()
//
//  Purpose:    Returns the root of the user's profile directory.
//
//  Parameters: hToken          -   User's token
//              lpProfileDir    -   Output buffer
//              lpcchSize       -   Size of output buffer
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   If false is returned, lpcchSize holds the number of
//              characters needed.
//
//  History:    Date        Author     Comment
//              9/18/95     ericflo    Created
//
//*************************************************************

BOOL
WINAPI
GetUserProfileDirectoryFromSid(
    PSID Sid,
    LPTSTR lpProfileDir,
    LPDWORD lpcchSize
    )
{
    DWORD  dwLength = MAX_PATH * sizeof(TCHAR);
    DWORD  dwType;
    BOOL   bRetVal = FALSE;
    LPTSTR lpSidString;
    TCHAR  szBuffer[MAX_PATH];
    TCHAR  szDirectory[MAX_PATH];
    HKEY   hKey;
    LONG   lResult;


    //
    // Retrieve the user's sid string
    //

    lpSidString = SidToString( Sid );

    if (!lpSidString) {
        return FALSE;
    }


    //
    // Check the registry
    //

    lstrcpy(szBuffer, PROFILE_LIST_PATH);
    lstrcat(szBuffer, TEXT("\\"));
    lstrcat(szBuffer, lpSidString);

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuffer, 0, KEY_READ,
                           &hKey);

    if (lResult != ERROR_SUCCESS) {
        FreeSidString(lpSidString);
        return FALSE;
    }

    lResult = RegQueryValueEx(hKey,
                              PROFILE_IMAGE_VALUE_NAME,
                              NULL,
                              &dwType,
                              (LPBYTE) szBuffer,
                              &dwLength);

    if (lResult != ERROR_SUCCESS) {
        RegCloseKey (hKey);
        FreeSidString(lpSidString);
        return FALSE;
    }


    //
    // Clean up
    //

    RegCloseKey(hKey);
    FreeSidString(lpSidString);



    //
    // Expand and get the length of string
    //

    ExpandEnvironmentStrings(szBuffer, szDirectory, MAX_PATH);

    dwLength = lstrlen(szDirectory) + 1;


    //
    // Save the string if appropriate
    //

    if (lpProfileDir) {

        if (*lpcchSize >= dwLength) {
            lstrcpy (lpProfileDir, szDirectory);
            bRetVal = TRUE;

        } else {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    }


    *lpcchSize = dwLength;

    return bRetVal;
}

BOOL
SetUserProfileDirectory(
    PSID Base,
    PSID Copy
    )
{
    LPTSTR lpSidString;
    TCHAR  szBuffer[MAX_PATH];
    HKEY   hKey;
    HKEY   hNewKey ;
    LONG   lResult;
    DWORD  Disp ;
    WCHAR  CopyBuffer[ MAX_PATH ] ;
    DWORD  CopySize ;
    DWORD ValueCount ;
    DWORD ValueNameLen ;
    DWORD ValueDataLen ;
    PUCHAR Value ;
    DWORD Type ;
    DWORD Index ;
    DWORD NameSize ;
    //
    // Retrieve the user's sid string
    //

    lpSidString = SidToString( Base );

    if (!lpSidString) {
        return FALSE;
    }


    //
    // Check the registry
    //

    lstrcpy(szBuffer, PROFILE_LIST_PATH);
    lstrcat(szBuffer, TEXT("\\"));
    lstrcat(szBuffer, lpSidString);

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuffer, 0, KEY_READ,
                           &hKey);

    FreeSidString( lpSidString );

    if ( lResult != 0 )
    {
        return FALSE ;
    }


    //
    // Retrieve the user's sid string
    //

    lpSidString = SidToString( Copy );

    if (!lpSidString) {
        return FALSE;
    }


    //
    // Check the registry
    //

    lstrcpy(szBuffer, PROFILE_LIST_PATH);
    lstrcat(szBuffer, TEXT("\\"));
    lstrcat(szBuffer, lpSidString);

    lResult = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                              szBuffer,
                              0,
                              TEXT(""),
                              REG_OPTION_NON_VOLATILE,
                              KEY_READ | KEY_WRITE,
                              NULL,
                              &hNewKey,
                              &Disp );


    FreeSidString( lpSidString );

    if ( lResult != 0 )
    {
        return FALSE ;
    }

    //
    // Copy Key:
    //

    lResult = RegQueryInfoKey( hKey,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               &ValueCount,
                               &ValueNameLen,
                               &ValueDataLen,
                               NULL,
                               NULL );

    if ( lResult != 0 )
    {
        return FALSE ;
    }

    Value = LocalAlloc( LMEM_FIXED, ValueDataLen );

    if ( Value )
    {
        Index = 0 ;

        do
        {
            CopySize = ValueDataLen ;
            NameSize = MAX_PATH ;

            lResult = RegEnumValue( hKey,
                                    Index,
                                    CopyBuffer,
                                    &NameSize,
                                    NULL,
                                    &Type,
                                    Value,
                                    &CopySize );

            if ( lResult == 0 )
            {
                lResult = RegSetValueEx( hNewKey,
                                         CopyBuffer,
                                         0,
                                         Type,
                                         Value,
                                         CopySize );
            }

            ValueCount-- ;
            Index ++ ;

        } while ( ValueCount );

        LocalFree( Value );

    }

    lResult = RegSetValueEx( hNewKey,
                             TEXT("Sid"),
                             0,
                             REG_BINARY,
                             Copy,
                             RtlLengthSid( Copy )
                             );

    if (lResult == 0) {
        return TRUE;
    } else {
        return FALSE;
    }
}

LONG
MyRegSaveKey(
    HKEY Key,
    LPTSTR File,
    LPSECURITY_ATTRIBUTES lpsa
    )
{
    BOOL bResult = TRUE;
    LONG error;
    NTSTATUS Status;
    BOOLEAN WasEnabled;


    //
    // Enable the restore privilege
    //

    Status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, TRUE, FALSE, &WasEnabled);

    if (NT_SUCCESS(Status))
    {
        error = RegSaveKey( Key, File, lpsa );

        Status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);
    }
    else
    {
        error = RtlNtStatusToDosError( Status );
    }

    return error ;

}

BOOL
GetPrimaryDomain(
    PWSTR Domain
    )
{
    NTSTATUS Status, IgnoreStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE LsaHandle;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo;
    BOOL    PrimaryDomainPresent = FALSE;

    //
    // Set up the Security Quality Of Service
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes to open the Lsa policy object
    //

    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0L,
                               (HANDLE)NULL,
                               NULL);
    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    //
    // Open the local LSA policy object
    //

    Status = LsaOpenPolicy( NULL,
                            &ObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &LsaHandle
                          );
    if (!NT_SUCCESS(Status)) {
        DebugLog((DEB_ERROR, "Failed to open local LsaPolicyObject, Status = 0x%lx\n", Status));
        return(FALSE);
    }

    //
    // Get the primary domain info
    //
    Status = LsaQueryInformationPolicy(LsaHandle,
                                       PolicyPrimaryDomainInformation,
                                       (PVOID *)&PrimaryDomainInfo);
    if (!NT_SUCCESS(Status)) {
        DebugLog((DEB_ERROR, "Failed to query primary domain from Lsa, Status = 0x%lx\n", Status));

        IgnoreStatus = LsaClose(LsaHandle);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        return(FALSE);
    }

    //
    // Copy the primary domain name into the return string
    //

    if (PrimaryDomainInfo->Sid != NULL) {

        PrimaryDomainPresent = TRUE;

        if ( Domain )
        {
            CopyMemory( Domain, PrimaryDomainInfo->Name.Buffer,
                        PrimaryDomainInfo->Name.Length + 2 );

        }
    }

    //
    // We're finished with the Lsa
    //

    IgnoreStatus = LsaFreeMemory(PrimaryDomainInfo);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    IgnoreStatus = LsaClose(LsaHandle);
    ASSERT(NT_SUCCESS(IgnoreStatus));


    return(PrimaryDomainPresent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\setspn\setspn.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       setspn.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    7-30-98   RichardW   Created
//		8-10-99   JBrezak    Turned into setspn added list capability
//              09-22-99  Jaroslad   support for adding/removing arbitrary SPNs
//
//----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#define SECURITY_WIN32
#include <rpc.h>
#include <sspi.h>
#include <secext.h>
#include <lm.h>
#include <winsock2.h>
#include <dsgetdc.h>
#include <dsgetdcp.h>
#include <ntdsapi.h>
#include <ntdsapip.h>	// private DS_NAME_FORMATS
#include <stdio.h>
#include <winldap.h>
#include <shlwapi.h>

DWORD debug = 0;

BOOL AddSpn(PWSTR Service, PWSTR Server);

BOOL
FindDomainForAccount(
    PWSTR Server,
    PWSTR DomainToCheck,
    PWSTR Domain,
    PWSTR DC
    )
{
    ULONG NetStatus ;
    PDOMAIN_CONTROLLER_INFO DcInfo ;
    WCHAR LocalServerName[ 64 ];

    wcsncpy( LocalServerName, Server, 63 );
    wcscat( LocalServerName, L"$" );

    NetStatus = DsGetDcNameWithAccountW(
                    NULL,
                    LocalServerName,
                    UF_ACCOUNT_TYPE_MASK,
                    DomainToCheck,
                    NULL,
                    NULL,
                    DS_DIRECTORY_SERVICE_REQUIRED |
                        DS_RETURN_FLAT_NAME,
                    &DcInfo );

    if ( NetStatus == 0 )
    {
	wcscat( Server, L"$" );
	wcscpy( Domain, DcInfo->DomainName );

	if (DC)
        {
            wcscpy( DC, &DcInfo->DomainControllerName[2] );

        }

        NetApiBufferFree( DcInfo );

        return TRUE ;
    }

    NetStatus = DsGetDcNameWithAccountW(
                    NULL,
                    Server,
                    UF_ACCOUNT_TYPE_MASK,
                    DomainToCheck,
                    NULL,
                    NULL,
                    DS_DIRECTORY_SERVICE_REQUIRED |
                        DS_RETURN_FLAT_NAME,
                    &DcInfo );

    if ( NetStatus == 0 )
    {
        wcscpy( Domain, DcInfo->DomainName );

	if (DC)
        {
            wcscpy( DC, &DcInfo->DomainControllerName[2] );

        }

        NetApiBufferFree( DcInfo );

        return TRUE ;
    }

    return FALSE ;

}

BOOL
AddHostSpn(
    PWSTR Server
    )
{
    return (AddSpn(L"HOST", Server));
}


BOOL
AddSpn(
    PWSTR Service,
    PWSTR Server
    )
{
    WCHAR HostSpn[ 64 ];
    WCHAR FlatSpn[ 64 ];
    WCHAR Domain[ MAX_PATH ];
    WCHAR FlatName[ 64 ];
    HANDLE hDs ;
    ULONG NetStatus ;
    PDS_NAME_RESULT Result ;
    LPWSTR Flat = FlatName;
    LPWSTR Spns[2];
    WCHAR LocalServerName[ 64 ];

    wcsncpy( LocalServerName, Server, sizeof(LocalServerName)/sizeof(LocalServerName[0]) );
    
    if ( !FindDomainForAccount( LocalServerName, L"", Domain, NULL ))
    {
        fprintf(stderr, 
		"Could not find account %ws\n", LocalServerName );
        return FALSE;
    }

    wcscpy( FlatName, Domain );
    wcscat( FlatName, L"\\" );
    wcscat( FlatName, LocalServerName );

    NetStatus = DsBind( NULL, Domain, &hDs );

    if ( NetStatus != 0 )
    {
        fprintf(stderr,
		"Failed to bind to DC of domain %ws, %#x\n", 
		Domain, NetStatus );
        return FALSE ;
    }

    NetStatus = DsCrackNames(
                    hDs,
                    0,
                    DS_NT4_ACCOUNT_NAME,
                    DS_FQDN_1779_NAME,
                    1,
                    &Flat,
                    &Result );

    if ( NetStatus != 0 ||
	 Result->rItems[0].status != DS_NAME_NO_ERROR ||
	 Result->cItems != 1)
    {
	fprintf(stderr,
		"Failed to crack name %ws into the FQDN, (%d) %d %#x\n",
		FlatName, NetStatus, Result->cItems,
		(Result->cItems==1)?Result->rItems[0].status:-1 );

        DsUnBind( &hDs );

        return FALSE ;
    }

    wsprintf( HostSpn, L"%s/%s.%s", Service, Server, Domain );
    wsprintf( FlatSpn, L"%s/%s", Service, Server );
    Spns[0] = HostSpn;
    Spns[1] = FlatSpn;
    
    printf("Registering ServicePrincipalNames for %ws\n",
	   Result->rItems[0].pName);
    printf("\t%ws\n", HostSpn);
    printf("\t%ws\n", FlatSpn);

#if 0
    printf("DsWriteAccountSpn: Commented out\n");
#else
    NetStatus = DsWriteAccountSpn(
                    hDs,
                    DS_SPN_ADD_SPN_OP,
                    Result->rItems[0].pName,
                    2,
                    Spns );


    if ( NetStatus != 0 )
    {
        fprintf(stderr,
		"Failed to assign SPN to account '%ws', %#x\n",
		Result->rItems[0].pName, NetStatus );
	return FALSE;
    }
#endif
    DsFreeNameResult( Result );

    DsUnBind( &hDs );

    return NetStatus == 0 ;
}

// added by jaroslad on 09/22/99
BOOL
AddRemoveSpn(
    PWSTR HostSpn,
    PWSTR HostDomain,
    PWSTR Server,
    DS_SPN_WRITE_OP Operation

)
{
    WCHAR FlatSpn[ MAX_PATH ];
    WCHAR Domain[ MAX_PATH ];
    WCHAR FlatName[ MAX_PATH ];
    HANDLE hDs ;
    ULONG NetStatus ;
    PDS_NAME_RESULT Result ;
    LPWSTR Flat = FlatName;
    LPWSTR Spns[2];
    
    if ( !FindDomainForAccount( Server, HostDomain, Domain, NULL ))
    {
        fprintf(stderr,
		"Unable to locate account %ws\n", Server);
        return FALSE ;
    }

    wcscpy( FlatName, Domain );
    wcscat( FlatName, L"\\" );
    wcscat( FlatName, Server );

    NetStatus = DsBind( NULL, Domain, &hDs );
    if ( NetStatus != 0 )
    {
        fprintf(stderr,
		"Failed to bind to DC of domain %ws, %#x\n", 
		Domain, NetStatus );
        return FALSE ;
    }

    NetStatus = DsCrackNames(
                    hDs,
                    0,
                    DS_NT4_ACCOUNT_NAME,
                    DS_FQDN_1779_NAME,
                    1,
                    &Flat,
                    &Result );

    if ( NetStatus != 0 ||
	 Result->rItems[0].status != DS_NAME_NO_ERROR ||
	 Result->cItems != 1)
    {
	fprintf(stderr,
		"Failed to crack name %ws into the FQDN, (%d) %d %#x\n",
		FlatName, NetStatus, Result->cItems,
		(Result->cItems==1)?Result->rItems[0].status:-1 );

        DsUnBind( &hDs );

        return FALSE ;
    }

    Spns[0] = HostSpn;
    
    printf("%s ServicePrincipalNames for %ws\n",
	   (Operation==DS_SPN_DELETE_SPN_OP)?"Unregistering":"Registering", Result->rItems[0].pName);
    printf("\t%ws\n", HostSpn);

#if 0
    printf("DsWriteAccountSpn: Commented out\n");
#else
    NetStatus = DsWriteAccountSpn(
                    hDs,
                    Operation,
                    Result->rItems[0].pName,
                    1,
                    Spns );


    if ( NetStatus != 0 )
    {
        fprintf(stderr,
		"Failed to %s SPN on account '%ws', %#x\n",
		(Operation==DS_SPN_DELETE_SPN_OP)?"remove":"assign",
		Result->rItems[0].pName, NetStatus );
	return FALSE;
    }
#endif

    DsFreeNameResult( Result );

    DsUnBind( &hDs );

    return NetStatus == 0 ;
}


BOOL
LookupHostSpn(
    PWSTR ServerDomain,
    PWSTR Server
    )
{
    WCHAR FlatName[ 128 ];
    HANDLE hDs ;
    ULONG NetStatus ;
    PDS_NAME_RESULT Result ;
    LPWSTR Flat = FlatName;
    LDAP *ld;
    int rc;
    LDAPMessage *e, *res;
    WCHAR *base_dn;
    WCHAR *search_dn, search_ava[256];
    WCHAR Domain[ MAX_PATH ];
    WCHAR DC[ MAX_PATH ];

    if ( !FindDomainForAccount( Server, ServerDomain, Domain, DC ))
    {
        fprintf(stderr, "Cannot find account %S\n", Server);
        return FALSE ;
    }
    
    if (debug)
        printf("Domain=%S DC=%S\n", Domain, DC);
    
    ld = ldap_open(DC, LDAP_PORT);
    if (ld == NULL) {
	fprintf(stderr, "ldap_init failed = %x", LdapGetLastError());
	return FALSE;
    }

    rc = ldap_bind_s(ld, NULL, NULL, LDAP_AUTH_NEGOTIATE);
    if (rc != LDAP_SUCCESS) {
	fprintf(stderr, "ldap_bind failed = %x", LdapGetLastError());
	ldap_unbind(ld);
	return FALSE;
    }

    NetStatus = DsBind( NULL, Domain, &hDs );
    if ( NetStatus != 0 )
    {
        fprintf(stderr, "Failed to bind to DC of domain %ws, %#x\n", 
               Domain, NetStatus );
        return FALSE ;
    }

    wcscpy( FlatName, Domain );
    wcscat( FlatName, L"\\" );
    wcscat( FlatName, Server );

    NetStatus = DsCrackNames(
                    hDs,
                    0,
                    DS_NT4_ACCOUNT_NAME,
                    DS_FQDN_1779_NAME,
                    1,
                    &Flat,
                    &Result );

    if ( NetStatus != 0 ||
	 Result->rItems[0].status != DS_NAME_NO_ERROR ||
	 Result->cItems != 1)
    {
	if (Result->rItems[0].status == DS_NAME_ERROR_NOT_FOUND)
	{
	    fprintf(stderr,
		    "Requested name \"%ws\" not found in directory.\n",
		    FlatName);
	}
	else if (Result->rItems[0].status == DS_NAME_ERROR_NOT_UNIQUE)
	{
	    fprintf(stderr,
		    "Requested name \"%ws\" not unique in directory.\n",
		    FlatName);
	}
	else
	    fprintf(stderr,
		    "Failed to crack name %ws into the FQDN, (%d) %d %#x\n",
		    FlatName, NetStatus, Result->cItems,
		    (Result->cItems==1)?Result->rItems[0].status:-1 );

        DsUnBind( &hDs );

        return FALSE ;
    }

    search_dn = Server;
	
    base_dn = StrChr(Result->rItems[0].pName, L',');
    if (!base_dn)
	base_dn = Result->rItems[0].pName;
    else
	base_dn++;
	
    if (debug) {
	printf("BASE_DN=%S\n", base_dn);
	printf("SEARCH_DN=%S\n", search_dn);
    }
	
    DsUnBind( &hDs );

    wsprintf(search_ava, L"(sAMAccountName=%s)", search_dn);
    if (debug)
	printf("FILTER=\"%S\"\n", search_ava);
    rc = ldap_search_s(ld, base_dn, LDAP_SCOPE_SUBTREE,
		       search_ava, NULL, 0, &res);

    DsFreeNameResult( Result );

    if (rc != LDAP_SUCCESS) {
	fprintf(stderr, "ldap_search_s failed: %S", ldap_err2string(rc));
	ldap_unbind(ld);
	return 1;
    }

    for (e = ldap_first_entry(ld, res);
	 e;
	 e = ldap_next_entry(ld, e)) {
	BerElement *b;
	WCHAR *attr;
	WCHAR *dn = ldap_get_dn(ld, res);

	printf("Registered ServicePrincipalNames");
	if (dn)
	    printf(" for %S", dn);
	printf(":\n");
	
	ldap_memfree(dn);
	
	for (attr = ldap_first_attribute(ld, e, &b);
	     attr;
	     attr = ldap_next_attribute(ld, e, b)) {
	    WCHAR **values, **p;
	    values = ldap_get_values(ld, e, attr);
	    for (p = values; *p; p++) {
		if (StrCmp(attr, L"servicePrincipalName") == 0)
		    printf("    %S\n", *p);
	    }
	    ldap_value_free(values);
	    ldap_memfree(attr);
	}

	//ber_free(b, 1);
    }

    ldap_msgfree(res);
    ldap_unbind(ld);

    return TRUE;
}

void Usage( PWSTR name)
{
    printf("\
Usage: %S [switches data] computername \n\
  Where \"computername\" can be the name or domain\\name\n\
\n\
  Switches:\n\
   -R = reset HOST ServicePrincipalName\n\
	Usage:   setspn -R computername\n\
   -A = add arbitrary SPN  \n\
	Usage:   setspn -A SPN computername\n\
   -D = delete arbitrary SPN  \n\
	Usage:   setspn -D SPN computername\n\
   -L = list registered SPNs  \n\
	Usage:   setspn [-L] computername   \n\
Examples: \n\
setspn -R daserver1 \n\
   It will register SPN \"HOST/daserver1\" and \"HOST/{DNS of daserver1}\" \n\
setspn -A http/daserver daserver1 \n\
   It will register SPN \"http/daserver\" for computer \"daserver1\" \n\
setspn -D http/daserver daserver1 \n\
   It will delete SPN \"http/daserver\" for computer \"daserver1\" \n\
", name);
    ExitProcess(0);
}

void __cdecl wmain (int argc, wchar_t *argv[])
{
    int resetSPN = FALSE, addSPN = FALSE, deleteSPN = FALSE, listSPN = TRUE;
    UNICODE_STRING Service, Host,HostSpn, HostDomain ;
    wchar_t *ptr;
    int i;
    DS_SPN_WRITE_OP Operation;
    PWSTR Scan;
    DWORD Status = 1;
    
    for (i = 1; i < argc; i++)
    {
        if ((argv[i][0] == L'-') || (argv[i][0] == L'/'))
        {
            for (ptr = (argv[i] + 1); *ptr; ptr++)
            {
                switch(towupper(*ptr))
                {
                case L'R':
                    resetSPN = TRUE;
                    break;
                case L'A':
                    addSPN = TRUE;
                    break;
                case L'D':
                    deleteSPN = TRUE;
                    break;
                case L'L':
                    listSPN = TRUE;
                    break;
                case L'V':
                    debug = TRUE;
                    break;
                case L'?':
                default:
                    Usage(argv[0]);
                    break;
                }
            }
        }
        else
            break;
    }
    
    
    if ( resetSPN )
    {
        if ( ( argc - i ) != 1 )
        {
            Usage( argv[0] );
        }

        RtlInitUnicodeString( &Host, argv[i] );

        if ( AddHostSpn( Host.Buffer ) )
        {
            printf("Updated object\n");
            Status = 0;
        }
    }
    else if ( addSPN || deleteSPN )
    {
        if ( ( argc - i ) != 2 )
        {
            Usage( argv[0] );
        }

        RtlInitUnicodeString( &HostSpn, argv[i] );

        Scan = argv[ i + 1 ];
    
        if ( Scan = wcschr( Scan, L'\\' ) )
        {
            *Scan++ = L'\0';
            RtlInitUnicodeString( &HostDomain, argv[i+1] );
            RtlInitUnicodeString( &Host, Scan );
        }
        else 
        {
            RtlInitUnicodeString( &HostDomain, L"" );
            RtlInitUnicodeString( &Host, argv[ i + 1 ] );
        }

        if ( addSPN )
            Operation = DS_SPN_ADD_SPN_OP;

        if ( deleteSPN )
            Operation = DS_SPN_DELETE_SPN_OP;

        if ( AddRemoveSpn( HostSpn.Buffer, HostDomain.Buffer, Host.Buffer, Operation) )
        {
            printf("Updated object\n");
            Status = 0;
        }
    }
    else if ( listSPN )
    {
        if ( ( argc - i ) != 1 )
        {
            Usage( argv[0] );
        }       

        Scan = argv[ i  ];
    
        if ( Scan = wcschr( Scan, L'\\' ) )
        {
            *Scan++ = L'\0';
            RtlInitUnicodeString( &HostDomain, argv[ i ] );
            RtlInitUnicodeString( &Host, Scan );
        }
        else 
        {
            RtlInitUnicodeString( &HostDomain, L"" );
            RtlInitUnicodeString( &Host, argv[ i ] );
        }

        if (LookupHostSpn( HostDomain.Buffer, Host.Buffer ))
        {
            Status = 0;
        }
    }

    ExitProcess(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\syskey\rng.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

//
// This file exports four functions: InitializeRNG, ShutdownRNG, GenRandom, and
// GenerateRandomBits, which are used to generate random sequences of bytes.
//

#include <windows.h>
#include <rng.h>
#include <rc4.h>
#include <sha.h>

#define A_SHA_DIGEST_LEN    20
#define RAND_CTXT_LEN       60
#define RC4_REKEY_PARAM     500     // rekey every 500 bytes

#define UNLEN   MAX_PATH

typedef struct _RandContext
{
    DWORD dwBitsFilled;
    BYTE  rgbBitBuffer[RAND_CTXT_LEN];
} RandContext;

#if 0
CRITICAL_SECTION    csRNG;

#define LockRNG()   EnterCriticalSection( &csRNG )
#define UnlockRNG() LeaveCriticalSection( &csRNG )
#else
#define LockRNG()
#define UnlockRNG()
#endif

unsigned char g_rgbStaticBits[A_SHA_DIGEST_LEN];
static DWORD         g_dwRC4BytesUsed = RC4_REKEY_PARAM;     // initially force rekey
static struct RC4_KEYSTRUCT g_rc4key;

static BOOL RandomFillBuffer(BYTE *pbBuffer, DWORD *pdwLength);
static void GatherRandomBits(RandContext *prandContext);
static void AppendRand(RandContext* prandContext, void* pv, DWORD dwSize);

/*****************************************************************************/
VOID STInitializeRNG(VOID)
{
    DWORD dwType;
    DWORD dwSize;

    LONG err;

#if 0

    InitializeCriticalSection( &csRNG );

    LockRNG();

    // grab seed from persistent storage

//    SPQueryPersistentSeed(g_rgbStaticBits, A_SHA_DIGEST_LEN);
#endif

    g_dwRC4BytesUsed = RC4_REKEY_PARAM;

#if 0
    UnlockRNG();
#endif

    return;
}

VOID ShutdownRNG(VOID)
{

#if 0
    DeleteCriticalSection( &csRNG );
#endif

    // put seed into persistent storage

//    SPSetPersistentSeed(g_rgbStaticBits, A_SHA_DIGEST_LEN);

    return;
}

/*****************************************************************************/
int STGenRandom(PVOID Reserved,
              UCHAR *pbBuffer,
              size_t dwLength)
{
    STGenerateRandomBits(pbBuffer, dwLength);
    return TRUE;
}

/************************************************************************/
/* GenerateRandomBits generates a specified number of random bytes and        */
/* places them into the specified buffer.                                */
/************************************************************************/
/*                                                                      */
/* Pseudocode logic flow:                                               */
/*                                                                      */
/* if (bits streamed > threshold)                                       */
/* {                                                                    */
/*  Gather_Bits()                                                       */
/*  SHAMix_Bits(User, Gathered, Static -> Static)                       */
/*  RC4Key(Static -> newRC4Key)                                         */
/*  SHABits(Static -> Static)      // hash after RC4 key generation     */
/* }                                                                    */
/* else                                                                 */
/* {                                                                    */
/*  SHAMix_Bits(User, Static -> Static)                                 */
/* }                                                                    */
/*                                                                      */
/* RC4(newRC4Key -> outbuf)                                             */
/* bits streamed += sizeof(outbuf)                                      */
/*                                                                      */
/************************************************************************/
VOID STGenerateRandomBits(PUCHAR pbBuffer,
                        ULONG  dwLength)
{
    DWORD dwBytesThisPass;
    DWORD dwFilledBytes = 0;

    // break request into chunks that we rekey between

    LockRNG();

    while(dwFilledBytes < dwLength)
    {
        dwBytesThisPass = dwLength - dwFilledBytes;

        RandomFillBuffer(pbBuffer + dwFilledBytes, &dwBytesThisPass);
        dwFilledBytes += dwBytesThisPass;
    }

    UnlockRNG();
}

/*****************************************************************************/
static BOOL RandomFillBuffer(BYTE *pbBuffer, DWORD *pdwLength)
{
    // Variables from loading and storing the registry...
    DWORD   cbDataLen;

    cbDataLen = A_SHA_DIGEST_LEN;

    if(g_dwRC4BytesUsed >= RC4_REKEY_PARAM) {
        // if we need to rekey

        RandContext randContext;
        randContext.dwBitsFilled = 0;

        GatherRandomBits(&randContext);

        // Mix all bits
        {
            A_SHA_CTX SHACtx;
            A_SHAInit(&SHACtx);

            // SHA the static bits
            A_SHAUpdate(&SHACtx, g_rgbStaticBits, A_SHA_DIGEST_LEN);

            // SHA the gathered bits
            A_SHAUpdate(&SHACtx, randContext.rgbBitBuffer, randContext.dwBitsFilled);

            // SHA the user-supplied bits
            A_SHAUpdate(&SHACtx, pbBuffer, *pdwLength);

            // output back out to static bits
            A_SHAFinal(&SHACtx, g_rgbStaticBits);
        }

        // Create RC4 key
        g_dwRC4BytesUsed = 0;
        rc4_key(&g_rc4key, A_SHA_DIGEST_LEN, g_rgbStaticBits);

        // Mix RC4 key bits around
        {
            A_SHA_CTX SHACtx;
            A_SHAInit(&SHACtx);

            // SHA the static bits
            A_SHAUpdate(&SHACtx, g_rgbStaticBits, A_SHA_DIGEST_LEN);

            // output back out to static bits
            A_SHAFinal(&SHACtx, g_rgbStaticBits);
        }

    } else {
        // Use current RC4 key, but capture any user-supplied bits.

        // Mix input bits
        {
            A_SHA_CTX SHACtx;
            A_SHAInit(&SHACtx);

            // SHA the static bits
            A_SHAUpdate(&SHACtx, g_rgbStaticBits, A_SHA_DIGEST_LEN);

            // SHA the user-supplied bits
            A_SHAUpdate(&SHACtx, pbBuffer, *pdwLength);

            // output back out to static bits
            A_SHAFinal(&SHACtx, g_rgbStaticBits);
        }
    }

    // only use RC4_REKEY_PARAM bytes from each RC4 key
    {
        DWORD dwMaxPossibleBytes = RC4_REKEY_PARAM - g_dwRC4BytesUsed;
        if(*pdwLength > dwMaxPossibleBytes) {
                *pdwLength = dwMaxPossibleBytes;
        }
    }

    FillMemory(pbBuffer, *pdwLength, 0);
    rc4(&g_rc4key, *pdwLength, pbBuffer);

    g_dwRC4BytesUsed += *pdwLength;

    return TRUE;
}

/*****************************************************************************/
static void GatherRandomBits(RandContext *prandContext)
{
    DWORD   dwTmp;
    WORD    wTmp;
    BYTE    bTmp;

    // ** indicates US DoD's specific recommendations for password generation

    // proc id
    dwTmp = GetCurrentProcessId();
    AppendRand(prandContext, &dwTmp, sizeof(dwTmp));

    // thread id
    dwTmp = GetCurrentThreadId();
    AppendRand(prandContext, &dwTmp, sizeof(dwTmp));

    // ** ticks since boot (system clock)
    dwTmp = GetTickCount();
    AppendRand(prandContext, &dwTmp, sizeof(dwTmp));

    // cursor position
    {
        POINT                        point;
        GetCursorPos(&point);
        bTmp = LOBYTE(point.x) ^ HIBYTE(point.x);
        AppendRand(prandContext, &bTmp, sizeof(BYTE));
        bTmp = LOBYTE(point.y) ^ HIBYTE(point.y);
        AppendRand(prandContext, &bTmp, sizeof(BYTE));
    }

    // ** system time, in ms, sec, min (date & time)
    {
        SYSTEMTIME                sysTime;
        GetLocalTime(&sysTime);
        AppendRand(prandContext, &sysTime.wMilliseconds, sizeof(sysTime.wMilliseconds));
        bTmp = LOBYTE(sysTime.wSecond) ^ LOBYTE(sysTime.wMinute);
        AppendRand(prandContext, &bTmp, sizeof(BYTE));
    }

    // ** hi-res performance counter (system counters)
    {
        LARGE_INTEGER        liPerfCount;
        if(QueryPerformanceCounter(&liPerfCount)) {
            bTmp = LOBYTE(LOWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
            AppendRand(prandContext, &bTmp, sizeof(BYTE));
            bTmp = HIBYTE(LOWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
            AppendRand(prandContext, &bTmp, sizeof(BYTE));
            bTmp = LOBYTE(HIWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
            AppendRand(prandContext, &bTmp, sizeof(BYTE));
            bTmp = HIBYTE(HIWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
            AppendRand(prandContext, &bTmp, sizeof(BYTE));
        }
    }

    // memory status
    {
        MEMORYSTATUS        mstMemStat;
        mstMemStat.dwLength = sizeof(MEMORYSTATUS);     // must-do
        GlobalMemoryStatus(&mstMemStat);
        wTmp = HIWORD(mstMemStat.dwAvailPhys);          // low words seem to be always zero
        AppendRand(prandContext, &wTmp, sizeof(WORD));
        wTmp = HIWORD(mstMemStat.dwAvailPageFile);
        AppendRand(prandContext, &wTmp, sizeof(WORD));
        bTmp = LOBYTE(HIWORD(mstMemStat.dwAvailVirtual));
        AppendRand(prandContext, &bTmp, sizeof(BYTE));
    }

    // free disk clusters
    {
        DWORD dwSectorsPerCluster, dwBytesPerSector, dwNumberOfFreeClusters, dwTotalNumberOfClusters;
        if(GetDiskFreeSpace(NULL, &dwSectorsPerCluster, &dwBytesPerSector,     &dwNumberOfFreeClusters, &dwTotalNumberOfClusters)) {
            AppendRand(prandContext, &dwNumberOfFreeClusters, sizeof(dwNumberOfFreeClusters));
            AppendRand(prandContext, &dwTotalNumberOfClusters, sizeof(dwTotalNumberOfClusters));
            AppendRand(prandContext, &dwBytesPerSector, sizeof(dwBytesPerSector));
        }
    }

    // last messages' timestamp
    {
        LONG lTime;
        lTime = GetMessageTime();
        AppendRand(prandContext, &lTime, sizeof(lTime));
    }

    {
        static DWORD dwComputerNameSize;
        static DWORD dwUserNameSize;
        static char lpComputerName [MAX_COMPUTERNAME_LENGTH + 1];
        static char lpUserName [UNLEN + 1];

        //
        // note use of two temp DWORDs - that's to keep the static DWORDs
        // thread safe
        //

        // **SystemID
        if(dwComputerNameSize == 0) {
            DWORD dwTempComputerNameSize = MAX_COMPUTERNAME_LENGTH + 1;

            if(GetComputerNameA(lpComputerName, &dwTempComputerNameSize))
                dwComputerNameSize = dwTempComputerNameSize;
        }

        if(dwComputerNameSize != 0) {
            // dwComputerNameSize = len not including null termination
            AppendRand(prandContext, lpComputerName, dwComputerNameSize);
        }

        // **UserID
        if(dwUserNameSize == 0) {
            DWORD dwTempUserNameSize = UNLEN + 1;

            if(GetUserNameA(lpUserName, &dwTempUserNameSize)) {
                // dwUserNameSize = len including null termination
                dwUserNameSize = dwTempUserNameSize - 1;
            }
        }

        if(dwUserNameSize != 0) {
            AppendRand(prandContext, lpUserName, dwUserNameSize);
        }
    }
}

/*****************************************************************************/
static void AppendRand(RandContext* prandContext, void* pv, DWORD dwSize)
{
    DWORD dwBitsLeft = (RAND_CTXT_LEN - prandContext->dwBitsFilled);

    if(dwBitsLeft > 0) {
        if(dwSize > dwBitsLeft) {
            dwSize = dwBitsLeft;
        }

        CopyMemory(prandContext->rgbBitBuffer + prandContext->dwBitsFilled, pv, dwSize);
        prandContext->dwBitsFilled += dwSize;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\syskey\samlock.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       samlock.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-19-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __SAMLOCK_H__
#define __SAMLOCK_H__


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <ntlsa.h>
#include <caiseapi.h>

#include <windows.h>
#include <md5.h>

#include <wxlpc.h>

#include "dialogs.h"
#include "miscid.h"
#include "strings.h"
#include "rng.h"



#endif //__SAMLOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\syskey\strings.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       strings.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-20-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __STRINGS_H__
#define __STRINGS_H__


#define IDS_SAM_NOT_SYNC            1500
#define IDS_ERROR_CAPTION           1501
#define IDS_SYSTEM_ERROR_OCCURRED   1502
#define IDS_WARNING_CAPTION         1503
#define IDS_NEW_PW_MATCH            1504
#define IDS_KEYFILE_NOT_FOUND       1505
#define IDS_SETPASS_FAILED          1506
#define IDS_SETPASS_SUCCESS         1507
#define IDS_SUCCESS_CAPTION         1508
#define IDS_INSERT_FLOPPY           1509
#define IDS_SAVE_KEY_CAPTION        1510
#define IDS_SAVE_KEY_SUCCESS        1511
#define IDS_SAVE_KEY_FAILED         1512
#define IDS_L_OPTION                1513
#define IDS_Q_OPTION                1514
#define IDS_NO_UNATTENDED           1515
#define IDS_ARE_YOU_SURE            1516
#define IDS_ARE_YOU_SURE_CAP        1517
#define IDS_RENAMED_OLD             1518




#endif // __STRINGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\pch.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    This module contains function prototypes.

Author:

    Jeffrey Lawson (jlawson) 12-Apr-2000

Revision History:

--*/

#ifndef _WINSAFER_PCH_
#define _WINSAFER_PCH_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif
//
// Include Common Definitions.
//

ULONG
BaseSetLastNTError(
    IN NTSTATUS Status
    );


#ifdef __cplusplus
} // extern "C"
#endif

#endif // _WINSAFER_PCH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\trustdom2\trustdom.c ===
/*--

Copyright (c) 1997-1997  Microsoft Corporation

Module Name:

    trustdom.c

Abstract:

    Command line tool for displaying/creating/deleting trust links between 2 domains

Author:

    1-Apr-1997   Mac McLain (macm)   Created
	14-Jun-1998  Cristian Ioneci (cristiai)   Heavily modified
	
Environment:

    User mode only.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntlsa.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <dsgetdc.h>

#include <ntrtl.h>

#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <lmserver.h>
#include <lmerr.h>

#include <string.h>

#define DEFINES_ONLY
#include "res.rc"


//taken from netlibnt.h; resides in netapi32.dll
NTSTATUS
NetpApiStatusToNtStatus(
    NET_API_STATUS NetStatus
    );


#define DBG 1

//dbgprintf macro: 	call it like dbgprint(("X:%d\n",i)); //notice the xtra paranthesis!!
#ifdef DBG
#define dbgprintf(a) if(Dbg) resprintf a
#else
#define dbgprintf(a)
#endif



/*-------------------------------------------------------*/
HINSTANCE hInst;
#define RBSZ 4096
WCHAR resbuf[RBSZ];
WCHAR outbuf[RBSZ];
			
#define RESPRINT_STDOUT 3
/*-------------------------------------------------------*/
//Printf message with format taken from a resource string
// where: 0 - stdout; 1- stderr; 2 - in the 'output' buffer
//take care: the resulting string must be max. RBSZ wchars (see #define above)
int resprintf(int where, UINT ids, ... )
{
	va_list parlist;
	va_start(parlist,ids);

	if(LoadString(hInst,ids,resbuf,RBSZ)==0)
		swprintf(resbuf,L"(LoadString failed with 0x%08lx)",GetLastError());
	
	switch(where) {
	case 0:
		return(vwprintf(resbuf, parlist));
	case 1:
		return(vfwprintf(stderr, resbuf, parlist));
	case 2:		
		return(vswprintf(outbuf, resbuf, parlist));
	case RESPRINT_STDOUT:
		return(vfwprintf(stdout, resbuf, parlist));

    DEFAULT_UNREACHABLE;

	}
}

enum DomInfoType_e { Minimal=0, Primary, DNS };
	// Minimal mode is used only for 'localonly' flag...
	//Minimal means that the name that was specified on the command line
	//(and copied in the ArgDomName member of the _TD_DOM_INFO structure) will
	//be the only information available about the target domain (that is, just
	//the flat name of the domain). That could happen if the target domain is
	//no longer accessible at the moment when the trustdom is run... 'TrustDom'
	//will try to do its best in this case...

struct LsaTIshot {
	ULONG count;
	PLSA_TRUST_INFORMATION	pTI;
};

typedef struct _TD_DOM_INFO {

	PWSTR pArgDomName; //from the command line...
	UNICODE_STRING uMinimalName;	//in case it is needed...
	LSA_HANDLE Policy;
	DWORD majver;
	LSA_HANDLE TrustedDomain;
	WCHAR DCName[1024];
	enum DomInfoType_e DomInfoType;
	union {
		PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo;
	    PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo;
	} u;
	PTRUSTED_DOMAIN_INFORMATION_EX pTDIX;	//one shot... Lsa memory space
	ULONG TDIXcEntries;
	struct LsaTIshot *pTIs;	//array of TIshots
	int nTIs;				//no. of TIshots
	ULONG TIcEntries;
	USER_INFO_1 *pUI1;	//one shot...
	DWORD UI1cEntries;

} TD_DOM_INFO, *PTD_DOM_INFO;

typedef struct _TD_VERIFY_INFO {

    PUNICODE_STRING DisplayName;
    PUNICODE_STRING ShortName;
    UNICODE_STRING NameBuffer;
    NTSTATUS IncomingStatus;
    NTSTATUS OutgoingStatus;

} TD_VERIFY_INFO, *PTD_VERIFY_INFO;

//
// Local function prototypes
//
NTSTATUS
GetDomainInfoForDomain(
    IN PWSTR DomainName,
    IN OPTIONAL PWSTR	DCMachineName,	// optional DC machine name
    IN PTD_DOM_INFO Info,
    IN BOOL MitTarget	
    );

NTSTATUS
GetTrustLinks(
    IN PTD_DOM_INFO pInfo
	);

VOID
FreeDomainInfo(
    IN PTD_DOM_INFO Info
    );

//
// Globals
//
BOOLEAN Force = FALSE;
BOOLEAN Nt4 = FALSE;
BOOLEAN Dbg = FALSE;
BOOLEAN SidList = FALSE;
//BOOLEAN Overwritesid = FALSE; actually use Force instead...

ULONG
DisplayErrorMessage(
    IN NTSTATUS Status
    )
/*++

Routine Description:

    This function display the error string for the given error status

Arguments:

    NetStatus - Status to display the message for

Return Value:

    VOID

--*/
{
    ULONG Size = 0;
    PWSTR DisplayString;
    ULONG Options = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM;


    Size = FormatMessage( Options,
                          NULL,
                          RtlNtStatusToDosError( Status ),
                          MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                          ( LPTSTR )&DisplayString,
                          0,
                          NULL );

    if ( Size != 0 ) {

        fprintf( stdout, "%ws", DisplayString );
        LocalFree( DisplayString );
    }

    return( Size );
}


VOID
Usage (
    VOID
    )
{
    resprintf(1,IDS_USAGE,VER_FILEVERSION_LSTR);
}


/*---------------------------- printSID --------------------------*/
BOOL
PrintSID(
        IN PSID	s
)
{
        int   i;
        BOOL r=TRUE;
        SID_IDENTIFIER_AUTHORITY        *a;

		if(s==NULL) {
			printf("<NULL sid>");
			return(FALSE);
		}

        if (!IsValidSid(s)) {
            printf("<invalid sid>:");
            r=FALSE;
        }

        a = GetSidIdentifierAuthority(s);

//      printf("S-0x1-%02x%02x%02x%02x%02x%02x",
//				a->Value[0], a->Value[1],
//				a->Value[2], a->Value[3],
//				a->Value[4], a->Value[5]);

		printf("S-0x1-");

		for(i=0; i<6; i++)
			if(a->Value[i]>0)
				break;
		if(i==6)			// hmmm... all zeroes?
			printf("0");	// out one zero then
		else {
			for(   ; i<6; i++) // else dump the remaining ones
					printf("%02x",a->Value[i]);
		}

        for (i = 0; i < (int)(*GetSidSubAuthorityCount(s)); i++) {
                printf("-%lx", *GetSidSubAuthority(s, i));
        }
        return(r);
}



NTSTATUS
GenerateRandomSID(
	OUT PSID *pSID
	)
{	
    NTSTATUS Status = STATUS_SUCCESS;

	SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    LARGE_INTEGER CurrentTime;

    NtQuerySystemTime(&CurrentTime);

    Status = RtlAllocateAndInitializeSid(
                &NtAuthority,
                4,
                SECURITY_NT_NON_UNIQUE,
                0,
                CurrentTime.LowPart,
                CurrentTime.HighPart,
                0,0,0,0,
                pSID
                );

    if (!NT_SUCCESS(Status))
    {
		*pSID=NULL;
		resprintf(0,IDS_GENERATERANDOMSID_F,Status);
    }

    return(Status);
}


//--------------------------zapchr------------------------------------
BOOL zapchr(WCHAR *s,    // zap specified character from the end of string
			WCHAR c,     // usefull to cut things like '\n' or '\\'
			WCHAR rc)    // rc is the char to replace with
{       WCHAR *p;
        if((p=wcsrchr(s,c))!=NULL) {
                *p=rc;
                return(TRUE);   // found smth to cut...
        }
        return(FALSE);          // the string was "clean"...
}


/*----------------------------------------------------------------------------*/
BOOL GetPassword(WCHAR *passwd, size_t n)
{
    /* turn off console echo & read in the password */

    HANDLE      console;
    DWORD       mode;

    *passwd=L'\0';
    if((console = GetStdHandle(STD_INPUT_HANDLE))==INVALID_HANDLE_VALUE)
                return(FALSE);
    if (! GetConsoleMode(console, &mode))
                return(FALSE);
    if (! SetConsoleMode(console, (mode & ~ENABLE_ECHO_INPUT)))
                return(FALSE);
    //fwprintf(stderr, L"Password : ");
    resprintf(1,IDS_PASSWORD_PROMPT);
    if (!fgetws(passwd, n, stdin))
                return(FALSE);
        zapchr(passwd,L'\n',L'\0');
    if (! SetConsoleMode(console, mode))
                return(FALSE);
    if(!CloseHandle(console))
                return(FALSE);
    fwprintf(stderr,L"\n");
    return(TRUE);
}


//UNICODE_STRING uMinimalName; not used anymore... added a field with same name inside each
//TD_DOM_INFO structure that will be used instead... in this way two consecutive calls
//*** FOR TWO STRUCTURES*** will not overwrite it.

//------------------GetFlatName---------------------------
PLSA_UNICODE_STRING GetFlatName(IN PTD_DOM_INFO pInfo)
{
	switch(pInfo->DomInfoType) {
	case DNS:
			return(&pInfo->u.DnsDomainInfo->Name);
	case Primary:
			return(&pInfo->u.PrimaryDomainInfo->Name);
	default:	//Minimal
			RtlInitUnicodeString(&pInfo->uMinimalName,pInfo->pArgDomName);
			return(&pInfo->uMinimalName);
	}
}

//------------------GetName--------------------------------
PLSA_UNICODE_STRING GetName(IN PTD_DOM_INFO pInfo)
{
	//simpler, just a little bit slower... (xtra call)
	//	if(pInfo->DomInfoType==DNS)
	//		return(&pInfo->u.DnsDomainInfo->DnsDomainName);
	//
	//	return(GetFlatName(pInfo));
	
	switch(pInfo->DomInfoType) {
	case DNS:
			return(&pInfo->u.DnsDomainInfo->DnsDomainName);
	case Primary:
			return(&pInfo->u.PrimaryDomainInfo->Name);
	default:	//Minimal
			RtlInitUnicodeString(&pInfo->uMinimalName,pInfo->pArgDomName);
			return(&pInfo->uMinimalName);
	}
}

PSID GetSid(IN PTD_DOM_INFO pInfo)
{
    PSID ReturnSid = NULL;

	switch(pInfo->DomInfoType) {
	case DNS:
        ReturnSid = pInfo->u.DnsDomainInfo->Sid;
        break;

	case Primary:
        ReturnSid = pInfo->u.PrimaryDomainInfo->Sid;
        break;

	}

    return( ReturnSid );
}

WCHAR SrvName[1024];
//----------------MakeSrvName-------------------------------
PWSTR MakeSrvName(IN PWSTR Name)	//add slashes at the beginning
{
	swprintf(SrvName,L"\\\\%ws",Name);
	if(SrvName[0]==L'\0')
		return(NULL);
	return(SrvName);
}

WCHAR Domain[1024];
//----------------AddDlrToDomainName-------------------------
PWSTR AddDlrToDomainName(IN PTD_DOM_INFO pInfo)
{
	swprintf(Domain,L"%wZ$",GetFlatName(pInfo));
	return(Domain);
}
WCHAR CutDlrDomain[1024];
//----------------CutDlrFromName-----------------------------
PWSTR CutDlrFromName(IN PWSTR Name)
{
	wcscpy(CutDlrDomain,Name);
	zapchr(CutDlrDomain,L'$',L'\0');
	return(CutDlrDomain);
}


WCHAR secret[1024];
LSA_UNICODE_STRING uSecret;
//---------------------MakeSecretName------------------
PLSA_UNICODE_STRING MakeSecretName(IN PTD_DOM_INFO pInfo)
{
	swprintf(secret,L"G$$%wZ",GetFlatName(pInfo));
	RtlInitUnicodeString(&uSecret,secret);
	return(&uSecret);
}

//start section inserted from Mac (11/05/1998(Thu) 17:08:53)
NTSTATUS
VerifyIndividualTrust(
    IN PSID InboundDomainSid,
    IN PUNICODE_STRING InboundDomainName,
    IN PLSA_HANDLE OutboundHandle,
    IN PWSTR OutboundServer,
    IN OUT PNTSTATUS VerifyStatus
    )
/*++

Routine Description:

	This routine will verify a single trust in the one direction only.

Arguments:

    InboundDomainSid -- Sid of the inbound side of the trust
    OutboundHandle -- Open policy handle to a domain controller on the outbound side
    OutboundServer -- Name of the domian controller on the outbound side
    VerifyStatus -- Status returned from the verification attempt
	
Return Value:

    STATUS_SUCCESS -- Success
    STATUS_INVALID_SID -- The specified domain sid was invalid

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD SidBuff[ sizeof( SID ) / sizeof( DWORD ) + 5 ];
    PSID DomAdminSid = ( PSID )SidBuff;
    PLSA_REFERENCED_DOMAIN_LIST Domains = NULL;
    PLSA_TRANSLATED_NAME Names = NULL;
    NET_API_STATUS NetStatus;
    PNETLOGON_INFO_2 NetlogonInfo2 = NULL;

    //
    // Assume the trust is invalid until we can prove otherwise.
    //
    *VerifyStatus = STATUS_TRUSTED_DOMAIN_FAILURE;

    ASSERT( RtlValidSid( InboundDomainSid ) );

    if ( !RtlValidSid( InboundDomainSid ) ) {

        return( STATUS_INVALID_SID );
    }

    //
    // Check netlogons secure channel
    //
    if ( NT_SUCCESS( Status )  ) {

        NetStatus = I_NetLogonControl2( OutboundServer,
                                        NETLOGON_CONTROL_TC_QUERY,
                                        2,
                                        ( LPBYTE )&InboundDomainName->Buffer,
                                        ( LPBYTE *)&NetlogonInfo2 );

        if ( NetStatus == NERR_Success ) {

            NetStatus = NetlogonInfo2->netlog2_pdc_connection_status;
            NetApiBufferFree( NetlogonInfo2 );

            if ( NetStatus != NERR_Success ) {

                NetStatus = I_NetLogonControl2( OutboundServer,
                                                NETLOGON_CONTROL_REDISCOVER,
                                                2,
                                                ( LPBYTE )&InboundDomainName->Buffer,
                                                ( LPBYTE *)&NetlogonInfo2 );
            }
        }

        *VerifyStatus = NetpApiStatusToNtStatus( NetStatus );

    }

    //
    // Now, try a lookup
    //
    if ( NT_SUCCESS( Status ) && NT_SUCCESS( *VerifyStatus ) ) {

        //
        // Build the domain admins sid for the inbound side of the trust
        //
        RtlCopyMemory( DomAdminSid,
                       InboundDomainSid,
                       RtlLengthSid( InboundDomainSid ) );


        ( ( PISID )( DomAdminSid ) )->SubAuthorityCount++;
        *( RtlSubAuthoritySid( DomAdminSid,
                               *( RtlSubAuthorityCountSid( InboundDomainSid ) ) ) ) =
                                                                            DOMAIN_GROUP_RID_ADMINS;

        //
        // Now, we'll simply do a remote lookup, and ensure that we get back success
        //
        Status = LsaLookupSids( OutboundHandle,
                                1,
                                &DomAdminSid,
                                &Domains,
                                &Names );

        if ( NT_SUCCESS( Status ) ) {

            LsaFreeMemory( Domains );
            LsaFreeMemory( Names );
            *VerifyStatus = STATUS_SUCCESS;

        } else if ( Status == STATUS_NONE_MAPPED ) {

            *VerifyStatus = STATUS_TRUSTED_DOMAIN_FAILURE;
            Status = STATUS_SUCCESS;

        } else {

            *VerifyStatus = Status;
        }

        //
        // If all of that worked, check netlogons secure channel
        //
        if ( NT_SUCCESS( Status ) && NT_SUCCESS( *VerifyStatus ) ) {

            NetStatus = I_NetLogonControl2( OutboundServer,
                                            NETLOGON_CONTROL_TC_QUERY,
                                            2,
                                            ( LPBYTE )&InboundDomainName->Buffer,
                                            ( LPBYTE *)&NetlogonInfo2 );

            if ( NetStatus == NERR_Success ) {

                NetStatus = NetlogonInfo2->netlog2_pdc_connection_status;
                NetApiBufferFree( NetlogonInfo2 );

                if ( NetStatus != NERR_Success ) {

                    NetStatus = I_NetLogonControl2( OutboundServer,
                                                    NETLOGON_CONTROL_REDISCOVER,
                                                    2,
                                                    ( LPBYTE )&InboundDomainName->Buffer,
                                                    ( LPBYTE *)&NetlogonInfo2 );
                }
            }

            *VerifyStatus = NetpApiStatusToNtStatus( NetStatus );

        }
    }

    return( Status );
}

NTSTATUS
VerifyTrustInbound(
    IN PTD_DOM_INFO LocalDomain,
    IN PUNICODE_STRING RemoteDomain,
    IN OUT PNTSTATUS VerifyStatus
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    TD_DOM_INFO RemoteTrustInfo;
    WCHAR  DCname[MAX_PATH + 1]= { L'\0' };



    RtlZeroMemory( &RemoteTrustInfo, sizeof( RemoteTrustInfo ) );
    Status = GetDomainInfoForDomain( RemoteDomain->Buffer, NULL, &RemoteTrustInfo, FALSE );

    if ( NT_SUCCESS( Status ) ) {

        Status= VerifyIndividualTrust( GetSid( LocalDomain ),
                                       GetName( LocalDomain ),
                                       RemoteTrustInfo.Policy,
                                       RemoteTrustInfo.DCName,
                                       VerifyStatus );

        FreeDomainInfo( &RemoteTrustInfo );

    } else {

        *VerifyStatus = Status;
    }

    return( Status );
}

NTSTATUS
VerifyTrustOutbound(
    IN PTD_DOM_INFO LocalDomain,
    IN PUNICODE_STRING RemoteDomain,
    IN OUT PNTSTATUS VerifyStatus
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    TD_DOM_INFO RemoteTrustInfo;

    RtlZeroMemory( &RemoteTrustInfo, sizeof( RemoteTrustInfo ) );
    Status = GetDomainInfoForDomain( RemoteDomain->Buffer, NULL, &RemoteTrustInfo, FALSE );

    if ( NT_SUCCESS( Status ) ) {

        Status= VerifyIndividualTrust( GetSid( &RemoteTrustInfo ),
                                       GetName( &RemoteTrustInfo ),
                                       LocalDomain->Policy,
                                       LocalDomain->DCName,
                                       VerifyStatus );

        FreeDomainInfo( &RemoteTrustInfo );

    } else {

        *VerifyStatus = Status;
    }

    return( Status );
}

NTSTATUS
VerifyTrusts(
    IN PWSTR DomainName,
    IN OPTIONAL PWSTR	DCMachineName	// optional DC machine name
    )
/*++

Routine Description:

	This routine will verify the existing trusts with all other NT domains, and display the
    results.

Arguments:

    DomainName -- OPTIONAL name of the domain on which to verify the information

	
Return Value:

    STATUS_SUCCESS -- Success

    STATUS_INSUFFICIENT_RESOURCES -- A memory allocation failed

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    TD_DOM_INFO TrustInfo;
    PTD_VERIFY_INFO VerifyList = NULL;
    ULONG VerifyCount = 0, VerifyIndex = 0, i, j;
    BOOLEAN InvalidIncoming = FALSE, InvalidOutgoing = FALSE, Valid = FALSE;
    UNICODE_STRING *LocalDomainName = NULL, SamNameAsDomain;
    WCHAR *AccountTrunc;


    RtlZeroMemory( &TrustInfo, sizeof( TrustInfo ) );
    Status = GetDomainInfoForDomain( DomainName, DCMachineName, &TrustInfo, FALSE );

    if ( NT_SUCCESS( Status ) ) {

        Status = GetTrustLinks( &TrustInfo );
    }

    if ( !NT_SUCCESS( Status ) ) {

        goto VerifyExit;
    }

    LocalDomainName = GetName( &TrustInfo );

    //
    // Allocate a list of verify information to correspond to the list we enumerated
    //
    VerifyCount = max( TrustInfo.TDIXcEntries,  TrustInfo.UI1cEntries + TrustInfo.TIcEntries );

    VerifyList = ( PTD_VERIFY_INFO )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                                VerifyCount * sizeof( TD_VERIFY_INFO ) );

    if ( !VerifyList ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto VerifyExit;
    }

    //
    // Now, do the verification.
    //
    if ( TrustInfo.TDIXcEntries ) {

        for ( i = 0; i < TrustInfo.TDIXcEntries; i++ ) {

            if ( TrustInfo.pTDIX[ i ].TrustType == TRUST_TYPE_DOWNLEVEL ||
                 TrustInfo.pTDIX[ i ].TrustType == TRUST_TYPE_UPLEVEL ) {

                VerifyList[ VerifyIndex ].DisplayName = &TrustInfo.pTDIX[ i ].Name;
                VerifyList[ VerifyIndex ].ShortName = &TrustInfo.pTDIX[ i ].FlatName;

                resprintf( RESPRINT_STDOUT, IDS_VERIFY_CHECK,
                           LocalDomainName,
                           VerifyList[ VerifyIndex ].DisplayName );

                if ( ( TrustInfo.pTDIX[ i ].TrustDirection & TRUST_DIRECTION_INBOUND ) ) {

                    Status = VerifyTrustInbound( &TrustInfo,
                                                 &TrustInfo.pTDIX[ i ].Name,
                                                 &VerifyList[ VerifyIndex ].IncomingStatus );
                }

                if ( ( TrustInfo.pTDIX[ i ].TrustDirection & TRUST_DIRECTION_OUTBOUND ) &&
                     Status != STATUS_NO_SUCH_DOMAIN ) {

                    Status = VerifyTrustOutbound( &TrustInfo,
                                                 &TrustInfo.pTDIX[ i ].Name,
                                                 &VerifyList[ VerifyIndex ].OutgoingStatus );
                }

                if ( NT_SUCCESS( VerifyList[ VerifyIndex ].OutgoingStatus ) &&
                     NT_SUCCESS( VerifyList[ VerifyIndex ].IncomingStatus ) ) {

                     Valid = TRUE;

                } else {

                    if ( !NT_SUCCESS( VerifyList[ VerifyIndex ].OutgoingStatus ) ) {

                        InvalidOutgoing = TRUE;
                    }

                    if ( !NT_SUCCESS( VerifyList[ VerifyIndex ].IncomingStatus ) ) {

                        InvalidIncoming = TRUE;
                    }
                }

                VerifyIndex++;
            }

            Status = STATUS_SUCCESS;
        }

    } else {
        //
        // Going to have to do the old NT4 style.
        //
        //for ( i = 0; i < TrustInfo.TIcEntries; i++ ) {

    	int shot;
        for ( VerifyIndex=0, shot=0; shot<TrustInfo.nTIs; shot++)
        	for(i=0; i<TrustInfo.pTIs[shot].count; i++) {

	            VerifyList[ VerifyIndex ].DisplayName = &TrustInfo.pTIs[shot].pTI[ i ].Name;
	            VerifyList[ VerifyIndex ].ShortName = &TrustInfo.pTIs[shot].pTI[ i ].Name;
	            resprintf( RESPRINT_STDOUT, IDS_VERIFY_CHECK,
	                       LocalDomainName,
	                       VerifyList[ VerifyIndex ].DisplayName );

	            Status = VerifyTrustOutbound( &TrustInfo,
	                                          &TrustInfo.pTIs[shot].pTI[ i ].Name,
	                                          &VerifyList[ VerifyIndex ].OutgoingStatus );

	            if ( !NT_SUCCESS( VerifyList[ VerifyIndex ].OutgoingStatus ) ) {

	                InvalidOutgoing = TRUE;
	            }
	            VerifyIndex++;
	        }

        //
        // Now, the same with the sam account names
        //
        for ( i = 0; i < TrustInfo.UI1cEntries; i++ ) {

            //
            // Shorten the account name to be a domain name
            //
            AccountTrunc = &TrustInfo.pUI1[ i ].usri1_name[
                                                wcslen( TrustInfo.pUI1[ i ].usri1_name ) - 1 ];
            *AccountTrunc = UNICODE_NULL;

            //
            // See if we already have an entry for this in our verified list
            //
            RtlInitUnicodeString( &SamNameAsDomain, TrustInfo.pUI1[ i ].usri1_name );
            for ( j = 0; j < VerifyIndex; j++ ) {

                if ( RtlEqualUnicodeString( &SamNameAsDomain,
                                            VerifyList[ j ].ShortName, TRUE ) ) {
                    break;
                }
            }

            if ( j == VerifyIndex ) {

                RtlCopyMemory( &VerifyList[ j ].NameBuffer, &SamNameAsDomain,
                              sizeof( UNICODE_STRING ) );
                VerifyList[ j ].DisplayName = &VerifyList[ j ].NameBuffer;
                VerifyList[ j ].ShortName = &VerifyList[ j ].NameBuffer;
                VerifyIndex++;
            }


            resprintf( RESPRINT_STDOUT, IDS_VERIFY_CHECK,
                       LocalDomainName,
                       &SamNameAsDomain );
            Status = VerifyTrustInbound( &TrustInfo,
                                         &SamNameAsDomain,
                                         &VerifyList[ j ].IncomingStatus );

            if ( !NT_SUCCESS( VerifyList[ j ].IncomingStatus ) ) {

                InvalidIncoming = TRUE;
            }

            *AccountTrunc = L'$';

        }

        //
        // Now, walk the list and see if we have any valid domain pairs
        //
        for ( i = 0; i < VerifyIndex; i++ ) {

            if ( NT_SUCCESS( VerifyList[ i ].IncomingStatus ) &&
                 NT_SUCCESS( VerifyList[ i ].OutgoingStatus ) ) {

                Valid = TRUE;
                break;
            }
        }
    }

    //
    // Display the list of valid trusts
    //
    if ( Valid ) {

        resprintf( RESPRINT_STDOUT, IDS_VERIFY_VALID );
        for ( i  = 0; i < VerifyIndex; i++ ) {

            if ( NT_SUCCESS( VerifyList[ i ].IncomingStatus ) &&
                 NT_SUCCESS( VerifyList[ i ].OutgoingStatus ) ) {

                fprintf(stdout, "%wZ\n", VerifyList[ i ].DisplayName );
            }
        }
    }

    if ( InvalidIncoming ) {

        resprintf( RESPRINT_STDOUT, IDS_VERIFY_INVALID_INCOMING );
        for ( i  = 0; i < VerifyIndex; i++ ) {

            if ( !NT_SUCCESS( VerifyList[ i ].IncomingStatus ) ) {

                fprintf( stdout, "%wZ - ", VerifyList[ i ].DisplayName );
                if ( DisplayErrorMessage( VerifyList[ i ].IncomingStatus ) == 0 ) {

                    resprintf( RESPRINT_STDOUT, IDS_VERIFY_UNMAPPABLE,
                               VerifyList[ i ].IncomingStatus );
                }
            }
        }
    }

    if ( InvalidOutgoing ) {

        resprintf( RESPRINT_STDOUT, IDS_VERIFY_INVALID_OUTGOING );
        for ( i  = 0; i < VerifyIndex; i++ ) {

            if ( !NT_SUCCESS( VerifyList[ i ].OutgoingStatus ) ) {

                fprintf( stdout, "%wZ - ", VerifyList[ i ].DisplayName );
                if ( DisplayErrorMessage( VerifyList[ i ].OutgoingStatus ) == 0 ) {

                    resprintf( RESPRINT_STDOUT, IDS_VERIFY_UNMAPPABLE,
                               VerifyList[ i ].OutgoingStatus );
                }
            }
        }
    }


    Status = STATUS_SUCCESS;
VerifyExit:

    LocalFree( VerifyList );
    FreeDomainInfo( &TrustInfo );

    return( Status );
}


//end section insert from Mac (11/05/1998(Thu) 17:09:39)

NTSTATUS
GetDomainInfoForDomain(
    IN PWSTR    		DomainName,
    IN OPTIONAL PWSTR	DCMachineName,	// optional DC machine name
    IN PTD_DOM_INFO		Info,
    BOOL	MitTarget		// TRUE if this call is made for the B domain in a A <-> B Mit type trust link

    )
/*++

Routine Description:

	Tries to fill as much as possible of the TD_DOM_INFO structure for the given domain;
	For a NT4 DC, the DNS name does not exist

Arguments:

    DomainName -- Optional domain to conect to

	    Info -- Information structure to fill in

Return Value:

    STATUS_SUCCESS -- Success

    STATUS_NO_SUCH_DOMAIN -- No server could be located for the domain

--*/
{
	NET_API_STATUS   netstatus=NERR_Success;
	NTSTATUS Status = STATUS_SUCCESS;
	PWSTR pMachine=NULL;
	DWORD dwErr;
	UNICODE_STRING Server;
//  UNICODE_STRING uString;
//	PLSA_UNICODE_STRING puDomName;
//
	OBJECT_ATTRIBUTES ObjectAttributes;
	PDOMAIN_CONTROLLER_INFO DCInfo = NULL;
	SERVER_INFO_101 *p101  = NULL;

	PSID sid=NULL;
	WCHAR *DCInfostr=L"";

	Info->DomInfoType=Minimal;
	Info->pArgDomName=DomainName;
	
	Info->majver=0;	// assume nothing... or a Unix machine... (for a MIT trust)

	Info->DCName[0]=L'\0';

	if(MitTarget)
		return(STATUS_NO_SUCH_DOMAIN);
	
	resprintf(2,IDS_LOCAL);	// printed to outbuf....

    if ( (DomainName != NULL && DomainName[0]!=L'\0') || Nt4 ) {	// try to get local machine name for an Nt4 style operation...

		if(DCMachineName == NULL || DCMachineName[0]==L'\0') {
	        dwErr = DsGetDcName( NULL, (LPCWSTR)DomainName, NULL, NULL,
	                             DS_DIRECTORY_SERVICE_PREFERRED | DS_WRITABLE_REQUIRED,
	                             &DCInfo );

	        if ( dwErr == ERROR_SUCCESS ) {
	        	wcscpy(Info->DCName,DCInfo->DomainControllerName + 2);
	        	pMachine=Info->DCName;
				//set the version
				if((DCInfo->Flags&(DS_DS_FLAG|DS_WRITABLE_FLAG))==DS_WRITABLE_FLAG)
						Info->majver=4;
				else	Info->majver=5;
		        dbgprintf((0,IDS_DSGETDCNAME_DC_D,DomainName!=NULL?DomainName:outbuf,Info->DCName)); //,DCInfo->Flags));
	        } else {
	           	Status = STATUS_NO_SUCH_DOMAIN;
				resprintf(0,IDS_DSGETDCNAME_F,DomainName!=NULL?DomainName:outbuf,dwErr);
				if(Force)
						resprintf(0,IDS_DSGETDCNAME_FFORCE);
				else	resprintf(0,IDS_DSGETDCNAME_FRET,Status);
	        }
		}
		else {
			wcscpy(Info->DCName,DCMachineName);
			pMachine=Info->DCName;
	        dbgprintf((0,IDS_DSGETDCNAME_DC_D,DomainName!=NULL?DomainName:outbuf,Info->DCName));
	        //now trying to get version using some other method than based on the flags returned by DsGetDcName...
		    netstatus = NetServerGetInfo( MakeSrvName(pMachine), 101, ( LPBYTE *) &p101 );
			if(netstatus != NERR_Success) {
	           	Status = STATUS_UNSUCCESSFUL;
				fprintf(stderr,"NetServerGetInfo (101) failed: err 0x%08lx;\n"
							"    ...now returning Status 0x%08lx (STATUS_UNSUCCESSFUL)\n",
									netstatus,Status);
				goto cleanup;
			}
			Info->majver=(p101->sv101_version_major & MAJOR_VERSION_MASK);
		}
    }

	RtlInitUnicodeString( &Server, Info->DCName );

	if(Nt4)	{ // force Nt4 style
		Info->majver=4;
		dbgprintf( (0, IDS_FORCENT4, DomainName!=NULL?DomainName:outbuf) );
	}


//    if ( NT_SUCCESS( Status ) )
//		{
//
//	    netstatus = NetServerGetInfo( pMachine, 101, ( LPBYTE *) &p101 );
//		if(netstatus != NERR_Success) {
//           	Status = STATUS_UNSUCCESSFUL;
//			fprintf(stderr,"NetServerGetInfo (101) failed: err 0x%08lx;\n"
//						"    ...now returning Status 0x%08lx (STATUS_UNSUCCESSFUL)\n",
//								netstatus,Status);
//			goto cleanup;
//		}
//		Info->majver=(p101->sv101_version_major & MAJOR_VERSION_MASK);
//    }
		
    if ( NT_SUCCESS( Status ) ) {

        RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

        Status = LsaOpenPolicy( DomainName == NULL ? NULL : &Server,
                                &ObjectAttributes,
                                MAXIMUM_ALLOWED,
                                &Info->Policy
                                );


		if(!NT_SUCCESS(Status)) {
       		resprintf(0,IDS_LSAOPENPOLICY_F1, (Info->DCName[0]==L'\0')?outbuf:Info->DCName);
	        if ( Status == STATUS_ACCESS_DENIED)
            		resprintf(0,IDS_ACCESS_DENIED);
            else	resprintf(0,IDS_ERROR_FORMAT,Status);
            goto cleanup;
        }

       	Info->DomInfoType=DNS;
       	DCInfostr=L"DNS";
        Status = LsaQueryInformationPolicy( Info->Policy,
                                            PolicyDnsDomainInformation,
                                            &(Info->u.DnsDomainInfo )	//the SID is in here...
                                            );
        dbgprintf( (0,IDS_GETDOMAININFOFORDOMAIN_D, DomainName!=NULL?DomainName:outbuf, DCInfostr, Status ));
        if( !NT_SUCCESS( Status ) || Nt4) {	// try at least Primary....
			Info->majver=4;        	
	       	DCInfostr=L"Primary";
            dbgprintf( (0,IDS_PRIMARY_D) );
	       	Info->DomInfoType=Primary;
            Status = LsaQueryInformationPolicy( Info->Policy,
                                                PolicyPrimaryDomainInformation,
                                                &(Info->u.PrimaryDomainInfo )	//the SID is in here...
                                                );
            dbgprintf( (0,IDS_GETDOMAININFOFORDOMAIN_D, DomainName!=NULL?DomainName:outbuf, DCInfostr, Status ) );
        }
        else	{
        	Info->majver=5;
        }

        switch(Info->DomInfoType) {
        case DNS:		sid = Info->u.DnsDomainInfo->Sid;
        				break;
        case Primary:	sid = Info->u.PrimaryDomainInfo->Sid;
        				break;
        }

		if(Dbg) {
			printf("Domain %ws Sid=",DCInfostr);
			PrintSID(sid);
			printf("\n");
		}


    }

	if(Info->DomInfoType==DNS)
		dbgprintf( (0,IDS_DOMAINNAMED,&(Info->u.DnsDomainInfo->DnsDomainName) ) );
		
    if ( !NT_SUCCESS( Status ) )
		//well...
    	goto cleanup;
		//...
cleanup:
	if(DCInfo!=NULL)
	    NetApiBufferFree( DCInfo );

	if(p101!=NULL)
		NetApiBufferFree( p101 );

    return( Status );
}


VOID
FreeDomainInfo(
    IN PTD_DOM_INFO Info
    )
/*++

Routine Description:

    Frees the info returned from GetDomainInfoForDomain

Arguments:

    Info -- Information structure to free

Return Value:

    STATUS_SUCCESS -- Success

--*/
{
	int i;
	
    if ( Info->Policy ) {
        LsaClose( Info->Policy );
        Info->Policy=NULL;
    }

    if ( Info->u.DnsDomainInfo != NULL )
        LsaFreeMemory( Info->u.DnsDomainInfo );
	// Info->u.DnsDomainInfo is inside an union with Info->u.PrimaryDomainInfo
	//on the same position

	if(Info->pTDIX!=NULL)
		LsaFreeMemory(Info->pTDIX);

	//if there's an array of pointers to TI shots returned from LsaEnumerateTrustedDomains...	
	if(Info->pTIs!=NULL) {
		for(i=0; i<Info->nTIs; i++)
			LsaFreeMemory(Info->pTIs[i].pTI);
	}
	
	if(Info->pUI1!=NULL)
		NetApiBufferFree(Info->pUI1);
}


NTSTATUS
GetTrustLinks(
    IN PTD_DOM_INFO pInfo
	)
/*++
Fills an array of trust links information.
	Usually that information will be printed in the form:
	domain_name, trust direction, type, attributes
	)
--*/
{
	NET_API_STATUS   netstatus=NERR_Success;
    NTSTATUS Status = STATUS_SUCCESS;
	
    LSA_ENUMERATION_HANDLE EnumerationContext = 0;
    //needed for NT4 enumeration...
	DWORD UIRead=0L;
	DWORD UITotal=0L;
	DWORD reshandle=0;	// Put 0 for enumeration handles !!!!
		//A value like INVALID_HANDLE_VALUE (that is -1) would make the NetUserEnum to return 0 users...

	if(pInfo->majver>=5) {
	    Status = LsaEnumerateTrustedDomainsEx( pInfo->Policy,
						   &EnumerationContext,
						   &pInfo->pTDIX,
						   0xffffffff,	//ULONG_MAX,
						   &pInfo->TDIXcEntries );

		dbgprintf( (0,IDS_LSAENUMERATETRUSTEDDOMAINSEX_D,GetName(pInfo),Status,pInfo->TDIXcEntries) );
		if(Status==STATUS_NO_MORE_ENTRIES && pInfo->pTDIX==NULL) {
			pInfo->TDIXcEntries=0L;
			Status=STATUS_SUCCESS;	//that means "0 entries"
		}

		return( Status );
	}

	//Enumerate NT4 Inbound trusts:
	netstatus = NetUserEnum( MakeSrvName(pInfo->DCName),
								1,
								FILTER_INTERDOMAIN_TRUST_ACCOUNT,
								(LPBYTE*)(&pInfo->pUI1),
								0xffffffff,	//ULONG_MAX
								&UIRead,
								&UITotal,
								&reshandle
								);
	dbgprintf( (0,IDS_NETUSERENUM_D,GetName(pInfo),netstatus,UIRead) );
	if(netstatus!=NERR_Success) {
		Status = STATUS_UNSUCCESSFUL;
		goto cleanup;
	}
	pInfo->UI1cEntries=UIRead;

	//Enumerate NT4 Outbound trusts:
	{	PLSA_TRUST_INFORMATION	pTIShot=NULL;
		ULONG nShotsize=0;
		struct LsaTIshot *pTIsav=NULL;
	
		do {
				Status=LsaEnumerateTrustedDomains( pInfo->Policy,
								&EnumerationContext,
								&pTIShot,
								0xffffffff,	//ULONG_MAX,
								&nShotsize);

				dbgprintf( (0,IDS_LSAENUMERATETRUSTEDDOMAINS_D,GetName(pInfo),Status,nShotsize) );
				if( (Status != STATUS_SUCCESS) &&
					(Status != STATUS_MORE_ENTRIES) &&
					(Status != STATUS_NO_MORE_ENTRIES)
					) {
						SetLastError( LsaNtStatusToWinError(Status) );
						goto cleanup;
				}
				if(pTIShot!=NULL) {
					if((pInfo->pTIs=realloc(pTIsav=pInfo->pTIs,pInfo->nTIs+1))==NULL) {
						free(pTIsav);
						Status = ERROR_NOT_ENOUGH_MEMORY;
						goto cleanup;
					}
					pInfo->TIcEntries+=nShotsize;
					pInfo->pTIs[pInfo->nTIs].count=nShotsize;
					pInfo->pTIs[pInfo->nTIs].pTI=pTIShot;
					pInfo->nTIs++;
				}
				
		} while (Status != STATUS_NO_MORE_ENTRIES);

		if(Dbg) printf("Total number of entries: %u\n",pInfo->TIcEntries);
		dbgprintf( (0,IDS_LSAENUMERATETRUSTEDDOMAINS_D,GetName(pInfo),Status,pInfo->TIcEntries) );
		if(Status==STATUS_NO_MORE_ENTRIES)
			Status=STATUS_SUCCESS;
		if(pInfo->pTIs==NULL) {
			pInfo->TIcEntries=0L;
		}
	}


cleanup:
	return( Status );	
}

struct bidir_st {
	ULONG index;	// index in the 'Inbound' vector
	char type;		// 'O' - Outbound, 'B' - Bidirectional
};
int __cdecl cmpbidir(const struct bidir_st *pb1, const struct bidir_st *pb2)
{
	if(pb1->index==pb2->index)
		return(0);
	if(pb1->index>pb2->index)
		return(1);
	return(-1);
}

NTSTATUS
PrintTrustLinks(
	IN PTD_DOM_INFO Info
	)
/*++
	Print Trust Links
--*/
{
	ULONG i,j;

	if(Info->majver>=5) {
		for(i=0; i<Info->TDIXcEntries; i++) {
			char c;
			switch(Info->pTDIX[i].TrustDirection)
			{
				case TRUST_DIRECTION_DISABLED:		c='D';	break;
				case TRUST_DIRECTION_INBOUND:		c='I';	break;
				case TRUST_DIRECTION_OUTBOUND:		c='O';	break;
				case TRUST_DIRECTION_BIDIRECTIONAL:	c='B';	break;
				default:							c='-';	break;
			}
			printf("%-32wZ,%c",&Info->pTDIX[i].Name,c);
			switch(Info->pTDIX[i].TrustType&0x000FFFFF)
			{
				case TRUST_TYPE_DOWNLEVEL:
					printf(",T_downlevel");	break;
				case TRUST_TYPE_UPLEVEL:
					printf(",T_uplevel");	break;
				case TRUST_TYPE_MIT:
					printf(",T_mit");		break;
				case TRUST_TYPE_DCE:
					printf(",T_DCE");		break;
				default:
					printf("-");			break;
			}
			if(Info->pTDIX[i].TrustAttributes & TRUST_ATTRIBUTE_NON_TRANSITIVE)
					printf(",A_NonTran");
			else	printf(",_");
			if(Info->pTDIX[i].TrustAttributes & TRUST_ATTRIBUTE_UPLEVEL_ONLY  )
					printf(",A_UpLevelOnly");
			else	printf(",_");
			if(Info->pTDIX[i].TrustAttributes & TRUST_ATTRIBUTE_FILTER_SIDS   )
					printf(",A_FilterSids");
			else	printf(",_");
			if(Info->pTDIX[i].TrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE)
					printf(",A_ForestTrust");
			else	printf(",_");
			if(SidList) {
				printf(",");
				PrintSID(Info->pTDIX[i].Sid);
			}
			printf("\n");
		}

	}
	else {
		//Info->majver<=4
		int shot;
		struct bidir_st *p=NULL, *q=NULL;
		if((p=calloc(Info->TIcEntries,sizeof(struct bidir_st)))==NULL)
			return(ERROR_NOT_ENOUGH_MEMORY);
		//for(q=p,i=0; i<Info->TIcEntries; q++,i++) {
		for(q=p,shot=0; shot<Info->nTIs; shot++) {
			for(i=0; i<Info->pTIs[shot].count; i++,q++) {
				WCHAR buf[1024];
				swprintf(buf,L"%wZ",&Info->pTIs[shot].pTI[i].Name);
				for(j=0; j<Info->UI1cEntries; j++)
					if(wcscmp(buf,CutDlrFromName(Info->pUI1[j].usri1_name))==0)
						break;
				if((q->index=j)<Info->UI1cEntries)	//found...
						q->type='B';	//actually it's a Bidir link...
				else	q->type='O';	//or this is a "true" Outbound...
			}
		}
		//print Outbound and Bidirectional links
		//for(q=p,i=0; i<Info->TIcEntries; q++,i++)
		for(q=p,shot=0; shot<Info->nTIs; shot++)
			for(i=0; i<Info->pTIs[shot].count; i++,q++)
				printf("%-32wZ,%c,T_downlevel,_,_,_,_\n",&Info->pTIs[shot].pTI[i].Name,q->type);
		qsort(p,Info->TIcEntries,sizeof(struct bidir_st),cmpbidir);
		//print Inbound links
		for(q=p,j=i=0; i<Info->UI1cEntries; i++) {
			if(j<Info->TIcEntries && q->index==i) {	//if it was a Bidirectional, it was already printed...
					j++; q++;
					continue;
			}
			printf("%-32ws,I,T_downlevel,_,_,_,_\n",CutDlrFromName(Info->pUI1[i].usri1_name));
		}
		if(p!=NULL)
			free(p);
	}

	return( STATUS_SUCCESS );

}



NTSTATUS
CreateNT5TrustDomObject(
    IN PTD_DOM_INFO Local,
    IN PTD_DOM_INFO Remote,
    IN PWSTR Password,
    IN BOOLEAN Downlevel,
    IN BOOLEAN Mit,
    IN ULONG Direction
    )
/*++
Routine Description:
    Creates the trusted domain object on an NT5 domain (DS based)

Arguments:
    Local -- Information about the domain doing the trust
    Remote -- Information about the domain being trusted
    Password -- Password to set on the trust
    Downlevel -- If TRUE, create this as a downlevel trust
    Mit -- If TRUE, creates this as an Mit style trust
    Direction -- Which direction to make the link in.
Return Value:
    STATUS_SUCCESS -- Success
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
	WCHAR Domain[1024]={L'\0'};
	WCHAR DnsDomain[1024]={L'\0'};

    TRUSTED_DOMAIN_INFORMATION_EX TDIEx;
    LSA_AUTH_INFORMATION AuthData;
    TRUSTED_DOMAIN_AUTH_INFORMATION AuthInfoEx;
    PSID Sid = NULL;

	swprintf(Domain,L"%wZ",GetFlatName(Remote));
	swprintf(DnsDomain,L"%wZ",GetName(Remote));

    Status  = NtQuerySystemTime( &AuthData.LastUpdateTime );

    if ( !NT_SUCCESS( Status ) ) {

        return( Status );
    }

    AuthData.AuthType = TRUST_AUTH_TYPE_CLEAR;
    AuthData.AuthInfoLength = wcslen( Password ) * sizeof( WCHAR );
    AuthData.AuthInfo = (PUCHAR)Password;


    RtlZeroMemory( &AuthInfoEx, sizeof( LSA_AUTH_INFORMATION ) );

    if ( Direction & TRUST_DIRECTION_INBOUND ) {
        AuthInfoEx.IncomingAuthInfos = 1;
        AuthInfoEx.IncomingAuthenticationInformation = &AuthData;
        AuthInfoEx.IncomingPreviousAuthenticationInformation = NULL;
    }

    if ( Direction & TRUST_DIRECTION_OUTBOUND ) {
        AuthInfoEx.OutgoingAuthInfos = 1;
        AuthInfoEx.OutgoingAuthenticationInformation = &AuthData;
        AuthInfoEx.OutgoingPreviousAuthenticationInformation = NULL;
    }

    if (!Mit)
    {
        RtlCopyMemory( &TDIEx.Name, GetName(Remote), sizeof( UNICODE_STRING ) );
        RtlCopyMemory( &TDIEx.FlatName, GetFlatName(Remote), sizeof( UNICODE_STRING ) );
        switch(Remote->DomInfoType) {
        case DNS:		TDIEx.Sid = Remote->u.DnsDomainInfo->Sid;
        				break;
        case Primary:	TDIEx.Sid = Remote->u.PrimaryDomainInfo->Sid;
        				break;
        default:		Status = GenerateRandomSID( &Sid);

				        if (!NT_SUCCESS(Status))
				        {
				            return(Status);
				        }
				        TDIEx.Sid = Sid;
				        break;
        }

        //TDIEx.Sid = (Remote->DomInfoType==DNS?Remote->u.DnsDomainInfo->Sid:Remote->u.PrimaryDomainInfo->Sid);
    }
    else
    {
//		printf("****Set %ws for the Name and FlatName in the trust object... GetFlatName(Local)=%wZ\n",
//						Domain,GetFlatName(Local));
        RtlInitUnicodeString(
            &TDIEx.Name,
            Domain
            );
        RtlInitUnicodeString(
            &TDIEx.FlatName,
            Domain
            );

		Status = GenerateRandomSID( &Sid);

        if (!NT_SUCCESS(Status))
        {
            return(Status);
        }
        TDIEx.Sid = Sid;
    }
    TDIEx.TrustDirection = Direction;
    TDIEx.TrustType = Mit ? TRUST_TYPE_MIT : (Downlevel ? TRUST_TYPE_DOWNLEVEL : TRUST_TYPE_UPLEVEL);
    TDIEx.TrustAttributes = 0;

    Status = LsaCreateTrustedDomainEx( Local->Policy,
                                       &TDIEx,
                                       &AuthInfoEx,
                                       TRUSTED_ALL_ACCESS,
                                       &Local->TrustedDomain );

    if (!NT_SUCCESS(Status)) {
        dbgprintf( (0,IDS_LSACREATETRUSTEDDOMAINEX_F, GetName(Local), DnsDomain, Status) );
        if(Status==STATUS_OBJECT_NAME_COLLISION)
        	dbgprintf( (0,IDS_STATUS_OBJECT_NAME_COLLISION, GetName(Local), DnsDomain) );
    }
    else	LsaClose(Local->TrustedDomain);	//not interested in the actual handle...

    if (Sid != NULL)
    {
        RtlFreeSid(Sid);
    }
    return( Status );
}

NTSTATUS
CreateTrustLink(
	IN PTD_DOM_INFO pInfoA,
	IN PTD_DOM_INFO pInfoB,
    IN PWSTR Password,
    IN BOOLEAN Downlevel,
    IN BOOLEAN Mit,
    IN BOOLEAN ParentChild,
    IN ULONG Direction
	)
{
	NET_API_STATUS   netstatus=NERR_Success;
	NTSTATUS Status = STATUS_SUCCESS;
	PWSTR pDomain=NULL;

	if(	!Force	// if -force was NOT specified...
		&&
		!Mit	// for a non-MIT trust...
		&&
		(pInfoA->DomInfoType==Minimal || pInfoB->DomInfoType==Minimal)
				// creating links not supported in 'Minimal' mode...
		)
		return( STATUS_UNSUCCESSFUL );

	if(pInfoA->majver>=5) {
		Status = CreateNT5TrustDomObject(
					pInfoA,
					pInfoB,
					Password,
					Downlevel,Mit,Direction
					);

		return( Status );
	}

	////////////////////////////////////////////////////////////////////////
	//for a NT4 domain...
	if(Mit || ParentChild)
		return (STATUS_INVALID_PARAMETER);

	if(Direction & TRUST_DIRECTION_INBOUND) {
		USER_INFO_1 UI1;
		DWORD dwParmErr=0xffffffff;

		memset(&UI1,0,sizeof(UI1));

		pDomain=AddDlrToDomainName(pInfoB);

	    //  Create the necessary SAM account.
	    UI1.usri1_name = pDomain;
	    UI1.usri1_password = Password;
	    UI1.usri1_password_age = 0;
	    UI1.usri1_priv = USER_PRIV_USER;
	    UI1.usri1_home_dir = NULL;
	    UI1.usri1_comment = NULL;
	    UI1.usri1_flags = UF_INTERDOMAIN_TRUST_ACCOUNT | UF_SCRIPT;
	    UI1.usri1_script_path = NULL;

	    netstatus = NetUserAdd(
	                MakeSrvName(pInfoA->DCName),
	                1,
	                (LPBYTE)&UI1,
	                &dwParmErr
	                );
		
		if(netstatus != NERR_Success) {
				resprintf(0,IDS_NETUSERADD_F,pInfoA->DCName,pDomain,netstatus);
				if(netstatus==NERR_UserExists)
					resprintf(0,IDS_NERR_UserExists,pInfoA->DCName,pDomain);
				goto Done;
		}
	}
	if(Direction & TRUST_DIRECTION_OUTBOUND) {
		LSA_TRUST_INFORMATION TI;
		PUNICODE_STRING puSecret;
		UNICODE_STRING uPass;
		LSA_HANDLE hSecret;
		

		swprintf(Domain,L"%wZ",GetFlatName(pInfoB));
		
		RtlInitUnicodeString(&TI.Name,Domain);
		{	PSID Sid = NULL;
	        switch(pInfoB->DomInfoType) {
	        case DNS:		TI.Sid = pInfoB->u.DnsDomainInfo->Sid;
	        				break;
	        case Primary:	TI.Sid = pInfoB->u.PrimaryDomainInfo->Sid;
	        				break;
	        default:		Status = GenerateRandomSID( &Sid);

					        if (!NT_SUCCESS(Status))
					        {
					            return(Status);
					        }
					        TI.Sid = Sid;
					        break;
	        }
		}

		//TI.Sid=(pInfoB->DomInfoType==DNS?pInfoB->u.DnsDomainInfo->Sid:pInfoB->u.PrimaryDomainInfo->Sid);

		Status = LsaCreateTrustedDomain(
						pInfoA->Policy,
						&TI,
						TRUSTED_ALL_ACCESS,
						&pInfoA->TrustedDomain
						);
		if( !NT_SUCCESS(Status)) {
			resprintf(0,IDS_LSACREATETRUSTEDDOMAIN_F,Status);
			goto Done;
		}
		else	LsaClose(pInfoA->TrustedDomain);	//not interested in the actual handle...
			
		puSecret=MakeSecretName(pInfoB);

		Status = LsaCreateSecret(
						pInfoA->Policy,
						puSecret,
						SECRET_ALL_ACCESS,
						&hSecret
						);
		if(!NT_SUCCESS(Status)) {
			resprintf(0,IDS_LSACREATESECRET_F,Status);
			goto Done;
		}
		
		RtlInitUnicodeString(&uPass,Password);
		Status=LsaSetSecret(
						hSecret,
						&uPass,
						NULL
						);
		if(!NT_SUCCESS(Status)) {
			resprintf(0,IDS_LSASETSECRET_F,Status);
			LsaDelete(hSecret); hSecret=NULL;
			goto Done;
		}
		if(hSecret!=NULL)
			LsaClose(hSecret);
	}
			
Done:
//	if(pInfoA->TrustedDomain!=NULL)
//		LsaClose(pInfoA->TrustedDomain);
	return(Status);
}




NTSTATUS
DeleteTrustLink(
    IN PTD_DOM_INFO pInfoA,
    IN PTD_DOM_INFO pInfoB
    )
/*++

Routine Description:

    Deletes on A trusted domain things related to a trust to B

Return Value:

    STATUS_SUCCESS -- Success

--*/
{
	NET_API_STATUS netstatus=NERR_Success;
    NTSTATUS Status=STATUS_SUCCESS;
//#define NO_TRUST_OBJECTS 	1
//#define NO_SECRETS			2
//#define NO_TRUST_ACCOUNTS	4
//    DWORD dwFlag=0;
    ULONG i, ix=0;
	PSID sid=NULL;


	PTRUSTED_DOMAIN_INFORMATION_EX pTDIx = NULL;
	PLSA_UNICODE_STRING puDomBName=GetName(pInfoB);
	PLSA_UNICODE_STRING puDomBFlatName=GetFlatName(pInfoB);
	PLSA_UNICODE_STRING puSecret;

	dbgprintf( (0,IDS_DELTRUSTFROMTO,GetName(pInfoA),puDomBName) );


	Status = GetTrustLinks(pInfoA);
	if(!NT_SUCCESS(Status)) {
		resprintf(0,IDS_GETTRUSTLINKS_F,GetName(pInfoA),Status);
		return(Status);
	}
	//try to find a trust link to B...
	if(pInfoA->majver>=5) {

		// now try to get a LSA_HANDLE to a (possible) trust object with this domain...
		// if not found any, that Info->TrustedDomain will remain NULL
		
		Status = LsaQueryTrustedDomainInfoByName(
					    pInfoA->Policy,
					    puDomBName,					//IN PLSA_UNICODE_STRING TrustedDomainName
					    TrustedDomainInformationEx,	//IN TRUSTED_INFORMATION_CLASS InformationClass,
					    &pTDIx						//OUT PVOID *Buffer
					    );
		if ( !NT_SUCCESS( Status ) ) {
			
			if(Status==STATUS_OBJECT_NAME_NOT_FOUND) {
					pInfoA->TrustedDomain=NULL;
					dbgprintf( (0,IDS_NO_TRUST_OBJECT_D,GetName(pInfoA),puDomBName) );
					Status=STATUS_SUCCESS;
			}
			else	resprintf(0,IDS_LSAQUERYTRUSTEDDOMAININFOBYNAME_F,GetName(pInfoA),puDomBName,Status);
			goto cleanup;
		}

		if(pTDIx->Sid==NULL)
			dbgprintf( (0,IDS_LSAQUERYNULLSID) ); //"NULL sid returned by LsaQueryTrustedDomainInfoByName\n"
		sid=pTDIx->Sid;
		//check to see if the trusted domain object can be opened with that sid...
		if(sid!=NULL) {
			LSA_HANDLE td;
			Status=LsaOpenTrustedDomain(pInfoA->Policy,
						sid,TRUSTED_ALL_ACCESS,&td);
			if(NT_SUCCESS( Status ))	// if it was ok...
				LsaClose(td);			// ...just close the handle (leave the following code to open it again later)
			else {						// if failed...
				if(Status==STATUS_INVALID_PARAMETER && Force) {
					printf("LsaOpenTrustedDomain for the trust to %wZ failed with STATUS_INVALID_PARAMETER (i.e. the sid is bad)\n"
						   "Trying to set a valid sid...\n",puDomBName);
										// if was STATUS_INVALID_PARAMETER (i.e. the sid) and '-overwritesid' option used...
					RtlFreeSid(sid);	// free the old sid
					sid=NULL;			// make it NULL as a signal to the next 'if' (see below) to
				}						// pick it up and set a new random valid sid in its place
			}
		}

		if(sid==NULL) {
			// try to put a sid THERE ...
			Status = GenerateRandomSID ( &pTDIx->Sid );
			if (!NT_SUCCESS( Status ))
				goto cleanup;

			Status = LsaSetTrustedDomainInfoByName(
						    pInfoA->Policy,
						    puDomBName,					//IN PLSA_UNICODE_STRING TrustedDomainName
						    TrustedDomainInformationEx,	//IN TRUSTED_INFORMATION_CLASS InformationClass,
						    pTDIx						//IN PVOID Buffer
						    );
			if(!NT_SUCCESS( Status )) {
				resprintf(0,IDS_LSASETTRUSTEDDOMAININFOBYNAME_F,GetName(pInfoA),puDomBName,Status);
				goto cleanup;		
			}
			sid=pTDIx->Sid;
			if(sid==NULL)
				resprintf(0,IDS_LSASETNULLSID); //"LsaSetTrustedDomainInfoByName: NULL sid\n"
		}
	}
	else {	// pInfoA->majver<=4
		//check for Outbound....	
		int shot;
		//for(ix=0; ix<pInfoA->TIcEntries; ix++)
		for(shot=0; shot<pInfoA->nTIs; shot++)
			for(ix=0; ix<pInfoA->pTIs[shot].count; ix++)
				if(RtlEqualUnicodeString(&pInfoA->pTIs[shot].pTI[ix].Name,puDomBFlatName,TRUE))
													//it was FALSE, i.e. case sensitive
					goto out_of_loop;
		out_of_loop:
		if(ix<pInfoA->TIcEntries)
			sid=pInfoA->pTIs[shot].pTI[ix].Sid;
		else {
			printf("No OUTBOUND trust to %wZ found...\n",puDomBFlatName);
		}
	}

	if(sid==NULL)
		dbgprintf( (0,IDS_NULLSID) );	//"#### NULL sid\n"

	if(sid!=NULL) {
		Status=LsaOpenTrustedDomain(
					pInfoA->Policy,
					sid,
					TRUSTED_ALL_ACCESS,
					&pInfoA->TrustedDomain
					);
		//printf("Handle=0x%08lx (Status: 0x%08lx)\n",pInfoA->TrustedDomain,Status);
		if(!NT_SUCCESS(Status)) {
			resprintf(0,IDS_LSAOPENTRUSTEDDOMAIN_F,Status);
			//return(Status);
		}
		dbgprintf( (0,IDS_LSATRUSTHANDLE,pInfoA->TrustedDomain,Status) );
	}
	else {
		if(	//pInfoA->majver<=4 &&
			ix<pInfoA->TIcEntries) {
				resprintf(0,IDS_NONNULL_SID,puDomBName);
				Status=STATUS_INVALID_SID;
		}
		else	//simply no trust objects...
			Status=STATUS_SUCCESS;
	}

	if(pInfoA->TrustedDomain) {
		dbgprintf( (0,IDS_LSADELOBJ,pInfoA->TrustedDomain) );
	    Status = LsaDelete( pInfoA->TrustedDomain );
	}

    if (!NT_SUCCESS(Status))
        dbgprintf( (0,IDS_DELETION_F,GetName(pInfoA), Status) );

	//NT4 only section...
	if(pInfoA->majver<=4) {
		LSA_HANDLE hSecret;
		//delete secret thing...
		puSecret=MakeSecretName(pInfoB);

		Status = LsaOpenSecret(
						pInfoA->Policy,
						puSecret,
						SECRET_ALL_ACCESS,
						&hSecret
						);
		if(Status==STATUS_OBJECT_NAME_NOT_FOUND) {
			dbgprintf( (0,IDS_SECRET_NOT_FOUND_D,puSecret) );
			Status=STATUS_SUCCESS;
		}
		else {
			if(!NT_SUCCESS(Status)) {
					resprintf(0,IDS_LSAOPENSECRET_F,Status);
			}
			else {
				Status = LsaDelete(hSecret);	hSecret=NULL;
				if(!NT_SUCCESS(Status))
					resprintf(0,IDS_LSADELETE_F,puSecret,Status);
			}
		}
		//delete Interdomain Trust Account....
		netstatus = NetUserDel(
						MakeSrvName(pInfoA->DCName),
						AddDlrToDomainName(pInfoB)
						);
		if(netstatus!=NERR_Success && netstatus!=NERR_UserNotFound) {
				resprintf(0,IDS_NETUSERDEL_F,AddDlrToDomainName(pInfoB),netstatus);
				Status=STATUS_UNSUCCESSFUL;
		}
	}

cleanup:
	if(pTDIx!=NULL)
		LsaFreeMemory(pTDIx);
	if(sid!=NULL)
		RtlFreeSid(sid);

    return( Status );
}

NTSTATUS
CheckTrustLink(
    IN PTD_DOM_INFO pInfoA,
    IN PTD_DOM_INFO pInfoB
    )
/*++

Routine Description:

    Checks on A trusted domain sids related to a trust to B

Return Value:

    STATUS_SUCCESS -- Success

--*/
{
	NET_API_STATUS netstatus=NERR_Success;
    NTSTATUS Status=STATUS_SUCCESS;

	PSID sid=NULL, sidb=NULL;
	BOOL UnknownRemoteSid=FALSE;

	PTRUSTED_DOMAIN_INFORMATION_EX pTDIx = NULL;
	PLSA_UNICODE_STRING puDomBName=GetName(pInfoB);
	PLSA_UNICODE_STRING puDomBFlatName=GetFlatName(pInfoB);

	dbgprintf( (0,IDS_CHKTRUSTFROMTO,GetName(pInfoA),puDomBName) );

	//try to find a trust link to B...
	if(pInfoA->majver>=5) {

		// now try to get a LSA_HANDLE to a (possible) trust object with this domain...
		// if not found any, that Info->TrustedDomain will remain NULL
		Status = LsaQueryTrustedDomainInfoByName(
					    pInfoA->Policy,
					    puDomBName,					//IN PLSA_UNICODE_STRING TrustedDomainName
					    TrustedDomainInformationEx,	//IN TRUSTED_INFORMATION_CLASS InformationClass,
					    &pTDIx						//OUT PVOID *Buffer
					    );
		if ( !NT_SUCCESS( Status ) ) {
			if(Status==STATUS_OBJECT_NAME_NOT_FOUND) {
					pInfoA->TrustedDomain=NULL;
					dbgprintf( (0,IDS_NO_TRUST_OBJECT_D,GetName(pInfoA),puDomBName) );
					Status=STATUS_SUCCESS;
			}
			else	resprintf(0,IDS_LSAQUERYTRUSTEDDOMAININFOBYNAME_F,GetName(pInfoA),puDomBName,Status);
			goto cleanup;
		}
		sid=pTDIx->Sid;
	}
	else {	// pInfoA->majver<=4
		//check for Outbound....
		int shot;
        ULONG i;

		for(shot=0; shot<pInfoA->nTIs; shot++)
			for(i=0; i<pInfoA->pTIs[shot].count; i++)
				if(RtlEqualUnicodeString(&pInfoA->pTIs[shot].pTI[i].Name,puDomBFlatName,TRUE))
													//it was FALSE, i.e. case sensitive
					goto out_of_loop;
		out_of_loop:
		if(i<pInfoA->TIcEntries)
			sid=pInfoA->pTIs[shot].pTI[i].Sid;

	}

    switch(pInfoB->DomInfoType) {
    case DNS:		sidb = pInfoB->u.DnsDomainInfo->Sid;
    				break;
    case Primary:	sidb = pInfoB->u.PrimaryDomainInfo->Sid;
    				break;
    default:		sidb=NULL;
    				UnknownRemoteSid=TRUE;
			        break;
    }

	
	//now sid contains the Sid of the trust object, if any... (on NT4, only the OUTBOUND
	//end of the trust has a trust object...)
	//Print them and compare them...
	printf("TDO on %wZ: sid:\t",GetName(pInfoA));
	PrintSID(sid);
	printf("\n");
	if(UnknownRemoteSid) {
		if(pInfoB->majver<=4)
			printf("Domain %wZ does not have a trust object (possibly an NT4 only with an INBOUND trust)\n",puDomBName);
		else
			printf("Sid for domain %wZ is unknown (possible localonly used or error getting Dns/Primary DomainInfo)",puDomBName);
	}
	else {
		if(sid!=NULL && IsValidSid(sid) && sidb!=NULL && IsValidSid(sidb)) {
			if(EqualSid(sid,sidb))
					printf("Sid on %wZ is the same:\t",puDomBName);
			else	printf("Sid on %wZ is different:\t",puDomBName);
		}
		else {
			printf("Sid on %wZ: ",puDomBName);
		}
		PrintSID(sidb);
	}
	printf("\n");

cleanup:
	if(pTDIx!=NULL)
		LsaFreeMemory(pTDIx);

    return( Status );
}

	
void ParseForDCName(WCHAR DomBuf[], WCHAR DCBuf[])
{
	WCHAR *pw;
	DCBuf[0]=L'\0';
	wcstok(DomBuf,L":");
	if((pw=wcstok(NULL,L":"))!=NULL)
		wcscpy(DCBuf,pw);
	if(DomBuf[0]==L'*' || wcscmp(DomBuf,L"(local)")==0)
		DomBuf[0]=L'\0';
}


//the NameValidate stuff below taken from icanon.h
NET_API_STATUS
NET_API_FUNCTION
I_NetNameValidate(
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  Name,
    IN  DWORD   NameType,
    IN  DWORD   Flags    );

//NameType:
#define NAMETYPE_DOMAIN         6
//Flags:
//#define LM2X_COMPATIBLE                 0x80000000L


#ifdef COMMENT
#define CTRL_CHARS_0   L"\001\002\003\004\005\006\007"
#define CTRL_CHARS_1   L"\010\011\012\013\014\015\016\017"
#define CTRL_CHARS_2   L"\020\021\022\023\024\025\026\027"
#define CTRL_CHARS_3   L"\030\031\032\033\034\035\036\037"
#define CTRL_CHARS_STR CTRL_CHARS_0 CTRL_CHARS_1 CTRL_CHARS_2 CTRL_CHARS_3

#define ILLEGAL_DOMAIN_CHARS_STR
#define ILLEGAL_DOMAIN_NAME_CHARS_STR  L"\"/\\[]:|<>+;,?" CTRL_CHARS_STR L"*" L" "
#endif //COMMENT

BOOL ValidateDomain(WCHAR DomBuf[])
{	WCHAR Buf[MAX_PATH + 1]= { L'\0' };
	WCHAR *p;
	int DomBuf_len, oem_name_len;
	NET_API_STATUS netstatus=NERR_Success;
	
	if(DomBuf==NULL || DomBuf[0]==L'\0')
		return(TRUE);

	wcscpy(Buf,DomBuf);
	//for DNS name, test each component; for a flat name, there's already only one...
	for(p=wcstok(Buf,L"."); p!=NULL; p=wcstok(NULL,L"."))
		if((netstatus=I_NetNameValidate(NULL,p,NAMETYPE_DOMAIN,0))!=NERR_Success)
			return(FALSE);
	return(TRUE);

#ifdef COMMENT
	DomBuf_len=wcslen(DomBuf);
    // oem_name_len : length in bytes in oem character set
    // name_len     : ifdef UNICODE
    //                    character length in unicode
    //                else
    //                    length in bytes in oem character set
    //
	{
        BOOL fUsedDefault;
        oem_name_len = WideCharToMultiByte(
                         CP_OEMCP,       // UINT CodePage
                         0,              // DWORD dwFlags
                         DomBuf,         // LPWSTR lpWideChar
                         DomBuf_len,     // int cchWideChar
                         NULL,           // LPSTR lpMultiByteStr
                         0,              // int cchMultiByte
                         NULL,           // use system default char
                         &fUsedDefault); //
	}

	if(oem_name_len<1 || oem_name_len>=DNLEN)
		return(FALSE);

	if(wcscspn(DomBuf,ILLEGAL_DOMAIN_NAME_CHARS_STR) < DomBuf_len)
		return(FALSE);

	return(TRUE);
#endif //COMMENT
}

#define ARG_CASE_S	0x8000	// case sensitive argument

#define BOOL_ARG(argvec,a_index,var)	{if((argvec)[(a_index)].b) (var)=(BOOLEAN)((argvec)[(a_index)].b);}
enum e_arg_type { ARG_S, ARG_U, ARG_B, ARG_I, ARG_L, ARG_UD };
struct _arg_st {
	char *name;
	union {
		char *s;
		ULONG u;
		BOOL b;
		int i;
		long l;
		void (*fct)(char *);
	};
	enum e_arg_type t;
};
#define NELEMS(a)  (sizeof(a)/sizeof(a[0]))
	
int process_opt(int argc, char **argv, struct _arg_st arg[])
{ // command line parameters processing
  int i,j,k; char *p; struct _arg_st *pa;
  int r=1;
  // process options
  for (i=1; i<argc; i++) {
     if (argv[i][0]=='/' || argv[i][0]=='-') {
   		p=strtok(argv[i]+1,":");
     	for(j=0; arg[j].name!=NULL; j++) {
     		if(p!=NULL && (	((arg[j].t & ARG_CASE_S) && strcmp(p,arg[j].name)==0) ||
     					    _stricmp(p,arg[j].name)==0 ) )
     			break;
     	}
     	if(arg[j].name==NULL) {
     		resprintf(1,IDS_UNKNOWN_OPTION,p);
     		r=0;
     		continue;
     	}
		switch(arg[j].t)
		{
			case ARG_B:
				if(	(p=strtok(NULL,""))==NULL
					|| _stricmp(p,"on")==0
					|| _stricmp(p,"true")==0)
						arg[j].b=TRUE;
				else	arg[j].b=FALSE;
				break;
			case ARG_S:
				if((p=strtok(NULL,""))!=NULL)
						arg[j].s=_strdup(p);
				else	arg[j].s=NULL;
				break;
			case ARG_U:
				if((p=strtok(NULL,""))!=NULL)
						arg[j].u=(ULONG)atol(p);
				break;							
			case ARG_L:
				if((p=strtok(NULL,""))!=NULL)
						arg[j].l=atol(p);
				break;							
			case ARG_I:
				if((p=strtok(NULL,""))!=NULL)
						arg[j].i=atoi(p);
				break;
			case ARG_UD:
				p=strtok(NULL,"");
				(*arg[j].fct)(p);
				break;
		}
     }
  }
  return(r);
}


// options
enum e_arg_idx {	A_LIST, A_BOTH, A_IN, A_OUT,
					A_UNTRUST, A_CHECK,
                    A_VERIFY,
					A_LOCALONLY, A_DOWNLEVEL, A_MIT, A_PARENT,
					A_DEBUG,
					A_PW,
					A_FORCE,
					A_NT4,
					A_SIDLIST,
					A_LASTARG };
struct _arg_st opt_arg[]={
	{"list",		NULL,	ARG_B},	// A_LIST
	{"both",		NULL,	ARG_B},	// A_BOTH
	{"in",			NULL,	ARG_B},	// A_IN
	{"out",			NULL,	ARG_B},	// A_OUT
	{"untrust",		NULL,	ARG_B},	// A_UNTRUST
	{"sidcheck",	NULL,	ARG_B},	// A_CHECK
    {"verify",      NULL,   ARG_B}, // A_VERIFY
	{"localonly",	NULL,	ARG_B},	// A_LOCALONLY
	{"downlevel",	NULL,	ARG_B},	// A_DOWNLEVEL
	{"mit",			NULL,	ARG_B},	// A_MIT
	{"parent",		NULL,	ARG_B},	// A_PARENT
	{"debug",		NULL,	ARG_B},	// A_DEBUG
	{"pw",			NULL,	ARG_S},	// A_PW
	{"force",		NULL,	ARG_B},	// A_FORCE
	{"nt4",			NULL,	ARG_B},	// A_NT4
	{"sidlist",		NULL,	ARG_B},	// A_SIDLIST
	{NULL,			NULL}
};


INT
__cdecl main (		// it was _CRTAPI1
    int argc,
    char **argv)
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS StatusL = STATUS_SUCCESS;
    NTSTATUS StatusR = STATUS_SUCCESS;

    WCHAR  ADomain[MAX_PATH + 1]= { L'\0' };
    WCHAR  BDomain[MAX_PATH + 1]= { L'\0' };

    WCHAR  ADC[MAX_PATH + 1]= { L'\0' };
    WCHAR  BDC[MAX_PATH + 1]= { L'\0' };	// BDC means just DC for machine B and NOT B(ackup) DC !!!...

    WCHAR  Xbuf[MAX_PATH + 1]= { L'\0' };	// general purpose buffer
    WCHAR  Ybuf[MAX_PATH + 1]= { L'\0' };	// general purpose buffer

    INT i,j;

    BOOLEAN List=FALSE;
	BOOLEAN Both = FALSE, DirIn=FALSE, DirOut=FALSE;
    BOOLEAN LocalOnly = FALSE, Untrust = FALSE, Downlevel = FALSE, Parent = FALSE;
    BOOLEAN Check=FALSE;
    BOOLEAN Mit = FALSE;
    BOOLEAN LocalCreated = FALSE;
    BOOL Verify = FALSE;
    // BOOLEAN Force = FALSE; moved global
    // BOOLEAN Nt4 = FALSE; this is global
	// BOOLEAN Dbg = FALSE; this is global

	DWORD DirectionLocal=0, DirectionRemote=0;

    WCHAR PasswordBuff[1024];
    PWSTR  Password = NULL;

    TD_DOM_INFO Local={0},
    			Remote={0};

	LSA_UNICODE_STRING uDomNameL,uDomNameR;

	// help requested? display it and exit ...
    if ( argc<2 ||
    	 _stricmp( argv[1], "-?") == 0 ||
         _stricmp( argv[1], "/?") == 0 ) {
		        Usage();
		        goto Done;
    }

	hInst=GetModuleHandle(NULL);


    RtlZeroMemory( &Local, sizeof( TD_DOM_INFO ) );
    RtlZeroMemory( &Remote, sizeof (TD_DOM_INFO ) );

	if(!process_opt(argc,argv, opt_arg)) {
        Status = STATUS_INVALID_PARAMETER;
        Usage();
        goto Done;
	}

	BOOL_ARG(opt_arg,A_LIST,	List		);
	BOOL_ARG(opt_arg,A_BOTH,	Both		);
	BOOL_ARG(opt_arg,A_IN,		DirIn		);
	BOOL_ARG(opt_arg,A_OUT,		DirOut		);
	BOOL_ARG(opt_arg,A_UNTRUST,	Untrust		);
	BOOL_ARG(opt_arg,A_CHECK,	Check		);
	BOOL_ARG(opt_arg,A_VERIFY,	Verify		);
	BOOL_ARG(opt_arg,A_LOCALONLY,LocalOnly	);
	BOOL_ARG(opt_arg,A_DOWNLEVEL,Downlevel	);
	BOOL_ARG(opt_arg,A_MIT,		Mit			);
	BOOL_ARG(opt_arg,A_PARENT,	Parent		);
	BOOL_ARG(opt_arg,A_DEBUG,	Dbg			);
	BOOL_ARG(opt_arg,A_FORCE,	Force		);
	BOOL_ARG(opt_arg,A_NT4,		Nt4			);
	BOOL_ARG(opt_arg,A_SIDLIST,	SidList		);

	//put this after Dbg variable is set
	if(Dbg)
		printf("TRUSTDOM - (ver %ws)\n",VER_FILEVERSION_LSTR);

	//get password (if any)
	if(opt_arg[A_PW].s)
			mbstowcs( PasswordBuff, opt_arg[A_PW].s, strlen( opt_arg[A_PW].s )+1 );
	else	PasswordBuff[0]='\0';

	// process normal command line arguments (positional)
	for (j=0,i=1; i<argc; i++) {
	 if (!(argv[i][0]=='/' || argv[i][0]=='-')) {
	    switch(j) {
	    case 0:
	    	{	WCHAR *pws;
	            mbstowcs(ADomain, argv[i], strlen(argv[i]) + 1 );

	            if((pws=wcschr(ADomain,L','))!=NULL) {
	            	*pws=L'\0';
	            	wcscpy(BDomain,pws+1);
	            }
	            else {
	            	wcscpy(BDomain,ADomain);
	            	ADomain[0]=L'\0';
	            }
	    	}
			break;
	    }
	 j++;
	 }
	}

	ParseForDCName(ADomain,ADC);
	ParseForDCName(BDomain,BDC);

	dbgprintf( (0,IDS_DOMARGUMENTS,ADomain,ADC[0]?L":":L"",ADC,BDomain,BDC[0]?L":":L"",BDC) );

	resprintf(2,IDS_WARNING);
	wcscpy(Xbuf,outbuf);
	resprintf(2,IDS_ERROR);
	wcscpy(Ybuf,outbuf);


	//Parameter adjust
	if(SidList)
		List=TRUE;

	//Domain names check:
	{	WCHAR *s=NULL;
		BOOL ba, bb;
		if(	!(ba=ValidateDomain(s=ADomain)) ||
			!(bb=ValidateDomain(s=BDomain))) {
				resprintf(0,IDS_INVALID_DOMAIN_NAME,s);
				Status = STATUS_INVALID_PARAMETER;
				goto Done;
		}
	}

	// Parameter constraints:

    // '-parent' REQUIRES '-both'
	if (Parent && !Both) {
		if(!Force)
			Status = STATUS_INVALID_PARAMETER;
		resprintf(0,IDS_PARENT_REQ_BOTH,(Force?Xbuf:Ybuf));
	}
    // MIT trusts are always local only
    if (Mit && (!LocalOnly || !Both)) {
    	resprintf(0,IDS_MIT_LOCAL_ONLY_BOTH);
        LocalOnly = TRUE;
        Both = TRUE;
    }
    //
    // Validate the parameters
    //
    //specifying both in and out means, yes, '-both'...
	if(DirIn && DirOut)
		Both=TRUE;

	if(List && Mit)
	    Status = STATUS_INVALID_PARAMETER;

	if((!List && BDomain[0]==L'\0') || (List && ADomain[0]!=L'\0'))
	    Status = STATUS_INVALID_PARAMETER;

    if ( Untrust == TRUE && (Downlevel)) // || Mit || Both ) )  // changed from Both || LocalOnly ||...
        Status = STATUS_INVALID_PARAMETER;

//    if(LocalOnly == TRUE  && Both == FALSE)
//        Status = STATUS_INVALID_PARAMETER;;

    if (Mit && (Downlevel || Parent ))
        Status = STATUS_INVALID_PARAMETER;
    // end validating parameters

    if( Status == STATUS_INVALID_PARAMETER ) {
        Usage();
        goto Done;
    }

	if(!Untrust && !List && !Verify) {	//check password... otherwise ignore
        if(wcscmp(PasswordBuff,L"*")==0)
        	GetPassword(PasswordBuff,1024);
        Password = PasswordBuff;
	}



	////////////////////////////////////////////////////////////////////////////////
	// list || verify operation: simplified GetDomainInfo scenario...
	////////////////////////////////////////////////////////////////////////////////
	if ( List ) {
		ULONG i;
		
	    Status = GetDomainInfoForDomain((BDomain[0]==L'\0'?NULL:BDomain),BDC,&Remote, Mit );
	    if (!NT_SUCCESS( Status ) )
	        goto Done;
		Status = GetTrustLinks( &Remote );
	    if (Status!=STATUS_NO_MORE_ENTRIES && !NT_SUCCESS( Status ) )
	        goto Done;

		Status = PrintTrustLinks( &Remote );

		goto Done;		
	} else
	////////////////////////////////////////////////////////////////////////////////
	// verify operation
	////////////////////////////////////////////////////////////////////////////////
	if ( Verify ) {
        Status = VerifyTrusts( BDomain[ 0 ]==L'\0' ? NULL : BDomain, BDC );
        goto Done;
    }

	// regular operation: create/delete trust...
	// get info about the domain(s) involved...
    Status = GetDomainInfoForDomain((ADomain[0]==L'\0'?NULL:ADomain), ADC, &Local, FALSE );
    if ( !NT_SUCCESS( Status ) )
	        goto Done;
    Status = GetDomainInfoForDomain( BDomain, BDC, &Remote, Mit );
    if ( !NT_SUCCESS( Status ) ) {
		if(Mit) {	//assuming a Unix machine...
			dbgprintf( (0,IDS_DSGETDCNAME_MIT, BDomain) );
		}
		else {
		    if(!(	Force
		    		//&& (Status==STATUS_NO_SUCH_DOMAIN)
		    		//&& LocalOnly && Untrust
		    		))						// if -force not specified...
							    			// continue anyway
		        goto Done;
		}
    }

    //
    // Ok, now check or or delete or create  the trust objects...
    //
    ////////////////////////////////////////////////////////////////////////////////
    // check trust link
    ////////////////////////////////////////////////////////////////////////////////
    if ( Check ) {
		dbgprintf( (0, IDS_PROCESSDOM, GetName(&Local)) );
        Status = CheckTrustLink( &Local, &Remote );
        if (Status!=NERR_Success)
            dbgprintf( (0,IDS_LOCAL_CHK_TRUST_F,Status) );
        if ( !LocalOnly ) {
			dbgprintf( (0, IDS_PROCESSDOM, GetName(&Remote)) );
            Status = CheckTrustLink( &Remote, &Local );
            if (Status!=NERR_Success)
                dbgprintf( (IDS_REMOTE_CHK_TRUST_F,Status) );
        }
    // end check block...
    } else
    ////////////////////////////////////////////////////////////////////////////////
    // delete trust object
    ////////////////////////////////////////////////////////////////////////////////
    if ( Untrust ) {
		dbgprintf( (0, IDS_PROCESSDOM, GetName(&Local)) );
        Status = DeleteTrustLink( &Local, &Remote );
        if (Status!=NERR_Success)
            dbgprintf( (0,IDS_LOCAL_DEL_TRUST_F,Status) );
        if ( !LocalOnly ) {
			dbgprintf( (0, IDS_PROCESSDOM, GetName(&Remote)) );
            Status = DeleteTrustLink( &Remote, &Local );
            if (Status!=NERR_Success)
                dbgprintf( (IDS_REMOTE_DEL_TRUST_F,Status) );
        }
    // end untrust block...
    } else {
		////////////////////////////////////////////////////////////////////////////
		// create trust links
		////////////////////////////////////////////////////////////////////////////
        if ( Password == NULL ) {

            Password = L""; // no password specified? then use void password: ""
        }
        if((Local.majver==4 || Remote.majver==4) && !Downlevel) {
			if(!Force)
				Status = STATUS_INVALID_PARAMETER;
			resprintf(0,IDS_NT4_REQ_DOWNLEVEL,(Force?Xbuf:Ybuf));
			if(!NT_SUCCESS(Status))
				goto Done;
        }
        	

		//compute direction of trust based on the values of Both, DirIn, DirOut
		//'Both' has higher priority
		if(Both) {
			DirectionLocal=DirectionRemote=TRUST_DIRECTION_BIDIRECTIONAL;
		} else {
			//default is 'OUTBOUND'... as being DirIn==FALSE and DirOut==TRUE
			DirectionLocal	=(DirIn?TRUST_DIRECTION_INBOUND:TRUST_DIRECTION_OUTBOUND);
			DirectionRemote	=(DirIn?TRUST_DIRECTION_OUTBOUND:TRUST_DIRECTION_INBOUND);
		}
		
		swprintf(Xbuf,L"%wZ",GetName(&Local));
		swprintf(Ybuf,L"%wZ",GetName(&Remote));

		//RtlCopyUnicodeString(&uDomNameL,GetName(&Local));
		//RtlCopyUnicodeString(&uDomNameR,GetName(&Remote));

		dbgprintf( (0, IDS_PROCESSDOM, GetName(&Local)) );
        StatusL = CreateTrustLink( &Local, &Remote,
                                       Password,
                                       Downlevel,
                                       Mit,
                                       Parent,
                                       DirectionLocal	//Both ? TRUST_DIRECTION_BIDIRECTIONAL :
					                                    //       TRUST_DIRECTION_OUTBOUND
                                     );

        if (!NT_SUCCESS(StatusL))
            dbgprintf( (0,IDS_CREATE_TRUST_F, Xbuf,Ybuf,StatusL) );
        //if ( NT_SUCCESS( StatusL ) ) {	not needed...
        //    LocalCreated = TRUE;
        //}

        if ( NT_SUCCESS( StatusL ) && !LocalOnly )  {
			dbgprintf( (0, IDS_PROCESSDOM, GetName(&Remote)) );
            StatusR = CreateTrustLink( &Remote, &Local,
                                           Password,
                                           Downlevel,
                                           Mit,
                                           FALSE,
				                           DirectionRemote	//Both ? TRUST_DIRECTION_BIDIRECTIONAL :
				                                            //		 TRUST_DIRECTION_INBOUND
                                         );
            if (!NT_SUCCESS(StatusR))
                dbgprintf( (0,IDS_CREATE_TRUST_F, Ybuf,Xbuf, StatusR) );
        }

        if ( !NT_SUCCESS( StatusR ) && NT_SUCCESS( StatusL ) ) { //LocalCreated not used anymore....

            DeleteTrustLink( &Local, &Remote );
        }

    }

	Status = StatusL;
	if( NT_SUCCESS(Status) )	//maybe the 'Remote' attempt failed ?...
		Status = StatusR;

Done:

    FreeDomainInfo( &Local );
    FreeDomainInfo( &Remote );

    if( NT_SUCCESS( Status ) ) {

		//No message; in this way will be easier also to get a count of the trust links for a list:
		// by example, 'trustdom <dom> -list | findstr ",B," | wc' will get a count of the
		// bidirectional trusts of domain <dom>

        //printf("The command completed successfully\n");


    } else {

        resprintf(0,IDS_COMMAND_FAILED, Status );

    }

	// return 0 for SUCCESS and 1 for some error
    return( !NT_SUCCESS( Status ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\syskey\samlock.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       samlock.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-19-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "samlock.h"
#include <stdio.h>
#include <wchar.h>



#if DBG
#define HIDDEN
#else
#define HIDDEN static
#endif


#define MAKE_SAM_CALLS 1

#if MAKE_SAM_CALLS
#define SYSTEM_KEY  TEXT("SecureBoot")
#else
#define SYSTEM_KEY  TEXT("BootType")
#endif

#define KEYFILE         TEXT("A:\\StartKey.Key")
#define KEYFILE_SAVE    TEXT("A:\\StartKey.Bak")


HICON   hLockIcon ;
HICON   KeyDataPwIcon ;
HICON   KeyDataDiskIcon ;
SAMPR_BOOT_TYPE SecureBootOption = 0;
SAMPR_BOOT_TYPE OriginalBootOption = 0 ;
SAM_HANDLE SamHandle ;
SAM_HANDLE DomainHandle ;
HKEY    LsaKey ;
HCURSOR hcurArrow ;
HCURSOR hcurWait ;
BOOL    WaitCursor ;

WCHAR   OptionL[ 4 ];   // Unattended, local store
WCHAR   OptionQ[ 4 ];   // Question (usage)
BOOL    Unattended = FALSE ;

DWORD PwSection[] = { IDD_PW_PW_TEXT, IDD_PW_PW_LABEL, IDD_PW_PASSWORD,
                 IDD_PW_CONFIRM_LABEL, IDD_PW_CONFIRM };

DWORD GenSection[]= { IDD_PW_FLOPPY, IDD_PW_STORE_LOCAL, IDD_PW_FLOPPY_TEXT,
                  IDD_PW_LOCAL_TEXT };


typedef WXHASH HASH, *PHASH;

BOOL ObfuscateKey(PHASH H)
{
    return(NT_SUCCESS(WxSaveSysKey(sizeof(H->Digest),&H->Digest)));
}

BOOL DeobfuscateKey(PHASH H)
{
    ULONG KeyLen = sizeof(H->Digest);

    return(NT_SUCCESS(WxReadSysKey(&KeyLen,&H->Digest)));
}

#if MAKE_SAM_CALLS
#define xSamiGetBootKeyInformation  SamiGetBootKeyInformation
#define xSamiSetBootKeyInformation  SamiSetBootKeyInformation
#else


NTSTATUS
xSamiGetBootKeyInformation(
    SAM_HANDLE Domain,
    SAMPR_BOOT_TYPE * BootType
    )
{
    DWORD Type ;
    DWORD Length ;
    int Result ;

    Length = sizeof( SAMPR_BOOT_TYPE );

    Result = RegQueryValueEx( LsaKey,
                              TEXT("SamiSetting"),
                              0,
                              &Type,
                              (PUCHAR) BootType,
                              &Length );

    if ( Result == 0 )
    {
        NOTHING ;
    }
    else
    {
        *BootType = SamBootKeyNone ;
    }

    return STATUS_SUCCESS ;
}

NTSTATUS
xSamiSetBootKeyInformation(
    SAM_HANDLE Domain,
    SAMPR_BOOT_TYPE BootType,
    PUNICODE_STRING Old,
    PUNICODE_STRING New
    )
{
    DWORD Type ;
    DWORD Length ;
    HASH Hash ;
    int Result ;

    Length = 16 ;

    Result = RegQueryValueEx(   LsaKey,
                                TEXT("SamiKey"),
                                0,
                                &Type,
                                Hash.Digest,
                                &Length );

    if ( Result == 0 )
    {
        if (!RtlEqualMemory( Hash.Digest, Old->Buffer, 16 ) )
        {
            return STATUS_WRONG_PASSWORD ;
        }

    }

    RegSetValueEx( LsaKey,
                   TEXT("SamiKey"),
                   0,
                   REG_BINARY,
                   (PUCHAR) New->Buffer,
                   16 );

    RegSetValueEx( LsaKey,
                   TEXT("SamiSetting"),
                   0,
                   REG_DWORD,
                   (PUCHAR) &BootType,
                   sizeof( DWORD ) );

    return STATUS_SUCCESS ;
}



#endif

BOOL
SetupCursor(
    BOOL fWait
    )
{
    BOOL Current ;

    if ( hcurArrow == NULL )
    {
        hcurArrow = LoadCursor( NULL, IDC_ARROW );
    }

    if ( hcurWait == NULL )
    {
        hcurWait = LoadCursor( NULL, IDC_WAIT );
    }

    if ( WaitCursor != fWait )
    {
        SetCursor( fWait ? hcurWait : hcurArrow );

        Current = WaitCursor ;

        WaitCursor = fWait ;
    }
    else
    {
        Current = fWait ;
    }

    return Current ;
}

int
MyMessageBox(
    HWND hWnd,
    int Text,
    int Caption,
    UINT Flags
    )
{
    WCHAR String1[ MAX_PATH ];
    WCHAR String2[ MAX_PATH ];
    int Result ;
    BOOL Cursor ;

    LoadString( GetModuleHandle(NULL), Caption, String1, MAX_PATH );
    LoadString( GetModuleHandle(NULL), Text, String2, MAX_PATH );

    Cursor = SetupCursor( FALSE );

    Result = MessageBox( hWnd, String2, String1, Flags );

    SetupCursor( Cursor );

    return Result ;
}

int
DisplayError(
    HWND hWnd,
    int Description,
    int Error
    )
{
    TCHAR Message[ MAX_PATH ];
    TCHAR Caption[ MAX_PATH ];
    TCHAR Descr[ MAX_PATH ];
    int Result ;
    BOOL Cursor ;

    FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
                   NULL,
                   Error,
                   0,
                   Message,
                   MAX_PATH,
                   NULL );

    LoadString( GetModuleHandle( NULL ), Description, Caption, MAX_PATH );
    wsprintf( Descr, Caption, Message );

    LoadString( GetModuleHandle( NULL ), IDS_ERROR_CAPTION, Caption, MAX_PATH );

    Cursor = SetupCursor( FALSE );

    Result = MessageBox( hWnd, Message, Caption, MB_ICONSTOP | MB_OK );

    SetupCursor( Cursor );

    return Result ;

}

VOID
DisplayErrorAndExit(
    HWND hWnd,
    int Description,
    int Error
    )
{
    DisplayError( hWnd, Description, Error );

    ExitProcess( Error );
}

VOID
EnableSection(
    HWND hDlg,
    BOOL Enable,
    PDWORD IdList,
    DWORD Count
    )
{
    DWORD i ;
    for ( i = 0 ; i < Count ; i++ )
    {
        EnableWindow( GetDlgItem( hDlg, IdList[ i ]), Enable );
    }
}


NTSTATUS
SbLoadKeyFromDisk(
    PUCHAR KeyDataBuffer
    )
{
    HANDLE  hFile ;
    ULONG Actual ;
    ULONG ErrorMode ;

    ErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );

    SetupCursor( TRUE );


    hFile = CreateFileA( "A:\\startkey.key",
                         GENERIC_READ,
                         0,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL );



    if ( hFile == INVALID_HANDLE_VALUE )
    {
        SetErrorMode( ErrorMode );

        SetupCursor( FALSE );

        return STATUS_OBJECT_NAME_NOT_FOUND ;
    }

    if (!ReadFile( hFile, KeyDataBuffer, 16, &Actual, NULL ) ||
        (Actual != 16 ))
    {
        SetErrorMode( ErrorMode );

        CloseHandle( hFile );

        SetupCursor( FALSE );

        return STATUS_FILE_CORRUPT_ERROR ;

    }

    SetErrorMode( ErrorMode );

    CloseHandle( hFile );

    SetupCursor( FALSE );

    return STATUS_SUCCESS ;
}

DWORD
SaveKeyToDisk(
    HWND hDlg,
    PUCHAR Key
    )
{
    HANDLE  hFile ;
    ULONG Actual ;
    ULONG ErrorMode ;
    DWORD Error ;

    ErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );

    SetupCursor( TRUE );

    hFile = CreateFile( KEYFILE,
                         GENERIC_WRITE,
                         0,
                         NULL,
                         CREATE_NEW,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        Error = GetLastError() ;

        if ( Error == ERROR_FILE_EXISTS )
        {
            //
            // This we can handle.
            //

            (VOID) DeleteFile( KEYFILE_SAVE );

            if ( !MoveFile( KEYFILE, KEYFILE_SAVE ) )
            {
                Error = GetLastError() ;
            }
            else
            {
                hFile = CreateFile( KEYFILE,
                                    GENERIC_WRITE,
                                    0,
                                    NULL,
                                    CREATE_NEW,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL );

                if ( hFile == INVALID_HANDLE_VALUE )
                {
                    Error = GetLastError() ;
                }
                else
                {
                    MyMessageBox( hDlg, IDS_RENAMED_OLD,
                                    IDS_WARNING_CAPTION,
                                    MB_OK | MB_ICONINFORMATION );
                    Error = 0 ;
                }
            }

        }

        if ( Error )
        {

            SetErrorMode( ErrorMode );

            SetupCursor( FALSE );

            return Error ;
        }
    }

    if (!WriteFile( hFile, Key, 16, &Actual, NULL ) ||
        (Actual != 16 ))
    {
        SetErrorMode( ErrorMode );

        CloseHandle( hFile );

        SetupCursor( FALSE );

        return GetLastError() ;

    }

    SetErrorMode( ErrorMode );

    CloseHandle( hFile );

    SetupCursor( FALSE );

    return 0 ;

}

LRESULT
ValidateDialog(
    HWND hDlg,
    PSAMPR_BOOT_TYPE Type,
    PHASH NewHash
    )
{
    SAMPR_BOOT_TYPE NewType ;
    WCHAR Password[ MAX_PATH ];
    WCHAR Confirm[ MAX_PATH ];
    PWSTR Scan ;
    DWORD PwLen, ConfLen ;
    BOOL Match ;
    MD5_CTX Md5 ;

    if ( IsDlgButtonChecked( hDlg, IDD_PW_PASSWORD_BTN ) == BST_CHECKED )
    {
        NewType = SamBootKeyPassword ;
    }
    else if ( IsDlgButtonChecked( hDlg, IDD_PW_FLOPPY ) == BST_CHECKED )
    {
        NewType = SamBootKeyDisk ;
    }
    else
    {
        NewType = SamBootKeyStored ;
    }

    *Type = NewType ;

    switch ( NewType )
    {
        case SamBootKeyDisk:
        case SamBootKeyStored:

            STGenerateRandomBits( NewHash->Digest, 16 );

            break;

        case SamBootKeyPassword:
            PwLen = GetDlgItemText( hDlg, IDD_PW_PASSWORD, Password, MAX_PATH );
            ConfLen = GetDlgItemText( hDlg, IDD_PW_CONFIRM, Confirm, MAX_PATH );

            if ( (PwLen != ConfLen) ||
                 (wcscmp( Password, Confirm ) ) )
            {
                Match = FALSE ;

            }
            else
            {
                Match = TRUE ;
            }

            //
            // Clear the PW from the dialog:
            //

            Scan = Confirm ;
            while ( *Scan != L'\0' )
            {
                *Scan++ = ' ';
            }

            SetDlgItemText( hDlg, IDD_PW_PASSWORD, Confirm );
            SetDlgItemText( hDlg, IDD_PW_CONFIRM, Confirm );
            SetDlgItemText( hDlg, IDD_PW_PASSWORD, L"" );
            SetDlgItemText( hDlg, IDD_PW_CONFIRM, L"" );

            if ( !Match )
            {
                MyMessageBox( hDlg,
                              IDS_NEW_PW_MATCH,
                              IDS_ERROR_CAPTION,
                              MB_OK | MB_ICONSTOP );

                SetFocus( GetDlgItem( hDlg, IDD_PW_PASSWORD ) );

                return IDCANCEL ;
            }

            MD5Init( &Md5 );
            MD5Update( &Md5, (PUCHAR) Password, PwLen * sizeof( WCHAR ) );
            MD5Final( &Md5 );

            ZeroMemory( Password, PwLen * sizeof( WCHAR ) );

            CopyMemory( NewHash->Digest, Md5.digest, 16 );

            break;
    }

    return IDOK ;

}

LRESULT
CALLBACK
ConfirmPasswordDlg(
    HWND    hDlg,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    WCHAR PW[ 128 ];
    MD5_CTX Md5;
    int PWLen ;
    PUCHAR Hash ;

    switch ( Message )
    {
        case WM_INITDIALOG:
            if ( KeyDataPwIcon == NULL )
            {
                KeyDataPwIcon = LoadImage( GetModuleHandle(NULL),
                                           MAKEINTRESOURCE( IDD_SB_ICON_PW ),
                                           IMAGE_ICON,
                                           64, 72,
                                           LR_DEFAULTCOLOR );

            }

            SendMessage( GetDlgItem( hDlg, IDD_SB_PW_ICON ),
                         STM_SETICON,
                         (WPARAM) KeyDataPwIcon,
                         0 );

            SetWindowLongPtr( hDlg, GWLP_USERDATA, lParam );

            return TRUE ;

        case WM_COMMAND:
            switch ( LOWORD( wParam ) )
            {
                case IDCANCEL:
                    EndDialog( hDlg, IDCANCEL );
                    return TRUE ;

                case IDOK:

                    // Get text

                    PWLen = GetDlgItemText( hDlg, IDD_SB_PASSWORD, PW, 128 );

                    // Convert length to bytes

                    PWLen *= sizeof(WCHAR);

                    // hash it

                    MD5Init( &Md5 );
                    MD5Update( &Md5, (PUCHAR) PW, PWLen );
                    MD5Final( &Md5 );

                    // save it

                    Hash = (PUCHAR) GetWindowLongPtr( hDlg, GWLP_USERDATA );

                    CopyMemory( Hash, Md5.digest, 16 );

                    // clean up:

                    EndDialog( hDlg, IDOK );
                    FillMemory( PW, PWLen, 0xFF );
                    ZeroMemory( PW, PWLen );
                    FillMemory( &Md5, sizeof( Md5 ), 0xFF );
                    ZeroMemory( &Md5, sizeof( Md5 ) );

                    return TRUE ;
                default:
                    break;

            }
        case WM_CLOSE:
            break;

    }

    return FALSE ;
}


LRESULT
CALLBACK
ConfirmDiskDlg(
    HWND    hDlg,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    NTSTATUS Status ;
    PUCHAR Hash ;

    switch ( Message )
    {
        case WM_INITDIALOG:
            if ( KeyDataDiskIcon == NULL )
            {
                KeyDataDiskIcon = LoadImage( GetModuleHandle(NULL),
                                           MAKEINTRESOURCE( IDD_SB_ICON_DISK ),
                                           IMAGE_ICON,
                                           64, 72,
                                           LR_DEFAULTCOLOR );

            }

            SendMessage( GetDlgItem( hDlg, IDD_SB_DISK_ICON ),
                         STM_SETICON,
                         (WPARAM) KeyDataDiskIcon,
                         0 );

            SetWindowLongPtr( hDlg, GWLP_USERDATA, lParam );

            return TRUE ;

        case WM_COMMAND:
            switch ( LOWORD( wParam ) )
            {
                case IDCANCEL:
                    EndDialog( hDlg, IDCANCEL );
                    return TRUE ;

                case IDOK:

                    Hash = (PUCHAR) GetWindowLongPtr( hDlg, GWLP_USERDATA );

                    Status = SbLoadKeyFromDisk( Hash );

                    if ( !NT_SUCCESS( Status ) )
                    {
                        MyMessageBox( hDlg,
                                      IDS_KEYFILE_NOT_FOUND,
                                      IDS_ERROR_CAPTION,
                                      MB_ICONSTOP | MB_OK);

                    }
                    else
                    {
                        EndDialog( hDlg, IDOK );
                    }
                    return TRUE ;
                default:
                    break;

            }
        case WM_CLOSE:
            break;

    }

    return FALSE ;
}




LRESULT
HandleUpdate(
    HWND    hDlg
    )
{
    HASH OldHash ;
    HASH NewHash ;
    SAMPR_BOOT_TYPE NewType ;
    SAMPR_BOOT_TYPE ExtraType ;
    LRESULT Result ;
    NTSTATUS Status ;
    UNICODE_STRING Old ;
    UNICODE_STRING New ;

    Result = ValidateDialog( hDlg, &NewType, &NewHash );

    if ( Result == IDCANCEL )
    {
        return Result ;
    }

    switch ( OriginalBootOption )
    {
        case SamBootKeyNone:
            break;

        case SamBootKeyStored:
            if (!DeobfuscateKey(&OldHash))
            {
                Result = IDCANCEL ;
            }
            break;

        case SamBootKeyPassword:
            Result = DialogBoxParam( GetModuleHandle( NULL ),
                                     MAKEINTRESOURCE( IDD_SECURE_BOOT ),
                                     hDlg,
                                     ConfirmPasswordDlg,
                                     (LPARAM) &OldHash );

            if ( Result == IDCANCEL )
            {
                return Result ;
            }
            break;

        case SamBootKeyDisk:
            Result = DialogBoxParam( GetModuleHandle( NULL ),
                                     MAKEINTRESOURCE( IDD_SECURE_BOOT_DISK ),
                                     hDlg,
                                     ConfirmDiskDlg,
                                     (LPARAM) &OldHash );

            if ( Result == IDCANCEL )
            {
                return Result ;
            }
            break;

    }

    Old.Buffer = (PWSTR) OldHash.Digest ;
    Old.Length = 16 ;
    Old.MaximumLength = 16 ;

    New.Buffer = (PWSTR) NewHash.Digest ;
    New.Length = 16 ;
    New.MaximumLength = 16 ;

    if ( NewType == SamBootKeyDisk )
    {
        ExtraType = SamBootKeyDisk ;
        NewType = SamBootKeyStored ;
    }
    else
    {
        ExtraType = NewType ;
    }

    Status = xSamiSetBootKeyInformation(
                    DomainHandle,
                    NewType,
                    (OriginalBootOption == SamBootKeyNone ? NULL : &Old),
                    &New );


    if ( !NT_SUCCESS( Status ) )
    {
        Result = RtlNtStatusToDosError( Status );

        DisplayError( hDlg, IDS_SETPASS_FAILED, (int) Result );

        return IDCANCEL ;
    }

    Result = RegSetValueEx( LsaKey,
                            SYSTEM_KEY,
                            0,
                            REG_DWORD,
                            (PUCHAR) &NewType,
                            sizeof( NewType ) );

    if ( NewType == SamBootKeyStored )
    {
        ObfuscateKey( &NewHash );
    }


    MyMessageBox( hDlg, IDS_SETPASS_SUCCESS, IDS_SUCCESS_CAPTION,
                    MB_OK | MB_ICONINFORMATION );


    //
    // Switch back to the intended NewType:
    //

    NewType = ExtraType ;


    if ( NewType == SamBootKeyDisk )
    {
        MyMessageBox( hDlg, IDS_INSERT_FLOPPY, IDS_SAVE_KEY_CAPTION,
                        MB_OK | MB_ICONQUESTION );

        Result = SaveKeyToDisk( hDlg, NewHash.Digest );

        while ( Result != 0 )
        {
            MyMessageBox( hDlg, IDS_SAVE_KEY_FAILED, IDS_SAVE_KEY_CAPTION,
                            MB_OK | MB_ICONSTOP );

            Result = SaveKeyToDisk( hDlg, NewHash.Digest );
        }

        //
        // Once the disk has been written successfully, update SAM and the
        // registry with the correct type:
        //

        Status = xSamiSetBootKeyInformation(
                        DomainHandle,
                        NewType,
                        &New,
                        &New );

        if ( NT_SUCCESS( Status ) )
        {
            Result = RegSetValueEx( LsaKey,
                                    SYSTEM_KEY,
                                    0,
                                    REG_DWORD,
                                    (PUCHAR) &NewType,
                                    sizeof( NewType ) );

        }



        MyMessageBox( hDlg, IDS_SAVE_KEY_SUCCESS, IDS_SAVE_KEY_CAPTION,
                                MB_OK | MB_ICONINFORMATION );
    }

    //
    // Now, if the new type isn't Store-local, write some random stuff in
    // there.
    //

    if ( NewType != SamBootKeyStored )
    {
        STGenerateRandomBits( NewHash.Digest, 16 );
        ObfuscateKey( &NewHash );
    }


    return IDOK ;



}

LRESULT
CALLBACK
UpdateDlg(
    HWND    hDlg,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    LRESULT Result ;

    switch ( Message )
    {
        case WM_INITDIALOG:
            switch ( SecureBootOption )
            {
                case SamBootKeyPassword:
                    CheckDlgButton( hDlg, IDD_PW_PASSWORD_BTN, BST_CHECKED );
                    CheckDlgButton( hDlg, IDD_PW_STORE_LOCAL, BST_CHECKED );

                    EnableSection( hDlg,
                                   FALSE,
                                   GenSection,
                                   sizeof( GenSection ) /sizeof ( DWORD ) );

                    SetFocus( GetDlgItem( hDlg, IDD_PW_PASSWORD_BTN ) );

                    break;

                case SamBootKeyStored:
                    CheckDlgButton( hDlg, IDD_PW_AUTO, BST_CHECKED );
                    CheckDlgButton( hDlg, IDD_PW_STORE_LOCAL, BST_CHECKED );

                    EnableSection( hDlg,
                                   FALSE,
                                   PwSection,
                                   sizeof( PwSection ) / sizeof( DWORD ) );

                    SetFocus( GetDlgItem( hDlg, IDD_PW_STORE_LOCAL ) );
                    break;

                case SamBootKeyDisk:
                    CheckDlgButton( hDlg, IDD_PW_AUTO, BST_CHECKED );
                    CheckDlgButton( hDlg, IDD_PW_FLOPPY, BST_CHECKED );

                    EnableSection( hDlg,
                                   FALSE,
                                   PwSection,
                                   sizeof( PwSection ) / sizeof( DWORD ) );

                    SetFocus( GetDlgItem( hDlg, IDD_PW_FLOPPY ) );
                    break;

                default:
                    return FALSE ;

            }
            return FALSE ;

        case WM_COMMAND:
            switch ( LOWORD( wParam ) )
            {
                case IDOK:
                    Result = HandleUpdate( hDlg );
                    if ( Result == IDOK )
                    {
                        EndDialog( hDlg, IDOK );
                    }
                    return TRUE ;

                case IDCANCEL:
                    EndDialog( hDlg, IDCANCEL );
                    return TRUE ;

                case IDD_PW_PASSWORD_BTN:
                    if ( HIWORD( wParam ) == BN_CLICKED )
                    {
                        if ( IsDlgButtonChecked( hDlg, IDD_PW_PASSWORD_BTN )
                                != BST_CHECKED )
                        {
                            break;
                        }
                        EnableSection( hDlg,
                                       TRUE,
                                       PwSection,
                                       sizeof( PwSection ) / sizeof(DWORD) );

                        EnableSection( hDlg,
                                       FALSE,
                                       GenSection,
                                       sizeof( GenSection ) / sizeof( DWORD ) );
                        return TRUE ;
                    }
                    break;

                case IDD_PW_AUTO:
                    if ( HIWORD( wParam ) == BN_CLICKED )
                    {
                        if ( IsDlgButtonChecked( hDlg, IDD_PW_AUTO )
                                != BST_CHECKED )
                        {
                            break;
                        }
                        EnableSection( hDlg,
                                       TRUE,
                                       GenSection,
                                       sizeof( GenSection ) / sizeof( DWORD ) );

                        EnableSection( hDlg,
                                       FALSE,
                                       PwSection,
                                       sizeof( PwSection ) / sizeof( DWORD ) );

                        return TRUE ;
                    }
                    break;

            }
            break;

        default:
            break;
    }
    return FALSE ;
}

LRESULT
CALLBACK
MainDlg(
    HWND    hDlg,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    LRESULT Result ;

    switch ( Message )
    {
        case WM_INITDIALOG:
            if ( hLockIcon == NULL )
            {
                hLockIcon = LoadImage( GetModuleHandle( NULL ),
                                        MAKEINTRESOURCE( LOCK_ICON ),
                                        IMAGE_ICON,
                                        64, 64,
                                        LR_DEFAULTCOLOR );

            }

            SendMessage( GetDlgItem( hDlg, IDD_MAIN_ICON ),
                         STM_SETICON,
                         (WPARAM) hLockIcon,
                         0 );

            if ( SecureBootOption )
            {
                EnableWindow( GetDlgItem( hDlg, IDD_MAIN_DISABLED ), FALSE );
                CheckDlgButton( hDlg, IDD_MAIN_ENABLED, BST_CHECKED );
            }
            else
            {
                EnableWindow( GetDlgItem( hDlg, IDD_MAIN_UPDATE ), FALSE );
                CheckDlgButton( hDlg, IDD_MAIN_DISABLED, BST_CHECKED );
            }

            return TRUE ;

        case WM_COMMAND:
            switch ( LOWORD( wParam ) )
            {
                case IDCANCEL:
                    EndDialog( hDlg, IDOK );
                    return TRUE ;

                case IDOK:
                    if ( IsDlgButtonChecked( hDlg, IDD_MAIN_DISABLED ) ==
                                    BST_CHECKED )
                    {
                        EndDialog( hDlg, IDOK );
                        return TRUE ;
                    }

                    if ( SecureBootOption )
                    {
                        EndDialog( hDlg, IDOK );
                        return TRUE ;
                    }

                    //
                    // Currently disabled, and the user checked enabled, and
                    // pressed OK.  DROP THROUGH to the
                    // Update case.
                    //

                    //
                    // Set default to Local Store:
                    //

                    Result = MyMessageBox( hDlg, IDS_ARE_YOU_SURE,
                                    IDS_ARE_YOU_SURE_CAP,
                                    MB_ICONWARNING | MB_OKCANCEL |
                                    MB_DEFBUTTON2 );

                    if ( Result == IDCANCEL )
                    {
                        return TRUE ;
                    }

                    SecureBootOption = SamBootKeyStored ;

                case IDD_MAIN_UPDATE:
                    Result = DialogBox( GetModuleHandle(NULL),
                               MAKEINTRESOURCE( IDD_PASSWORD_DLG ),
                               hDlg,
                               UpdateDlg
                               );

                    if ( Result == IDOK )
                    {
                        EnableWindow( GetDlgItem( hDlg, IDD_MAIN_DISABLED ), FALSE );
                        CheckDlgButton( hDlg, IDD_MAIN_ENABLED, BST_CHECKED );
                        EndDialog( hDlg, IDOK );

                    }
                    else
                    {
                        SecureBootOption = OriginalBootOption ;
                    }
                    return TRUE ;
            }

        default:
            break;

    }
    return FALSE ;
}

BOOL
UnattendedLocal(
    VOID
    )
{
    HASH OldHash ;
    HASH NewHash ;
    SAMPR_BOOT_TYPE NewType ;
    int Result ;
    NTSTATUS Status ;
    UNICODE_STRING Old ;
    UNICODE_STRING New ;

    Result = 0;

    if ( OriginalBootOption == SamBootKeyStored )
    {
        if ( !DeobfuscateKey( &OldHash ) )
        {
            Result = IDCANCEL ;
        }
    }

    if ( Result == IDCANCEL )
    {
        return FALSE ;
    }

    NewType = SamBootKeyStored ;

    Old.Buffer = (PWSTR) OldHash.Digest ;
    Old.Length = 16 ;
    Old.MaximumLength = 16 ;

    New.Buffer = (PWSTR) NewHash.Digest ;
    New.Length = 16 ;
    New.MaximumLength = 16 ;

    Status = xSamiSetBootKeyInformation(
                    DomainHandle,
                    NewType,
                    (OriginalBootOption == SamBootKeyNone ? NULL : &Old),
                    &New );


    if ( !NT_SUCCESS( Status ) )
    {
        Result = RtlNtStatusToDosError( Status );

        return FALSE ;
    }

    Result = RegSetValueEx( LsaKey,
                            SYSTEM_KEY,
                            0,
                            REG_DWORD,
                            (PUCHAR) &NewType,
                            sizeof( NewType ) );

    ObfuscateKey( &NewHash );

    return TRUE ;

}



DWORD
OpenSamAccountDomain(
    VOID
    )
{
    NTSTATUS Status ;
    UNICODE_STRING String ;
    OBJECT_ATTRIBUTES Obja ;
    LSA_HANDLE LsaHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo = NULL;
    CAIROSID DomainSid;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;


    RtlInitUnicodeString( &String, L"" );

    InitializeObjectAttributes( &Obja, NULL, 0, NULL, NULL );

    Status = SamConnect( &String,
                         &SamHandle,
                         MAXIMUM_ALLOWED,
                         &Obja );

    if ( !NT_SUCCESS( Status ) )
    {
        return RtlNtStatusToDosError( Status );

    }

    RtlZeroMemory(&Obja, sizeof(OBJECT_ATTRIBUTES));
    Status = LsaOpenPolicy(
                    &String,
                    &Obja,
                    POLICY_VIEW_LOCAL_INFORMATION,
                    &LsaHandle
                    );
    if (!NT_SUCCESS(Status))
    {
        SamCloseHandle( SamHandle );

        return( RtlNtStatusToDosError( Status ) );

    }
    Status = LsaQueryInformationPolicy(
                    LsaHandle,
                    PolicyAccountDomainInformation,
                    (PVOID *) &DomainInfo
                    );
    if (!NT_SUCCESS(Status))
    {
        LsaClose( LsaHandle);

        SamCloseHandle( SamHandle );

        return( RtlNtStatusToDosError( Status ) );

    }

    RtlCopyMemory(
            &DomainSid,
            DomainInfo->DomainSid,
            RtlLengthSid(DomainInfo->DomainSid)
            );

    LsaFreeMemory(DomainInfo);

    LsaClose( LsaHandle );

    Status = SamOpenDomain(
                SamHandle,
                MAXIMUM_ALLOWED,
                (PSID) &DomainSid,
                &DomainHandle
                );

    return RtlNtStatusToDosError( Status );

}


void
__cdecl
wmain (int argc, WCHAR *argv[])
{
    HKEY    Key ;
    int err ;
    SAMPR_BOOT_TYPE SystemSetting ;
    SAMPR_BOOT_TYPE SamSetting ;
    DWORD Type;
    DWORD Length ;
    NTSTATUS Status ;
    WCHAR MsgBuffer[ MAX_PATH ];

    STInitializeRNG();



    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      TEXT("System\\CurrentControlSet\\Control\\Lsa"),
                      0,
                      KEY_READ | KEY_WRITE,
                      & Key );

    if ( err )
    {
        DisplayErrorAndExit( NULL, IDS_SYSTEM_ERROR_OCCURRED, err );
    }

    LsaKey = Key ;

    Length = sizeof( SystemSetting );

    err = RegQueryValueEx( Key,
                           SYSTEM_KEY,
                           NULL,
                           &Type,
                           (PUCHAR) &SystemSetting,
                           &Length );

    if ( err )
    {
        SystemSetting = SamBootKeyNone ;
    }

    //
    // Now, compare with SAM:
    //

    err = OpenSamAccountDomain();

    if ( err )
    {
        DisplayErrorAndExit( NULL, IDS_SYSTEM_ERROR_OCCURRED, err );
    }

    Status = xSamiGetBootKeyInformation( DomainHandle,
                                        &SamSetting );

    if ( !NT_SUCCESS( Status ) )
    {
        DisplayErrorAndExit( NULL,
                             IDS_SYSTEM_ERROR_OCCURRED,
                             RtlNtStatusToDosError( Status ) );
    }


    if ( SamSetting != SystemSetting )
    {
        SystemSetting = SamSetting ;

        err = RegSetValueEx( Key,
                             SYSTEM_KEY,
                             0,
                             REG_DWORD,
                             (PUCHAR) &SystemSetting,
                             sizeof( DWORD ) );

        MyMessageBox( NULL, IDS_SAM_NOT_SYNC, IDS_WARNING_CAPTION,
                        MB_ICONHAND | MB_OK );


    }

    SecureBootOption = SamSetting ;

    OriginalBootOption = SamSetting ;

    if ( argc > 1 )
    {
        LoadString( GetModuleHandle( NULL ), IDS_L_OPTION, OptionL, 4 );
        LoadString( GetModuleHandle( NULL ), IDS_Q_OPTION, OptionQ, 4 );
        //
        // Check for unattended:
        //

        if ( (*argv[1] == L'-') ||
             (*argv[1] == L'/') )
        {
            if ( towupper(argv[1][1]) == OptionL[0] )
            {
                Unattended = TRUE ;
            }
        }

    }

    if ( Unattended )
    {
        if ( ( OriginalBootOption == SamBootKeyStored ) ||
             ( OriginalBootOption == SamBootKeyNone ) )
        {
            UnattendedLocal();
        }
        else
        {
            LoadString( GetModuleHandle( NULL ), IDS_NO_UNATTENDED,
                        MsgBuffer, MAX_PATH );

            fprintf( stderr, "%ws\n", MsgBuffer );

        }
    }
    else
    {
        DialogBox(  GetModuleHandle(NULL),
                    MAKEINTRESOURCE( IDD_MAIN_DIALOG ),
                    NULL,
                    MainDlg );

    }



    RegCloseKey( LsaKey );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\tools\users\users.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       users.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-10-99   JBrezak   Created
//
//----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#define SECURITY_WIN32
#include <rpc.h>
#include <ntsecapi.h>
#include <sspi.h>
extern "C" {
#include <secint.h>
}
#include <stdio.h>
#include <winsta.h>
#include <ntdsapi.h>

LPTSTR FormatUserUpn(
    BOOL UseUpn,
    PSECURITY_STRING Domain,
    PSECURITY_STRING User
    )
{
    HANDLE hDs;
    ULONG NetStatus;
    PDS_NAME_RESULT Result;
    TCHAR DName[DOMAIN_LENGTH + 1];
    static TCHAR UName[DOMAIN_LENGTH + USERNAME_LENGTH + 2];
    LPTSTR Name = UName;
    
    swprintf(DName, TEXT("%wZ"), Domain);
    swprintf(UName, TEXT("%wZ\\%wZ"), Domain, User);

    if (!UseUpn)
	return UName;
	
    NetStatus = DsBind(NULL, DName, &hDs);
    if (NetStatus != 0) {
#ifdef DBGX
	wprintf(TEXT("DsBind failed -0x%x\n"), NetStatus);
#endif
	return UName;
    }
    
    NetStatus = DsCrackNames(hDs, DS_NAME_NO_FLAGS, DS_NT4_ACCOUNT_NAME,
			     DS_USER_PRINCIPAL_NAME, 1, &Name, &Result);
    if (NetStatus != 0) {
#ifdef DBGX
	wprintf(TEXT("DsCrackNames failed -0x%x\n"), NetStatus);
#endif
	return UName;
    }
    
    if (Result->rItems[0].pName)
	return Result->rItems[0].pName;
    else
	return UName;
}

static LPCTSTR dt_output_dhms   = TEXT("%d %s %02d:%02d:%02d");
static LPCTSTR dt_day_plural    = TEXT("days");
static LPCTSTR dt_day_singular  = TEXT("day");
static LPCTSTR dt_output_donly  = TEXT("%d %s");
static LPCTSTR dt_output_ms    = TEXT("%d:%02d");
static LPCTSTR dt_output_hms    = TEXT("%d:%02d:%02d");
static LPCTSTR ftime_default_fmt        = TEXT("%02d/%02d/%02d %02d:%02d");

LPTSTR FormatIdleTime(long dt)
{
    static TCHAR buf2[80];
    int days, hours, minutes, seconds, tt;
    
    days = (int) (dt / (24*3600l));
    tt = dt % (24*3600l);
    hours = (int) (tt / 3600);
    tt %= 3600;
    minutes = (int) (tt / 60);
    seconds = (int) (tt % 60);

    if (days) {
	if (hours || minutes || seconds) {
	    wsprintf(buf2, dt_output_dhms, days,
		     (days > 1) ? dt_day_plural : dt_day_singular,
		     hours, minutes, seconds);
	}
	else {
	    wsprintf(buf2, dt_output_donly, days,
		     (days > 1) ? dt_day_plural : dt_day_singular);
	}
    }
    else {
	wsprintf(buf2, dt_output_hms, hours, minutes, seconds);
    }

    return buf2;
}

LPTSTR FormatLogonType(ULONG LogonType)
{
    static TCHAR buf[20];
    
    switch((SECURITY_LOGON_TYPE)LogonType) {
    case Interactive:
	lstrcpy(buf, TEXT("Interactive"));
	break;
    case Network:
	lstrcpy(buf, TEXT("Network"));
	break;
    case Batch:
	lstrcpy(buf, TEXT("Batch"));
	break;
    case Service:
	lstrcpy(buf, TEXT("Service"));
	break;
    case Proxy:
	lstrcpy(buf, TEXT("Proxy"));
	break;
    case Unlock:
	lstrcpy(buf, TEXT("Unlock"));
	break;
    case NetworkCleartext:
	lstrcpy(buf, TEXT("NetworkCleartext"));
	break;
    case NewCredentials:
	lstrcpy(buf, TEXT("NewCredentials"));
	break;
    default:
	swprintf(buf, TEXT("(%d)"), LogonType);
	break;
    }
    return buf;
}

void Usage(void)
{
    wprintf(TEXT("\
Usage: users [-u] [-a]\n\
       -u = Print userPrincipalName\n\
       -a = Print all logon sessions\n"));
    ExitProcess(0);
}

void __cdecl main (int argc, char *argv[])
{
    ULONG LogonSessionCount;
    PLUID LogonSessions;
    int i;
    DWORD err;
    PSECURITY_LOGON_SESSION_DATA SessionData;
    DWORD all = FALSE;
    DWORD UPN = FALSE;
    WINSTATIONINFORMATION WinStationInfo;
    DWORD WinStationInfoLen;
    char *ptr;
    FILETIME LocalTime;
    SYSTEMTIME LogonTime;
    TCHAR DateStr[40], TimeStr[40];
    WINSTATIONNAME WinStationName = TEXT("inactive");
    long IdleTime = 0L;
    
    for (i = 1; i < argc; i++) {
        if ((argv[i][0] == '-') || (argv[i][0] == '/')) {
            for (ptr = (argv[i] + 1); *ptr; ptr++) {
                switch(toupper(*ptr)) {
		case 'A':
                    all = TRUE;
                    break;
		case 'U':
		    UPN = TRUE;
		    break;
		case '?':
		default:
		    Usage();
		    break;
		}
	    }
	}
    }

    err = LsaEnumerateLogonSessions(&LogonSessionCount, &LogonSessions);
    if (err != ERROR_SUCCESS) {
	printf("LsaEnumeratelogonSession failed - 0x%x\n", err);
	ExitProcess(1);
    }

    for (i = 0; i < (int)LogonSessionCount; i++) {
	err = LsaGetLogonSessionData(&LogonSessions[i], &SessionData);
	if (err != ERROR_SUCCESS) {
	    printf("LsaGetLogonSessionData failed - 0x%x\n", err);
	    continue;
	}
	
	if (SessionData->LogonType != 0 && 
	    (all || ((SECURITY_LOGON_TYPE)SessionData->LogonType == Interactive))) {
	    ZeroMemory(DateStr, sizeof(DateStr));
	    ZeroMemory(TimeStr, sizeof(TimeStr));
	    if (!FileTimeToLocalFileTime((LPFILETIME)&SessionData->LogonTime,
					 &LocalTime) ||
		!FileTimeToSystemTime(&LocalTime, &LogonTime)) {
		printf("Time conversion failed - 0x%x\n", GetLastError());
	    }
	    else {
		if (!GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE,
				   &LogonTime, NULL,
				   DateStr, sizeof(DateStr))) {
		    printf("Date format failed - 0x%x\n", GetLastError());
		}
		if (!GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS,
				   &LogonTime, NULL,
				   TimeStr, sizeof(TimeStr))) {
		    printf("Time format failed - 0x%x\n", GetLastError());
		}
	    }
	    
	    if (WinStationQueryInformation(SERVERNAME_CURRENT,
					   SessionData->Session,
					   WinStationInformation, 
					   &WinStationInfo,
					   sizeof(WinStationInfo),
					   &WinStationInfoLen)) {
		if (WinStationInfo.ConnectState != State_Idle) {
		    
		    wcscpy(WinStationName, WinStationInfo.WinStationName);
		}

		const long TPS = (10*1000*1000);
		FILETIME CurrentFileTime;
		LARGE_INTEGER Quad;

		GetSystemTimeAsFileTime(&CurrentFileTime);

		Quad.LowPart = CurrentFileTime.dwLowDateTime;
		Quad.HighPart = CurrentFileTime.dwHighDateTime;

		IdleTime = (long)
		    ((Quad.QuadPart - WinStationInfo.LastInputTime.QuadPart) / TPS);

	    }
	    else if (GetLastError() == ERROR_APP_WRONG_OS) {
		wcscpy(WinStationName, TEXT("Console"));
	    }
	    else {
#ifdef DBGX
		printf("Query failed for %wZ\\%wZ @ %d - 0x%x\n",
		       &SessionData->LogonDomain, &SessionData->UserName,
		       SessionData->Session,
		       GetLastError());
#endif
		continue;
	    }
	    wprintf(TEXT("%-30.30s"),
		    FormatUserUpn(UPN, &SessionData->LogonDomain,
				 &SessionData->UserName));
		    
	    if (all)
		wprintf(TEXT(" %-12.12s"),
			FormatLogonType(SessionData->LogonType));

	    wprintf(TEXT(" %8.8s %s %s"), WinStationName, DateStr, TimeStr);

	    if (all)
		wprintf(TEXT(" %wZ"),
			&SessionData->AuthenticationPackage);

	    if (all && (IdleTime > 10))
		wprintf(TEXT(" %-12.12s"), FormatIdleTime(IdleTime));
	    
	    wprintf(TEXT("\n"));
	}
    }

    ExitProcess(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\safecann.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    SafeCann.c        (WinSAFER Filename Canonicalization)

Abstract:

    This module implements the WinSAFER APIs that produce canonicalized
    filenames from a caller-supplied .

Author:

    Jeffrey Lawson (JLawson) - Nov 1999

Environment:

    User mode only.

Exported Functions:

    CodeAuthzFullyQualifyFilename

Revision History:

    Created - Nov 2000

--*/

#include "pch.h"
#pragma hdrstop
#include <winsafer.h>
#include <winsaferp.h>
#include "saferp.h"


//
// Defines the maximum recursion depth that will be used when attempting
// to resolve the final mapping of SUBST'ed drives.  For worst-case, value
// shouldn't be greater than 26 (the number of possible drive letters).
//
#define MAX_RECURSE_DRIVE_LETTER        10


//
// Some static name prefixes in the NT object namespace.
//
static const UNICODE_STRING UnicodeDeviceWinDfs =
        RTL_CONSTANT_STRING( L"\\Device\\WinDfs\\" );
static const UNICODE_STRING UnicodeDeviceLanman =
        RTL_CONSTANT_STRING( L"\\Device\\LanmanRedirector\\" );
static const UNICODE_STRING UnicodeDosDevicesUncPrefix =
        RTL_CONSTANT_STRING( L"\\??\\UNC\\" );
static const UNICODE_STRING UnicodeDosDevicesPrefix =
        RTL_CONSTANT_STRING( L"\\??\\" );
static const UNICODE_STRING UnicodeDevicePrefix =
        RTL_CONSTANT_STRING( L"\\Device\\" );




static BOOLEAN FORCEINLINE
SaferpIsAlphaLetter(
        IN WCHAR inwcletter
        )
{
#if 1
    if ((inwcletter >= L'A' && inwcletter <= L'Z') ||
        (inwcletter >= L'a' && inwcletter <= L'z'))
        return TRUE;
    else
        return FALSE;
#else
    inwcletter = RtlUpcaseUnicodeChar(inwcletter);
    return (inwcletter >= L'A' && inwcletter <= 'Z') ? TRUE : FALSE;
#endif
}



static BOOLEAN NTAPI
SaferpQueryActualDriveLetterFromDriveLetter(
        IN WCHAR        inDriveLetter,
        OUT WCHAR       *outDriveLetter,
        IN SHORT        MaxRecurseCount
        )
/*++

Routine Description:

    Attempts to determine if a specified drive letter is a SUBST'ed
    drive letter, a network mapped drive letter, or a physical drive
    letter.  Unknown cases result in a failure.

Arguments:

    inDriveLetter - Drive leter to obtain information about.  This must
            be an alphabetic character.

    outDriveLetter - Receives the result of the evaluation and indicates
            what drive letter the requested one actually points to:
               -->  If the drive letter is a SUBST'ed drive, then the result
                    will be the drive letter of the original drive.
               -->  If the drive letter is a network mapped drive, then the
                    result will be UNICODE_NULL, indicating a network volume.
               -->  If the drive letter is a local, physical drive, then
                    the result will be the same as the input letter.

    MaxRecurseCount - used for limiting maximum recursion depth.
            Recommend specifying a reasonable positive value.

Return Value:

    Returns TRUE on successful operation, FALSE if the determination
    could not be made.

--*/
{
    NTSTATUS Status;
    HANDLE LinkHandle;
    UNICODE_STRING UnicodeFileName;
    OBJECT_ATTRIBUTES Attributes;
    const WCHAR FileNameBuffer[7] = { L'\\', L'?', L'?', L'\\',
            inDriveLetter, L':', UNICODE_NULL };
    UNICODE_STRING LinkValue;
    WCHAR LinkValueBuffer[2*MAX_PATH];
    ULONG ReturnedLength;


    //
    // Require that the input drive letter be alphabetic.
    //
    if (!SaferpIsAlphaLetter(inDriveLetter)) {
        // Input drive letter was not uppercase alphabetic.
        return FALSE;
    }


    //
    // Open a reference to see if there are any links.
    //
    RtlInitUnicodeString(&UnicodeFileName, FileNameBuffer);
    InitializeObjectAttributes(&Attributes, &UnicodeFileName,
                               OBJ_CASE_INSENSITIVE, NULL, NULL);
    Status = NtOpenSymbolicLinkObject (&LinkHandle,
                                       SYMBOLIC_LINK_QUERY,
                                       &Attributes);
    if (!NT_SUCCESS(Status)) {
        // Unable to open the drive letter so it must not exist.
        return FALSE;
    }


    //
    // Now query the link and see if there is a redirection
    //
    LinkValue.Buffer = LinkValueBuffer;
    LinkValue.Length = 0;
    LinkValue.MaximumLength = (USHORT)(sizeof(LinkValueBuffer));
    ReturnedLength = 0;
    Status = NtQuerySymbolicLinkObject( LinkHandle,
                                        &LinkValue,
                                        &ReturnedLength
                                      );
    NtClose( LinkHandle );
    if (!NT_SUCCESS(Status)) {
        // Could not retrieve final link destination.
        return FALSE;
    }


    //
    // Analyze the resulting link destination and extract the
    // actual destination drive letter or network path.
    //
    if (RtlPrefixUnicodeString(
                (PUNICODE_STRING) &UnicodeDeviceWinDfs,
                &LinkValue, TRUE) ||
        RtlPrefixUnicodeString(
                (PUNICODE_STRING) &UnicodeDeviceLanman,
                &LinkValue, TRUE) ||
        RtlPrefixUnicodeString(
                (PUNICODE_STRING) &UnicodeDosDevicesUncPrefix,
                &LinkValue, TRUE))
        // Note: Other network redirectors (Netware, NFS, etc) will not be known as such.
        // Maybe there is a way to query if a device is a "network redirector"?
    {
        // This is a network volume.
        *outDriveLetter = UNICODE_NULL;
        return TRUE;
    }
    else if (RtlPrefixUnicodeString(
                (PUNICODE_STRING) &UnicodeDosDevicesPrefix,
                &LinkValue, TRUE) &&
             LinkValue.Length >= 6 * sizeof(WCHAR) &&
             LinkValue.Buffer[5] == L':' &&
             SaferpIsAlphaLetter(LinkValue.Buffer[4]))
    {
        // This is a SUBST'ed drive letter.
        // We need to recurse, since you can SUBST multiple times,
        // or SUBST a network mapped drive to a second drive letter.
        if (MaxRecurseCount > 0) {
            // Tail recursion here would be nice.
            return SaferpQueryActualDriveLetterFromDriveLetter(
                LinkValue.Buffer[4], outDriveLetter, MaxRecurseCount - 1);
        }
        return FALSE;
    }
    else if (RtlPrefixUnicodeString(
                (PUNICODE_STRING) &UnicodeDevicePrefix,
                &LinkValue, TRUE))
    {
        // Otherwise this drive letter is an actual device and is
        // apparently its own identity.  However, network redirectors
        // that we did not know about will also fall into this bucket.
        *outDriveLetter = inDriveLetter;
        return TRUE;
    } else {
        // Otherwise we don't know what it is.
        return FALSE;
    }
}



static BOOLEAN NTAPI
SaferpQueryCanonicalizedDriveLetterFromDosPathname(
        IN LPCWSTR          szDosPathname,
        OUT WCHAR           *wcDriveLetter
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    RTL_PATH_TYPE PathType;


    //
    // Verify input arguments were supplied.
    //
    if (!ARGUMENT_PRESENT(szDosPathname) ||
        !ARGUMENT_PRESENT(wcDriveLetter)) {
        return FALSE;
    }


    //
    // Determine what syntax this DOS pathname was supplied to us as.
    //
    PathType = RtlDetermineDosPathNameType_U(szDosPathname);
    switch (PathType) {

        case RtlPathTypeUncAbsolute:
            // definitely a network volume.
            *wcDriveLetter = UNICODE_NULL;
            return TRUE;


        case RtlPathTypeDriveAbsolute:
        case RtlPathTypeDriveRelative:
            // explicitly specified drive letter, but need to handle subst or network mapped.
        {
            WCHAR CurDrive = RtlUpcaseUnicodeChar( szDosPathname[0] );
            if (SaferpQueryActualDriveLetterFromDriveLetter(
                        CurDrive, wcDriveLetter, MAX_RECURSE_DRIVE_LETTER)) {
                return TRUE;
            }
            break;
        }


        case RtlPathTypeRooted:
        case RtlPathTypeRelative:
            // relative to current drive, but still need to handle subst or network mapped.
        {
            PCURDIR CurDir;
            WCHAR CurDrive;

            CurDir = &(NtCurrentPeb()->ProcessParameters->CurrentDirectory);
            CurDrive = RtlUpcaseUnicodeChar( CurDir->DosPath.Buffer[0] );

            if (SaferpQueryActualDriveLetterFromDriveLetter(
                        CurDrive, wcDriveLetter, MAX_RECURSE_DRIVE_LETTER)) {
                return TRUE;
            }
            break;
        }


        // Everything else gets rejected:
        //      RtlPathTypeUnknown
        //      RtlPathTypeLocalDevice
        //      RtlPathTypeRootLocalDevice
    }

    return FALSE;
}



static BOOLEAN NTAPI
SaferpQueryCanonicalizedDriveLetterFromNtPathname(
        IN LPCWSTR          szNtPathname,
        OUT WCHAR           *wcDriveLetter
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    UNICODE_STRING LinkValue;


    RtlInitUnicodeString(&LinkValue, szNtPathname);


    //
    // Analyze the resulting link destination and extract the
    // actual destination drive letter or network path.
    //
    if (RtlPrefixUnicodeString(
                (PUNICODE_STRING) &UnicodeDeviceWinDfs,
                &LinkValue, TRUE) ||
        RtlPrefixUnicodeString(
                (PUNICODE_STRING) &UnicodeDeviceLanman,
                &LinkValue, TRUE) ||
        RtlPrefixUnicodeString(
                (PUNICODE_STRING) &UnicodeDosDevicesUncPrefix,
                &LinkValue, TRUE))
        // Note: Other network redirectors (Netware, NFS, etc) will not be known as such.
        // Maybe there is a way to query if a device is a "network redirector"?
    {
        // This is a network volume.
        *wcDriveLetter = UNICODE_NULL;
        return TRUE;
    }
    else if (RtlPrefixUnicodeString(
                (PUNICODE_STRING) &UnicodeDosDevicesPrefix,
                &LinkValue, TRUE) &&
             LinkValue.Length >= 6 * sizeof(WCHAR) &&
             LinkValue.Buffer[5] == L':' &&
             SaferpIsAlphaLetter(LinkValue.Buffer[4]))
    {
        // This is a SUBST'ed drive letter.
        // We need to recurse, since you can SUBST multiple times,
        // or SUBST a network mapped drive to a second drive letter.
        return SaferpQueryActualDriveLetterFromDriveLetter(
            LinkValue.Buffer[4], wcDriveLetter, MAX_RECURSE_DRIVE_LETTER);
    }
    else {
        // Otherwise we don't know what it is.
        return FALSE;
    }
}




static NTSTATUS NTAPI
SaferpQueryFilenameFromHandle(
        IN HANDLE               hFileHandle,
        IN WCHAR                wcDriveLetter,
        OUT PUNICODE_STRING     pUnicodeOutput
        )
/*++

Routine Description:

    Attempts to determine the fully qualified, canonicalized long
    filename version of the file associated with a given file handle.

    Note that the behavior provided by this function is a frequently
    requested API by Win32 developers because this information is
    normally not available by any other way through documented
    Win32 API calls.  However, even this implementation is not able to
    generally satisfy the general case very well due the limited access
    to the full path information from user-mode.

Arguments:

    hFileHandle -

    wcDriveLetter -

    pUnicodeOutput - Canonicalized DOS namespace filename, or
        potentially a UNC network path.

Return Value:

    Returns STATUS_SUCCESS on successful completion, otherwise an error code.

--*/
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    WCHAR szLongFileNameBuffer[MAX_PATH];

    union {
        BYTE FileNameInfoBuffer[ (sizeof(WCHAR) * MAX_PATH) +
                    sizeof(FILE_NAME_INFORMATION)];
        FILE_NAME_INFORMATION FileNameInfo;
    } moo;

    UNICODE_STRING UnicodeFileName;


    //
    // Query the full path and filename (minus the drive letter).
    //
    Status = NtQueryInformationFile(
                hFileHandle,
                &IoStatusBlock,
                &moo.FileNameInfo,
                sizeof(moo.FileNameInfoBuffer),
                FileNameInformation);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }


    //
    // Initialize the UNICODE_STRING reference to the output string.
    //
    UnicodeFileName.Buffer = &moo.FileNameInfo.FileName[0];
    UnicodeFileName.Length = (USHORT) moo.FileNameInfo.FileNameLength;
    UnicodeFileName.MaximumLength = (USHORT)
            ( sizeof(moo.FileNameInfoBuffer) -
                ( ((PBYTE) (&moo.FileNameInfo.FileName[0])) -
                  ((PBYTE) &moo.FileNameInfoBuffer) ) );
    ASSERT(UnicodeFileName.Length <= UnicodeFileName.MaximumLength);


    //
    // Perform some additional fixups depending upon whether we
    // were told that the file eventually comes from a local drive
    // letter or a network/dfs share.
    //
    if (wcDriveLetter == UNICODE_NULL)
    {
        // Ensure there is room for one more character.
        if (UnicodeFileName.Length + sizeof(WCHAR) >
            UnicodeFileName.MaximumLength) {
            return STATUS_BUFFER_OVERFLOW;
        }

        // We've been told that this comes from a network volume,
        // so we need to prepend another backslash to the front.
        RtlMoveMemory(&UnicodeFileName.Buffer[1],
                      &UnicodeFileName.Buffer[0],
                      UnicodeFileName.Length);
        ASSERT(UnicodeFileName.Buffer[0] == L'\\' &&
               UnicodeFileName.Buffer[1] == L'\\');
        UnicodeFileName.Length += sizeof(WCHAR);
    }
    else if (SaferpIsAlphaLetter(wcDriveLetter))
    {
        // Ensure there is room for two more characters.
        if (UnicodeFileName.Length + 2 * sizeof(WCHAR) >
            UnicodeFileName.MaximumLength) {
            return STATUS_BUFFER_OVERFLOW;
        }

        // We've been told that this comes from a local drive.
        RtlMoveMemory(&UnicodeFileName.Buffer[2],
                      &UnicodeFileName.Buffer[0],
                      UnicodeFileName.Length);
        UnicodeFileName.Buffer[0] = RtlUpcaseUnicodeChar(wcDriveLetter);
        UnicodeFileName.Buffer[1] = L':';
        ASSERT(UnicodeFileName.Buffer[2] == L'\\');
        UnicodeFileName.Length += 2 * sizeof(WCHAR);
    }
    else {
        // Otherwise invalid input.
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make sure the string is NULL terminated
    //

    UnicodeFileName.Buffer[(UnicodeFileName.Length)/sizeof(WCHAR)] = L'\0';
    szLongFileNameBuffer[0] =  L'\0';

    if (GetLongPathNameW(UnicodeFileName.Buffer,
                          szLongFileNameBuffer,
                          sizeof(szLongFileNameBuffer) / sizeof(WCHAR))) {

        RtlInitUnicodeString(&UnicodeFileName, szLongFileNameBuffer);
    }


    //
    // Duplicate the local string into a new memory buffer so we
    // can pass it back to the caller.
    Status = RtlDuplicateUnicodeString(
                    RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE,
                    &UnicodeFileName,
                    pUnicodeOutput);

    return Status;
}




NTSTATUS NTAPI
CodeAuthzFullyQualifyFilename(
        IN HANDLE               hFileHandle         OPTIONAL,
        IN BOOLEAN              bSourceIsNtPath,
        IN LPCWSTR              szSourceFilePath,
        OUT PUNICODE_STRING     pUnicodeResult
        )
/*++

Routine Description:

    Attempts to return fully qualified, canonicalized filename using a
    caller-supplied filename and optionally an opened file handle.
    The method used by this function is significantly more reliable
    and consistent if an opened file handle can additionally be provided.

Arguments:

    hFileHandle - optionally supplies the file handle to the file that
        is being canonicalized.  The handle is used to obtain a more
        definitive canonicalization result.

        Unfortunately, since NT does not currently allow full information
        to be queried from strictly the file handle, the original filename
        used to open the file needs to also be supplied.  No explicit
        verification is done to ensure that the supplied file handle
        actually corresponds with the filename that is also supplied.

    bSourceIsNtPath - boolean indicator of whether the filename being
        supplied is a DOS namespace or an NT-namespace filename.

    szSourceFilePath - string of the filename to canonicalize.  This
        filename may either be a DOS or an NT-namespace filename.

    pUnicodeResult - output UNICODE_STRING structure that receives an
        allocated string of the resulting canonicalized path.
        The resulting path will always be a DOS namespace filename.

Return Value:

    Returns STATUS_SUCCESS if successful, otherwise the error code.

--*/
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;


    if (ARGUMENT_PRESENT(hFileHandle) && ARGUMENT_PRESENT(szSourceFilePath))
    {
        //
        // When we are given a file handle, or are able to open
        // the file ourselves, use the handle to derive the full name.
        // First, determine the drive letter by looking at the supplied
        // file path itself.  This step is necessary because the
        // NtQueryInformationFile API that we use later is unable to
        // supply the full prefix of the filename.
        //
        WCHAR wcDriveLetter;
        Status = STATUS_SUCCESS;
        if (bSourceIsNtPath) {
            if (!SaferpQueryCanonicalizedDriveLetterFromNtPathname(
                    szSourceFilePath, &wcDriveLetter))
                Status = STATUS_UNSUCCESSFUL;
        } else {
            if (!SaferpQueryCanonicalizedDriveLetterFromDosPathname(
                    szSourceFilePath, &wcDriveLetter))
                Status = STATUS_UNSUCCESSFUL;
        }

        if (NT_SUCCESS(Status)) {
            Status = SaferpQueryFilenameFromHandle(
                            hFileHandle,
                            wcDriveLetter,
                            pUnicodeResult);
            if (NT_SUCCESS(Status)) return Status;
        }
    }



    if (szSourceFilePath != NULL)
    {
        //
        // Allow the case where a pathname was supplied, but not a
        // handle and we were unable to open the file.  This case
        // will not be very common, so it can be less efficient.
        //
        UNICODE_STRING UnicodeInput;
        WCHAR FileNameBuffer[MAX_PATH];
        WCHAR FileNameBuffer2[MAX_PATH];


        //
        // Transform the name into a fully qualified name.
        //
        RtlInitUnicodeString(&UnicodeInput, szSourceFilePath);
        if ( bSourceIsNtPath )
        {
            if (RtlPrefixUnicodeString(
                    (PUNICODE_STRING) &UnicodeDosDevicesPrefix,
                    &UnicodeInput, TRUE) &&
                UnicodeInput.Length >= 6 * sizeof(WCHAR) &&
                UnicodeInput.Buffer[5] == L':' &&
                SaferpIsAlphaLetter(UnicodeInput.Buffer[4]) &&
                UnicodeInput.Buffer[6] == L'\\')
            {
                // Absolute NT style filename, and assumed to already be
                // fully-qualified.  Since we want the DOS-namespace,
                // the leading NT prefix stuff needs to be chopped.
                UnicodeInput.Buffer = &UnicodeInput.Buffer[4];
                UnicodeInput.Length -= (4 * sizeof(WCHAR));
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_UNSUCCESSFUL;
            }
        } else {
            // Need to possibly fully qualify the path first.
            ULONG ulResult = RtlGetFullPathName_U(
                    UnicodeInput.Buffer,
                    sizeof(FileNameBuffer2),   // yes, BYTEs not WCHARs!
                    FileNameBuffer2,
                    NULL);
            if (ulResult != 0 && ulResult < sizeof(FileNameBuffer2)) {
                UnicodeInput.Buffer = FileNameBuffer2;
                UnicodeInput.Length = (USHORT) ulResult;
                UnicodeInput.MaximumLength = sizeof(FileNameBuffer2);
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_UNSUCCESSFUL;
            }
        }


        //
        // Convert any short 8.3 filenames to their full versions.
        //
        if (NT_SUCCESS(Status))
        {
            if (!GetLongPathNameW(UnicodeInput.Buffer,
                                  FileNameBuffer,
                                  sizeof(FileNameBuffer) / sizeof(WCHAR))) {
                // duplicate UnicodeInput into identStruct.UnicodeFullyQualfiedLongFileName
                Status = RtlDuplicateUnicodeString(
                                RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE |
                                RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING,
                                &UnicodeInput,
                                pUnicodeResult);
            } else {
                // Conversion was possible, so just return an
                // allocated copy of what we were able to find.
                // This can happen when the file path doesn't exist.
                Status = RtlCreateUnicodeString(
                                pUnicodeResult,
                                FileNameBuffer);
            }
            if (NT_SUCCESS(Status)) return Status;
        }


        // REVIEW: we could also potentially try to use GetDriveType()
        //      and expand the drive letter to the actual network volume
        //      or subst'ed target drive.
    }



    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\safeext.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    SafeExt.c        (WinSAFER File Extension)

Abstract:

    This module implements the WinSAFER APIs that evaluate the system
    policies to determine if a given file extension is an "executable"
    file that needs to have different enforcement policies considered.

Author:

    Jeffrey Lawson (JLawson) - Nov 1999

Environment:

    User mode only.

Exported Functions:


Revision History:

    Created - Jul 2000

--*/

#include "pch.h"
#pragma hdrstop
#include <winsafer.h>
#include <winsaferp.h>
#include "saferp.h"



NTSTATUS NTAPI
__CodeAuthzIsExecutableFileTypeHelper(
        IN PUNICODE_STRING  UnicodeFullPathname,
        IN DWORD			dwScopeId,
        IN BOOLEAN          bFromShellExecute,
        OUT PBOOLEAN        pbResult
        )
{
    NTSTATUS Status;
    LPCWSTR szExtension, szPtr, szEnd;
    ULONG ulExtensionLength;
    HANDLE hKeyBadTypes;
    DWORD dwAllocatedSize = 0, dwActualSize;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo = NULL;

    const static UNICODE_STRING UnicodeValueName =
        RTL_CONSTANT_STRING(SAFER_EXETYPES_REGVALUE);

    if (!ARGUMENT_PRESENT(UnicodeFullPathname) ||
        UnicodeFullPathname->Buffer == NULL ||
        UnicodeFullPathname->Length == 0)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }
    if (!ARGUMENT_PRESENT(pbResult)) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }


    //
    // Start from the end of the string and scan backwards to
    // look for the period separator and find the extension.
    //
    szExtension = UnicodeFullPathname->Buffer +
            (UnicodeFullPathname->Length / sizeof(WCHAR));
    ASSERT(szExtension >= UnicodeFullPathname->Buffer);

    for (;;) {
        if (szExtension < UnicodeFullPathname->Buffer ||
            *szExtension == L'\\' || *szExtension == L'/') {
            // We scanned back too far, but did not find the extension.
            Status = STATUS_NOT_FOUND;
            goto ExitHandler;
        }
        if (*szExtension == L'.') {
            // We found the period that marks the extension.
            szExtension++;
            break;
        }
        szExtension--;
    }
    ulExtensionLength = (UnicodeFullPathname->Length / sizeof(WCHAR)) -
            (ULONG) (szExtension - UnicodeFullPathname->Buffer);
    if (ulExtensionLength == 0) {
        // We found a period, but there was no extension.
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }

    if (bFromShellExecute) {
        
        if ( _wcsicmp(szExtension, L"exe") == 0 ){
            
            *pbResult = FALSE;
            Status = STATUS_SUCCESS;
            goto ExitHandler;
        
        }
    }

    //
    // Open and query the registry value containing the list of extensions.
    //
	Status = CodeAuthzpOpenPolicyRootKey(
		dwScopeId,
        NULL,
        SAFER_CODEIDS_REGSUBKEY,
        KEY_READ,
        FALSE,
        &hKeyBadTypes
        );

    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    for (;;) {
        Status = NtQueryValueKey(
                        hKeyBadTypes,
                        (PUNICODE_STRING) &UnicodeValueName,
                        KeyValuePartialInformation,
                        pKeyValueInfo, dwAllocatedSize, &dwActualSize);
        if (NT_SUCCESS(Status)) {
            break;
        }
        else if ((Status == STATUS_BUFFER_OVERFLOW ||
                Status == STATUS_BUFFER_TOO_SMALL) &&
                dwActualSize > dwAllocatedSize)
        {
            if (pKeyValueInfo != NULL) {
                RtlFreeHeap(RtlProcessHeap(), 0, pKeyValueInfo);
            }
            dwAllocatedSize = dwActualSize;
            pKeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)
                RtlAllocateHeap(RtlProcessHeap(), 0, dwAllocatedSize);
            if (!pKeyValueInfo) {
                Status = STATUS_NO_MEMORY;
                goto ExitHandler2;
            }
        }
        else {
            goto ExitHandler3;
        }
    }


    //
    // See if the extension is in one of those specified in the list.
    //
    szEnd = (LPCWSTR) ( ((LPBYTE) pKeyValueInfo->Data) +
                        pKeyValueInfo->DataLength);
    for (szPtr = (LPCWSTR) pKeyValueInfo->Data; szPtr < szEnd; ) {
        ULONG ulOneExtension = wcslen(szPtr);
        if (szPtr + ulOneExtension > szEnd) {
            ulOneExtension = (ULONG) (szEnd - szPtr);
        }

        if (ulOneExtension == ulExtensionLength &&
            _wcsnicmp(szExtension, szPtr, ulExtensionLength) == 0) {
            *pbResult = TRUE;
            Status = STATUS_SUCCESS;
            goto ExitHandler3;
        }
        szPtr += ulOneExtension + 1;
    }
    *pbResult = FALSE;
    Status = STATUS_SUCCESS;


ExitHandler3:
    if (pKeyValueInfo != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, pKeyValueInfo);
    }

ExitHandler2:
    NtClose(hKeyBadTypes);

ExitHandler:
    return Status;
}

NTSTATUS NTAPI
CodeAuthzIsExecutableFileType(
        IN PUNICODE_STRING  UnicodeFullPathname,
        IN BOOLEAN  bFromShellExecute,
        OUT PBOOLEAN        pbResult
        )
/*++

Routine Description:

    This API determines if a specified filename has an extension that
    is considered an "executable" extension.  Applications can take
    special precautions to avoid invoking untrusted files that might
    be considered executable.

    Common examples of extensions that are considered executable include:
    EXE, COM, BAT, CMD, VBS, JS, URL, LNK, SHS, PIF, PL, and others.

Arguments:

    UnicodeFullPathname - pointer to a Unicode string of the
        full path and/or filename to evaluate.  Only the file's extension
        (the portion of the specified path following the last period)
        is used in this evaluation.  File extension comparisons are done
        case-insensitively, without regard to case.

        An error will be returned if this pointer is NULL, or if the length
        of the path is zero, or if the file does not have an extension.

        Although applications are encouraged to supply the entire,
        fully-qualified pathname to this API, the szFullPathname argument
        will also accept only the file extension, by ensuring that the
        file extension is preceeded by a period (for example:  L".exe")

    bFromShellExecute - for performance reasons, if this is being called 
        from ShellExecute, we'd like to skip exe checking since CreateProcess 
        will do the check
    
    pbResult - pointer to a variable that will receive a TRUE or FALSE
        result value if this API executes successfully.  An error will
        be returned if this pointer is NULL.

Return Value:

    Returns STATUS_SUCCESS if the API executes successfully, otherwise a
    valid NTSTATUS error code is returned.  If the return value indicates
    success, then the argument 'pbResult' will also receive a boolean
    value indicating whether or not the pathname represented an executable
    file type.

--*/
{
	NTSTATUS Status;

    Status = __CodeAuthzIsExecutableFileTypeHelper(
			UnicodeFullPathname,
        	SAFER_SCOPEID_MACHINE,
            bFromShellExecute,
        	pbResult
        );
	if (!NT_SUCCESS(Status)) {
	    Status = __CodeAuthzIsExecutableFileTypeHelper(
				UnicodeFullPathname,
	        	SAFER_SCOPEID_USER,
                bFromShellExecute,
	        	pbResult
	        );
	}
	return Status;
}

BOOL WINAPI
SaferiIsExecutableFileType(
        IN LPCWSTR      szFullPathname,
        IN BOOLEAN  bFromShellExecute
        )
/*++

Routine Description:

    This API determines if a specified filename has an extension that
    is considered an "executable" extension.  Applications can take
    special precautions to avoid invoking untrusted files that might
    be considered executable.

    Common examples of extensions that are considered executable include:
    EXE, COM, BAT, CMD, VBS, JS, URL, LNK, SHS, PIF, PL, and others.

Arguments:

    szFullPathname - pointer to a Null-terminated Unicode string of the
        full path and/or filename to evaluate.  Only the file's extension
        (the portion of the specified path following the last period)
        is used in this evaluation.  File extension comparisons are done
        case-insensitively, without regard to case.

        An error will be returned if this pointer is NULL, or if the length
        of the path is zero, or if the file does not have an extension.

        Although applications are encouraged to supply the entire,
        fully-qualified pathname to this API, the szFullPathname argument
        will also accept only the file extension, by ensuring that the
        file extension is preceeded by a period (for example:  L".exe")
        
    bFromShellExecute - for performance reasons, if this is being called 
        from ShellExecute, we'd like to skip exe checking since CreateProcess 
        will do the check

Return Value:

    Returns TRUE if the API executes successfully and the filepath's
    extension was recognized as one of the "executable extensions".
    Otherwise a return value of FALSE will either indicate unsuccessful
    API execution, or identification of a non-executable extension.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING UnicodePathname;
    BOOLEAN bResult;

    RtlInitUnicodeString(&UnicodePathname, szFullPathname);
    Status = CodeAuthzIsExecutableFileType(
                &UnicodePathname, bFromShellExecute, &bResult);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }
    if (!bResult) {
        BaseSetLastNTError(STATUS_NOT_FOUND);
        return FALSE;
    } else {
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\safecat.c ===
//depot/main/DS/security/winsafer/safecat.c#8 - integrate change 7547 (text)
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    safecat.cpp         (SAFER SaferComputeTokenFromLevel)

Abstract:

    This module implements the WinSAFER APIs to compute a new restricted
    token from a more privileged one, utilizing an "Code Authorization
    Level Object", which specifies the actions to perform to apply
    the restrictions.

Author:

    Jeffrey Lawson (JLawson) - Nov 1999

Environment:

    User mode only.

Exported Functions:

    CodeAuthzpGetTokenInformation               (private)
    CodeAuthzpSidInSidAndAttributes             (private)
    CodeAuthzpModifyTokenPermissions            (private)
    CodeAuthzpInvertPrivs                       (private)
    SaferComputeTokenFromLevel
    CompareCodeAuthzObjectWithToken
    CodeAuthzpGetAuthzObjectRestrictions        (private)

Revision History:

    Created - Nov 1999

--*/

#include "pch.h"
#pragma hdrstop
#include <seopaque.h>       // needed for sertlp.h
#include <sertlp.h>         // RtlpDaclAddrSecurityDescriptor
#include <winsafer.h>
#include <winsaferp.h>
#include "saferp.h"



//
// Internal prototypes of other functions defined locally within this file.
//

NTSTATUS NTAPI
CodeAuthzpModifyTokenPermissions(
    IN HANDLE   hToken,
    IN PSID     pExplicitSid,
    IN DWORD    dwExplicitPerms,
    IN PSID     pExplicitSid2       OPTIONAL,
    IN DWORD    dwExplicitPerms2    OPTIONAL
    );

NTSTATUS NTAPI
CodeAuthzpModifyTokenOwner(
    IN HANDLE   hToken,
    IN PSID     NewOwnerSid
    );

BOOL
IsSaferDisabled(
    void
    )
{
    static int g_nDisableSafer = -1;
            // -1 means we didn't check yet
            //  0 means safer is enabled
            //  1 means safer is disabled

    static const UNICODE_STRING KeyNameSafeBoot =
        RTL_CONSTANT_STRING(L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\SafeBoot\\Option");
    static const UNICODE_STRING ValueNameSafeBoot =
        RTL_CONSTANT_STRING(L"OptionValue");
    static const OBJECT_ATTRIBUTES objaSafeBoot =
        RTL_CONSTANT_OBJECT_ATTRIBUTES(&KeyNameSafeBoot, OBJ_CASE_INSENSITIVE);

    HANDLE                      hKey;
    BYTE ValueBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD)];
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInformation =
            (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
    DWORD                       ValueLength;
    NTSTATUS                    Status;

    //
    // First see if we already checked the registry
    //
    if (g_nDisableSafer == 1) {
        return TRUE;
    }

    if (g_nDisableSafer == 0) {
        return FALSE;
    }

    //
    // This is the only time we check for safeboot by going to the registry
    // Opening the key for "write" tells us if we are an admin.
	// 
    Status = NtOpenKey(&hKey, KEY_QUERY_VALUE | KEY_SET_VALUE, (POBJECT_ATTRIBUTES) &objaSafeBoot);
    if (NT_SUCCESS(Status)) {
        Status = NtQueryValueKey(hKey,
                                 (PUNICODE_STRING) &ValueNameSafeBoot,
                                 KeyValuePartialInformation,
                                 pKeyValueInformation,
                                 sizeof(ValueBuffer),
                                 &ValueLength);

        NtClose(hKey);

        if (NT_SUCCESS(Status) &&
            pKeyValueInformation->Type == REG_DWORD &&
            pKeyValueInformation->DataLength == sizeof(DWORD)) {
            //
            // If the value exists and it's not 0 then we are in one of SafeBoot modes.
            // Return TRUE in this case to disable the shim infrastructure
            //
            if (*((PDWORD) pKeyValueInformation->Data) > 0) {
                g_nDisableSafer = 1;
                return TRUE;
            }
        }
    }

    g_nDisableSafer = 0;

    return FALSE;
}


LPVOID NTAPI
CodeAuthzpGetTokenInformation(
    IN HANDLE                       TokenHandle,
    IN TOKEN_INFORMATION_CLASS      TokenInformationClass
    )
/*++

Routine Description:

    Returns a pointer to allocated memory containing a specific
    type of information class about the specified token.  This
    wrapper function around GetTokenInformation() handles the
    allocation of memory of the appropriate size needed.

Arguments:

    TokenHandle - specifies the token that should be used
        to obtain the specified information from.

    TokenInformationClass - specifies the information class wanted.

Return Value:

    Returns NULL on error.  Otherwise caller must free the returned
    structure with RtlFreeHeap().

--*/
{
    DWORD dwSize = 128;
    LPVOID pTokenInfo = NULL;

    if (ARGUMENT_PRESENT(TokenHandle))
    {
        pTokenInfo = (LPVOID)RtlAllocateHeap(RtlProcessHeap(), 0, dwSize);
        if (pTokenInfo != NULL)
        {
            DWORD dwNewSize;
            NTSTATUS Status;

            Status = NtQueryInformationToken(
                    TokenHandle, TokenInformationClass,
                    pTokenInfo, dwSize, &dwNewSize);
            if (Status == STATUS_BUFFER_TOO_SMALL)
            {
                RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) pTokenInfo);

                pTokenInfo = (LPVOID)RtlAllocateHeap(RtlProcessHeap(), 0, dwNewSize);
                if (pTokenInfo != NULL)
                {
                    Status = NtQueryInformationToken(
                        TokenHandle, TokenInformationClass,
                        pTokenInfo, dwNewSize, &dwNewSize);
                }
            }
            if (!NT_SUCCESS(Status))
            {
                RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) pTokenInfo);
                pTokenInfo = NULL;
            }
        }
    }

    return pTokenInfo;
}



BOOLEAN NTAPI
CodeAuthzpSidInSidAndAttributes (
    IN PSID_AND_ATTRIBUTES  SidAndAttributes,
    IN ULONG                SidCount,
    OPTIONAL IN PSID        SePrincipalSelfSid,
    OPTIONAL IN PSID        PrincipalSelfSid,
    IN PSID                 Sid,
    BOOLEAN                 HonorEnabledAttribute
    )
/*++

Routine Description:

    Checks to see if a given SID is in the given token.

    N.B. The code to compute the length of a SID and test for equality
         is duplicated from the security runtime since this is such a
         frequently used routine.

    This function is mostly copied from the SepSidInSidAndAttributes
    found in ntos\se\tokendup.c, except it handles PrincipalSelfSid
    within the list as well as the passed in Sid.  SePrincipalSelfSid
    is also a parameter here, instead of an ntoskrnl global.  also the
    HonorEnabledAttribute argument was added.

Arguments:

    SidAndAttributes - Pointer to the sid and attributes to be examined

    SidCount - Number of entries in the SidAndAttributes array.

    SePrincipalSelfSid - This parameter should optionally be the SID that
        will be replaced with the PrincipalSelfSid if this SID is encountered
        in any ACE.  This SID should be generated from SECURITY_PRINCIPAL_SELF_RID

        The parameter should be NULL if the object does not represent a principal.


    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        SECURITY_PRINCIPAL_SELF_RID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.


    Sid - Pointer to the SID of interest


    HonorEnabledAttribute - If this argument is TRUE, then only Sids in the
        SidsAndAttributes array that have the Attribute SE_GROUP_ENABLED set
        will be processed during the evaluation.

Return Value:

    A value of TRUE indicates that the SID is in the token, FALSE
    otherwise.

--*/
{
    ULONG i;
    PISID MatchSid;
    ULONG SidLength;
    PSID_AND_ATTRIBUTES TokenSid;
    ULONG UserAndGroupCount;



    if (!ARGUMENT_PRESENT( SidAndAttributes ) ) {
        return(FALSE);
    }
    ASSERT(Sid != NULL);

    //
    // If Sid is the constant PrincipalSelfSid,
    //  replace it with the passed in PrincipalSelfSid.
    //

    if ( ARGUMENT_PRESENT(PrincipalSelfSid) &&
         ARGUMENT_PRESENT(SePrincipalSelfSid) &&
         RtlEqualSid( SePrincipalSelfSid, Sid ) ) {

        ASSERT(!RtlEqualSid(SePrincipalSelfSid, PrincipalSelfSid));
        Sid = PrincipalSelfSid;
    }

    //
    // Get the length of the source SID since this only needs to be computed
    // once.
    //

    SidLength = 8 + (4 * ((PISID)Sid)->SubAuthorityCount);

    //
    // Get address of user/group array and number of user/groups.
    //

    ASSERT(SidAndAttributes != NULL);
    TokenSid = SidAndAttributes;
    UserAndGroupCount = SidCount;

    //
    // Scan through the user/groups and attempt to find a match with the
    // specified SID.
    //

    for (i = 0 ; i < UserAndGroupCount ; i++)
    {
        if (!HonorEnabledAttribute ||
            (TokenSid->Attributes & SE_GROUP_ENABLED) != 0)
        {
            MatchSid = (PISID)TokenSid->Sid;
            ASSERT(MatchSid != NULL);

            //
            // If the SID is the principal self SID, then replace it.
            //

            if ( ARGUMENT_PRESENT(SePrincipalSelfSid) &&
                 ARGUMENT_PRESENT(PrincipalSelfSid) &&
                 RtlEqualSid(SePrincipalSelfSid, MatchSid)) {

                MatchSid = (PISID) PrincipalSelfSid;
            }


            //
            // If the SID revision and length matches, then compare the SIDs
            // for equality.
            //

            if ((((PISID)Sid)->Revision == MatchSid->Revision) &&
                (SidLength == (8 + (4 * (ULONG)MatchSid->SubAuthorityCount)))) {

                if (RtlEqualMemory(Sid, MatchSid, SidLength)) {

                    return TRUE;

                }
            }
        }

        TokenSid++;
    }

    return FALSE;
}


NTSTATUS NTAPI
CodeAuthzpModifyTokenPermissions(
    IN HANDLE   hToken,
    IN PSID     pExplicitSid,
    IN DWORD    dwExplicitPerms,
    IN PSID     pExplicitSid2       OPTIONAL,
    IN DWORD    dwExplicitPerms2    OPTIONAL
    )

/*++

Routine Description:

    An internal function to make some additional permission modifications
    on a newly created restricted token.

Arguments:

    hToken - token to modify

    pExplicitSid - explicitly named SID to add to the token's DACL.

    dwExplicitPerms - permissions given to the explicitly named SID
            when it is added to the DACL.

    pExplicitSid2 - (optional) secondary named SID to add to the DACL.

    dwExplicitPerms2 - (optional) secondary permissions given to the
            secondary SID when it is added to the DACL.

Return Value:

    A value of TRUE indicates that the operation was successful,
    FALSE otherwise.

--*/

{
    NTSTATUS            Status       = STATUS_SUCCESS;
    PACL                pTokenDacl   = NULL;
    PUCHAR              Buffer       = NULL;
    TOKEN_DEFAULT_DACL  TokenDefDacl = {0};
    ULONG               BufferLength = 0;
    ULONG               AclLength    = 0;

    //
    // Verify that our arguments were supplied.  Since this is
    // an internal function, we just assert instead of doing
    // real argument checking.
    //

    ASSERT(ARGUMENT_PRESENT(hToken));
    ASSERT(ARGUMENT_PRESENT(pExplicitSid) && RtlValidSid(pExplicitSid));
    ASSERT(!ARGUMENT_PRESENT(pExplicitSid2) || RtlValidSid(pExplicitSid2));

    //
    // Retrieve the default acl in the token.
    //

    Status = NtQueryInformationToken(
                    hToken,
                    TokenDefaultDacl,
                    NULL,
                    0, 
                    (PULONG) &BufferLength
                    );

    if (Status == STATUS_BUFFER_TOO_SMALL)
    {
        //
        // Allocate memory for the buffer.
        //

        Buffer = (PUCHAR) RtlAllocateHeap(RtlProcessHeap(), 0, BufferLength);

        if (!Buffer) 
        {
            Status = STATUS_NO_MEMORY;
            goto ExitHandler;
        }

        //
        // Perform the query again and actually get it.
        //

        Status = NtQueryInformationToken(
                        hToken,
                        TokenDefaultDacl,
                        Buffer, 
                        BufferLength, 
                        (PULONG) &BufferLength
                        );

        if (!NT_SUCCESS(Status)) 
        {
            goto ExitHandler;
        }

        AclLength = ((PTOKEN_DEFAULT_DACL) Buffer)->DefaultDacl->AclSize;

        //
        // Calculate how much size we might need in the worst case where
        // we have to enlarge the DACL.
        //

        AclLength += (sizeof(ACCESS_ALLOWED_ACE) +
                      RtlLengthSid(pExplicitSid) -
                      sizeof(DWORD));

        if (ARGUMENT_PRESENT(pExplicitSid2)) 
        {
            AclLength += (sizeof(ACCESS_ALLOWED_ACE) +
                          RtlLengthSid(pExplicitSid2) -
                          sizeof(DWORD));
        }

        //
        // Allocate memory to hold the new acl.
        //

        pTokenDacl = (PACL) RtlAllocateHeap(RtlProcessHeap(), 0, AclLength);

        if (!pTokenDacl) 
        {
            Status = STATUS_NO_MEMORY;
            goto ExitHandler;
        }

        //
        // Copy the old acl into allocated memory.
        //

        RtlCopyMemory(
            pTokenDacl, 
            ((PTOKEN_DEFAULT_DACL) Buffer)->DefaultDacl,
            ((PTOKEN_DEFAULT_DACL) Buffer)->DefaultDacl->AclSize
            );

        //
        // Set the acl size to the new size.
        //

        pTokenDacl->AclSize = (USHORT) AclLength;

    } 
    else if (!NT_SUCCESS(Status)) 
    {
        goto ExitHandler;
    } 
    else 
    {
        //
        // If we get here, there's a bug in Nt code.
        //

        ASSERT(FALSE);
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }

    ASSERT(RtlValidAcl(pTokenDacl));

    //
    // Create the new DACL that includes the extra ACEs that we want.
    //

    Status = RtlAddAccessAllowedAceEx(
                    pTokenDacl,
                    ACL_REVISION,
                    CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
                    dwExplicitPerms,
                    pExplicitSid
                    );

    if (!NT_SUCCESS(Status)) 
    {
        ASSERT(Status != STATUS_ALLOTTED_SPACE_EXCEEDED);
        goto ExitHandler;
    }

    if (ARGUMENT_PRESENT(pExplicitSid2))
    {
        Status = RtlAddAccessAllowedAceEx(
                        pTokenDacl,
                        ACL_REVISION,
                        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
                        dwExplicitPerms2,
                        pExplicitSid2
                        );

        if (!NT_SUCCESS(Status)) 
        {
            ASSERT(Status != STATUS_ALLOTTED_SPACE_EXCEEDED);
            goto ExitHandler;
        }

    }

    ASSERT(RtlValidAcl(pTokenDacl));

    //
    // Set the Default DACL within the token to the DACL that we built.
    //

    RtlZeroMemory(&TokenDefDacl, sizeof(TOKEN_DEFAULT_DACL));
    TokenDefDacl.DefaultDacl = pTokenDacl;

    Status = NtSetInformationToken(
                    hToken,
                    TokenDefaultDacl,
                    &TokenDefDacl,
                    sizeof(TOKEN_DEFAULT_DACL)
                    );

    if (!NT_SUCCESS(Status)) 
    {
        goto ExitHandler;
    }

    Status = STATUS_SUCCESS;      // success


ExitHandler:
    if (pTokenDacl != NULL)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, pTokenDacl);
    }

    if (Buffer != NULL)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, Buffer);
    }

    return Status;
}



NTSTATUS NTAPI
CodeAuthzpModifyTokenOwner(
    IN HANDLE       hToken,
    IN PSID         NewOwnerSid
    )
{
    NTSTATUS Status;
    TOKEN_OWNER tokenowner;

    //
    // Verify that we have our arguments.
    //
    if (!ARGUMENT_PRESENT(hToken) ||
        !ARGUMENT_PRESENT(NewOwnerSid)) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }


    //
    // Set the owner of the Token.
    //
    RtlZeroMemory(&tokenowner, sizeof(TOKEN_OWNER));
    tokenowner.Owner = NewOwnerSid;
    Status = NtSetInformationToken(hToken, TokenOwner,
                    &tokenowner, sizeof(TOKEN_OWNER));

ExitHandler:
    return Status;
}



BOOLEAN NTAPI
CodeAuthzpInvertPrivs(
    IN HANDLE                   InAccessToken,
    IN DWORD                    dwNumInvertedPrivs,
    IN PLUID_AND_ATTRIBUTES     pInvertedPrivs,
    OUT PDWORD                  dwOutNumPrivs,
    OUT PLUID_AND_ATTRIBUTES   *pResultingPrivs
    )
/*++

Routine Description:


Arguments:

    InAccessToken -

    dwNumInvertedPrivs -

    pInvertedPrivs -

    dwOutNumPrivs -

    pResultingPrivs -

Return Value:

    Returns FALSE on error, TRUE on success.

--*/
{
    PTOKEN_PRIVILEGES pTokenPrivileges;
    DWORD Index, InnerIndex;


    //
    // Obtain the list of currently held privileges.
    //
    ASSERT( ARGUMENT_PRESENT(InAccessToken) );
    pTokenPrivileges = (PTOKEN_PRIVILEGES)
        CodeAuthzpGetTokenInformation(InAccessToken, TokenPrivileges);
    if (!pTokenPrivileges) goto ExitHandler;


    //
    // Squeeze out any privileges that were specified to us,
    // leaving only those privileges that weren't specified.
    //
    ASSERT( ARGUMENT_PRESENT(pInvertedPrivs) );
    for (Index = 0; Index < pTokenPrivileges->PrivilegeCount; Index++)
    {
        for (InnerIndex = 0; InnerIndex < dwNumInvertedPrivs; InnerIndex++)
        {
            if (RtlEqualMemory(&pTokenPrivileges->Privileges[Index].Luid,
                    &pInvertedPrivs[InnerIndex].Luid, sizeof(LUID)) )
            {
                pTokenPrivileges->PrivilegeCount--;
                RtlMoveMemory(&pTokenPrivileges->Privileges[Index],
                    &pTokenPrivileges->Privileges[Index + 1],
                    pTokenPrivileges->PrivilegeCount - Index);
                Index--;
                break;
            }
        }
    }


    //
    // Return the number of final privileges.  Also, convert the
    // TOKEN_PRIVILEGES structure into just a LUID_AND_ATTRIBUTES array.
    // There will be some unused slack at the end of the used portion
    // of the array, but that is fine (some array entries have probably
    // already been squeezed out).
    //
    *dwOutNumPrivs = pTokenPrivileges->PrivilegeCount;
    RtlMoveMemory(pTokenPrivileges, &pTokenPrivileges->Privileges[0],
         pTokenPrivileges->PrivilegeCount * sizeof(LUID_AND_ATTRIBUTES) );
    *pResultingPrivs = (PLUID_AND_ATTRIBUTES) pTokenPrivileges;
    return TRUE;


ExitHandler:
    return FALSE;
}



NTSTATUS NTAPI
__CodeAuthzpComputeAccessTokenFromCodeAuthzObject (
    IN PAUTHZLEVELTABLERECORD     pLevelRecord,
    IN HANDLE                   InAccessToken OPTIONAL,
    OUT PHANDLE                 OutAccessToken,
    IN DWORD                    dwFlags,
    IN LPVOID                   lpReserved,
    IN DWORD                    dwSaferIdentFlags OPTIONAL
    )
/*++

Routine Description:

    Uses the specified WinSafer Level to apply various restrictions
    or modifications to the specified InAccessToken to produce a
    Restricted Token that can be used to execute processes with.
    Alternatively, the returned Restricted Token can be used for
    thread impersonation to selectively perform operations within a
    less-privileged environment.

Arguments:

    pLevelRecord - the record structure of the Level to evaluate.

    InAccessToken - Optionally specifies the input Token that will be
        modified with restrictions.  If this argument is NULL, then the
        Token for the currently executing process will be opened and used.

    OutAccessToken - Specifies the memory region to receive the resulting
        Restricted Token.

    dwFlags - Specifies additional flags that can be used to control the
        restricted token creation:

            SAFER_TOKEN_MAKE_INERT -
            SAFER_TOKEN_NULL_IF_EQUAL -
            SAFER_TOKEN_WANT_FLAGS -

    lpReserved - extra parameter used for some dwFlag combinations.

    dwSaferIdentFlags - extra SaferFlags bits derived from the matched
        Code Identifier record entry.  These extra bits are ORed to
        combine them with the SaferFlags associated with the Level.

Return Value:

    Returns -1 if the input Level record is the Disallowed level.

    Returns STATUS_SUCCESS on a successful operation, otherwise the
    errorcode of the failure that occurred.

--*/
{
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    NTSTATUS Status;
    BOOL InAccessTokenWasSupplied = FALSE;
    HANDLE RestrictedToken = NULL;
    DWORD FinalFilterFlags;
    DWORD SaferFlags;
    BOOL InertStateChanged = FALSE;

    PSID restrictedSid = NULL;
    PTOKEN_USER pTokenUser = NULL;
    PSID principalSelfSid = NULL;

    DWORD FinalDisabledSidCount;
    PSID_AND_ATTRIBUTES FinalSidsToDisable = NULL;
    BOOL FreeFinalDisabledSids = FALSE;

    DWORD FinalRestrictedSidCount;
    PSID_AND_ATTRIBUTES FinalSidsToRestrict = NULL;
    BOOL FreeFinalRestrictedSids = FALSE;

    DWORD FinalPrivsToDeleteCount;
    PLUID_AND_ATTRIBUTES FinalPrivsToDelete = NULL;
    BOOL FreeFinalPrivsToDelete = FALSE;


    OBJECT_ATTRIBUTES ObjAttr = {0};
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService = {0};
    SECURITY_DESCRIPTOR sd = {0};

    //
    // Verify that our input arguments were supplied.
    //
    if (!ARGUMENT_PRESENT(pLevelRecord)) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto ExitHandler;
    }
    if (!ARGUMENT_PRESENT(OutAccessToken)) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }


    //
    // Ensure that we have the parent token that will be
    // used for the creation of the restricted token.
    //
    if (ARGUMENT_PRESENT(InAccessToken)) {
        InAccessTokenWasSupplied = TRUE;
    } else {
        Status = NtOpenThreadToken(NtCurrentThread(),
                TOKEN_DUPLICATE | READ_CONTROL | TOKEN_QUERY,
                TRUE, &InAccessToken);
        if (!NT_SUCCESS(Status)) {
            Status = NtOpenProcessToken(NtCurrentProcess(),
                    TOKEN_DUPLICATE | READ_CONTROL | TOKEN_QUERY,
                    &InAccessToken);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;       // could not obtain default token
            }
        }
    }



    //
    // Figure out the combined effect of the "SaferFlags".
    // Also figure out what flags we'll pass to NtFilterToken.
    // Note that all of the bits within the SaferFlags can be
    // combined by bitwise-OR, except for the JOBID portion.
    //
    FinalFilterFlags = (pLevelRecord->DisableMaxPrivileges ?
                        DISABLE_MAX_PRIVILEGE : 0);
    if ((dwSaferIdentFlags & SAFER_POLICY_JOBID_MASK) != 0) {
        SaferFlags = dwSaferIdentFlags |
            (pLevelRecord->SaferFlags & ~SAFER_POLICY_JOBID_MASK);
    } else {
        SaferFlags = pLevelRecord->SaferFlags | dwSaferIdentFlags;
    }
    if ((dwFlags & SAFER_TOKEN_MAKE_INERT) != 0 ||
        (SaferFlags & SAFER_POLICY_SANDBOX_INERT) != 0)
    {
        SaferFlags |= SAFER_POLICY_SANDBOX_INERT;
        FinalFilterFlags |= SANDBOX_INERT;
    }



    //
    // Retrieve the User's personal SID.
    // (user's SID is accessible afterwards with "pTokenUser->User.Sid")
    //

    pTokenUser = (PTOKEN_USER) CodeAuthzpGetTokenInformation(
                                   InAccessToken, 
                                   TokenUser
                                   );

    if (pTokenUser == NULL) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }

    //
    // Quick check to see if we can expect a change in the
    // token's "Sandbox Inert" state to occur.
    //
    {
        ULONG bIsInert = 0;
        ULONG ulReturnLength;

        Status = NtQueryInformationToken(
                    InAccessToken,
                    TokenSandBoxInert,
                    &bIsInert,
                    sizeof(bIsInert),
                    &ulReturnLength);
        if (NT_SUCCESS(Status) && bIsInert) {
            if ( (dwFlags & SAFER_TOKEN_NULL_IF_EQUAL) != 0) {
                // The output token was not made any more restrictive during
                // this operation, so pass back NULL and return success.
                *OutAccessToken = NULL;
                Status = STATUS_SUCCESS;
                goto ExitHandler;
            } else {
                
                SecurityQualityOfService.Length = sizeof( SECURITY_QUALITY_OF_SERVICE  );
                SecurityQualityOfService.ImpersonationLevel = SecurityAnonymous;
                SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
                SecurityQualityOfService.EffectiveOnly = FALSE;

                Status = RtlCreateSecurityDescriptor(
                            &sd, 
                            SECURITY_DESCRIPTOR_REVISION
                            );

                if (!NT_SUCCESS(Status)) {
                    goto ExitHandler;
                }
                Status = RtlSetOwnerSecurityDescriptor(
                             &sd, 
                             pTokenUser->User.Sid, 
                             FALSE
                             );

                if (!NT_SUCCESS(Status)) {
                    goto ExitHandler;
                }

                InitializeObjectAttributes(
                        &ObjAttr,
                        NULL,
                        OBJ_INHERIT,
                        NULL,
                        &sd
                        );

                ObjAttr.SecurityQualityOfService = &SecurityQualityOfService;

                Status = NtDuplicateToken(
                             InAccessToken,
                             TOKEN_ALL_ACCESS,
                             &ObjAttr,
                             FALSE,
                             TokenPrimary,
                             OutAccessToken
                             );
                
                goto ExitHandler;
            }
        } else {
            if ((FinalFilterFlags & SANDBOX_INERT) != 0) {
                // the input token was not "SandBox Inert" and
                // we're being requested to make it.
                InertStateChanged = TRUE;
            }
        }
    }

    //
    // If this is not allowed to execute, then break out now.
    //
    if (pLevelRecord->DisallowExecution) {
        Status = -1;            // special status code
        goto ExitHandler;
    }


    //
    // Process PrivsToDelete inversion.
    //
    if (pLevelRecord->InvertDeletePrivs != FALSE)
    {
        if (!CodeAuthzpInvertPrivs(
                InAccessToken,
                pLevelRecord->DeletePrivilegeUsedCount,
                pLevelRecord->PrivilegesToDelete,
                &FinalPrivsToDeleteCount,
                &FinalPrivsToDelete))
        {
            Status = STATUS_UNSUCCESSFUL;
            goto ExitHandler;
        }
        FreeFinalPrivsToDelete = TRUE;
    }
    else
    {
        FinalPrivsToDeleteCount = pLevelRecord->DeletePrivilegeUsedCount;
        FinalPrivsToDelete = pLevelRecord->PrivilegesToDelete;
    }


    //
    // Process SidsToDisable inversion.
    //
    if (pLevelRecord->InvertDisableSids != FALSE)
    {
        if (!CodeAuthzpInvertAndAddSids(
                InAccessToken,
                pTokenUser->User.Sid,
                pLevelRecord->DisableSidUsedCount,
                pLevelRecord->SidsToDisable,
                0,
                NULL,
                &FinalDisabledSidCount,
                &FinalSidsToDisable))
        {
            Status = STATUS_UNSUCCESSFUL;
            goto ExitHandler;
        }
        FreeFinalDisabledSids = TRUE;
    }
    else
    {
        if (pLevelRecord->DisableSidUsedCount == 0 ||
            pLevelRecord->SidsToDisable == NULL)
        {
            FinalSidsToDisable = NULL;
            FinalDisabledSidCount = 0;
            FreeFinalDisabledSids = FALSE;
        } else {
            if (!CodeAuthzpExpandWildcardList(
                InAccessToken,
                pTokenUser->User.Sid,
                pLevelRecord->DisableSidUsedCount,
                pLevelRecord->SidsToDisable,
                &FinalDisabledSidCount,
                &FinalSidsToDisable))
            {
                Status = STATUS_UNSUCCESSFUL;
                goto ExitHandler;
            }
            FreeFinalDisabledSids = TRUE;
        }
    }


    //
    // Process RestrictingSids inversion.
    //
    if (pLevelRecord->RestrictedSidsInvUsedCount != 0)
    {
        if (!CodeAuthzpInvertAndAddSids(
                InAccessToken,
                pTokenUser->User.Sid,
                pLevelRecord->RestrictedSidsInvUsedCount,
                pLevelRecord->RestrictedSidsInv,
                pLevelRecord->RestrictedSidsAddedUsedCount,
                pLevelRecord->RestrictedSidsAdded,
                &FinalRestrictedSidCount,
                &FinalSidsToRestrict))
        {
            Status = STATUS_UNSUCCESSFUL;
            goto ExitHandler;
        }
        FreeFinalRestrictedSids = TRUE;
    }
    else
    {
        FinalRestrictedSidCount = pLevelRecord->RestrictedSidsAddedUsedCount;
        FinalSidsToRestrict = pLevelRecord->RestrictedSidsAdded;
    }


    //
    // In some cases, we can bail out early if we were called with
    // the compare-only flag, and we know that there should not be
    // any actual changes being made to the token.
    //
    if (!InertStateChanged &&
        FinalDisabledSidCount == 0 &&
        FinalPrivsToDeleteCount == 0 &&
        FinalRestrictedSidCount == 0 &&
        (FinalFilterFlags & DISABLE_MAX_PRIVILEGE) == 0)
    {
        if ( (dwFlags & SAFER_TOKEN_NULL_IF_EQUAL) != 0) {
            // The output token was not made any more restrictive during
            // this operation, so pass back NULL and return success.
            *OutAccessToken = NULL;
            Status = STATUS_SUCCESS;
            goto ExitHandler;
        } else {
            // OPTIMIZATION: for this case we can consider using DuplicateToken
        }
    }


    //
    // Create the actual restricted token.
    //
    if (!CreateRestrictedToken(
            InAccessToken,              // handle to existing token
            FinalFilterFlags,           // privilege options and inert
            FinalDisabledSidCount,      // number of deny-only SIDs
            FinalSidsToDisable,         // deny-only SIDs
            FinalPrivsToDeleteCount,    // number of privileges
            FinalPrivsToDelete,         // privileges
            FinalRestrictedSidCount,    // number of restricting SIDs
            FinalSidsToRestrict,        // list of restricting SIDs
            &RestrictedToken            // handle to new token
        ))
    {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }


    //
    // If the caller requested SAFER_TOKEN_NULL_IF_EQUAL
    // then do the evaluation now.
    // Notice that NtCompareTokens intentionally does not
    // consider possible differences in the SandboxInert
    // flag, so we have to handle that case ourself.
    //
    if ( (dwFlags & SAFER_TOKEN_NULL_IF_EQUAL) != 0 &&
         !InertStateChanged )
    {
        BOOLEAN bResult = FALSE;

        Status = NtCompareTokens(InAccessToken, RestrictedToken, &bResult);
        if (!NT_SUCCESS(Status)) {
            // An error occurred during the comparison.
            goto ExitHandler;
        }
        if (bResult) {
            // The output token was not made any more restrictive during
            // this operation, so pass back NULL and return success.
            *OutAccessToken = NULL;
            Status = STATUS_SUCCESS;
            goto ExitHandler;
        }
    }



    //
    // Build the "Restricted Code" SID.
    //
    Status = RtlAllocateAndInitializeSid( &SIDAuth, 1,
        SECURITY_RESTRICTED_CODE_RID, 0, 0, 0, 0, 0, 0, 0,
        &restrictedSid);
    if (! NT_SUCCESS(Status) ) goto ExitHandler;


    //
    // Build the "Principal Self" SID.
    //
    Status = RtlAllocateAndInitializeSid( &SIDAuth, 1,
        SECURITY_PRINCIPAL_SELF_RID, 0, 0, 0, 0, 0, 0, 0,
        &principalSelfSid);
    if (! NT_SUCCESS(Status) ) goto ExitHandler;


    //
    // Duplicate the token into a primary token and simultaneously
    // update the owner to the user's personal SID, instead of the
    // user of the current thread token.
    //
    {
        OBJECT_ATTRIBUTES ObjA;
        HANDLE NewTokenHandle;

        //
        // Initialize a SECURITY_ATTRIBUTES and SECURITY_DESCRIPTOR
        // to force the owner to the personal user SID.
        //
        Status = RtlCreateSecurityDescriptor(
                &sd, SECURITY_DESCRIPTOR_REVISION);
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler;
        }
        Status = RtlSetOwnerSecurityDescriptor(
                &sd, pTokenUser->User.Sid, FALSE);
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler;
        }

        //
        // Only a primary token can be assigned to a process, so
        // we must duplicate the restricted token so we can ensure
        // the we can assign it to the new process.
        //
        SecurityQualityOfService.Length = sizeof( SECURITY_QUALITY_OF_SERVICE  );
        SecurityQualityOfService.ImpersonationLevel = SecurityAnonymous;
        SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        SecurityQualityOfService.EffectiveOnly = FALSE;
        InitializeObjectAttributes(
                &ObjA,
                NULL,
                OBJ_INHERIT,
                NULL,
                &sd
                );
        ObjA.SecurityQualityOfService = &SecurityQualityOfService;
        Status = NtDuplicateToken(
                RestrictedToken,   // handle to token to duplicate
                TOKEN_ALL_ACCESS,  // access rights of new token
                &ObjA,             // attributes
                FALSE,
                TokenPrimary,      // primary or impersonation token
                &NewTokenHandle    // handle to duplicated token
                );
        if (Status == STATUS_INVALID_OWNER) {
            // If we failed once, then it might be because the new owner
            // that was specified in the Security Descriptor could not
            // be set, so retry but without the SD specified.
            ObjA.SecurityDescriptor = NULL;
            Status = NtDuplicateToken(
                    RestrictedToken,   // handle to token to duplicate
                    TOKEN_ALL_ACCESS,  // access rights of new token
                    &ObjA,             // attributes
                    FALSE,
                    TokenPrimary,      // primary or impersonation token
                    &NewTokenHandle    // handle to duplicated token
                    );
        }
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler;
        }
        ASSERT(NewTokenHandle != NULL);
        NtClose(RestrictedToken);
        RestrictedToken = NewTokenHandle;
    }


    //
    // Modify permissions on the token.  This involves:
    //    1) edit the DACL on the token to explicitly grant the special
    //       permissions to the User SID and to the Restricted SID.
    //    2) optionally change owner to specified SID.
    //
    {
        PSID defaultOwner = ( (pLevelRecord->DefaultOwner != NULL &&
                    RtlEqualSid(pLevelRecord->DefaultOwner, principalSelfSid)) ?
                        pTokenUser->User.Sid : pLevelRecord->DefaultOwner);

        Status = CodeAuthzpModifyTokenPermissions(
                RestrictedToken,           // token to modify.
                pTokenUser->User.Sid,      // explicitly named SID to add to the DACL.
                GENERIC_ALL,
                (pLevelRecord->dwLevelId < SAFER_LEVELID_NORMALUSER ?
                        restrictedSid : NULL),             // optional secondary named SID to add to the DACL
                GENERIC_ALL
                );

        if (NT_SUCCESS(Status) && defaultOwner != NULL) {
            Status = CodeAuthzpModifyTokenOwner(
                    RestrictedToken,
                    defaultOwner);
        }
        if (!NT_SUCCESS(Status)) {
            NtClose(RestrictedToken);
            goto ExitHandler;
        }
    }


    //
    // Return the result.
    //
    ASSERT(OutAccessToken != NULL);
    *OutAccessToken = RestrictedToken;
    RestrictedToken = NULL;
    Status = STATUS_SUCCESS;


    //
    // Cleanup and epilogue code.
    //
ExitHandler:
    if (RestrictedToken != NULL)
        NtClose(RestrictedToken);
    if (pTokenUser != NULL)
        RtlFreeHeap(RtlProcessHeap(), 0, pTokenUser);
    if (restrictedSid != NULL)
        RtlFreeSid(restrictedSid);
    if (principalSelfSid != NULL)
        RtlFreeSid(principalSelfSid);
    if (FreeFinalDisabledSids)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) FinalSidsToDisable);
    if (FreeFinalRestrictedSids)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) FinalSidsToRestrict);
    if (FreeFinalPrivsToDelete)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) FinalPrivsToDelete);

    //
    // If the caller specified SAFER_TOKEN_WANT_SAFERFLAGS then we
    // need to copy the JobFlags value into the lpReserved parameter.
    //
    if ( Status == STATUS_SUCCESS &&
        (dwFlags & SAFER_TOKEN_WANT_FLAGS) != 0 )
    {
        if (ARGUMENT_PRESENT(lpReserved)) {
            *((LPDWORD)lpReserved) = SaferFlags;
        }
    }

    //
    // Close the process token if it wasn't supplied and we opened it.
    //
    if (!InAccessTokenWasSupplied && InAccessToken != NULL)
        NtClose(InAccessToken);

    return Status;
}


NTSTATUS NTAPI
__CodeAuthzpCompareCodeAuthzLevelWithToken(
    IN PAUTHZLEVELTABLERECORD   pLevelRecord,
    IN HANDLE                   InAccessToken     OPTIONAL,
    IN LPDWORD                  lpResultWord
    )
/*++

Routine Description:

    Performs a "light-weight" evaluation of the token manipulations that
    would be performed if the InAccessToken were restricted with the
    specified WinSafer Level.  The return code indicates if any
    modifications would actually be done to the token (ie: a distinctly
    less-privileged token would be created).

    This function is intended to be used to decide if a DLL (with the
    specified WinSafer Level) is authorized enough to be loaded into
    the specified process context handle, but without actually having
    to create a restricted token since a separate token won't actually
    be needed.

Arguments:

    pLevelRecord - the record structure of the Level to evaluate.

    InAccessToken - optionally the access token to use as a parent token.
            If this argument is not supplied, then the current process
            token will be opened and used.

    lpResultWord - receives the result of the evaluation when function
            is successful (value is left indeterminate if not successful).
            This result will be value 1 if the level is equal or more
            privileged than the InAccessToken, or value -1 if the level
            is less privileged (more restrictions necessary).


Return Value:

    Returns STATUS_SUCCESS on successful evaluation, otherwise returns
    the error status code.  When successful, lpResultWord receives
    the result of the evaluation.

--*/
{
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    NTSTATUS Status;
    BOOLEAN TokenWasSupplied = FALSE;
    DWORD Index;

    PTOKEN_USER pTokenUser = NULL;
    PSID principalSelfSid = NULL;
    PTOKEN_PRIVILEGES pTokenPrivs = NULL;
    PTOKEN_GROUPS pTokenGroups = NULL;
    PTOKEN_GROUPS pTokenRestrictedSids = NULL;

    DWORD FinalDisabledSidCount;
    PSID_AND_ATTRIBUTES FinalSidsToDisable;
    BOOLEAN FreeFinalDisabledSids = FALSE;
    DWORD FinalRestrictedSidCount;
    PSID_AND_ATTRIBUTES FinalSidsToRestrict;
    BOOLEAN FreeFinalRestrictedSids = FALSE;
    DWORD FinalPrivsToDeleteCount;
    PLUID_AND_ATTRIBUTES FinalPrivsToDelete;
    BOOLEAN FreeFinalPrivsToDelete = FALSE;
    
    ULONG bIsInert = 0;
    ULONG ulReturnLength;


    //
    // Ensure that we have a place to write the result.
    //
    if (!ARGUMENT_PRESENT(pLevelRecord)) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto ExitHandler;
    }
    if (!ARGUMENT_PRESENT(lpResultWord)) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }

    //
    // Ensure that we have the token that will be
    // used for the comparison test.
    //
    if (ARGUMENT_PRESENT(InAccessToken)) {
        TokenWasSupplied = TRUE;
    } else {
        Status = NtOpenThreadToken(NtCurrentThread(),
                TOKEN_DUPLICATE | READ_CONTROL | TOKEN_QUERY,
                TRUE, &InAccessToken);
        if (!NT_SUCCESS(Status)) {
            Status = NtOpenProcessToken(NtCurrentProcess(),
                    TOKEN_DUPLICATE | READ_CONTROL | TOKEN_QUERY,
                    &InAccessToken);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;       // could not obtain default token
            }
        }
    }


    //
    // check if token is inert - if so, this object is definitely not more restrictive 
    //

    Status = NtQueryInformationToken(
                InAccessToken,
                TokenSandBoxInert,
                &bIsInert,
                sizeof(bIsInert),
                &ulReturnLength);
    
    if (NT_SUCCESS(Status)) {
        if ( bIsInert ) {
            *lpResultWord = +1;
            goto ExitHandler2;
        }
    }
    else {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler2;
    }



    //
    // If this is not allowed to execute, then break out now and return LESS.
    //
    if (pLevelRecord->DisallowExecution) {
        *lpResultWord = (DWORD) -1;        // Less priv'ed.
        Status = STATUS_SUCCESS;
        goto ExitHandler2;
    }


    //
    // Evaluate the privileges that should be deleted.
    //
    if (pLevelRecord->InvertDeletePrivs != FALSE)
    {
        if (!CodeAuthzpInvertPrivs(
                InAccessToken,
                pLevelRecord->DeletePrivilegeUsedCount,
                pLevelRecord->PrivilegesToDelete,
                &FinalPrivsToDeleteCount,
                &FinalPrivsToDelete))
        {
            Status = STATUS_UNSUCCESSFUL;
            goto ExitHandler2;
        }
        FreeFinalPrivsToDelete = TRUE;

        //
        // If there are any Privileges that need to be deleted, then
        // this object definitely less restricted than the token.
        //
        if (FinalPrivsToDeleteCount != 0)
        {
            *lpResultWord = (DWORD) -1;        // Less priv'ed.
            Status = STATUS_SUCCESS;
            goto ExitHandler3;
        }
    }
    else
    {
        //
        // Get the list of privileges held by the token.
        //
        pTokenPrivs = (PTOKEN_PRIVILEGES) CodeAuthzpGetTokenInformation(
                InAccessToken, TokenPrivileges);
        if (!pTokenPrivs) {
            Status = STATUS_UNSUCCESSFUL;
            goto ExitHandler2;
        }


        //
        // if PrivsToRemove includes a Privilege not yet disabled,
        // then return LESS.
        //
        for (Index = 0; Index < pLevelRecord->DeletePrivilegeUsedCount; Index++)
        {
            DWORD InnerLoop;
            PLUID pLuid = &pLevelRecord->PrivilegesToDelete[Index].Luid;

            for (InnerLoop = 0; InnerLoop < pTokenPrivs->PrivilegeCount; InnerLoop++)
            {
                if ( RtlEqualMemory(&pTokenPrivs->Privileges[InnerLoop].Luid,
                        pLuid, sizeof(LUID)) )
                {
                    *lpResultWord = (DWORD) -1;        // Less priv'ed.
                    Status = STATUS_SUCCESS;
                    goto ExitHandler3;
                }
            }
        }
    }



    //
    // Retrieve the User's personal SID.
    // (user's SID is accessible afterwards with "pTokenUser->User.Sid")
    //
    pTokenUser = (PTOKEN_USER) CodeAuthzpGetTokenInformation(
            InAccessToken, TokenUser);
    if (pTokenUser == NULL) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler3;
    }


    //
    // Process SidsToDisable inversion.
    //
    if (pLevelRecord->InvertDisableSids != FALSE)
    {
        if (!CodeAuthzpInvertAndAddSids(
                InAccessToken,
                pTokenUser->User.Sid,
                pLevelRecord->DisableSidUsedCount,
                pLevelRecord->SidsToDisable,
                0,
                NULL,
                &FinalDisabledSidCount,
                &FinalSidsToDisable))
        {
            Status = STATUS_UNSUCCESSFUL;
            goto ExitHandler3;
        }
        FreeFinalDisabledSids = TRUE;
    }
    else
    {
        if (pLevelRecord->DisableSidUsedCount == 0 ||
            pLevelRecord->SidsToDisable == NULL)
        {
            FinalSidsToDisable = NULL;
            FinalDisabledSidCount = 0;
            FreeFinalDisabledSids = FALSE;
        } else {
            if (!CodeAuthzpExpandWildcardList(
                InAccessToken,
                pTokenUser->User.Sid,
                pLevelRecord->DisableSidUsedCount,
                pLevelRecord->SidsToDisable,
                &FinalDisabledSidCount,
                &FinalSidsToDisable))
            {
                Status = STATUS_UNSUCCESSFUL;
                goto ExitHandler3;
            }
            FreeFinalDisabledSids = TRUE;
        }
    }



    //
    // Get the list of group membership from the token.
    //
    pTokenGroups = (PTOKEN_GROUPS) CodeAuthzpGetTokenInformation(
            InAccessToken, TokenGroups);
    if (!pTokenGroups) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler3;
    }



    //
    // Build the "Principal Self" SID.
    //
    Status = RtlAllocateAndInitializeSid( &SIDAuth, 1,
        SECURITY_PRINCIPAL_SELF_RID, 0, 0, 0, 0, 0, 0, 0,
        &principalSelfSid);
    if (! NT_SUCCESS(Status) ) {
        goto ExitHandler3;
    }


    //
    // if SidsToDisable includes a SID in Groups that is not
    // yet disabled, then return LESS.
    //
    for (Index = 0; Index < FinalDisabledSidCount; Index++)
    {
        if (CodeAuthzpSidInSidAndAttributes (
                pTokenGroups->Groups,
                pTokenGroups->GroupCount,
                principalSelfSid,
                pTokenUser->User.Sid,
                FinalSidsToDisable[Index].Sid,
                TRUE))                  // check only SIDs that are still enabled
        {
            Status = STATUS_SUCCESS;
            *lpResultWord = (DWORD) -1;        // Less priv'ed.
            goto ExitHandler3;
        }
    }


    //
    // Process RestrictingSids inversion.
    //
    if (pLevelRecord->RestrictedSidsInvUsedCount != 0)
    {
        if (!CodeAuthzpInvertAndAddSids(
                InAccessToken,
                pTokenUser->User.Sid,
                pLevelRecord->RestrictedSidsInvUsedCount,
                pLevelRecord->RestrictedSidsInv,
                pLevelRecord->RestrictedSidsAddedUsedCount,
                pLevelRecord->RestrictedSidsAdded,
                &FinalRestrictedSidCount,
                &FinalSidsToRestrict))
        {
            Status = STATUS_UNSUCCESSFUL;
            goto ExitHandler3;
        }
        FreeFinalRestrictedSids = TRUE;
    }
    else
    {
        FinalRestrictedSidCount = pLevelRecord->RestrictedSidsAddedUsedCount;
        FinalSidsToRestrict = pLevelRecord->RestrictedSidsAdded;
    }


    //
    // Get the existing Restricted SIDs from the token.
    //
    pTokenRestrictedSids = (PTOKEN_GROUPS) CodeAuthzpGetTokenInformation(
            InAccessToken, TokenRestrictedSids);
    if (!pTokenRestrictedSids) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler3;
    }


    if (pTokenRestrictedSids->GroupCount != 0)
    {
        //
        // If there are currently no Restricting SIDs and we
        // have to add any, then return LESS.
        //
        if (pTokenRestrictedSids->GroupCount == 0 &&
            FinalRestrictedSidCount != 0)
        {
            *lpResultWord = (DWORD) -1;        // Less priv'ed.
            Status = STATUS_SUCCESS;
            goto ExitHandler3;
        }


        //
        // If the token already includes a Restricting SID that is
        // not in RestrictedSidsAdded then return LESS.
        //
        for (Index = 0; Index < pTokenRestrictedSids->GroupCount; Index++)
        {
            if (!CodeAuthzpSidInSidAndAttributes (
                FinalSidsToRestrict,
                FinalRestrictedSidCount,
                principalSelfSid,
                pTokenUser->User.Sid,
                pTokenRestrictedSids->Groups[Index].Sid,
                FALSE))                     // check all SIDs in the list
            {
                *lpResultWord = (DWORD) -1;        // Less priv'ed.
                Status = STATUS_SUCCESS;
                goto ExitHandler3;
            }
        }
    }
    else
    {
        //
        // if RestrictedSidsAdded then return LESS.
        //
        if (FinalRestrictedSidCount != 0)
        {
            *lpResultWord = (DWORD) -1;        // Less priv'ed.
            Status = STATUS_SUCCESS;
            goto ExitHandler3;
        }
    }


    //
    // If we got here, then the Level is equal or greater
    // privileged than the access token and is safe to run.
    // We could conceivably also want to return LESS if the
    // default owner needs to be changed from what it currently is.
    //
    *lpResultWord = +1;
    Status = STATUS_SUCCESS;



    //
    // Cleanup and epilogue code.
    //
ExitHandler3:
    if (principalSelfSid != NULL)
        RtlFreeSid(principalSelfSid);
    if (pTokenRestrictedSids != NULL)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) pTokenRestrictedSids);
    if (pTokenGroups != NULL)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) pTokenGroups);
    if (pTokenPrivs != NULL)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) pTokenPrivs);
    if (pTokenUser != NULL)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) pTokenUser);
    if (FreeFinalDisabledSids)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) FinalSidsToDisable);
    if (FreeFinalRestrictedSids)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) FinalSidsToRestrict);
    if (FreeFinalPrivsToDelete)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) FinalPrivsToDelete);


ExitHandler2:

ExitHandler:
    if (!TokenWasSupplied && InAccessToken != NULL)
        NtClose(InAccessToken);

    return Status;
}



BOOL WINAPI
SaferComputeTokenFromLevel(
        IN SAFER_LEVEL_HANDLE      hLevelObject,
        IN HANDLE           InAccessToken         OPTIONAL,
        OUT PHANDLE         OutAccessToken,
        IN DWORD            dwFlags,
        IN LPVOID           lpReserved
        )
/*++

Routine Description:

    Uses the specified WinSafer Level handle to apply various
    restrictions or modifications to the specified InAccessToken
    to produce a Restricted Token that can be used to execute
    processes with.

Arguments:

    hLevelObject - the WinSafer Level handle that specifies the
        restrictions that should be applied.

    InAccessToken - Optionally specifies the input Token that will be
        modified with restrictions.  If this argument is NULL, then the
        Token for the currently executing process will be opened and used.

    OutAccessToken - Specifies the memory region to receive the resulting
        Restricted Token.

    dwFlags - Specifies additional flags that can be used to control the
        restricted token creation.

    lpReserved - reserved for future use, must be zero.

Return Value:

    A value of TRUE indicates that the operation was successful,
    FALSE otherwise.

--*/
{
    NTSTATUS Status;
    PAUTHZLEVELHANDLESTRUCT pLevelStruct;
    PAUTHZLEVELTABLERECORD pLevelRecord;
    
    OBJECT_ATTRIBUTES ObjAttr = {0};
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService = {0};
    SECURITY_DESCRIPTOR sd;
    PTOKEN_USER pTokenUser = NULL;


    //
    // Verify our input arguments are minimally okay.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    if (!ARGUMENT_PRESENT(hLevelObject)) {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler;
    }

    if (IsSaferDisabled()) {
		Status = STATUS_SUCCESS;
        if ( (dwFlags & SAFER_TOKEN_NULL_IF_EQUAL) != 0) {
            // The output token was not made any more restrictive during
            // this operation, so pass back NULL and return success.
            *OutAccessToken = NULL;
            Status = STATUS_SUCCESS;
        } else {
            
            //
            // Retrieve the User's personal SID.
            // (user's SID is accessible afterwards with "pTokenUser->User.Sid")
            //
            
            pTokenUser = (PTOKEN_USER) CodeAuthzpGetTokenInformation(
                                           InAccessToken, 
                                           TokenUser
                                           );
            
            if (pTokenUser == NULL) {
                Status = STATUS_UNSUCCESSFUL;
                goto ExitHandler;
            }

            SecurityQualityOfService.Length = sizeof( SECURITY_QUALITY_OF_SERVICE  );
            SecurityQualityOfService.ImpersonationLevel = SecurityAnonymous;
            SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
            SecurityQualityOfService.EffectiveOnly = FALSE;

            Status = RtlCreateSecurityDescriptor(
                        &sd, 
                        SECURITY_DESCRIPTOR_REVISION
                        );

            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            Status = RtlSetOwnerSecurityDescriptor(
                         &sd, 
                         pTokenUser->User.Sid, 
                         FALSE
                         );

            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }

            InitializeObjectAttributes(
                    &ObjAttr,
                    NULL,
                    OBJ_INHERIT,
                    NULL,
                    &sd
                    );

            ObjAttr.SecurityQualityOfService = &SecurityQualityOfService;

            Status = NtDuplicateToken(
                         InAccessToken,
                         TOKEN_ALL_ACCESS,
                         &ObjAttr,
                         FALSE,
                         TokenPrimary,
                         OutAccessToken
                         );

        }
        goto ExitHandler;
	} 

    //
    // Obtain the pointer to the level handle structure.
    //
    RtlEnterCriticalSection(&g_TableCritSec);

    Status = CodeAuthzHandleToLevelStruct(hLevelObject, &pLevelStruct);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }
    ASSERT(pLevelStruct != NULL);
    pLevelRecord = CodeAuthzLevelObjpLookupByLevelId(
                &g_CodeLevelObjTable, pLevelStruct->dwLevelId);
    if (!pLevelRecord) {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler2;
    }


	// 
	// Perform the actual computation or comparison operation.
    //
    if ((dwFlags & SAFER_TOKEN_COMPARE_ONLY) != 0) {
        Status = __CodeAuthzpCompareCodeAuthzLevelWithToken(
                        pLevelRecord,
                        InAccessToken,
                        (LPDWORD) lpReserved);
    }
    else {
        Status = __CodeAuthzpComputeAccessTokenFromCodeAuthzObject (
                        pLevelRecord,
                        InAccessToken,
                        OutAccessToken,
                        dwFlags,
                        lpReserved,
                        pLevelStruct->dwSaferFlags);
    }


    //
    // Cleanup and return code handling.
    //
ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);

ExitHandler:
    if (pTokenUser) {
        LocalFree(pTokenUser);
    }
    if (Status == -1) {
        SetLastError(ERROR_ACCESS_DISABLED_BY_POLICY);
        return FALSE;
    }
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }
    return TRUE;
}


BOOL WINAPI
IsTokenUntrusted(
        IN HANDLE   hToken
        )
/*++

Routine Description:

    Indicate if the token does is not able to access a DACL against the
    Token User SID.  This is typically the case in these situations:
      - the User SID is disabled (for deny-use only)
      - there are Restricting SIDs and the User SID is not one of them.

    The passed token handle must have been opened for TOKEN_QUERY and
    TOKEN_DUPLICATE access or else the evaluation will fail.

Arguments:

    hToken - Specifies the input Token that will be analyzed.

Return Value:

    Returns TRUE if the token is "untrusted", or FALSE if the token
    represents a "trusted" token.

    If an error occurs during the evaluation of this check, the result
    returned will be TRUE (assumed untrusted).

--*/
{
    BOOL fTrusted = FALSE;
    DWORD dwStatus;
    DWORD dwACLSize;
    DWORD cbps = sizeof(PRIVILEGE_SET);
    PACL pACL = NULL;
    DWORD dwUserSidSize;
    PTOKEN_USER psidUser = NULL;
    PSECURITY_DESCRIPTOR psdUser = NULL;
    PRIVILEGE_SET ps;
    GENERIC_MAPPING gm;
    HANDLE hImpToken;

    const int TESTPERM_READ = 1;
    const int TESTPERM_WRITE = 2;


    // Prepare some memory
    ZeroMemory(&ps, sizeof(ps));
    ZeroMemory(&gm, sizeof(gm));

    // Get the User's SID.
    if (!GetTokenInformation(hToken, TokenUser, NULL, 0, &dwUserSidSize))
    {
        psidUser = (PTOKEN_USER) LocalAlloc(LPTR, dwUserSidSize);
        if (psidUser != NULL)
        {
            if (GetTokenInformation(hToken, TokenUser, psidUser, dwUserSidSize, &dwUserSidSize))
            {
                // Create the Security Descriptor (SD)
                psdUser = LocalAlloc(LPTR,SECURITY_DESCRIPTOR_MIN_LENGTH);
                if (psdUser != NULL)
                {
                    if(InitializeSecurityDescriptor(psdUser,SECURITY_DESCRIPTOR_REVISION))
                    {
                        // Compute size needed for the ACL then allocate the
                        // memory for it
                        dwACLSize = sizeof(ACCESS_ALLOWED_ACE) + 8 +
                                    GetLengthSid(psidUser->User.Sid) - sizeof(DWORD);
                        pACL = (PACL)LocalAlloc(LPTR, dwACLSize);
                        if (pACL != NULL)
                        {
                            // Initialize the new ACL
                            if(InitializeAcl(pACL, dwACLSize, ACL_REVISION2))
                            {
                                // Add the access-allowed ACE to the DACL
                                if(AddAccessAllowedAce(pACL,ACL_REVISION2,
                                                     (TESTPERM_READ | TESTPERM_WRITE),psidUser->User.Sid))
                                {
                                    // Set our DACL to the Administrator's SD
                                    if (SetSecurityDescriptorDacl(psdUser, TRUE, pACL, FALSE))
                                    {
                                        // AccessCheck is downright picky about what is in the SD,
                                        // so set the group and owner
                                        SetSecurityDescriptorGroup(psdUser,psidUser->User.Sid,FALSE);
                                        SetSecurityDescriptorOwner(psdUser,psidUser->User.Sid,FALSE);

                                        // Initialize GenericMapping structure even though we
                                        // won't be using generic rights
                                        gm.GenericRead = TESTPERM_READ;
                                        gm.GenericWrite = TESTPERM_WRITE;
                                        gm.GenericExecute = 0;
                                        gm.GenericAll = TESTPERM_READ | TESTPERM_WRITE;

                                        if (ImpersonateLoggedOnUser(hToken) &&
                                            OpenThreadToken(GetCurrentThread(),
                                                    TOKEN_QUERY, FALSE, &hImpToken))
                                        {

                                            if (!AccessCheck(psdUser, hImpToken, TESTPERM_READ, &gm,
                                                            &ps,&cbps,&dwStatus,&fTrusted))
                                                    fTrusted = FALSE;

                                            CloseHandle(hImpToken);
                                        }
                                    }
                                }
                            }
                            LocalFree(pACL);
                        }
                    }
                    LocalFree(psdUser);
                }
            }
            LocalFree(psidUser);
        }
    }
    RevertToSelf();
    return(!fTrusted);
}



BOOL WINAPI
SaferiCompareTokenLevels (
        IN HANDLE   ClientAccessToken,
        IN HANDLE   ServerAccessToken,
        OUT PDWORD  pdwResult
        )
/*++

Routine Description:

    Private function provided to try to empiracally determine if
    the two access token have been restricted with comparable
    WinSafer authorization Levels.

Arguments:

    ClientAccessToken - handle to the Access Token of the "client"

    ServerAccessToken - handle to the Access Token of the "server"

    pdwResult - When TRUE is returned, the pdwResult output parameter
        will receive any of the following values:
        -1 = Client's access token is more authorized than Server's.
         0 = Client's access token is comparable level to Server's.
         1 = Server's access token is more authorized than Clients's.

Return Value:

    A value of TRUE indicates that the operation was successful,
    FALSE otherwise.

--*/
{
    NTSTATUS Status;
    LPVOID RestartKey;
    PAUTHZLEVELTABLERECORD authzobj;
    DWORD dwCompareResult;


    //
    // Verify our input arguments are minimally okay.
    //
    if (!ARGUMENT_PRESENT(ClientAccessToken) ||
        !ARGUMENT_PRESENT(ServerAccessToken)) {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler;
    }
    if (!ARGUMENT_PRESENT(pdwResult)) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }


    //
    // Gain the critical section lock and load the tables as needed.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_bNeedCacheReload) {
        Status = CodeAuthzpImmediateReloadCacheTables();
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
    }
    if (RtlIsGenericTableEmpty(&g_CodeLevelObjTable)) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler2;
    }


    //
    // Loop through the Authorization Levels and see where we
    // find the first difference in access rights.
    //
    dwCompareResult = 0;
    RestartKey = NULL;
    for (authzobj = (PAUTHZLEVELTABLERECORD)
                RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeLevelObjTable, &RestartKey);
        authzobj != NULL;
        authzobj = (PAUTHZLEVELTABLERECORD)
                RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeLevelObjTable, &RestartKey))
    {
        DWORD dwClientResult, dwServerResult;

        Status = __CodeAuthzpCompareCodeAuthzLevelWithToken(
                authzobj,
                ClientAccessToken,
                &dwClientResult);
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }

        Status = __CodeAuthzpCompareCodeAuthzLevelWithToken(
                authzobj,
                ServerAccessToken,
                &dwServerResult);
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }

        if (dwClientResult == (DWORD) -1 && dwServerResult != (DWORD) -1) {
            dwCompareResult = (DWORD) -1;
            break;
        } else if (dwClientResult != (DWORD) -1 && dwServerResult == (DWORD) -1) {
            dwCompareResult = 1;
            break;
        } else if (dwClientResult != (DWORD) -1 && dwServerResult != (DWORD) -1) {
            dwCompareResult = 0;
            break;
        }
    }
    Status = STATUS_SUCCESS;
    *pdwResult = dwCompareResult;


    //
    // Cleanup and return code handling.
    //
ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);

ExitHandler:
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\safehand.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    SafeHand.c        (WinSAFER Handle Operations)

Abstract:

    This module implements the WinSAFER APIs to open and close handles
    to SAFER Code Authorization Levels.

Author:

    Jeffrey Lawson (JLawson) - Nov 1999

Environment:

    User mode only.

Exported Functions:

    CodeAuthzHandleToLevelStruct
    CodeAuthzpOpenPolicyRootKey
    CodeAuthzCreateLevelHandle
    CodeAuthzCloseLevelHandle
    SaferCreateLevel                (public win32 api)
    SaferCloseLevel                 (public win32 api)

Revision History:

    Created - Nov 1999

--*/

#include "pch.h"
#pragma hdrstop
#include <winsafer.h>
#include <winsaferp.h>
#include "saferp.h"


//
// All handles have a bit pattern OR-ed onto them to serve both
// as a debugging aid in distinguishing obvious non-handles,
// and also to ensure that a zero handle is never given back.
//
#define LEVEL_HANDLE_BITS   0x74000000
#define LEVEL_HANDLE_MASK   0xFF000000



NTSTATUS NTAPI
CodeAuthzpCreateLevelHandleFromRecord(
        IN PAUTHZLEVELTABLERECORD   pLevelRecord,
        IN DWORD                    dwScopeId,
        IN DWORD                    dwSaferFlags OPTIONAL,
        IN DWORD                    dwExtendedError,
        IN SAFER_IDENTIFICATION_TYPES IdentificationType,
        IN REFGUID                  refIdentGuid OPTIONAL,
        OUT SAFER_LEVEL_HANDLE            *pLevelHandle
        )
/*++

Routine Description:

    Converts a level record to an opaque SAFER_LEVEL_HANDLE handle.

    Note that although this function assumes that the global
    critical section has already been obtained by the caller.

Arguments:

    pLevelRecord - specifies the level record for which the
        request is being made.  It is assumed that this record
        is valid and exists within the g_CodeLevelObjTable.

    dwScopeId - indicates the scope that will be stored within
        the opened handle.  This scope affects the behavior of
        Get/SetInfoCodeAuthzLevel for code identifiers.

    dwSaferFlags - indicates any optional Safer flags that were
        derived from the matching code identifier.  These bits
        will be bitwise ORed in SaferComputeTokenFromLevel.

    dwExtendedError - Error returned by WinVerifyTrust.

    IdentificationType - Rule that identified this level.
    
    refIdentGuid - indicates the Code Identifier record that was
        used to match the given level.  This may be NULL.

    pLevelHandle - receives the resulting opaque Level handle.

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status;
    ULONG ulHandleIndex;
    PAUTHZLEVELHANDLESTRUCT pLevelStruct;


    ASSERT(ARGUMENT_PRESENT(pLevelRecord) &&
           ARGUMENT_PRESENT(pLevelHandle));


    //
    // Validate the value passed within the dwScope argument.
    //
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE &&
            dwScopeId != SAFER_SCOPEID_USER) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler;
        }
    }


    //
    // Allocate a handle to represent this level.
    //
    pLevelStruct = (PAUTHZLEVELHANDLESTRUCT) RtlAllocateHandle(
                        &g_LevelHandleTable,
                        &ulHandleIndex);
    if (!pLevelStruct) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ExitHandler;
    }
    ASSERT((ulHandleIndex & LEVEL_HANDLE_MASK) == 0);
    *pLevelHandle = UlongToPtr(ulHandleIndex | LEVEL_HANDLE_BITS);


    //
    // Fill in the handle structure to represent this level.
    //
    RtlZeroMemory(pLevelStruct, sizeof(AUTHZLEVELHANDLESTRUCT));
    pLevelStruct->HandleHeader.Flags = RTL_HANDLE_ALLOCATED;
    pLevelStruct->dwLevelId = pLevelRecord->dwLevelId;
    pLevelStruct->dwScopeId = dwScopeId;
    pLevelStruct->dwSaferFlags = dwSaferFlags;
    pLevelStruct->dwHandleSequence = g_dwLevelHandleSequence;
    pLevelStruct->dwExtendedError = dwExtendedError;
    pLevelStruct->IdentificationType = IdentificationType;
    if (ARGUMENT_PRESENT(refIdentGuid)) {
        RtlCopyMemory(&pLevelStruct->identGuid, refIdentGuid, sizeof(GUID));
    } else {
        ASSERT(IsZeroGUID(&pLevelStruct->identGuid));
    }
    Status = STATUS_SUCCESS;


ExitHandler:
    return Status;
}


NTSTATUS NTAPI
CodeAuthzHandleToLevelStruct(
            IN SAFER_LEVEL_HANDLE          hLevelObject,
            OUT PAUTHZLEVELHANDLESTRUCT  *pLevelStruct)
/*++

Routine Description:

    Converts an opaque SAFER_LEVEL_HANDLE handle into a pointer to the
    internal handle structure.

    Note that although this function gains and releases access to
    the critical section during the API execution, the caller is
    expected to have already entered the critical section and
    maintain the critical section for the entire duration under
    which the return pLevelStruct will be used.  Otherwise, the
    pLevelStruct can potentially become invalid if another thread
    reloads the cache tables and invalidates all handles.

Arguments:

    hLevelObject - specifies the handle to the AuthzObject for which the
        request is being made.

    lpLevelObjectStruct - receives a pointer to the internal handle
        structure that represents the specified AuthzLevelObject.

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status;
    ULONG ulHandleIndex;

    if (!g_bInitializedFirstTime) {
        return STATUS_UNSUCCESSFUL;
    }
    if (!ARGUMENT_PRESENT(hLevelObject)) {
        return STATUS_INVALID_HANDLE;
    }
    if (!ARGUMENT_PRESENT(pLevelStruct)) {
        return STATUS_ACCESS_VIOLATION;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    ASSERT(!g_bNeedCacheReload);


    //
    // Translate the handle index into a pointer to the handle structure.
    //
    ulHandleIndex = PtrToUlong(hLevelObject);
    if ( (ulHandleIndex & LEVEL_HANDLE_MASK) != LEVEL_HANDLE_BITS) {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler;
    }
    ulHandleIndex &= ~LEVEL_HANDLE_MASK;
    if (!RtlIsValidIndexHandle(&g_LevelHandleTable, ulHandleIndex,
                          (PRTL_HANDLE_TABLE_ENTRY*) pLevelStruct)) {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler;
    }

    //
    // Verify some additional sanity checks on the handle structure
    // that was mapped.  Ensure that it was not a handle that was
    // opened, but invalidated because CodeAuthzReloadCacheTables was
    // called before closing then Level handle.
    //
    if (*pLevelStruct == NULL ||
        (*pLevelStruct)->dwHandleSequence != g_dwLevelHandleSequence ||
        !CodeAuthzLevelObjpLookupByLevelId(
                    &g_CodeLevelObjTable, (*pLevelStruct)->dwLevelId ) )
    {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler;
    }
    Status = STATUS_SUCCESS;


ExitHandler:
    RtlLeaveCriticalSection(&g_TableCritSec);
    return Status;
}




NTSTATUS NTAPI
CodeAuthzCreateLevelHandle(
        IN DWORD            dwLevelId,
        IN DWORD            OpenFlags,
        IN DWORD            dwScopeId,
        IN DWORD            dwSaferFlags OPTIONAL,
        OUT SAFER_LEVEL_HANDLE    *pLevelHandle)
/*++

Routine Description:

    Internal function to open a handle to a WinSafer Level.

Arguments:

    dwLevelId - input level of the WinSafer Level to open.
        Note that the dwScopeId argument does not affect the scope
        of the level that is opened itself.

    OpenFlags - flags that affect how the object is opened.

    dwScopeId - input scope identifier that is stored within the
        resulting handle.  This scope identifier is used to affect
        the behavior of SaferGet/SetLevelInformation for code identifier.

    dwSaferFlags - flags that are stored within the resulting handle.
        These flags are usually derived from the code identifier
        that matched, and will be used in the final call to
        SaferComputeTokenFromLevel.

    pLevelHandle - receives the new handle.

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status;
    PAUTHZLEVELTABLERECORD pLevelRecord;



    //
    // Verify our input arguments are okay.
    //
    if (!ARGUMENT_PRESENT(pLevelHandle)) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }
    if ((OpenFlags & SAFER_LEVEL_CREATE) != 0 ||
        (OpenFlags & SAFER_LEVEL_DELETE) != 0) {
        // BLACKCOMB TODO: need to support creation or deletion.
        Status = STATUS_NOT_IMPLEMENTED;
        goto ExitHandler;
    }
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_bNeedCacheReload) {
        Status = CodeAuthzpImmediateReloadCacheTables();
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
    }


    //
    // Find the cached record for the requested level.
    //
    pLevelRecord = CodeAuthzLevelObjpLookupByLevelId(
                            &g_CodeLevelObjTable,
                            dwLevelId);
    if (!pLevelRecord) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler2;
    }
    ASSERT(pLevelRecord->dwLevelId == dwLevelId);


    //
    // Actually create a Level handle for this record.
    //
    Status = CodeAuthzpCreateLevelHandleFromRecord(
                    pLevelRecord, dwScopeId,
                    dwSaferFlags, ERROR_SUCCESS, SaferIdentityDefault, NULL, pLevelHandle);


    //
    // Handle cleanup and error handling.
    //
ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);

ExitHandler:
    return Status;
}


NTSTATUS NTAPI
CodeAuthzCloseLevelHandle(
            IN SAFER_LEVEL_HANDLE      hLevelObject)
/*++

Routine Description:

    Internal function to close an AuthzObject handle.

Arguments:

    hLevelObject - the AuthzObject handle to close.

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status;
    ULONG ulHandleIndex;
    PAUTHZLEVELHANDLESTRUCT pLevelStruct;

    if (!ARGUMENT_PRESENT(hLevelObject)) {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler;
    }
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);

    ulHandleIndex = PtrToUlong(hLevelObject);
    if ( (ulHandleIndex & LEVEL_HANDLE_MASK) != LEVEL_HANDLE_BITS) {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler2;
    }
    ulHandleIndex &= ~LEVEL_HANDLE_MASK;
    if (!RtlIsValidIndexHandle(&g_LevelHandleTable, ulHandleIndex,
                   (PRTL_HANDLE_TABLE_ENTRY *) &pLevelStruct)) {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler2;
    }
    if (!RtlFreeHandle(&g_LevelHandleTable,
                  (PRTL_HANDLE_TABLE_ENTRY) pLevelStruct)) {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler2;
    }
    Status = STATUS_SUCCESS;

ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);
ExitHandler:
    return Status;
}



BOOL WINAPI
SaferCreateLevel(
            IN DWORD            dwScopeId,
            IN DWORD            dwLevelId,
            IN DWORD            OpenFlags,
            OUT SAFER_LEVEL_HANDLE    *pLevelObject,
            IN LPVOID           lpReserved)
/*++

Routine Description:

    Public function implementing the Unicode version of this API,
    allowing the user to create or open an Authorization Object
    and receive a handle representing the object.

Arguments:

    dwScopeId - not used (anymore), reserved for future use.

    dwLevelId - input object level of the AuthzObject to create/open.

    OpenFlags - flags to control opening, creation, or deletion.

    lpReserved - not used, reserved for future use.

    pLevelObject - receives the new handle.

Return Value:

    Returns FALSE on error, TRUE on success.  Sets GetLastError() on error.

--*/
{
    NTSTATUS Status;


    //
    // Verify the arguments were all supplied.
    //
    UNREFERENCED_PARAMETER(lpReserved);
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    if (!ARGUMENT_PRESENT(pLevelObject)) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE &&
            dwScopeId != SAFER_SCOPEID_USER) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    }


    //
    // Actually call the worker functions to get it done.
    //
    Status = CodeAuthzCreateLevelHandle(
                    dwLevelId,
                    OpenFlags,
                    dwScopeId,
                    0,
                    pLevelObject);

    //
    // Set the error result.
    //
ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);

ExitHandler:
    if ( NT_SUCCESS( Status ) ) {
        return TRUE;
    }
    BaseSetLastNTError(Status);
    return FALSE;
}



BOOL WINAPI
SaferCloseLevel(
            IN SAFER_LEVEL_HANDLE hLevelObject)
/*++

Routine Description:

    Public function to close a handle to an Authorization Level Object.

Arguments:

    hLevelObject - the AuthzObject handle to close.

Return Value:

    Returns FALSE on error, TRUE on success.

--*/
{
    NTSTATUS Status;

    Status = CodeAuthzCloseLevelHandle(hLevelObject);
    if (! NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\winsafer\safeiden.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    SafeIden.c        (WinSAFER SaferIdentifyLevel)

Abstract:

    This module implements the WinSAFER APIs that evaluate the system
    policies to determine which Authorization Level has been configured
    to apply restrictions for a specified application or code library.

Author:

    Jeffrey Lawson (JLawson) - Nov 1999

Environment:

    User mode only.

Exported Functions:

    SaferiSearchMatchingHashRules        (privately exported)
    SaferIdentifyLevel

Revision History:

    Created - Nov 1999

--*/

#include "pch.h"
#pragma hdrstop
#include <md5.h>
#include <wchar.h>  //for swprintf

#pragma warning(push, 3)
#include <wintrust.h>           // WinVerifyTrust
#include <softpub.h>            // WINTRUST_ACTION_GENERIC_VERIFY_V2
#pragma warning(pop)

#include <winsafer.h>
#include <winsaferp.h>
#include "saferp.h"

#define EXPAND_REGPATH

//#define VERBOSE_IDENTIFICATIONS
#ifdef VERBOSE_IDENTIFICATIONS
#define OUTPUTDEBUGSTRING(v)        OutputDebugStringW(v)
#else
#define OUTPUTDEBUGSTRING(v)
#endif

const static GUID guidTrustedCert = SAFER_GUID_RESULT_TRUSTED_CERT;
const static GUID guidDefaultRule = SAFER_GUID_RESULT_DEFAULT_LEVEL;



NTSTATUS NTAPI
__CodeAuthzpEnsureMapped(
        IN OUT PLOCALIDENTITYCONTEXT pIdentContext
        )
/*++

Routine Description:

    Evaluates the supplied identification context structure and
    attempts to gain access to a mapped memory region of the entity
    being identified.  It does the following steps:

        1) if the identification context already has a non-NULL memory
            pointer then returns successfully.
        2) if the identification context has a non-NULL file handle
            then that handle is memory mapped into memory and
            returns successfully.
        3) if the identification context has a non-NULL image filename
            then that filename is opened for read access and memory
            mapped into memory.

    Otherwise the function call is not successful.

    The caller must be sure to call CodeAuthzpEnsureUnmapped later.

Arguments:

    pIdentContext = pointer to the identification context structure.
            After this function call succeeds, the caller can assume
            that pIdentContext->pImageMemory and pIdentContext->ImageSize
            are valid and can be used.

Return Value:

    Returns STATUS_SUCCESS if a memory-mapped image pointer and size
    are now available, otherwise a failure occurred trying to map them.

--*/
{
    HANDLE hMapping;


    ASSERT(ARGUMENT_PRESENT(pIdentContext) &&
           pIdentContext->CodeProps != NULL);


    if (pIdentContext->pImageMemory == NULL ||
        pIdentContext->ImageSize.QuadPart == 0)
    {
        //
        // If a memory pointer and imagesize were supplied to us
        // in the CodeProperties, then just use them directly.
        //
        if (pIdentContext->CodeProps->ImageSize.QuadPart != 0 &&
            pIdentContext->CodeProps->pByteBlock != NULL)
        {
            pIdentContext->pImageMemory =
                    pIdentContext->CodeProps->pByteBlock;
            pIdentContext->ImageSize.QuadPart =
                    pIdentContext->CodeProps->ImageSize.QuadPart;
            pIdentContext->bImageMemoryNeedUnmap = FALSE;
            return STATUS_SUCCESS;
        }

        //
        // Ensure that we have an open file handle, by using the
        // handle supplied to us in the CodeProperties if possible,
        // otherwise by opening the supplied ImagePath.
        //
        if (pIdentContext->hFileHandle == NULL) {
            // no file handle supplied.
            return STATUS_UNSUCCESSFUL;       // failed.
        }


        //
        // Get the size of the file.  We assume that if we had to
        // open the file ourself that the ImageSize cannot be used.
        //
        if (!GetFileSizeEx(pIdentContext->hFileHandle,
                           &pIdentContext->ImageSize)) {
            return STATUS_UNSUCCESSFUL;       // failure
        }
        if (pIdentContext->ImageSize.HighPart != 0) {
            //BLACKCOMB TODO: maybe later handle very large files.
            return STATUS_NO_MEMORY;        // failure--too large.
        }
        if (pIdentContext->ImageSize.QuadPart == 0) {
            return STATUS_UNSUCCESSFUL;       // failure--zero file size.
        }


        //
        // Now that we have an open file handle, open it up
        // as a memory-mapped file mapping.
        //
        hMapping = CreateFileMapping(
                        pIdentContext->hFileHandle,
                        NULL,
                        PAGE_READONLY,
                        (DWORD) 0,      // highword zero
                        (DWORD) pIdentContext->ImageSize.LowPart,
                        NULL);
        if (hMapping == NULL || hMapping == INVALID_HANDLE_VALUE) {
            return STATUS_UNSUCCESSFUL;
        }


        //
        // View map the file into memory.
        //
        pIdentContext->pImageMemory =
            MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0,
                    pIdentContext->ImageSize.LowPart);
        CloseHandle(hMapping);
        if (pIdentContext->pImageMemory == NULL) {
            return STATUS_UNSUCCESSFUL;
        }
        pIdentContext->bImageMemoryNeedUnmap = TRUE;
    }
    return STATUS_SUCCESS;
}


NTSTATUS NTAPI
__CodeAuthzpEnsureUnmapped(
        IN OUT PLOCALIDENTITYCONTEXT        pIdentContext
        )
/*++

Routine Description:

    Reverses the effects of __CodeAuthzEnsureMapped and closes and
    frees any handles that were opened to the specified file.

Arguments:

    pIdentContext - pointer to the context structure.

Return Value:

    Returns STATUS_SUCCESS if no errors occurred.

--*/
{
    ASSERT(pIdentContext != NULL);

    if (pIdentContext->bImageMemoryNeedUnmap &&
        pIdentContext->pImageMemory != NULL)
    {
        UnmapViewOfFile((LPCVOID) pIdentContext->pImageMemory);
        pIdentContext->pImageMemory = NULL;
        pIdentContext->bImageMemoryNeedUnmap = FALSE;
    }

    return STATUS_SUCCESS;
}



NTSTATUS NTAPI
CodeAuthzpComputeImageHash(
        IN PVOID        pImageMemory,
        IN DWORD        dwImageSize,
        OUT PBYTE       pComputedHash OPTIONAL,
        IN OUT PDWORD   pdwHashSize OPTIONAL,
        OUT ALG_ID     *pHashAlgorithm OPTIONAL
        )
/*++

Routine Description:

    Computes an MD5 image hash of a specified region of memory.
    Note, MD5 hashes are always 16 bytes in length.

Arguments:

    pImageMemory - Pointer to a memory buffer to compute the hash of.

    dwImageSize - Total size of the pImageMemory buffer in bytes.

    pComputedHash - Pointer that receives the computed hash.

    pdwHashSize - Pointer to a DWORD value.  On input, this DWORD should
            specify the maximum size of the pComputedHash buffer.
            On successful execution of this function, the length of the
            resulting hash is written to this pointer.

    pHashAlgorithm - pointer to a variable that will receive the hash
            algorithm that was used to compute the hash.  This will
            always be the constant CALG_MD5.

Return Value:

    Returns STATUS_SUCCESS on successful execution.

--*/
{
    MD5_CTX md5ctx;

    //
    // Check the validity of the arguments supplied to us.
    //
    if (!ARGUMENT_PRESENT(pImageMemory) ||
        dwImageSize == 0) {
        return STATUS_INVALID_PARAMETER;
    }
    if (!ARGUMENT_PRESENT(pComputedHash) ||
        !ARGUMENT_PRESENT(pdwHashSize) ||
        *pdwHashSize < 16) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Compute the MD5 hash of it.
    // (this could also be done with CryptCreateHash+CryptHashData)
    //
    MD5Init(&md5ctx);
    MD5Update(&md5ctx, (LPBYTE) pImageMemory, dwImageSize);
    MD5Final(&md5ctx);

    //
    // Copy the hash to the user's buffer.
    //
    RtlCopyMemory(pComputedHash, &md5ctx.digest[0], 16);
    *pdwHashSize = 16;
    if (ARGUMENT_PRESENT(pHashAlgorithm)) {
        *pHashAlgorithm = CALG_MD5;
    }

    return STATUS_SUCCESS;
}




NTSTATUS NTAPI
__CodeAuthzpCheckIdentityPathRules(
        IN OUT PLOCALIDENTITYCONTEXT    pIdentStruct,
        OUT PAUTHZLEVELTABLERECORD       *pFoundLevel,
        OUT PBOOL                       pbExactMatch,
        OUT PAUTHZIDENTSTABLERECORD    *pFoundIdentity
        )
/*++

Routine Description:

    Evaluates a wildcard pattern against a specified pathname and
    indicates if they match.

Arguments:

    pIdentStruct -

    pFoundLevel - receives a pointer to the authorization Level record
        indicated by the best matching rule.

    pbExactMatch - receives a boolean value indicating if the match
        was against an exact fully qualified path rule.

    pFoundIdentity - receives a pointer to the identifier entry rule
        that best matched.

Return Value:

    Returns STATUS_SUCCESS if a WinSafer Level has been found,
    or STATUS_NOT_FOUND if not.  Otherwise an error code.

--*/
{
    NTSTATUS Status;
    PVOID RestartKey;
    UNICODE_STRING UnicodePath;
    WCHAR ExpandedPath[MAX_PATH];
    WCHAR szLongPath[MAX_PATH];
    PAUTHZIDENTSTABLERECORD pAuthzIdentRecord, pBestIdentRecord;
    PAUTHZLEVELTABLERECORD pAuthzLevelRecord;
    LPWSTR lpKeyname = NULL;

    LONG lBestLevelDepth;
    DWORD dwBestLevelId;
    BOOLEAN bFirstPass;

    LONG bPathIdentIsBadType = -1;     // represents uninit'd state


    //
    // Verify that our input arguments all make sense.
    //
    if (!ARGUMENT_PRESENT(pIdentStruct) ||
        pIdentStruct->CodeProps == NULL ||
        !ARGUMENT_PRESENT(pFoundLevel) ||
        !ARGUMENT_PRESENT(pbExactMatch))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }
    if ((pIdentStruct->dwCheckFlags & SAFER_CRITERIA_IMAGEPATH) == 0 ||
        pIdentStruct->UnicodeFullyQualfiedLongFileName.Buffer == NULL ||
        RtlIsGenericTableEmpty(&g_CodeIdentitiesTable))
    {
        // We're not supposed to evaluate image paths.
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }
    ASSERT(g_TableCritSec.OwningThread == UlongToHandle(GetCurrentThreadId()));


    //
    // Enumerate through all path subkey GUIDs.
    //
    bFirstPass = TRUE;
    RestartKey = NULL;
    for (pAuthzIdentRecord = (PAUTHZIDENTSTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey);
         pAuthzIdentRecord != NULL;
         pAuthzIdentRecord = (PAUTHZIDENTSTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey)
         )
    {
        if (pAuthzIdentRecord->dwIdentityType ==
                    SaferIdentityTypeImageName)
        {//begin reg key lookup block
            LONG lMatchDepth;


            //
            // Explicitly expand environmental variables.
            //
            if (pAuthzIdentRecord->ImageNameInfo.bExpandVars) {

#ifdef EXPAND_REGPATH
            //This code attempts to expand "path" entries that are really reg keys.
            //For example, some paths are install dependent.  These paths are commonly written into
            //the registry.  You can specify a regkey that is a path.
            //For example see the following regkeys:
            //HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders
            //HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders
            //HKEY_CURRENT_USER\Software\Microsoft\Office\9.0\Outlook\Security\OutlookSecureTempFolder
            {
                LPWSTR lpzRegKey = pAuthzIdentRecord->ImageNameInfo.ImagePath.Buffer;
                HKEY hKey=NULL, hKeyHive=NULL;
                BOOL bIsCurrentUser = FALSE;

                //leading percent does two things:
                //1.  The rules created will be the Expandable String Type (REG_EXPAND_SZ)
                //2.  Reduces the chance of a real path name conflict.
                LPCWSTR LP_CU_HIVE = L"%HKEY_CURRENT_USER";
                LPCWSTR LP_LM_HIVE = L"%HKEY_LOCAL_MACHINE";

                BYTE buffer[MAX_PATH *2 + 80];
                LPWSTR lpValue=NULL;
                DWORD dwBufferSize = sizeof(buffer);
                LPWSTR lpHivename;
                LPWSTR lpLastPercentSign;
                LONG retval;
                BOOL bIsRegKey=TRUE;
                DWORD dwKeyLength;

                //We expect a string like the following:
                //%HKEY_CURRENT_USER\Software\Microsoft\Office\9.0\Outlook\Security\OutlookSecureTempFolder%
                //We need to break it into three parts for the registry query:
                //1.  The hive: HKEY_CURRENT_USER
                //2.  The key name: Software\Microsoft\Office\9.0\Outlook\Security
                //3.  The value name: OutlookSecureTempFolder
                lpKeyname=NULL;
                lpValue=NULL;
                lpHivename=NULL;
                lpLastPercentSign=NULL;
                memset(buffer, 0, dwBufferSize);
                lpHivename = wcsstr(lpzRegKey, LP_CU_HIVE);
                OUTPUTDEBUGSTRING(L"\n");
                OUTPUTDEBUGSTRING(L"$");
                OUTPUTDEBUGSTRING(lpzRegKey);
                OUTPUTDEBUGSTRING(L"\n");
                lpLastPercentSign = wcsrchr(lpzRegKey, '%');
                //if (lpLastPercentSign != &lpzRegKey[wcslen(lpzRegKey) - 1]) {  //needs to end in a '%' as well
                
                //
                // we allow %key+valuename%OLK* type paths now
                // but there still has to be a matching %
                //

                if (!lpLastPercentSign) {  
                    bIsRegKey = FALSE;
                }
                if (bIsRegKey) {
                    if (lpHivename != NULL) {
                        hKeyHive = HKEY_CURRENT_USER;
                        bIsCurrentUser = TRUE;
                        dwKeyLength = (wcslen(&lpzRegKey[wcslen(LP_CU_HIVE)+1]) +1) * sizeof (WCHAR);
                        lpKeyname = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY, dwKeyLength);
                        if ( lpKeyname == NULL ) {
                            Status = STATUS_NO_MEMORY;
                            goto ForLoopCleanup;
                        }
                        wcscpy(lpKeyname, &lpzRegKey[wcslen(LP_CU_HIVE)+1] );
                        OUTPUTDEBUGSTRING(L"HKEY_CURRENT_USER");
                        OUTPUTDEBUGSTRING(L"\n");
                    } else {
                        lpHivename = wcsstr(lpzRegKey, LP_LM_HIVE);
                        if (lpHivename != NULL) {
                            hKeyHive = HKEY_LOCAL_MACHINE;
                            dwKeyLength = (wcslen(&lpzRegKey[wcslen(LP_LM_HIVE)+1]) +1) * sizeof (WCHAR);
                            lpKeyname = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY, dwKeyLength);
                            if ( lpKeyname == NULL ) {
                                Status = STATUS_NO_MEMORY;
                                goto ForLoopCleanup;
                            }
                            wcscpy(lpKeyname, &lpzRegKey[wcslen(LP_LM_HIVE)+1] );
                            OUTPUTDEBUGSTRING(L"HKEY_LOCAL_MACHINE");
                            OUTPUTDEBUGSTRING(L"\n");
                        } else {
                            //The string is either a path or bogus data
                            bIsRegKey = FALSE;
                        }
                    }
                }

                if (bIsRegKey) {
                    lpValue = wcsrchr(lpKeyname, '\\');
                    if (lpValue==NULL) {
                        Status = STATUS_NOT_FOUND;
                        goto ForLoopCleanup;
                    }
                    //Take the regkey and value and stick a null terminator in between them.
                    *lpValue = '\0';
                    lpValue++;
                    //lpValue[wcslen(lpValue)-1] = '\0';
                    //lpLastPercentSign[0] = L'\0'; //replace the final '%' char with a null terminator
                    lpLastPercentSign = wcsrchr(lpValue, '%');
                    if (lpLastPercentSign == NULL) {
                        Status = STATUS_NOT_FOUND;
                        goto ForLoopCleanup;
                        }
                        *lpLastPercentSign = '\0';

                 //
                 // Bug# 416461 - causes handle leak so use a different API
                 // for the user hive
                 //

                 if ( bIsCurrentUser ) {
                       if (retval = RegOpenCurrentUser( KEY_READ, &hKeyHive ) ) {
                           if ( retval == ERROR_FILE_NOT_FOUND || 
                                retval == ERROR_NOT_FOUND ||
                                retval == ERROR_PATH_NOT_FOUND) {

                                if (lpKeyname) {
                                    HeapFree(GetProcessHeap(), 0,lpKeyname);
                                    lpKeyname = NULL;
                                }
                                continue;
                            }

                            Status = STATUS_NOT_FOUND;
                            goto ForLoopCleanup;
                        }
                  }

                  retval = RegOpenKeyEx(hKeyHive,
                                        lpKeyname,
                                        0,
                                        KEY_READ,
                                        &hKey);

                  if ( bIsCurrentUser ) {
                     RegCloseKey(hKeyHive);
                  }

                    if (retval)
                    {
                        if ( retval == ERROR_FILE_NOT_FOUND || 
                             retval == ERROR_NOT_FOUND ||
                             retval == ERROR_PATH_NOT_FOUND) {
                            
                            if (lpKeyname) {
                                HeapFree(GetProcessHeap(), 0,lpKeyname);
                                lpKeyname = NULL;
                            }
                            continue;
                        }
                        
                        Status = STATUS_NOT_FOUND;
                        goto ForLoopCleanup;
                    } else {
                        OUTPUTDEBUGSTRING(lpKeyname);
                        OUTPUTDEBUGSTRING(L"\n");
                        OUTPUTDEBUGSTRING(lpValue);
                        OUTPUTDEBUGSTRING(L"\n");

                        if (retval = RegQueryValueEx(hKey,
                                            lpValue,
                                            NULL,
                                            NULL,
                                            buffer,
                                            &dwBufferSize))
                        {
                            RegCloseKey(hKey);
                            Status = STATUS_NOT_FOUND;
                            goto ForLoopCleanup;
                        } else {
#ifdef VERBOSE_IDENTIFICATIONS
                            UNICODE_STRING UnicodeDebug;
                            WCHAR DebugBuffer[MAX_PATH*2 + 80];
#endif
                            UNICODE_STRING NewPath;
                            PUNICODE_STRING pPathFromRule;

                            //
                            // if it exists, concatenate the filename after 
                            // i.e. the OLK in %HKEY\somekey\somevalue%OLK
                            //

                            if (lpLastPercentSign[1] != L'\0') {

                                //
                                // there is some stuff after %HKEY\somekey\somevalue%
                                //
                            
                                if (sizeof(buffer) > 
                                    ((wcslen((WCHAR*)buffer) + wcslen(lpLastPercentSign+1))* sizeof(WCHAR))) {

                                    WCHAR   *pwcBuffer = (WCHAR *)buffer;
                                    if (pwcBuffer[0] != L'\0' && 
                                        pwcBuffer[wcslen(pwcBuffer)-1] != L'\\') {
                                        wcscat((WCHAR*)buffer, L"\\");
                                    }
                                    wcscat((WCHAR*)buffer, lpLastPercentSign+1);
                            
                                }
                            }
                            
                            pPathFromRule=&(pAuthzIdentRecord->ImageNameInfo.ImagePath);
                            NewPath.Length = (USHORT)wcslen((WCHAR*)buffer) * sizeof(WCHAR);
                            NewPath.MaximumLength = (USHORT)wcslen((WCHAR*)buffer) * sizeof(WCHAR);
                            NewPath.Buffer = (PWCHAR)buffer;
                            

#ifdef VERBOSE_IDENTIFICATIONS
                            RtlInitEmptyUnicodeString(&UnicodeDebug, DebugBuffer, sizeof(DebugBuffer));
                            swprintf(UnicodeDebug.Buffer, L"pPathFromRule(L,ML,Buffer)=(%d,%d,%s)\n",
                                        pPathFromRule->Length,
                                        pPathFromRule->MaximumLength,
                                        pPathFromRule->Buffer);
                            OUTPUTDEBUGSTRING(UnicodeDebug.Buffer);

                            memset(DebugBuffer, '0', sizeof(DebugBuffer));
                            swprintf(UnicodeDebug.Buffer, L"NewPath(L,ML,Buffer)=(%d,%d,%s)\n",
                                        NewPath.Length,
                                        NewPath.MaximumLength,
                                        NewPath.Buffer);
                            OUTPUTDEBUGSTRING(UnicodeDebug.Buffer);
#endif


                            //The new path may be bigger than the current UNICODE_STRING can store.  Reallocate if necessary.
                            if (pPathFromRule->MaximumLength >=
                                NewPath.Length + sizeof(UNICODE_NULL)) {
                                RtlCopyUnicodeString(
                                        pPathFromRule,
                                        &NewPath);
                            } else {
                                UNICODE_STRING UnicodeExpandedCopy;

                                Status = RtlDuplicateUnicodeString(
                                                RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE |
                                                RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING,
                                                &NewPath,
                                                &UnicodeExpandedCopy);

                                if (NT_SUCCESS(Status)) {
                                    RtlFreeUnicodeString(&pAuthzIdentRecord->ImageNameInfo.ImagePath);
                                    pAuthzIdentRecord->ImageNameInfo.ImagePath = UnicodeExpandedCopy;
                                }
                            }

#ifdef VERBOSE_IDENTIFICATIONS
                            memset(DebugBuffer, '0', sizeof(DebugBuffer));
                            swprintf(UnicodeDebug.Buffer, L"pPathFromRule after copy(L,ML,Buffer)=(%d,%d,%s)\n",
                                        pPathFromRule->Length,
                                        pPathFromRule->MaximumLength,
                                        pPathFromRule->Buffer);
                            OUTPUTDEBUGSTRING(UnicodeDebug.Buffer);
#endif
                        }

                    }
                    RegCloseKey(hKey);
                }
                if (lpKeyname) {
                    HeapFree(GetProcessHeap(), 0,lpKeyname);
                    lpKeyname = NULL;
                }

            } //end reg key lookup block

#endif

            // Attempt to expand now.
                RtlInitEmptyUnicodeString(
                        &UnicodePath,
                        &ExpandedPath[0],
                        sizeof(ExpandedPath) );

                Status = RtlExpandEnvironmentStrings_U(
                            NULL,               // environment
                            &pAuthzIdentRecord->ImageNameInfo.ImagePath,       // unexpanded path
                            &UnicodePath,       // resulting path
                            NULL);              // needed buffer size.
                if (!NT_SUCCESS(Status)) {
                    // Failed to expand environment strings.
                    continue;
                }


                // Perf optimization:  If the expansion was successful,
                // update the table to keep the expanded version, eliminating
                // the need to expand the string for any future comparisons.
                if (pAuthzIdentRecord->ImageNameInfo.ImagePath.MaximumLength >=
                    UnicodePath.Length + sizeof(UNICODE_NULL)) {
                    RtlCopyUnicodeString(
                            &pAuthzIdentRecord->ImageNameInfo.ImagePath,
                            &UnicodePath);
                    pAuthzIdentRecord->ImageNameInfo.bExpandVars = FALSE;
                } else {
                    UNICODE_STRING UnicodeExpandedCopy;

                    Status = RtlDuplicateUnicodeString(
                                    RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE |
                                    RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING,
                                    &UnicodePath,
                                    &UnicodeExpandedCopy);

                    if (NT_SUCCESS(Status)) {
                        RtlFreeUnicodeString(
                                &pAuthzIdentRecord->ImageNameInfo.ImagePath);
                        pAuthzIdentRecord->ImageNameInfo.ImagePath =
                                UnicodeExpandedCopy;
                        pAuthzIdentRecord->ImageNameInfo.bExpandVars = FALSE;
                    }
                }

            } else {
                UnicodePath.Buffer = pAuthzIdentRecord->ImageNameInfo.ImagePath.Buffer;
                UnicodePath.Length = pAuthzIdentRecord->ImageNameInfo.ImagePath.Length;
                UnicodePath.MaximumLength = pAuthzIdentRecord->ImageNameInfo.ImagePath.MaximumLength;
            }


            //
            // Attempt short -> long filename expansion (if there is a need)
            //

            szLongPath[0] = L'\0';

            //
            //  unicode buffer is guaranteed to be < MAX_PATH
            //

            wcsncpy(szLongPath,
                    pAuthzIdentRecord->ImageNameInfo.ImagePath.Buffer,
                    pAuthzIdentRecord->ImageNameInfo.ImagePath.Length/sizeof(WCHAR));

            szLongPath[pAuthzIdentRecord->ImageNameInfo.ImagePath.Length/sizeof(WCHAR)] = L'\0';

            if ( wcschr(szLongPath, L'~') ) {

                if (!GetLongPathNameW(szLongPath,
                                      szLongPath,
                                      sizeof(szLongPath) / sizeof(WCHAR))) {

                    Status = STATUS_VARIABLE_NOT_FOUND;
                    continue;
                }

                RtlInitUnicodeString(&UnicodePath, szLongPath);

                if (pAuthzIdentRecord->ImageNameInfo.ImagePath.MaximumLength >=
                    UnicodePath.Length + sizeof(UNICODE_NULL)) {
                    RtlCopyUnicodeString(
                                        &pAuthzIdentRecord->ImageNameInfo.ImagePath,
                                        &UnicodePath);
                } else {
                    UNICODE_STRING UnicodeExpandedCopy;

                    Status = RtlDuplicateUnicodeString(
                                                      RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE |
                                                      RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING,
                                                      &UnicodePath,
                                                      &UnicodeExpandedCopy);

                    if (NT_SUCCESS(Status)) {
                        RtlFreeUnicodeString(
                                            &pAuthzIdentRecord->ImageNameInfo.ImagePath);
                        pAuthzIdentRecord->ImageNameInfo.ImagePath =
                        UnicodeExpandedCopy;
                    }
                }
            }


            //
            // Compute the quality of which the wildcard path identity
            // matches the ImagePath property we were asked to evaluate.
            //
            ASSERT(UnicodePath.Buffer[UnicodePath.Length / sizeof(WCHAR)] == UNICODE_NULL);
            ASSERT(pIdentStruct->UnicodeFullyQualfiedLongFileName.Buffer[
                    pIdentStruct->UnicodeFullyQualfiedLongFileName.Length / sizeof(WCHAR)] == UNICODE_NULL);
            lMatchDepth = CodeAuthzpCompareImagePath(UnicodePath.Buffer,
                    pIdentStruct->UnicodeFullyQualfiedLongFileName.Buffer);
            if (!lMatchDepth) continue;


            //
            // If this path identity is configured to only apply to
            // file extensions on the "bad list" then check to see if
            // the ImagePath specifies one of the bad extensions.
            //
            #ifdef AUTHZPOL_SAFERFLAGS_ONLY_EXES
            if (lMatchDepth > 0 &&
                (pAuthzIdentRecord->ImageNameInfo.dwSaferFlags &
                    AUTHZPOL_SAFERFLAGS_ONLY_EXES) != 0)
            {
                if (bPathIdentIsBadType == -1) {
                    BOOLEAN bResult;

                    Status = CodeAuthzIsExecutableFileType(
                            &pIdentStruct->UnicodeFullyQualfiedLongFileName, FALSE,
                            &bResult );
                    if (!NT_SUCCESS(Status) || !bResult) {
                        bPathIdentIsBadType = FALSE;
                    } else {
                        bPathIdentIsBadType = TRUE;
                    }
                }
                if (!bPathIdentIsBadType) {
                    // This identity matches against only the "bad"
                    // extensions, so pretend that this didn't match.
                    continue;
                }
            }
            #endif


            //
            // Emit some diagnostic debugging code to show the result
            // of all of the path evaluations and their match depths.
            //
            #ifdef VERBOSE_IDENTIFICATIONS
            {
                UNICODE_STRING UnicodeDebug;
                WCHAR DebugBuffer[MAX_PATH*2 + 80];

                // sprintf is for wimps.
                RtlInitEmptyUnicodeString(&UnicodeDebug, DebugBuffer, sizeof(DebugBuffer));
                RtlAppendUnicodeToString(&UnicodeDebug, L"Safer pattern ");
                RtlAppendUnicodeStringToString(&UnicodeDebug, &UnicodePath);
                RtlAppendUnicodeToString(&UnicodeDebug, L" matched ");
                RtlAppendUnicodeStringToString(&UnicodeDebug, &(pIdentStruct->UnicodeFullyQualfiedLongFileName));
                RtlAppendUnicodeToString(&UnicodeDebug, L" with value ");
                UnicodeDebug.Buffer += UnicodeDebug.Length / sizeof(WCHAR);
                UnicodeDebug.MaximumLength -= UnicodeDebug.Length;
                RtlIntegerToUnicodeString(lMatchDepth, 10, &UnicodeDebug);
                RtlAppendUnicodeToString(&UnicodeDebug, L"\n");
                OUTPUTDEBUGSTRING(DebugBuffer);
            }
            #endif


            //
            // Evaluate if this path identity matches better than whatever
            // best path identity that we previously had, and keep it if so.
            //
            if (lMatchDepth < 0)    // an exact fully-qualified path!
            {
                if (bFirstPass ||
                    lBestLevelDepth >= 0 ||
                    pAuthzIdentRecord->dwLevelId < dwBestLevelId)
                {
                    pBestIdentRecord = pAuthzIdentRecord;
                    dwBestLevelId = pAuthzIdentRecord->dwLevelId;
                    lBestLevelDepth = lMatchDepth;
                    bFirstPass = FALSE;
                }
            }
            else   // an inexact leading prefix path match.
            {
                ASSERT(lMatchDepth > 0);

                if (bFirstPass ||
                    (lBestLevelDepth >= 0 &&
                        (lMatchDepth > lBestLevelDepth ||
                            (lMatchDepth == lBestLevelDepth &&
                            pAuthzIdentRecord->dwLevelId < dwBestLevelId)
                         )
                     )
                    )
                {
                    pBestIdentRecord = pAuthzIdentRecord;
                    dwBestLevelId = pAuthzIdentRecord->dwLevelId;
                    lBestLevelDepth = lMatchDepth;
                    bFirstPass = FALSE;
                }
            }

ForLoopCleanup:
            if (lpKeyname)
            {
                HeapFree(GetProcessHeap(), 0,lpKeyname);
                lpKeyname = NULL;
            }
        }

    }


    //
    // If we have identified a matching WinSafer Level then
    // look up the Level record for it and return success.
    //
    if (bFirstPass) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }
    pAuthzLevelRecord = CodeAuthzLevelObjpLookupByLevelId(
                &g_CodeLevelObjTable, dwBestLevelId);
    if (!pAuthzLevelRecord) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }
    *pFoundLevel = pAuthzLevelRecord;
    *pbExactMatch = (lBestLevelDepth < 0 ? TRUE : FALSE);
    *pFoundIdentity = pBestIdentRecord;

    Status = STATUS_SUCCESS;


ExitHandler:
                
    if (lpKeyname)
        HeapFree(GetProcessHeap(), 0,lpKeyname);
    return Status;
}



NTSTATUS NTAPI
__CodeAuthzpCheckIdentityCertificateRules(
        IN OUT PLOCALIDENTITYCONTEXT    pIdentStruct,
        OUT DWORD                    *dwExtendedError,
        OUT PAUTHZLEVELTABLERECORD     *pFoundLevel,
        IN  DWORD                       dwUIChoice
        )
/*++

Routine Description:

    Calls WinVerifyTrust to determine the trust level of the code
    signer that has signed a piece of code.

Arguments:

    pIdentStruct - context state structure.

    dwExtendedError - To return extended error returned by WinVerifyTrust.
    
    pFoundLevel - receives a pointer to the authorization Level record
        indicated by the best matching rule.

    dwUIChoice - optionally specifies the amount of UI that WinVerifyTrust
        is allowed to display.  If this argument is 0, then it is treated
        as if WTD_UI_ALL had been supplied.

Return Value:

    Returns STATUS_SUCCESS if a WinSafer Level has been found,
    or STATUS_RETRY if the publisher was unknown and UIflags blocked prompting,
    or STATUS_NOT_FOUND if not.  Otherwise an error code.

--*/
{
    NTSTATUS Status;
    PAUTHZLEVELTABLERECORD pLevelRecord;
    GUID wvtFileActionID = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    WINTRUST_FILE_INFO wvtFileInfo;
    WINTRUST_DATA wvtData;
    LONG lStatus;
    DWORD dwLastError;
    DWORD LocalHandleSequenceNumber;

    //
    // Verify that our input arguments all make sense.
    //
    if (!ARGUMENT_PRESENT(pIdentStruct) ||
        pIdentStruct->CodeProps == NULL ) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }
    if ((pIdentStruct->dwCheckFlags & SAFER_CRITERIA_AUTHENTICODE) == 0 ||
        !ARGUMENT_PRESENT(pIdentStruct->UnicodeFullyQualfiedLongFileName.Buffer)) {
        // We're not supposed to evaluate certificates, or the
        // filename was not supplied (WinVerifyTrust requires a
        // filename, even if an opened handle to is also supplied).
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }
    if ( !ARGUMENT_PRESENT(pFoundLevel) ) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }
    ASSERT(g_TableCritSec.OwningThread == UlongToHandle(GetCurrentThreadId()));



    //
    // Prepare the input data structure that WinVerifyTrust expects.
    //
    RtlZeroMemory(&wvtData, sizeof(WINTRUST_DATA));
    wvtData.cbStruct = sizeof(WINTRUST_DATA);
    if ((wvtData.dwUIChoice = dwUIChoice) == 0) {
        // If the UI choice element was left zero, then assume all UI.
        wvtData.dwUIChoice = WTD_UI_ALL;
    }
    wvtData.dwProvFlags = WTD_SAFER_FLAG;        // our magic flag.
    wvtData.dwUnionChoice = WTD_CHOICE_FILE;
    wvtData.pFile = &wvtFileInfo;


    //
    // Prepare the input file data structure used by WinVerifyTrust.
    //
    RtlZeroMemory(&wvtFileInfo, sizeof(WINTRUST_FILE_INFO));
    wvtFileInfo.cbStruct = sizeof(WINTRUST_FILE_INFO);
    wvtFileInfo.hFile = pIdentStruct->hFileHandle;
    wvtFileInfo.pcwszFilePath = pIdentStruct->UnicodeFullyQualfiedLongFileName.Buffer;


    //
    // Save the global state number.
    //

    LocalHandleSequenceNumber = g_dwLevelHandleSequence;

    //
    // Leave the critical section to prevent deadlock with the LoaderLock.
    //

    RtlLeaveCriticalSection(&g_TableCritSec);

    //
    // Actually call WinVerifyTrust and save off the return code
    // and last error code.
    //
    lStatus = WinVerifyTrust(
                pIdentStruct->CodeProps->hWndParent,  // hwnd
                &wvtFileActionID,
                &wvtData
                );

    dwLastError = GetLastError();

    *dwExtendedError = dwLastError;

    //
    // Reacquire the lock and check global state.
    //

    RtlEnterCriticalSection(&g_TableCritSec);


    //
    // Check the global state and make sure that the tables were not reloaded 
    // when we were not looking.
    //

    if (LocalHandleSequenceNumber != g_dwLevelHandleSequence) {

        ASSERT(FALSE);

        Status = STATUS_INTERNAL_ERROR;
        goto ExitHandler;
    }

    //
    // Process the WinVerifyTrust errors per PhilH
    //
    
    pLevelRecord = NULL;


    if (S_OK == lStatus && TRUST_E_SUBJECT_NOT_TRUSTED != dwLastError) {
	
        //
        // The file is signed. The publisher or hash is explicitly trusted
        //

        pLevelRecord = CodeAuthzLevelObjpLookupByLevelId(
            &g_CodeLevelObjTable, SAFER_LEVELID_FULLYTRUSTED);

    } else if (TRUST_E_EXPLICIT_DISTRUST == lStatus || TRUST_E_SUBJECT_NOT_TRUSTED == lStatus) {
	
        //
        // The publisher is revoked or explicitly untrusted. Alternatively, the hash is
        // explicitly untrusted.
        //
        
        pLevelRecord = CodeAuthzLevelObjpLookupByLevelId(
            &g_CodeLevelObjTable, SAFER_LEVELID_DISALLOWED);

    } else {

        //
        // we won't be too conservative in any of the following cases. 
        // No explicit trust or untrust. Continue on to other SAFER checks.
        //

        // TRUST_E_NOSIGNATURE == lStatus	
        // The file isn't signed. Alternatively for TRUST_E_BAD_DIGEST == dwLastError,
        // a signed file has been modified.


        // CRYPT_E_SECURITY_SETTINGS == lStatus	
        // For authenticode downloads, the admin has disabled user UI and trust.	

	
        // any other combination of lStatus and dwLastError
        // The file is signed. WVT has already called safer to check the hash rules.

	
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;

    }
    
    if (!pLevelRecord) {
        Status = STATUS_ACCESS_DENIED;
    } else {
        *pFoundLevel = pLevelRecord;
        Status = STATUS_SUCCESS;
    }

ExitHandler:
    return Status;
}



BOOL WINAPI
SaferiSearchMatchingHashRules(
        IN ALG_ID       HashAlgorithm OPTIONAL,
        IN PBYTE        pHashBytes,
        IN DWORD        dwHashSize,
        IN DWORD        dwOriginalImageSize OPTIONAL,
        OUT PDWORD      pdwFoundLevel,
        OUT PDWORD      pdwSaferFlags
        )
/*++

Routine Description:

    This is a private function that is exported for WinVerifyTrust
    to call to determine if a given hash has a WinSafer policy
    associated with it.

    Because this is a private function that is directly called by
    outside code, there is extra work needed to enter the critical
    section, reload the policy if needed, and set the value returned
    by GetLastError.

Arguments:

    HashAlgorithm - specifies the algorithm in which the hash
        was computed (CALG_MD5, CALG_SHA, etc).

    pHashBytes - pointer to a buffer containing the pre-computed
        hash value of the file's contents.

    dwHashSize - length indicating the size of the hash value that
        is referenced by the pHashBytes argument.  For example,
        a 128-bit MD5 hash should have a dwHashSize length of 16.

    dwOriginalImageSize - Specifies the size of the original file's
        contents that are being hashed.  This value is used as a
        heuristic to minimize the number of comparisons that must
        be done to identify a match.  If this parameter is 0, then
        this heuristic will not be used.

    pdwFoundLevel - pointer that receives a DWORD indicating the
        WinSafer LevelId that is found.  This value is only written
        when TRUE is returned.

    pdwSaferFlags - pointer that receives a DWORD value containing flags
        that control the supression of User-Interface dialogs.
        This value is only written when TRUE is returned.

Return Value:

    Returns TRUE if a WinSafer Level has been found, or FALSE if not.
    If FALSE is returned, GetLastError() may be used to find out
    specifics about why no match was found (possibly argument errors).

--*/
{
    NTSTATUS Status;
    PVOID RestartKey;
    PAUTHZIDENTSTABLERECORD pAuthzIdentRecord;

    DWORD dwBestLevelId;
    DWORD dwBestSaferFlags;
    BOOLEAN bFirstPass;


    //
    // Verify that our input arguments all make sense.
    //
    if (!ARGUMENT_PRESENT(pHashBytes) ||
        dwHashSize < 1) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }
    if (!ARGUMENT_PRESENT(pdwFoundLevel) ||
        !ARGUMENT_PRESENT(pdwSaferFlags)) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }


    //
    // Enter the critical section and reload the tables if needed.
    // Notice that a potential reload is needed here because this
    // function is externally called directly.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_bNeedCacheReload) {
        Status = CodeAuthzpImmediateReloadCacheTables();
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
    }


    //
    // Enumerate through all hash subkey GUIDs.
    //
    bFirstPass = TRUE;
    RestartKey = NULL;
    for (pAuthzIdentRecord = (PAUTHZIDENTSTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey);
         pAuthzIdentRecord != NULL;
         pAuthzIdentRecord = (PAUTHZIDENTSTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey)
         )
    {
        if (pAuthzIdentRecord->dwIdentityType == SaferIdentityTypeImageHash)
        {
            //
            // Ensure that the hash algorithm is the same type between
            // what we were supplied and what we are matching against.
            //
            if (HashAlgorithm != 0 &&
                pAuthzIdentRecord->ImageHashInfo.HashAlgorithm !=
                        HashAlgorithm) {
                continue;
            }


            //
            // If the actual filesize does not match the filesize stored
            // with the hash identity then there is no need to perform
            // any comparisons involving the hash.
            //
            if ( dwOriginalImageSize != 0 && dwOriginalImageSize !=
                pAuthzIdentRecord->ImageHashInfo.ImageSize.QuadPart ) {
                continue;
            }

            //
            // If the hash doesn't match at all, then go onto the next one.
            //
            if ( dwHashSize != pAuthzIdentRecord->ImageHashInfo.HashSize ||
                !RtlEqualMemory(
                    &pAuthzIdentRecord->ImageHashInfo.ImageHash[0],
                    &pHashBytes[0], dwHashSize))
            {
                continue;
            }


            //
            // Evaluate if this identity matches better than whatever
            // best path identity that we previously had, and keep it if so.
            //
            if ( bFirstPass ||
                        // we didn't have anything before.
                pAuthzIdentRecord->dwLevelId < dwBestLevelId
                        // or specifies a less-privileged level.
                )
            {
                dwBestLevelId = pAuthzIdentRecord->dwLevelId;
                dwBestSaferFlags = pAuthzIdentRecord->ImageHashInfo.dwSaferFlags;
                bFirstPass = FALSE;
            }
        }
    }


    //
    // If we have identified a matching WinSafer Level then
    // pass it back and return success.
    //
    if (bFirstPass) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler2;
    }
    *pdwFoundLevel = dwBestLevelId;
    *pdwSaferFlags = dwBestSaferFlags;

    Status = STATUS_SUCCESS;

ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);

ExitHandler:
    if (NT_SUCCESS(Status)) {
        return TRUE;
    } else {
        BaseSetLastNTError(Status);
        return FALSE;
    }
}



NTSTATUS NTAPI
__CodeAuthzpCheckIdentityHashRules(
        IN OUT PLOCALIDENTITYCONTEXT    pIdentStruct,
        OUT PAUTHZLEVELTABLERECORD     *pFoundLevel,
        OUT PAUTHZIDENTSTABLERECORD    *pFoundIdentity
        )
/*++

Routine Description:

    Assumes that the global table lock has already been acquired.

Arguments:

    pIdentStruct -

    pFoundLevel - receives a pointer to the authorization Level record
        indicated by the best matching rule.

    pFoundIdentity - receives a pointer to the identifier entry rule
        that best matched.

Return Value:

    Returns STATUS_SUCCESS if a WinSafer Level has been found,
    or STATUS_NOT_FOUND if not.  Otherwise an error code.

--*/
{
    NTSTATUS Status;
    PVOID RestartKey;
    PAUTHZIDENTSTABLERECORD pAuthzIdentRecord, pBestIdentRecord;
    PAUTHZLEVELTABLERECORD pAuthzLevelRecord;
    DWORD dwBestLevelId;
    BOOLEAN bFirstPass;


    //
    // Verify that our input arguments all make sense.
    //
    if (!ARGUMENT_PRESENT(pIdentStruct) ||
        pIdentStruct->CodeProps == NULL ) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }
    if ((pIdentStruct->dwCheckFlags & SAFER_CRITERIA_IMAGEHASH) == 0 ||
        RtlIsGenericTableEmpty(&g_CodeIdentitiesTable)) {
        // We're not supposed to evaluate hashes.
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }
    if ( !ARGUMENT_PRESENT(pFoundLevel) ||
         !ARGUMENT_PRESENT(pFoundIdentity) ) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }
    ASSERT(g_TableCritSec.OwningThread == UlongToHandle(GetCurrentThreadId()));



    //
    // Enumerate through all hash subkey GUIDs.
    //
    bFirstPass = TRUE;
    RestartKey = NULL;
    for (pAuthzIdentRecord = (PAUTHZIDENTSTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey);
         pAuthzIdentRecord != NULL;
         pAuthzIdentRecord = (PAUTHZIDENTSTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey)
         )
    {
        if (pAuthzIdentRecord->dwIdentityType == SaferIdentityTypeImageHash)
        {
            //
            // If the user already supplied the pre-computed hash to us,
            // but not the file size, then assume that we do not need
            // to consider the file size when making a comparison.
            //
            if (pIdentStruct->bHaveHash &&
                pIdentStruct->ImageSize.QuadPart == 0) {
                goto SkipToActualHashCheck;
            }


            //
            // If the actual filesize does not match the filesize stored
            // with the hash identity then there is no need to perform
            // any comparisons involving the hash.
            //
            if ( pIdentStruct->ImageSize.QuadPart == 0 )
            {
                // If we don't have the ImageSize yet, then try to
                // open the file and memory map it to find the size.
                Status = __CodeAuthzpEnsureMapped(pIdentStruct);
                if (!NT_SUCCESS(Status)) {
                    // If we failed to compute the MD5 sum of this, then that is
                    // actually rather bad, but we'll proceed to evaluate any
                    // non-MD5 identity rules, since ignoring them could be worse.
                    pIdentStruct->dwCheckFlags &= ~SAFER_CRITERIA_IMAGEHASH;
                    goto ExitHandler;
                }
                ASSERTMSG("EnsureMapped failed but did not return error",
                          pIdentStruct->pImageMemory != NULL &&
                            pIdentStruct->ImageSize.QuadPart != 0);
            }

            if ( pAuthzIdentRecord->ImageHashInfo.ImageSize.QuadPart !=
                    pIdentStruct->ImageSize.QuadPart) {
                continue;
            }


    SkipToActualHashCheck:
            //
            // Dynamically compute the MD5 hash of the item if needed.
            //
            if (!pIdentStruct->bHaveHash)
            {
                // Otherwise hash was not supplied, so we must compute it now.
                // Open the file and memory map it.
                Status = __CodeAuthzpEnsureMapped(pIdentStruct);
                if (!NT_SUCCESS(Status)) {
                    // If we failed to compute the MD5 sum of this, then
                    // that is actually rather bad, but we'll proceed to
                    // evaluate any non-MD5 identity rules, since ignoring
                    // them could be worse.
                    pIdentStruct->dwCheckFlags &= ~SAFER_CRITERIA_IMAGEHASH;
                    goto ExitHandler;
                }
                ASSERTMSG("EnsureMapped failed but did not return error",
                          pIdentStruct->pImageMemory != NULL &&
                        pIdentStruct->ImageSize.QuadPart != 0);



                // We now have a MD5 hash to use.
                pIdentStruct->FinalHashSize =
                    sizeof(pIdentStruct->FinalHash);
                Status = CodeAuthzpComputeImageHash(
                            pIdentStruct->pImageMemory,
                            pIdentStruct->ImageSize.LowPart,
                            &pIdentStruct->FinalHash[0],
                            &pIdentStruct->FinalHashSize,
                            &pIdentStruct->FinalHashAlgorithm);
                if (!NT_SUCCESS(Status)) {
                    goto ExitHandler;
                }
                pIdentStruct->bHaveHash = TRUE;
            }


            //
            // Ensure that the hash algorithm is the same type between
            // what we were supplied and what we are matching against.
            //
            if ( pIdentStruct->FinalHashAlgorithm != 0 &&
                pAuthzIdentRecord->ImageHashInfo.HashAlgorithm !=
                        pIdentStruct->FinalHashAlgorithm) {
                continue;
            }


            //
            // If the hash doesn't match at all, then go onto the next one.
            //
            if ( pIdentStruct->FinalHashSize !=
                        pAuthzIdentRecord->ImageHashInfo.HashSize ||
                !RtlEqualMemory(
                    &pIdentStruct->FinalHash[0],
                    &pAuthzIdentRecord->ImageHashInfo.ImageHash[0],
                    pIdentStruct->FinalHashSize))
            {
                continue;
            }


            //
            // Evaluate if this identity matches better than whatever
            // best path identity that we previously had, and keep it if so.
            //
            if ( bFirstPass ||
                        // we didn't have anything before.
                pAuthzIdentRecord->dwLevelId < dwBestLevelId
                        // same scope, but specifies a less-privileged level.
                )
            {
                pBestIdentRecord = pAuthzIdentRecord;
                dwBestLevelId = pAuthzIdentRecord->dwLevelId;
                bFirstPass = FALSE;
            }
        }
    }


    //
    // If we have identified a matching WinSafer Level then
    // look up the Level record for it and return success.
    //
    if (bFirstPass) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }
    pAuthzLevelRecord = CodeAuthzLevelObjpLookupByLevelId(
                &g_CodeLevelObjTable, dwBestLevelId);
    if (!pAuthzLevelRecord) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }
    *pFoundLevel = pAuthzLevelRecord;
    *pFoundIdentity = pBestIdentRecord;

    Status = STATUS_SUCCESS;

ExitHandler:
    return Status;
}


NTSTATUS NTAPI
__CodeAuthzpCheckIdentityUrlZoneRules(
        IN OUT PLOCALIDENTITYCONTEXT    pIdentStruct,
        OUT PAUTHZLEVELTABLERECORD     *pFoundLevel,
        OUT PAUTHZIDENTSTABLERECORD    *pFoundIdentity
        )
/*++

Routine Description:

Arguments:

    pIdentStruct -

    pFoundLevel - receives a pointer to the authorization Level record
        indicated by the best matching rule.

    pFoundIdentity - receives a pointer to the identifier entry rule
        that best matched.

Return Value:

    Returns STATUS_SUCCESS if a WinSafer Level has been found,
    or STATUS_NOT_FOUND if not.  Otherwise an error code.

--*/
{
    NTSTATUS Status;
    PVOID RestartKey;
    PAUTHZIDENTSTABLERECORD pAuthzIdentRecord, pBestIdentRecord;
    PAUTHZLEVELTABLERECORD pAuthzLevelRecord;
    DWORD dwBestLevelId;
    BOOLEAN bFirstPass;


    //
    // Verify that our input arguments all make sense.
    //
    if (!ARGUMENT_PRESENT(pIdentStruct) ||
        pIdentStruct->CodeProps == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }
    if ((pIdentStruct->dwCheckFlags & SAFER_CRITERIA_URLZONE) == 0 ||
        RtlIsGenericTableEmpty(&g_CodeIdentitiesTable)) {
        // We're not supposed to evaluate zones.
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }
    if (!ARGUMENT_PRESENT(pFoundLevel) ||
        !ARGUMENT_PRESENT(pFoundIdentity) ) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }
    ASSERT(g_TableCritSec.OwningThread == UlongToHandle(GetCurrentThreadId()));


    //
    // Enumerate through all UrlZone subkey GUIDs.
    //
    RestartKey = NULL;
    bFirstPass = TRUE;
    for (pAuthzIdentRecord = (PAUTHZIDENTSTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey);
         pAuthzIdentRecord != NULL;
         pAuthzIdentRecord = (PAUTHZIDENTSTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey)
         )
    {
        if (pAuthzIdentRecord->dwIdentityType ==
                SaferIdentityTypeUrlZone)
        {
            //
            // Compare the identity with what was supplied to us.
            //
            if (pAuthzIdentRecord->ImageZone.UrlZoneId !=
                    pIdentStruct->CodeProps->UrlZoneId) {
                // this zone does not match, so ignore it.
                continue;
            }


            //
            // Evaluate if this path identity matches better than whatever
            // best path identity that we previously had, and keep it if so.
            //
            if (bFirstPass ||
                        // we didn't have anything better before.
                pAuthzIdentRecord->dwLevelId < dwBestLevelId)
                        // this also matches, but specifies a less-privileged level.
            {
                pBestIdentRecord = pAuthzIdentRecord;
                dwBestLevelId = pAuthzIdentRecord->dwLevelId;
                bFirstPass = FALSE;
            }
        }
    }


    //
    // If we have identified a matching WinSafer Level then
    // look up the Level record for it and return success.
    //
    if (bFirstPass) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }
    pAuthzLevelRecord = CodeAuthzLevelObjpLookupByLevelId(
                &g_CodeLevelObjTable, dwBestLevelId);
    if (!pAuthzLevelRecord) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }
    *pFoundLevel = pAuthzLevelRecord;
    *pFoundIdentity = pBestIdentRecord;

    Status = STATUS_SUCCESS;

ExitHandler:
    return Status;
}



NTSTATUS NTAPI
__CodeAuthzpIdentifyOneCodeAuthzLevel(
        IN PSAFER_CODE_PROPERTIES       pCodeProperties OPTIONAL,
        OUT DWORD                      *dwExtendedError,
        OUT PAUTHZLEVELTABLERECORD     *pBestLevelRecord,
        OUT GUID                       *pBestIdentGuid
        )
/*++

Routine Description:

    Performs the code identification process.
    Assumes that the caller has already locked the global critsec.

Arguments:

    pCodeProperties - pointer the single CODE_PROPERTIESW structure
            that should be analyzed and evaluated.  This parameter
            may be specified as NULL to indicate that there are
            no specific properties that should be evaluated and that
            only the configured Default Level should be used.

    dwExtendedError - In case of certificate rule match, return the extended
            error from WinVerifyTrust.
            
    pBestLevelRecord - returns the matching WinSafer Level record.
            The value written to this parameter should only be
            considered valid when STATUS_SUCCESS is also returned.

    pBestIdentGuid - returns the matching Code Identity guid from
            which the resulting WinSafer Level was determined.
            The value written to this parameter should only be
            considered valid when STATUS_SUCCESS is also returned.

            This GUID may also be SAFER_GUID_RESULT_TRUSTED_CERT or
            SAFER_GUID_RESULT_DEFAULT_LEVEL to indicate that the result
            was from a publisher cert or a default rule match.
            Note that a cert hash match will also

Return Value:

    Returns STATUS_SUCCESS if a WinSafer Level has been found,
    or STATUS_NOT_FOUND or another error code if not.

--*/
{
    NTSTATUS Status;
    LOCALIDENTITYCONTEXT identStruct = {0};

    //
    // Verify our input state and perform any explicit
    // policy loading, if it hasn't been loaded yet.
    //
    if (!ARGUMENT_PRESENT(pBestLevelRecord) ||
        !ARGUMENT_PRESENT(pBestIdentGuid)) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }
    ASSERT(g_TableCritSec.OwningThread == UlongToHandle(GetCurrentThreadId()));


    //
    // Star the identification process.  If no code properties were
    // supplied to us, then we can immediately skip to only
    // considering the default WinSafer Level configurations.
    //
    if (ARGUMENT_PRESENT(pCodeProperties))
    {
        BOOLEAN bRetryCertRuleCheck = FALSE;
        BOOLEAN bPathIsNtNamespace;

        // Current best identity match.
        PAUTHZLEVELTABLERECORD pAuthzLevelRecord = NULL;
        PAUTHZIDENTSTABLERECORD pAuthzIdentRecord;

        // Temporary evaluation identity match.
        BOOL bExactPath;
        PAUTHZLEVELTABLERECORD pTempLevelRecord;
        PAUTHZIDENTSTABLERECORD pTempIdentRecord;


        //
        // Check that the CODE_PROPERTIES structure is the right size.
        //
        if (pCodeProperties->cbSize != sizeof(SAFER_CODE_PROPERTIES)) {
            Status = STATUS_INFO_LENGTH_MISMATCH;
            goto ExitHandler;
        }


        //
        // Initialize the structure that we use to store our
        // stateful information during policy evaluation.
        // We don't copy everything from the CODE_PROPERTIES
        // structure into the identStruct, since some of it
        // is dynamically loaded/copied within "EnsureMapped".
        //
        RtlZeroMemory(&identStruct, sizeof(LOCALIDENTITYCONTEXT));
        identStruct.CodeProps = pCodeProperties;
        identStruct.dwCheckFlags = pCodeProperties->dwCheckFlags;
        identStruct.ImageSize.QuadPart =
            pCodeProperties->ImageSize.QuadPart;
        if (identStruct.ImageSize.QuadPart != 0 &&
            pCodeProperties->dwImageHashSize > 0 &&
            pCodeProperties->dwImageHashSize <= SAFER_MAX_HASH_SIZE)
        {
            // The image hash and filesize were both supplied, therefore
            // we have a valid hash and don't need to compute it ourself.
            RtlCopyMemory(&identStruct.FinalHash[0],
                          &pCodeProperties->ImageHash[0],
                          pCodeProperties->dwImageHashSize);
            identStruct.FinalHashSize = pCodeProperties->dwImageHashSize;
            identStruct.bHaveHash = TRUE;
        }
        bPathIsNtNamespace = ((identStruct.dwCheckFlags &
                SAFER_CRITERIA_IMAGEPATH_NT) != 0 ? TRUE : FALSE);


        //
        // Copy over the file handle into the context structure, if a
        // handle was supplied, otherwise try to open the filepath.
        //
        if (pCodeProperties->hImageFileHandle != NULL &&
            pCodeProperties->hImageFileHandle != INVALID_HANDLE_VALUE)
        {
            identStruct.hFileHandle = pCodeProperties->hImageFileHandle;
            identStruct.bCloseFileHandle = FALSE;
        }
        else if (pCodeProperties->ImagePath != NULL)
        {
            HANDLE hFile;

            if (bPathIsNtNamespace) {
                UNICODE_STRING UnicodeFilename;
                IO_STATUS_BLOCK IoStatusBlock;
                OBJECT_ATTRIBUTES ObjectAttributes;

                RtlInitUnicodeString(&UnicodeFilename, pCodeProperties->ImagePath);
                InitializeObjectAttributes(
                        &ObjectAttributes, &UnicodeFilename,
                        OBJ_CASE_INSENSITIVE, NULL, NULL);
                Status = NtOpenFile(&hFile, FILE_GENERIC_READ, &ObjectAttributes,
                                    &IoStatusBlock, FILE_SHARE_READ, FILE_NON_DIRECTORY_FILE);

                if (!NT_SUCCESS(Status)) {
                    hFile = NULL;
                }
            } else {
                hFile = CreateFileW(
                                pCodeProperties->ImagePath,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
            }

            if (hFile != NULL && hFile != INVALID_HANDLE_VALUE) {
                identStruct.hFileHandle = hFile;
                identStruct.bCloseFileHandle = TRUE;
            }
        }


        //
        // Reconstruct the fully qualified pathname from the handle
        // or from the supplied filename.
        //
        Status = CodeAuthzFullyQualifyFilename(
                        identStruct.hFileHandle,
                        bPathIsNtNamespace,
                        pCodeProperties->ImagePath,
                        &identStruct.UnicodeFullyQualfiedLongFileName);
        if (!NT_SUCCESS(Status) &&
            pCodeProperties->ImagePath != NULL &&
            !bPathIsNtNamespace)
        {
            // Otherwise just live with what was passed in to us.
            // If allocation fails, then path criteria will just be ignored.
            Status = RtlCreateUnicodeString(
                    &identStruct.UnicodeFullyQualfiedLongFileName,
                    pCodeProperties->ImagePath);
        }


        //
        // Perform the WinVerifyTrust sequence to see if the signing
        // certificate matches any of the publishers that are in the
        // trusted or distrusted publisher stores.  This also has the
        // additional effect of checking the "signed hashes".
        //
        Status = __CodeAuthzpCheckIdentityCertificateRules(
                                        &identStruct,
                                        dwExtendedError,
                                        &pAuthzLevelRecord,
                                        WTD_UI_NONE);
        if (NT_SUCCESS(Status)) {
            // An exact publisher was found, so return immediately.
            ASSERT(pAuthzLevelRecord != NULL);
            *pBestLevelRecord = pAuthzLevelRecord;
            RtlCopyMemory(pBestIdentGuid,
                          &guidTrustedCert, sizeof(GUID));
            goto ExitHandler2;
        } else if (STATUS_RETRY == Status) {
            if (WTD_UI_NONE != identStruct.CodeProps->dwWVTUIChoice) {
                // if originally supposed to suppress UI, no need to retry.
                bRetryCertRuleCheck = TRUE;
            }
        }



        //
        // Search hash rules defined for this level/scope.
        // Note that hashes match exactly or not at all,
        // so if we get a positive match, then that level
        // is absolutely returned.
        //
        Status = __CodeAuthzpCheckIdentityHashRules(
                        &identStruct,
                        &pAuthzLevelRecord,
                        &pAuthzIdentRecord);
        if (NT_SUCCESS(Status)) {
            // An exact hash identity was found, so return immediately.
            ASSERT(pAuthzLevelRecord != NULL);
            *pBestLevelRecord = pAuthzLevelRecord;
            RtlCopyMemory(pBestIdentGuid,
                          &pAuthzIdentRecord->IdentGuid, sizeof(GUID));
            goto ExitHandler2;
        }
        ASSERT(pAuthzLevelRecord == NULL);


        //
        // Search file path rules defined for this level/scope.
        // Note that file paths can either be an exact match
        // or a partial match.  If we find an exact match, then
        // it should be absolutely returned.  Otherwise the
        // path was a "grouping match" and we must compare the
        // Level with all of the remaining "grouping checks".
        //
        Status = __CodeAuthzpCheckIdentityPathRules(
                        &identStruct,
                        &pAuthzLevelRecord,
                        &bExactPath,
                        &pAuthzIdentRecord);
        if (NT_SUCCESS(Status)) {
            ASSERT(pAuthzLevelRecord != NULL);
            pTempLevelRecord = pAuthzLevelRecord;
            pTempIdentRecord = pAuthzIdentRecord;
            if (bExactPath) {
                *pBestLevelRecord = pTempLevelRecord;
                RtlCopyMemory(pBestIdentGuid,
                        &pTempIdentRecord->IdentGuid, sizeof(GUID));
                goto ExitHandler2;
            }
        }


        //
        // Search URL Zone identity rules.
        // Note that zones are always "grouping matches",
        // so they must be compared against all of the remaining
        // "grouping checks".
        //
        Status = __CodeAuthzpCheckIdentityUrlZoneRules(
                        &identStruct,
                        &pTempLevelRecord,
                        &pTempIdentRecord);
        if (NT_SUCCESS(Status)) {
            ASSERT(pTempLevelRecord != NULL);
            if (pAuthzLevelRecord == NULL ||
                pTempLevelRecord->dwLevelId <
                    pAuthzLevelRecord->dwLevelId)
            {
                pAuthzLevelRecord = pTempLevelRecord;
                pAuthzIdentRecord = pTempIdentRecord;
            }
        }

#ifdef SAFER_PROMPT_USER_FOR_DECISION_MAKING

#error "Prompting user in WinVerifyTrust"

        //
        // We were originally passed UI flag, but we supressed
        // the UI display the first time.  Call WinVerifyTrust
        // again and see if user choice would allow code to run.
        //
        if (bRetryCertRuleCheck)
        {
            if (pAuthzLevelRecord != NULL) {
                //If we have a rule match and the rule match is FULLYTRUSTED skip retry.
                if (pAuthzLevelRecord->dwLevelId == SAFER_LEVELID_FULLYTRUSTED) {
                    bRetryCertRuleCheck = FALSE;
                }
            } else if (g_DefaultCodeLevel != NULL) {
                //No rule match so far.  Check default level.
                //If default level is FULLY_TRUSTED skip retry
                if (g_DefaultCodeLevel->dwLevelId == SAFER_LEVELID_FULLYTRUSTED) {
                    bRetryCertRuleCheck = FALSE;
                }
            }

            //
            // Perform the WinVerifyTrust sequence again to see if the signing
            // certificate matches any of the publishers that are in the
            // trusted or distrusted publisher stores.
            //
            if (bRetryCertRuleCheck) {
                Status = __CodeAuthzpCheckIdentityCertificateRules(
                                    &identStruct,
                                    &pTempLevelRecord,
                                    identStruct.CodeProps->dwWVTUIChoice);
                if (NT_SUCCESS(Status)) {
                    // User clicked Yes or No.  Run it as such.
                    ASSERT(pTempLevelRecord != NULL);
                    *pB