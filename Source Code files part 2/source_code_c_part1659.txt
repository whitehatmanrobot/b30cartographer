s class, which is either 0xffff plus one more word,
        // or a unicode string. After that is text/title.
        //
        p = pItem + 1;
        if(*(WORD *)p == 0xffff) {
            p = (WORD *)p + 2;
        } else {
            p = (PWCHAR)p + lstrlenW(p) + 1;
        }

        if(*(WORD *)p == 0xffff) {
            p = (WORD *)p + 2;
        } else {
            p = (PWCHAR)p + lstrlenW(p) + 1;
        }

        //
        // Skip creation data.
        //
        p = (PUCHAR)p + *(WORD *)p;
        p = (WORD *)p + 1;
    }

    if(i == ItemCount) {
        pItem = NULL;
    }

    return(pItem);
}


UINT
GetYPositionOfDialogItem(
    IN LPCTSTR Dialog,
    IN UINT    ControlId
    )
{
    HRSRC hRsrc;
    PVOID p;
    HGLOBAL hGlobal;
    DLGITEMTEMPLATE *pItem;
    UINT i;

    i = 0;

    if(hRsrc = FindResource(FaxWizModuleHandle,Dialog,RT_DIALOG)) {
        if(hGlobal = LoadResource(FaxWizModuleHandle,hRsrc)) {
            if(p = LockResource(hGlobal)) {

                if(pItem = FindControlInDialog(p,ControlId)) {
                    i = pItem->y * HIWORD(GetDialogBaseUnits()) / 8;
                }

                UnlockResource(hGlobal);
            }
            FreeResource(hGlobal);
        }
    }

    return(i);
}


int
CALLBACK
WizardCallback(
    IN HWND   hdlg,
    IN UINT   code,
    IN LPARAM lParam
    )
{
    DLGTEMPLATE *DlgTemplate;


    //
    // Get rid of context sensitive help control on title bar
    //
    if(code == PSCB_PRECREATE) {
        DlgTemplate = (DLGTEMPLATE *)lParam;
        DlgTemplate->style &= ~DS_CONTEXTHELP;
    }

    return 0;
}


int
CALLBACK
Winnt32SheetCallback(
    IN HWND   DialogHandle,
    IN UINT   Message,
    IN LPARAM lParam
    )
{
    DLGTEMPLATE *DlgTemplate;
    HDC hdc;

    switch(Message) {

    case PSCB_PRECREATE:
        //
        // Make sure we get into the foreground.
        //
        DlgTemplate = (DLGTEMPLATE *)lParam;
        DlgTemplate->style &= ~DS_CONTEXTHELP;
        DlgTemplate->style |= DS_SETFOREGROUND;

        //
        // Get the height of the page header/watermark area. The first page
        // must have a separator control with a known ID. We use that as
        // the basis for the header area height.
        //
        WatermarkHeaderHeight = GetYPositionOfDialogItem(
                                    MAKEINTRESOURCE(IDD_WELCOME),
                                    IDC_HEADER_BOTTOM
                                    );

        break;

    case PSCB_INITIALIZED:
        //
        // Load the watermark bitmap and override the dialog procedure for the wizard.
        //
        hdc = GetDC(NULL);

        GetBitmapDataAndPalette(
            FaxWizModuleHandle,
              (!hdc || (GetDeviceCaps(hdc,BITSPIXEL) < 8))
            ? MAKEINTRESOURCE(IDB_WATERMARK16) : MAKEINTRESOURCE(IDB_WATERMARK256),
            &WatermarkPalette,
            &WatermarkPaletteColorCount,
            &WatermarkBitmapInfoHeader
            );

        if(hdc) {
            ReleaseDC(NULL,hdc);
        }

        //OldWizardProc = (WNDPROC)SetWindowLong(DialogHandle,DWL_DLGPROC,(LONG)WizardDlgProc);
        break;
    }

    return(0);
}


LPHPROPSHEETPAGE
CreateWizardPages(
    HINSTANCE hInstance,
    PWIZPAGE SetupWizardPages,
    LPDWORD RequestedPages,
    LPDWORD PageCount
    )
{
    LPHPROPSHEETPAGE WizardPageHandles;
    LPDWORD PageList;
    DWORD PagesInSet;
    DWORD i;
    DWORD PageOrdinal;
    BOOL b;


    //
    // Determine which set of pages to use and how many there are in the set.
    //
    PageList = RequestedPages;

    PagesInSet = 0;
    while( PageList[PagesInSet] != (DWORD)-1) {
        PagesInSet += 1;
    }

    //
    // allocate the page handle array
    //

    WizardPageHandles = (HPROPSHEETPAGE*) MemAlloc(
        sizeof(HPROPSHEETPAGE) * PagesInSet
        );

    if (!WizardPageHandles) {
        return NULL;
    }

    //
    // Create each page.
    //

    b = TRUE;
    *PageCount = 0;
    for(i=0; b && (i<PagesInSet); i++) {

        PageOrdinal = PageList[i];

        SetupWizardPages[PageOrdinal].Page.hInstance = hInstance;
        SetupWizardPages[PageOrdinal].Page.dwFlags |= PSP_USETITLE;
        SetupWizardPages[PageOrdinal].Page.lParam = (LPARAM) &SetupWizardPages[PageOrdinal];
        SetupWizardPages[PageOrdinal].Page.dwSize = sizeof(PROPSHEETPAGE);

        if (PointPrintSetup) {
            SetupWizardPages[PageOrdinal].Page.pszTitle = GetString( IDS_TITLE_PP );
        }

        WizardPageHandles[*PageCount] = CreatePropertySheetPage(
            &SetupWizardPages[PageOrdinal].Page
            );

        if(WizardPageHandles[*PageCount]) {
            (*PageCount)++;
        } else {
            b = FALSE;
        }

    }

    if (!b) {
        MemFree( WizardPageHandles );
        return NULL;
    }

    return WizardPageHandles;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\shellext\faxshell.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    faxshell.cpp

Abstract:

    fax tiff data column provider

Author:

    Andrew Ritz (andrewr) 2-27-98

Environment:

    user-mode

Notes:


Revision History:

    2-27-98 (andrewr) Created.
    8-06-99 (steveke) Major rewrite -> changed from shell extension to column provider

--*/




#include <windows.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <faxcom.h>
#include <faxcom_i.c>
#include <initguid.h>
#include "faxutil.h"

#include "resource.h"
#include "faxshell.h"



extern "C" int APIENTRY
DllMain(
    HINSTANCE  hInstance,
    DWORD      dwReason,
    LPVOID     pContext
)
/*++

Routine Description:

  DLL entry point

Arguments:

  hInstance - handle to the module
  dwReason - indicates the reason for being called
  pContext - pointer to the context

Return Value:

  TRUE on success

--*/
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        g_hInstance = hInstance;
    }

    return TRUE;
}



STDAPI
DllGetClassObject(
    REFCLSID  rclsid,
    REFIID    riid,
    LPVOID    *ppvOut
)
/*++

Routine Description:

  Retrieves the class object

Arguments:

  rclsid - clsid for the class object
  riid - reference to the identifier of the interface
  ppvOut - interface pointer of the requested identifier

Return Value:

  S_OK on success

--*/
{
    if (ppvOut == NULL) {
        return E_INVALIDARG;
    }

    *ppvOut = NULL;

    // Verify the class id is CLSID_FaxShellExtension
    if (IsEqualCLSID(rclsid, CLSID_FaxShellExtension) == FALSE)
    {
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    // Instantiate a class factory object
    CClassFactory *pClassFactory = new CClassFactory();

    if (pClassFactory == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Get the interface pointer from QueryInterface and copy it to *ppvOut
    HRESULT hr = pClassFactory->QueryInterface(riid, ppvOut);
    pClassFactory->Release();

    return hr;
}



STDAPI
DllCanUnloadNow(
    VOID
)
/*++

Routine Description:

  Determines whether the the Dll is in use.

Arguments:

  None

Return Value:

  S_OK if the Dll can be unloaded, S_FALSE if the Dll cannot be unloaded

--*/
{
    return (InterlockedCompareExchange(&cLockCount, 0, 0) == 0) ? S_OK : S_FALSE;
}



STDMETHODIMP
CClassFactory::CreateInstance(
    LPUNKNOWN   pUnknown,
    REFIID      riid,
    LPVOID FAR  *ppvOut
)
/*++

Routine Description:

  Creates an uninitialized object

Arguments:

  pUnknown - pointer to controlling IUnknown
  riid - reference to the identifier of the interface
  ppvOut - interface pointer of the requested identifier

Return Value:

  S_OK on success

--*/
{
    if (ppvOut == NULL)
    {
        return E_INVALIDARG;
    }

    *ppvOut = NULL;

    if (pUnknown != NULL)
    {
        return CLASS_E_NOAGGREGATION;
    }

    // Instantiate a fax column provider object
    CFaxColumnProvider *pFaxColumnProvider = new CFaxColumnProvider();

    if (pFaxColumnProvider == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Get the interface pointer from QueryInterface and copy it to *ppvOut
    HRESULT hr = pFaxColumnProvider->QueryInterface(riid, ppvOut);
    pFaxColumnProvider->Release();

    return hr;
}



STDMETHODIMP
CFaxColumnProvider::GetColumnInfo(
    DWORD         dwIndex,
    SHCOLUMNINFO  *psci
)
/*++

Routine Description:

  Provides information about a column

Arguments:

  dwIndex - column's zero based index
  psci - pointer to an SHCOLUMNINFO structure to hold the column information

Return Value:

  S_OK on success

--*/
{
    ZeroMemory(psci, sizeof(SHCOLUMNINFO));
    
    if (dwIndex < ColumnTableCount)
    {
        WCHAR szColumnName[MAX_COLUMN_NAME_LEN];
        
        // Load the column name
        LoadString(g_hInstance, ColumnTable[dwIndex].dwId, szColumnName, ColumnTable[dwIndex].dwSize);
        lstrcpy(psci->wszTitle, szColumnName);
        lstrcpy(psci->wszDescription, szColumnName);

        psci->scid = *ColumnTable[dwIndex].pscid;
        psci->cChars = lstrlen(szColumnName) + 1;
        psci->vt = ColumnTable[dwIndex].vt;
        psci->fmt = LVCFMT_LEFT;
        psci->csFlags = SHCOLSTATE_TYPE_STR;

        return S_OK;
    }

    return S_FALSE;
}



STDMETHODIMP
CFaxColumnProvider::GetItemData(
    LPCSHCOLUMNID    pscid,
    LPCSHCOLUMNDATA  pscd,
    VARIANT          *pvarData
)
/*++

Routine Description:

  Provides column data for a specified file

Arguments:

  pscid - SHCOLUMNID structure that identifies the column
  pscd - SHCOLUMNDATA structure that specifies the file
  pvarData - pointer to a VARIANT with the data for the file

Return Value:

  S_OK if file data is returned, S_FALSE if the file is not supported by the column provider and no data is returned

--*/
{
    // hr is the result of an object method
    HRESULT  hr = S_FALSE;
    // FaxData is the fax tiff data
    BSTR     FaxData = NULL;

    // Check if file is a directory, which is not supported
    if ((pscd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == TRUE)
    {
        return S_FALSE;
    }

    // Check if file is supported, i.e. pscd->pwszExt == L".tif"
    if (lstrcmpi(pscd->pwszExt, L".tif") != 0)
    {
        return S_FALSE;
    }

    // Check if the IFaxTiff object exists
    if (m_IFaxTiff == NULL)
    {
        // Create the IFaxTiff object
        hr = CoCreateInstance(CLSID_FaxTiff, NULL, CLSCTX_INPROC_SERVER, IID_IFaxTiff, (LPVOID *) &m_IFaxTiff);
        if (FAILED(hr) == TRUE)
        {
            return hr;
        }
    }

    // Set the full path and file name of the fax tiff
    hr = m_IFaxTiff->put_Image((LPWSTR) pscd->wszFile);
    if (FAILED(hr) == TRUE)
    {
       return hr;
    }

    // Retrieve the fax tiff data
    switch (pscid->pid)
    {
        case PID_SENDERNAME:
            hr = m_IFaxTiff->get_SenderName(&FaxData);
            break;

        case PID_RECIPIENTNAME:
            hr = m_IFaxTiff->get_RecipientName(&FaxData);
            break;

        case PID_RECIPIENTNUMBER:
            hr = m_IFaxTiff->get_RecipientNumber(&FaxData);
            break;

        case PID_CSID:
            hr = m_IFaxTiff->get_Csid(&FaxData);
            break;

        case PID_TSID:
            hr = m_IFaxTiff->get_Tsid(&FaxData);
            break;

        case PID_RECEIVETIME:
            hr = m_IFaxTiff->get_ReceiveTime(&FaxData);
            break;

        case PID_CALLERID:
            hr = m_IFaxTiff->get_CallerId(&FaxData);
            break;

        case PID_ROUTING:
            hr = m_IFaxTiff->get_Routing(&FaxData);
            break;

        default:
            hr = S_FALSE;
    }

    if (FAILED(hr) == TRUE)
    {
       goto e0;
    }

    // Set the column data
    pvarData->vt = VT_BSTR;
    pvarData->bstrVal = SysAllocString(FaxData);
    SysFreeString(FaxData);

    if (pvarData->bstrVal == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e0;
    }

    hr = S_OK;

e0:
    // Close the file
    m_IFaxTiff->put_Image(L"");

    return hr;
}



STDAPI
DllRegisterServer(
   VOID
)
/*++

Routine Description:

  Function for the in-process server to create its registry entries

Return Value:

  S_OK on success

--*/
{
    // hKey is a handle to the registry key
    HKEY   hKey;
    // szKeyName is the name of a registry key
    WCHAR  szKeyName[MAX_PATH];

    // Register the COM object

    wsprintf(szKeyName, L"%s\\%s", REGKEY_CLASSES_CLSID, REGKEY_FAXSHELL_CLSID);
    hKey = OpenRegistryKey(HKEY_CLASSES_ROOT, szKeyName, TRUE, NULL);
    if (hKey == NULL)
    {
        return E_FAIL;
    }

    SetRegistryString(hKey, NULL, REGVAL_FAXSHELL_TEXT);

    RegCloseKey(hKey);

    wsprintf(szKeyName, L"%s\\%s\\%s", REGKEY_CLASSES_CLSID, REGKEY_FAXSHELL_CLSID, REGKEY_INPROC);
    hKey = OpenRegistryKey(HKEY_CLASSES_ROOT, szKeyName, TRUE, NULL);
    if (hKey == NULL)
    {
        return E_FAIL;
    }

    SetRegistryString(hKey, REGVAL_THREADING, REGVAL_APARTMENT);
    SetRegistryStringExpand(hKey, NULL, REGVAL_LOCATION);

    RegCloseKey(hKey);

    // Register the column provider

    wsprintf(szKeyName, L"%s\\%s", REGKEY_COLUMNHANDLERS, REGKEY_FAXSHELL_CLSID);
    hKey = OpenRegistryKey(HKEY_CLASSES_ROOT, szKeyName, TRUE, NULL);
    if (hKey == NULL)
    {
        return E_FAIL;
    }

    SetRegistryString(hKey, NULL, REGVAL_FAXSHELL_TEXT);

    RegCloseKey(hKey);

    return S_OK;
}



STDAPI
DllUnregisterServer(
   VOID
)
/*++

Routine Description:

  Function for the in-process server to remove its registry entries

Return Value:

  S_OK on success

--*/
{
    // szKeyName is the name of a registry key
    WCHAR  szKeyName[MAX_PATH];

    // Unregister the COM object

    wsprintf(szKeyName, L"%s\\%s", REGKEY_CLASSES_CLSID, REGKEY_FAXSHELL_CLSID);
    if (DeleteRegistryKey(HKEY_CLASSES_ROOT, szKeyName) == FALSE)
    {
        return E_FAIL;
    }

    // Unregister the column provider

    wsprintf(szKeyName, L"%s\\%s", REGKEY_COLUMNHANDLERS, REGKEY_FAXSHELL_CLSID);
    if (DeleteRegistryKey(HKEY_CLASSES_ROOT, szKeyName) == FALSE)
    {
        return E_FAIL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\shellext\faxshell.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    faxshell.h

Abstract:

    definitions for faxshell.cpp

Author:

    Andrew Ritz (andrewr) 2-27-98

Environment:

    user-mode

Notes:


Revision History:

    2-27-98 (andrewr) Created.
    8-06-99 (steveke) Major rewrite -> changed from shell extension to column provider

--*/




#define REGKEY_CLASSES_CLSID   L"Clsid"
#define REGKEY_FAXSHELL_CLSID  L"{7f9609be-af9a-11d1-83e0-00c04fb6e984}"
#define REGVAL_FAXSHELL_TEXT   L"Fax Tiff Data Column Provider"
#define REGKEY_INPROC          L"InProcServer32"
#define REGVAL_THREADING       L"ThreadingModel"
#define REGVAL_APARTMENT       L"Apartment"
#define REGVAL_LOCATION        L"%SystemRoot%\\system32\\faxshell.dll"
#define REGKEY_COLUMNHANDLERS  L"Folder\\shellex\\ColumnHandlers"



// g_hInstance is a global handle to the instance of the dll
HINSTANCE  g_hInstance = NULL;
// cLockCount is the lock count on the dll
LONG       cLockCount = 0;



// CLSID_FaxShellExtension is the class id: 7f9609be-af9a-11d1-83e0-00c04fb6e984
DEFINE_GUID (CLSID_FaxShellExtension, 0x7f9609be, 0xaf9a, 0x11d1, 0x83, 0xe0, 0x00, 0xc0, 0x4f, 0xb6, 0xe9, 0x84);
// PSGUID_FAXSHELLEXTENSION is the class guid: 7f9609be-af9a-11d1-83e0-00c04fb6e984
#define PSGUID_FAXSHELLEXTENSION {0x7f9609be, 0xaf9a, 0x11d1, 0x83, 0xe0, 0x00, 0xc0, 0x4f, 0xb6, 0xe9, 0x84}



// PID_* are column property identifiers
#define PID_SENDERNAME       0
#define PID_RECIPIENTNAME    1
#define PID_RECIPIENTNUMBER  2
#define PID_CSID             3
#define PID_TSID             4
#define PID_RECEIVETIME      5
#define PID_CALLERID         6
#define PID_ROUTING          7



// SCID_* are SHCOLUMNID structures that uniquely indentify the columns
SHCOLUMNID SCID_SenderName      = { PSGUID_FAXSHELLEXTENSION, PID_SENDERNAME      };
SHCOLUMNID SCID_RecipientName   = { PSGUID_FAXSHELLEXTENSION, PID_RECIPIENTNAME   };
SHCOLUMNID SCID_RecipientNumber = { PSGUID_FAXSHELLEXTENSION, PID_RECIPIENTNUMBER };
SHCOLUMNID SCID_Csid            = { PSGUID_FAXSHELLEXTENSION, PID_CSID            };
SHCOLUMNID SCID_Tsid            = { PSGUID_FAXSHELLEXTENSION, PID_TSID            };
SHCOLUMNID SCID_ReceiveTime     = { PSGUID_FAXSHELLEXTENSION, PID_RECEIVETIME     };
SHCOLUMNID SCID_CallerId        = { PSGUID_FAXSHELLEXTENSION, PID_CALLERID        };
SHCOLUMNID SCID_Routing         = { PSGUID_FAXSHELLEXTENSION, PID_ROUTING         };



typedef struct _COLUMN_TABLE
{
    SHCOLUMNID  *pscid;  // SHCOLUMNID structure that uniquely identifies the column
    DWORD       dwId;    // Resource id of the column name
    DWORD       dwSize;  // Resource size of the column name
    VARTYPE     vt;      // Variant type of the column's data
} COLUMN_TABLE;



const COLUMN_TABLE ColumnTable[] =
{
    { &SCID_SenderName,      IDS_COL_SENDERNAME,      MAX_COLUMN_NAME_LEN, VT_BSTR },
    { &SCID_RecipientName,   IDS_COL_RECIPIENTNAME,   MAX_COLUMN_NAME_LEN, VT_BSTR },
    { &SCID_RecipientNumber, IDS_COL_RECIPIENTNUMBER, MAX_COLUMN_NAME_LEN, VT_BSTR },
    { &SCID_Csid,            IDS_COL_CSID,            MAX_COLUMN_NAME_LEN, VT_BSTR },
    { &SCID_Tsid,            IDS_COL_TSID,            MAX_COLUMN_NAME_LEN, VT_BSTR },
    { &SCID_ReceiveTime,     IDS_COL_RECEIVETIME,     MAX_COLUMN_NAME_LEN, VT_BSTR },
    { &SCID_CallerId,        IDS_COL_CALLERID,        MAX_COLUMN_NAME_LEN, VT_BSTR },
    { &SCID_Routing,         IDS_COL_ROUTING,         MAX_COLUMN_NAME_LEN, VT_BSTR },
};

// ColumnTableCount is the number of entries in the column table
#define ColumnTableCount  (sizeof(ColumnTable) / sizeof(COLUMN_TABLE))



class CClassFactory : public IClassFactory
{
public:
    // IUnknown methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvOut)
    {
        static const QITAB qit[] =
        {
            QITABENT(CClassFactory, IClassFactory),    // IID_IClassFactory
            { 0 },
        };

        return QISearch(this, qit, riid, ppvOut);
    };
    
    virtual STDMETHODIMP_(ULONG) AddRef()
    {
        return InterlockedIncrement(&cObjectCount);
    };
    virtual STDMETHODIMP_(ULONG) Release()
    {
        if (InterlockedDecrement(&cObjectCount) != 0)
        {
            return cObjectCount;
        }

        delete this;

        return 0;
    };

    // IClassFactory methods
    virtual STDMETHODIMP CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR *ppvOut);
    virtual STDMETHODIMP LockServer(BOOL fLock)
    {
        (fLock == TRUE) ? InterlockedIncrement(&cLockCount) : InterlockedDecrement(&cLockCount);

        return S_OK;
    }

    CClassFactory() : cObjectCount(1)
    {
        LockServer(TRUE);
    }
    virtual ~CClassFactory()
    {
        LockServer(FALSE);
    }

private:
    // cObjectCount is the reference count of the object
    LONG  cObjectCount;
};

class CFaxColumnProvider : public IColumnProvider
{
public:
    // IUnknown methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvOut)
    {
        static const QITAB qit[] =
        {
            QITABENT(CFaxColumnProvider, IColumnProvider),  // IID_IColumnProvider
            { 0 },
        };

        return QISearch(this, qit, riid, ppvOut);
    };
    
    virtual STDMETHODIMP_(ULONG) AddRef()
    {
        return InterlockedIncrement(&cObjectCount);
    };
    virtual STDMETHODIMP_(ULONG) Release()
    {
        if (InterlockedDecrement(&cObjectCount) != 0)
        {
            return cObjectCount;
        }

        if (m_IFaxTiff != NULL)
        {
            m_IFaxTiff->Release();
        }

        delete this;

        return 0;
    };

    // IColumnProvider methods
    virtual STDMETHODIMP Initialize(LPCSHCOLUMNINIT psci) {return S_OK;};
    virtual STDMETHODIMP GetColumnInfo(DWORD dwIndex, SHCOLUMNINFO *psci);
    virtual STDMETHODIMP GetItemData(LPCSHCOLUMNID pscid, LPCSHCOLUMNDATA pscd, VARIANT *pvarData);

    CFaxColumnProvider() : cObjectCount(1), m_IFaxTiff(NULL)
    {
        InterlockedIncrement(&cLockCount);
    }
    virtual ~CFaxColumnProvider()
    {
        InterlockedDecrement(&cLockCount);
    }

private:
    // m_IFaxTiff is the IFaxTiff object
    IFaxTiff*  m_IFaxTiff;
    // cObjectCount is the reference count of the object
    LONG       cObjectCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\wizard.h ===
#include <windows.h>
#include <commctrl.h>
#include <setupapi.h>
#include <winspool.h>
#include <winsprlp.h>
#include <shellapi.h>
#include <lm.h>
#include <userenv.h>
#include <userenvp.h>
#define REALLY_USE_UNICODE 1
#include <tapi.h>
#include <shlobj.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "winfax.h"
#include "resource.h"
#include "faxutil.h"
#include "faxwiz.h"
#include "faxreg.h"

#pragma warning(3:4101)   // Unreferenced local variable

#define MAX_PLATFORMS               2

#define PRINTER_DRIVER_DIR          66000
#define PRINTER_CLIENT_DIR          66001
#define COVERPAGE_SERVER_DIR        66002
#define COVERPAGE_CLIENT_DIR        66003
#define OUTLOOK_ECF_DIR             66004

#define FAX_SERVICE_NAME            TEXT("Fax")
#define FAX_PRINTER_NAME            TEXT("Fax")
#define FAX_SERVICE_DISPLAY_NAME    TEXT("Microsoft Fax Service")
#define FAX_SERVICE_IMAGE_NAME      TEXT("%systemroot%\\system32\\faxsvc.exe")
#define FAX_SERVICE_DEPENDENCY      TEXT("TapiSrv\0RpcSs\0PlugPlay\0\0")
#define EXCHANGE_CLIENT_EXT_NAME    "FaxExtension"
#define EXCHANGE_CLIENT_EXT_FILE    "%windir%\\system32\\faxext32.dll"
#define EXCHANGE_CONTEXT_MASK       "00000100000000"
#define DEFAULT_FAX_STORE_DIR       TEXT("%systemroot%\\FaxStore")
#define WM_MY_PROGRESS              (WM_USER+100)
#define FAX_DRIVER_NAME             TEXT("Windows NT Fax Driver")
#define FAX_MONITOR_NAME            TEXT("Windows NT Fax Monitor")
#define UNINSTALL_STRING            TEXT("%windir%\\system32\\faxsetup.exe -r")
#define LT_PRINTER_NAME             32
#define LT_FAX_PHONE                64
#define LT_USER_NAME                64
#define LT_AREA_CODE                10
#define LT_PHONE_NUMBER             50
#define LT_ACCOUNT_NAME             64
#define LT_PASSWORD                 64
#define SPLREG_UI_SINGLE_STATUS     TEXT( "UISingleJobStatusString" )

#define FAXCLIENTS_DIR              TEXT("FxClient")
#define FAXCLIENTS_FULL_PATH        TEXT("%SystemRoot%\\System32\\Spool\\Drivers\\FxClient")
#define FAXCLIENTS_COMMENT          TEXT("Fax Client Installations")
#define COVERPAGE_DIR               TEXT("CoverPg")
#define OLD_COVERPAGE_DIR           TEXT("CoverPage")

#define OUTLOOKCONFIG_DIR           TEXT("addins")

#define COVERPAGE_EDITOR            TEXT("%systemroot%\\system32\\faxcover.exe")
#define DEFAULT_COVERPAGE_DIR       TEXT("%systemroot%\\CoverPg")
#define DEFAULT_FAX_PROFILE         TEXT("")

#define FAXAB_SERVICE_NAME          TEXT("MSFAX AB")
#define FAXXP_SERVICE_NAME          TEXT("MSFAX XP")

#define LVIS_GCNOCHECK              0x1000
#define LVIS_GCCHECK                0x2000

#define PLATFORM_NONE               0
#define PLATFORM_USE_PRINTER        1
#define PLATFORM_USE_MACHINE        2

#define SETUP_ACTION_NONE           0
#define SETUP_ACTION_COPY           1
#define SETUP_ACTION_DELETE         2

#define COVERPAGE_EXTENSION         TEXT(".cov")
#define COVERPAGE_ASSOC_NAME        TEXT("Coverpage")
#define COVERPAGE_ASSOC_DESC        TEXT("Fax Coverpage File")
#define COVERPAGE_OPEN_COMMAND      TEXT("%SystemRoot%\\system32\\faxcover.exe %1")

#define FAXVIEW_EXTENSION           TEXT(".tif")
#define FAXVIEW_EXTENSION2          TEXT(".tiff")
#define FAXVIEW_ASSOC_NAME          TEXT("Fax Document")
#define FAXVIEW_ASSOC_DESC          TEXT("Fax Document")
#define WANGIMAGE_ASSOC_NAME        TEXT("TIFImage.Document")
#define FAXVIEW_OPEN_COMMAND        TEXT("%SystemRoot%\\system32\\FaxView.exe \"%1\"")
#define FAXVIEW_PRINT_COMMAND       TEXT("%SystemRoot%\\system32\\FaxView.exe -p \"%1\"")
#define FAXVIEW_PRINTTO_COMMAND     TEXT("%SystemRoot%\\system32\\FaxView.exe -pt \"%1\" \"%2\" \"%3\" \"%4\"")
#define FAXVIEW_FILE_NAME           TEXT("%SystemRoot%\\system32\\FaxView.exe")
#define FAXVIEW_ICON_INDEX          0

#define SETUP_TYPE_INVALID          0
#define SETUP_TYPE_WORKSTATION      1
#define SETUP_TYPE_SERVER           2
#define SETUP_TYPE_CLIENT           3
#define SETUP_TYPE_POINT_PRINT      4
#define SETUP_TYPE_REMOTE_ADMIN     5

#define WRONG_PLATFORM              10

typedef HPROPSHEETPAGE *LPHPROPSHEETPAGE;


typedef struct _WIZPAGE {
    UINT            ButtonState;
    UINT            HelpContextId;
    LPTSTR          Title;
    DWORD           PageId;
    DLGPROC         DlgProc;
    PROPSHEETPAGE   Page;
} WIZPAGE, *PWIZPAGE;

#define REGKEY_WORDPAD              TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OptionalComponents\\WordPad")
#define   REGVAL_WP_INSTALLED       TEXT("Installed")
#define   REGVAL_WP_INF             TEXT("INF")
#define   REGVAL_WP_SECTION         TEXT("Section")

#define RUNDLL32_INF_INSTALL_CMD    TEXT("rundll32.exe setupapi,InstallHinfSection %s 132 %s")
#define FAX_MONITOR_CMD             TEXT("faxstat.exe")

#define WORDPAD_OPEN_CMD            TEXT("\"%SystemDrive%\\Program Files\\Windows NT\\Accessories\\WORDPAD.EXE\" \"%1\"")
#define WORDPAD_PRINT_CMD           TEXT("\"%SystemDrive%\\Program Files\\Windows NT\\Accessories\\WORDPAD.EXE\" /p \"%1\"")
#define WORDPAD_PRINTTO_CMD         TEXT("\"%SystemDrive%\\Program Files\\Windows NT\\Accessories\\WORDPAD.EXE\" /pt \"%1\" \"%2\" \"%3\" \"%4\"")


typedef struct _PLATFORM_INFO {
    LPTSTR      PrintPlatform;
    LPTSTR      OsPlatform;
    BOOL        Selected;
    DWORD       Mask;
    LPTSTR      DriverDir;
    BOOL        ThisPlatform;
} PLATFORM_INFO, *PPLATFORM_INFO;

typedef struct _FILE_QUEUE_INFO {
    LPTSTR      SectionName;
    LPTSTR      DestDir;
    DWORD       InfDirId;
    DWORD       DestDirId;
    DWORD       PlatformsFlag;
    DWORD       CopyFlags;
} FILE_QUEUE_INFO, *PFILE_QUEUE_INFO;

typedef struct _FILE_QUEUE_CONTEXT {
    HWND        hwnd;
    PVOID       QueueContext;
} FILE_QUEUE_CONTEXT, *PFILE_QUEUE_CONTEXT;

typedef struct _LINE_INFO {
    DWORD       PermanentLineID;
    BOOL        Selected;
    LPTSTR      DeviceName;
    LPTSTR      ProviderName;
    DWORD       Rings;
    DWORD       Flags;       // device use flags
} LINE_INFO, *PLINE_INFO;

typedef struct _WIZ_DATA {
    BOOL        RoutePrint;
    BOOL        UseDefaultPrinter;
    BOOL        RouteStore;
    BOOL        RouteMail;
    TCHAR       PrinterName[LT_PRINTER_NAME+1];
    TCHAR       UserName[LT_USER_NAME+1];
    TCHAR       AreaCode[LT_AREA_CODE+1];
    TCHAR       PhoneNumber[LT_PHONE_NUMBER+1];
    TCHAR       Csid[LT_FAX_PHONE+1];
    TCHAR       Tsid[LT_FAX_PHONE+1];
    TCHAR       RoutePrinterName[128];
    TCHAR       RouteDir[MAX_PATH];
    TCHAR       RouteProfile[128];
    TCHAR       AccountName[64];
    TCHAR       Password[64];
    TCHAR       MapiProfile[128];
    BOOL        UseLocalSystem;
    BOOL        UseExchange;
} WIZ_DATA, *PWIZ_DATA;


//
// group flags
//

#define USE_COMMON_GROUP        0x00000001    // do not use USE_USER_GROUP and USE_COMMON_GROUP
#define USE_USER_GROUP          0x00000002    //   together, they are mutually exclusive
#define USE_APP_PATH            0x00000004    // commandline must contain the subkey name
#define USE_SERVER_NAME         0x00000008    // if we're doing a client install the append the server name to the command line


typedef struct _GROUP_ITEMS {
    LPTSTR      GroupName;
    LPTSTR      Description;
    LPTSTR      CommandLine;
    LPTSTR      IconPath;
    LPTSTR      WorkingDirectory;
    DWORD       Flags;
    INT         IconIndex;
    INT         ShowCmd;
    WORD        HotKey;
} GROUP_ITEMS, *PGROUP_ITEMS;

typedef struct _SECURITY_INFO {
    TCHAR       AccountName[256];
    TCHAR       Password[256];
} SECURITY_INFO, *PSECURITY_INFO;

typedef struct _MDM_DEVSPEC {
    DWORD Contents;                                 // Set to 1 (indicates containing key)
    DWORD KeyOffset;                                // Offset to key from start of this struct.
                                                    // (not from start of LINEDEVCAPS ).
                                                    //  8 in our case.
    CHAR String[1];                                 // place containing null-terminated registry key.
} MDM_DEVSPEC, *PMDM_DEVSPEC;

typedef struct {
    HANDLE  hComm;
    CHAR    szDeviceName[1];
} DEVICEID, *PDEVICEID;

typedef enum _DATAYPE {
   DT_STRING,
   DT_LONGINT,
   DT_BOOLEAN,
   DT_NONE,
} DATATYPE;


TCHAR  ThisPlatformName[100];


#define SECTION_NAME                L"Fax"

#define KEY_MODE                    L"Mode"
#define   MODE_NEW                  L"New"
#define   MODE_UPGRADE              L"Upgrade"
#define   MODE_REMOVE               L"Remove"
#define   MODE_DRIVERS              L"Drivers"
#define KEY_FAX_PRINTER_NAME        L"FaxPrinterName"
#define KEY_FAX_NUMBER              L"FaxNumber"
#define KEY_USE_EXCHANGE            L"UseExchange"
#define KEY_PROFILE_NAME            L"ProfileName"
#define KEY_ROUTE_MAIL              L"RouteMail"
#define KEY_ROUTE_PROFILENAME       L"RouteProfileName"
#define KEY_PLATFORMS               L"Platforms"
#define KEY_ROUTE_PRINT             L"RoutePrint"
#define KEY_ROUTE_PRINTERNAME       L"RoutePrintername"
#define KEY_ACCOUNT_NAME            L"AccountName"
#define KEY_PASSWORD                L"Password"
#define KEY_FAX_PHONE               L"FaxPhone"
#define KEY_ROUTE_FOLDER            L"RouteFolder"
#define KEY_DEST_DIRPATH            L"FolderName"
#define KEY_SERVER_NAME             L"ServerName"
#define KEY_SENDER_NAME             L"SenderName"
#define KEY_SENDER_FAX_AREA_CODE    L"SenderFaxAreaCode"
#define KEY_SENDER_FAX_NUMBER       L"SenderFaxNumber"

#define EMPTY_STRING                L""

#define UAA_MODE                    0
#define UAA_PRINTER_NAME            1
#define UAA_FAX_PHONE               2
#define UAA_USE_EXCHANGE            3
#define UAA_DEST_PROFILENAME        4
#define UAA_ROUTE_MAIL              5
#define UAA_ROUTE_PROFILENAME       6
#define UAA_PLATFORM_LIST           7
#define UAA_ROUTE_PRINT             8
#define UAA_DEST_PRINTERLIST        9
#define UAA_ACCOUNT_NAME            10
#define UAA_PASSWORD                11
#define UAA_DEST_DIRPATH            12
#define UAA_SERVER_NAME             13
#define UAA_SENDER_NAME             14
#define UAA_SENDER_FAX_AREA_CODE    15
#define UAA_SENDER_FAX_NUMBER       16
#define UAA_ROUTE_FOLDER            17


typedef struct _UNATTEND_ANSWER {
    DWORD       ControlId;
    LPWSTR      SectionName;
    LPWSTR      KeyName;
    LPWSTR      DefaultAnswer;
    DATATYPE    DataType;
    union {
        PWSTR   String;
        LONG    Num;
        BOOL    Bool;
    } Answer;
} UNATTEND_ANSWER, *PUNATTEND_ANSWER;

typedef enum {
    WizPageDeviceStatus,
    WizPageDeviceSelection,
    WizPageServerName,
    WizPageExchange,
    WizPageFileCopy,
    WizPageStationId,
    WizPageRoutePrint,
    WizPageRouteStoreDir,
    WizPageRouteInbox,
    WizPageRouteSecurity,
    WizPagePlatforms,
    WizPageLast,
    WizPageLastUninstall,
    WizPageClientServerName,
    WizPageClientUserInfo,
    WizPageClientFileCopy,
    WizPageClientLast,
    WizPageRemoteAdminCopy,
    WizPageMaximum
} WizPage;


extern HINSTANCE        FaxWizModuleHandle;
extern HWND             FaxWizParentWindow;
extern DWORD            ServerWizardPages[];
extern DWORD            ClientWizardPages[];
extern DWORD            PointPrintWizardPages[];
extern WIZ_DATA         WizData;
extern PLINE_INFO       LineInfo;
extern DWORD            FaxDevices;
extern TCHAR            SourceDirectory[4096];
extern TCHAR            ClientSetupServerName[128];
extern BOOL             PointPrintSetup;
extern PLATFORM_INFO    Platforms[];
extern WORD             EnumPlatforms[4];
extern BOOL             OkToCancel;
extern DWORD            InstallMode;
extern DWORD            CountPlatforms;
extern PLATFORM_INFO    Platforms[];
extern DWORD            RequestedSetupType;
extern BOOL             RebootRequired;
extern BOOL             SuppressReboot;
extern DWORD            Installed;
extern DWORD            InstallType;
extern DWORD            InstalledPlatforms;
extern DWORD            InstallThreadError;
extern BOOL             MapiAvail;
extern DWORD            CurrentLocationId;
extern DWORD            CurrentCountryId;
extern LPTSTR           CurrentAreaCode;
extern UNATTEND_ANSWER  UnattendAnswerTable[];
extern BOOL             Unattended;
extern BOOL             NtGuiMode;
extern DWORD            Enabled;


LRESULT
SecurityErrorDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT
CommonDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT
DeviceStatusDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT
PlatformsDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT
FileCopyDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT
LastPageDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT
LastPageUninstallDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT
ServerNameDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT
StationIdDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT
RoutePrintDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT
RouteStoreDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT
RouteMailDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT
RouteSecurityDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT
ClientServerNameDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT
ClientUserInfoDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT
ClientFileCopyDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT
PrinterNameDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT
RemoteAdminFileCopyDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

DWORD
ServerFileCopyThread(
    HWND hwnd
    );

DWORD
RemoteAdminCopyThread(
    HWND hwnd
    );

DWORD
ClientFileCopyThread(
    HWND hwnd
    );

PVOID
MyEnumPrinters(
    LPTSTR  pServerName,
    DWORD   level,
    PDWORD  pcPrinters,
    DWORD   Flags
    );

PVOID
MyEnumMonitors(
    PDWORD  pcMonitors
    );

PVOID
MyEnumDrivers(
    LPTSTR pEnvironment,
    PDWORD pcDrivers
    );

BOOL
GetMapiProfiles(
    HWND hwnd,
    DWORD ResourceId
    );

BOOL
CreateServerFaxPrinter(
    HWND hwnd,
    LPTSTR FaxPrinterName
    );

DWORD
CreateClientFaxPrinter(
    HWND hwnd,
    LPTSTR FaxPrinterName
    );

BOOL
WINAPI
AddPortExW(
    IN LPWSTR   pName, OPTIONAL
    IN DWORD    Level,
    IN LPBYTE   lpBuffer,
    IN LPWSTR   lpMonitorName
    );

BOOL
InstallFaxService(
    BOOL UseLocalSystem,
    BOOL DemandStart,
    LPTSTR AccountName,
    LPTSTR Password
    );

DWORD
StartFaxService(
    VOID
    );

DWORD
MyStartService(
    LPTSTR ServiceName
    );

DWORD
DeviceInitThread(
    HWND hwnd
    );

DWORD
GetModemClass(
    HANDLE hFile
    );

//------------------------------------------
// private setupapi.dll functions
//------------------------------------------

BOOL
IsUserAdmin(
    VOID
    );

VOID
OutOfMemory(
    IN HWND Owner OPTIONAL
    );

//------------------------------------------

VOID
DeleteModemRegistryKey(
    VOID
    );

BOOL
StopFaxService(
    VOID
    );

BOOL
DeleteFaxService(
    VOID
    );

BOOL
StartSpoolerService(
    VOID
    );

BOOL
StopSpoolerService(
    VOID
    );

BOOL
SetServerRegistryData(
    VOID
    );

BOOL
SetClientRegistryData(
    VOID
    );

BOOL
SetSoundRegistryData(
    VOID
    );

DWORD
SetServiceSecurity(
    LPTSTR AccountName
    );

BOOL
IsPrinterFaxPrinter(
    LPTSTR PrinterName
    );

BOOL
ShareFaxPrinter(
    LPHANDLE hPrinter,
    LPTSTR FaxPrinterName
    );

BOOL
StopTheService(
    LPTSTR ServiceName
    );

BOOL
SetServiceDependency(
    LPTSTR ServiceName,
    LPTSTR DependentServiceName
    );

BOOL
SetServiceAccount(
    LPTSTR ServiceName,
    PSECURITY_INFO SecurityInfo
    );

DWORD
PointPrintFileCopyThread(
    HWND hwnd
    );

BOOL
CallModemInstallWizard(
   HWND hwnd
   );

BOOL
SetInstalledFlag(
    BOOL Installed
    );

BOOL
SetInstallType(
    DWORD InstallType
    );

BOOL
SetInstalledPlatforms(
    DWORD PlatformsMask
    );

BOOL
GetInstallationInfo(
    LPDWORD Installed,
    LPDWORD InstallType,
    LPDWORD InstalledPlatforms,
    LPDWORD Enabled
    );

BOOL
DeleteFaxRegistryData(
    VOID
    );

BOOL
MyDeleteService(
    LPTSTR ServiceName
    );

BOOL
DeleteFaxPrinters(
    HWND hwnd
    );

//
// util.c
//

LPTSTR
RemoveLastNode(
    LPTSTR Path
    );

DWORD
ExtraChars(
    HWND hwnd,
    LPTSTR TextBuffer
    );

LPTSTR
CompactFileName(
    LPCTSTR FileNameIn,
    DWORD CharsToRemove
    );

//
// fileq.c
//

BOOL
InitializeFileQueue(
    HWND hwnd,
    HINF *SetupInf,
    HSPFILEQ **FileQueue,
    PVOID *QueueContext,
    LPTSTR SourceRoot
    );

BOOL
ProcessFileQueue(
    HINF SetupInf,
    HSPFILEQ *FileQueue,
    PVOID QueueContext,
    LPTSTR SourceRoot,
    PFILE_QUEUE_INFO FileQueueInfo,
    DWORD CountFileQueueInfo,
    PSP_FILE_CALLBACK MyQueueCallback,
    DWORD ActionId
    );

BOOL
CloseFileQueue(
    HSPFILEQ *FileQueue,
    PVOID QueueContext
    );

//
// groups.c
//

VOID
CreateGroupItems(
    BOOL RemoteAdmin,
    LPTSTR ServerName
    );

VOID
DeleteGroupItems(
    VOID
    );

//
// uninstal.c
//

DWORD
UninstallThread(
    HWND hwnd
    );

//
// server.c
//

UINT
InstallQueueCallback(
    IN PVOID QueueContext,
    IN UINT  Notification,
    IN UINT  Param1,
    IN UINT  Param2
    );

VOID
SetProgress(
    HWND hwnd,
    DWORD StatusString
    );

BOOL
DoBrowseDestDir(
    HWND    hDlg
    );

LRESULT
DeviceSelectionDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
AddPrinterDrivers(
    VOID
    );

//
// dlgclast.c
//

LRESULT
LastClientPageDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
SetUnInstallInfo(
    VOID
    );

LRESULT
ExchangeDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

//
// mapi.c
//

BOOL
DeleteFaxMsgServices(
    VOID
    );

BOOL
DeleteMessageService(
    LPSTR ProfileName
    );

BOOL
GetDefaultMapiProfile(
    LPWSTR ProfileName
    );

BOOL
InitializeMapi(
    VOID
    );

BOOL
GetExchangeInstallCommand(
    LPWSTR InstallCommand
    );

BOOL
CreateDefaultMapiProfile(
    LPWSTR ProfileName
    );

BOOL
IsMapiServiceInstalled(
    LPWSTR ProfileNameW,
    LPWSTR ServiceNameW
    );

BOOL
InstallFaxAddressBook(
    HWND hwnd,
    LPWSTR ProfileName
    );

VOID
AddFaxAbToMapiSvcInf(
    VOID
    );

VOID
AddFaxXpToMapiSvcInf(
    VOID
    );

BOOL
InstallFaxTransport(
    LPWSTR ProfileNameW
    );

VOID
DoExchangeInstall(
    HWND hwnd
    );

BOOL
DeleteUnInstallInfo(
    VOID
    );

BOOL
InstallExchangeClientExtension(
    LPSTR ExtensionName,
    LPSTR FileName,
    LPSTR  ContextMask
    );

DWORD
IsExchangeRunning(
    VOID
    );

BOOL
InstallHelpFiles(
    VOID
    );

BOOL
GetUserInformation(
    LPTSTR *UserName,
    LPTSTR *FaxNumber,
    LPTSTR *AreaCode
    );

BOOL
CreateFileAssociation(
    LPWSTR FileExtension,
    LPWSTR FileAssociationName,
    LPWSTR FileAssociationDescription,
    LPWSTR OpenCommand,
    LPWSTR PrintCommand,
    LPWSTR PrintToCommand,
    LPWSTR FileName,
    DWORD  IconIndex
    );

BOOL
CreateNetworkShare(
    LPTSTR Path,
    LPTSTR ShareName,
    LPTSTR Comment
    );

BOOL
DeleteNetworkShare(
    LPTSTR ShareName
    );

LPTSTR
GetString(
    DWORD ResourceId
    );

int
PopUpMsg(
    HWND hwnd,
    DWORD ResourceId,
    BOOL Error,
    DWORD Type
    );

int
PopUpMsgFmt(
    HWND hwnd,
    DWORD ResourceId,
    BOOL Error,
    DWORD Type,
    ...
    );

VOID
SetWizPageTitle(
    HWND hWnd
    );

LPHPROPSHEETPAGE
CreateWizardPages(
    HINSTANCE hInstance,
    PWIZPAGE SetupWizardPages,
    LPDWORD RequestedPages,
    LPDWORD PageCount
    );

VOID
InitializeStringTable(
    VOID
    );

VOID
SetTitlesInStringTable(
    VOID
    );

LPTSTR
GetProductName(
    VOID
    );

BOOL
IsWordpadInstalled(
    VOID
    );

BOOL
InstallWordpad(
    VOID
    );

BOOL
ChangeTxtFileAssociation(
    VOID
    );

BOOL
DeleteDirectoryTree(
    LPWSTR Root
    );

BOOL
MyDeleteFile(
    LPWSTR FileName
    );

BOOL
UnAttendInitialize(
    IN LPWSTR AnswerFile
    );

BOOL
UnAttendGetAnswer(
    DWORD ControlId,
    LPBYTE AnswerBuf,
    DWORD AnswerBufSize
    );

int
CALLBACK
WizardCallback(
    IN HWND   hdlg,
    IN UINT   code,
    IN LPARAM lParam
    );

BOOL
ResetFileAssociation(
    LPWSTR FileExtension,
    LPWSTR FileAssociationName
    );


BOOL
PlatformOverride(
    LPTSTR   ThisPlatformName,
    LPTSTR   Override,
    LPTSTR   SourceRoot,
    LPTSTR   Result
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\shellext\resource.h ===
#define IDS_COL_SENDERNAME       1001
#define IDS_COL_RECIPIENTNAME    1002
#define IDS_COL_RECIPIENTNUMBER  1003
#define IDS_COL_CSID             1004
#define IDS_COL_TSID             1005
#define IDS_COL_RECEIVETIME      1006
#define IDS_COL_CALLERID         1007
#define IDS_COL_ROUTING          1008
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\test\faxvrfy\events.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  events.c

Abstract:

  This module:
    1) Determines if the port is valid
    2) Post a completion packet to a completion port.  This packet indicates for the Fax Event Queue thread to exit.
    3) Thread to handle the Fax Event Queue logic

Author:

  Steven Kehrli (steveke) 11/15/1997

--*/

#ifndef _EVENTS_C
#define _EVENTS_C

BOOL
fnIsPortValid(
    PFAX_PORT_INFO  pFaxPortsConfig,
    DWORD           dwNumPorts,
    DWORD           dwDeviceId
)
/*++

Routine Description:

  Determines if the port is valid

Arguments:

  pFaxPortsConfig - pointer to the ports configuration
  dwNumFaxPorts - number of ports
  dwDeviceId - port id

Return Value:

  TRUE on success

--*/
{
    // dwIndex is a counter to enumerate each port
    DWORD  dwIndex;

    for (dwIndex = 0; dwIndex < dwNumPorts; dwIndex++) {
        // Search, by priority, each port for the appropriate port
        if (pFaxPortsConfig[dwIndex].DeviceId == dwDeviceId) {
            return TRUE;
        }
    }

    return FALSE;
}

VOID
fnPostExitToCompletionPort(
    HANDLE  hCompletionPort
)
/*++

Routine Description:

  Post a completion packet to a completion port.  This packet indicates for the Fax Event Queue thread to exit.

Arguments:

  hCompletionPort - handle to the completion port

Return Value:

  None

--*/
{
    PFAX_EVENT  pFaxEvent;

    pFaxEvent = LocalAlloc(LPTR, sizeof(FAX_EVENT));
    pFaxEvent->EventId = -1;

    PostQueuedCompletionStatus(hCompletionPort, sizeof(FAX_EVENT), 0, (LPOVERLAPPED) pFaxEvent);
}

DWORD WINAPI fnFaxEventQueueProc (LPVOID lpv)
/*++

Routine Description:

  Thread to handle the Fax Event Queue logic

Return Value:

  DWORD - exit code

--*/
{
    // pFaxEvent is a pointer to the port event
    PFAX_EVENT        pFaxEvent;
    DWORD             dwBytes;
    UINT_PTR          upCompletionKey;

    // FaxDialingInfo is the fax dialing info
    FAX_DIALING_INFO  FaxDialingInfo;

    // bFaxPassed indicates a fax passed
    BOOL              bFaxPassed = FALSE;
    // bFaxFailed indicates a fax failed
    BOOL              bFaxFailed = FALSE;
    // dwDeviceId is the port id
    DWORD             dwDeviceId = 0;

    while (GetQueuedCompletionStatus(g_hCompletionPort, &dwBytes, &upCompletionKey, (LPOVERLAPPED *) &pFaxEvent, INFINITE)) {

        if (pFaxEvent->EventId == -1) {
            // g_hExitEvent was signaled, so thread should exit
            LocalFree(pFaxEvent);
            break;
        }

        if (pFaxEvent->EventId == FEI_FAXSVC_ENDED) {
            // Signal the g_hFaxEvent
            SetEvent(g_hFaxEvent);

            // Free the packet
            LocalFree(pFaxEvent);
            break;
        }

        if (pFaxEvent->EventId == FEI_MODEM_POWERED_OFF) {
            // Update the status
            SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_DEVICE_POWERED_OFF, pFaxEvent->DeviceId);

            // Free the packet
            LocalFree(pFaxEvent);

            // Decrement g_dwNumAvailPorts
            g_dwNumAvailPorts--;
            if (!g_dwNumAvailPorts) {
                SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_PORTS_NOT_AVAILABLE, 0);
            }
            continue;
        }

        if (pFaxEvent->EventId == FEI_MODEM_POWERED_ON) {
            // Update the status
            SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_DEVICE_POWERED_ON, pFaxEvent->DeviceId);

            // Free the packet
            LocalFree(pFaxEvent);

            // Increment g_dwNumAvailPorts
            g_dwNumAvailPorts++;
            continue;
        }

        // Verify the port is valid
        if (!fnIsPortValid(g_pFaxPortsConfig, g_dwNumPorts, pFaxEvent->DeviceId)) {
            // Free the packet
            LocalFree(pFaxEvent);
            continue;
        }

        if ((pFaxEvent->EventId == FEI_IDLE) && (g_bFaxSndInProgress) && (pFaxEvent->DeviceId == dwDeviceId) && ((bFaxPassed) || (bFaxFailed))) {
            // Update the status
            SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_IDLE, pFaxEvent->DeviceId);
            if (bFaxPassed) {
                SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_SEND_PASSED, pFaxEvent->DeviceId);
                // Signal the Send Passed event
                SetEvent(g_hSendPassedEvent);
            }
            else {
                SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_SEND_FAILED, pFaxEvent->DeviceId);
                // Signal the Send Failed event
                SetEvent(g_hSendFailedEvent);
            }
            dwDeviceId = 0;
            bFaxPassed = FALSE;
            bFaxFailed = FALSE;
            continue;
        }

        if ((pFaxEvent->EventId == FEI_IDLE) && (g_bFaxSndInProgress)) {
            // Update the status
            SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_IDLE, pFaxEvent->DeviceId);
        }

        if ((pFaxEvent->JobId == g_dwFaxId) && (g_bFaxSndInProgress)) {
            switch (pFaxEvent->EventId) {
                case FEI_INITIALIZING:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_INITIALIZING, pFaxEvent->DeviceId);
                    break;

                case FEI_DIALING:
                    g_dwAttempt++;
                    // Set FaxDialingInfo
                    FaxDialingInfo.dwAttempt = g_dwAttempt;
                    FaxDialingInfo.dwDeviceId = pFaxEvent->DeviceId;
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_DIALING, (LPARAM) &FaxDialingInfo);
                    dwDeviceId = pFaxEvent->DeviceId;
                    break;

                case FEI_NO_DIAL_TONE:
                    if (g_dwAttempt < (FAXSVC_RETRIES + 1)) {
                        // Update the status
                        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_NO_DIAL_TONE_RETRY, pFaxEvent->DeviceId);
                    }
                    else {
                        // Update the status
                        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_NO_DIAL_TONE_ABORT, pFaxEvent->DeviceId);
                        bFaxFailed = TRUE;
                    }
                    break;

                case FEI_BUSY:
                    if (g_dwAttempt < (FAXSVC_RETRIES + 1)) {
                        // Update the status
                        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_BUSY_RETRY, pFaxEvent->DeviceId);
                    }
                    else {
                        // Update the status
                        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_BUSY_ABORT, pFaxEvent->DeviceId);
                        bFaxFailed = TRUE;
                    }
                    break;

                case FEI_NO_ANSWER:
                    if (g_dwAttempt < (FAXSVC_RETRIES + 1)) {
                        // Update the status
                        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_NO_ANSWER_RETRY, pFaxEvent->DeviceId);
                    }
                    else {
                        // Update the status
                        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_NO_ANSWER_ABORT, pFaxEvent->DeviceId);
                        bFaxFailed = TRUE;
                    }
                    break;

                case FEI_SENDING:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_SENDING, pFaxEvent->DeviceId);
                    break;

                case FEI_FATAL_ERROR:
                    if (g_dwAttempt < (FAXSVC_RETRIES + 1)) {
                        // Update the status
                        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_FATAL_ERROR_RETRY, pFaxEvent->DeviceId);
                    }
                    else {
                        // Update the status
                        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_FATAL_ERROR_ABORT, pFaxEvent->DeviceId);
                        bFaxFailed = TRUE;
                    }
                    break;

                case FEI_ABORTING:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_ABORTING, pFaxEvent->DeviceId);
                    bFaxFailed = TRUE;
                    break;

                case FEI_COMPLETED:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_COMPLETED, pFaxEvent->DeviceId);
                    bFaxPassed = TRUE;
                    break;

                default:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_UNEXPECTED_STATE, pFaxEvent->DeviceId);
                    bFaxFailed = TRUE;
                    break;
            }
        }

        if (g_bFaxRcvInProgress) {
            switch (pFaxEvent->EventId) {
                case FEI_INITIALIZING:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_INITIALIZING, pFaxEvent->DeviceId);
                    break;

                case FEI_RINGING:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_RINGING, pFaxEvent->DeviceId);
                    break;

                case FEI_ANSWERED:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_ANSWERED, pFaxEvent->DeviceId);
                    break;

                case FEI_NOT_FAX_CALL:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_NOT_FAX_CALL, pFaxEvent->DeviceId);
                    break;

                case FEI_RECEIVING:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_RECEIVING, pFaxEvent->DeviceId);
                    break;

                case FEI_FATAL_ERROR:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_FATAL_ERROR, pFaxEvent->DeviceId);
                    break;

                case FEI_ABORTING:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_ABORTING, pFaxEvent->DeviceId);
                    break;

                case FEI_COMPLETED:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_COMPLETED, pFaxEvent->DeviceId);
                    break;

                case FEI_IDLE:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_IDLE, pFaxEvent->DeviceId);
                    break;

                default:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_UNEXPECTED_STATE, pFaxEvent->DeviceId);
                    break;
            }
        }

        // Free the packet
        LocalFree(pFaxEvent);
    }

    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\test\faxvrfy\faxvrfy.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  faxvrfy.c

Abstract:

  This module verifies the minimal functionality of the Windows NT Fax Service.

Author:

  Steven Kehrli (steveke) 11/15/1997

--*/

#include <windows.h>
#include <stdlib.h>
#include <commctrl.h>
#include <shellapi.h>
#include <winfax.h>

#include "faxrcv.h"
#include "faxvrfy.h"
#include "macros.h"
#include "macros.c"

#include "resource.h"

#include "startup.c"
#include "util.c"
#include "events.c"
#include "sndthrd.c"

// fnDialogProcSetup is the Setup Dialog Procedure
LRESULT CALLBACK fnDialogProcSetup (HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam);

VOID
fnUsageInfo(
    HWND  hWnd
)
/*++

Routine Description:

  Displays the usage info

Return Value:

  None

--*/
{
    // szHelpFile is the name of the help file
    WCHAR  szHelpFile[MAX_PATH];
    DWORD  cb;

    GetCurrentDirectory(sizeof(szHelpFile) / sizeof(WCHAR), szHelpFile);
    lstrcat(szHelpFile, L"\\");
    lstrcat(szHelpFile, FAXVRFY_HLP);

    WinHelp(hWnd, szHelpFile, HELP_FINDER, 0);
}

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)
{
    WNDCLASSEX          wndclass;
    MSG                 msg;

    // hMutex is the handle to the mutex
    HANDLE              hMutex;

    // argvW are the command line parameters
    LPWSTR              *argvW;
    // argc is the count of command line parameters
    INT                 argc;
    INT                 iIndex;

    // pFaxPortsConfigLocal is a pointer to the Fax Ports Configuration
    PFAX_PORT_INFO      pFaxPortsConfigLocal;
    // pFaxSvcConfigLocal is a pointer to the fax service configuration
    PFAX_CONFIGURATION  pFaxSvcConfigLocal;
    // hFaxPortHandle is the handle to a port
    HANDLE              hFaxPortHandle;
    DWORD               dwIndex;
    UINT                uRslt;

    // hFaxDevicesKey is the handle to the fax devices registry key
    HKEY                hFaxDevicesKey;
    // hFaxPortKey is the handle to the fax port registry key
    HKEY                hFaxPortKey;
    // szFaxPortKey is the name of the fax port registry key
    TCHAR               szFaxPortKey[15];
    // szFixModemClass is the modem class of the fax port
    LPWSTR              szFixModemClass;
    DWORD               cb;

    // szText is a text string
    WCHAR               szText[MAX_STRINGLEN + 2];

    // Set g_hInstance
    g_hInstance = hInstance;

    // Initialize the wndclass
    wndclass.cbSize = sizeof(wndclass);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = fnDialogProcSetup;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = DLGWINDOWEXTRA;
    wndclass.hInstance = g_hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_WINLOGO);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH) (COLOR_INACTIVEBORDER + 1);
    wndclass.lpszMenuName = MAKEINTRESOURCE(IDR_MENU);
    wndclass.lpszClassName = FAXVRFY_NAME;
    wndclass.hIconSm = LoadIcon(NULL, IDI_WINLOGO);

    // See if FaxVrfy is already running
    hMutex = CreateMutex(NULL, FALSE, FAXVRFY_NAME);
    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        while (TRUE) {
            // Wait for access to the mutex
            WaitForSingleObject(hMutex, INFINITE);

            // Find the window
            g_hWndDlg = FindWindow(FAXVRFY_NAME, NULL);
            if (g_hWndDlg) {
                // Switch to that window
                ShowWindow(g_hWndDlg, SW_RESTORE);
                SetForegroundWindow(g_hWndDlg);
                // Release access to the mutex
                ReleaseMutex(hMutex);
                return 0;
            }

            // Release access to the mutex
            ReleaseMutex(hMutex);

            // See if FaxVrfy is still running
            CloseHandle(hMutex);
            hMutex = CreateMutex(NULL, FALSE, FAXVRFY_NAME);
            if (GetLastError() == ERROR_SUCCESS) {
                break;
            }
        }
    }

    // Initialize the local mem
    MemInitializeMacro();

    // Set the default caption
    SetDefaultCaptionMacro(FAXVRFY_NAME);

    // Initialize the common controls
    InitCommonControls();

    argvW = CommandLineToArgvW(GetCommandLine(), &argc);
    for (iIndex = 0; iIndex < argc; iIndex++) {
        if ((!lstrcmpi(FAXVRFY_CMD_HELP_1, argvW[iIndex])) || (!lstrcmpi(FAXVRFY_CMD_HELP_2, argvW[iIndex])) || (!lstrcmpi(FAXVRFY_CMD_HELP_3, argvW[iIndex])) || (!lstrcmpi(FAXVRFY_CMD_HELP_4, argvW[iIndex]))) {
            fnUsageInfo(NULL);
            return 0;
        }
        else if ((!lstrcmpi(FAXVRFY_CMD_BVT_1, argvW[iIndex])) || (!lstrcmpi(FAXVRFY_CMD_BVT_2, argvW[iIndex]))) {
            g_bBVT = TRUE;
            g_bGo = FALSE;
            g_bNoCheck = FALSE;
            g_bRasAvailable = FALSE;
        }
        else if ((!lstrcmpi(FAXVRFY_CMD_SEND_1, argvW[iIndex])) || (!lstrcmpi(FAXVRFY_CMD_SEND_2, argvW[iIndex]))) {
            g_bSend = TRUE;
        }
        else if ((!lstrcmpi(FAXVRFY_CMD_RECEIVE_1, argvW[iIndex])) || (!lstrcmpi(FAXVRFY_CMD_RECEIVE_2, argvW[iIndex]))) {
            g_bSend = FALSE;
        }
        else if ((!g_bBVT) && ((!lstrcmpi(FAXVRFY_CMD_GO_1, argvW[iIndex])) || (!lstrcmpi(FAXVRFY_CMD_GO_2, argvW[iIndex])))) {
            g_bGo = TRUE;
        }
        else if ((!g_bBVT) && ((!lstrcmpi(FAXVRFY_CMD_NO_CHECK_1, argvW[iIndex])) || (!lstrcmpi(FAXVRFY_CMD_NO_CHECK_2, argvW[iIndex])))) {
            g_bNoCheck = TRUE;
        }
    }

    MemFreeMacro(argvW);

    // Initialize NTLog
    g_bNTLogAvailable = fnInitializeNTLog();

    // Start the log file
    fnStartLogFile();

    // Verify fax is installed
    uRslt = fnIsFaxInstalled();
    if (uRslt) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, uRslt, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, uRslt, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }

        goto ExitLevel0;
    }

    // Verify com objects are installed
    uRslt = fnIsComInstalled();
    if (uRslt) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, uRslt, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, uRslt, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }

        goto ExitLevel0;
    }

    // Initialize FaxRcv
    uRslt = fnInitializeFaxRcv();
    if (uRslt) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, uRslt, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, uRslt, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }

        goto ExitLevel0;
    }

    if (!g_bBVT) {
        g_bRasAvailable = fnInitializeRas();
    }

    // Create the Start event
    g_hStartEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    // Create the Stop event
    g_hStopEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    // Create the Exit event
    g_hExitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    // Create the Fax event
    g_hFaxEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    // Create the RAS Passed event
    g_hRasPassedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    // Create the RAS Failed event
    g_hRasFailedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    // Create the Send Passed event
    g_hSendPassedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    // Create the Send Failed event
    g_hSendFailedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    // Connect to the Fax Service
    if (!FaxConnectFaxServer(NULL, &g_hFaxSvcHandle)) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, IDS_FAX_CONNECT_FAILED, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, IDS_FAX_CONNECT_FAILED, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }

        goto ExitLevel1;
    }

    // Get the Fax Ports Configuration
    if (!FaxEnumPorts(g_hFaxSvcHandle, &g_pFaxPortsConfig, &g_dwNumPorts)) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, IDS_FAX_ENUM_PORTS_FAILED, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, IDS_FAX_ENUM_PORTS_FAILED, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }

        goto ExitLevel2;
    }

    if (!g_dwNumPorts) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, IDS_FAX_PORTS_NOT_INSTALLED, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, IDS_FAX_PORTS_NOT_INSTALLED, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }

        goto ExitLevel3;
    }
    g_dwNumAvailPorts = g_dwNumPorts;

    // Get the Fax Ports Configuration
    if (!FaxEnumPorts(g_hFaxSvcHandle, &pFaxPortsConfigLocal, &g_dwNumPorts)) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, IDS_FAX_ENUM_PORTS_FAILED, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, IDS_FAX_ENUM_PORTS_FAILED, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }

        goto ExitLevel3;
    }

    // Set the Fax Ports Configuration
    for (dwIndex = 0; dwIndex < g_dwNumPorts; dwIndex++) {
        pFaxPortsConfigLocal[dwIndex].Flags = FPF_RECEIVE | FPF_SEND;
        if (!FaxOpenPort(g_hFaxSvcHandle, pFaxPortsConfigLocal[dwIndex].DeviceId, PORT_OPEN_MODIFY, &hFaxPortHandle)) {
            if (!g_bBVT) {
                MessageBoxMacro(NULL, IDS_FAX_SET_PORT_FAILED, MB_ICONERROR, pFaxPortsConfigLocal[dwIndex].DeviceName);
            }
            g_bTestFailed = TRUE;

            LoadString(g_hInstance, IDS_FAX_SET_PORT_FAILED, szText, MAX_STRINGLEN);
            lstrcat(szText, L"\r\n");
            fnWriteLogFile(TRUE, szText, g_pFaxPortsConfig[dwIndex].DeviceName);
            if (g_bNTLogAvailable) {
                g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, szText, g_pFaxPortsConfig[dwIndex].DeviceName);
            }

            // Free the Fax Ports Configuration
            FaxFreeBuffer(pFaxPortsConfigLocal);
            goto ExitLevel4;
        }

        if (!FaxSetPort(hFaxPortHandle, (PFAX_PORT_INFO) &pFaxPortsConfigLocal[dwIndex])) {
            FaxClose(hFaxPortHandle);
            if (!g_bBVT) {
                MessageBoxMacro(NULL, IDS_FAX_SET_PORT_FAILED, MB_ICONERROR, pFaxPortsConfigLocal[dwIndex].DeviceName);
            }
            g_bTestFailed = TRUE;

            LoadString(g_hInstance, IDS_FAX_SET_PORT_FAILED, szText, MAX_STRINGLEN);
            lstrcat(szText, L"\r\n");
            fnWriteLogFile(TRUE, szText, g_pFaxPortsConfig[dwIndex].DeviceName);
            if (g_bNTLogAvailable) {
                g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, szText, g_pFaxPortsConfig[dwIndex].DeviceName);
            }

            // Free the Fax Ports Configuration
            FaxFreeBuffer(pFaxPortsConfigLocal);
            goto ExitLevel4;
        }

        FaxClose(hFaxPortHandle);
    }

    // Free the Fax Ports Configuration
    FaxFreeBuffer(pFaxPortsConfigLocal);

    // Get the modem fax class
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, FAXDEVICES_REGKEY, 0, KEY_ALL_ACCESS, &hFaxDevicesKey)) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, IDS_OPEN_FAXDEVICES_REGKEY_FAILED, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, IDS_OPEN_FAXDEVICES_REGKEY_FAILED, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }
        goto ExitLevel4;
    }

    for (dwIndex = 0; dwIndex < g_dwNumPorts; dwIndex++) {
        // Initialize the string representation of the DeviceId
        ZeroMemory(szFaxPortKey, sizeof(szFaxPortKey));
        // Set the string representation of the DeviceId
        wsprintf(szFaxPortKey, L"%08u", g_pFaxPortsConfig[dwIndex].DeviceId);
        lstrcat(szFaxPortKey, MODEM_REGKEY);

        szFixModemClass = NULL;
        if (!RegOpenKeyEx(hFaxDevicesKey, szFaxPortKey, 0, KEY_ALL_ACCESS, &hFaxPortKey)) {
            if (!RegQueryValueEx(hFaxPortKey, FIXMODEMCLASS_REGVALUE, NULL, NULL, NULL, &cb)) {
                if (cb) {
                    szFixModemClass = MemAllocMacro(cb);
                    if (RegQueryValueEx(hFaxPortKey, FIXMODEMCLASS_REGVALUE, NULL, NULL, (PBYTE) szFixModemClass, &cb)) {
                        MemFreeMacro(szFixModemClass);
                        szFixModemClass = NULL;
                    }
                    else if (!lstrcmp(L"", szFixModemClass)) {
                        MemFreeMacro(szFixModemClass);
                        szFixModemClass = NULL;
                    }
                }
            }

            RegCloseKey(hFaxPortKey);
        }

        if (!szFixModemClass) {
            szFixModemClass = MemAllocMacro(2 * sizeof(WCHAR));
            lstrcpy(szFixModemClass, L"1");
        }

        LoadString(g_hInstance, IDS_FIXMODEMCLASS_DATA, szText, MAX_STRINGLEN);
        lstrcat(szText, L"\r\n");
        fnWriteLogFile(TRUE, szText, g_pFaxPortsConfig[dwIndex].DeviceName, szFixModemClass);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_INFO | TL_TEST, szText, g_pFaxPortsConfig[dwIndex].DeviceName, szFixModemClass);
        }

        MemFreeMacro(szFixModemClass);
    }

    RegCloseKey(hFaxDevicesKey);
    fnWriteLogFile(FALSE, L"\r\n");
    if (g_bNTLogAvailable) {
        g_NTLogApi.ptlLog(g_hLogFile, TLS_INFO | TL_TEST, L"\r\n");
    }

    // Get the Fax Service Configuration
    if (!FaxGetConfiguration(g_hFaxSvcHandle, &g_pFaxSvcConfig)) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, IDS_FAX_GET_CONFIG_FAILED, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, IDS_FAX_GET_CONFIG_FAILED, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }

        goto ExitLevel4;
    }

    // Get the Fax Service Configuration
    if (!FaxGetConfiguration(g_hFaxSvcHandle, &pFaxSvcConfigLocal)) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, IDS_FAX_GET_CONFIG_FAILED, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, IDS_FAX_GET_CONFIG_FAILED, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }

        goto ExitLevel5;
    }

    // Set the Fax Service Configuration
    pFaxSvcConfigLocal->Retries = FAXSVC_RETRIES;
    pFaxSvcConfigLocal->RetryDelay = FAXSVC_RETRYDELAY;
    pFaxSvcConfigLocal->UseDeviceTsid = FALSE;
    if (!FaxSetConfiguration(g_hFaxSvcHandle, pFaxSvcConfigLocal)) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, IDS_FAX_SET_CONFIG_FAILED, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, IDS_FAX_SET_CONFIG_FAILED, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }

        // Free the Fax Service Configuration
        FaxFreeBuffer(pFaxSvcConfigLocal);
        goto ExitLevel5;
    }

    // Free the Fax Service Configuration
    FaxFreeBuffer(pFaxSvcConfigLocal);

    // Create the completion port
    g_hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1);
    // Initialize the Fax Event Queue
    if (!FaxInitializeEventQueue(g_hFaxSvcHandle, g_hCompletionPort, 0, NULL, 0)) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, IDS_FAX_EVENT_QUEUE_FAILED, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, IDS_FAX_EVENT_QUEUE_FAILED, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }

        goto ExitLevel6;
    }

    // Create the Fax Event Queue thread
    CreateThread(NULL, 0, fnFaxEventQueueProc, NULL, 0, NULL);

    // Create the Send thread
    CreateThread(NULL, 0, fnSendProc, NULL, 0, NULL);

    if (g_bBVT) {
        wndclass.lpszMenuName = NULL;
    }

    RegisterClassEx(&wndclass);

    // Create the Setup Dialog
    g_hWndDlg = CreateDialog(g_hInstance, MAKEINTRESOURCE(IDD_SETUP), NULL, NULL);
    SendMessage(g_hWndDlg, UM_FAXVRFY_INITIALIZE, 0, 0);

    ShowWindow(g_hWndDlg, iCmdShow);
    UpdateWindow(g_hWndDlg);

    if ((g_bBVT) || (g_bGo)) {
        PostMessage(GetDlgItem(g_hWndDlg, IDC_START_BUTTON), BM_CLICK, 0, 0);
    }

    while (GetMessage(&msg, NULL, 0, 0)) {
        if (!IsDialogMessage(g_hWndDlg, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

ExitLevel6:
    if (g_hCompletionPort) {
        CloseHandle(g_hCompletionPort);
    }

    // Restore the Fax Service Configuration
    if (!FaxSetConfiguration(g_hFaxSvcHandle, g_pFaxSvcConfig)) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, IDS_FAX_RESTORE_CONFIG_FAILED, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, IDS_FAX_RESTORE_CONFIG_FAILED, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }
    }

ExitLevel5:
    // Free the Fax Service Configuration
    FaxFreeBuffer(g_pFaxSvcConfig);

ExitLevel4:
    // Restore the Fax Ports Configuration
    for (dwIndex = 0; dwIndex < g_dwNumPorts; dwIndex++) {
        if (!FaxOpenPort(g_hFaxSvcHandle, g_pFaxPortsConfig[dwIndex].DeviceId, PORT_OPEN_MODIFY, &hFaxPortHandle)) {
            if (!g_bBVT) {
                MessageBoxMacro(NULL, IDS_FAX_RESTORE_PORT_FAILED, MB_ICONERROR, g_pFaxPortsConfig[dwIndex].DeviceName);
            }
            g_bTestFailed = TRUE;

            LoadString(g_hInstance, IDS_FAX_RESTORE_PORT_FAILED, szText, MAX_STRINGLEN);
            lstrcat(szText, L"\r\n");
            fnWriteLogFile(TRUE, szText, g_pFaxPortsConfig[dwIndex].DeviceName);
            if (g_bNTLogAvailable) {
                g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, szText, g_pFaxPortsConfig[dwIndex].DeviceName);
            }

            continue;
        }

        if (!FaxSetPort(hFaxPortHandle, &g_pFaxPortsConfig[dwIndex])) {
            if (!g_bBVT) {
                MessageBoxMacro(NULL, IDS_FAX_RESTORE_PORT_FAILED, MB_ICONERROR, g_pFaxPortsConfig[dwIndex].DeviceName);
            }
            g_bTestFailed = TRUE;

            LoadString(g_hInstance, IDS_FAX_RESTORE_PORT_FAILED, szText, MAX_STRINGLEN);
            lstrcat(szText, L"\r\n");
            fnWriteLogFile(TRUE, szText, g_pFaxPortsConfig[dwIndex].DeviceName);
            if (g_bNTLogAvailable) {
                g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, szText, g_pFaxPortsConfig[dwIndex].DeviceName);
            }
        }

        FaxClose(hFaxPortHandle);
    }

ExitLevel3:
    // Free the Fax Ports Configuration
    FaxFreeBuffer(g_pFaxPortsConfig);

ExitLevel2:
    // Disconnect from the Fax Service
    FaxClose(g_hFaxSvcHandle);

ExitLevel1:
    CloseHandle(g_hSendFailedEvent);
    CloseHandle(g_hSendPassedEvent);
    CloseHandle(g_hRasFailedEvent);
    CloseHandle(g_hRasPassedEvent);
    CloseHandle(g_hFaxEvent);
    CloseHandle(g_hExitEvent);
    CloseHandle(g_hStopEvent);
    CloseHandle(g_hStartEvent);

    if (g_bRasAvailable) {
        FreeLibrary(g_RasApi.hInstance);
    }

ExitLevel0:
    fnWriteLogFile(FALSE, L"\r\n");
    if (g_bNTLogAvailable) {
        g_NTLogApi.ptlLog(g_hLogFile, TLS_INFO | TL_TEST, L"\r\n");
    }

    if ((g_bTestFailed) || (g_dwNumTotal)) {
        if (g_dwNumTotal) {
            // Log the results
            LoadString(g_hInstance, IDS_NUM_PASSED, szText, MAX_STRINGLEN);
            fnWriteLogFile(FALSE, szText, g_dwNumPassed);
            if (g_bNTLogAvailable) {
                g_NTLogApi.ptlLog(g_hLogFile, TLS_INFO | TL_TEST, szText, g_dwNumPassed);
            }

            LoadString(g_hInstance, IDS_NUM_FAILED, szText, MAX_STRINGLEN);
            fnWriteLogFile(FALSE, szText, g_dwNumFailed);
            if (g_bNTLogAvailable) {
                g_NTLogApi.ptlLog(g_hLogFile, TLS_INFO | TL_TEST, szText, g_dwNumFailed);
            }

            LoadString(g_hInstance, IDS_NUM_TOTAL, szText, MAX_STRINGLEN);
            fnWriteLogFile(FALSE, szText, g_dwNumTotal);
            if (g_bNTLogAvailable) {
                g_NTLogApi.ptlLog(g_hLogFile, TLS_INFO | TL_TEST, szText, g_dwNumTotal);
            }
        }

        if ((g_bTestFailed) || (g_dwNumFailed)) {
            fnWriteLogFile(FALSE, L"\r\n");
            if (g_bNTLogAvailable) {
                g_NTLogApi.ptlLog(g_hLogFile, TLS_INFO | TL_TEST, L"\r\n");
            }

            LoadString(g_hInstance, IDS_STATUS_TEST_FAILED, szText, MAX_STRINGLEN);
            fnWriteLogFile(FALSE, L"%s\r\n", szText);
            if (g_bNTLogAvailable) {
                g_NTLogApi.ptlLog(g_hLogFile, TLS_INFO | TL_TEST, L"%s\r\n", szText);
            }
        }
        else {
            fnWriteLogFile(FALSE, L"\r\n");
            if (g_bNTLogAvailable) {
                g_NTLogApi.ptlLog(g_hLogFile, TLS_INFO | TL_TEST, L"\r\n");
            }

            LoadString(g_hInstance, IDS_STATUS_TEST_PASSED, szText, MAX_STRINGLEN);
            fnWriteLogFile(FALSE, L"%s\r\n", szText);
            if (g_bNTLogAvailable) {
                g_NTLogApi.ptlLog(g_hLogFile, TLS_INFO | TL_TEST, L"%s\r\n", szText);
            }
        }
    }

    // Close the log file
    fnCloseLogFile();

    CloseHandle(hMutex);

    return 0;
}

LRESULT CALLBACK fnDialogProcSetup (HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    // hWndStatusList is the handle to the Status List
    static HWND   hWndStatusList;
    // rcClient is the WindowRect of the Status List
    RECT          rcClient;
    // lvc specifies the attributes of a particular column of the Status List
    LV_COLUMN     lvc;
    // lvi specifies the attributes of a particular item of the Status List
    LV_ITEM       lvi;

    // szText is a text string
    WCHAR         szText[MAX_STRINGLEN + 1];
    // szFormatString is the format of the text string
    WCHAR         szFormatString[MAX_STRINGLEN + 1];
    // szRasError is the Ras error string
    WCHAR         szRasError[MAX_STRINGLEN + 1];

    // dwResourceId is the resource id
    DWORD         dwResourceId;
    // szDeviceName is the device name
    LPWSTR        szDeviceName;

    // szIniFile is the ini file name
    static WCHAR  szIniFile[_MAX_PATH + 1];

    // szMissingInfo is the missing info
    WCHAR         szMissingInfo[MAX_STRINGLEN + 1];
    // szMissingInfoError is the missing info error message
    WCHAR         szMissingInfoError[(MAX_STRINGLEN * 5) + 1];

    DWORD         dwStyle;
    DWORD         dwLevel;

    switch (iMsg) {
        case WM_CREATE:
            // Get the Rect of the Setup Dialog
            GetWindowRect(hWnd, &rcClient);
            if (!g_bBVT) {
                // Increase the bottom of the Setup Dialog Rect by the height of the menu
                rcClient.bottom += GetSystemMetrics(SM_CYMENU);
            }
            // Resize the Setup Dialog
            SetWindowPos(hWnd, NULL, 0, 0, rcClient.right - rcClient.left, rcClient.bottom - rcClient.top, SWP_NOMOVE | SWP_NOZORDER);
            break;

        case UM_FAXVRFY_INITIALIZE:
            CheckMenuItem(GetMenu(hWnd), IDM_SEND, MF_BYCOMMAND | g_bSend ? MF_CHECKED : MF_UNCHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_RECEIVE, MF_BYCOMMAND | g_bSend ? MF_UNCHECKED : MF_CHECKED);

            // Limit the text length of edit controls
            SendMessage(GetDlgItem(hWnd, IDC_SEND_NUMBER), EM_SETLIMITTEXT, PHONE_NUM_LEN, 0);
            SendMessage(GetDlgItem(hWnd, IDC_RECEIVE_NUMBER), EM_SETLIMITTEXT, PHONE_NUM_LEN, 0);
            SendMessage(GetDlgItem(hWnd, IDC_RAS_USER_NAME), EM_SETLIMITTEXT, UNLEN, 0);
            SendMessage(GetDlgItem(hWnd, IDC_RAS_PASSWORD), EM_SETLIMITTEXT, PWLEN, 0);
            SendMessage(GetDlgItem(hWnd, IDC_RAS_DOMAIN), EM_SETLIMITTEXT, DNLEN, 0);

            // Get the handle to the Status List
            hWndStatusList = GetDlgItem(hWnd, IDC_STATUS_LIST);
            // Get the Rect of the Status List
            GetWindowRect(hWndStatusList, &rcClient);

            // Set common attributes for each column
            lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvc.fmt = LVCFMT_LEFT;

            // Event Column
            // Load the Event Column text
            LoadString(g_hInstance, IDS_EVENT_LABEL, szText, MAX_STRINGLEN);
            // Set the column text
            lvc.pszText = szText;
            // Set the width of the column to be about 2 / 5 of the width of the Status List, allowing for the width of the borders and scroll bar
            lvc.cx = ((rcClient.right - rcClient.left - 4 * GetSystemMetrics(SM_CXBORDER) - GetSystemMetrics(SM_CXVSCROLL)) * 2) / 5;
            // Indicate this is the first column
            lvc.iSubItem = 0;
            // Insert column into Status List
            ListView_InsertColumn(hWndStatusList, 0, &lvc);

            // Port Column
            // Load the Port Column text
            LoadString(g_hInstance, IDS_PORT_LABEL, szText, MAX_STRINGLEN);
            // Set the column text
            lvc.pszText = szText;
            // Set the width of the column to be about 3 / 5 of the width of the Status List, allowing for the width of the borders and scroll bar
            lvc.cx = (lvc.cx * 3) / 2;
            // Indicate this is the second column
            lvc.iSubItem = 1;
            // Insert column into Status List
            ListView_InsertColumn(hWndStatusList, 1, &lvc);

            // Disable the Stop Button
            EnableWindow(GetDlgItem(hWnd, IDC_STOP_BUTTON), FALSE);

            // Get the current directory
            GetCurrentDirectory(sizeof(szIniFile) / sizeof(WCHAR), szIniFile);
            // Set the ini file name
            lstrcat(szIniFile, L"\\");
            lstrcat(szIniFile, FAXVRFY_INI);

            // Get the strings from the ini file
            GetPrivateProfileString(L"Fax", L"SendNumber", L"", g_szSndNumber, sizeof(g_szSndNumber), szIniFile);
            if (fnIsStringASCII(g_szSndNumber)) {
                SetDlgItemText(hWnd, IDC_SEND_NUMBER, g_szSndNumber);
            }
            else {
                ZeroMemory(g_szSndNumber, sizeof(g_szSndNumber));
            }
            GetPrivateProfileString(L"Fax", L"ReceiveNumber", L"", g_szRcvNumber, sizeof(g_szRcvNumber), szIniFile);
            if (fnIsStringASCII(g_szRcvNumber)) {
                SetDlgItemText(hWnd, IDC_RECEIVE_NUMBER, g_szRcvNumber);
            }
            else {
                ZeroMemory(g_szRcvNumber, sizeof(g_szRcvNumber));
            }

            if (g_bRasAvailable) {
                if (GetPrivateProfileInt(L"RAS", L"Enabled", 0, szIniFile)) {
                    // Click the Fax Send check button
                    SendMessage(GetDlgItem(hWnd, IDC_RAS_ENABLED_BUTTON), BM_CLICK, 0, 0);
                }
            }
            GetPrivateProfileString(L"RAS", L"UserName", L"", g_szRasUserName, sizeof(g_szRasUserName), szIniFile);
            SetDlgItemText(hWnd, IDC_RAS_USER_NAME, g_szRasUserName);
            ZeroMemory(g_szRasPassword, sizeof(g_szRasPassword));
            GetPrivateProfileString(L"RAS", L"Domain", L"", g_szRasDomain, sizeof(g_szRasDomain), szIniFile);
            SetDlgItemText(hWnd, IDC_RAS_DOMAIN, g_szRasDomain);

            SendMessage(hWnd, UM_FAXVRFY_RESET, 0, 0);

            return 0;

        case UM_FAXVRFY_RESET:
            // Enable or disable the Fax specific controls
            EnableWindow(GetDlgItem(hWnd, IDC_SEND_NUMBER_STATIC), (!wParam && g_bSend) ? TRUE : FALSE);
            EnableWindow(GetDlgItem(hWnd, IDC_SEND_NUMBER), (!wParam && g_bSend) ? TRUE : FALSE);
            EnableWindow(GetDlgItem(hWnd, IDC_RECEIVE_NUMBER_STATIC), (!wParam && g_bSend) ? TRUE : FALSE);
            EnableWindow(GetDlgItem(hWnd, IDC_RECEIVE_NUMBER), (!wParam && g_bSend) ? TRUE : FALSE);

            // Enable the RAS specific controls
            EnableWindow(GetDlgItem(hWnd, IDC_RAS_ENABLED_BUTTON), (!wParam && g_bSend && g_bRasAvailable) ? TRUE : FALSE);
            EnableWindow(GetDlgItem(hWnd, IDC_RAS_USER_NAME_STATIC), (!wParam && g_bSend && g_bRasEnabled && g_bRasAvailable) ? TRUE : FALSE);
            EnableWindow(GetDlgItem(hWnd, IDC_RAS_USER_NAME), (!wParam && g_bSend && g_bRasEnabled && g_bRasAvailable) ? TRUE : FALSE);
            EnableWindow(GetDlgItem(hWnd, IDC_RAS_PASSWORD_STATIC), (!wParam && g_bSend && g_bRasEnabled && g_bRasAvailable) ? TRUE : FALSE);
            EnableWindow(GetDlgItem(hWnd, IDC_RAS_PASSWORD), (!wParam && g_bSend && g_bRasEnabled && g_bRasAvailable) ? TRUE : FALSE);
            EnableWindow(GetDlgItem(hWnd, IDC_RAS_DOMAIN_STATIC), (!wParam && g_bSend && g_bRasEnabled && g_bRasAvailable) ? TRUE : FALSE);
            EnableWindow(GetDlgItem(hWnd, IDC_RAS_DOMAIN), (!wParam && g_bSend && g_bRasEnabled && g_bRasAvailable) ? TRUE : FALSE);

            if (wParam) {
                // Disable the Start Button
                EnableWindow(GetDlgItem(hWnd, IDC_START_BUTTON), FALSE);
                // Disable the Stop Button
                EnableWindow(GetDlgItem(hWnd, IDC_STOP_BUTTON), FALSE);
                // Enable the Exit Button
                EnableWindow(GetDlgItem(hWnd, IDC_EXIT_BUTTON), TRUE);

                // Disable the Option Menu
                EnableMenuItem(GetMenu(hWnd), IDM_SEND, MF_BYCOMMAND | MF_GRAYED);
                EnableMenuItem(GetMenu(hWnd), IDM_RECEIVE, MF_BYCOMMAND | MF_GRAYED);

                // Set the focus to the Exit button
                SendMessage(hWnd, WM_NEXTDLGCTL, (WPARAM) GetDlgItem(hWnd, IDC_EXIT_BUTTON), MAKELONG(TRUE, 0));
            }
            else {
                // Enable the Start Button
                EnableWindow(GetDlgItem(hWnd, IDC_START_BUTTON), TRUE);
                // Disable the Stop Button
                EnableWindow(GetDlgItem(hWnd, IDC_STOP_BUTTON), FALSE);
                // Enable the Exit Button
                EnableWindow(GetDlgItem(hWnd, IDC_EXIT_BUTTON), TRUE);

                // Enable the Option Menu
                EnableMenuItem(GetMenu(hWnd), IDM_SEND, MF_BYCOMMAND | MF_ENABLED);
                EnableMenuItem(GetMenu(hWnd), IDM_RECEIVE, MF_BYCOMMAND | MF_ENABLED);

                // Set the focus to the Start button
                SendMessage(hWnd, WM_NEXTDLGCTL, (WPARAM) GetDlgItem(hWnd, IDC_START_BUTTON), MAKELONG(TRUE, 0));
            }
            return 0;

        case UM_TIMEOUT_ENDED:
        case UM_FAXSVC_ENDED:
            g_bTestFailed = TRUE;

            if (iMsg == UM_TIMEOUT_ENDED) {
                // Update the status
                SendMessage(hWnd, UM_UPDATE_STATUS, IDS_STATUS_TIMEOUT_ENDED, 0);
            }
            else if (iMsg == UM_FAXSVC_ENDED) {
                // Post a completion packet to a completion port to exit the Fax Event Queue thread
                fnPostExitToCompletionPort(g_hCompletionPort);
                // Update the status
                SendMessage(hWnd, UM_UPDATE_STATUS, IDS_STATUS_FAXSVC_ENDED, 0);
            }

            if ((!IsWindowEnabled(GetDlgItem(hWnd, IDC_START_BUTTON))) && (g_bSend)) {
                // Update the status
                SendMessage(hWnd, UM_ITERATION_FAILED, 0, 0);
            }

            SendMessage(hWnd, UM_FAXVRFY_RESET, 1, 0);

            if (g_bBVT) {
                SendMessage(GetDlgItem(g_hWndDlg, IDC_EXIT_BUTTON), BM_CLICK, 0, 0);
            }

            return 0;

        case UM_ITERATION_STOPPED:
            // Update the status
            SendMessage(hWnd, UM_UPDATE_STATUS, IDS_STATUS_ITERATION_STOPPED, 0);
            SendMessage(hWnd, UM_FAXVRFY_RESET, 0, 0);

            return 0;

        case UM_ITERATION_PASSED:
            // Update the status
            SendMessage(hWnd, UM_UPDATE_STATUS, IDS_STATUS_ITERATION_PASSED, 0);
            SendMessage(hWnd, UM_FAXVRFY_RESET, 0, 0);

            // Update the iterations
            g_dwNumPassed++;
            g_dwNumTotal++;
            SetDlgItemInt(hWnd, IDC_NUM_PASSED, g_dwNumPassed, FALSE);
            SetDlgItemInt(hWnd, IDC_NUM_TOTAL, g_dwNumTotal, FALSE);

            if (g_bBVT) {
                SendMessage(GetDlgItem(g_hWndDlg, IDC_EXIT_BUTTON), BM_CLICK, 0, 0);
            }

            return 0;

        case UM_ITERATION_FAILED:
            // Update the status
            SendMessage(hWnd, UM_UPDATE_STATUS, IDS_STATUS_ITERATION_FAILED, 0);
            SendMessage(hWnd, UM_FAXVRFY_RESET, 0, 0);

            // Update the iterations
            g_dwNumFailed++;
            g_dwNumTotal++;
            SetDlgItemInt(hWnd, IDC_NUM_FAILED, g_dwNumFailed, FALSE);
            SetDlgItemInt(hWnd, IDC_NUM_TOTAL, g_dwNumTotal, FALSE);

            if (g_bBVT) {
                SendMessage(GetDlgItem(g_hWndDlg, IDC_EXIT_BUTTON), BM_CLICK, 0, 0);
            }

            return 0;

        case UM_UPDATE_STATUS:
            dwStyle = TLS_INFO;
            dwLevel = TLS_VARIATION;

            // Get the resource id
            dwResourceId = (DWORD) wParam;

            // Load the event text
            LoadString(g_hInstance, dwResourceId, szFormatString, MAX_STRINGLEN);

            // Set the event text
            lstrcpy(szText, szFormatString);
            szDeviceName = NULL;

            switch (wParam) {
                case IDS_STATUS_ITERATION_PASSED:
                    dwStyle = TLS_PASS;
                    break;

                case IDS_STATUS_ITERATION_FAILED:
                    dwStyle = TLS_SEV2;
                    break;

                case IDS_STATUS_TEST_PASSED:
                    dwStyle = TLS_PASS;
                    dwLevel = TL_TEST;
                    break;

                case IDS_STATUS_RAS_FAILED:
                case IDS_STATUS_TIMEOUT_ENDED:
                case IDS_STATUS_FAX_SEND_FAILED:
                case IDS_STATUS_FAX_INVALID:
                case IDS_TIFF_INVALID_TIFF:
                case IDS_TIFF_INVALID_IMAGEWIDTH:
                case IDS_TIFF_INVALID_IMAGELENGTH:
                case IDS_TIFF_INVALID_COMPRESSION:
                case IDS_TIFF_INVALID_PHOTOMETRIC:
                case IDS_TIFF_INVALID_XRESOLUTION:
                case IDS_TIFF_INVALID_YRESOLUTION:
                case IDS_TIFF_INVALID_SOFTWARE:
                case IDS_TIFF_INVALID_PAGES:
                case IDS_STATUS_FAX_NO_DIAL_TONE_ABORT:
                case IDS_STATUS_FAX_BUSY_ABORT:
                case IDS_STATUS_FAX_NO_ANSWER_ABORT:
                case IDS_STATUS_FAX_FATAL_ERROR_ABORT:
                    dwStyle = TLS_SEV2;
                    break;

                case IDS_STATUS_FAXSVC_ENDED:
                    dwStyle = TLS_SEV2;
                    dwLevel = TL_TEST;
                    break;

                case IDS_STATUS_RAS_SPEED_SUSPECT:
                case IDS_STATUS_FAX_NO_DIAL_TONE_RETRY:
                case IDS_STATUS_FAX_BUSY_RETRY:
                case IDS_STATUS_FAX_NO_ANSWER_RETRY:
                case IDS_STATUS_FAX_FATAL_ERROR_RETRY:
                case IDS_STATUS_FAX_FATAL_ERROR:
                case IDS_STATUS_FAX_ABORTING:
                    dwStyle = TLS_WARN;
                    break;

                case IDS_STATUS_DEVICE_POWERED_OFF:
                case IDS_STATUS_DEVICE_POWERED_ON:
                case IDS_STATUS_PORTS_NOT_AVAILABLE:
                case IDS_STATUS_UNEXPECTED_STATE:
                    dwStyle = TLS_WARN;
                    dwLevel = TL_TEST;
                    break;
            }

            switch (wParam) {
                case IDS_TIFF_INVALID_PAGES:
                    // Set the event text
                    wsprintf(szText, szFormatString, (DWORD) lParam, g_bBVT ? FAXBVT_PAGES : FAXWHQL_PAGES);
                    break;

                case IDS_STATUS_RAS_STARTING:
                case IDS_STATUS_FAX_STARTING:
                    // Set the event text
                    wsprintf(szText, szFormatString, (LPWSTR) lParam);
                    break;

                case IDS_STATUS_RAS_LINESPEED:
                    // Set the event text
                    wsprintf(szText, szFormatString, ((PRAS_INFO) lParam)->dwBps);

                    // Find the device name
                    szDeviceName = ((PRAS_INFO) lParam)->szDeviceName;
                    break;

                case IDS_STATUS_RAS_SPEED_SUSPECT:
                    // Set the exent text
                    wsprintf(szText, szFormatString, (DWORD) lParam);
                    break;

                case IDS_STATUS_RAS_FAILED:
                    // Initialize szRasError
                    ZeroMemory(szRasError, sizeof(szRasError));
                    if (lParam) {
                        g_RasApi.RasGetErrorString((DWORD) lParam, szRasError, sizeof(szRasError) / sizeof(WCHAR));
                    }

                    // Set the event text
                    wsprintf(szText, szFormatString, szRasError);
                    break;

                case IDS_STATUS_FAX_DIALING:
                    // Set the event text
                    wsprintf(szText, szFormatString, ((PFAX_DIALING_INFO) lParam)->dwAttempt);

                    // Find the device name
                    fnFindDeviceName(g_pFaxPortsConfig, g_dwNumPorts, ((PFAX_DIALING_INFO) lParam)->dwDeviceId, &szDeviceName);
                    break;

                case IDS_STATUS_FAX_RECEIVED:
                    // Set the event text
                    wsprintf(szText, szFormatString, ((PFAX_RECEIVE_INFO) lParam)->szCopyTiffName);

                    // Find the device name
                    fnFindDeviceName(g_pFaxPortsConfig, g_dwNumPorts, ((PFAX_RECEIVE_INFO) lParam)->dwDeviceId, &szDeviceName);

                    break;

                case IDS_STATUS_FAX_ID:
                    // Set the event text
                    wsprintf(szText, szFormatString, (LPWSTR) lParam);

                    break;

                case IDS_STATUS_FAX_VERIFYING:
                    // Set the event text
                    wsprintf(szText, szFormatString, (LPWSTR) lParam);
                    break;

                default:
                    // Find the device name
                    fnFindDeviceName(g_pFaxPortsConfig, g_dwNumPorts, (DWORD) lParam, &szDeviceName);
                    break;
            }

            // Indicate only pszText is valid
            lvi.mask = LVIF_TEXT;

            // Set the Event text
            lvi.pszText = szText;
            // Set the item number
            lvi.iItem = ListView_GetItemCount(hWndStatusList);
            // Indicate this is the first column
            lvi.iSubItem = 0;
            // Insert item into Status List
            ListView_InsertItem(hWndStatusList, &lvi);

            // Set the Port text
            lvi.pszText = szDeviceName;
            // Indicate this is the second column
            lvi.iSubItem = 1;
            // Set item in Status List
            ListView_SetItem(hWndStatusList, &lvi);

            if (szDeviceName) {
                DebugMacro(L"%s: %s\n", szDeviceName, szText);
            }
            else {
                DebugMacro(L"%s\n", szText);
            }

            if (szDeviceName) {
                fnWriteLogFile(TRUE, L"%s: %s\r\n", szDeviceName, szText);
            }
            else {
                fnWriteLogFile(TRUE, L"%s\r\n", szText);
            }

            if (g_bNTLogAvailable) {
                if (szDeviceName) {
                    switch (dwLevel) {
                        case TLS_TEST:
                            g_NTLogApi.ptlLog(g_hLogFile, dwStyle | TL_TEST, L"%s: %s\r\n", szDeviceName, szText);
                            break;

                        case TLS_VARIATION:
                            g_NTLogApi.ptlLog(g_hLogFile, dwStyle | TL_VARIATION, L"%s: %s\r\n", szDeviceName, szText);
                            break;
                    }
                }
                else {
                    switch (dwLevel) {
                        case TLS_TEST:
                            g_NTLogApi.ptlLog(g_hLogFile, dwStyle | TL_TEST, L"%s\r\n", szText);
                            break;

                        case TLS_VARIATION:
                            g_NTLogApi.ptlLog(g_hLogFile, dwStyle | TL_VARIATION, L"%s\r\n", szText);
                            break;
                    }
                }
            }

            // Scroll the Status List
            ListView_EnsureVisible(hWndStatusList, lvi.iItem, FALSE);
            return 0;

        case WM_SETFOCUS:
            // Verify correct control has the focus
            if ((!IsWindowEnabled(GetDlgItem(hWnd, IDC_STOP_BUTTON))) && (SendMessage(GetDlgItem(hWnd, IDC_STOP_BUTTON), WM_GETDLGCODE, 0, 0) & DLGC_DEFPUSHBUTTON)) {
                // Set the focus to the start button
                SendMessage(hWnd, WM_NEXTDLGCTL, (WPARAM) GetDlgItem(hWnd, IDC_START_BUTTON), MAKELONG(TRUE, 0));
            }

            break;

        case WM_CLOSE:
            if (IsWindowEnabled(GetDlgItem(hWnd, IDC_EXIT_BUTTON))) {
                // Signal the Exit event
                SetEvent(g_hExitEvent);
                // Post a completion packet to a completion port to exit the Fax Event Queue thread
                fnPostExitToCompletionPort(g_hCompletionPort);
                // Close the application
                DestroyWindow(hWnd);
                PostQuitMessage(0);
            }
            return 0;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDM_SEND:
                    if (!g_bSend) {
                        g_bSend = TRUE;
                        CheckMenuItem(GetMenu(hWnd), IDM_SEND, MF_BYCOMMAND | MF_CHECKED);
                        CheckMenuItem(GetMenu(hWnd), IDM_RECEIVE, MF_BYCOMMAND | MF_UNCHECKED);
                        SendMessage(hWnd, UM_FAXVRFY_RESET, 0, 0);
                    }
                    return 0;

                case IDM_RECEIVE:
                    if (g_bSend) {
                        g_bSend = FALSE;
                        CheckMenuItem(GetMenu(hWnd), IDM_SEND, MF_BYCOMMAND | MF_UNCHECKED);
                        CheckMenuItem(GetMenu(hWnd), IDM_RECEIVE, MF_BYCOMMAND | MF_CHECKED);
                        SendMessage(hWnd, UM_FAXVRFY_RESET, 0, 0);
                    }
                    return 0;

                case IDM_HELP:
                    fnUsageInfo(hWnd);
                    return 0;

                case IDC_SEND_NUMBER:
                    if (HIWORD(wParam) == EN_CHANGE) {
                        if (!fnIsEditControlASCII(hWnd, IDC_SEND_NUMBER, PHONE_NUM_LEN + 1)) {
                            // Load the error text
                            LoadString(g_hInstance, IDS_ASCII_SEND_NUMBER, szText, MAX_STRINGLEN);
                            // Display the pop-up
                            MessageBox(hWnd, szText, FAXVRFY_NAME, MB_OK | MB_ICONERROR);

                            SetDlgItemText(hWnd, IDC_SEND_NUMBER, g_szSndNumber);
                        }

                        GetDlgItemText(hWnd, IDC_SEND_NUMBER, g_szSndNumber, PHONE_NUM_LEN + 1);
                    }
                    return 0;

                case IDC_RECEIVE_NUMBER:
                    if (HIWORD(wParam) == EN_CHANGE) {
                        if (!fnIsEditControlASCII(hWnd, IDC_RECEIVE_NUMBER, PHONE_NUM_LEN + 1)) {
                            // Load the error text
                            LoadString(g_hInstance, IDS_ASCII_RECEIVE_NUMBER, szText, MAX_STRINGLEN);
                            // Display the pop-up
                            MessageBox(hWnd, szText, FAXVRFY_NAME, MB_OK | MB_ICONERROR);

                            SetDlgItemText(hWnd, IDC_RECEIVE_NUMBER, g_szRcvNumber);
                        }

                        GetDlgItemText(hWnd, IDC_RECEIVE_NUMBER, g_szRcvNumber, PHONE_NUM_LEN + 1);
                    }
                    return 0;

                case IDC_RAS_ENABLED_BUTTON:
                    // RAS Enabled Check Box was clicked
                    g_bRasEnabled = IsDlgButtonChecked(hWnd, IDC_RAS_ENABLED_BUTTON);
                    // Enable or disable the RAS specific controls
                    EnableWindow(GetDlgItem(hWnd, IDC_RAS_USER_NAME_STATIC), g_bRasEnabled ? TRUE : FALSE);
                    EnableWindow(GetDlgItem(hWnd, IDC_RAS_USER_NAME), g_bRasEnabled ? TRUE : FALSE);
                    EnableWindow(GetDlgItem(hWnd, IDC_RAS_PASSWORD_STATIC), g_bRasEnabled ? TRUE : FALSE);
                    EnableWindow(GetDlgItem(hWnd, IDC_RAS_PASSWORD), g_bRasEnabled ? TRUE : FALSE);
                    EnableWindow(GetDlgItem(hWnd, IDC_RAS_DOMAIN_STATIC), g_bRasEnabled ? TRUE : FALSE);
                    EnableWindow(GetDlgItem(hWnd, IDC_RAS_DOMAIN), g_bRasEnabled ? TRUE : FALSE);
                    return 0;

                case IDC_START_BUTTON:
                    if (g_bSend) {
                        // Initialize szMissingInfoError
                        ZeroMemory(szMissingInfoError, sizeof(szMissingInfoError));

                        // Get send phone number
                        GetDlgItemText(hWnd, IDC_SEND_NUMBER, g_szSndNumber, PHONE_NUM_LEN + 1);
                        // Get receive phone number
                        GetDlgItemText(hWnd, IDC_RECEIVE_NUMBER, g_szRcvNumber, PHONE_NUM_LEN + 1);

                        // See if RAS is enabled
                        g_bRasEnabled = IsDlgButtonChecked(hWnd, IDC_RAS_ENABLED_BUTTON);
                        // Get RAS user name
                        GetDlgItemText(hWnd, IDC_RAS_USER_NAME, g_szRasUserName, UNLEN + 1);
                        // Get RAS password
                        GetDlgItemText(hWnd, IDC_RAS_PASSWORD, g_szRasPassword, PWLEN + 1);
                        // Get RAS domain
                        GetDlgItemText(hWnd, IDC_RAS_DOMAIN, g_szRasDomain, DNLEN + 1);

                        if (!lstrlen(g_szSndNumber)) {
                            // There is no send phone number
                            LoadString(g_hInstance, IDS_MISSING_INFO, szMissingInfoError, MAX_STRINGLEN);
                            LoadString(g_hInstance, IDS_NO_SEND_NUMBER, szMissingInfo, MAX_STRINGLEN);
                            lstrcat(szMissingInfoError, szMissingInfo);
                        }

                        if (!lstrlen(g_szRcvNumber)) {
                            // There is no receive phone number
                            if (lstrlen(szMissingInfoError)) {
                                lstrcat(szMissingInfoError, L"\n");
                            }
                            else {
                                LoadString(g_hInstance, IDS_MISSING_INFO, szMissingInfoError, MAX_STRINGLEN);
                            }
                            LoadString(g_hInstance, IDS_NO_RECEIVE_NUMBER, szMissingInfo, MAX_STRINGLEN);
                            lstrcat(szMissingInfoError, szMissingInfo);
                        }

                        if (g_bRasEnabled) {
                            if (!lstrlen(g_szRasUserName)) {
                                // There is no RAS user name
                                if (lstrlen(szMissingInfoError)) {
                                    lstrcat(szMissingInfoError, L"\n");
                                }
                                else {
                                    LoadString(g_hInstance, IDS_MISSING_INFO, szMissingInfoError, MAX_STRINGLEN);
                                }
                                LoadString(g_hInstance, IDS_NO_RAS_USER_NAME, szMissingInfo, MAX_STRINGLEN);
                                lstrcat(szMissingInfoError, szMissingInfo);
                            }

                            if (!lstrlen(g_szRasDomain)) {
                                // There is no RAS domain
                                if (lstrlen(szMissingInfoError)) {
                                    lstrcat(szMissingInfoError, L"\n");
                                }
                                else {
                                    LoadString(g_hInstance, IDS_MISSING_INFO, szMissingInfoError, MAX_STRINGLEN);
                                }
                                LoadString(g_hInstance, IDS_NO_RAS_DOMAIN, szMissingInfo, MAX_STRINGLEN);
                                lstrcat(szMissingInfoError, szMissingInfo);
                            }
                        }

                        if (lstrlen(szMissingInfoError)) {
                            // Display the missing info error pop-up
                            MessageBox(hWnd, szMissingInfoError, FAXVRFY_NAME, MB_OK | MB_ICONERROR);
                            return 0;
                        }

                        // Disable the Fax specific controls
                        EnableWindow(GetDlgItem(hWnd, IDC_SEND_NUMBER_STATIC), FALSE);
                        EnableWindow(GetDlgItem(hWnd, IDC_SEND_NUMBER), FALSE);
                        EnableWindow(GetDlgItem(hWnd, IDC_RECEIVE_NUMBER), FALSE);
                        EnableWindow(GetDlgItem(hWnd, IDC_RECEIVE_NUMBER_STATIC), FALSE);

                        // Disable the RAS specific controls
                        EnableWindow(GetDlgItem(hWnd, IDC_RAS_ENABLED_BUTTON), FALSE);
                        EnableWindow(GetDlgItem(hWnd, IDC_RAS_USER_NAME_STATIC), FALSE);
                        EnableWindow(GetDlgItem(hWnd, IDC_RAS_USER_NAME), FALSE);
                        EnableWindow(GetDlgItem(hWnd, IDC_RAS_PASSWORD_STATIC), FALSE);
                        EnableWindow(GetDlgItem(hWnd, IDC_RAS_PASSWORD), FALSE);
                        EnableWindow(GetDlgItem(hWnd, IDC_RAS_DOMAIN_STATIC), FALSE);
                        EnableWindow(GetDlgItem(hWnd, IDC_RAS_DOMAIN), FALSE);

                        // Set the strings to the ini file
                        WritePrivateProfileString(L"Fax", L"SendNumber", g_szSndNumber, szIniFile);
                        WritePrivateProfileString(L"Fax", L"ReceiveNumber", g_szRcvNumber, szIniFile);
                        WritePrivateProfileString(L"RAS", L"Enabled", g_bRasEnabled ? L"1" : L"0", szIniFile);
                        WritePrivateProfileString(L"RAS", L"UserName", g_szRasUserName, szIniFile);
                        WritePrivateProfileString(L"RAS", L"Domain", g_szRasDomain, szIniFile);
                    }

                    // Disable the Option Menu
                    EnableMenuItem(GetMenu(hWnd), IDM_SEND, MF_BYCOMMAND | MF_GRAYED);
                    EnableMenuItem(GetMenu(hWnd), IDM_RECEIVE, MF_BYCOMMAND | MF_GRAYED);

                    // Disable the Start Button
                    EnableWindow(GetDlgItem(hWnd, IDC_START_BUTTON), FALSE);
                    // Enable the Stop Button
                    EnableWindow(GetDlgItem(hWnd, IDC_STOP_BUTTON), TRUE);
                    // Disable the Exit Button
                    EnableWindow(GetDlgItem(hWnd, IDC_EXIT_BUTTON), FALSE);

                    // Set the focus to the Stop button
                    SendMessage(hWnd, WM_NEXTDLGCTL, (WPARAM) GetDlgItem(hWnd, IDC_STOP_BUTTON), MAKELONG(TRUE, 0));

                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_ITERATION_STARTED, 0);

                    // Signal the Start event
                    SetEvent(g_hStartEvent);
                    return 0;

                case IDC_STOP_BUTTON:
                    // Signal the Stop event
                    SetEvent(g_hStopEvent);
                    return 0;

                case IDC_EXIT_BUTTON:
                    SendMessage(hWnd, WM_CLOSE, 0, 0);
                    return 0;
            }
    }

    return DefDlgProc(hWnd, iMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\test\faxvrfy\faxvrfy.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  faxvrfy.h

Abstract:

  This module contains the global definitions

Author:

  Steven Kehrli (steveke) 11/15/1997

--*/

#ifndef _FAXVRFY_H
#define _FAXVRFY_H

#include "ntlog.h"
#include <ras.h>

// FAXVRFY_NAME is the name of the FaxVrfy application
#define FAXVRFY_NAME            L"FaxVrfy"

// FAXVRFY_HLP is the name of the FaxVrfy help file
#define FAXVRFY_HLP             L"faxvrfy.hlp"

// FAXRCV_DLL is the name of the FaxRcv dll
#define FAXRCV_DLL              L"faxrcv.dll"

// FAXVRFY_LOG is the name of the FaxVrfy log file
#define FAXVRFY_LOG             L"faxvrfy.log"
// FAXVRFY_TXT is the name of the FaxVrfy text file
#define FAXVRFY_TXT             L"faxvrfy.txt"

// FAXVRFY_INI is the name of the FaxVrfy ini
#define FAXVRFY_INI             L"faxvrfy.ini"

// FAXBVT_TIF is the name of the tif file for the BVT test
#define FAXBVT_TIF              L"faxbvt.tif"
// FAXWHQL_TIF is the name of the tif file for the WHQL test
#define FAXWHQL_TIF             L"faxwhql.tif"

// FAXVRFY_CMD_HELP is the help command line parameter
#define FAXVRFY_CMD_HELP_1      L"/?"
#define FAXVRFY_CMD_HELP_2      L"/h"
#define FAXVRFY_CMD_HELP_3      L"-?"
#define FAXVRFY_CMD_HELP_4      L"-h"
// FAXVRFY_CMD_BVT is the BVT command line parameter
#define FAXVRFY_CMD_BVT_1       L"/bvt"
#define FAXVRFY_CMD_BVT_2       L"-bvt"
// FAXVRFY_CMD_SEND is the send command line parameter
#define FAXVRFY_CMD_SEND_1      L"/s"
#define FAXVRFY_CMD_SEND_2      L"-s"
// FAXVRFY_CMD_RECEIVE is the receive command line parameter
#define FAXVRFY_CMD_RECEIVE_1   L"/r"
#define FAXVRFY_CMD_RECEIVE_2   L"-r"
// FAXVRFY_CMD_GO is the go command line parameter
#define FAXVRFY_CMD_GO_1        L"/g"
#define FAXVRFY_CMD_GO_2        L"-g"
// FAXVRFY_CMD_NO_CHECK is the no check command line parameter
#define FAXVRFY_CMD_NO_CHECK_1  L"/x"
#define FAXVRFY_CMD_NO_CHECK_2  L"-x"

// ENCODE_CHAR_LEN is the text length limit of the encoding character.
#define ENCODE_CHAR_LEN         1
// CONTROL_CHAR_LEN is the text length limit of the control characters.
#define CONTROL_CHAR_LEN        2
// PHONE_NUM_LEN is the text length limit of phone number edit controls.  The length of 17 corresponds to the TSID limit for the fax service (20) minus 3 characters for encoding
#define PHONE_NUM_LEN           17

// TX_CONTROL_CHARS are the control characters when sending
#define TX_CONTROL_CHARS        L"TX"
// RX_CONTROL_CHARS are the control characters when receiving
#define RX_CONTROL_CHARS        L"RX"

// FAXSVC_RETRIES is the number of retries
#define FAXSVC_RETRIES          2
// FAXSVC_RETRYDELAY is the retry delay
#define FAXSVC_RETRYDELAY       3

// FAXBVT_PAGES is the number of pages in the BVT fax
#define FAXBVT_PAGES            1
// FAXWHQL_PAGES is the number of pages in the WHQL fax
#define FAXWHQL_PAGES           5
// FAXBVT_NUM_FAXES is the number of faxes to send for BVT
#define FAXBVT_NUM_FAXES        1
// FAXWHQL_NUM_FAXES is the number of faxes to send for WHQL
#define FAXWHQL_NUM_FAXES       2

// UM_FAXVRFY_INITIALIZE is the message to initialize the application window
#define UM_FAXVRFY_INITIALIZE   (WM_USER + 1)
// UM_FAXVRFY_UPDATE is the message to update the test
#define UM_FAXVRFY_UPDATE       (WM_USER + 2)
// UM_FAXVRFY_RESET is the message to reset the test
#define UM_FAXVRFY_RESET        (WM_USER + 3)
// UM_TIMEOUT_ENDED is the message to indicate the timeout ended
#define UM_TIMEOUT_ENDED        (WM_USER + 4)
// UM_FAXSVC_ENDED is the message to indicate the fax service stopped
#define UM_FAXSVC_ENDED         (WM_USER + 5)
// UM_ITERATION_STOPPED is the message to indicate the iteration stopped
#define UM_ITERATION_STOPPED    (WM_USER + 6)
// UM_ITERATION_PASSED is the message to indicate the iteration passed
#define UM_ITERATION_PASSED     (WM_USER + 7)
// UM_ITERATION_FAILED is the message to indicate the iteration failed
#define UM_ITERATION_FAILED     (WM_USER + 8)

// UM_UPDATE_STATUS is a message to update the Status List
#define UM_UPDATE_STATUS        (WM_USER + 11)

HWND                g_hWndDlg;                          // g_hWndDlg is the handle to the Setup Dialog

HANDLE              g_hLogFile = NULL;                  // g_hLogFile is the handle to the log file
HANDLE              g_hTxtFile = INVALID_HANDLE_VALUE;  // g_hLogFile is the handle to the text file

BOOL                g_bBVT = FALSE;                     // g_bBVT indicates BVT command line parameter
BOOL                g_bSend = FALSE;                    // g_bSend indicates send command line parameter
BOOL                g_bGo = FALSE;                      // g_bGo indicates go command line parameter
BOOL                g_bNoCheck = FALSE;                 // g_bNoCheck indicates no check command line parameter

HANDLE              g_hStartEvent;                      // g_hStartEvent is the handle to the Start event
HANDLE              g_hStopEvent;                       // g_hStopEvent is the handle to the Stop event
HANDLE              g_hFaxEvent;                        // g_hFaxEvent is the handle to the event to indicate the Fax Service stopped
HANDLE              g_hExitEvent;                       // g_hExitEvent is the handle to the Exit event

HANDLE              g_hRasPassedEvent;                  // g_hRasPassedEvent is the handle to the RAS Passed event
HANDLE              g_hRasFailedEvent;                  // g_hRasFailedEvent is the handle to the RAS Failed event
HANDLE              g_hSendPassedEvent;                 // g_hSendPassedEvent is the handle to the Send Passed event
HANDLE              g_hSendFailedEvent;                 // g_hSendFailedEvent is the handle to the Send Failed event

HANDLE              g_hFaxSvcHandle;                    // g_hFaxSvcHandle is the handle to the Fax Service
PFAX_PORT_INFO      g_pFaxPortsConfig;                  // g_pFaxPorts is the pointer to the Fax Ports Configuration
DWORD               g_dwNumPorts;                       // g_dwNumPorts is the number of Ports
DWORD               g_dwNumAvailPorts;                  // g_dwNumAvailPorts is the number of Available Ports
PFAX_CONFIGURATION  g_pFaxSvcConfig;                    // g_pFaxConfig is the pointer to the Fax Service Configuration

BOOL                g_bFaxSndInProgress = FALSE;        // g_bFaxSndInProgress indicates if a fax send is in progress
DWORD               g_dwFaxId = 0;                      // g_dwFaxId is the fax job id of the fax
DWORD               g_dwAttempt = 0;                    // g_dwAttempt is the attempt number of the fax
BOOL                g_bFaxRcvInProgress = FALSE;        // g_bFaxRcvInProgress indicates if a fax receive is in progress

HANDLE              g_hCompletionPort;                  // g_hCompletionPort is the handle to the completion port

BOOL                g_bTestFailed = FALSE;              // g_bTestFailed indicates the test failed
DWORD               g_dwNumPassed = 0;                  // g_dwNumPassed is the number of passed iterations
DWORD               g_dwNumFailed = 0;                  // g_dwNumFailed is the number of failed iterations
DWORD               g_dwNumTotal = 0;                   // g_dwNumTotal is the number of total iterations

WCHAR               g_szSndNumber[PHONE_NUM_LEN + 1];   // g_szSndNumber is the send phone number
WCHAR               g_szRcvNumber[PHONE_NUM_LEN + 1];   // g_szRcvNumber is the receive phone number
WCHAR               g_szRasUserName[UNLEN + 1];         // g_szRasUserName is the RAS user name
WCHAR               g_szRasPassword[PWLEN + 1];         // g_szRasPassword is the RAS password
WCHAR               g_szRasDomain[DNLEN + 1];           // g_szRasDomain is the RAS domain

BOOL                g_bNTLogAvailable = FALSE;          // g_bNTLogAvailable indicates if NTLog is available

BOOL                g_bRasAvailable = FALSE;            // g_bRasAvailable indicates if RAS is available
BOOL                g_bRasEnabled = FALSE;              // g_bRasEnables indicates if RAS is enabled

#define FAXDEVICES_REGKEY       L"Software\\Microsoft\\Fax\\Devices"
#define MODEM_REGKEY            L"\\Modem"
#define FIXMODEMCLASS_REGVALUE  L"FixModemClass"

// FAX_DIALING_INFO is a structure that is the fax dialing info
typedef struct _FAX_DIALING_INFO {
    DWORD  dwAttempt;        // Attempt number
    DWORD  dwDeviceId;       // Device id
} FAX_DIALING_INFO, *PFAX_DIALING_INFO;

// FAX_RECEIVE_INFO is a structure that is the fax receive info
typedef struct _FAX_RECEIVE_INFO {
    LPWSTR  szCopyTiffName;  // Attempt number
    DWORD   dwDeviceId;      // Device id
} FAX_RECEIVE_INFO, *PFAX_RECEIVE_INFO;

// NTLOG_DLL is the name of the dll that contains all of the NTLOG API's
#define NTLOG_DLL  L"ntlog.dll"

// NTLOG_API is a structure that points to the NTLOG API's
typedef struct _NTLOG_API {
    HINSTANCE             hInstance;             // Handle to the instance of the dll
    PTLCREATELOG          ptlCreateLog;          // tlCreateLog
    PTLDESTROYLOG         ptlDestroyLog;         // tlDestroyLog
    PTLADDPARTICIPANT     ptlAddParticipant;     // tlAddParticipant
    PTLREMOVEPARTICIPANT  ptlRemoveParticipant;  // tlRemoveParticipant
    PTLLOG                ptlLog;                // tlLog
} NTLOG_API, *PNTLOG_API;

// g_NTLogApi is the global NTLOG_API object
NTLOG_API  g_NTLogApi;

// RASAPI32_DLL is the name of the dll that contains all of the RAS API's
#define RASAPI32_DLL  L"\\rasapi32.dll"

// RAS_API is a structure that points to the RAS API's
typedef struct _RAS_API {
    HINSTANCE  hInstance;                   // Handle to the instance of the dll
    FARPROC    RasDial;                     // RasDial
    FARPROC    RasGetErrorString;           // RasGetErrorString
    FARPROC    RasGetConnectStatus;         // RasGetConnectStatus
    FARPROC    RasGetConnectionStatistics;  // RasGetConnectionStatistics
    FARPROC    RasHangUp;                   // RasHangUp
} RAS_API, *PRAS_API;

// g_RasApi is the global RAS_API object
RAS_API  g_RasApi;

// RAS_INFO is a structure that is the RAS connection info
typedef struct _RAS_INFO {
    DWORD   dwBps;         // Connection speed
    LPWSTR  szDeviceName;  // Device name
} RAS_INFO, *PRAS_INFO;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\test\faxrcv\faxrcv.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  faxrcv.h

Abstract:

  This module contains the global definitions

Author:

  Steven Kehrli (steveke) 11/15/1997

--*/

#ifndef _FAXRCV_H
#define _FAXRCV_H

// FAXRCV_EXT_REGKEY is the FaxRcv Extension Registry key
#define FAXRCV_EXT_REGKEY            L"SOFTWARE\\Microsoft\\Fax\\Routing Extensions\\FaxRcv Routing Extension"
// BENABLE_EXT_REGVAL is the FaxRcv Extension bEnable Registry value
#define BENABLE_EXT_REGVAL           L"bEnable"
// BENABLE_EXT_REGDATA is the FaxRcv Extension bEnable Registry data
#define BENABLE_EXT_REGDATA          0
// FRIENDLYNAME_EXT_REGVAL is the FaxRcv Extension FriendlyName Registry value
#define FRIENDLYNAME_EXT_REGVAL      L"FriendlyName"
// FRIENDLYNAME_EXT_REGDATA is the FaxRcv Extension FriendlyName Registry data
#define FRIENDLYNAME_EXT_REGDATA     L"FaxRcv Routing Extension"
// IMAGENAME_EXT_REGVAL is the FaxRcv Extension ImageName Registry value
#define IMAGENAME_EXT_REGVAL         L"ImageName"
// IMAGENAME_EXT_REGDATA is the FaxRcv Extension ImageName Registry data
#define IMAGENAME_EXT_REGDATA        L"%SystemRoot%\\system32\\faxrcv.dll"
// ROUTINGMETHODS_REGKEY is the FaxRcv Routing Methods Registry key
#define ROUTINGMETHODS_REGKEY        L"Routing Methods"
// FAXRCV_METHOD_REGKEY is the FaxRcv Method Registry key
#define FAXRCV_METHOD_REGKEY         L"FaxRcv"
// FRIENDLYNAME_METHOD_REGVAL is the FaxRcv Method FriendlyName Registry value
#define FRIENDLYNAME_METHOD_REGVAL   L"FriendlyName"
// FRIENDLYNAME_METHOD_REGDATA is the FaxRcv Method FriendlyName Registry data
#define FRIENDLYNAME_METHOD_REGDATA  L"FaxRcv"
// FUNCTIONNAME_METHOD_REGVAL is the FaxRcv Method FunctionName Registry value
#define FUNCTIONNAME_METHOD_REGVAL   L"Function Name"
// FUNCTIONNAME_METHOD_REGDATA is the FaxRcv Method FunctionName Registry data
#define FUNCTIONNAME_METHOD_REGDATA  L"FaxRcv"
// GUID_METHOD_REGVAL is the FaxRcv Method Guid Registry value
#define GUID_METHOD_REGVAL           L"Guid"
// GUID_METHOD_REGDATA is the FaxRcv Method Guid Registry data
#define GUID_METHOD_REGDATA          L"{5800F650-B6B7-11D0-8CDB-00C04FB6BCE9}"
// PRIORITY_METHOD_REGVAL is the FaxRcv Method Priority Registry value
#define PRIORITY_METHOD_REGVAL       L"Priority"
// PRIORITY_METHOD_REGDATA is the FaxRcv Method Priority Registry data
#define PRIORITY_METHOD_REGDATA      5

// FAXRCV_EVENT is the name of the FaxRcv named event
#define FAXRCV_EVENT  L"FaxRcvEvent"
// FAXRCV_MUTEXT is the name of the FaxRcv named mutex
#define FAXRCV_MUTEX  L"FaxRcvMutex"
// FAXRCV_MAP is the name of the FaxRcv named memory map
#define FAXRCV_MAP    L"FaxRcvMap"

HANDLE  g_hFaxRcvEvent = NULL;  // g_hFaxRcvEvent is the handle to the FaxRcv named event
HANDLE  g_hFaxRcvMutex = NULL;  // g_hFaxRcvMutex is the handle to the FaxRcv named mutex

HANDLE  g_hFaxRcvMap = NULL;    // g_hFaxRcvMap is the handle to the FaxRcv memory map
LPBYTE  g_pFaxRcvView = NULL;   // g_pFaxRcvView is the pointer to the FaxRcv memory map view

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\test\faxrcv\faxrcv.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  faxrcv.c

Abstract:

  Window NT Fax Routing Extension.  This routing method signals a named event.

Author:

  Steven Kehrli (steveke) 11/15/1997

--*/

#include <windows.h>
#include <stdlib.h>
#include <winfax.h>
#include <faxroute.h>

#include "faxrcv.h"

PFAXROUTEGETFILE  g_pFaxRouteGetFile;  // g_pFaxRouteGetFile is the pointer to callback to get file from fax file list

DWORD
DllEntry(
    HINSTANCE  hInstance,
    DWORD      dwReason,
    LPVOID     pContext
)
/*++

Routine Description:

  DLL entry point

Arguments:

  hInstance - handle to the module
  dwReason - indicates the reason for being called
  pContext - context

Return Value:

  TRUE on success

--*/
{
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            if (!g_hFaxRcvEvent) {
                // Create FaxRcv named event
                g_hFaxRcvEvent = CreateEvent(NULL, FALSE, FALSE, FAXRCV_EVENT);
            }

            if (!g_hFaxRcvMutex) {
                // Create FaxRcv named mutex
                g_hFaxRcvMutex = CreateMutex(NULL, FALSE, FAXRCV_MUTEX);
            }

            break;

        case DLL_PROCESS_DETACH:
            if (g_hFaxRcvMutex) {
                // Wait for access to the FaxRcv named mutex
                WaitForSingleObject(g_hFaxRcvMutex, INFINITE);

                // Reset FaxRcv named event
                ResetEvent(g_hFaxRcvEvent);

                // Close FaxRcv named event
                CloseHandle(g_hFaxRcvEvent);
                g_hFaxRcvEvent = NULL;

                if (g_pFaxRcvView) {
                    // Delete szCopyTiffFile
                    DeleteFile((LPWSTR) g_pFaxRcvView);
                    // Close FaxRcv memory map view
                    UnmapViewOfFile(g_pFaxRcvView);
                    g_pFaxRcvView = NULL;
                }

                if (g_hFaxRcvMap) {
                    // Close FaxRcv memory map
                    CloseHandle(g_hFaxRcvMap);
                    g_hFaxRcvMap = NULL;
                }

                // Release access to the FaxRcv named mutex
                ReleaseMutex(g_hFaxRcvMutex);

                // Close FaxRcv named mutex
                CloseHandle(g_hFaxRcvMutex);
                g_hFaxRcvMutex = NULL;
            }

            break;
    }

    return TRUE;
}

BOOL WINAPI
FaxRouteInitialize(
    HANDLE                       hHeap,
    PFAX_ROUTE_CALLBACKROUTINES  pFaxRouteCallbackRoutines
)
/*++

Routine Description:

  Initializes the routing extension

Arguments:

  hHeap - handle to the heap
  pFaxRouteCallbackRoutins - pointer to fax routing callback routines

Return Value:

  TRUE on success

--*/
{
    // Set g_pFaxRouteGetFile
    g_pFaxRouteGetFile = pFaxRouteCallbackRoutines->FaxRouteGetFile;

    return TRUE;
}

BOOL WINAPI
FaxRouteGetRoutingInfo(
    LPCWSTR  RoutingGuid,
    DWORD    dwDeviceId,
    LPBYTE   RoutingInfo,
    LPDWORD  pdwRoutingInfoSize
)
/*++

Routine Description:

  Gets the routing info for a routing method

Arguments:

  RoutingGuid - pointer to the GUID of the routing method
  dwDeviceId - port id
  RoutingInfo - pointer to the routing info
  pdwRoutingInfoSize - pointer to the size of the routing info

Return Value:

  TRUE on success

--*/
{
    return TRUE;
}

BOOL WINAPI
FaxRouteSetRoutingInfo(
    LPCWSTR     RoutingGuid,
    DWORD       dwDeviceId,
    BYTE const  *RoutingInfo,
    DWORD       dwRoutingInfoSize
)
/*++

Routine Description:

  Sets the routing info for a routing method

Arguments:

  RoutingGuid - pointer to the GUID of the routing method
  dwDeviceId - port id
  RoutingInfo - pointer to the routing info
  dwRoutingInfoSize - size of the routing info

Return Value:

  TRUE on success

--*/
{
    return TRUE;
}

BOOL WINAPI
FaxRouteDeviceEnable(
    LPCWSTR  RoutingGuid,
    DWORD    dwDeviceId,
    LONG     bEnable
)
/*++

Routine Description:

  Enables a routing method

Arguments:

  RoutingGuid - pointer to the GUID of the routing method
  dwDeviceId - port id
  bEnable - indicates whether the routing method is enabled or disabled

Return Value:

  TRUE on success

--*/
{
    return TRUE;
}

BOOL WINAPI
FaxRouteDeviceChangeNotification(
    DWORD  dwDeviceId,
    BOOL   bNewDevice
)
/*++

Routine Description:

  Handles a device change

Arguments:

  dwDeviceId - port id
  bNewDevice - indicates whether the device is new

Return Value:

  TRUE on success

--*/
{
    return TRUE;
}

BOOL WINAPI
FaxRcv(
    PFAX_ROUTE  pFaxRoute,
    PVOID       *FailureData,
    LPDWORD     pdwFailureDataSize
)
/*++

Routine Description:

  Routing method.  This routing method signals a named event.

Arguments:

  pFaxRoute - pointer to the fax routing structure
  FailureData - pointer to the failure data
  pdwFailureDataSize - size of the failure data

Return Value:

  TRUE on success

--*/
{
    // hFaxRcvExtKey is the handle to the FaxRcv Extension Registry key
    HKEY      hFaxRcvExtKey;
    // bEnable indicates whether the Routing method is enabled
    BOOL      bEnable;

    // szTiffFile is the name of the received fax
    WCHAR     szTiffFile[_MAX_PATH];
    // szCopyTiffFile is the name of the copy of the received fax
    WCHAR     szCopyTiffFile[_MAX_PATH];

    // szDrive is the drive of the received fax
    WCHAR     szDrive[_MAX_DRIVE];
    // szDir is the dir of the received fax
    WCHAR     szDir[_MAX_DIR];
    // szFile is the name of the received fax
    WCHAR     szFile[_MAX_FNAME];
    // szExt is the extension of the received fax
    WCHAR     szExt[_MAX_EXT];

    UINT_PTR  upOffset;
    DWORD     cb;

    // Wait for access to the FaxRcv named mutex
    WaitForSingleObject(g_hFaxRcvMutex, INFINITE);

    // Open the FaxRcv Extension Registry key
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, FAXRCV_EXT_REGKEY, 0, KEY_ALL_ACCESS, &hFaxRcvExtKey) != ERROR_SUCCESS) {
        // Release access to the FaxRcv named mutex
        ReleaseMutex(g_hFaxRcvMutex);
        return TRUE;
    }

    // Set cb
    cb = sizeof(BOOL);
    // Query the FaxRcv Extension bEnable Registry value
    if (RegQueryValueEx(hFaxRcvExtKey, BENABLE_EXT_REGVAL, NULL, NULL, (LPBYTE) &bEnable, &cb) != ERROR_SUCCESS) {
        // Close the FaxRcv Extension Registry key
        RegCloseKey(hFaxRcvExtKey);
        // Release access to the FaxRcv named mutex
        ReleaseMutex(g_hFaxRcvMutex);
        return TRUE;
    }

    // Close the FaxRcv Extension Registry key
    RegCloseKey(hFaxRcvExtKey);

    if (!bEnable) {
        // Release access to the FaxRcv named mutex
        ReleaseMutex(g_hFaxRcvMutex);
        return TRUE;
    }

    // Set cb
    cb = sizeof(szTiffFile);
    // Initialize szTiffFile
    ZeroMemory(szTiffFile, cb);

    // Get the file
    if (!g_pFaxRouteGetFile(pFaxRoute->JobId, 1, szTiffFile, &cb)) {
        // Release access to the FaxRcv named mutex
        ReleaseMutex(g_hFaxRcvMutex);
        return FALSE;
    }

    // Initialize szDrive
    ZeroMemory(szDrive, sizeof(szDrive));
    // Initialize szDir
    ZeroMemory(szDir, sizeof(szDir));
    // Initialize szFile
    ZeroMemory(szFile, sizeof(szFile));
    // Initialize szExt
    ZeroMemory(szExt, sizeof(szExt));

    _wsplitpath(szTiffFile, szDrive, szDir, szFile, szExt);

    // Initialize szCopyTiffFile
    ZeroMemory(szCopyTiffFile, sizeof(szCopyTiffFile));
    // Set szCopyTiffFile
    wsprintf(szCopyTiffFile, L"%s%s%s%s%s", szDrive, szDir, L"Copy of ", szFile, szExt);

    // Copy szTiffFile to szCopyTiffFile
    CopyFile(szTiffFile, szCopyTiffFile, FALSE);

    // Determine the memory required by FaxRcv memory map
    cb = (lstrlen(szCopyTiffFile) + 1) * sizeof(WCHAR);
    cb += (lstrlen(pFaxRoute->Tsid) + 1) * sizeof(WCHAR);
    cb += sizeof(DWORD);

    if (g_pFaxRcvView) {
        // Delete szCopyTiffFile
        DeleteFile((LPWSTR) g_pFaxRcvView);
        // Close FaxRcv memory map view
        UnmapViewOfFile(g_pFaxRcvView);
    }
    if (g_hFaxRcvMap) {
        // Close FaxRcv memory map
        CloseHandle(g_hFaxRcvMap);
    }

    // Create FaxRcv memory map
    g_hFaxRcvMap = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, cb, FAXRCV_MAP);
    // Create FaxRcv memory map view
    g_pFaxRcvView = (LPBYTE) MapViewOfFile(g_hFaxRcvMap, FILE_MAP_WRITE, 0, 0, 0);

    // Set upOffset
    upOffset = 0;

    // Set szCopyTiffFile
    lstrcpy((LPWSTR) ((UINT_PTR) g_pFaxRcvView + upOffset), szCopyTiffFile);
    upOffset += (lstrlen(szCopyTiffFile) + 1) * sizeof(WCHAR);

    // Set Tsid
    lstrcpy((LPWSTR) ((UINT_PTR) g_pFaxRcvView + upOffset), pFaxRoute->Tsid);
    upOffset += (lstrlen(pFaxRoute->Tsid) + 1) * sizeof(WCHAR);

    // Set DeviceId
    CopyMemory((LPDWORD) ((UINT_PTR) g_pFaxRcvView + upOffset), &pFaxRoute->DeviceId, sizeof(DWORD));

    // Signal FaxRcv named event
    SetEvent(g_hFaxRcvEvent);

    // Release access to the FaxRcv named mutex
    ReleaseMutex(g_hFaxRcvMutex);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\test\faxvrfy\macros.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  macros.h

Abstract:

  This module contains the global macros

Author:

  Steven Kehrli (steveke) 11/15/1997

--*/

#ifndef _MACROS_H
#define _MACROS_H

HINSTANCE  g_hInstance = NULL;   // g_hInstance is the handle to the instance
HANDLE     hProcessHeap = NULL;  // hProcessHeap is a handle to the process heap

// MemInitializeMacro is a macro to get the handle to the process heap
#define MemInitializeMacro() (hProcessHeap = GetProcessHeap())

// MemAllocMacro is a macro to allocate dwBytes bytes of memory from the process heap
#define MemAllocMacro(dwBytes) (HeapAlloc(hProcessHeap, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, dwBytes))

// MemFreeMacro is a macro to free a memory block allocated from the process heap
#define MemFreeMacro(lpMem) (HeapFree(hProcessHeap, 0, lpMem))

// MAX_STRINGLEN is the text length limit of a character string resource
#define MAX_STRINGLEN  255

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\test\faxvrfy\ntlog.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  ntlog.h

Abstract:

  This module contains the necessary ntlog definitions

Author:

  Steven Kehrli (steveke) 11/15/1997

--*/

#ifndef _NTLOG_H
#define _NTLOG_H

#define TLS_INFO       0x00002000L  // Log at information level
#define TLS_SEV2       0x00000004L  // Log at severity 2 level
#define TLS_WARN       0x00000010L  // Log at warn level
#define TLS_PASS       0x00000020L  // Log at pass level
#define TLS_TEST       0x00000100L  // Log at test level
#define TLS_VARIATION  0x00000200L  // Log at variation level
#define TLS_REFRESH    0x00010000L  // Create new log file

#define TL_TEST        TLS_TEST     , TEXT(__FILE__), (int)__LINE__
#define TL_VARIATION   TLS_VARIATION, TEXT(__FILE__), (int)__LINE__

typedef HANDLE (APIENTRY *PTLCREATELOG) (LPCWSTR, DWORD);
typedef BOOL (APIENTRY *PTLDESTROYLOG) (HANDLE);
typedef BOOL (APIENTRY *PTLADDPARTICIPANT) (HANDLE, DWORD, int);
typedef BOOL (APIENTRY *PTLREMOVEPARTICIPANT) (HANDLE);
typedef BOOL FAR (cdecl *PTLLOG) (HANDLE, DWORD, LPCWSTR, int, LPCWSTR, ...);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\test\faxvrfy\resource.h ===
#define FONTNAME                           "MS Shell Dlg"
#define FONTSIZE                           8

#define IDD_SETUP                          101

#define IDR_MENU                           201
#define IDM_SEND                           202
#define IDM_RECEIVE                        203
#define IDM_HELP                           204

#define IDC_SEND_NUMBER                    1001
#define IDC_SEND_NUMBER_STATIC             1002
#define IDC_RECEIVE_NUMBER                 1003
#define IDC_RECEIVE_NUMBER_STATIC          1004
#define IDC_RAS_ENABLED_BUTTON             1005
#define IDC_RAS_USER_NAME_STATIC           1006
#define IDC_RAS_USER_NAME                  1007
#define IDC_RAS_PASSWORD_STATIC            1008
#define IDC_RAS_PASSWORD                   1009
#define IDC_RAS_DOMAIN_STATIC              1010
#define IDC_RAS_DOMAIN                     1011
#define IDC_NUM_PASSED                     1012
#define IDC_NUM_FAILED                     1013
#define IDC_NUM_TOTAL                      1014
#define IDC_STATUS_LIST                    1015
#define IDC_START_BUTTON                   1016
#define IDC_STOP_BUTTON                    1017
#define IDC_EXIT_BUTTON                    1018

#define IDS_FAX_MONITOR_NOT_INSTALLED      2001
#define IDS_FAX_PORT_NOT_INSTALLED         2002
#define IDS_FAX_DRIVER_NOT_INSTALLED       2003
#define IDS_FAX_PRINTER_NOT_INSTALLED      2004
#define IDS_COM_NOT_INITIALIZED            2005
#define IDS_FAXCOM_NOT_INSTALLED           2006
#define IDS_FAXADMIN_NOT_INSTALLED         2007
#define IDS_ROUTEEXT_NOT_INSTALLED         2008
#define IDS_FAX_SVC_NOT_INSTALLED          2009
#define IDS_FAX_SVC_NOT_STOPPED            2010
#define IDS_FAX_RCV_NOT_INITIALIZED        2011
#define IDS_FAX_CONNECT_FAILED             2012
#define IDS_FAX_ENUM_PORTS_FAILED          2013
#define IDS_FAX_PORTS_NOT_INSTALLED        2014
#define IDS_FAX_SET_PORT_FAILED            2015
#define IDS_FAX_RESTORE_PORT_FAILED        2016
#define IDS_OPEN_FAXDEVICES_REGKEY_FAILED  2017
#define IDS_FIXMODEMCLASS_DATA             2018
#define IDS_FAX_GET_CONFIG_FAILED          2019
#define IDS_FAX_SET_CONFIG_FAILED          2020
#define IDS_FAX_RESTORE_CONFIG_FAILED      2021
#define IDS_FAX_EVENT_QUEUE_FAILED         2022
#define IDS_EVENT_LABEL                    2023
#define IDS_PORT_LABEL                     2024
#define IDS_ASCII_SEND_NUMBER              2025
#define IDS_ASCII_RECEIVE_NUMBER           2026
#define IDS_MISSING_INFO                   2027
#define IDS_NO_SEND_NUMBER                 2028
#define IDS_NO_RECEIVE_NUMBER              2029
#define IDS_NO_RAS_USER_NAME               2030
#define IDS_NO_RAS_DOMAIN                  2031
#define IDS_STATUS_ITERATION_STARTED       2032
#define IDS_STATUS_ITERATION_STOPPED       2033
#define IDS_STATUS_ITERATION_PASSED        2034
#define IDS_STATUS_ITERATION_FAILED        2035
#define IDS_STATUS_TEST_PASSED             2036
#define IDS_STATUS_TEST_FAILED             2037
#define IDS_STATUS_TIMEOUT_ENDED           2038
#define IDS_STATUS_RAS_STARTING            2039
#define IDS_STATUS_RAS_STOPPING            2040
#define IDS_STATUS_RAS_FAILED              2041
#define IDS_STATUS_RAS_LINESPEED           2042
#define IDS_STATUS_RAS_PASSED              2043
#define IDS_STATUS_RAS_SPEED_SUSPECT       2044
#define IDS_STATUS_FAX_STARTING            2045
#define IDS_STATUS_FAX_STOPPING            2046
#define IDS_STATUS_FAX_SEND_PASSED         2047
#define IDS_STATUS_FAX_SEND_FAILED         2048
#define IDS_STATUS_FAX_WAITING             2049
#define IDS_STATUS_FAX_RECEIVED            2050
#define IDS_STATUS_FAX_ID                  2051
#define IDS_STATUS_FAX_INVALID             2052
#define IDS_STATUS_FAX_VERIFYING           2053
#define IDS_TIFF_VALID_TIFF                2054
#define IDS_TIFF_INVALID_TIFF              2055
#define IDS_TIFF_INVALID_IMAGEWIDTH        2056
#define IDS_TIFF_INVALID_IMAGELENGTH       2057
#define IDS_TIFF_INVALID_COMPRESSION       2058
#define IDS_TIFF_INVALID_PHOTOMETRIC       2059
#define IDS_TIFF_INVALID_XRESOLUTION       2060
#define IDS_TIFF_INVALID_YRESOLUTION       2061
#define IDS_TIFF_INVALID_SOFTWARE          2062
#define IDS_TIFF_INVALID_PAGES             2063
#define IDS_STATUS_RAS_DIALING             2064
#define IDS_STATUS_RAS_AUTHENTICATING      2065
#define IDS_STATUS_RAS_CONNECTED           2066
#define IDS_STATUS_FAX_INITIALIZING        2067
#define IDS_STATUS_FAX_DIALING             2068
#define IDS_STATUS_FAX_NO_DIAL_TONE_ABORT  2069
#define IDS_STATUS_FAX_NO_DIAL_TONE_RETRY  2070
#define IDS_STATUS_FAX_BUSY_ABORT          2071
#define IDS_STATUS_FAX_BUSY_RETRY          2072
#define IDS_STATUS_FAX_NO_ANSWER_ABORT     2073
#define IDS_STATUS_FAX_NO_ANSWER_RETRY     2074
#define IDS_STATUS_FAX_RINGING             2075
#define IDS_STATUS_FAX_ANSWERED            2076
#define IDS_STATUS_FAX_NOT_FAX_CALL        2077
#define IDS_STATUS_FAX_SENDING             2078
#define IDS_STATUS_FAX_RECEIVING           2079
#define IDS_STATUS_FAX_FATAL_ERROR_ABORT   2080
#define IDS_STATUS_FAX_FATAL_ERROR_RETRY   2081
#define IDS_STATUS_FAX_FATAL_ERROR         2082
#define IDS_STATUS_FAX_ABORTING            2083
#define IDS_STATUS_FAX_COMPLETED           2084
#define IDS_STATUS_FAX_IDLE                2085
#define IDS_STATUS_FAXSVC_ENDED            2086
#define IDS_STATUS_DEVICE_POWERED_OFF      2087
#define IDS_STATUS_DEVICE_POWERED_ON       2088
#define IDS_STATUS_PORTS_NOT_AVAILABLE     2089
#define IDS_STATUS_UNEXPECTED_STATE        2090
#define IDS_NUM_PASSED                     2091
#define IDS_NUM_FAILED                     2092
#define IDS_NUM_TOTAL                      2093
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\test\faxvrfy\startup.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  startup.c

Abstract:

  This module:  
    1) Retrieves all the printer monitors
    2) Verifies the fax printer monitor is installed
    3) Retrieves all the printer ports
    4) Verifies the fax printer port is installed
    5) Retrieves all the printer drivers
    6) Verifies the fax printer driver is installed
    7) Retrieves all the printers
    8) Verifies the fax printer is installed
    9) Verifies fax is installed
    10) Verifies the faxcom com objects are installed
    11) Verifies the faxadmin com objects are installed
    12) Verifies the routeext com objects are installed
    13) Verifies the com objects are installed
    14) Verifies the fax service is installed
    15) Stops the fax service
    16) Initializes FaxRcv
    17) Initializes RAS

Author:

  Steven Kehrli (steveke) 11/15/1997

--*/

#ifndef _STARTUP_C
#define _STARTUP_C

#include <winspool.h>
#include <faxcom.h>
#include <faxcom_i.c>
#include <faxadmin.h>
#include <faxadmin_i.c>
#include <routeext.h>
#include <routeext_i.c>

#define FAX_MONITOR_NAME  L"Windows NT Fax Monitor"  // FAX_MONITOR_NAME is the name of the Fax Printer Monitor
#define FAX_MONITOR_DLL   L"msfaxmon.dll"              // FAX_MONITOR_DLL is the name of the Fax Printer Monitor Dll
#define FAX_PORT_NAME     L"MSFAX:"                  // FAX_PORT_NAME is the name of the Fax Printer Port
#define FAX_DRIVER_NAME   L"Windows NT Fax Driver"   // FAX_DRIVER_NAME is the name of the Fax Printer Driver
#define FAX_DRIVER_DLL    L"faxdrv.dll"              // FAX_DRIVER_DLL is the name of the Fax Printer Driver Dll
#define FAX_SERVICE       L"Fax"                     // FAX_SERVICE is the name of the Fax Service

PVOID
fnLocalEnumPrinterMonitors(
    LPDWORD  pdwNumPrinterMonitors
)
/*++

Routine Description:

  Retrieves all the printer monitors

Arguments:

  pdwNumPrinterMonitors - pointer to number of printer monitors

Return Value:

  PVOID - pointer to the printer monitors info

--*/
{
    // pPrinterMonitorInfo is a pointer to a buffer of printer monitor info structures
    LPBYTE  pPrinterMonitorInfo;
    // cb is the size of the buffer of printer driver info structures
    DWORD   cb;

    *pdwNumPrinterMonitors = 0;
    // Get all printer monitors
    if ((!EnumMonitors(NULL, 2, NULL, 0, &cb, pdwNumPrinterMonitors)) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        // EnumMonitors failed because the buffer is too small
        // cb is the size of the buffer needed, so allocate a buffer of that size
        pPrinterMonitorInfo = MemAllocMacro(cb);
        // Call EnumMonitors again with the correct size buffer
        if (!EnumMonitors(NULL, 2, pPrinterMonitorInfo, cb, &cb, pdwNumPrinterMonitors)) {
            // EnumMonitors failed
            // Free the buffer
            MemFreeMacro(pPrinterMonitorInfo);
            goto ExitLevel0;
        }
        // EnumMonitors succeeded, so return pointer to the buffer
        return pPrinterMonitorInfo;
    }

ExitLevel0:
    // EnumMonitors failed
    DebugMacro(L"EnumMonitors() failed, ec = 0x%08x\n", GetLastError());
    // Return a NULL handle
    return NULL;
}

BOOL
fnIsFaxPrinterMonitorInstalled(
)
/*++

Routine Description:

  Verifies the fax printer monitor is installed

Return Value:

  TRUE on success

--*/
{
    // szDllPath is the path where the fax printer monitor dll resides
    WCHAR             szDllPath[_MAX_PATH];

    // pAllPrinterMonitors is the pointer to all printer monitors info
    LPMONITOR_INFO_2  pAllPrinterMonitors;
    // dwNumPrinterMonitors is the number of all printer monitors
    DWORD             dwNumPrinterMonitors;
    // dwNumFaxPrinterMonitors is the number of fax printer monitors
    DWORD             dwNumFaxPrinterMonitors;
    // dwIndex is a counter to enumerate each printer monitor
    DWORD             dwIndex;

    // Clear the dll path
    ZeroMemory(szDllPath, sizeof(szDllPath));

    // Get the path
    if (GetSystemDirectory(szDllPath, sizeof(szDllPath)) == 0) {
        DebugMacro(L"GetSystemDirectory() failed, ec = 0x%08x\n", GetLastError());
        return FALSE;
    }

    // Concatenate the fax printer monitor dll with the path
    lstrcat(szDllPath, L"\\");
    lstrcat(szDllPath, FAX_MONITOR_DLL);

    // Verify fax printer monitor dll exists
    if (GetFileAttributes(szDllPath) == 0xFFFFFFFF) {
        DebugMacro(L"The Fax Printer Monitor DLL does not exist.\n");
        return FALSE;
    }

    // Get all printer monitors
    pAllPrinterMonitors = fnLocalEnumPrinterMonitors(&dwNumPrinterMonitors);
    if (!pAllPrinterMonitors)
        // Return FALSE
        return FALSE;

    // Determine the number of fax printer monitors
    for (dwIndex = 0, dwNumFaxPrinterMonitors = 0; dwIndex < dwNumPrinterMonitors; dwIndex++) {
        // A fax printer monitor is determined by comparing the name of the current printer monitor against the name of the fax printer monitor
        if ((!lstrcmpi(pAllPrinterMonitors[dwIndex].pName, FAX_MONITOR_NAME)) && (!lstrcmpi(pAllPrinterMonitors[dwIndex].pDLLName, FAX_MONITOR_DLL))) {
            // Name of the current printer monitor and the name of the fax printer monitor match
            // Increment the number of fax printer monitors
            dwNumFaxPrinterMonitors++;
        }
    }

    // Free all printer monitors
    MemFreeMacro(pAllPrinterMonitors);

    if (dwNumFaxPrinterMonitors == 1) {
        return TRUE;
    }
    else if (dwNumFaxPrinterMonitors > 1) {
        DebugMacro(L"The Fax Printer Monitor is installed more than once.\n");
        return FALSE;
    }
    else {
        DebugMacro(L"The Fax Printer Monitor is not installed.\n");
        return FALSE;
    }
}

PVOID
fnLocalEnumPrinterPorts(
    LPDWORD  pdwNumPrinterPorts
)
/*++

Routine Description:

  Retrieves all the printer ports

Arguments:

  pdwNumPrinterPorts - pointer to number of printer ports

Return Value:

  PVOID - pointer to the printer ports info

--*/
{
    // pPrinterPortInfo is a pointer to a buffer of printer port info structures
    LPBYTE  pPrinterPortInfo;
    // cb is the size of the buffer of printer port info structures
    DWORD   cb;

    *pdwNumPrinterPorts = 0;
    // Get all printer ports
    if ((!EnumPorts(NULL, 2, NULL, 0, &cb, pdwNumPrinterPorts)) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        // EnumPorts failed because the buffer is too small
        // cb is the size of the buffer needed, so allocate a buffer of that size
        pPrinterPortInfo = MemAllocMacro(cb);
        // Call EnumPorts again with the correct size buffer
        if (!EnumPorts(NULL, 2, pPrinterPortInfo, cb, &cb, pdwNumPrinterPorts)) {
            // EnumPorts failed
            // Free the buffer
            MemFreeMacro(pPrinterPortInfo);
            goto ExitLevel0;
        }
        // EnumPorts succeeded, so return pointer to the buffer
        return pPrinterPortInfo;
    }

ExitLevel0:
    // EnumPorts failed
    DebugMacro(L"EnumPorts() failed, ec = 0x%08x\n", GetLastError());
    // Return a NULL handle
    return NULL;
}

BOOL
fnIsFaxPrinterPortInstalled(
)
/*++

Routine Description:

  Verifies the fax printer port is installed

Return Value:

  TRUE on success

--*/
{
    // pAllPrinterPorts is the pointer to all printer ports info
    LPPORT_INFO_2  pAllPrinterPorts;
    // dwNumPrinterPorts is the number of all printer ports
    DWORD          dwNumPrinterPorts;
    // dwNumFaxPrinterPorts is the number of fax printer ports
    DWORD          dwNumFaxPrinterPorts;
    // dwIndex is a counter to enumerate each printer ports
    DWORD          dwIndex;

    // Get all printer ports
    pAllPrinterPorts = fnLocalEnumPrinterPorts(&dwNumPrinterPorts);
    if (!pAllPrinterPorts) {
        // Return FALSE
        return FALSE;
    }

    // Determine the number of fax printer ports
    for (dwIndex = 0, dwNumFaxPrinterPorts = 0; dwIndex < dwNumPrinterPorts; dwIndex++) {
        // A fax printer port is determined by comparing the name of the current printer port against the name of the fax printer port
        if ((!lstrcmpi(pAllPrinterPorts[dwIndex].pPortName, FAX_PORT_NAME)) && (!lstrcmpi(pAllPrinterPorts[dwIndex].pMonitorName, FAX_MONITOR_NAME))) {
            // Name of the current printer port and the name of the fax printer port match
            // Increment the number of fax printer ports
            dwNumFaxPrinterPorts++;
        }
    }

    // Free all printer ports
    MemFreeMacro(pAllPrinterPorts);

    if (dwNumFaxPrinterPorts == 1) {
        return TRUE;
    }
    else if (dwNumFaxPrinterPorts > 1) {
        DebugMacro(L"The Fax Printer Port is installed more than once.\n");
        return FALSE;
    }
    else {
        DebugMacro(L"The Fax Printer Port is not installed.\n");
        return FALSE;
    }
}

PVOID
fnLocalEnumPrinterDrivers(
    LPDWORD  pdwNumPrinterDrivers
)
/*++

Routine Description:

  Retrieves all the printer drivers

Arguments:

  pdwNumPrinterDrivers - pointer to number of printer drivers

Return Value:

  PVOID - pointer to the printer drivers info

--*/
{
    // pPrinterDriverInfo is a pointer to a buffer of printer driver info structures
    LPBYTE  pPrinterDriverInfo;
    // cb is the size of the buffer of printer driver info structures
    DWORD   cb;

    *pdwNumPrinterDrivers = 0;
    // Get all printer drivers
    if ((!EnumPrinterDrivers(NULL, NULL, 2, NULL, 0, &cb, pdwNumPrinterDrivers)) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        // EnumPrinterDrivers failed because the buffer is too small
        // cb is the size of the buffer needed, so allocate a buffer of that size
        pPrinterDriverInfo = MemAllocMacro(cb);
        // Call EnumPrinterDrivers again with the correct size buffer
        if (!EnumPrinterDrivers(NULL, NULL, 2, pPrinterDriverInfo, cb, &cb, pdwNumPrinterDrivers)) {
            // EnumPrinterDrivers failed
            // Free the buffer
            MemFreeMacro(pPrinterDriverInfo);
            goto ExitLevel0;
        }
        // EnumPrinterDrivers succeeded, so return pointer to the buffer
        return pPrinterDriverInfo;
    }

ExitLevel0:
    // EnumPrinterDrivers failed
    DebugMacro(L"EnumPrinterDrivers() failed, ec = 0x%08x\n", GetLastError());
    // Return a NULL handle
    return NULL;
}

BOOL
fnIsFaxPrinterDriverInstalled(
)
/*++

Routine Description:

  Verifies the fax printer driver is installed

Return Value:

  TRUE on success

--*/
{
    // pAllPrinterDrivers is the pointer to all printer drivers info
    LPDRIVER_INFO_2  pAllPrinterDrivers;
    // dwNumPrinterDrivers is the number of all printer drivers
    DWORD            dwNumPrinterDrivers;
    // dwNumFaxPrinterDrivers is the number of fax printer drivers
    DWORD            dwNumFaxPrinterDrivers;
    // dwIndex is a counter to enumerate each printer driver
    DWORD            dwIndex;
    DWORD            cb;

    // Get all printer drivers
    pAllPrinterDrivers = fnLocalEnumPrinterDrivers(&dwNumPrinterDrivers);
    if (!pAllPrinterDrivers)
        // Return FALSE
        return FALSE;

    // Determine the number of fax printer drivers
    for (dwIndex = 0, dwNumFaxPrinterDrivers = 0; dwIndex < dwNumPrinterDrivers; dwIndex++) {
        // A fax printer driver is determined by comparing the name of the current printer driver against the name of the fax printer driver
        if ((!lstrcmpi(pAllPrinterDrivers[dwIndex].pName, FAX_DRIVER_NAME)) && (!lstrcmpi((LPWSTR) ((UINT_PTR) pAllPrinterDrivers[dwIndex].pDriverPath + (lstrlen(pAllPrinterDrivers[dwIndex].pDriverPath) - lstrlen(FAX_DRIVER_DLL)) * sizeof(WCHAR)), FAX_DRIVER_DLL)) && (GetFileAttributes(pAllPrinterDrivers[dwIndex].pDriverPath) != 0xFFFFFFFF)) {
            // Name of the current printer driver and the name of the fax printer driver match
            // Increment the number of fax printer drivers
            dwNumFaxPrinterDrivers++;
        }
    }

    // Free all printer drivers
    MemFreeMacro(pAllPrinterDrivers);

    if (dwNumFaxPrinterDrivers == 1) {
        return TRUE;
    }
    else if (dwNumFaxPrinterDrivers > 1) {
        DebugMacro(L"The Fax Printer Driver is installed more than once.\n");
        return FALSE;
    }
    else {
        DebugMacro(L"The Fax Printer Driver is not installed.\n");
        return FALSE;
    }
}

PVOID
fnLocalEnumPrinters(
    LPDWORD  pdwNumPrinters
)
/*++

Routine Description:

  Retrieves all the printers

Arguments:

  pdwNumPrinters - pointer to number of printers

Return Value:

  PVOID - pointer to the printer info

--*/
{
    // pPrinterInfo is a pointer to a buffer of printer info structures
    LPBYTE  pPrinterInfo;
    // cb is the size of the buffer of printer info structures
    DWORD   cb;

    *pdwNumPrinters = 0;
    // Get all printers
    if ((!EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 2, NULL, 0, &cb, pdwNumPrinters)) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        // EnumPrinters failed because the buffer is too small
        // cb is the size of the buffer needed, so allocate a buffer of that size
        pPrinterInfo = MemAllocMacro(cb);
        // Call EnumPrinters again with the correct size buffer
        if (!EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 2, pPrinterInfo, cb, &cb, pdwNumPrinters)) {
            // EnumPrinters failed
            // Free the buffer
            MemFreeMacro(pPrinterInfo);
            goto ExitLevel0;
        }
        // EnumPrinters succeeded, so return pointer to the buffer
        return pPrinterInfo;
    }

ExitLevel0:
    // EnumPrinters failed
    DebugMacro(L"EnumPrinters() failed, ec = 0x%08x\n", GetLastError());
    // Return a NULL handle
    return NULL;
}

BOOL
fnIsFaxPrinterInstalled(
)
/*++

Routine Description:

  Verifies the fax printer is installed

Return Value:

  TRUE on success

--*/
{
    // pPrinterInfo is the pointer to all printers info
    LPPRINTER_INFO_2  pAllPrinters;
    // dwNumPrinters is the number of all printers
    DWORD             dwNumPrinters;
    // dwNumFaxPrinters is the number of fax printers
    DWORD             dwNumFaxPrinters;
    // dwIndex is a counter to enumerate each printer
    DWORD             dwIndex;

    // Get all printers
    pAllPrinters = fnLocalEnumPrinters(&dwNumPrinters);
    if (!pAllPrinters)
        // Return FALSE
        return FALSE;

    // Determine the number of fax printers
    for (dwIndex = 0, dwNumFaxPrinters = 0; dwIndex < dwNumPrinters; dwIndex++) {
        // A fax printer is determined by comparing the name of the current printer driver against the name of the fax printer driver
        if ((!lstrcmpi(pAllPrinters[dwIndex].pDriverName, FAX_DRIVER_NAME)) && (!lstrcmpi(pAllPrinters[dwIndex].pPortName, FAX_PORT_NAME))) {
            // Name of the current printer driver and the name of the fax printer driver match
            // Increment the number of fax printers
            dwNumFaxPrinters++;
        }
    }

    // Free all printers
    MemFreeMacro(pAllPrinters);

    if (dwNumFaxPrinters) {
        return TRUE;
    }
    else {
        DebugMacro(L"A Fax Printer is not installed.\n");
        return FALSE;
    }
}

UINT
fnIsFaxInstalled(
)
/*++

Routine Description:

  Verifies fax is installed

Return Value:

  UINT - resource id

--*/
{
    // Verify the fax printer monitor is installed
    if (!fnIsFaxPrinterMonitorInstalled()) {
        return IDS_FAX_MONITOR_NOT_INSTALLED;
    }

    // Verify the fax printer port is installed
    if (!fnIsFaxPrinterPortInstalled()) {
        return IDS_FAX_PORT_NOT_INSTALLED;
    }

    // Verify the fax printer driver is installed
    if (!fnIsFaxPrinterDriverInstalled()) {
        return IDS_FAX_DRIVER_NOT_INSTALLED;
    }

    // Verify the fax printer is installed
    if (!fnIsFaxPrinterInstalled()) {
        return IDS_FAX_PRINTER_NOT_INSTALLED;
    }

    return ERROR_SUCCESS;
}

BOOL
fnIsFaxComInstalled(
)
/*++

Routine Description:

  Verifies the faxcom com objects are installed

Return Value:

  TRUE on success

--*/
{
    HRESULT   hResult;
    IFaxTiff  *pIFaxTiff;

    hResult = CoCreateInstance((REFCLSID) &CLSID_FaxTiff, NULL, CLSCTX_INPROC_SERVER, &IID_IFaxTiff, &pIFaxTiff);
    if (hResult != S_OK) {
        DebugMacro(L"CoCreateInstance(CLSID_FaxTiff, IID_IFaxTiff) failed, ec = 0x%08x\n", hResult);
        return FALSE;
    }

    pIFaxTiff->lpVtbl->Release(pIFaxTiff);

    return TRUE;
}

BOOL
fnIsFaxAdminInstalled(
)
/*++

Routine Description:

  Verifies the faxadmin com objects are installed

Return Value:

  TRUE on success

--*/
{
    HRESULT     hResult;
    IFaxSnapin  *pIFaxSnapin;

    hResult = CoCreateInstance((REFCLSID) &CLSID_FaxSnapin, NULL, CLSCTX_INPROC_SERVER, &IID_IFaxSnapin, &pIFaxSnapin);
    if (hResult != S_OK) {
        DebugMacro(L"CoCreateInstance(CLSID_FaxSnapin, IID_IFaxSnapin) failed, ec = 0x%08x\n", hResult);
        return FALSE;
    }

    pIFaxSnapin->lpVtbl->Release(pIFaxSnapin);

    return TRUE;
}

BOOL
fnIsRouteExtInstalled(
)
/*++

Routine Description:

  Verifies the routeext com objects are installed

Return Value:

  TRUE on success

--*/
{
    HRESULT   hResult;
    IUnknown  *pRoute;

    hResult = CoCreateInstance((REFCLSID) &CLSID_Route, NULL, CLSCTX_INPROC_SERVER, &IID_IUnknown, &pRoute);
    if (hResult != S_OK) {
        DebugMacro(L"CoCreateInstance(CLSID_Route, IID_IUnknown) failed, ec = 0x%08x\n", hResult);
        return FALSE;
    }

    pRoute->lpVtbl->Release(pRoute);

    return TRUE;
}

UINT
fnIsComInstalled(
)
/*++

Routine Description:

  Verifies the com objects are installed

Return Value:

  UINT - resource id

--*/
{
    HRESULT  hResult;
    UINT     uRslt;

    hResult = CoInitialize(NULL);
    if (hResult != S_OK) {
        DebugMacro(L"CoInitialize() failed, ec = 0x%08x\n", hResult);
        uRslt = IDS_COM_NOT_INITIALIZED;
    }

    if (!fnIsFaxComInstalled()) {
        uRslt = IDS_FAXCOM_NOT_INSTALLED;
    }

    if (!fnIsFaxAdminInstalled()) {
        uRslt = IDS_FAXADMIN_NOT_INSTALLED;
    }

    if (!fnIsRouteExtInstalled()) {
        uRslt = IDS_ROUTEEXT_NOT_INSTALLED;
    }

    uRslt = ERROR_SUCCESS;

    CoUninitialize();
    return uRslt;
}

BOOL
fnIsFaxSvcInstalled(
)
/*++

Routine Description:

  Verifies the fax service is installed

Return Value:

  TRUE on success

--*/
{
    SC_HANDLE  hManager = NULL;
    SC_HANDLE  hService = NULL;

    // Open the service control manager
    hManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);

    if (!hManager) {
        DebugMacro(L"OpenSCManager() failed, ec = 0x%08x\n", GetLastError());
        return FALSE;
    }

    // Open the service
    hService = OpenService(hManager, FAX_SERVICE, SERVICE_ALL_ACCESS);

    if (!hService) {
        CloseServiceHandle(hManager);
        DebugMacro(L"OpenService() failed, ec = 0x%08x\n", GetLastError());
        return FALSE;
    }

    CloseServiceHandle(hService);
    CloseServiceHandle(hManager);
    return TRUE;
}

BOOL
fnStopFaxSvc(
)
/*++

Routine Description:

  Stops the fax service

Return Value:

  TRUE on success

--*/
{
    SC_HANDLE       hManager;
    SC_HANDLE       hService;
    SERVICE_STATUS  ServiceStatus;
    BOOL            bRslt;

    bRslt = FALSE;

    // Open the service control manager
    hManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);
    if (!hManager) {
        DebugMacro(L"OpenSCManager() failed, ec = 0x%08x\n", GetLastError());
        goto ExitLevel0;
    }

    // Open the service
    hService = OpenService(hManager, FAX_SERVICE, SERVICE_ALL_ACCESS);
    if (!hService) {
        DebugMacro(L"OpenService() failed, ec = 0x%08x\n", GetLastError());
        goto ExitLevel0;
    }

    // Query the service status
    ZeroMemory(&ServiceStatus, sizeof(SERVICE_STATUS));
    if (!QueryServiceStatus(hService, &ServiceStatus)) {
        DebugMacro(L"QueryServiceStatus() failed, ec = 0x%08x\n", GetLastError());
        goto ExitLevel0;
    }

    if (ServiceStatus.dwCurrentState == SERVICE_STOPPED) {
        // Service is stopped
        bRslt = TRUE;
        goto ExitLevel0;
    }

    // Stop the service
    if (!ControlService(hService, SERVICE_CONTROL_STOP, &ServiceStatus)) {
        DebugMacro(L"ControlService() failed, ec = 0x%08x\n", GetLastError());
        goto ExitLevel0;
    }

    // Wait until the service is stopped
    ZeroMemory(&ServiceStatus, sizeof(SERVICE_STATUS));
    while (ServiceStatus.dwCurrentState != SERVICE_STOPPED) {
        Sleep(1000);

        // Query the service status
        if (!QueryServiceStatus(hService, &ServiceStatus)) {
            DebugMacro(L"QueryServiceStatus() failed, ec = 0x%08x\n", GetLastError());
            goto ExitLevel0;
        }

        // Verify the service is stopped or stopping
        if (!((ServiceStatus.dwCurrentState == SERVICE_STOPPED) || (ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING))) {
            DebugMacro(L"The Fax Service is in an unexpected state.  dwCurrentState: 0x%08x\n", ServiceStatus.dwCurrentState);
            goto ExitLevel0;
        }
    }

    bRslt = TRUE;

    Sleep(1000);

ExitLevel0:
    if (hService) {
        CloseServiceHandle(hService);
    }
    if (hManager) {
        CloseServiceHandle(hManager);
    }
    return bRslt;
}

UINT
fnInitializeFaxRcv(
)
/*++

Routine Description:

  Initializes FaxRcv

Return Value:

  UINT - resource id

--*/
{
    // szFaxRcvDll is the FaxRcv dll
    WCHAR   szFaxRcvDll[_MAX_PATH];

    // hFaxRcvExtKey is the handle to the FaxRcv Extension Registry key
    HKEY    hFaxRcvExtKey;
    // hRoutingMethodsKey is the handle to the FaxRcv Routing Methods Registry key
    HKEY    hRoutingMethodsKey;
    // hFaxRcvMethodKey is the handle to the FaxRcv Method Registry key
    HKEY    hFaxRcvMethodKey;
    DWORD   dwDisposition;

    DWORD   dwData;
    LPWSTR  szData;

    UINT    uRslt;

    uRslt = IDS_FAX_RCV_NOT_INITIALIZED;

    if (!fnIsFaxSvcInstalled()) {
        return IDS_FAX_SVC_NOT_INSTALLED;
    }

    if (!fnStopFaxSvc()) {
        return IDS_FAX_SVC_NOT_STOPPED;
    }

    ExpandEnvironmentStrings(IMAGENAME_EXT_REGDATA, szFaxRcvDll, sizeof(szFaxRcvDll) / sizeof(WCHAR));
    if (!lstrcmpi(IMAGENAME_EXT_REGDATA, szFaxRcvDll)) {
        return IDS_FAX_RCV_NOT_INITIALIZED;
    }

    // Copy the FaxRcv dll
    if (!CopyFile(FAXRCV_DLL, szFaxRcvDll, FALSE)) {
        return IDS_FAX_RCV_NOT_INITIALIZED;
    }

    // Create or open the FaxRcv Extension Registry key
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, FAXRCV_EXT_REGKEY, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hFaxRcvExtKey, &dwDisposition) != ERROR_SUCCESS) {
        return IDS_FAX_RCV_NOT_INITIALIZED;
    }

    // Create or open the FaxRcv Routing Methods Registry key
    if (RegCreateKeyEx(hFaxRcvExtKey, ROUTINGMETHODS_REGKEY, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hRoutingMethodsKey, &dwDisposition) != ERROR_SUCCESS) {
        goto ExitLevel0;
    }

    // Create or open the FaxRcv Method Registry key
    if (RegCreateKeyEx(hRoutingMethodsKey, FAXRCV_METHOD_REGKEY, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hFaxRcvMethodKey, &dwDisposition) != ERROR_SUCCESS) {
        goto ExitLevel1;
    }

    // Set FaxRcv Extension bEnable Registry value
    dwData = BENABLE_EXT_REGDATA;
    if (RegSetValueEx(hFaxRcvExtKey, BENABLE_EXT_REGVAL, 0, REG_DWORD, (PBYTE) &dwData, sizeof(DWORD)) != ERROR_SUCCESS) {
        goto ExitLevel2;
    }

    // Set FaxRcv Extension FriendlyName Registry value
    szData = FRIENDLYNAME_EXT_REGDATA;
    if (RegSetValueEx(hFaxRcvExtKey, FRIENDLYNAME_EXT_REGVAL, 0, REG_SZ, (PBYTE) szData, (lstrlen(szData) + 1) * sizeof(WCHAR)) != ERROR_SUCCESS) {
        goto ExitLevel2;
    }

    // Set FaxRcv Extension ImageName Registry value
    szData = IMAGENAME_EXT_REGDATA;
    if (RegSetValueEx(hFaxRcvExtKey, IMAGENAME_EXT_REGVAL, 0, REG_EXPAND_SZ, (PBYTE) szData, (lstrlen(szData) + 1) * sizeof(WCHAR)) != ERROR_SUCCESS) {
        goto ExitLevel2;
    }

    // Set FaxRcv Method FriendlyName Registry value
    szData = FRIENDLYNAME_METHOD_REGDATA;
    if (RegSetValueEx(hFaxRcvMethodKey, FRIENDLYNAME_METHOD_REGVAL, 0, REG_SZ, (PBYTE) szData, (lstrlen(szData) + 1) * sizeof(WCHAR)) != ERROR_SUCCESS) {
        goto ExitLevel2;
    }

    // Set FaxRcv Method FunctionName Registry value
    szData = FUNCTIONNAME_METHOD_REGDATA;
    if (RegSetValueEx(hFaxRcvMethodKey, FUNCTIONNAME_METHOD_REGVAL, 0, REG_SZ, (PBYTE) szData, (lstrlen(szData) + 1) * sizeof(WCHAR)) != ERROR_SUCCESS) {
        goto ExitLevel2;
    }

    // Set FaxRcv Method Guid Registry value
    szData = GUID_METHOD_REGDATA;
    if (RegSetValueEx(hFaxRcvMethodKey, GUID_METHOD_REGVAL, 0, REG_SZ, (PBYTE) szData, (lstrlen(szData) + 1) * sizeof(WCHAR)) != ERROR_SUCCESS) {
        goto ExitLevel2;
    }

    // Set FaxRcv Method Priority Registry value
    dwData = PRIORITY_METHOD_REGDATA;
    if (RegSetValueEx(hFaxRcvMethodKey, PRIORITY_METHOD_REGVAL, 0, REG_DWORD, (PBYTE) &dwData, sizeof(DWORD)) != ERROR_SUCCESS) {
        goto ExitLevel2;
    }

    uRslt = ERROR_SUCCESS;

ExitLevel2:
    // Close the FaxRcv Method Registry key
    RegCloseKey(hFaxRcvMethodKey);

ExitLevel1:
    // Close the FaxRcv Routing Methods Registry key
    RegCloseKey(hRoutingMethodsKey);

ExitLevel0:
    // Close the FaxRcv Extension Registry key
    RegCloseKey(hFaxRcvExtKey);

    return uRslt;
}

BOOL
fnInitializeRas(
)
/*++

Routine Description:

  Initializes RAS

Return Value:

  TRUE on success

--*/
{
    // szDllPath is the path where the RAS dll resides
    WCHAR      szDllPath[_MAX_PATH];
    // hInstance is the handle to the RAS dll
    HINSTANCE  hInstance;

    // Clear the dll path
    ZeroMemory(szDllPath, sizeof(szDllPath));

    // Get the path
    if (GetSystemDirectory(szDllPath, sizeof(szDllPath)) == 0) {
        DebugMacro(L"GetSystemDirectory() failed, ec = 0x%08x\n", GetLastError());
        return FALSE;
    }

    // Concatenate the RAS dll with the path
    lstrcat(szDllPath, RASAPI32_DLL);

    // Get the handle to the RAS dll
    hInstance = LoadLibrary((LPCWSTR) szDllPath);
    if (!hInstance) {
        DebugMacro(L"LoadLibrary(%s) failed, ec = 0x%08x\n", szDllPath, GetLastError());
        return FALSE;
    }

    // Map all needed functions

    g_RasApi.hInstance = hInstance;

    // RasDial
    g_RasApi.RasDial = GetProcAddress(hInstance, "RasDialW");

    if (!g_RasApi.RasDial) {
        DebugMacro(L"GetProcAddress(RasDial) failed, ec = 0x%08x\n", GetLastError());
        FreeLibrary(hInstance);
        return FALSE;
    }

    // RasGetErrorString
    g_RasApi.RasGetErrorString = GetProcAddress(hInstance, "RasGetErrorStringW");

    if (!g_RasApi.RasGetErrorString) {
        DebugMacro(L"GetProcAddress(RasGetErrorString) failed, ec = 0x%08x\n", GetLastError());
        FreeLibrary(hInstance);
        return FALSE;
    }

    // RasGetConnectStatus
    g_RasApi.RasGetConnectStatus = GetProcAddress(hInstance, "RasGetConnectStatusW");

    if (!g_RasApi.RasGetConnectStatus) {
        DebugMacro(L"GetProcAddress(RasGetConnectStatus) failed, ec = 0x%08x\n", GetLastError());
        FreeLibrary(hInstance);
        return FALSE;
    }

    // RasGetConnectionStatistics
    g_RasApi.RasGetConnectionStatistics = GetProcAddress(hInstance, "RasGetConnectionStatistics");

    if (!g_RasApi.RasGetConnectionStatistics) {
        DebugMacro(L"GetProcAddress(RasGetConnectionStatistics) failed, ec = 0x%08x\n", GetLastError());
        FreeLibrary(hInstance);
        return FALSE;
    }

    // RasHangUp
    g_RasApi.RasHangUp = GetProcAddress(hInstance, "RasHangUpW");

    if (!g_RasApi.RasHangUp) {
        DebugMacro(L"GetProcAddress(RasHangUp) failed, ec = 0x%08x\n", GetLastError());
        FreeLibrary(hInstance);
        return FALSE;
    }

    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\test\faxvrfy\macros.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  macros.c

Abstract:

  This module contains the global macros

Author:

  Steven Kehrli (steveke) 11/15/1997

--*/

#ifndef _MACROS_C
#define _MACROS_C

#include <stdio.h>

// szDefaultCaption is the default caption
LPWSTR  szDefaultCaption = NULL;

VOID
SetDefaultCaptionMacro(
    LPWSTR  szCaption
)
/*++

Routine Description:

  Sets the default caption

Arguments:

  szCaption - default caption

Return Value:

  None

--*/
{
    DWORD  cb;

    if (szCaption) {
        // Determine the memory required by szDefaultCaption
        cb = (lstrlen(szCaption) + 1) * sizeof(WCHAR);

        // Allocate the memory for szDefaultCaption
        szDefaultCaption = MemAllocMacro(cb);

        // Set szDefaultCaption
        lstrcpy(szDefaultCaption, szCaption);
    }
}

VOID
DebugMacro(
    LPWSTR  szFormatString,
    ...
)
/*++

Routine Description:

  Displays a string in the debugger

Arguments:

  szFormatString - pointer to the string

Return Value:

  None

--*/
{
    va_list     varg_ptr;
    SYSTEMTIME  SystemTime;
    // szDebugBuffer is the debug string
    WCHAR       szDebugBuffer[1024];
    DWORD       cb;

    // Initialize the buffer
    ZeroMemory(szDebugBuffer, sizeof(szDebugBuffer));

    // Get the current time
    GetLocalTime(&SystemTime);
    if (szDefaultCaption) {
        wsprintf(szDebugBuffer, L"%s - %02d.%02d.%04d@%02d:%02d:%02d.%03d:\n", szDefaultCaption, SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear, SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond, SystemTime.wMilliseconds);
    }
    else {
        wsprintf(szDebugBuffer, L"%02d.%02d.%04d@%02d:%02d:%02d.%03d:\n", SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear, SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond, SystemTime.wMilliseconds);
    }
    cb = lstrlen(szDebugBuffer);

    va_start(varg_ptr, szFormatString);
    _vsnwprintf(&szDebugBuffer[cb], sizeof(szDebugBuffer) - cb, szFormatString, varg_ptr);
    OutputDebugString(szDebugBuffer);
}

VOID
MessageBoxMacro(
    HWND  hWndParent,
    UINT  uID,
    UINT  uType,
    ...
)
/*++

Routine Description:

  Displays a pop-up

Arguments:

  hWndParent - handle of parent window
  uID - id of resource string
  uType - type of message box

Return Value:

  None

--*/
{
    va_list  varg_ptr;
    // szFormatString is the string determined from the id of the resource string, used as format control
    WCHAR    szFormatString[MAX_STRINGLEN];
    // szTest is the string displayed in the pop-up
    WCHAR    szText[MAX_STRINGLEN * 2];

    // Initialize the buffers
    ZeroMemory(szFormatString, sizeof(szFormatString));
    ZeroMemory(szText, sizeof(szText));

    // Load the resource string
    LoadString(g_hInstance, uID, szFormatString, MAX_STRINGLEN);

    va_start(varg_ptr, uType);
    _vsnwprintf(szText, MAX_STRINGLEN * 2, szFormatString, varg_ptr);
    DebugMacro(L"%s\n", szText);
    // Display the pop-up
    MessageBox(hWndParent, szText, szDefaultCaption, MB_OK | uType);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\test\faxvrfy\sndthrd.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  sndthrd.c

Abstract:

  This module:
    1) Verifies a tiff
    2) Enables or disables the FaxRcv Routing Extension
    3) Callback function for the change of state during the RAS connection process
    4) Sends a RAS call
    5) Sends a fax
    6) Receives a fax
    7) Thread to handle the Send logic

Author:

  Steven Kehrli (steveke) 11/15/1997

--*/

#ifndef _SNDTHRD_C
#define _SNDTHRD_C

#include <tifflib.h>
#include <tifflibp.h>

#define SUSPECT_RAS_SPEED    28800

#define IMAGEWIDTH_REF       1728
#define IMAGELENGTH_200_REF  2200
#define IMAGELENGTH_100_REF  1100
#define SOFTWARE_REF         "Windows NT Fax Server"

UINT
fnVerifyTiff(
    LPWSTR   szTiffFile,
    LPDWORD  pdwPages
)
/*++

Routine Description:

  Verifies a tiff

Arguments:

  szTiffFile - tiff file name
  pdwPages - pointer to the number of pages

Return Value:

  TRUE on success

--*/
{
    HANDLE               hTiffFile;
    TIFF_INFO            TiffInfo;
    PTIFF_INSTANCE_DATA  pTiffInstanceData;
    DWORD                IFDOffset;
    WORD                 wNumDirEntries;
    PTIFF_TAG            pTiffTag;
    WORD                 wIndex;

    DWORD                ImageLengthRef;

    DWORD                ImageWidth;
    DWORD                ImageLength;
    DWORD                Compression;
    DWORD                Photometric;
    DWORD                XResolution;
    DWORD                YResolution;
    LPSTR                SoftwareBuffer;
    LPSTR                Software;

    UINT                 uFlags;

    uFlags = ERROR_SUCCESS;
    *pdwPages = 0;

    // Open the tiff file
    hTiffFile = TiffOpen(szTiffFile, &TiffInfo, TRUE, FILLORDER_MSB2LSB);
    if (hTiffFile == NULL) {
        TiffClose(hTiffFile);
        return IDS_TIFF_INVALID_TIFF;
    }

    pTiffInstanceData = (PTIFF_INSTANCE_DATA) hTiffFile;
    // Get the next IFD offset
    IFDOffset = pTiffInstanceData->TiffHdr.IFDOffset;

    while (IFDOffset) {

        // Increment the number of pages
        (*pdwPages)++;

        // Get the number of tags in this IFD
        wNumDirEntries = (WORD) *(LPWORD) (pTiffInstanceData->fPtr + IFDOffset);

        // Set the tag pointer
        pTiffTag = (PTIFF_TAG) (pTiffInstanceData->fPtr +IFDOffset + sizeof(WORD));

        // Get the tiff tags
        ImageWidth = -1;
        ImageLength = -1;
        Compression = -1;
        Photometric = -1;
        XResolution = -1;
        YResolution = -1;
        Software = NULL;

        for (wIndex = 0; wIndex < wNumDirEntries; wIndex++) {
            switch (pTiffTag[wIndex].TagId) {
                case TIFFTAG_IMAGEWIDTH:
                    ImageWidth = GetTagData(pTiffInstanceData->fPtr, 0, &pTiffTag[wIndex]);
                    break;

                case TIFFTAG_IMAGELENGTH:
                    ImageLength = GetTagData(pTiffInstanceData->fPtr, 0, &pTiffTag[wIndex]);
                    break;

                case TIFFTAG_COMPRESSION:
                    Compression = GetTagData(pTiffInstanceData->fPtr, 0, &pTiffTag[wIndex]);
                    break;

                case TIFFTAG_PHOTOMETRIC:
                    Photometric = GetTagData(pTiffInstanceData->fPtr, 0, &pTiffTag[wIndex]);
                    break;

                case TIFFTAG_XRESOLUTION:
                    XResolution = GetTagData(pTiffInstanceData->fPtr, 0, &pTiffTag[wIndex]);
                    break;

                case TIFFTAG_YRESOLUTION:
                    YResolution = GetTagData(pTiffInstanceData->fPtr, 0, &pTiffTag[wIndex]);
                    break;

                case TIFFTAG_SOFTWARE:
                    SoftwareBuffer = (LPSTR) (DWORD UNALIGNED *) (pTiffInstanceData->fPtr + pTiffTag[wIndex].DataOffset);
                    Software = MemAllocMacro((lstrlenA(SOFTWARE_REF) + 1) * sizeof(CHAR));
                    lstrcpynA(Software, SoftwareBuffer, (lstrlenA(SOFTWARE_REF) + 1));
                    break;
            }
        }

        if ((ImageWidth < (IMAGEWIDTH_REF - (IMAGEWIDTH_REF * .1))) || (ImageWidth > (IMAGEWIDTH_REF + (IMAGEWIDTH_REF * .1)))) {
            uFlags = IDS_TIFF_INVALID_IMAGEWIDTH;
            goto InvalidFax;
        }

        if (YResolution == 196) {
            ImageLengthRef = IMAGELENGTH_200_REF;
        }
        else if (YResolution == 98) {
            ImageLengthRef = IMAGELENGTH_100_REF;
        }
        else {
            uFlags = IDS_TIFF_INVALID_YRESOLUTION;
            goto InvalidFax;
        }
        if ((ImageLength < (ImageLengthRef - (ImageLengthRef * .1))) || (ImageLength > (ImageLengthRef + (ImageLengthRef * .1)))) {
            uFlags = IDS_TIFF_INVALID_IMAGELENGTH;
            goto InvalidFax;
        }

        if (Compression != 4) {
            uFlags = IDS_TIFF_INVALID_COMPRESSION;
            goto InvalidFax;
        }

        if (Photometric != 0) {
            uFlags = IDS_TIFF_INVALID_PHOTOMETRIC;
            goto InvalidFax;
        }

        if (XResolution != 204) {
            uFlags = IDS_TIFF_INVALID_XRESOLUTION;
            goto InvalidFax;
        }

        if ((YResolution != 196) && (YResolution != 98)) {
            uFlags = IDS_TIFF_INVALID_YRESOLUTION;
            goto InvalidFax;
        }

        if (lstrcmpA(SOFTWARE_REF, Software)) {
            uFlags = IDS_TIFF_INVALID_SOFTWARE;
            goto InvalidFax;
        }

        MemFreeMacro(Software);

        // Get the next IFD offset
        IFDOffset = (DWORD) *(DWORD UNALIGNED *) (pTiffInstanceData->fPtr + (wNumDirEntries * sizeof(TIFF_TAG)) + IFDOffset + sizeof(WORD));
    }

    TiffClose(hTiffFile);
    return ERROR_SUCCESS;

InvalidFax:
    if (Software) {
        MemFreeMacro(Software);
    }

    TiffClose(hTiffFile);
    return uFlags;
}

VOID
fnEnableFaxRcv(
    BOOL  bEnable
)
/*++

Routine Description:

  Enables or disables the FaxRcv Routing Extension

Arguments:

  bEnable - indicates whether to enable or disable the FaxRcv Routing Extension
            TRUE enables the FaxRcv Routing Extension
            FALSE enables the FaxRcv Routing Extension

Return Value:

  None

--*/
{
    // hFaxRcvExtKey is the handle to the FaxRcv Extension Registry key
    HKEY  hFaxRcvExtKey;

    // Open the FaxRcv Extension Registry key
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, FAXRCV_EXT_REGKEY, 0, KEY_ALL_ACCESS, &hFaxRcvExtKey) != ERROR_SUCCESS) {
        return;
    }

    // Set the FaxRcv Extension bEnable Registry value
    if (RegSetValueEx(hFaxRcvExtKey, BENABLE_EXT_REGVAL, 0, REG_DWORD, (LPBYTE) &bEnable, sizeof(BOOL)) != ERROR_SUCCESS) {
        // Close the FaxRcv Extension Registry key
        RegCloseKey(hFaxRcvExtKey);
        return;
    }

    // Close the FaxRcv Extension Registry key
    RegCloseKey(hFaxRcvExtKey);
}

VOID WINAPI
fnRasDialCallback(
    UINT          uMsg,
    RASCONNSTATE  RasConnState,
    DWORD         dwError
)
/*++

Routine Description:

  Callback function for the change of state during the RAS connection process

Arguments:

  uMsg - type of event
  RasConnState - state
  dwError - error

Return Value:

  None

--*/
{
    static BOOL    bError = FALSE;

    if ((dwError) && (!bError)) {
        bError = TRUE;
        // Update the status
        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_RAS_FAILED, dwError);
        SetEvent(g_hRasFailedEvent);
    }
    else if (RasConnState == RASCS_OpenPort) {
        bError = FALSE;
    }
    else if (RasConnState == RASCS_ConnectDevice) {
        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_RAS_DIALING, 0);
    }
    else if (RasConnState == RASCS_Authenticate) {
        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_RAS_AUTHENTICATING, 0);
    }
    else if (RasConnState == RASCS_Connected) {
        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_RAS_CONNECTED, 0);
        SetEvent(g_hRasPassedEvent);
    }

    return;
}

UINT
fnSendRas(
    LPHANDLE  phFaxStopRasPassFailEvents
)
/*++

Routine Description:

  Sends a RAS call

Arguments:

  phFaxStopSendPassFailEvents - pointer to the g_hFaxEvent, g_hStopEvent, g_hRasPassedEvent and g_hRasFailedEvent

Return Value:

  UINT - resource id

--*/
{
    DWORD_PTR  dwRslt;
    UINT   uRslt;

    // RasDialParams is the RAS dial params
    RASDIALPARAMS  RasDialParams;
    // hRasConn is the handle to the RAS connection
    HRASCONN       hRasConn;
    // RasConnStatus is the RAS connection status
    RASCONNSTATUS  RasConnStatus;
    // RasStats are the RAS connection statistics
    RAS_STATS      RasStats;
    // RasInfo is the RAS connection info
    RAS_INFO       RasInfo;

    // Initialize hRasConn
    hRasConn = NULL;

    // Initialize RasDialParams
    ZeroMemory(&RasDialParams, sizeof(RASDIALPARAMS));

    // Set RasDialParams
    RasDialParams.dwSize = sizeof(RASDIALPARAMS);
    lstrcpy(RasDialParams.szPhoneNumber, g_szSndNumber);
    lstrcpy(RasDialParams.szUserName, g_szRasUserName);
    lstrcpy(RasDialParams.szPassword, g_szRasPassword);
    lstrcpy(RasDialParams.szDomain, g_szRasDomain);

    // Update the status
    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_RAS_STARTING, (LPARAM) g_szSndNumber);

    // Start the RAS session
    ResetEvent(g_hRasPassedEvent);
    ResetEvent(g_hRasFailedEvent);
    dwRslt = g_RasApi.RasDial(NULL, NULL, &RasDialParams, 0, fnRasDialCallback, &hRasConn);

    if (dwRslt != 0) {
        // Update the status
        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_RAS_FAILED, dwRslt);

        return IDS_STATUS_RAS_FAILED;
    }


    // Wait for Fax, Stop, RAS Passed or RAS Failed event
    dwRslt = WaitForMultipleObjects(4, phFaxStopRasPassFailEvents, FALSE, INFINITE);

    switch (dwRslt) {
        case WAIT_OBJECT_0:
            uRslt = IDS_STATUS_FAXSVC_ENDED;
            break;

        case (WAIT_OBJECT_0 + 1):
            uRslt = IDS_STATUS_ITERATION_STOPPED;
            break;

        case (WAIT_OBJECT_0 + 2):
            uRslt = IDS_STATUS_RAS_PASSED;
            break;

        case (WAIT_OBJECT_0 + 3):
            uRslt = IDS_STATUS_RAS_FAILED;
            break;
    }

    if (uRslt != IDS_STATUS_RAS_PASSED) {
        // Update the status
        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_RAS_STOPPING, 0);
        // Stop the RAS session
        g_RasApi.RasHangUp(hRasConn);
        if (uRslt != IDS_STATUS_RAS_FAILED) {
            WaitForSingleObject(g_hRasFailedEvent, INFINITE);
        }

        return uRslt;
    }

    // Initialize RasConnStatus
    ZeroMemory(&RasConnStatus, sizeof(RASCONNSTATUS));
    // Set RasConnStatus
    RasConnStatus.dwSize = sizeof(RASCONNSTATUS);
    // Get the RAS connection status
    g_RasApi.RasGetConnectStatus(hRasConn, &RasConnStatus);

    // Initialize RasStats
    ZeroMemory(&RasStats, sizeof(RAS_STATS));
    // Set RasStats
    RasStats.dwSize = sizeof(RAS_STATS);
    // Get the connection statistics
    g_RasApi.RasGetConnectionStatistics(hRasConn, &RasStats);

    // Set the line speed
    RasInfo.dwBps = RasStats.dwBps;
    // Set the port name
    RasInfo.szDeviceName = RasConnStatus.szDeviceName;

    // Update the status
    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_RAS_LINESPEED, (LPARAM) &RasInfo);

    if (RasStats.dwBps < SUSPECT_RAS_SPEED) {
        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_RAS_SPEED_SUSPECT, SUSPECT_RAS_SPEED);
    }
    else {
        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_RAS_PASSED, 0);
    }

    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_RAS_STOPPING, 0);

    // Stop the RAS session
    g_RasApi.RasHangUp(hRasConn);

    return IDS_STATUS_RAS_PASSED;
}

UINT
fnSendFax(
    FAX_JOB_PARAM  FaxJobParams,
    LPWSTR         szDocumentName,
    LPHANDLE       phFaxStopSendPassFailEvents,
    DWORD          dwSendTimeout
)
/*++

Routine Description:

  Sends a fax

Arguments:

  FaxJobParams - fax job parameters
  szDocumentName - name of document to send
  phFaxStopSendPassFailEvents - pointer to the g_hFaxEvent, g_hStopEvent, g_hSendPassedEvent and g_hSendFailedEvent
  dwSendTimeout - send timeout interval

Return Value:

  UINT - resource id

--*/
{
    DWORD  dwRslt;
    UINT   uRslt;

    // Update the status
    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_STARTING, (LPARAM) FaxJobParams.RecipientNumber);

    if (!g_bNoCheck) {
        // Update the status
        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_ID, (LPARAM) FaxJobParams.Tsid);
    }

    // Send a fax
    if (!FaxSendDocument(g_hFaxSvcHandle, szDocumentName, &FaxJobParams, NULL, &g_dwFaxId)) {
        return IDS_STATUS_FAX_SEND_FAILED;
    }

    g_bFaxSndInProgress = TRUE;
    g_dwAttempt = 0;

    // Wait for Fax, Stop, Send Passed or Send Failed event
    dwRslt = WaitForMultipleObjects(4, phFaxStopSendPassFailEvents, FALSE, dwSendTimeout);

    g_bFaxSndInProgress = FALSE;

    switch (dwRslt) {
        case WAIT_TIMEOUT:
            uRslt = IDS_STATUS_TIMEOUT_ENDED;
            break;

        case WAIT_OBJECT_0:
            uRslt = IDS_STATUS_FAXSVC_ENDED;
            break;

        case (WAIT_OBJECT_0 + 1):
            uRslt = IDS_STATUS_ITERATION_STOPPED;
            break;

        case (WAIT_OBJECT_0 + 2):
            uRslt = IDS_STATUS_FAX_SEND_PASSED;
            break;

        case (WAIT_OBJECT_0 + 3):
            uRslt = IDS_STATUS_FAX_SEND_FAILED;
            break;
    }

    if (uRslt != IDS_STATUS_FAX_SEND_PASSED) {
        if (uRslt == IDS_STATUS_ITERATION_STOPPED) {
            SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_STOPPING, 0);
        }

        FaxAbort(g_hFaxSvcHandle, g_dwFaxId);

        return uRslt;
    }

    return IDS_STATUS_FAX_SEND_PASSED;
}

UINT
fnReceiveFax(
    LPHANDLE  phFaxStopRcvEvents,
    DWORD     dwReceiveTimeout,
    LPWSTR    szTsid,
    DWORD     dwTsidSize,
    LPWSTR    szCopyTiffFile,
    DWORD     dwCopyTiffFileSize,
    LPWSTR    szCopyTiffName,
    DWORD     dwCopyTiffNameSize
)
/*++

Routine Description:

  Receives a fax

Arguments:

  phFaxStopRcvEvents - pointer to the g_hFaxEvent, g_hStopEvent and hFaxRcvEvent
  dwReceiveTimeout - receive timeout interval
  szTsid - TSID of the received fax
  dwTsidSize - size of szTsid buffer, in bytes
  szCopyTiffFile - name of the copy of the received fax
  dwCopyTiffFileSize - size of szCopyTiffFile buffer, in bytes
  szCopyTiffName - name of the copy of the received fax
  dwCopyTiffNameSize - size of szCopyTiffName buffer, in bytes

Return Value:

  UINT - resource id

--*/
{
    // hFaxRcvEvent is the handle to the FaxRcv named event
    HANDLE            hFaxRcvEvent;
    // hFaxRcvMutex is the handle to the FaxRcv named mutex
    HANDLE            hFaxRcvMutex;

    // hFaxRcvMap is the handle to the FaxRcv memory map
    HANDLE            hFaxRcvMap;
    // pFaxRcvView is the pointer to the FaxRcv memory map view
    LPBYTE            pFaxRcvView;

    // szTiffFile is the name of the received fax
    LPWSTR            szTiffFile;
    // szFile is the name of the received fax
    WCHAR             szFile[_MAX_FNAME];
    // szExt is the extension of the received fax
    WCHAR             szExt[_MAX_EXT];

    // FaxReceiveInfo is the fax receive info
    FAX_RECEIVE_INFO  FaxReceiveInfo;

    DWORD             dwRslt;
    UINT              uRslt;
    UINT_PTR          upOffset;

    // Update the status
    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_WAITING, 0);

    // Open FaxRcv named event
    hFaxRcvEvent = OpenEvent(SYNCHRONIZE, FALSE, FAXRCV_EVENT);
    // Open FaxRcv named mutex
    hFaxRcvMutex = OpenMutex(SYNCHRONIZE, FALSE, FAXRCV_MUTEX);

    if ((!hFaxRcvEvent) || (!hFaxRcvMutex)) {
        if (hFaxRcvEvent) {
            CloseHandle(hFaxRcvEvent);
        }
        if (hFaxRcvMutex) {
            CloseHandle(hFaxRcvMutex);
        }

        return IDS_STATUS_FAXSVC_ENDED;
    }

    // Update phFaxStopRcvEvents
    // hFaxRcvEvent
    phFaxStopRcvEvents[2] = hFaxRcvEvent;

    // Wait for FaxRcv named mutex
    WaitForSingleObject(hFaxRcvMutex, INFINITE);
    // Enable the FaxRcv Routing Extension
    fnEnableFaxRcv(TRUE);
    // Release access to the FaxRcv named mutex
    ReleaseMutex(hFaxRcvMutex);

    g_bFaxRcvInProgress = TRUE;

    // Wait for Fax, Stop or FaxRcv named event
    dwRslt = WaitForMultipleObjects(3, phFaxStopRcvEvents, FALSE, dwReceiveTimeout);

    g_bFaxRcvInProgress = FALSE;

    // Wait for FaxRcv named mutex
    WaitForSingleObject(hFaxRcvMutex, INFINITE);
    // Disable the FaxRcv Routing Extension
    fnEnableFaxRcv(FALSE);

    switch (dwRslt) {
        case WAIT_TIMEOUT:
            uRslt = IDS_STATUS_TIMEOUT_ENDED;
            break;

        case WAIT_OBJECT_0:
            uRslt = IDS_STATUS_FAXSVC_ENDED;
            break;

        case (WAIT_OBJECT_0 + 1):
            uRslt = IDS_STATUS_ITERATION_STOPPED;
            break;

        case (WAIT_OBJECT_0 + 2):
            uRslt = IDS_STATUS_FAX_RECEIVED;
            break;

    }

    if (uRslt != IDS_STATUS_FAX_RECEIVED) {
        // Release access to the FaxRcv named mutex
        ReleaseMutex(hFaxRcvMutex);

        CloseHandle(hFaxRcvEvent);
        CloseHandle(hFaxRcvMutex);

        return uRslt;
    }

    // Open FaxRcv memory map
    hFaxRcvMap = OpenFileMapping(FILE_MAP_READ, FALSE, FAXRCV_MAP);
    if (!hFaxRcvMap) {
        // Release access to the FaxRcv named mutex
        ReleaseMutex(hFaxRcvMutex);

        CloseHandle(hFaxRcvEvent);
        CloseHandle(hFaxRcvMutex);

        return IDS_STATUS_FAXSVC_ENDED;
    }

    // Create FaxRcv memory map view
    pFaxRcvView = (LPBYTE) MapViewOfFile(hFaxRcvMap, FILE_MAP_READ, 0, 0, 0);

    // Set upOffset
    upOffset = 0;

    // Set szTiffFile
    szTiffFile = MemAllocMacro((lstrlen((LPWSTR) ((UINT_PTR) pFaxRcvView + upOffset)) + 1) * sizeof(WCHAR));
    lstrcpy(szTiffFile, (LPWSTR) ((UINT_PTR) pFaxRcvView + upOffset));
    upOffset += (lstrlen(szTiffFile) + 1) * sizeof(WCHAR);

    // Initialize szTsid
    ZeroMemory(szTsid, dwTsidSize);
    // Set szTsid
    lstrcpy(szTsid, (LPWSTR) ((UINT_PTR) pFaxRcvView + upOffset));
    upOffset += (lstrlen(szTsid) + 1) * sizeof(WCHAR);

    // Set FaxReceiveInfo.dwDeviceId
    FaxReceiveInfo.dwDeviceId = (DWORD) *(LPDWORD) ((UINT_PTR) pFaxRcvView + upOffset);

    // Close FaxRcv memory map view
    UnmapViewOfFile(pFaxRcvView);
    // Close FaxRcv memory map
    CloseHandle(hFaxRcvMap);

    _wsplitpath(szTiffFile, NULL, NULL, szFile, szExt);

    // Initialize szCopyTiffFile
    ZeroMemory(szCopyTiffFile, dwCopyTiffFileSize * sizeof(WCHAR));
    // Set szCopyTiffFile
    GetCurrentDirectory(dwCopyTiffFileSize, szCopyTiffFile);
    lstrcat(szCopyTiffFile, L"\\");
    lstrcat(szCopyTiffFile, (LPWSTR) ((UINT_PTR) szFile + lstrlen(L"Copy of ") * sizeof(WCHAR)));
    lstrcat(szCopyTiffFile, szExt);

    // Initialize szCopyTiffName
    ZeroMemory(szCopyTiffName, dwCopyTiffNameSize);
    // Set szCopyTiffName
    lstrcpy(szCopyTiffName, (LPWSTR) ((UINT_PTR) szFile + lstrlen(L"Copy of ") * sizeof(WCHAR)));
    lstrcat(szCopyTiffName, szExt);

    // Set FaxReceiveInfo.szCopyTiffName
    FaxReceiveInfo.szCopyTiffName = szCopyTiffName;

    // Copy szTiffFile to szCopyTiffFile
    CopyFile(szTiffFile, szCopyTiffFile, FALSE);

    // Delete the received fax
    DeleteFile(szTiffFile);

    // Free szTiffFile
    MemFreeMacro(szTiffFile);

    // Release access to the FaxRcv named mutex
    ReleaseMutex(hFaxRcvMutex);

    CloseHandle(hFaxRcvEvent);
    CloseHandle(hFaxRcvMutex);

    // Update the status
    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_RECEIVED, (LPARAM) &FaxReceiveInfo);

    return IDS_STATUS_FAX_RECEIVED;
}

DWORD WINAPI fnSendProc (LPVOID lpv)
/*++

Routine Description:

  Thread to handle the Send logic

Return Value:

  DWORD - exit code

--*/
{
    // hFaxExitStartEvents is a pointer to the g_hFaxEvent, g_hExitEvent and g_hStartEvent
    HANDLE         hFaxExitStartEvents[3];
    // hFaxStopRasPassFailEvents is a pointer to the g_hFaxEvent, g_hStopEvent, g_hRasPassedEvent and g_hRasFailedEvent
    HANDLE         hFaxStopRasPassFailEvents[4];
    // hFaxStopSendPassFailEvents is a pointer to the g_hFaxEvent, g_hStopEvent, g_hSendPassedEvent and g_hSendFailedEvent
    HANDLE         hFaxStopSendPassFailEvents[4];
    // hFaxStopRcvEvents is a pointer to the g_hFaxEvent, g_hStopEvent and g_hFaxRcvEvent
    HANDLE         hFaxStopRcvEvents[3];

    // dwSendTimeout is the send timeout interval
    DWORD          dwSendTimeout;
    // dwReceiveTimeout is the receive timeout interval
    DWORD          dwReceiveTimeout;

    // szOriginalTiffFile is the name of the original tiff file
    LPWSTR         szOriginalTiffFile;
    // dwNumFaxesToSend is the number of faxes to be sent
    DWORD          dwNumFaxesToSend;
    // dwNumFaxesRemaining is the number of faxes remaining to be sent
    DWORD          dwNumFaxesRemaining;

    // FaxJobParams is the fax job params
    FAX_JOB_PARAM  FaxJobParams;

    // szCopyTiffFile is the name of the copy of the received fax
    WCHAR          szCopyTiffFile[_MAX_PATH];
    // szCopyTiffName is the name of the copy of the received fax
    WCHAR          szCopyTiffName[_MAX_FNAME + _MAX_EXT];
    // szReceivedTsid is the received TSID
    WCHAR          szReceivedTsid[ENCODE_CHAR_LEN + CONTROL_CHAR_LEN + PHONE_NUM_LEN + 1];
    // szEncodedTsid is the encoded TSID
    WCHAR          szEncodedTsid[ENCODE_CHAR_LEN + CONTROL_CHAR_LEN + PHONE_NUM_LEN + 1];
    // szDecodedTsid is the decoded TSID
    WCHAR          szDecodedTsid[PHONE_NUM_LEN + 1];

    DWORD          dwPages;
    DWORD          dwRslt;
    UINT           uRslt;

    // Set hFaxExitStartEvents
    // g_hFaxEvent
    hFaxExitStartEvents[0] = g_hFaxEvent;
    // g_hExitEvent
    hFaxExitStartEvents[1] = g_hExitEvent;
    // g_hStartEvent
    hFaxExitStartEvents[2] = g_hStartEvent;

    // Set hFaxStopRasPassFailEvents
    // g_hFaxEvent
    hFaxStopRasPassFailEvents[0] = g_hFaxEvent;
    // g_hStopEvent
    hFaxStopRasPassFailEvents[1] = g_hStopEvent;
    // g_hPassEvent
    hFaxStopRasPassFailEvents[2] = g_hRasPassedEvent;
    // g_hFailEvent
    hFaxStopRasPassFailEvents[3] = g_hRasFailedEvent;

    // Set hFaxStopSendPassFailEvents
    // g_hFaxEvent
    hFaxStopSendPassFailEvents[0] = g_hFaxEvent;
    // g_hStopEvent
    hFaxStopSendPassFailEvents[1] = g_hStopEvent;
    // g_hSendPassedEvent
    hFaxStopSendPassFailEvents[2] = g_hSendPassedEvent;
    // g_hSendFailedEvent
    hFaxStopSendPassFailEvents[3] = g_hSendFailedEvent;

    // Set hFaxStopRcvEvents
    // g_hFaxEvent
    hFaxStopRcvEvents[0] = g_hFaxEvent;
    // g_hStopEvent
    hFaxStopRcvEvents[1] = g_hStopEvent;

    if (g_bBVT) {
        dwSendTimeout = FAXSVC_RETRIES * ((FAXSVC_RETRIES + 1) * FAXSVC_RETRYDELAY) * 60000;
        dwReceiveTimeout = dwSendTimeout * 2;

        szOriginalTiffFile = FAXBVT_TIF;

        dwNumFaxesToSend = FAXBVT_NUM_FAXES;
        dwNumFaxesRemaining = dwNumFaxesToSend;
    }
    else {
        dwSendTimeout = INFINITE;
        dwReceiveTimeout = INFINITE;

        szOriginalTiffFile = FAXWHQL_TIF;

        dwNumFaxesToSend = FAXWHQL_NUM_FAXES;
        dwNumFaxesRemaining = dwNumFaxesToSend;
    }

    while (TRUE) {
        // Wait for Fax, Exit, or Start event
        dwRslt = WaitForMultipleObjects(3, hFaxExitStartEvents, FALSE, INFINITE);

        if (dwRslt == WAIT_OBJECT_0) {
            SendMessage(g_hWndDlg, UM_FAXSVC_ENDED, 0, 0);
            continue;
        }
        else if (dwRslt == (WAIT_OBJECT_0 + 1)) {
            return 0;
        }

        if (g_bSend) {
            if (g_bRasEnabled) {
                // Send a RAS call
                uRslt = fnSendRas(hFaxStopRasPassFailEvents);

                if (uRslt != IDS_STATUS_RAS_PASSED) {
                    switch (uRslt) {
                        case IDS_STATUS_TIMEOUT_ENDED:
                            SendMessage(g_hWndDlg, UM_TIMEOUT_ENDED, 0, 0);
                            break;

                        case IDS_STATUS_FAXSVC_ENDED:
                            SendMessage(g_hWndDlg, UM_FAXSVC_ENDED, 0, 0);
                            break;

                        case IDS_STATUS_ITERATION_STOPPED:
                            SendMessage(g_hWndDlg, UM_ITERATION_STOPPED, 0, 0);
                            break;

                        case IDS_STATUS_RAS_FAILED:
                            SendMessage(g_hWndDlg, UM_ITERATION_FAILED, 0, 0);
                            break;

                    }

                    dwNumFaxesRemaining = dwNumFaxesToSend;

                    continue;
                }
            }

            // Encode the TSID
            if (!g_bNoCheck) {
                fnEncodeTsid(g_szRcvNumber, TX_CONTROL_CHARS, szEncodedTsid);
            }
            else {
                lstrcpy(szEncodedTsid, g_szSndNumber);
            }

            // Initialize FaxJobParams
            ZeroMemory(&FaxJobParams, sizeof(FAX_JOB_PARAM));

            // Set FaxJobParams
            FaxJobParams.SizeOfStruct = sizeof(FAX_JOB_PARAM);
            FaxJobParams.RecipientNumber = g_szSndNumber;
            FaxJobParams.RecipientName = g_szSndNumber;
            FaxJobParams.Tsid = szEncodedTsid;
            FaxJobParams.ScheduleAction = JSA_NOW;

            // Send a fax
            uRslt = fnSendFax(FaxJobParams, szOriginalTiffFile, hFaxStopSendPassFailEvents, dwSendTimeout);

            if (uRslt != IDS_STATUS_FAX_SEND_PASSED) {
                switch (uRslt) {
                    case IDS_STATUS_TIMEOUT_ENDED:
                        SendMessage(g_hWndDlg, UM_TIMEOUT_ENDED, 0, 0);
                        break;

                    case IDS_STATUS_FAXSVC_ENDED:
                        SendMessage(g_hWndDlg, UM_FAXSVC_ENDED, 0, 0);
                        break;

                    case IDS_STATUS_ITERATION_STOPPED:
                        SendMessage(g_hWndDlg, UM_ITERATION_STOPPED, 0, 0);
                        break;

                    case IDS_STATUS_FAX_SEND_FAILED:
                        SendMessage(g_hWndDlg, UM_ITERATION_FAILED, 0, 0);
                        break;

                }

                dwNumFaxesRemaining = dwNumFaxesToSend;

                continue;
            }
        }

        // Receive a fax
        uRslt = fnReceiveFax(hFaxStopRcvEvents, dwReceiveTimeout, szReceivedTsid, sizeof(szReceivedTsid) / sizeof(WCHAR), szCopyTiffFile, sizeof(szCopyTiffFile) / sizeof(WCHAR), szCopyTiffName, sizeof(szCopyTiffName) / sizeof(WCHAR));

        if (uRslt != IDS_STATUS_FAX_RECEIVED) {
            switch (uRslt) {
                case IDS_STATUS_TIMEOUT_ENDED:
                    SendMessage(g_hWndDlg, UM_TIMEOUT_ENDED, 0, 0);
                    break;

                case IDS_STATUS_FAXSVC_ENDED:
                    SendMessage(g_hWndDlg, UM_FAXSVC_ENDED, 0, 0);
                    break;

                case IDS_STATUS_ITERATION_STOPPED:
                    SendMessage(g_hWndDlg, UM_ITERATION_STOPPED, 0, 0);
                    break;

            }

            if (g_bSend) {
                if (uRslt != IDS_STATUS_ITERATION_STOPPED) {
                    // This iteration failed
                    SendMessage(g_hWndDlg, UM_ITERATION_FAILED, 0, 0);
                }
                // Reset the number of faxes remaining to be sent
                dwNumFaxesRemaining = dwNumFaxesToSend;
            }

            continue;
        }

        if (!g_bNoCheck) {
            if (!fnDecodeTsid(szReceivedTsid, g_bSend ? RX_CONTROL_CHARS : TX_CONTROL_CHARS, szDecodedTsid)) {
                // Update the status
                SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_INVALID, 0);

                if (g_bSend) {
                    // This iteration failed
                    SendMessage(g_hWndDlg, UM_ITERATION_FAILED, 0, 0);
                    // Reset the number of faxes remaining to be sent
                    dwNumFaxesRemaining = dwNumFaxesToSend;
                }
                else {
                    // Set the g_hStartEvent to start another cycle to receive a fax
                    SetEvent(g_hStartEvent);
                }

                continue;
            }

            // Update the status
            SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_ID, (LPARAM) szReceivedTsid);
            SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_VERIFYING, (LPARAM) szCopyTiffName);

            // Verify the tiff
            uRslt = fnVerifyTiff(szCopyTiffFile, &dwPages);

            if ((uRslt == ERROR_SUCCESS) && (((g_bBVT) && (dwPages == FAXBVT_PAGES)) || ((!g_bBVT) && (dwPages == FAXWHQL_PAGES)))) {
                // Fax is valid
                uRslt = IDS_TIFF_VALID_TIFF;
            }
            else if (uRslt == ERROR_SUCCESS) {
                // Each page is valid, but missing pages
                uRslt = IDS_TIFF_INVALID_PAGES;
            }

            if (uRslt == IDS_TIFF_INVALID_PAGES) {
                // Update the status
                SendMessage(g_hWndDlg, UM_UPDATE_STATUS, uRslt, dwPages);
            }
            else {
                // Update the status
                SendMessage(g_hWndDlg, UM_UPDATE_STATUS, uRslt, 0);
            }

        }
        else {
            lstrcpy(szDecodedTsid, szReceivedTsid);
            uRslt = IDS_TIFF_VALID_TIFF;
        }

        if ((g_bSend) && (uRslt == IDS_TIFF_VALID_TIFF)) {
            // Decrement the number of faxes remaining to be sent
            dwNumFaxesRemaining--;

            if (dwNumFaxesRemaining == 0) {
                // All faxes have been sent, so this iteration passed
                SendMessage(g_hWndDlg, UM_ITERATION_PASSED, 0, 0);
                // Reset the number of faxes remaining to be sent
                dwNumFaxesRemaining = dwNumFaxesToSend;
            }
            else {
                // There are faxes remaining to be sent, so set the g_hStartEvent to start another cycle to send a fax
                SetEvent(g_hStartEvent);
            }

            continue;
        }
        else if (g_bSend) {
            // This iteration failed
            SendMessage(g_hWndDlg, UM_ITERATION_FAILED, 0, 0);
            // Reset the number of faxes remaining to be sent
            dwNumFaxesRemaining = dwNumFaxesToSend;

            continue;
        }
        else if (uRslt != IDS_TIFF_VALID_TIFF) {
            // Set the g_hStartEvent to start another cycle to receive a fax
            SetEvent(g_hStartEvent);

            continue;
        }

        if (!g_bSend) {
            // Encode the TSID
            if (!g_bNoCheck) {
                fnEncodeTsid(szDecodedTsid, RX_CONTROL_CHARS, szEncodedTsid);
            }
            else {
                lstrcpy(szEncodedTsid, szDecodedTsid);
            }

            // Initialize FaxJobParams
            ZeroMemory(&FaxJobParams, sizeof(FAX_JOB_PARAM));

            // Set FaxJobParams
            FaxJobParams.SizeOfStruct = sizeof(FAX_JOB_PARAM);
            FaxJobParams.RecipientNumber = szDecodedTsid;
            FaxJobParams.RecipientName = szDecodedTsid;
            FaxJobParams.Tsid = szEncodedTsid;
            FaxJobParams.ScheduleAction = JSA_NOW;

            // Send a fax
            uRslt = fnSendFax(FaxJobParams, szCopyTiffFile, hFaxStopSendPassFailEvents, dwSendTimeout);

            switch (uRslt) {
                case IDS_STATUS_TIMEOUT_ENDED:
                    SendMessage(g_hWndDlg, UM_TIMEOUT_ENDED, 0, 0);
                    break;

                case IDS_STATUS_FAXSVC_ENDED:
                    SendMessage(g_hWndDlg, UM_FAXSVC_ENDED, 0, 0);
                    break;

                case IDS_STATUS_ITERATION_STOPPED:
                    SendMessage(g_hWndDlg, UM_ITERATION_STOPPED, 0, 0);
                    break;

                case IDS_STATUS_FAX_SEND_PASSED:
                case IDS_STATUS_FAX_SEND_FAILED:
                    break;

            }

            if ((uRslt == IDS_STATUS_FAX_SEND_PASSED) || (uRslt == IDS_STATUS_FAX_SEND_FAILED)) {
                if (g_bBVT) {
                    SendMessage(g_hWndDlg, UM_ITERATION_STOPPED, 0, 0);
                    SendMessage(GetDlgItem(g_hWndDlg, IDC_EXIT_BUTTON), BM_CLICK, 0, 0);
                }
                else {
                    // Set the g_hStartEvent to start another cycle to wait for a fax
                    SetEvent(g_hStartEvent);
                }
            }

            continue;

        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\test\faxvrfy\util.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  util.c

Abstract:

  This module:
    1) Finds the device name of a port
    2) Initializes NTLog
    3) Starts the log file
    4) Closes the log file
    5) Gets the current time
    6) Writes a string to the log and text files
    7) Checks if an edit control string is composed of only ASCII characters
    8) Encodes a TSID
    9) Decodes a TSID

Author:

  Steven Kehrli (steveke) 11/15/1997

--*/

#ifndef _UTIL_C
#define _UTIL_C

VOID
fnFindDeviceName(
    PFAX_PORT_INFO  pFaxPortsConfig,
    DWORD           dwNumPorts,
    DWORD           dwDeviceId,
    LPWSTR          *pszDeviceName
)
/*++

Routine Description:

  Finds the device name of a port

Arguments:

  pFaxPortsConfig - pointer to the fax ports configuration
  dwNumFaxPorts - number of ports
  dwDeviceId - port id
  pszDeviceName - device name

Return Value:

  None

--*/
{
    // dwIndex is a counter to enumerate each port
    DWORD  dwIndex;

    // Set szDeviceName to NULL
    *pszDeviceName = NULL;

    for (dwIndex = 0; dwIndex < dwNumPorts; dwIndex++) {
        // Search, by priority, each port for the appropriate port
        if (pFaxPortsConfig[dwIndex].DeviceId == dwDeviceId) {
            if (pFaxPortsConfig[dwIndex].DeviceName) {
                *pszDeviceName = (LPWSTR) pFaxPortsConfig[dwIndex].DeviceName;
            }
            return;
        }
    }
}

BOOL
fnInitializeNTLog(
)
/*++

Routine Description:

  Initializes NTLog

Return Value:

  TRUE on success

--*/
{
    // hInstance is the handle to the NTLog dll
    HINSTANCE  hInstance;

    // Get the handle to the NTLog dll
    hInstance = LoadLibrary((LPCWSTR) NTLOG_DLL);
    if (!hInstance) {
        DebugMacro(L"LoadLibrary(%s) failed, ec = 0x%08x\n", NTLOG_DLL, GetLastError());
        return FALSE;
    }

    // Map all needed functions

    g_NTLogApi.hInstance = hInstance;

    // tlCreateLog
    g_NTLogApi.ptlCreateLog = (PTLCREATELOG) GetProcAddress(hInstance, "tlCreateLog_W");

    if (!g_NTLogApi.ptlCreateLog) {
        DebugMacro(L"GetProcAddress(tlCreateLog) failed, ec = 0x%08x\n", GetLastError());
        FreeLibrary(hInstance);
        return FALSE;
    }

    // tlDestroyLog
    g_NTLogApi.ptlDestroyLog = (PTLDESTROYLOG) GetProcAddress(hInstance, "tlDestroyLog");

    if (!g_NTLogApi.ptlDestroyLog) {
        DebugMacro(L"GetProcAddress(tlDestroyLog) failed, ec = 0x%08x\n", GetLastError());
        FreeLibrary(hInstance);
        return FALSE;
    }

    // tlAddParticipant
    g_NTLogApi.ptlAddParticipant = (PTLADDPARTICIPANT) GetProcAddress(hInstance, "tlAddParticipant");

    if (!g_NTLogApi.ptlAddParticipant) {
        DebugMacro(L"GetProcAddress(tlAddParticipant) failed, ec = 0x%08x\n", GetLastError());
        FreeLibrary(hInstance);
        return FALSE;
    }

    // tlRemoveParticipant
    g_NTLogApi.ptlRemoveParticipant = (PTLREMOVEPARTICIPANT) GetProcAddress(hInstance, "tlRemoveParticipant");

    if (!g_NTLogApi.ptlRemoveParticipant) {
        DebugMacro(L"GetProcAddress(tlRemoveParticipant) failed, ec = 0x%08x\n", GetLastError());
        FreeLibrary(hInstance);
        return FALSE;
    }

    // tlLog
    g_NTLogApi.ptlLog = (PTLLOG) GetProcAddress(hInstance, "tlLog_W");

    if (!g_NTLogApi.ptlLog) {
        DebugMacro(L"GetProcAddress(tlLog) failed, ec = 0x%08x\n", GetLastError());
        FreeLibrary(hInstance);
        return FALSE;
    }

    return TRUE;
}

VOID
fnStartLogFile(
)
/*++

Routine Description:

  Starts the log file

Return Value:

  None

--*/
{
    // cUnicodeBOM is the Unicode BOM
    WCHAR  cUnicodeBOM = 0xFEFF;
    DWORD  cb;
    INT    iInt;

    // Create the new text log file
    g_hTxtFile = CreateFile(FAXVRFY_TXT, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    WriteFile(g_hTxtFile, &cUnicodeBOM, sizeof(WCHAR), &cb, NULL);

    // Create the new NTLog log file
    if (g_bNTLogAvailable) {
        g_hLogFile = (HANDLE) g_NTLogApi.ptlCreateLog(FAXVRFY_LOG, TLS_INFO | TLS_SEV2 | TLS_WARN | TLS_PASS | TLS_TEST | TLS_VARIATION | TLS_REFRESH);
        g_NTLogApi.ptlAddParticipant(g_hLogFile, 0, 0);
    }
}

VOID
fnCloseLogFile(
)
/*++

Routine Description:

  Closes the log file

Return Value:

  None

--*/
{
    CloseHandle(g_hTxtFile);

    if (g_bNTLogAvailable) {
        g_NTLogApi.ptlRemoveParticipant(g_hLogFile);
        g_NTLogApi.ptlDestroyLog(g_hLogFile);
        FreeLibrary(g_NTLogApi.hInstance);
    }
}

VOID
fnGetCurrentTime(
    LPWSTR  *szCurrentTime
)
/*++

Routine Description:

  Gets the current time

Arguments:

  szFaxTime - string representation of the current time

Return Value:

  None

--*/
{
    // CurrentTime is the current time
    SYSTEMTIME  CurrentTime;
    // lcid is the default locale
    LCID        lcid;
    // szDate is the date
    LPWSTR      szDate;
    // szTime is the time
    LPWSTR      szTime;
    DWORD       cb;

    // Set szCurrentTime to NULL
    *szCurrentTime = NULL;

    // Get the current time
    GetLocalTime(&CurrentTime);

    // Get the default locale
    lcid = GetUserDefaultLCID();

    // Determine the memory required by the date
    cb = GetDateFormat(lcid, DATE_SHORTDATE, &CurrentTime, NULL, NULL, 0);
    // Allocate the memory for the date
    szDate = MemAllocMacro(cb * sizeof(WCHAR));
    // Get the date
    GetDateFormat(lcid, DATE_SHORTDATE, &CurrentTime, NULL, szDate, cb);

    // Determine the memory required by the time
    cb = GetTimeFormat(lcid, TIME_FORCE24HOURFORMAT, &CurrentTime, NULL, NULL, 0);
    // Allocate the memory for the time
    szTime = MemAllocMacro(cb * sizeof(WCHAR));
    // Get the time
    GetTimeFormat(lcid, 0, &CurrentTime, NULL, szTime, cb);

    // Allocate the memory for the time of the fax
    *szCurrentTime = MemAllocMacro((lstrlen(szDate) + lstrlen(szTime) + 4) * sizeof(WCHAR));
    // Copy the date
    lstrcpy(*szCurrentTime, szDate);
    // Append a space
    lstrcat(*szCurrentTime, L" ");
    // Append the time
    lstrcat(*szCurrentTime, szTime);
    lstrcat(*szCurrentTime, L"\r\n");
}

VOID
fnWriteLogFile(
    BOOL    bTime,
    LPWSTR  szFormatString,
    ...
)
/*++

Routine Description:

  Writes a string to the log and text files

Arguments:

  bTime - indicates current time should be logged
  szFormatString - pointer to the string

Return Value:

  None

--*/
{
    va_list  varg_ptr;
    // szOutputString is the output string
    WCHAR    szOutputString[1024];
    // szCurrentTime is the current time
    LPWSTR   szCurrentTime;
    DWORD    cb;

    if (bTime) {
        // Get the current time
        fnGetCurrentTime(&szCurrentTime);

        WriteFile(g_hTxtFile, szCurrentTime, lstrlen(szCurrentTime) * sizeof(WCHAR), &cb, NULL);

        // Free the current time
        MemFreeMacro(szCurrentTime);
    }

    va_start(varg_ptr, szFormatString);
    _vsnwprintf(szOutputString, sizeof(szOutputString), szFormatString, varg_ptr);

    WriteFile(g_hTxtFile, szOutputString, lstrlen(szOutputString) * sizeof(WCHAR), &cb, NULL);
}

BOOL
fnIsStringASCII(
    LPWSTR  szString
)
/*++

Routine Description:

  Checks if a string is composed of only ASCII characters

Arguments:

  szString - string

Return Value:

  TRUE on success

--*/
{
    // szSearchString is the string used to search for non-ASCII characters
    LPWSTR  szSearchString;
    BOOL    bRslt;

    szSearchString = szString;
    bRslt = TRUE;

    while ((*szSearchString) && (bRslt)) {
        if ((*szSearchString < (WCHAR) 0x0020) || (*szSearchString >= (WCHAR) MAXCHAR)) {
            // Found a non-ASCII character
            bRslt = FALSE;
        }

        szSearchString = CharNext(szSearchString);
    }

    return bRslt;
}

BOOL
fnIsEditControlASCII(
    HWND   hWnd,
    UINT   uResource,
    DWORD  dwResourceLen
)
/*++

Routine Description:

  Checks if an edit control string is composed of only ASCII characters

Arguments:

  hWnd - handle to the window
  uResource - edit control resource id
  dwResourceLen - length of the edit control

Return Value:

  TRUE on success

--*/
{
    // szResourceString is the edit control string
    LPWSTR  szResourceString;
    BOOL    bRslt;

    bRslt = TRUE;

    // Allocate the memory for the edit control string
    szResourceString = MemAllocMacro(dwResourceLen * sizeof(WCHAR));

    // Get the edit control string
    GetDlgItemText(hWnd, uResource, szResourceString, dwResourceLen);

    bRslt = fnIsStringASCII(szResourceString);

    MemFreeMacro(szResourceString);

    return bRslt;
}

VOID
fnEncodeTsid(
    LPWSTR  szTsid,
    LPWSTR  szControlChars,
    LPWSTR  szEncodedTsid
)
/*++

Routine Description:

  Encodes a TSID

Arguments:

  szTsid - original TSID
  szControlChars - control characters to prepend TSID
  szEncodedTsid - encoded TSID

  Encoding a TSID is difficult.  Each ASCII value of the TSID must fall in the range 32 (0x0020) and 126 (0x009E), a range of 95.
  The TSID is encoded as follows:
     1) Prepend TSID with the control characters.  The control characters are used to verify FaxVrfy sent the fax.
     2) Create a random number based on wMilliseconds:
        1) wMilliseconds MOD 48 (0x0030): This gives a range of 0 - 48, half the ASCII value range of TSID
        2) Add 24 (0x0018): This moves the range to 24 - 72, guaranteeing the ASCII values of the TSID will be changed.
     3) Create a shift number based on the random number:
        1) wRandomNumber MOD (TSID length / 2): This gives a range of 0 - (TSID length / 2), half the TSID length
        2) Add (TSID length / 4): This moves the range to (TSID length / 4) - 3 * (TSID length / 4), guaranteeing the ASCII values of the TSID will be shifted.
     4) Create an intermediate string where each ASCII value of the intermediate string is
        1) Subtract 32 (0x0020) from each ASCII value of the TSID: This gives a range of 0 - 94.
        2) Add the random number
        3) MOD 95 (0x005F): This ensures each ASCII value of the intermediate string is in the range 0 - 94.
        4) Add 32 (0x0020): This moves the range back to 32 - 126.
     5) Create an array of pointers to each ASCII value of the encoded TSID
     6) Determine the appropriate offset in the encoded TSID
        1) Add the shift number to the current offset
        2) MOD (TSID length - wIndex): This ensures the offset is in the range 0 - (number of remaining offsets).
     7) Place the next ASCII value of the intermediate string into the appropriate offset in the encoded TSID
     8) Compact the remaining offsets of the encoded TSID
     9) Repeat steps 6 - 8 until all offsets have been used
    10) Create the final encoded string
        1) Add 32 (0x0020) to the random number: This ensure the random number is in the range 56 - 104.
        2) Set the first character of the encoded string to the ASCII value of the random number.
        3) Concatenate the encoded string with the encoded TSID

Return Value:

  None

--*/
{
    // szControlString is the TSID prepended by the control characters
    WCHAR       szControlString[CONTROL_CHAR_LEN + PHONE_NUM_LEN + 1] = {'\0'};
    // szEncodeChar is the encoding character
    WCHAR       szEncodeChar[ENCODE_CHAR_LEN + 1] = {'\0'};
    // szIntermediateString is the intermediate encoded string
    WCHAR      szIntermediateString[CONTROL_CHAR_LEN + PHONE_NUM_LEN + 1] = {'\0'};
    // szFinalString is the final encoded string
    WCHAR       szFinalString[CONTROL_CHAR_LEN + PHONE_NUM_LEN + 1] = {'\0'};
    // szShiftChars is an array of pointers to each ASCII value of the encoded TSID
    LPWSTR      szShiftChars[CONTROL_CHAR_LEN + PHONE_NUM_LEN + 1] = {'\0'};

    // SystemTime is the current system time where wMilliseconds is used to generate wRandomNumber and wShiftNumber
    SYSTEMTIME  SystemTime;
    // wRandomNumber is a number to increment each ASCII value of the TSID
    WORD        wRandomNumber;
    // wShiftNumber is a number to shift the order of each ASCII value of the TSID
    WORD        wShiftNumber;
    // wIndex is a counter to enumerate each ASCII value of the TSID
    WORD        wIndex;
    // wOffset is a counter to identify the appropriate offset of the encoded TSID when shifting each ASCII value of the TSID
    WORD        wOffset;
    // wCompact is a counter to compact the remaining offsets of the encoded TSID
    WORD        wCompact;

    // Set szControlString
    lstrcpy(szControlString, szControlChars);
    lstrcat(szControlString, szTsid);

    // Get the current system time
    GetSystemTime(&SystemTime);

    // Create the random number: (wMilliseconds MOD 48) + 24
    wRandomNumber = (SystemTime.wMilliseconds % (WORD) 0x0030) + (WORD) 0x0018;
    // Create the shift number: (wRandomNumber MOD (lstrlen(szControlString) / 2)) + (lstrlen(szControlString) / 4)
    wShiftNumber = ((wRandomNumber) % ((WORD) lstrlen(szControlString) / 2)) + ((WORD) lstrlen(szControlString) / 4);

    // Set szEncodeChar
    szEncodeChar[0] = (WCHAR) wRandomNumber + (WCHAR) 0x0020;

    for (wIndex = 0; wIndex < (WORD) lstrlen(szControlString); wIndex++) {
        // Create the intermediate string: ((ASCII value of the TSID - 32 + wRandomNumber) MOD 95) + 32
        szIntermediateString[wIndex] = ((szControlString[wIndex] - (WCHAR) 0x0020 + (WCHAR) wRandomNumber) % (WCHAR) 0x005F) + (WCHAR) 0x0020;
    }

    for (wIndex = 0; wIndex < (WORD) lstrlen(szIntermediateString); wIndex++) {
        // Create the list of remaining offsets of the encoded TSID
        szShiftChars[wIndex] = (LPWSTR) ((UINT_PTR) szFinalString + (sizeof(WCHAR) * wIndex));
    }

    for (wIndex = 0, wOffset = 0; wIndex < (WORD) lstrlen(szIntermediateString); wIndex++) {
        // Determine the appropriate offset of the encoded TSID
        wOffset = (wOffset + wShiftNumber) % (lstrlen(szIntermediateString) - wIndex);
        // Set the appropriate offset of the encoded TSID
        *((LPWSTR) szShiftChars[wOffset]) = szIntermediateString[wIndex];
        // Compact the remaining offsets of the encoded TSID
        for (wCompact = wOffset; wCompact < (lstrlen(szIntermediateString) - wIndex); wCompact++) {
            szShiftChars[wCompact] = szShiftChars[wCompact + 1];
        }
    }

    // Set szEncodedTsid
    lstrcpy(szEncodedTsid, szEncodeChar);
    lstrcat(szEncodedTsid, szFinalString);
}

BOOL
fnDecodeTsid(
    LPWSTR  szTsid,
    LPWSTR  szControlChars,
    LPWSTR  szDecodedTsid
)
/*++

Routine Description:

  Decodes a TSID

Arguments:

  szTsid - encoded TSID
  szControlChars - control characters to prepend TSID
  szDecodedTsid - decoded TSID

  The TSID is decoded as follows:
     1) Isolate the encoded TSID from the random number.
     2) Get the random number:
        1) The first character in the TSID is the ASCII value of the random number
        2) Subtract 32 (0x0020) from the ASCII value to get the random number.
     3) Get the shift number based on the random number:
        1) wRandomNumber MOD (TSID length / 2): This gives a range of 0 - (TSID length / 2), half the TSID length
        2) Add (TSID length / 4): This moves the range to (TSID length / 4) - 3 * (TSID length / 4), guaranteeing the ASCII values of the TSID will be shifted.
     4) Create an array of pointers to each ASCII value of the intermediate string
     5) Determine the appropriate offset in the intermediate string
        1) Add the shift number to the current offset
        2) MOD (TSID length - wIndex): This ensures the offset is in the range 0 - (number of remaining offsets).
     6) Place the next ASCII value of the encoded TSID into the appropriate offset in the intermediate string
     7) Compact the remaining offsets of the intermediate string
     8) Repeat steps 6 - 8 until all offsets have been used
     9) Create the final string where each ASCII value of the final string is
        1) Subtract 32 (0x0020) from each ASCII value of the intermediate string: This gives a range of 0 - 94.
        2) Add 95 (0x005F): This ensures each ASCII value will not underflow when subtracting the random number.
        3) Subtract the random number
        3) MOD 95 (0x005F): This ensures each ASCII value of the intermediate string is in the range 0 - 94.
        4) Add 32 (0x0020): This moves the range back to 32 - 126.
    10) Create the final decoded string
    11) Isolate and compare the control characters

Return Value:

  TRUE if control characters match

--*/
{
    // szControlString is the TSID prepended by the control characters
    WCHAR   szControlString[CONTROL_CHAR_LEN + PHONE_NUM_LEN + 1] = {'\0'};
    // szEncodeChar is the encoding character
    WCHAR   szEncodeChar[ENCODE_CHAR_LEN + 1] = {'\0'};
    // szIntermediateString is the intermediate encoded string
    WCHAR   szIntermediateString[CONTROL_CHAR_LEN + PHONE_NUM_LEN + 1] = {'\0'};
    // szFinalString is the final encoded string
    WCHAR   szFinalString[CONTROL_CHAR_LEN + PHONE_NUM_LEN + 1] = {'\0'};
    // szShiftChars is an array of pointers to each ASCII value of the encoded TSID
    LPWSTR  szShiftChars[CONTROL_CHAR_LEN + PHONE_NUM_LEN + 1] = {'\0'};

    // wRandomNumber is a number to decrement each ASCII value of the encoded TSID
    WORD    wRandomNumber;
    // wShiftNumber is a number to shift the order of each ASCII value of the encoded TSID
    WORD    wShiftNumber;
    // wIndex is a counter to enumerate each ASCII value of the TSID
    WORD    wIndex;
    // wOffset is a counter to identify the appropriate offset of the decoded TSID when shifting each ASCII value of the encoded TSID
    WORD    wOffset;
    // wCompact is a counter to compact the remaining offsets of the decoded TSID
    WORD    wCompact;

    // Get szControlString
    lstrcpy(szControlString, (LPWSTR) ((UINT_PTR) szTsid + sizeof(WCHAR)));

    // Get szEncodeChar
    szEncodeChar[0] = *szTsid;

    // Get the random number
    wRandomNumber = (WORD) ((WCHAR) szEncodeChar[0] - (WCHAR) 0x0020);
    // Create the shift number: (wRandomNumber MOD (lstrlen(szControlString) / 2)) + (lstrlen(szControlString) / 4)
    wShiftNumber = ((wRandomNumber) % ((WORD) lstrlen(szControlString) / 2)) + ((WORD) lstrlen(szControlString) / 4);

    for (wIndex = 0; wIndex < (WORD) lstrlen(szControlString); wIndex++) {
        // Create the list of remaining offsets of the decoded TSID
        szShiftChars[wIndex] = (LPWSTR) ((UINT_PTR) szControlString + (sizeof(WCHAR) * wIndex));
    }

    for (wIndex = 0, wOffset = 0; wIndex < (WORD) lstrlen(szControlString); wIndex++) {
        // Determine the appropriate offset of the decoded TSID
        wOffset = (wOffset + wShiftNumber) % (lstrlen(szControlString) - wIndex);
        // Set the appropriate offset of the decoded TSID
        szIntermediateString[wIndex] = *((LPWSTR) szShiftChars[wOffset]);
        // Compact the remaining offsets of the decoded TSID
        for (wCompact = wOffset; wCompact < (lstrlen(szControlString) - wIndex); wCompact++) {
            szShiftChars[wCompact] = szShiftChars[wCompact + 1];
        }
    }

    for (wIndex = 0; wIndex < (WORD) lstrlen(szIntermediateString); wIndex++) {
        // Create the final string: ((ASCII value of the TSID - 32 + 95 - wRandomNumber) MOD 95) + 32
        szFinalString[wIndex] = ((szIntermediateString[wIndex] - (WCHAR) 0x0020 + (WCHAR) 0x005F - (WCHAR) wRandomNumber) % (WCHAR) 0x005F) + (WCHAR) 0x0020;
    }

    // Set szDecodedTsid
    lstrcpy(szDecodedTsid, (LPWSTR) ((UINT_PTR) szFinalString + lstrlen(szControlChars) * sizeof(WCHAR)));

    // Isolate the control characters
    lstrcpy((LPWSTR) ((UINT_PTR) szFinalString + lstrlen(szControlChars) * sizeof(WCHAR)), L"\0");
    // Compare the control characters
    return lstrcmp(szControlChars, szFinalString) ? FALSE : TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\tiff\dump\tiffdump.c ===
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include <malloc.h>
#include "tiffdump.h"

char    *curfile;
int     swabflag;
int     bigendian;
int     typeshift[13];  /* data type shift counts */
long    typemask[13];   /* data type masks */

//
// prototypes
//
long ReadDirectory();
void dump(int fd);
long ReadDirectory(int fd,long off);
void PrintTag(FILE *fd, unsigned short tag);
void PrintType(FILE *fd, unsigned short type);
void PrintData(FILE *fd,unsigned short type,long count,unsigned char *data);
void TIFFSwabShort(unsigned short *wp);
void TIFFSwabLong(unsigned long *lp);
void TIFFSwabArrayOfShort(unsigned short *wp,int n);
void TIFFSwabArrayOfLong(unsigned long *lp,int n);
int  TIFFFetchData(int fd,TIFFDirEntry *dir,char *cp);
void ReadError(char *what);
void Error(char *fmt,...);
void Fatal(char *fmt,...);




int _cdecl main(int argc, char *argv[])
{
        int one = 1, fd;
        int multiplefiles = (argc > 1);

        bigendian = (*(char *)&one == 0);
        for (argc--, argv++; argc > 0; argc--, argv++) {
                fd = _open(argv[0], O_RDONLY|O_BINARY, 0);
                if (fd < 0) {
                        perror(argv[0]);
                        exit(-1);
                }
                if (multiplefiles)
                        printf("%s:\n", argv[0]);
                curfile = *argv;
                swabflag = 0;
                dump(fd);
                _close(fd);
        }
        return 0;
}

TIFFHeader h;

#define ord(e)  ((int)e)

/*
 * Initialize shift & mask tables and byte
 * swapping state according to the file
 * byte order.
 */
void InitByteOrder(int magic)
{
        typemask[0] = 0;
        typemask[ord(TIFF_BYTE)] = 0xff;
        typemask[ord(TIFF_SBYTE)] = 0xff;
        typemask[ord(TIFF_UNDEFINED)] = 0xff;
        typemask[ord(TIFF_SHORT)] = 0xffff;
        typemask[ord(TIFF_SSHORT)] = 0xffff;
        typemask[ord(TIFF_LONG)] = 0xffffffff;
        typemask[ord(TIFF_SLONG)] = 0xffffffff;
        typemask[ord(TIFF_RATIONAL)] = 0xffffffff;
        typemask[ord(TIFF_SRATIONAL)] = 0xffffffff;
        typemask[ord(TIFF_FLOAT)] = 0xffffffff;
        typemask[ord(TIFF_DOUBLE)] = 0xffffffff;
        typeshift[0] = 0;
        typeshift[ord(TIFF_LONG)] = 0;
        typeshift[ord(TIFF_SLONG)] = 0;
        typeshift[ord(TIFF_RATIONAL)] = 0;
        typeshift[ord(TIFF_SRATIONAL)] = 0;
        typeshift[ord(TIFF_FLOAT)] = 0;
        typeshift[ord(TIFF_DOUBLE)] = 0;
        if (magic == TIFF_BIGENDIAN) {
                typeshift[ord(TIFF_BYTE)] = 24;
                typeshift[ord(TIFF_SBYTE)] = 24;
                typeshift[ord(TIFF_SHORT)] = 16;
                typeshift[ord(TIFF_SSHORT)] = 16;
                swabflag = !bigendian;
        } else {
                typeshift[ord(TIFF_BYTE)] = 0;
                typeshift[ord(TIFF_SBYTE)] = 0;
                typeshift[ord(TIFF_SHORT)] = 0;
                typeshift[ord(TIFF_SSHORT)] = 0;
                swabflag = bigendian;
        }
}

void
dump(
    int fd
    )
{
        long off;
        int i;

        _lseek(fd, 0L, 0);
        if (_read(fd, &h, sizeof (h)) != sizeof (h))
                ReadError("TIFF header");
        /*
         * Setup the byte order handling.
         */
        if (h.tiff_magic != TIFF_BIGENDIAN && h.tiff_magic != TIFF_LITTLEENDIAN)
                Fatal("Not a TIFF file, bad magic number %u (0x%x)",
                    h.tiff_magic, h.tiff_magic);
        InitByteOrder(h.tiff_magic);
        /*
         * Swap header if required.
         */
        if (swabflag) {
                TIFFSwabShort(&h.tiff_version);
                TIFFSwabLong(&h.tiff_diroff);
        }
        /*
         * Now check version (if needed, it's been byte-swapped).
         * Note that this isn't actually a version number, it's a
         * magic number that doesn't change.
         */
        if (h.tiff_version != TIFF_VERSION)
                Fatal("Not a TIFF file, bad version number %u (0x%x)",
                    h.tiff_version, h.tiff_version);
        printf("Magic: 0x%x <%s-endian> Version: 0x%x\n",
            h.tiff_magic,
            h.tiff_magic == TIFF_BIGENDIAN ? "big" : "little",
            h.tiff_version);
        i = 0;
        off = h.tiff_diroff;
        while (off) {
                if (i > 0)
                        putchar('\n');
                printf("Directory %d: offset %lu (0x%lx)\n", i++, off, off);
                off = ReadDirectory(fd, off);
        }
}

static int datawidth[] = {
    0,  /* nothing */
    1,  /* TIFF_BYTE */
    1,  /* TIFF_ASCII */
    2,  /* TIFF_SHORT */
    4,  /* TIFF_LONG */
    8,  /* TIFF_RATIONAL */
    1,  /* TIFF_SBYTE */
    1,  /* TIFF_UNDEFINED */
    2,  /* TIFF_SSHORT */
    4,  /* TIFF_SLONG */
    8,  /* TIFF_SRATIONAL */
    4,  /* TIFF_FLOAT */
    8,  /* TIFF_DOUBLE */
};
#define NWIDTHS (sizeof (datawidth) / sizeof (datawidth[0]))

/*
 * Read the next TIFF directory from a file
 * and convert it to the internal format.
 * We read directories sequentially.
 */
long
ReadDirectory(
    int fd,
    long off
    )
{
        TIFFDirEntry *dp;
        int n;
        TIFFDirEntry *dir = 0;
        unsigned short dircount;
        int space;
        long nextdiroff = 0;

        if (off == 0)                   /* no more directories */
                goto done;
        if (_lseek(fd, off, 0) != off) {
                Fatal("Seek error accessing TIFF directory");
                goto done;
        }
        if (_read(fd, &dircount, sizeof (short)) != sizeof (short)) {
                ReadError("directory count");
                goto done;
        }
        if (swabflag)
                TIFFSwabShort(&dircount);
        dir = (TIFFDirEntry *)malloc(dircount * sizeof (TIFFDirEntry));
        if (dir == NULL) {
                Fatal("No space for TIFF directory");
                goto done;
        }
        n = _read(fd, dir, dircount*sizeof (*dp));
        if (n != (int)(dircount*sizeof(*dp))) {
                n /= sizeof (*dp);
                Error(
            "Could only read %u of %u entries in directory at offset 0x%x",
                    n, dircount, off);
                dircount = n;
        }
        if (_read(fd, &nextdiroff, sizeof (long)) != sizeof (long))
                nextdiroff = 0;
        if (swabflag)
                TIFFSwabLong(&nextdiroff);
        for (dp = dir, n = dircount; n > 0; n--, dp++) {
                if (swabflag) {
                        TIFFSwabArrayOfShort(&dp->tdir_tag, 2);
                        TIFFSwabArrayOfLong(&dp->tdir_count, 2);
                }
                PrintTag(stdout, dp->tdir_tag);
                putchar(' ');
                PrintType(stdout, dp->tdir_type);
                putchar(' ');
                printf("%u<", dp->tdir_count);
                if (dp->tdir_type >= NWIDTHS) {
                        printf(">\n");
                        continue;
                }
                space = dp->tdir_count * datawidth[dp->tdir_type];
                if (space <= 4) {
                        switch (dp->tdir_type) {
                        case TIFF_ASCII: {
                                char data[4];
                                memcpy(data,&dp->tdir_offset,4);
                                if (swabflag)
                                        TIFFSwabLong((unsigned long *)data);
                                PrintData(stdout,
                                    dp->tdir_type, dp->tdir_count, data);
                                break;
                        }
                        case TIFF_BYTE:
                        case TIFF_SBYTE:
                                if (h.tiff_magic == TIFF_LITTLEENDIAN) {
                                        switch ((int)dp->tdir_count) {
                                        case 4:
                                                printf("0x%02x",
                                                    dp->tdir_offset&0xff);
                                        case 3:
                                                printf("0x%02x",
                                                    (dp->tdir_offset>>8)&0xff);
                                        case 2:
                                                printf("0x%02x",
                                                    (dp->tdir_offset>>16)&0xff);
                                        case 1:
                                                printf("0x%02x",
                                                    dp->tdir_offset>>24);
                                                break;
                                        }
                                } else {
                                        switch ((int)dp->tdir_count) {
                                        case 4:
                                                printf("0x%02x",
                                                    dp->tdir_offset>>24);
                                        case 3:
                                                printf("0x%02x",
                                                    (dp->tdir_offset>>16)&0xff);
                                        case 2:
                                                printf("0x%02x",
                                                    (dp->tdir_offset>>8)&0xff);
                                        case 1:
                                                printf("0x%02x",
                                                    dp->tdir_offset&0xff);
                                                break;
                                        }
                                }
                                break;
                        case TIFF_SHORT:
                        case TIFF_SSHORT:
                                if (h.tiff_magic == TIFF_LITTLEENDIAN) {
                                        switch (dp->tdir_count) {
                                        case 2:
                                                printf("%u ",
                                                    dp->tdir_offset&0xffff);
                                        case 1:
                                                printf("%u",
                                                    //dp->tdir_offset>>16);
                                                    (SHORT)dp->tdir_offset);
                                                break;
                                        }
                                } else {
                                        switch (dp->tdir_count) {
                                        case 2:
                                                printf("%u ",
                                                    dp->tdir_offset>>16);
                                        case 1:
                                                printf("%u",
                                                    dp->tdir_offset&0xffff);
                                                break;
                                        }
                                }
                                break;
                        case TIFF_LONG:
                                printf("%lu", dp->tdir_offset);
                                break;
                        case TIFF_SLONG:
                                printf("%ld", dp->tdir_offset);
                                break;
                        }
                } else {
                        char *data = (char *)malloc(space);
                        if (data) {
                                if (TIFFFetchData(fd, dp, data))
                                        PrintData(stdout, dp->tdir_type,
                                            dp->tdir_count, data);
                                free(data);
                        } else
                                Error("No space for data for tag %u",
                                    dp->tdir_tag);
                }
                printf(">\n");
        }
done:
        if (dir)
                free((char *)dir);
        return (nextdiroff);
}

static  struct tagname {
        int     tag;
        char    *name;
} tagnames[] = {
    { TIFFTAG_SUBFILETYPE,      "SubFileType" },
    { TIFFTAG_OSUBFILETYPE,     "OldSubFileType" },
    { TIFFTAG_IMAGEWIDTH,       "ImageWidth" },
    { TIFFTAG_IMAGELENGTH,      "ImageLength" },
    { TIFFTAG_BITSPERSAMPLE,    "BitsPerSample" },
    { TIFFTAG_COMPRESSION,      "Compression" },
    { TIFFTAG_PHOTOMETRIC,      "Photometric" },
    { TIFFTAG_THRESHHOLDING,    "Threshholding" },
    { TIFFTAG_CELLWIDTH,        "CellWidth" },
    { TIFFTAG_CELLLENGTH,       "CellLength" },
    { TIFFTAG_FILLORDER,        "FillOrder" },
    { TIFFTAG_DOCUMENTNAME,     "DocumentName" },
    { TIFFTAG_IMAGEDESCRIPTION, "ImageDescription" },
    { TIFFTAG_MAKE,             "Make" },
    { TIFFTAG_MODEL,            "Model" },
    { TIFFTAG_STRIPOFFSETS,     "StripOffsets" },
    { TIFFTAG_ORIENTATION,      "Orientation" },
    { TIFFTAG_SAMPLESPERPIXEL,  "SamplesPerPixel" },
    { TIFFTAG_ROWSPERSTRIP,     "RowsPerStrip" },
    { TIFFTAG_STRIPBYTECOUNTS,  "StripByteCounts" },
    { TIFFTAG_MINSAMPLEVALUE,   "MinSampleValue" },
    { TIFFTAG_MAXSAMPLEVALUE,   "MaxSampleValue" },
    { TIFFTAG_XRESOLUTION,      "XResolution" },
    { TIFFTAG_YRESOLUTION,      "YResolution" },
    { TIFFTAG_PLANARCONFIG,     "PlanarConfig" },
    { TIFFTAG_PAGENAME,         "PageName" },
    { TIFFTAG_XPOSITION,        "XPosition" },
    { TIFFTAG_YPOSITION,        "YPosition" },
    { TIFFTAG_FREEOFFSETS,      "FreeOffsets" },
    { TIFFTAG_FREEBYTECOUNTS,   "FreeByteCounts" },
    { TIFFTAG_GRAYRESPONSEUNIT, "GrayResponseUnit" },
    { TIFFTAG_GRAYRESPONSECURVE,"GrayResponseCurve" },
    { TIFFTAG_GROUP3OPTIONS,    "Group3Options" },
    { TIFFTAG_GROUP4OPTIONS,    "Group4Options" },
    { TIFFTAG_RESOLUTIONUNIT,   "ResolutionUnit" },
    { TIFFTAG_PAGENUMBER,       "PageNumber" },
    { TIFFTAG_COLORRESPONSEUNIT,"ColorResponseUnit" },
    { TIFFTAG_TRANSFERFUNCTION, "TransferFunction" },
    { TIFFTAG_SOFTWARE,         "Software" },
    { TIFFTAG_DATETIME,         "DateTime" },
    { TIFFTAG_ARTIST,           "Artist" },
    { TIFFTAG_HOSTCOMPUTER,     "HostComputer" },
    { TIFFTAG_PREDICTOR,        "Predictor" },
    { TIFFTAG_WHITEPOINT,       "Whitepoint" },
    { TIFFTAG_PRIMARYCHROMATICITIES,"PrimaryChromaticities" },
    { TIFFTAG_COLORMAP,         "Colormap" },
    { TIFFTAG_HALFTONEHINTS,    "HalftoneHints" },
    { TIFFTAG_TILEWIDTH,        "TileWidth" },
    { TIFFTAG_TILELENGTH,       "TileLength" },
    { TIFFTAG_TILEOFFSETS,      "TileOffsets" },
    { TIFFTAG_TILEBYTECOUNTS,   "TileByteCounts" },
    { TIFFTAG_BADFAXLINES,      "BadFaxLines" },
    { TIFFTAG_CLEANFAXDATA,     "CleanFaxData" },
    { TIFFTAG_CONSECUTIVEBADFAXLINES, "ConsecutiveBadFaxLines" },
    { TIFFTAG_INKSET,           "InkSet" },
    { TIFFTAG_INKNAMES,         "InkNames" },
    { TIFFTAG_DOTRANGE,         "DotRange" },
    { TIFFTAG_TARGETPRINTER,    "TargetPrinter" },
    { TIFFTAG_EXTRASAMPLES,     "ExtraSamples" },
    { TIFFTAG_SAMPLEFORMAT,     "SampleFormat" },
    { TIFFTAG_SMINSAMPLEVALUE,  "SMinSampleValue" },
    { TIFFTAG_SMAXSAMPLEVALUE,  "SMaxSampleValue" },
    { TIFFTAG_JPEGPROC,         "JPEGProcessingMode" },
    { TIFFTAG_JPEGIFOFFSET,     "JPEGInterchangeFormat" },
    { TIFFTAG_JPEGIFBYTECOUNT,  "JPEGInterchangeFormatLength" },
    { TIFFTAG_JPEGRESTARTINTERVAL,"JPEGRestartInterval" },
    { TIFFTAG_JPEGLOSSLESSPREDICTORS,"JPEGLosslessPredictors" },
    { TIFFTAG_JPEGPOINTTRANSFORM,"JPEGPointTransform" },
    { TIFFTAG_JPEGQTABLES,      "JPEGQTables" },
    { TIFFTAG_JPEGDCTABLES,     "JPEGDCTables" },
    { TIFFTAG_JPEGACTABLES,     "JPEGACTables" },
    { TIFFTAG_YCBCRCOEFFICIENTS,"YCbCrCoefficients" },
    { TIFFTAG_YCBCRSUBSAMPLING, "YCbCrSubsampling" },
    { TIFFTAG_YCBCRPOSITIONING, "YCbCrPositioning" },
    { TIFFTAG_REFERENCEBLACKWHITE, "ReferenceBlackWhite" },
    { TIFFTAG_MATTEING,         "OBSOLETE Matteing" },
    { TIFFTAG_DATATYPE,         "OBSOLETE DataType" },
    { TIFFTAG_IMAGEDEPTH,       "ImageDepth" },
    { TIFFTAG_RECIP_NAME,       "RecipientName" },
    { TIFFTAG_RECIP_NUMBER,     "RecipientNumber" },
    { TIFFTAG_SENDER_NAME,      "SenderName" },
    { TIFFTAG_ROUTING,          "Routing" },
    { TIFFTAG_CALLERID,         "CallerID" },
    { TIFFTAG_TSID,             "TSID" },
    { TIFFTAG_CSID,             "CSID" },
    { TIFFTAG_FAX_TIME,         "FaxTime" },
    { TIFFTAG_TILEDEPTH,        "TileDepth" },
    { 32768,                    "OLD BOGUS Matteing tag" },
};
#define NTAGS   (sizeof (tagnames) / sizeof (tagnames[0]))

void
PrintTag(
    FILE *fd,
    unsigned short tag
    )
{
        struct tagname *tp;

        for (tp = tagnames; tp < &tagnames[NTAGS]; tp++)
                if (tp->tag == tag) {
                        fprintf(fd, "%s --0x%x (%u)", tp->name, tag,tag);
                        return;
                }
        fprintf(fd, "%u (0x%x)", tag, tag);
}

void
PrintType(
    FILE *fd,
    unsigned short type
    )
{
        static char *typenames[] = {
            "0",
            "BYTE",
            "ASCII",
            "SHORT",
            "LONG",
            "RATIONAL",
            "SBYTE",
            "UNDEFINED",
            "SSHORT",
            "SLONG",
            "SRATIONAL",
            "FLOAT",
            "DOUBLE"
        };
#define NTYPES  (sizeof (typenames) / sizeof (typenames[0]))

        if (type < NTYPES)
                fprintf(fd, "%s (%u)", typenames[type], type);
        else
                fprintf(fd, "%u (0x%x)", type, type);
}
#undef  NTYPES

void
PrintData(
    FILE *fd,
    unsigned short type,
    long count,
    unsigned char *data
    )
{

        switch (type) {
        case TIFF_BYTE:
                while (count-- > 0)
                        fprintf(fd, "%u%s", *data++, count > 0 ? " " : "");
                break;
        case TIFF_SBYTE:
                while (count-- > 0)
                        fprintf(fd, "%d%s", *(char *)data++, count > 0 ? " " : "");
                break;
        case TIFF_UNDEFINED:
                while (count-- > 0)
                        fprintf(fd, "0x%02x", *data++);
                break;
        case TIFF_ASCII:
                fprintf(fd, "%.*s", count, data);
                break;
        case TIFF_SHORT: {
                unsigned short *wp = (unsigned short *)data;
                while (count-- > 0)
                        fprintf(fd, "%u%s", *wp++, count > 0 ? " " : "");
                break;
        }
        case TIFF_SSHORT: {
                short *wp = (short *)data;
                while (count-- > 0)
                        fprintf(fd, "%d%s", *wp++, count > 0 ? " " : "");
                break;
        }
        case TIFF_LONG: {
                unsigned long *lp = (unsigned long *)data;
                while (count-- > 0)
                        fprintf(fd, "%lu%s", *lp++, count > 0 ? " " : "");
                break;
        }
        case TIFF_SLONG: {
                long *lp = (long *)data;
                while (count-- > 0)
                        fprintf(fd, "%ld%s", *lp++, count > 0 ? " " : "");
                break;
        }
        case TIFF_RATIONAL: {
                unsigned long *lp = (unsigned long *)data;
                while (count-- > 0) {
                        if (lp[1] == 0)
                                fprintf(fd, "Nan (%lu/%lu)", lp[0], lp[1]);
                        else
                                fprintf(fd, "%g",
                                    (double)lp[0] / (double)lp[1]);
                        if (count > 0)
                                fprintf(fd, " ");
                        lp += 2;
                }
                break;
        }
        case TIFF_SRATIONAL: {
                long *lp = (long *)data;
                while (count-- > 0) {
                        if (lp[1] == 0)
                                fprintf(fd, "Nan (%ld/%ld)", lp[0], lp[1]);
                        else
                                fprintf(fd, "%g",
                                    (double)lp[0] / (double)lp[1]);
                        if (count > 0)
                                fprintf(fd, " ");
                        lp += 2;
                }
                break;
        }
        case TIFF_FLOAT: {
                float *fp = (float *)data;
                while (count-- > 0)
                        fprintf(fd, "%g%s", *fp++, count > 0 ? " " : "");
                break;
        }
        case TIFF_DOUBLE: {
                double *dp = (double *)data;
                while (count-- > 0)
                        fprintf(fd, "%g%s", *dp++, count > 0 ? " " : "");
                break;
        }
        }
}

void
TIFFSwabShort(
    unsigned short *wp
    )
{
        unsigned char *cp = (unsigned char *)wp;
        int t;

        t = cp[1]; cp[1] = cp[0]; cp[0] = t;
}

void
TIFFSwabLong(
    unsigned long *lp
    )
{
        unsigned char *cp = (unsigned char *)lp;
        int t;

        t = cp[3]; cp[3] = cp[0]; cp[0] = t;
        t = cp[2]; cp[2] = cp[1]; cp[1] = t;
}

void
TIFFSwabArrayOfShort(
    unsigned short *wp,
    int n
    )
{
        unsigned char *cp;
        int t;

        /* XXX unroll loop some */
        while (n-- > 0) {
                cp = (unsigned char *)wp;
                t = cp[1]; cp[1] = cp[0]; cp[0] = t;
                wp++;
        }
}

void
TIFFSwabArrayOfLong(
    unsigned long *lp,
    int n
    )
{
        unsigned char *cp;
        int t;

        /* XXX unroll loop some */
        while (n-- > 0) {
                cp = (unsigned char *)lp;
                t = cp[3]; cp[3] = cp[0]; cp[0] = t;
                t = cp[2]; cp[2] = cp[1]; cp[1] = t;
                lp++;
        }
}

/*
 * Fetch a contiguous directory item.
 */
int
TIFFFetchData(
    int fd,
    TIFFDirEntry *dir,
    char *cp
    )
{
        int cc, w;

        w = (dir->tdir_type < NWIDTHS ? datawidth[dir->tdir_type] : 0);
        cc = dir->tdir_count * w;
        if (_lseek(fd, dir->tdir_offset, 0) == (int)dir->tdir_offset && _read(fd, cp, cc) == cc) {
                if (swabflag) {
                        switch (dir->tdir_type) {
                        case TIFF_SHORT:
                        case TIFF_SSHORT:
                                TIFFSwabArrayOfShort((unsigned short *)cp, dir->tdir_count);
                                break;
                        case TIFF_LONG:
                        case TIFF_SLONG:
                                TIFFSwabArrayOfLong((unsigned long *)cp, dir->tdir_count);
                                break;
                        case TIFF_RATIONAL:
                        case TIFF_DOUBLE:
                                TIFFSwabArrayOfLong((unsigned long *)cp, 2*dir->tdir_count);
                                break;
                        }
                }
                return (cc);
        }
        Error("Error while reading data for tag %u", dir->tdir_tag);
        return (0);
}

void
ReadError(
    char *what
    )
{
        Fatal("Error while reading %s", what);
}

void
Error(
    char *fmt,
    ...
    )
{
    char buf[1024];
    va_list arg_ptr;
    va_start(arg_ptr,fmt);
    _vsnprintf(buf,sizeof(buf),fmt,arg_ptr);
    va_end(arg_ptr);
    fprintf(stderr,"%s: ",curfile);
    fprintf(stderr,"%s\n",buf);
}

void
Fatal(
    char *fmt,
    ...
    )
{
    char buf[1024];
    va_list arg_ptr;
    va_start(arg_ptr,fmt);
    _vsnprintf(buf,sizeof(buf),fmt,arg_ptr);
    va_end(arg_ptr);
    fprintf(stderr,"%s: ",curfile);
    fprintf(stderr,"%s\n",buf);
    exit(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\tiff\dump\tiffdump.h ===
#ifndef _TIFF_
#define _TIFF_
/*
 * Tag Image File Format (TIFF)
 *
 * Based on Rev 6.0 from:
 *    Developer's Desk
 *    Aldus Corporation
 *    411 First Ave. South
 *    Suite 200
 *    Seattle, WA  98104
 *    206-622-5500
 */
#define TIFF_VERSION    42

#define TIFF_BIGENDIAN          0x4d4d
#define TIFF_LITTLEENDIAN       0x4949

/*
 * Intrinsic data types required by the file format:
 *
 * 8-bit quantities     int8/uint8
 * 16-bit quantities    int16/uint16
 * 32-bit quantities    int32/uint32
 * strings              unsigned char*
 */
typedef signed char int8;       /* NB: non-ANSI compilers may not grok */
typedef unsigned char uint8;
typedef short int16;
typedef unsigned short uint16;  /* sizeof (uint16) must == 2 */
#if defined(__alpha) || (defined(_MIPS_SZLONG) && _MIPS_SZLONG == 64)
typedef int int32;
typedef unsigned int uint32;    /* sizeof (uint32) must == 4 */
#else
typedef long int32;
typedef unsigned long uint32;   /* sizeof (uint32) must == 4 */
#endif

typedef struct {
        uint16  tiff_magic;     /* magic number (defines byte order) */
        uint16  tiff_version;   /* TIFF version number */
        uint32  tiff_diroff;    /* byte offset to first directory */
} TIFFHeader;

/*
 * TIFF Image File Directories are comprised of
 * a table of field descriptors of the form shown
 * below.  The table is sorted in ascending order
 * by tag.  The values associated with each entry
 * are disjoint and may appear anywhere in the file
 * (so long as they are placed on a word boundary).
 *
 * If the value is 4 bytes or less, then it is placed
 * in the offset field to save space.  If the value
 * is less than 4 bytes, it is left-justified in the
 * offset field.
 */
typedef struct {
        uint16  tdir_tag;       /* see below */
        uint16  tdir_type;      /* data type; see below */
        uint32  tdir_count;     /* number of items; length in spec */
        uint32  tdir_offset;    /* byte offset to field data */
} TIFFDirEntry;

/*
 * NB: In the comments below,
 *  - items marked with a + are obsoleted by revision 5.0,
 *  - items marked with a ! are introduced in revision 6.0.
 *  - items marked with a % are introduced post revision 6.0.
 *  - items marked with a $ are obsoleted by revision 6.0.
 */

/*
 * Tag data type information.
 *
 * Note: RATIONALs are the ratio of two 32-bit integer values.
 */
typedef enum {
        TIFF_NOTYPE     = 0,    /* placeholder */
        TIFF_BYTE       = 1,    /* 8-bit unsigned integer */
        TIFF_ASCII      = 2,    /* 8-bit bytes w/ last byte null */
        TIFF_SHORT      = 3,    /* 16-bit unsigned integer */
        TIFF_LONG       = 4,    /* 32-bit unsigned integer */
        TIFF_RATIONAL   = 5,    /* 64-bit unsigned fraction */
        TIFF_SBYTE      = 6,    /* !8-bit signed integer */
        TIFF_UNDEFINED  = 7,    /* !8-bit untyped data */
        TIFF_SSHORT     = 8,    /* !16-bit signed integer */
        TIFF_SLONG      = 9,    /* !32-bit signed integer */
        TIFF_SRATIONAL  = 10,   /* !64-bit signed fraction */
        TIFF_FLOAT      = 11,   /* !32-bit IEEE floating point */
        TIFF_DOUBLE     = 12    /* !64-bit IEEE floating point */
} TIFFDataType;

/*
 * TIFF Tag Definitions.
 */
#define TIFFTAG_SUBFILETYPE             254     /* subfile data descriptor */
#define     FILETYPE_REDUCEDIMAGE       0x1     /* reduced resolution version */
#define     FILETYPE_PAGE               0x2     /* one page of many */
#define     FILETYPE_MASK               0x4     /* transparency mask */
#define TIFFTAG_OSUBFILETYPE            255     /* +kind of data in subfile */
#define     OFILETYPE_IMAGE             1       /* full resolution image data */
#define     OFILETYPE_REDUCEDIMAGE      2       /* reduced size image data */
#define     OFILETYPE_PAGE              3       /* one page of many */
#define TIFFTAG_IMAGEWIDTH              256     /* image width in pixels */
#define TIFFTAG_IMAGELENGTH             257     /* image height in pixels */
#define TIFFTAG_BITSPERSAMPLE           258     /* bits per channel (sample) */
#define TIFFTAG_COMPRESSION             259     /* data compression technique */
#define     COMPRESSION_NONE            1       /* dump mode */
#define     COMPRESSION_CCITTRLE        2       /* CCITT modified Huffman RLE */
#define     COMPRESSION_CCITTFAX3       3       /* CCITT Group 3 fax encoding */
#define     COMPRESSION_CCITTFAX4       4       /* CCITT Group 4 fax encoding */
#define     COMPRESSION_LZW             5       /* Lempel-Ziv  & Welch */
#define     COMPRESSION_OJPEG           6       /* !6.0 JPEG */
#define     COMPRESSION_JPEG            7       /* %JPEG DCT compression */
#define     COMPRESSION_NEXT            32766   /* NeXT 2-bit RLE */
#define     COMPRESSION_CCITTRLEW       32771   /* #1 w/ word alignment */
#define     COMPRESSION_PACKBITS        32773   /* Macintosh RLE */
#define     COMPRESSION_THUNDERSCAN     32809   /* ThunderScan RLE */
/* compression codes 32908-32911 are reserved for Pixar */
#define     COMPRESSION_PIXARFILM       32908   /* Pixar companded 10bit LZW */
#define     COMPRESSION_DEFLATE         32946   /* Deflate compression */
#define     COMPRESSION_JBIG            34661   /* ISO JBIG */
#define TIFFTAG_PHOTOMETRIC             262     /* photometric interpretation */
#define     PHOTOMETRIC_MINISWHITE      0       /* min value is white */
#define     PHOTOMETRIC_MINISBLACK      1       /* min value is black */
#define     PHOTOMETRIC_RGB             2       /* RGB color model */
#define     PHOTOMETRIC_PALETTE         3       /* color map indexed */
#define     PHOTOMETRIC_MASK            4       /* $holdout mask */
#define     PHOTOMETRIC_SEPARATED       5       /* !color separations */
#define     PHOTOMETRIC_YCBCR           6       /* !CCIR 601 */
#define     PHOTOMETRIC_CIELAB          8       /* !1976 CIE L*a*b* */
#define TIFFTAG_THRESHHOLDING           263     /* +thresholding used on data */
#define     THRESHHOLD_BILEVEL          1       /* b&w art scan */
#define     THRESHHOLD_HALFTONE         2       /* or dithered scan */
#define     THRESHHOLD_ERRORDIFFUSE     3       /* usually floyd-steinberg */
#define TIFFTAG_CELLWIDTH               264     /* +dithering matrix width */
#define TIFFTAG_CELLLENGTH              265     /* +dithering matrix height */
#define TIFFTAG_FILLORDER               266     /* data order within a byte */
#define     FILLORDER_MSB2LSB           1       /* most significant -> least */
#define     FILLORDER_LSB2MSB           2       /* least significant -> most */
#define TIFFTAG_DOCUMENTNAME            269     /* name of doc. image is from */
#define TIFFTAG_IMAGEDESCRIPTION        270     /* info about image */
#define TIFFTAG_MAKE                    271     /* scanner manufacturer name */
#define TIFFTAG_MODEL                   272     /* scanner model name/number */
#define TIFFTAG_STRIPOFFSETS            273     /* offsets to data strips */
#define TIFFTAG_ORIENTATION             274     /* +image orientation */
#define     ORIENTATION_TOPLEFT         1       /* row 0 top, col 0 lhs */
#define     ORIENTATION_TOPRIGHT        2       /* row 0 top, col 0 rhs */
#define     ORIENTATION_BOTRIGHT        3       /* row 0 bottom, col 0 rhs */
#define     ORIENTATION_BOTLEFT         4       /* row 0 bottom, col 0 lhs */
#define     ORIENTATION_LEFTTOP         5       /* row 0 lhs, col 0 top */
#define     ORIENTATION_RIGHTTOP        6       /* row 0 rhs, col 0 top */
#define     ORIENTATION_RIGHTBOT        7       /* row 0 rhs, col 0 bottom */
#define     ORIENTATION_LEFTBOT         8       /* row 0 lhs, col 0 bottom */
#define TIFFTAG_SAMPLESPERPIXEL         277     /* samples per pixel */
#define TIFFTAG_ROWSPERSTRIP            278     /* rows per strip of data */
#define TIFFTAG_STRIPBYTECOUNTS         279     /* bytes counts for strips */
#define TIFFTAG_MINSAMPLEVALUE          280     /* +minimum sample value */
#define TIFFTAG_MAXSAMPLEVALUE          281     /* +maximum sample value */
#define TIFFTAG_XRESOLUTION             282     /* pixels/resolution in x */
#define TIFFTAG_YRESOLUTION             283     /* pixels/resolution in y */
#define TIFFTAG_PLANARCONFIG            284     /* storage organization */
#define     PLANARCONFIG_CONTIG         1       /* single image plane */
#define     PLANARCONFIG_SEPARATE       2       /* separate planes of data */
#define TIFFTAG_PAGENAME                285     /* page name image is from */
#define TIFFTAG_XPOSITION               286     /* x page offset of image lhs */
#define TIFFTAG_YPOSITION               287     /* y page offset of image lhs */
#define TIFFTAG_FREEOFFSETS             288     /* +byte offset to free block */
#define TIFFTAG_FREEBYTECOUNTS          289     /* +sizes of free blocks */
#define TIFFTAG_GRAYRESPONSEUNIT        290     /* $gray scale curve accuracy */
#define     GRAYRESPONSEUNIT_10S        1       /* tenths of a unit */
#define     GRAYRESPONSEUNIT_100S       2       /* hundredths of a unit */
#define     GRAYRESPONSEUNIT_1000S      3       /* thousandths of a unit */
#define     GRAYRESPONSEUNIT_10000S     4       /* ten-thousandths of a unit */
#define     GRAYRESPONSEUNIT_100000S    5       /* hundred-thousandths */
#define TIFFTAG_GRAYRESPONSECURVE       291     /* $gray scale response curve */
#define TIFFTAG_GROUP3OPTIONS           292     /* 32 flag bits */
#define     GROUP3OPT_2DENCODING        0x1     /* 2-dimensional coding */
#define     GROUP3OPT_UNCOMPRESSED      0x2     /* data not compressed */
#define     GROUP3OPT_FILLBITS          0x4     /* fill to byte boundary */
#define TIFFTAG_GROUP4OPTIONS           293     /* 32 flag bits */
#define     GROUP4OPT_UNCOMPRESSED      0x2     /* data not compressed */
#define TIFFTAG_RESOLUTIONUNIT          296     /* units of resolutions */
#define     RESUNIT_NONE                1       /* no meaningful units */
#define     RESUNIT_INCH                2       /* english */
#define     RESUNIT_CENTIMETER          3       /* metric */
#define TIFFTAG_PAGENUMBER              297     /* page numbers of multi-page */
#define TIFFTAG_COLORRESPONSEUNIT       300     /* $color curve accuracy */
#define     COLORRESPONSEUNIT_10S       1       /* tenths of a unit */
#define     COLORRESPONSEUNIT_100S      2       /* hundredths of a unit */
#define     COLORRESPONSEUNIT_1000S     3       /* thousandths of a unit */
#define     COLORRESPONSEUNIT_10000S    4       /* ten-thousandths of a unit */
#define     COLORRESPONSEUNIT_100000S   5       /* hundred-thousandths */
#define TIFFTAG_TRANSFERFUNCTION        301     /* !colorimetry info */
#define TIFFTAG_SOFTWARE                305     /* name & release */
#define TIFFTAG_DATETIME                306     /* creation date and time */
#define TIFFTAG_ARTIST                  315     /* creator of image */
#define TIFFTAG_HOSTCOMPUTER            316     /* machine where created */
#define TIFFTAG_PREDICTOR               317     /* prediction scheme w/ LZW */
#define TIFFTAG_WHITEPOINT              318     /* image white point */
#define TIFFTAG_PRIMARYCHROMATICITIES   319     /* !primary chromaticities */
#define TIFFTAG_COLORMAP                320     /* RGB map for pallette image */
#define TIFFTAG_HALFTONEHINTS           321     /* !highlight+shadow info */
#define TIFFTAG_TILEWIDTH               322     /* !rows/data tile */
#define TIFFTAG_TILELENGTH              323     /* !cols/data tile */
#define TIFFTAG_TILEOFFSETS             324     /* !offsets to data tiles */
#define TIFFTAG_TILEBYTECOUNTS          325     /* !byte counts for tiles */
#define TIFFTAG_BADFAXLINES             326     /* lines w/ wrong pixel count */
#define TIFFTAG_CLEANFAXDATA            327     /* regenerated line info */
#define     CLEANFAXDATA_CLEAN          0       /* no errors detected */
#define     CLEANFAXDATA_REGENERATED    1       /* receiver regenerated lines */
#define     CLEANFAXDATA_UNCLEAN        2       /* uncorrected errors exist */
#define TIFFTAG_CONSECUTIVEBADFAXLINES  328     /* max consecutive bad lines */
#define TIFFTAG_SUBIFD                  330     /* subimage descriptors */
#define TIFFTAG_INKSET                  332     /* !inks in separated image */
#define     INKSET_CMYK                 1       /* !cyan-magenta-yellow-black */
#define TIFFTAG_INKNAMES                333     /* !ascii names of inks */
#define TIFFTAG_DOTRANGE                336     /* !0% and 100% dot codes */
#define TIFFTAG_TARGETPRINTER           337     /* !separation target */
#define TIFFTAG_EXTRASAMPLES            338     /* !info about extra samples */
#define     EXTRASAMPLE_UNSPECIFIED     0       /* !unspecified data */
#define     EXTRASAMPLE_ASSOCALPHA      1       /* !associated alpha data */
#define     EXTRASAMPLE_UNASSALPHA      2       /* !unassociated alpha data */
#define TIFFTAG_SAMPLEFORMAT            339     /* !data sample format */
#define     SAMPLEFORMAT_UINT           1       /* !unsigned integer data */
#define     SAMPLEFORMAT_INT            2       /* !signed integer data */
#define     SAMPLEFORMAT_IEEEFP         3       /* !IEEE floating point data */
#define     SAMPLEFORMAT_VOID           4       /* !untyped data */
#define TIFFTAG_SMINSAMPLEVALUE         340     /* !variable MinSampleValue */
#define TIFFTAG_SMAXSAMPLEVALUE         341     /* !variable MaxSampleValue */
#define TIFFTAG_JPEGTABLES              347     /* %JPEG table stream */
/*
 * Tags 512-521 are obsoleted by Technical Note #2
 * which specifies a revised JPEG-in-TIFF scheme.
 */
#define TIFFTAG_JPEGPROC                512     /* !JPEG processing algorithm */
#define     JPEGPROC_BASELINE           1       /* !baseline sequential */
#define     JPEGPROC_LOSSLESS           14      /* !Huffman coded lossless */
#define TIFFTAG_JPEGIFOFFSET            513     /* !pointer to SOI marker */
#define TIFFTAG_JPEGIFBYTECOUNT         514     /* !JFIF stream length */
#define TIFFTAG_JPEGRESTARTINTERVAL     515     /* !restart interval length */
#define TIFFTAG_JPEGLOSSLESSPREDICTORS  517     /* !lossless proc predictor */
#define TIFFTAG_JPEGPOINTTRANSFORM      518     /* !lossless point transform */
#define TIFFTAG_JPEGQTABLES             519     /* !Q matrice offsets */
#define TIFFTAG_JPEGDCTABLES            520     /* !DCT table offsets */
#define TIFFTAG_JPEGACTABLES            521     /* !AC coefficient offsets */
#define TIFFTAG_YCBCRCOEFFICIENTS       529     /* !RGB -> YCbCr transform */
#define TIFFTAG_YCBCRSUBSAMPLING        530     /* !YCbCr subsampling factors */
#define TIFFTAG_YCBCRPOSITIONING        531     /* !subsample positioning */
#define     YCBCRPOSITION_CENTERED      1       /* !as in PostScript Level 2 */
#define     YCBCRPOSITION_COSITED       2       /* !as in CCIR 601-1 */
#define TIFFTAG_REFERENCEBLACKWHITE     532     /* !colorimetry info */
/* tags 32952-32956 are private tags registered to Island Graphics */
#define TIFFTAG_REFPTS                  32953   /* image reference points */
#define TIFFTAG_REGIONTACKPOINT         32954   /* region-xform tack point */
#define TIFFTAG_REGIONWARPCORNERS       32955   /* warp quadrilateral */
#define TIFFTAG_REGIONAFFINE            32956   /* affine transformation mat */
/* tags 32995-32999 are private tags registered to SGI */
#define TIFFTAG_MATTEING                32995   /* $use ExtraSamples */
#define TIFFTAG_DATATYPE                32996   /* $use SampleFormat */
#define TIFFTAG_IMAGEDEPTH              32997   /* z depth of image */
#define TIFFTAG_TILEDEPTH               32998   /* z depth/data tile */
/* tags 33300-33309 are private tags registered to Pixar */
/*
 * TIFFTAG_PIXAR_IMAGEFULLWIDTH and TIFFTAG_PIXAR_IMAGEFULLLENGTH
 * are set when an image has been cropped out of a larger image.
 * They reflect the size of the original uncropped image.
 * The TIFFTAG_XPOSITION and TIFFTAG_YPOSITION can be used
 * to determine the position of the smaller image in the larger one.
 */
#define TIFFTAG_PIXAR_IMAGEFULLWIDTH    33300   /* full image size in x */
#define TIFFTAG_PIXAR_IMAGEFULLLENGTH   33301   /* full image size in y */
/* tag 33432 is listed in the 6.0 spec w/ unknown ownership */
#define TIFFTAG_COPYRIGHT               33432   /* copyright string */
/* tags 34232-34236 are private tags registered to Texas Instruments */
#define TIFFTAG_FRAMECOUNT              34232   /* Sequence Frame Count */
/* tag 34750 is a private tag registered to Pixel Magic */
#define TIFFTAG_JBIGOPTIONS             34750   /* JBIG options */
/* tags 34908-34914 are private tags registered to SGI */
#define TIFFTAG_FAXRECVPARAMS           34908   /* encoded Class 2 ses. parms */
#define TIFFTAG_FAXSUBADDRESS           34909   /* received SubAddr string */
#define TIFFTAG_FAXRECVTIME             34910   /* receive time (secs) */


//
// tags 40001-40100 are private tags registered to ms
//
#define TIFFTAG_RECIP_NAME              40001
#define TIFFTAG_RECIP_NUMBER            40002
#define TIFFTAG_SENDER_NAME             40003
#define TIFFTAG_ROUTING                 40004
#define TIFFTAG_CALLERID                40005
#define TIFFTAG_TSID                    40006
#define TIFFTAG_CSID                    40007
#define TIFFTAG_FAX_TIME                40008



/*
 * The following are ``pseudo tags'' that can be
 * used to control codec-specific functionality.
 * These tags are not written to file.  Note that
 * these values start at 0xffff+1 so that they'll
 * never collide with Aldus-assigned tags.
 *
 * If you want your private pseudo tags ``registered''
 * (i.e. added to this file), send mail to sam@sgi.com
 * with the appropriate C definitions to add.
 */
#define TIFFTAG_FAXMODE                 65536   /* Group 3/4 format control */
#define     FAXMODE_CLASSIC     0x0000          /* default, include RTC */
#define     FAXMODE_NORTC       0x0001          /* no RTC at end of data */
#define     FAXMODE_NOEOL       0x0002          /* no EOL code at end of row */
#define     FAXMODE_BYTEALIGN   0x0004          /* byte align row */
#define     FAXMODE_WORDALIGN   0x0008          /* word align row */
#define     FAXMODE_CLASSF      FAXMODE_NORTC   /* TIFF Class F */
#define TIFFTAG_JPEGQUALITY             65537   /* Compression quality level */
/* Note: quality level is on the IJG 0-100 scale.  Default value is 75 */
#define TIFFTAG_JPEGCOLORMODE           65538   /* Auto RGB<=>YCbCr convert? */
#define     JPEGCOLORMODE_RAW   0x0000          /* no conversion (default) */
#define     JPEGCOLORMODE_RGB   0x0001          /* do auto conversion */
#define TIFFTAG_JPEGTABLESMODE          65539   /* What to put in JPEGTables */
#define     JPEGTABLESMODE_QUANT 0x0001         /* include quantization tbls */
#define     JPEGTABLESMODE_HUFF 0x0002          /* include Huffman tbls */
/* Note: default is JPEGTABLESMODE_QUANT | JPEGTABLESMODE_HUFF */
#define TIFFTAG_FAXFILLFUNC             65540   /* G3/G4 fill function */
#define TIFFTAG_PIXARLOGDATAFMT         65549   /* PixarLogCodec I/O data sz */
#define     PIXARLOGDATAFMT_8BIT        0       /* regular u_char samples */
#define     PIXARLOGDATAFMT_8BITABGR    1       /* ABGR-order u_chars */
#define     PIXARLOGDATAFMT_10BITLOG    2       /* 10-bit log-encoded (raw) */
#define     PIXARLOGDATAFMT_12BITPICIO  3       /* as per PICIO (1.0==2048) */
#define     PIXARLOGDATAFMT_16BIT       4       /* signed short samples */
#define     PIXARLOGDATAFMT_FLOAT       5       /* IEEE float samples */
#endif /* _TIFF_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\tiff\src\decode.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    decode.c

Abstract:

    This file contains functions for decoding (de-compressing)
    compressed 1 bit per pel data from a TIFF data
    stream.  The supported compression algorithms are
    as follows:

        o  Uncompressed (raw)
        o  One dimensional - MH or Modified Huffman
        o  Two dimensional - MR or Modified Read

Environment:

        WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "tifflibp.h"
#pragma hdrstop



BOOL
DecodeUnCompressedFaxData(
    PTIFF_INSTANCE_DATA TiffInstance,
    LPBYTE              OutputBuffer,
    BOOL                SingleLineBuffer,
    DWORD               PadLength
    )

/*++

Routine Description:

    Decode a single page of uncompressed TIFF data.

Arguments:

    TiffInstance    - Pointer to the TIFF instance data
    OutputBuffer    - Output buffer where the uncompressed data
                      is written.  This buffer must be allocated
                      by the caller and must be large enough for
                      a single page of data.

Return Value:

    NONE

--*/

{
    __try {

        FillMemory( OutputBuffer, TiffInstance->ImageHeight * (TiffInstance->ImageWidth / 8), WHITE );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        return FALSE;

    }

    TiffInstance->Lines = TiffInstance->StripDataSize / (TiffInstance->ImageWidth / 8);
    CopyMemory( OutputBuffer, TiffInstance->StripData, TiffInstance->StripDataSize );

    return TRUE;
}


BOOL
DecodeMHFaxData(
    PTIFF_INSTANCE_DATA TiffInstance,
    LPBYTE              OutputBuffer,
    BOOL                SingleLineBuffer,
    DWORD               PadLength
    )

/*++

Routine Description:

    Decode a single page of 1 dimensionaly compressed
    TIFF data.

Arguments:

    TiffInstance    - Pointer to the TIFF instance data
    OutputBuffer    - Output buffer where the uncompressed data
                      is written.  This buffer must be allocated
                      by the caller and must be large enough for
                      a single page of data.

Return Value:

    NONE

--*/

{
    DWORD               i;
    DWORD               j;
    BYTE                octet;
    PDECODE_TREE        Tree;
    INT                 code;
    PBYTE               plinebuf;
    DWORD               lineWidth;
    DWORD               Lines;
    DWORD               EolCount;
    DWORD               BadFaxLines;
    BOOL                LastLineBad;


    //
    // initialization
    //

    if (!SingleLineBuffer) {

        __try {

            FillMemory( OutputBuffer, TiffInstance->ImageHeight * (TiffInstance->ImageWidth / 8), WHITE );

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            return FALSE;

        }

    }

    Tree = WhiteDecodeTree;
    code = 0;
    Lines = 0;
    EolCount = 1;
    BadFaxLines = 0;
    LastLineBad = FALSE;
    TiffInstance->Color = 0;
    TiffInstance->RunLength = 0;
    TiffInstance->bitdata = 0;
    TiffInstance->bitcnt = DWORDBITS;
    TiffInstance->bitbuf = OutputBuffer;
    TiffInstance->StartGood = 0;
    TiffInstance->EndGood = 0;
    plinebuf = TiffInstance->StripData;
    lineWidth = TiffInstance->ImageWidth;


    for (i=0; i<TiffInstance->StripDataSize; i++) {
        if (plinebuf[i] == 0) {
            break;
        }
    }

    //
    // loop thru each byte in the file
    //

    for (; i<TiffInstance->StripDataSize; i++) {

        octet = plinebuf[i];

        if (i == 2147) DebugBreak();

        //
        // loop thru each bit in the byte
        //

        for (j=0; j<8; j++,octet<<=1) {

            if (code == DECODEEOL) {

                if (!(octet&0x80)) {
                    //
                    // here we skip all bits until we hit a 1 bit
                    // this happens when the first octet in a line
                    // is all zeroes and we detect that we are
                    // searching for an EOL
                    //
                    continue;
                }

                if (TiffInstance->RunLength && TiffInstance->RunLength != lineWidth) {

                    if (TiffInstance->RunLength < lineWidth) {
                        TiffInstance->Color = 0;
                        OutputCodeBits( TiffInstance, lineWidth - TiffInstance->RunLength );
                    }

                    if (LastLineBad) {

                        BadFaxLines += 1;

                    } else {

                        if (BadFaxLines > TiffInstance->BadFaxLines) {
                            TiffInstance->BadFaxLines = BadFaxLines;
                        }
                        BadFaxLines = 1;
                        LastLineBad = TRUE;

                    }

                } else {

                    LastLineBad = FALSE;

                }

                if (!TiffInstance->StartGood) {
                    TiffInstance->StartGood = i - 1;
                }

                //
                // we hit the eol marker
                //
                Tree = WhiteDecodeTree;
                TiffInstance->Color = 0;
                code = 0;

                if (SingleLineBuffer) {
                    TiffInstance->bitbuf = OutputBuffer;
                }

                if (TiffInstance->RunLength) {

                    FlushLine(TiffInstance,PadLength);
                    TiffInstance->RunLength = 0;
                    Lines += 1;
                    EolCount = 1;

                } else {

                    //
                    // the eol count is maintained to that
                    // an rtc sequence is detected.
                    //

                    EolCount += 1;

                    if (EolCount == 6) {

                        //
                        // this is an rtc sequence, so any
                        // data that follows in the file
                        // is garbage.
                        //

                        goto good_exit;

                    }

                }

                continue;
            }

            code = ((octet&0x80)>>7) ? Tree[code].Right : Tree[code].Left;

            if (code == BADRUN) {
                return FALSE;
            }

            if (code < 1) {

                code = (-code);

                OutputCodeBits( TiffInstance, code );

                if (code < 64) {
                    //
                    // terminating code
                    //
                    TiffInstance->Color = !TiffInstance->Color;
                    Tree = TiffInstance->Color ? BlackDecodeTree : WhiteDecodeTree;
                }
                code = 0;
            }

        }
    }

good_exit:

    TiffInstance->EndGood = i;
    if (BadFaxLines > TiffInstance->BadFaxLines) {
        TiffInstance->BadFaxLines = BadFaxLines;
    }

    FlushBits( TiffInstance );
    TiffInstance->Lines = Lines;

    return TRUE;
}


BOOL
DecodeMRFaxData(
    PTIFF_INSTANCE_DATA TiffInstance,
    LPBYTE              OutputBuffer,
    BOOL                SingleLineBuffer,
    DWORD               PadLength
    )

/*++

Routine Description:

    Decode a single page of 2 dimensionaly compressed
    TIFF data.

Arguments:

    TiffInstance    - Pointer to the TIFF instance data
    OutputBuffer    - Output buffer where the uncompressed data
                      is written.  This buffer must be allocated
                      by the caller and must be large enough for
                      a single page of data.

Return Value:

    NONE

--*/

{
    DWORD               i;
    DWORD               j;
    BYTE                octet;
    PDECODE_TREE        Tree;
    INT                 code;
    LPBYTE              prefline;
    LPBYTE              pcurrline;
    DWORD               HorzRuns;
    BOOL                OneDimensional;
    DWORD               a0;
    DWORD               a1;
    DWORD               b1;
    DWORD               b2;
    PBYTE               plinebuf;
    DWORD               lineWidth;
    DWORD               Lines;
    DWORD               EolCount;
    DWORD               BadFaxLines;
    BOOL                LastLineBad;


    //
    // initialization
    //

    if (!SingleLineBuffer) {

        __try {

            FillMemory( OutputBuffer, TiffInstance->ImageHeight * (TiffInstance->ImageWidth / 8), WHITE );

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            return FALSE;

        }

    }

    Tree = WhiteDecodeTree;
    code = 0;
    HorzRuns = 0;
    EolCount = 1;
    BadFaxLines = 0;
    LastLineBad = FALSE;
    TiffInstance->Color = 0;
    TiffInstance->RunLength = 0;
    TiffInstance->bitdata = 0;
    TiffInstance->bitcnt = DWORDBITS;
    TiffInstance->bitbuf = OutputBuffer;
    OneDimensional = TRUE;
    plinebuf = TiffInstance->StripData;
    lineWidth = TiffInstance->ImageWidth;
    pcurrline = OutputBuffer;
    prefline = OutputBuffer;
    a0 = 0;
    a1 = 0;
    b1 = 0;
    b2 = 0;
    Lines = 0;


    //
    // loop thru each byte in the file
    //

    for (j=0; j<TiffInstance->StripDataSize; j++) {


        octet = *plinebuf++;

        //
        // loop thru each bit in the byte
        //

        for (i=0; i<8; i++,octet<<=1) {

            if (code == DECODEEOL2) {

                //
                // we hit the final eol marker
                //

                if (TiffInstance->RunLength && TiffInstance->RunLength != lineWidth) {

                    if (TiffInstance->RunLength < lineWidth) {
                        TiffInstance->Color = 0;
                        OutputCodeBits( TiffInstance, lineWidth - TiffInstance->RunLength );
                    }

                    if (LastLineBad) {

                        BadFaxLines += 1;

                    } else {

                        if (BadFaxLines > TiffInstance->BadFaxLines) {
                            TiffInstance->BadFaxLines = BadFaxLines;
                        }
                        BadFaxLines = 1;
                        LastLineBad = TRUE;

                    }

                } else {

                    LastLineBad = FALSE;

                }

                if (!TiffInstance->StartGood) {
                    TiffInstance->StartGood = i - 1;
                }

                //
                // set the decoding tree
                //

                OneDimensional = (octet & 0x80) == 0x80;
                Tree = OneDimensional ? WhiteDecodeTree : TwoDecodeTree;

                //
                // reset the control variables
                //

                TiffInstance->Color = 0;
                code = 0;
                a0 = 0;
                a1 = 0;
                b1 = 0;
                b2 = 0;

                //
                // if there is a non-zero runlength then
                // spaw the reference & current line pointers
                // and count this line.  the runlength can be
                // zero when there is just an empty eol in
                // the stream.
                //

                if (SingleLineBuffer) {
                    TiffInstance->bitbuf = OutputBuffer;
                }

                if (TiffInstance->RunLength) {
                    TiffInstance->RunLength = 0;
                    Lines += 1;
                    prefline = pcurrline;
                    pcurrline = TiffInstance->bitbuf;

                } else {

                    //
                    // the eol count is maintained to that
                    // an rtc sequence is detected.
                    //

                    EolCount += 1;

                    if (EolCount == 6) {

                        //
                        // this is an rtc sequence, so any
                        // data that follows in the file
                        // is garbage.
                        //

                        goto good_exit;

                    }

                }

                continue;
            }

            if (code == DECODEEOL) {

                if (!(octet&0x80)) {
                    //
                    // here we skip all bits until we hit a 1 bit
                    // this happens when the first octet in a line
                    // is all zeroes and we detect that we are
                    // searching for an EOL
                    //
                    continue;
                }

                //
                // this forces the code to pickup the next
                // bit in the stream, which tells whether
                // the next line is encoded in MH or MR compression
                //
                code = DECODEEOL2;
                continue;

            }

            if (code == BADRUN) {

                code = 0;
                continue;

            }

            code = ((octet&0x80)>>7) ? Tree[code].Right : Tree[code].Left;

            b1 = NextChangingElement( prefline, a0, lineWidth, !TiffInstance->Color );
            b1 = NextChangingElement( prefline, b1, lineWidth,  TiffInstance->Color );

            b2 = NextChangingElement( prefline, b1, lineWidth, GetBit(prefline, b1 ) );

            if (OneDimensional) {

                if (code < 1) {

                    code = (-code);

                    OutputCodeBits( TiffInstance, code );

                    //
                    // the affect of this is to accumulate the runlengths
                    // into a0, causing a0 to be placed on a2 when horizontal
                    // mode is completed/
                    //

                    a0 += code;

                    if (code < 64) {

                        //
                        // terminating code
                        //
                        TiffInstance->Color = !TiffInstance->Color;
                        Tree = TiffInstance->Color ? BlackDecodeTree : WhiteDecodeTree;

                        if (HorzRuns) {

                            HorzRuns -= 1;

                            if (!HorzRuns) {

                                Tree = TwoDecodeTree;
                                OneDimensional = FALSE;

                            }

                        }

                    }

                    code = 0;

                }

                continue;

            }

            if (code == HORZMODE) {

                //
                // horizontal mode occurs when b1-a1 greater than 3
                //

                code= 0;
                HorzRuns = 2;
                OneDimensional = TRUE;
                Tree = TiffInstance->Color ? BlackDecodeTree : WhiteDecodeTree;

            } else if (code == PASSMODE) {

                //
                // pass mode occurs when the position of b2 lies
                // to the left of a1, but a1 cannot be equal to b2.
                //

                code = b2 - a0;
                OutputCodeBits( TiffInstance, code );
                code = 0;
                a0 = b2;

            } else if (code >= VTMODE3N && code <= VTMODE3P) {

                //
                // vertical mode occurs when b1-a1 <= 3
                //

                a1 = b1 - (VTMODE0 - code);
                code = a1 - a0;

                OutputCodeBits( TiffInstance, code );

                code = 0;
                a0 = a1;

                TiffInstance->Color = !TiffInstance->Color;

            }


        }
    }

good_exit:

    TiffInstance->EndGood = i;
    if (BadFaxLines > TiffInstance->BadFaxLines) {
        TiffInstance->BadFaxLines = BadFaxLines;
    }

    FlushBits( TiffInstance );
    TiffInstance->Lines = Lines;

    return TRUE;
}


BOOL
DecodeMMRFaxData(
    PTIFF_INSTANCE_DATA TiffInstance,
    LPBYTE              OutputBuffer,
    BOOL                SingleLineBuffer,
    DWORD               PadLength
    )

/*++

Routine Description:

    Decode a single page of 2 dimensionaly compressed
    TIFF data.

Arguments:

    TiffInstance    - Pointer to the TIFF instance data
    OutputBuffer    - Output buffer where the uncompressed data
                      is written.  This buffer must be allocated
                      by the caller and must be large enough for
                      a single page of data.

Return Value:

    NONE

--*/

{
    DWORD               i;
    DWORD               j;
    BYTE                octet;
    PDECODE_TREE        Tree;
    INT                 code;
    LPBYTE              prefline;
    LPBYTE              pcurrline;
    DWORD               HorzRuns;
    BOOL                OneDimensional;
    DWORD               a0;
    DWORD               a1;
    DWORD               b1;
    DWORD               b2;
    PBYTE               plinebuf;
    DWORD               lineWidth;
    DWORD               Lines;
    DWORD               EolCount;


    //
    // initialization
    //

    if (!SingleLineBuffer) {

        __try {

            FillMemory( OutputBuffer, TiffInstance->ImageHeight * (TiffInstance->ImageWidth / 8), WHITE );

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            return FALSE;

        }

    }

    Tree = TwoDecodeTree;
    code = 0;
    HorzRuns = 0;
    EolCount = 0;
    TiffInstance->Color = 0;
    TiffInstance->RunLength = 0;
    TiffInstance->bitdata = 0;
    TiffInstance->bitcnt = DWORDBITS;
    TiffInstance->bitbuf = OutputBuffer;
    OneDimensional = FALSE;
    plinebuf = TiffInstance->StripData;
    lineWidth = TiffInstance->ImageWidth;
    pcurrline = OutputBuffer;
    prefline = OutputBuffer;
    a0 = 0;
    a1 = 0;
    b1 = 0;
    b2 = 0;
    Lines = 0;


    //
    // loop thru each byte in the file
    //

    for (j=0; j<TiffInstance->StripDataSize; j++) {


        octet = *plinebuf++;

        //
        // loop thru each bit in the byte
        //

        for (i=0; i<8; i++,octet<<=1) {

            if (Lines + 1 == TiffInstance->ImageHeight && TiffInstance->RunLength == lineWidth)
            {
                goto good_exit;
            }

            //
            // if the OneDimensional flag is set and the RunLength == lineWidth
            // then it means that the last run length was horizontal mode
            // and it was not a terminating code.  in this case we must go
            // process the remaining termination code before ending the line.
            //
            // if the OneDimensional flag is NOT set and the RunLength == lineWidth
            // then we are at the end of a line.  for mmr compression there are
            // no eols, so this is the pseudo eol.
            //

            if ((TiffInstance->RunLength == lineWidth) && (!OneDimensional)) {
                //
                // set the decoding tree
                //

                Tree = TwoDecodeTree;

                //
                // reset the control variables
                //

                TiffInstance->Color = 0;
                code = 0;
                a0 = 0;
                a1 = 0;
                b1 = 0;
                b2 = 0;
                Tree = TwoDecodeTree;
                OneDimensional = FALSE;

                //
                // if there is a non-zero runlength then
                // spaw the reference & current line pointers
                // and count this line.  the runlength can be
                // zero when there is just an empty eol in
                // the stream.
                //

                if (SingleLineBuffer) {
                    TiffInstance->bitbuf = OutputBuffer;
                }

                TiffInstance->RunLength = 0;
                Lines += 1;
                prefline = pcurrline;
                pcurrline = TiffInstance->bitbuf;
                b1 = GetBit(prefline, 0) ? 0 : NextChangingElement(prefline, 0, lineWidth, 0);
            } else if (code == DECODEEOL2) {

                //
                // the eol count is maintained to that
                // an rtc sequence is detected.
                //

                EolCount += 1;

                if (EolCount == 2) {

                    //
                    // this is an rtc sequence, so any
                    // data that follows in the file
                    // is garbage.
                    //

                    goto good_exit;

                }

                continue;
            } else if (code == DECODEEOL) {

                if (!(octet&0x80)) {
                    //
                    // here we skip all bits until we hit a 1 bit
                    // this happens when the first octet in a line
                    // is all zeroes and we detect that we are
                    // searching for an EOL
                    //
                    continue;
                }

                //
                // this forces the code to pickup the next
                // bit in the stream, which tells whether
                // the next line is encoded in MH or MR compression
                //
                code = DECODEEOL2;
                continue;

            } else if (code == BADRUN) {

                code = 0;
                continue;

            } else {
                b1 = NextChangingElement( prefline, a0, lineWidth, !TiffInstance->Color );
                b1 = NextChangingElement( prefline, b1, lineWidth,  TiffInstance->Color );
            }

            b2 = NextChangingElement( prefline, b1, lineWidth, GetBit(prefline, b1 ) );

            code = ((octet&0x80)>>7) ? Tree[code].Right : Tree[code].Left;

            if (OneDimensional) {

                if (code < 1) {

                    code = (-code);

                    OutputCodeBits( TiffInstance, code );

                    //
                    // the affect of this is to accumulate the runlengths
                    // into a0, causing a0 to be placed on a2 when horizontal
                    // mode is completed/
                    //

                    a0 += code;

                    if (code < 64) {

                        //
                        // terminating code
                        //
                        TiffInstance->Color = !TiffInstance->Color;
                        Tree = TiffInstance->Color ? BlackDecodeTree : WhiteDecodeTree;

                        if (HorzRuns) {

                            HorzRuns -= 1;

                            if (!HorzRuns) {

                                Tree = TwoDecodeTree;
                                OneDimensional = FALSE;

                            }

                        }

                    }

                    code = 0;

                }

                continue;

            }

            if (code == HORZMODE) {

                //
                // horizontal mode occurs when b1-a1 greater than 3
                //

                code= 0;
                HorzRuns = 2;
                OneDimensional = TRUE;
                Tree = TiffInstance->Color ? BlackDecodeTree : WhiteDecodeTree;

            } else if (code == PASSMODE) {

                //
                // pass mode occurs when the position of b2 lies
                // to the left of a1, but a1 cannot be equal to b2.
                //

                code = b2 - a0;
                OutputCodeBits( TiffInstance, code );
                code = 0;
                a0 = b2;

            } else if (code >= VTMODE3N && code <= VTMODE3P) {

                //
                // vertical mode occurs when b1-a1 <= 3
                //

                a1 = b1 - (VTMODE0 - code);
                code = a1 - a0;

                OutputCodeBits( TiffInstance, code );

                code = 0;
                a0 = a1;

                TiffInstance->Color = !TiffInstance->Color;

            }

        }
    }

good_exit:
    FlushBits( TiffInstance );
    TiffInstance->Lines = Lines;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\tiff\src\encode.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    encode.c

Abstract:

    This file contains functions for encoding (compressing)
    uncompressed 1 bit per pel data into a TIFF data
    stream.  The supported compression algorithms are
    as follows:

        o  Uncompressed (raw)
        o  One dimensional - MH or Modified Huffman
        o  Two dimensional - MR or Modified Read

Environment:

        WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "tifflibp.h"
#pragma hdrstop




#if TIFFDBG
VOID
PrintRunInfo(
    INT     Mode,
    INT     Run,
    INT     BitLen,
    WORD    Code
    )

/*++

Routine Description:

    Prints run information to standard out.  This
    function is available only if TIFFDBG is TRUE.

Arguments:

    Mode    - Encoding mode: vertical, horizontal, pass, or raw
    Run     - Run length
    BitLen  - Number of bits
    Code    - The actual bits

Return Value:

    None.

--*/

{
    TCHAR BitBuf[16];
    INT i;
    WORD j;


    _tprintf( TEXT("\t") );

    if (Mode) {
        switch( Mode ) {
            case 1:
                _tprintf( TEXT("pass mode ") );
                break;

            case 2:
                _tprintf( TEXT("vertical mode run=%d, "), Run );
                break;

            case 3:
                _tprintf( TEXT("horizontal mode ") );
                break;
        }
    } else {
        _tprintf( TEXT("run=%d, bitlen=%d, "), Run, BitLen );
    }

    j = Code << (16 - BitLen);

    for (i=0; i<BitLen; i++,j<<=1) {
        if (j & 0x8000) {
            BitBuf[i] = TEXT('1');
        } else {
            BitBuf[i] = TEXT('0');
        }
    }
    BitBuf[i] = 0;

    _tprintf( TEXT("value=%04x, bits=%s\n"), Code << (16 - BitLen), BitBuf );
}
#endif


VOID
OutputEOL(
    PTIFF_INSTANCE_DATA TiffInstance,
    BOOL                OneDimensional
    )

/*++

Routine Description:

    Output EOL code at the beginning of each scanline

Arguments:

    TiffInstance    - Pointer to the TIFF instance data
    OneDimensional  - TRUE for MH encoding

Return Value:

    None.

--*/

{
    DWORD   length, code;

    //
    // EOL code word always ends on a byte boundary
    //
    code = EOL_CODE;
    length = EOL_LENGTH + ((TiffInstance->bitcnt - EOL_LENGTH) & 7);
    OutputBits( TiffInstance, (WORD) length, (WORD) code );

    //
    // When using MR encoding, append a 1 or 0 depending whether
    // we're the line should be MH or MR encoded.
    //
    if (TiffInstance->CompressionType == TIFF_COMPRESSION_MR) {
        OutputBits( TiffInstance, (WORD) 1, (WORD) (OneDimensional ? 1 : 0) );
    }
}


VOID
OutputRun(
    PTIFF_INSTANCE_DATA TiffInstance,
    INT                 run,
    PCODETABLE          pCodeTable
    )

/*++

Routine Description:

    Output a single run (black or white) using the specified code table

Arguments:

    TiffInstance    - Pointer to the TIFF instance data
    run             - Specifies the length of the run
    pCodeTable      - Specifies the code table to use

Return Value:

    None.

--*/

{
    PCODETABLE  pTableEntry;

    //
    // Use make-up code word for 2560 for any runs of at least 2624 pixels
    // This is currently not necessary for us since our scanlines always
    // have 1728 pixels.
    //

    while (run >= 2624) {

        pTableEntry = pCodeTable + (63 + (2560 >> 6));
        OutputBits( TiffInstance, pTableEntry->length, pTableEntry->code );
#if TIFFDBG
        PrintRunInfo( 0, run, pTableEntry->length, pTableEntry->code );
#endif
        run -= 2560;
    }

    //
    // Use appropriate make-up code word if the run is longer than 63 pixels
    //

    if (run >= 64) {

        pTableEntry = pCodeTable + (63 + (run >> 6));
        OutputBits( TiffInstance, pTableEntry->length, pTableEntry->code );
#if TIFFDBG
        PrintRunInfo( 0, run, pTableEntry->length, pTableEntry->code );
#endif
        run &= 0x3f;
    }

    //
    // Output terminating code word
    //

    OutputBits( TiffInstance, pCodeTable[run].length, pCodeTable[run].code );
#if TIFFDBG
        PrintRunInfo( 0, run, pCodeTable[run].length, pCodeTable[run].code );
#endif
}


BOOL
EncodeFaxDataNoCompression(
    PTIFF_INSTANCE_DATA TiffInstance,
    PBYTE               plinebuf,
    INT                 lineWidth
    )

/*++

Routine Description:

    Encodes a single line of TIFF data using no compression.
    This is basically raw data.

Arguments:

    TiffInstance    - Pointer to the TIFF instance data
    plinebuf        - Pointer to the input data
    lineWidth       - Width of the line in pixels

Return Value:

    TRUE for success, FALSE for failure

--*/

{
    DWORD               Bytes;


#if TIFFDBG
    _tprintf( TEXT("encoding(raw) line #%d\n"), TiffInstance->Lines );
#endif

    WriteFile(
        TiffInstance->hFile,
        plinebuf,
        lineWidth / 8,
        &Bytes,
        NULL
        );

    TiffInstance->Bytes += Bytes;

    return TRUE;
}


BOOL
EncodeFaxDataMhCompression(
    PTIFF_INSTANCE_DATA TiffInstance,
    PBYTE               plinebuf,
    INT                 lineWidth
    )

/*++

Routine Description:

    Encodes a single line of TIFF data using 1 dimensional
    TIFF compression.

Arguments:

    TiffInstance    - Pointer to the TIFF instance data
    plinebuf        - Pointer to the input data
    lineWidth       - Width of the line in pixels

Return Value:

    TRUE for success, FALSE for failure

--*/

{
    INT     bitIndex, run, runLength;


#if TIFFDBG
    _tprintf( TEXT("encoding line #%d\n"), TiffInstance->Lines );
#endif

    bitIndex = 0;
    runLength = 0;

    OutputEOL( TiffInstance, TRUE );

    while (TRUE) {

        //
        // Code white run
        //

        run = FindWhiteRun( plinebuf, bitIndex, lineWidth );
        runLength += run;
        OutputRun( TiffInstance, run, WhiteRunCodes );

        if ((bitIndex += run) >= lineWidth)
            break;

        //
        // Code black run
        //

        run = FindBlackRun(plinebuf, bitIndex, lineWidth);
        runLength += run;
        OutputRun( TiffInstance, run, BlackRunCodes );

        if ((bitIndex += run) >= lineWidth)
            break;
    }

    CopyMemory( TiffInstance->RefLine, plinebuf, lineWidth/8 );

    return TRUE;
}


BOOL
EncodeFaxDataMmrCompression(
    PTIFF_INSTANCE_DATA TiffInstance,
    PBYTE               plinebuf,
    INT                 lineWidth
    )

/*++

Routine Description:

    Encodes a single line of TIFF data using 2 dimensional
    TIFF compression.

Arguments:

    TiffInstance    - Pointer to the TIFF instance data
    plinebuf        - Pointer to the input data
    lineWidth       - Width of the line in pixels

Return Value:

    TRUE for success, FALSE for failure

--*/

{
    INT a0, a1, a2, b1, b2, distance;
    LPBYTE prefline;


#if TIFFDBG
    _tprintf( TEXT("encoding line #%d\n"), TiffInstance->Lines );
#endif

    OutputEOL( TiffInstance, FALSE );

    //
    // Use 2-dimensional encoding scheme
    //

    prefline = TiffInstance->RefLine;
    a0 = 0;
    a1 = GetBit( plinebuf, 0) ? 0 : NextChangingElement(plinebuf, 0, lineWidth, 0 );
    b1 = GetBit( prefline, 0) ? 0 : NextChangingElement(prefline, 0, lineWidth, 0 );

    while (TRUE) {

        b2 = (b1 >= lineWidth) ? lineWidth :
                NextChangingElement( prefline, b1, lineWidth, GetBit(prefline, b1 ));

        if (b2 < a1) {

            //
            // Pass mode
            //

            OutputBits( TiffInstance, PASSCODE_LENGTH, PASSCODE );
#if TIFFDBG
            PrintRunInfo( 1, 0, PASSCODE_LENGTH, PASSCODE );
            _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif
            a0 = b2;

        } else if ((distance = a1 - b1) <= 3 && distance >= -3) {

            //
            // Vertical mode
            //

            OutputBits( TiffInstance, VertCodes[distance+3].length, VertCodes[distance+3].code );
#if TIFFDBG
            PrintRunInfo( 2, a1-a0, VertCodes[distance+3].length, VertCodes[distance+3].code );
            _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif
            a0 = a1;

        } else {

            //
            // Horizontal mode
            //

            a2 = (a1 >= lineWidth) ? lineWidth :
                    NextChangingElement( plinebuf, a1, lineWidth, GetBit( plinebuf, a1 ) );

            OutputBits( TiffInstance, HORZCODE_LENGTH, HORZCODE );
#if TIFFDBG
            PrintRunInfo( 3, 0, HORZCODE_LENGTH, HORZCODE );
            _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif

            if (a1 != 0 && GetBit( plinebuf, a0 )) {

                OutputRun( TiffInstance, a1-a0, BlackRunCodes );
                OutputRun( TiffInstance, a2-a1, WhiteRunCodes );

            } else {

                OutputRun( TiffInstance, a1-a0, WhiteRunCodes );
                OutputRun( TiffInstance, a2-a1, BlackRunCodes );
            }

            a0 = a2;
        }

        if (a0 >= lineWidth) {
            break;
        }

        a1 = NextChangingElement( plinebuf, a0, lineWidth, GetBit( plinebuf, a0 ) );
        b1 = NextChangingElement( prefline, a0, lineWidth, !GetBit( plinebuf, a0 ) );
        b1 = NextChangingElement( prefline, b1, lineWidth, GetBit( plinebuf, a0 ) );
    }


    CopyMemory( TiffInstance->RefLine, plinebuf, TiffInstance->BytesPerLine );

    return TRUE;
}


BOOL
EncodeFaxData(
    PTIFF_INSTANCE_DATA TiffInstance,
    PBYTE               plinebuf,
    INT                 lineWidth,
    DWORD               CompressionType
    )

/*++

Routine Description:

    Encodes a single line of TIFF data using the specified
    compression method.

Arguments:

    TiffInstance    - Pointer to the TIFF instance data
    plinebuf        - Pointer to the input data
    lineWidth       - Width of the line in pixels
    CompressionType - Requested compression method

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    switch( CompressionType ) {
        case TIFF_COMPRESSION_NONE:
            return EncodeFaxDataNoCompression( TiffInstance, plinebuf, lineWidth );

        case TIFF_COMPRESSION_MH:
            return EncodeFaxDataMhCompression( TiffInstance, plinebuf, lineWidth );

        case TIFF_COMPRESSION_MR:
            if (!TiffInstance->Lines) {
                return EncodeFaxDataMhCompression( TiffInstance, plinebuf, lineWidth );
            }
            return EncodeFaxDataMmrCompression( TiffInstance, plinebuf, lineWidth );
    }

    return FALSE;
}


BOOL
EncodeFaxPageMmrCompression(
    PTIFF_INSTANCE_DATA TiffInstance,
    PBYTE               plinebuf,
    INT                 lineWidth,
    DWORD               ImageHeight,
    DWORD               *DestSize
    )

/*++

Routine Description:

    Encodes a page of TIFF data using 2 dimensional
    TIFF compression.

Arguments:

    TiffInstance    - Pointer to the TIFF instance data
    plinebuf        - Pointer to the input data
    lineWidth       - Width of the line in pixels

Return Value:

    TRUE for success, FALSE for failure

--*/

{
    INT a0, a1, a2, b1, b2, distance;
    LPBYTE prefline;
    BYTE pZeroline[1728/8];
    DWORD Lines=0;
    LPBYTE StartBitbuf = TiffInstance->bitbuf;


    // set first all white reference line

    prefline = pZeroline;

    ZeroMemory( pZeroline, sizeof(pZeroline) );

    // loop til end

    do {


        //
        // Use 2-dimensional encoding scheme
        //


        a0 = 0;
        a1 = GetBit( plinebuf, 0) ? 0 : NextChangingElement(plinebuf, 0, lineWidth, 0 );
        b1 = GetBit( prefline, 0) ? 0 : NextChangingElement(prefline, 0, lineWidth, 0 );

        while (TRUE) {

            b2 = (b1 >= lineWidth) ? lineWidth :
                    NextChangingElement( prefline, b1, lineWidth, GetBit(prefline, b1 ));

            if (b2 < a1) {

                //
                // Pass mode
                //

                OutputBits( TiffInstance, PASSCODE_LENGTH, PASSCODE );
#if TIFFDBG
                PrintRunInfo( 1, 0, PASSCODE_LENGTH, PASSCODE );
                _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif
                a0 = b2;

            } else if ((distance = a1 - b1) <= 3 && distance >= -3) {

                //
                // Vertical mode
                //

                OutputBits( TiffInstance, VertCodes[distance+3].length, VertCodes[distance+3].code );
#if TIFFDBG
                PrintRunInfo( 2, a1-a0, VertCodes[distance+3].length, VertCodes[distance+3].code );
                _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif
                a0 = a1;

            } else {

                //
                // Horizontal mode
                //

                a2 = (a1 >= lineWidth) ? lineWidth :
                        NextChangingElement( plinebuf, a1, lineWidth, GetBit( plinebuf, a1 ) );

                OutputBits( TiffInstance, HORZCODE_LENGTH, HORZCODE );
#if TIFFDBG
                PrintRunInfo( 3, 0, HORZCODE_LENGTH, HORZCODE );
                _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif

                if (a1 != 0 && GetBit( plinebuf, a0 )) {

                    OutputRun( TiffInstance, a1-a0, BlackRunCodes );
                    OutputRun( TiffInstance, a2-a1, WhiteRunCodes );

                } else {

                    OutputRun( TiffInstance, a1-a0, WhiteRunCodes );
                    OutputRun( TiffInstance, a2-a1, BlackRunCodes );
                }

                a0 = a2;
            }

            if (a0 >= lineWidth) {
                Lines++;
                break;
            }

            a1 = NextChangingElement( plinebuf, a0, lineWidth, GetBit( plinebuf, a0 ) );
            b1 = NextChangingElement( prefline, a0, lineWidth, !GetBit( plinebuf, a0 ) );
            b1 = NextChangingElement( prefline, b1, lineWidth, GetBit( plinebuf, a0 ) );
        }

        prefline = plinebuf;
        plinebuf += TiffInstance->BytesPerLine;

    } while (Lines < ImageHeight);

    OutputEOL( TiffInstance, FALSE );

    *DestSize = (DWORD)(TiffInstance->bitbuf - StartBitbuf);
    TiffInstance->Lines = Lines;

    return TRUE;
}





BOOL
EncodeMmrBranding(
    PBYTE               pBrandBits,
    LPDWORD             pMmrBrandBits,
    INT                 BrandHeight,
    INT                 BrandWidth,
    DWORD              *DwordsOut,
    DWORD              *BitsOut
    )

/*++

Routine Description:

   Encode an MMR branding from uncompressed branding bits.
   I don't have enough time to write an optimized
   Uncompressed -> MMR convertor, so the compromise is
   to use the existing Uncompressed Decoder (fast enough)
   and use the optimized MMR Encoder.
   Since we only convert few lines for Branding, it's OK.

--*/

{
    INT         a0, a1, a2, b1, b2, distance;
    LPBYTE      prefline;
    BYTE        pZeroline[1728/8];
    INT         Lines = 0;
    LPDWORD     lpdwOut = pMmrBrandBits;
    BYTE        BitOut = 0;



    // set first all white reference line

    prefline = pZeroline;

    ZeroMemory(pZeroline, BrandWidth/8);

    // loop til all lines done

    do {

        a0 = 0;
        a1 = GetBit( pBrandBits, 0) ? 0 : NextChangingElement(pBrandBits, 0, BrandWidth, 0 );
        b1 = GetBit( prefline, 0) ? 0 : NextChangingElement(prefline, 0, BrandWidth, 0 );

        while (TRUE) {

            b2 = (b1 >= BrandWidth) ? BrandWidth :
                    NextChangingElement( prefline, b1, BrandWidth, GetBit(prefline, b1 ));

            if (b2 < a1) {

                //
                // Pass mode
                //

                //OutputBits( TiffInstance, PASSCODE_LENGTH, PASSCODE );
                (*lpdwOut) += ( ((DWORD) (PASSCODE_REVERSED)) << BitOut);
                if ( (BitOut = BitOut + PASSCODE_LENGTH ) > 31 ) {
                    BitOut -= 32;
                    *(++lpdwOut) = ( (DWORD) (PASSCODE_REVERSED) ) >> (PASSCODE_LENGTH - BitOut);
                }


#if TIFFDBG
                PrintRunInfo( 1, 0, PASSCODE_LENGTH, PASSCODE );
                _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif
                a0 = b2;

            } else if ((distance = a1 - b1) <= 3 && distance >= -3) {

                //
                // Vertical mode
                //

                // OutputBits( TiffInstance, VertCodes[distance+3].length, VertCodes[distance+3].code );
                (*lpdwOut) += ( ( (DWORD) VertCodesReversed[distance+3].code) << BitOut);
                if ( (BitOut = BitOut + VertCodesReversed[distance+3].length ) > 31 ) {
                    BitOut -= 32;
                    *(++lpdwOut) = ( (DWORD) (VertCodesReversed[distance+3].code) ) >> (VertCodesReversed[distance+3].length - BitOut);
                }

#if TIFFDBG
                PrintRunInfo( 2, a1-a0, VertCodes[distance+3].length, VertCodes[distance+3].code );
                _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif
                a0 = a1;

            } else {

                //
                // Horizontal mode
                //

                a2 = (a1 >= BrandWidth) ? BrandWidth :
                        NextChangingElement( pBrandBits, a1, BrandWidth, GetBit( pBrandBits, a1 ) );

                // OutputBits( TiffInstance, HORZCODE_LENGTH, HORZCODE );
                (*lpdwOut) += ( ((DWORD) (HORZCODE_REVERSED)) << BitOut);
                if ( (BitOut = BitOut + HORZCODE_LENGTH ) > 31 ) {
                    BitOut -= 32;
                    *(++lpdwOut) = ( (DWORD) (HORZCODE_REVERSED) ) >> (HORZCODE_LENGTH - BitOut);
                }



#if TIFFDBG
                PrintRunInfo( 3, 0, HORZCODE_LENGTH, HORZCODE );
                _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif

                if (a1 != 0 && GetBit( pBrandBits, a0 )) {

                    //OutputRun( TiffInstance, a1-a0, BlackRunCodes );
                    //OutputRun( TiffInstance, a2-a1, WhiteRunCodes );
                    OutputRunFastReversed(a1-a0, BLACK, &lpdwOut, &BitOut);
                    OutputRunFastReversed(a2-a1, WHITE, &lpdwOut, &BitOut);

                } else {

                    //OutputRun( TiffInstance, a1-a0, WhiteRunCodes );
                    //OutputRun( TiffInstance, a2-a1, BlackRunCodes );
                    OutputRunFastReversed(a1-a0, WHITE, &lpdwOut, &BitOut);
                    OutputRunFastReversed(a2-a1, BLACK, &lpdwOut, &BitOut);

                }

                a0 = a2;
            }

            if (a0 >= BrandWidth) {
                Lines++;
                break;
            }

            a1 = NextChangingElement( pBrandBits, a0, BrandWidth, GetBit( pBrandBits, a0 ) );
            b1 = NextChangingElement( prefline, a0, BrandWidth, !GetBit( pBrandBits, a0 ) );
            b1 = NextChangingElement( prefline, b1, BrandWidth, GetBit( pBrandBits, a0 ) );
        }

        prefline = pBrandBits;
        pBrandBits += (BrandWidth / 8);

    } while (Lines < BrandHeight);

    *DwordsOut = (DWORD)(lpdwOut - pMmrBrandBits);
    *BitsOut  = BitOut;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\tiff\inc\tifflib.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tifflib.h

Abstract:

    This file contains the interfaces for the
    Windows NT FAX Server TIFF I/O Library.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/


#ifndef _TIFFLIB_
#define _TIFFLIB_

#ifdef __cplusplus
extern "C" {
#endif


#define TIFF_COMPRESSION_NONE     1
#define TIFF_COMPRESSION_MH       2
#define TIFF_COMPRESSION_MR       3
#define TIFF_COMPRESSION_MMR      4


typedef struct _TIFF_INFO {
    DWORD   ImageWidth;
    DWORD   ImageHeight;
    DWORD   PageCount;
    DWORD   PhotometricInterpretation;
    DWORD   ImageSize;
    DWORD   CompressionType;
    DWORD   FillOrder;
    DWORD   YResolution;
} UNALIGNED TIFF_INFO, *PTIFF_INFO;

typedef struct _MS_TAG_INFO {
    LPWSTR      RecipName;
    LPWSTR      RecipNumber;
    LPWSTR      SenderName;
    LPWSTR      Routing;
    LPWSTR      CallerId;
    LPWSTR      Csid;
    LPWSTR      Tsid;
    DWORDLONG   FaxTime;
} MS_TAG_INFO, *PMS_TAG_INFO;


HANDLE
TiffCreate(
    LPTSTR FileName,
    DWORD  CompressionType,
    DWORD  ImageWidth,
    DWORD  FillOrder,
    DWORD  HiRes
    );

HANDLE
TiffOpen(
    LPTSTR FileName,
    PTIFF_INFO TiffInfo,
    BOOL ReadOnly,
    DWORD RequestedFillOrder
    );

BOOL
TiffClose(
    HANDLE hTiff
    );

BOOL
TiffStartPage(
    HANDLE hTiff
    );

BOOL
TiffEndPage(
    HANDLE hTiff
    );

BOOL
TiffWrite(
    HANDLE hTiff,
    LPBYTE TiffData
    );


BOOL
TiffWriteRaw(
    HANDLE hTiff,
    LPBYTE TiffData,
    DWORD Size
    );

BOOL
TiffRead(
    HANDLE hTiff,
    LPBYTE TiffData,
    DWORD PadLength
    );

BOOL
TiffReadRaw(
    HANDLE  hTiff,
    IN OUT  LPBYTE Buffer,
    IN OUT  LPDWORD BufferSize,
    IN      DWORD RequestedCompressionType,
    IN      DWORD FillOrder,
    IN      BOOL HiRes
    );


BOOL
TiffSeekToPage(
    HANDLE hTiff,
    DWORD PageNumber,
    DWORD FillOrder
    );

BOOL
TiffPostProcess(
    LPTSTR FileName
    );


BOOL
TiffRecoverGoodPages(
    LPWSTR SrcFileName,
    LPDWORD RecoveredPages,
    LPDWORD TotalPages
    );

// fast tiff



void
BuildLookupTables(
    DWORD TableLength
    );


BOOL
DecodeMrPage(
    HANDLE              hTiff,
    LPBYTE              OutputBuffer,
    BOOL                SingleLineBuffer,
    BOOL                HiRes
    );


BOOL
DecodeMhPage(
    HANDLE              hTiff,
    LPBYTE              OutputBuffer,
    BOOL                SingleLineBuffer
    );


BOOL
DecodeMmrPage(
    HANDLE              hTiff,
    LPBYTE              OutputBuffer,
    BOOL                SingleLineBuffer,
    BOOL                HiRes
    );





BOOL
ConvMmrPageToMrSameRes(
    HANDLE              hTiff,
    LPDWORD             lpdwOutputBuffer,
    DWORD               *lpdwSizeOutputBuffer,
    BOOL                NegotHiRes
    );


BOOL
ConvMmrPageHiResToMrLoRes(
    HANDLE              hTiff,
    LPDWORD             lpdwOutputBuffer,
    DWORD               *lpdwSizeOutputBuffer
    );



BOOL
ConvMmrPageToMh(
    HANDLE              hTiff,
    LPDWORD             lpdwOutputBuffer,
    DWORD               *lpdwSizeOutputBuffer,
    BOOL                NegotHiRes,
    BOOL                SrcHiRes
    );


BOOL
ConvMmrHiResToLowRes(
    LPTSTR              SrcFileName,
    LPTSTR              DestFileName
    );


BOOL
ConvFileMhToMmr(
    LPTSTR              SrcFileName,
    LPTSTR              DestFileName
    );


BOOL
OutputMmrLine(
    LPDWORD     lpdwOut,
    BYTE        BitOut,
    WORD       *pCurLine,
    WORD       *pRefLine,
    LPDWORD    *lpdwResPtr,
    BYTE       *ResBit,
    LPDWORD     lpdwOutLimit
    );


BOOL
TiffPostProcessFast(
    LPTSTR SrcFileName,
    LPTSTR DstFileName          // can be null for generated name
    );



BOOL
MmrAddBranding(
    LPTSTR              SrcFileName,
    LPTSTR              Branding,
    LPTSTR              BrandingOf,
    INT                 BrandingHeight
    );


BOOL
ScanMhSegment(
    LPDWORD             *lplpdwResPtr,
    BYTE                *lpResBit,
    LPDWORD              EndPtr,
    LPDWORD              EndBuffer,
    DWORD               *Lines,
    DWORD               *BadFaxLines,
    DWORD               *ConsecBadLines,
    DWORD                AllowedBadFaxLines,
    DWORD                AllowedConsecBadLines
    );

BOOL
ScanMrSegment(
    LPDWORD             *lplpdwResPtr,
    BYTE                *lpResBit,
    LPDWORD              EndPtr,
    LPDWORD              EndBuffer,
    DWORD               *Lines,
    DWORD               *BadFaxLines,
    DWORD               *ConsecBadLines,
    DWORD                AllowedBadFaxLines,
    DWORD                AllowedConsecBadLines,
    BOOL                *f1D
    );


BOOL
FaxTiffInitialize();

BOOL
TiffGetCurrentPageData(
    HANDLE      hTiff,
    LPDWORD     Lines,
    LPDWORD     StripDataSize,
    LPDWORD     ImageWidth,
    LPDWORD     ImageHeight
    );

BOOL
TiffUncompressMmrPage(
    HANDLE      hTiff,
    LPDWORD     lpdwOutputBuffer,
    LPDWORD     Lines
    );

BOOL
TiffUncompressMmrPageRaw(
    LPBYTE      StripData,
    DWORD       StripDataSize,
    DWORD       ImageWidth,
    LPDWORD     lpdwOutputBuffer,
    LPDWORD     LinesOut
    );

BOOL
TiffExtractFirstPage(
    LPWSTR FileName,
    LPBYTE *Buffer,
    LPDWORD BufferSize,
    LPDWORD ImageWidth,
    LPDWORD ImageHeight
    );

BOOL
TiffAddMsTags(
    LPWSTR FileName,
    PMS_TAG_INFO MsTagInfo
    );

BOOL
PrintTiffFile(
    HDC PrinterDC,
    LPWSTR FileName
    );

#define TIFFCF_ORIGINAL_FILE_GOOD       0x00000001
#define TIFFCF_UNCOMPRESSED_BITS        0x00000002
#define TIFFCF_NOT_TIFF_FILE            0x00000004

BOOL
ConvertTiffFileToValidFaxFormat(
    LPWSTR TiffFileName,
    LPWSTR NewFileName,
    LPDWORD Flags
    );

BOOL
MergeTiffFiles(
    LPWSTR BaseTiffFile,
    LPWSTR NewTiffFile
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\tiff\src\fasttiff.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fasttiff.h

Abstract:

    This module defines and exposes Fast TIFF structures.

Author:

    Rafael Lisitsa (RafaelL) 14-Aug-1996

Revision History:

--*/



#define  LINE_LENGTH   1728
#define  MaxColorTransPerLine (LINE_LENGTH + 3)


#define  DO_NOT_TEST_LENGTH  0
#define  DO_TEST_LENGTH      1

//  this makes BLACK_COLOR = 1
#define  WHITE_COLOR   0

#define  EOL_FOUND     99

// makeup/terminate
#define  MAKEUP_CODE      1
#define  TERMINATE_CODE   0

// additional useful codes
#define  ERROR_CODE             30
#define  LOOK_FOR_EOL_CODE      31
#define  EOL_FOUND_CODE         32
#define  NO_MORE_RECORDS        33

#define  ERROR_PREFIX            7
#define  LOOK_FOR_EOL_PREFIX     6
#define  PASS_PREFIX             5
#define  HORIZ_PREFIX            4

#define TIFF_SCAN_SEG_END        1
#define TIFF_SCAN_FAILURE        2
#define TIFF_SCAN_SUCCESS        3

#define MINUS_ONE_DWORD          ( (DWORD) 0xffffffff )
#define MINUS_ONE_BYTE           ( (BYTE) 0xff )


typedef struct {
    char        Tail          :4;
    char        Value         :4;
} PREF_BYTE;






BOOL
FindNextEol(
    LPDWORD     lpdwStartPtr,
    BYTE        dwStartBit,
    LPDWORD     lpdwEndPtr,
    LPDWORD    *lpdwResPtr,
    BYTE       *ResBit,
    BOOL        fTestlength,
    BOOL       *fError
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\tiff\src\tifftabl.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tifftabl.h

Abstract:

    Tables used for Group3 fax compression and decompression.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/


#ifndef _FAXTABLE_H_
#define _FAXTABLE_H_

//
// Data structure for representing code table entries
//

typedef struct _CODETABLE {

    WORD    length;     // code length
    WORD    code;       // code word itself

} CODETABLE;

typedef const CODETABLE *PCODETABLE;

//
// Code word for end-of-line (EOL)
//  000000000001
//

#define EOL_CODE                   1
#define EOL_REVERSED_CODE          0x0800
#define EOL_LENGTH                 12

#define TAG_1D_EOL_REVERSED_CODE   0x1001
#define TAG_1D_EOL_LENGTH          13

//
// Code word for 2D encoding - pass mode
//  0001
//

#define PASSCODE        1
#define PASSCODE_REVERSED  0x08
#define PASSCODE_LENGTH 4

//
// Code word for 2D encoding - horizontal mode prefix
//  001
//

#define HORZCODE        1
#define HORZCODE_REVERSED  0x04
#define HORZCODE_LENGTH 3

//
// Code word for 2D encoding - vertical mode
//

static const CODETABLE VertCodes[] = {

    {  7, 0x02 },       // 0000010     VTMODE3N
    {  6, 0x02 },       // 000010      VTMODE2N
    {  3, 0x02 },       // 010         VTMODE1N
    {  1, 0x01 },       // 1           VTMODE0
    {  3, 0x03 },       // 011         VTMODE1P
    {  6, 0x03 },       // 000011      VTMODE2P
    {  7, 0x03 },       // 0000011     VTMODE3P
};


static const CODETABLE VertCodesReversed[] = {

    {  7, 0x20 },       // 010 0000    VTMODE3N
    {  6, 0x10 },       // 01 0000     VTMODE2N
    {  3, 0x02 },       // 010         VTMODE1N
    {  1, 0x01 },       // 1           VTMODE0
    {  3, 0x06 },       // 110         VTMODE1P
    {  6, 0x30 },       // 11 0000     VTMODE2P
    {  7, 0x60 },       // 110 0000    VTMODE3P
};




//
// Code table for white runs
//

static const CODETABLE WhiteRunCodes[] = {

    {  8, 0x35 },       // 00110101            0         0
    {  6, 0x07 },       // 000111              1         1
    {  4, 0x07 },       // 0111                2         2
    {  4, 0x08 },       // 1000                3         3
    {  4, 0x0b },       // 1011                4         4
    {  4, 0x0c },       // 1100                5         5
    {  4, 0x0e },       // 1110                6         6
    {  4, 0x0f },       // 1111                7         7
    {  5, 0x13 },       // 10011               8         8
    {  5, 0x14 },       // 10100               9         9
    {  5, 0x07 },       // 00111              10        10
    {  5, 0x08 },       // 01000              11        11
    {  6, 0x08 },       // 001000             12        12
    {  6, 0x03 },       // 000011             13        13
    {  6, 0x34 },       // 110100             14        14
    {  6, 0x35 },       // 110101             15        15
    {  6, 0x2a },       // 101010             16        16
    {  6, 0x2b },       // 101011             17        17
    {  7, 0x27 },       // 0100111            18        18
    {  7, 0x0c },       // 0001100            19        19
    {  7, 0x08 },       // 0001000            20        20
    {  7, 0x17 },       // 0010111            21        21
    {  7, 0x03 },       // 0000011            22        22
    {  7, 0x04 },       // 0000100            23        23
    {  7, 0x28 },       // 0101000            24        24
    {  7, 0x2b },       // 0101011            25        25
    {  7, 0x13 },       // 0010011            26        26
    {  7, 0x24 },       // 0100100            27        27
    {  7, 0x18 },       // 0011000            28        28
    {  8, 0x02 },       // 00000010           29        29
    {  8, 0x03 },       // 00000011           30        30
    {  8, 0x1a },       // 00011010           31        31
    {  8, 0x1b },       // 00011011           32        32
    {  8, 0x12 },       // 00010010           33        33
    {  8, 0x13 },       // 00010011           34        34
    {  8, 0x14 },       // 00010100           35        35
    {  8, 0x15 },       // 00010101           36        36
    {  8, 0x16 },       // 00010110           37        37
    {  8, 0x17 },       // 00010111           38        38
    {  8, 0x28 },       // 00101000           39        39
    {  8, 0x29 },       // 00101001           40        40
    {  8, 0x2a },       // 00101010           41        41
    {  8, 0x2b },       // 00101011           42        42
    {  8, 0x2c },       // 00101100           43        43
    {  8, 0x2d },       // 00101101           44        44
    {  8, 0x04 },       // 00000100           45        45
    {  8, 0x05 },       // 00000101           46        46
    {  8, 0x0a },       // 00001010           47        47
    {  8, 0x0b },       // 00001011           48        48
    {  8, 0x52 },       // 01010010           49        49
    {  8, 0x53 },       // 01010011           50        50
    {  8, 0x54 },       // 01010100           51        51
    {  8, 0x55 },       // 01010101           52        52
    {  8, 0x24 },       // 00100100           53        53
    {  8, 0x25 },       // 00100101           54        54
    {  8, 0x58 },       // 01011000           55        55
    {  8, 0x59 },       // 01011001           56        56
    {  8, 0x5a },       // 01011010           57        57
    {  8, 0x5b },       // 01011011           58        58
    {  8, 0x4a },       // 01001010           59        59
    {  8, 0x4b },       // 01001011           50        60
    {  8, 0x32 },       // 00110010           51        61
    {  8, 0x33 },       // 00110011           52        62
    {  8, 0x34 },       // 00110100           53        63
    {  5, 0x1b },       // 11011              54        64
    {  5, 0x12 },       // 10010              55       128
    {  6, 0x17 },       // 010111             56       192
    {  7, 0x37 },       // 0110111            57       256
    {  8, 0x36 },       // 00110110           58       320
    {  8, 0x37 },       // 00110111           59       384
    {  8, 0x64 },       // 01100100           60       448
    {  8, 0x65 },       // 01100101           61       512
    {  8, 0x68 },       // 01101000           62       576
    {  8, 0x67 },       // 01100111           63       640
    {  9, 0xcc },       // 011001100          64       704
    {  9, 0xcd },       // 011001101          65       768
    {  9, 0xd2 },       // 011010010          66       832
    {  9, 0xd3 },       // 011010011          67       896
    {  9, 0xd4 },       // 011010100          68       960
    {  9, 0xd5 },       // 011010101          69      1024
    {  9, 0xd6 },       // 011010110          70      1088
    {  9, 0xd7 },       // 011010111          71      1152
    {  9, 0xd8 },       // 011011000          72      1216
    {  9, 0xd9 },       // 011011001          73      1280
    {  9, 0xda },       // 011011010          74      1344
    {  9, 0xdb },       // 011011011          75      1408
    {  9, 0x98 },       // 010011000          76      1472
    {  9, 0x99 },       // 010011001          77      1536
    {  9, 0x9a },       // 010011010          78      1600
    {  6, 0x18 },       // 011000             79      1664
    {  9, 0x9b },       // 010011011          80      1728
    { 11, 0x08 },       // 00000001000        81      1792
    { 11, 0x0c },       // 00000001100        82      1856
    { 11, 0x0d },       // 00000001101        83      1920
    { 12, 0x12 },       // 000000010010       84      1984
    { 12, 0x13 },       // 000000010011       85      2048
    { 12, 0x14 },       // 000000010100       86      2112
    { 12, 0x15 },       // 000000010101       87      2176
    { 12, 0x16 },       // 000000010110       88      2240
    { 12, 0x17 },       // 000000010111       89      2304
    { 12, 0x1c },       // 000000011100       90      2368
    { 12, 0x1d },       // 000000011101       91      2432
    { 12, 0x1e },       // 000000011110       92      2496
    { 12, 0x1f },       // 000000011111       93      2560
};

static const CODETABLE WhiteRunCodesReversed[] = {

    {  8, 0x00ac },       // 00110101            0         0
    {  6, 0x0038 },       // 000111              1         1
    {  4, 0x000e },       // 0111                2         2
    {  4, 0x0001 },       // 1000                3         3
    {  4, 0x000d },       // 1011                4         4
    {  4, 0x0003 },       // 1100                5         5
    {  4, 0x0007 },       // 1110                6         6
    {  4, 0x000f },       // 1111                7         7
    {  5, 0x0019 },       // 10011               8         8
    {  5, 0x0005 },       // 10100               9         9
    {  5, 0x001c },       // 00111              10        10
    {  5, 0x0002 },       // 01000              11        11
    {  6, 0x0004 },       // 001000             12        12
    {  6, 0x0030 },       // 000011             13        13
    {  6, 0x000b },       // 110100             14        14
    {  6, 0x002b },       // 110101             15        15
    {  6, 0x0015 },       // 101010             16        16
    {  6, 0x0035 },       // 101011             17        17
    {  7, 0x0072 },       // 0100111            18        18
    {  7, 0x0018 },       // 0001100            19        19
    {  7, 0x0008 },       // 0001000            20        20
    {  7, 0x0074 },       // 0010111            21        21
    {  7, 0x0060 },       // 0000011            22        22
    {  7, 0x0010 },       // 0000100            23        23
    {  7, 0x000a },       // 0101000            24        24
    {  7, 0x006a },       // 0101011            25        25
    {  7, 0x0064 },       // 0010011            26        26
    {  7, 0x0012 },       // 0100100            27        27
    {  7, 0x000c },       // 0011000            28        28
    {  8, 0x0040 },       // 00000010           29        29
    {  8, 0x00c0 },       // 00000011           30        30
    {  8, 0x0058 },       // 00011010           31        31
    {  8, 0x00d8 },       // 00011011           32        32
    {  8, 0x0048 },       // 00010010           33        33
    {  8, 0x00c8 },       // 00010011           34        34
    {  8, 0x0028 },       // 00010100           35        35
    {  8, 0x00a8 },       // 00010101           36        36
    {  8, 0x0068 },       // 00010110           37        37
    {  8, 0x00e8 },       // 00010111           38        38
    {  8, 0x0014 },       // 00101000           39        39
    {  8, 0x0094 },       // 00101001           40        40
    {  8, 0x0054 },       // 00101010           41        41
    {  8, 0x00d4 },       // 00101011           42        42
    {  8, 0x0034 },       // 00101100           43        43
    {  8, 0x00b4 },       // 00101101           44        44
    {  8, 0x0020 },       // 00000100           45        45
    {  8, 0x00a0 },       // 00000101           46        46
    {  8, 0x0050 },       // 00001010           47        47
    {  8, 0x00d0 },       // 00001011           48        48
    {  8, 0x004a },       // 01010010           49        49
    {  8, 0x00ca },       // 01010011           50        50
    {  8, 0x002a },       // 01010100           51        51
    {  8, 0x00aa },       // 01010101           52        52
    {  8, 0x0024 },       // 00100100           53        53
    {  8, 0x00a4 },       // 00100101           54        54
    {  8, 0x001a },       // 01011000           55        55
    {  8, 0x009a },       // 01011001           56        56
    {  8, 0x005a },       // 01011010           57        57
    {  8, 0x00da },       // 01011011           58        58
    {  8, 0x0052 },       // 01001010           59        59
    {  8, 0x00d2 },       // 01001011           50        60
    {  8, 0x004c },       // 00110010           51        61
    {  8, 0x00cc },       // 00110011           52        62
    {  8, 0x002c },       // 00110100           53        63
    {  5, 0x001b },       // 11011              54        64
    {  5, 0x0009 },       // 10010              55       128
    {  6, 0x003a },       // 010111             56       192
    {  7, 0x0076 },       // 0110111            57       256
    {  8, 0x006c },       // 00110110           58       320
    {  8, 0x00ec },       // 00110111           59       384
    {  8, 0x0026 },       // 01100100           60       448
    {  8, 0x00a6 },       // 01100101           61       512
    {  8, 0x0016 },       // 01101000           62       576
    {  8, 0x00e6 },       // 01100111           63       640
    {  9, 0x0066 },       // 011001100          64       704
    {  9, 0x0166 },       // 011001101          65       768
    {  9, 0x0096 },       // 011010010          66       832
    {  9, 0x0196 },       // 011010011          67       896
    {  9, 0x0056 },       // 011010100          68       960
    {  9, 0x0156 },       // 011010101          69      1024
    {  9, 0x00d6 },       // 011010110          70      1088
    {  9, 0x01d6 },       // 011010111          71      1152
    {  9, 0x0036 },       // 011011000          72      1216
    {  9, 0x0136 },       // 011011001          73      1280
    {  9, 0x00b6 },       // 011011010          74      1344
    {  9, 0x01b6 },       // 011011011          75      1408
    {  9, 0x0032 },       // 010011000          76      1472
    {  9, 0x0132 },       // 010011001          77      1536
    {  9, 0x00b2 },       // 010011010          78      1600
    {  6, 0x0006 },       // 011000             79      1664
    {  9, 0x01b2 },       // 010011011          80      1728
    { 11, 0x0080 },       // 00000001000        81      1792
    { 11, 0x0180 },       // 00000001100        82      1856
    { 11, 0x0580 },       // 00000001101        83      1920
    { 12, 0x0480 },       // 000000010010       84      1984
    { 12, 0x0c80 },       // 000000010011       85      2048
    { 12, 0x0280 },       // 000000010100       86      2112
    { 12, 0x0a80 },       // 000000010101       87      2176
    { 12, 0x0680 },       // 000000010110       88      2240
    { 12, 0x0e80 },       // 000000010111       89      2304
    { 12, 0x0380 },       // 000000011100       90      2368
    { 12, 0x0b80 },       // 000000011101       91      2432
    { 12, 0x0780 },       // 000000011110       92      2496
    { 12, 0x0f80 },       // 000000011111       93      2560
};

#define WhiteRunCodeEntries  (sizeof(WhiteRunCodes)/sizeof(CODETABLE))

//
// Code table for black runs
//

static const CODETABLE BlackRunCodes[] = {

    { 10, 0x37 },       // 0000110111          0       0
    {  3, 0x02 },       // 010                 1       1
    {  2, 0x03 },       // 11                  2       2
    {  2, 0x02 },       // 10                  3       3
    {  3, 0x03 },       // 011                 4       4
    {  4, 0x03 },       // 0011                5       5
    {  4, 0x02 },       // 0010                6       6
    {  5, 0x03 },       // 00011               7       7
    {  6, 0x05 },       // 000101              8       8
    {  6, 0x04 },       // 000100              9       9
    {  7, 0x04 },       // 0000100            10      10
    {  7, 0x05 },       // 0000101            11      11
    {  7, 0x07 },       // 0000111            12      12
    {  8, 0x04 },       // 00000100           13      13
    {  8, 0x07 },       // 00000111           14      14
    {  9, 0x18 },       // 000011000          15      15
    { 10, 0x17 },       // 0000010111         16      16
    { 10, 0x18 },       // 0000011000         17      17
    { 10, 0x08 },       // 0000001000         18      18
    { 11, 0x67 },       // 00001100111        19      19
    { 11, 0x68 },       // 00001101000        20      20
    { 11, 0x6c },       // 00001101100        21      21
    { 11, 0x37 },       // 00000110111        22      22
    { 11, 0x28 },       // 00000101000        23      23
    { 11, 0x17 },       // 00000010111        24      24
    { 11, 0x18 },       // 00000011000        25      25
    { 12, 0xca },       // 000011001010       26      26
    { 12, 0xcb },       // 000011001011       27      27
    { 12, 0xcc },       // 000011001100       28      28
    { 12, 0xcd },       // 000011001101       29      29
    { 12, 0x68 },       // 000001101000       30      30
    { 12, 0x69 },       // 000001101001       31      31
    { 12, 0x6a },       // 000001101010       32      32
    { 12, 0x6b },       // 000001101011       33      33
    { 12, 0xd2 },       // 000011010010       34      34
    { 12, 0xd3 },       // 000011010011       35      35
    { 12, 0xd4 },       // 000011010100       36      36
    { 12, 0xd5 },       // 000011010101       37      37
    { 12, 0xd6 },       // 000011010110       38      38
    { 12, 0xd7 },       // 000011010111       39      39
    { 12, 0x6c },       // 000001101100       40      40
    { 12, 0x6d },       // 000001101101       41      41
    { 12, 0xda },       // 000011011010       42      42
    { 12, 0xdb },       // 000011011011       43      43
    { 12, 0x54 },       // 000001010100       44      44
    { 12, 0x55 },       // 000001010101       45      45
    { 12, 0x56 },       // 000001010110       46      46
    { 12, 0x57 },       // 000001010111       47      47
    { 12, 0x64 },       // 000001100100       48      48
    { 12, 0x65 },       // 000001100101       49      49
    { 12, 0x52 },       // 000001010010       50      50
    { 12, 0x53 },       // 000001010011       51      51
    { 12, 0x24 },       // 000000100100       52      52
    { 12, 0x37 },       // 000000110111       53      53
    { 12, 0x38 },       // 000000111000       54      54
    { 12, 0x27 },       // 000000100111       55      55
    { 12, 0x28 },       // 000000101000       56      56
    { 12, 0x58 },       // 000001011000       57      57
    { 12, 0x59 },       // 000001011001       58      58
    { 12, 0x2b },       // 000000101011       59      59
    { 12, 0x2c },       // 000000101100       50      60
    { 12, 0x5a },       // 000001011010       51      61
    { 12, 0x66 },       // 000001100110       52      62
    { 12, 0x67 },       // 000001100111       53      63
    { 10, 0x0f },       // 0000001111         54      64
    { 12, 0xc8 },       // 000011001000       55     128
    { 12, 0xc9 },       // 000011001001       56     192
    { 12, 0x5b },       // 000001011011       57     256
    { 12, 0x33 },       // 000000110011       58     320
    { 12, 0x34 },       // 000000110100       59     384
    { 12, 0x35 },       // 000000110101       60     448
    { 13, 0x6c },       // 0000001101100      61     512
    { 13, 0x6d },       // 0000001101101      62     576
    { 13, 0x4a },       // 0000001001010      63     640
    { 13, 0x4b },       // 0000001001011      64     704
    { 13, 0x4c },       // 0000001001100      65     768
    { 13, 0x4d },       // 0000001001101      66     832
    { 13, 0x72 },       // 0000001110010      67     896
    { 13, 0x73 },       // 0000001110011      68     960
    { 13, 0x74 },       // 0000001110100      69    1024
    { 13, 0x75 },       // 0000001110101      70    1088
    { 13, 0x76 },       // 0000001110110      71    1152
    { 13, 0x77 },       // 0000001110111      72    1216
    { 13, 0x52 },       // 0000001010010      73    1280
    { 13, 0x53 },       // 0000001010011      74    1344
    { 13, 0x54 },       // 0000001010100      75    1408
    { 13, 0x55 },       // 0000001010101      76    1472
    { 13, 0x5a },       // 0000001011010      77    1536
    { 13, 0x5b },       // 0000001011011      78    1600
    { 13, 0x64 },       // 0000001100100      79    1664
    { 13, 0x65 },       // 0000001100101      80    1728
    { 11, 0x08 },       // 00000001000        81    1792
    { 11, 0x0c },       // 00000001100        82    1856
    { 11, 0x0d },       // 00000001101        83    1920
    { 12, 0x12 },       // 000000010010       84    1984
    { 12, 0x13 },       // 000000010011       85    2048
    { 12, 0x14 },       // 000000010100       86    2112
    { 12, 0x15 },       // 000000010101       87    2176
    { 12, 0x16 },       // 000000010110       88    2240
    { 12, 0x17 },       // 000000010111       89    2304
    { 12, 0x1c },       // 000000011100       90    2368
    { 12, 0x1d },       // 000000011101       91    2432
    { 12, 0x1e },       // 000000011110       92    2496
    { 12, 0x1f },       // 000000011111       93    2560
};

static const CODETABLE BlackRunCodesReversed[] = {

    { 10, 0x03b0 },       // 0000110111          0       0
    {  3, 0x0002 },       // 010                 1       1
    {  2, 0x0003 },       // 11                  2       2
    {  2, 0x0001 },       // 10                  3       3
    {  3, 0x0006 },       // 011                 4       4
    {  4, 0x000c },       // 0011                5       5
    {  4, 0x0004 },       // 0010                6       6
    {  5, 0x0018 },       // 00011               7       7
    {  6, 0x0028 },       // 000101              8       8
    {  6, 0x0008 },       // 000100              9       9
    {  7, 0x0010 },       // 0000100            10      10
    {  7, 0x0050 },       // 0000101            11      11
    {  7, 0x0070 },       // 0000111            12      12
    {  8, 0x0020 },       // 00000100           13      13
    {  8, 0x00e0 },       // 00000111           14      14
    {  9, 0x0030 },       // 000011000          15      15
    { 10, 0x03a0 },       // 0000010111         16      16
    { 10, 0x0060 },       // 0000011000         17      17
    { 10, 0x0040 },       // 0000001000         18      18
    { 11, 0x0730 },       // 00001100111        19      19
    { 11, 0x00b0 },       // 00001101000        20      20
    { 11, 0x01b0 },       // 00001101100        21      21
    { 11, 0x0760 },       // 00000110111        22      22
    { 11, 0x00a0 },       // 00000101000        23      23
    { 11, 0x0740 },       // 00000010111        24      24
    { 11, 0x00c0 },       // 00000011000        25      25
    { 12, 0x0530 },       // 000011001010       26      26
    { 12, 0x0d30 },       // 000011001011       27      27
    { 12, 0x0330 },       // 000011001100       28      28
    { 12, 0x0b30 },       // 000011001101       29      29
    { 12, 0x0160 },       // 000001101000       30      30
    { 12, 0x0960 },       // 000001101001       31      31
    { 12, 0x0560 },       // 000001101010       32      32
    { 12, 0x0d60 },       // 000001101011       33      33
    { 12, 0x04b0 },       // 000011010010       34      34
    { 12, 0x0cb0 },       // 000011010011       35      35
    { 12, 0x02b0 },       // 000011010100       36      36
    { 12, 0x0ab0 },       // 000011010101       37      37
    { 12, 0x06b0 },       // 000011010110       38      38
    { 12, 0x0eb0 },       // 000011010111       39      39
    { 12, 0x0360 },       // 000001101100       40      40
    { 12, 0x0b60 },       // 000001101101       41      41
    { 12, 0x05b0 },       // 000011011010       42      42
    { 12, 0x0db0 },       // 000011011011       43      43
    { 12, 0x02a0 },       // 000001010100       44      44
    { 12, 0x0aa0 },       // 000001010101       45      45
    { 12, 0x06a0 },       // 000001010110       46      46
    { 12, 0x0ea0 },       // 000001010111       47      47
    { 12, 0x0260 },       // 000001100100       48      48
    { 12, 0x0a60 },       // 000001100101       49      49
    { 12, 0x04a0 },       // 000001010010       50      50
    { 12, 0x0ca0 },       // 000001010011       51      51
    { 12, 0x0240 },       // 000000100100       52      52
    { 12, 0x0ec0 },       // 000000110111       53      53
    { 12, 0x01c0 },       // 000000111000       54      54
    { 12, 0x0e40 },       // 000000100111       55      55
    { 12, 0x0140 },       // 000000101000       56      56
    { 12, 0x01a0 },       // 000001011000       57      57
    { 12, 0x09a0 },       // 000001011001       58      58
    { 12, 0x0d40 },       // 000000101011       59      59
    { 12, 0x0340 },       // 000000101100       50      60
    { 12, 0x05a0 },       // 000001011010       51      61
    { 12, 0x0660 },       // 000001100110       52      62
    { 12, 0x0e60 },       // 000001100111       53      63
    { 10, 0x03c0 },       // 0000001111         54      64
    { 12, 0x0130 },       // 000011001000       55     128
    { 12, 0x0930 },       // 000011001001       56     192
    { 12, 0x0da0 },       // 000001011011       57     256
    { 12, 0x0cc0 },       // 000000110011       58     320
    { 12, 0x02c0 },       // 000000110100       59     384
    { 12, 0x0ac0 },       // 000000110101       60     448
    { 13, 0x06c0 },       // 0000001101100      61     512
    { 13, 0x16c0 },       // 0000001101101      62     576
    { 13, 0x0a40 },       // 0000001001010      63     640
    { 13, 0x1a40 },       // 0000001001011      64     704
    { 13, 0x0640 },       // 0000001001100      65     768
    { 13, 0x1640 },       // 0000001001101      66     832
    { 13, 0x09c0 },       // 0000001110010      67     896
    { 13, 0x19c0 },       // 0000001110011      68     960
    { 13, 0x05c0 },       // 0000001110100      69    1024
    { 13, 0x15c0 },       // 0000001110101      70    1088
    { 13, 0x0dc0 },       // 0000001110110      71    1152
    { 13, 0x1dc0 },       // 0000001110111      72    1216
    { 13, 0x0940 },       // 0000001010010      73    1280
    { 13, 0x1940 },       // 0000001010011      74    1344
    { 13, 0x0540 },       // 0000001010100      75    1408
    { 13, 0x1540 },       // 0000001010101      76    1472
    { 13, 0x0b40 },       // 0000001011010      77    1536
    { 13, 0x1b40 },       // 0000001011011      78    1600
    { 13, 0x04c0 },       // 0000001100100      79    1664
    { 13, 0x14c0 },       // 0000001100101      80    1728
    { 11, 0x0080 },       // 00000001000        81    1792
    { 11, 0x0180 },       // 00000001100        82    1856
    { 11, 0x0580 },       // 00000001101        83    1920
    { 12, 0x0480 },       // 000000010010       84    1984
    { 12, 0x0c80 },       // 000000010011       85    2048
    { 12, 0x0280 },       // 000000010100       86    2112
    { 12, 0x0a80 },       // 000000010101       87    2176
    { 12, 0x0680 },       // 000000010110       88    2240
    { 12, 0x0e80 },       // 000000010111       89    2304
    { 12, 0x0380 },       // 000000011100       90    2368
    { 12, 0x0b80 },       // 000000011101       91    2432
    { 12, 0x0780 },       // 000000011110       92    2496
    { 12, 0x0f80 },       // 000000011111       93    2560
};


#define BlackRunCodeEntries  (sizeof(BlackRunCodes)/sizeof(CODETABLE))


#define BADRUN      3000
#define DECODEEOL   3001
#define DECODEEOL2  3002
#define HORZMODE    3003
#define VTMODE3N    3004
#define VTMODE2N    3005
#define VTMODE1N    3006
#define VTMODE0     3007
#define VTMODE1P    3008
#define VTMODE2P    3009
#define VTMODE3P    3010
#define PASSMODE    3011


typedef struct _DECODE_TREE {
    INT     Left;
    INT     Right;
} DECODE_TREE;

typedef CONST DECODE_TREE *PDECODE_TREE;


static const DECODE_TREE WhiteDecodeTree[] =
{
    {         1,                 80  },                   // 0
    {        40,                  2  },                   // 1
    {        21,                  3  },                   // 2
    {         4,                 -2  },                   // 3
    {        16,                  5  },                   // 4
    {        10,                  6  },                   // 5
    {         7,               -256  },                   // 6
    {         9,                  8  },                   // 7
    {     -1344,              -1408  },                   // 8
    {     -1216,              -1280  },                   // 9
    {        11,                 13  },                   // 10
    {      -576,                 12  },                   // 11
    {      -832,               -896  },                   // 12
    {        14,                 15  },                   // 13
    {      -960,              -1024  },                   // 14
    {     -1088,              -1152  },                   // 15
    {     -1664,                 17  },                   // 16
    {        18,                 19  },                   // 17
    {      -448,               -512  },                   // 18
    {        20,               -640  },                   // 19
    {      -704,               -768  },                   // 20
    {        32,                 22  },                   // 21
    {        23,                 28  },                   // 22
    {        24,                 26  },                   // 23
    {       -24,                 25  },                   // 24
    {       -49,                -50  },                   // 25
    {        27,                -25  },                   // 26
    {       -51,                -52  },                   // 27
    {        29,               -192  },                   // 28
    {        30,                 31  },                   // 29
    {       -55,                -56  },                   // 30
    {       -57,                -58  },                   // 31
    {       -11,                 33  },                   // 32
    {        34,                 36  },                   // 33
    {       -27,                 35  },                   // 34
    {       -59,                -60  },                   // 35
    {        37,                -18  },                   // 36
    {        38,                 39  },                   // 37
    {     -1472,              -1536  },                   // 38
    {     -1600,              -1728  },                   // 39
    {        59,                 41  },                   // 40
    {        49,                 42  },                   // 41
    {        43,                -10  },                   // 42
    {        47,                 44  },                   // 43
    {        46,                 45  },                   // 44
    {      -320,               -384  },                   // 45
    {       -63,                  0  },                   // 46
    {       -28,                 48  },                   // 47
    {       -61,                -62  },                   // 48
    {        56,                 50  },                   // 49
    {        53,                 51  },                   // 50
    {        52,                -21  },                   // 51
    {       -43,                -44  },                   // 52
    {        55,                 54  },                   // 53
    {       -41,                -42  },                   // 54
    {       -39,                -40  },                   // 55
    {       -12,                 57  },                   // 56
    {        58,                -26  },                   // 57
    {       -53,                -54  },                   // 58
    {        70,                 60  },                   // 59
    {        64,                 61  },                   // 60
    {        62,                 -1  },                   // 61
    {       -19,                 63  },                   // 62
    {       -31,                -32  },                   // 63
    {        68,                 65  },                   // 64
    {        67,                 66  },                   // 65
    {       -37,                -38  },                   // 66
    {       -35,                -36  },                   // 67
    {       -20,                 69  },                   // 68
    {       -33,                -34  },                   // 69
    {        74,                 71  },                   // 70
    {        72,                -13  },                   // 71
    {       -23,                 73  },                   // 72
    {       -47,                -48  },                   // 73
    {        77,                 75  },                   // 74
    {        76,                -22  },                   // 75
    {       -45,                -46  },                   // 76
    {        79,                 78  },                   // 77
    {       -29,                -30  },                   // 78
    { DECODEEOL,             BADRUN  },                   // 79
    {        86,                 81  },                   // 80
    {        83,                 82  },                   // 81
    {        -6,                 -7  },                   // 82
    {        -5,                 84  },                   // 83
    {        85,                -64  },                   // 84
    {       -14,                -15  },                   // 85
    {        90,                 87  },                   // 86
    {        88,                 -4  },                   // 87
    {        -9,                 89  },                   // 88
    {       -16,                -17  },                   // 89
    {        -3,                 91  },                   // 90
    {      -128,                 -8  }                    // 91
};

#define WhiteDecodeEntries  (sizeof(WhiteDecodeTree)/sizeof(DECODE_TREE))


static const DECODE_TREE BlackDecodeTree[] =
{
    {         2,                  1  },                   // 0
    {        -3,                 -2  },                   // 1
    {         4,                  3  },                   // 2
    {        -1,                 -4  },                   // 3
    {         6,                  5  },                   // 4
    {        -6,                 -5  },                   // 5
    {         9,                  7  },                   // 6
    {         8,                 -7  },                   // 7
    {        -9,                 -8  },                   // 8
    {        31,                 10  },                   // 9
    {        30,                 11  },                   // 10
    {        12,                -12  },                   // 11
    {        23,                 13  },                   // 12
    {        17,                 14  },                   // 13
    {        15,                  0  },                   // 14
    {       -21,                 16  },                   // 15
    {       -42,                -43  },                   // 16
    {        21,                 18  },                   // 17
    {        20,                 19  },                   // 18
    {       -38,                -39  },                   // 19
    {       -36,                -37  },                   // 20
    {       -20,                 22  },                   // 21
    {       -34,                -35  },                   // 22
    {       -15,                 24  },                   // 23
    {        27,                 25  },                   // 24
    {        26,                -19  },                   // 25
    {       -28,                -29  },                   // 26
    {        29,                 28  },                   // 27
    {       -26,                -27  },                   // 28
    {      -128,               -192  },                   // 29
    {       -10,                -11  },                   // 30
    {        57,                 32  },                   // 31
    {        45,                 33  },                   // 32
    {        34,                -14  },                   // 33
    {        41,                 35  },                   // 34
    {        38,                 36  },                   // 35
    {        37,                -22  },                   // 36
    {       -40,                -41  },                   // 37
    {        40,                 39  },                   // 38
    {       -32,                -33  },                   // 39
    {       -30,                -31  },                   // 40
    {       -17,                 42  },                   // 41
    {        44,                 43  },                   // 42
    {       -62,                -63  },                   // 43
    {       -48,                -49  },                   // 44
    {       -13,                 46  },                   // 45
    {        51,                 47  },                   // 46
    {        48,                -16  },                   // 47
    {        50,                 49  },                   // 48
    {       -61,               -256  },                   // 49
    {       -57,                -58  },                   // 50
    {        55,                 52  },                   // 51
    {        54,                 53  },                   // 52
    {       -46,                -47  },                   // 53
    {       -44,                -45  },                   // 54
    {       -23,                 56  },                   // 55
    {       -50,                -51  },                   // 56
    { DECODEEOL,                 58  },                   // 57
    {        75,                 59  },                   // 58
    {        67,                 60  },                   // 59
    {        61,                -64  },                   // 60
    {        65,                 62  },                   // 61
    {        64,                 63  },                   // 62
    {     -1152,              -1216  },                   // 63
    {     -1024,              -1088  },                   // 64
    {       -54,                 66  },                   // 65
    {      -896,               -960  },                   // 66
    {        72,                 68  },                   // 67
    {        71,                 69  },                   // 68
    {        70,                -53  },                   // 69
    {      -512,               -576  },                   // 70
    {      -384,               -448  },                   // 71
    {       -25,                 73  },                   // 72
    {        74,               -320  },                   // 73
    {     -1664,              -1728  },                   // 74
    {        85,                 76  },                   // 75
    {        80,                 77  },                   // 76
    {        78,                -24  },                   // 77
    {       -60,                 79  },                   // 78
    {     -1536,              -1600  },                   // 79
    {        83,                 81  },                   // 80
    {        82,                -59  },                   // 81
    {     -1408,              -1472  },                   // 82
    {       -56,                 84  },                   // 83
    {     -1280,              -1344  },                   // 84
    {       -18,                 86  },                   // 85
    {        89,                 87  },                   // 86
    {        88,                -55  },                   // 87
    {      -768,               -832  },                   // 88
    {       -52,                 90  },                   // 89
    {      -640,               -704  }                    // 90
};

#define BlackDecodeEntries  (sizeof(BlackDecodeTree)/sizeof(DECODE_TREE))


static const DECODE_TREE TwoDecodeTree[] =
{
    {         1,            VTMODE0  },                   // 0
    {         2,                  3  },                   // 1
    {         4,           HORZMODE  },                   // 2
    {  VTMODE1N,           VTMODE1P  },                   // 3
    {         5,           PASSMODE  },                   // 4
    {         6,                  7  },                   // 5
    {         8,                  9  },                   // 6
    {  VTMODE2N,           VTMODE2P  },                   // 7
    { DECODEEOL,             BADRUN  },                   // 8
    {  VTMODE3N,           VTMODE3P  }                    // 9
};


static const BYTE BitReverseTable[256] =
{
    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
};



static const BYTE First1[256] = {
    0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
};



static const BYTE Last1[256] = {
    0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0
};


static const BYTE All1[8] = {
    0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe
};


#endif  // !_FAXTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\tiff\src\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This file contains utilitarian functions for
    the FAX TIFF library.

Environment:

        WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "tifflibp.h"
#pragma hdrstop



INT
FindWhiteRun(
    PBYTE       pbuf,
    INT         startBit,
    INT         stopBit
    )

/*++

Routine Description:

    Find the next span of white pixels on the specified line

Arguments:

    pbuf        - Points to uncompressed pixel data for the current line
    startBit    - Starting bit index
    stopBit     - Last bit index

Return Value:

    Length of the next run of white pixels

--*/

{
    static const BYTE WhiteRuns[256] = {

        8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };

    INT run, bits, n;

    pbuf += (startBit >> 3);
    if ((bits = stopBit-startBit) <= 0)
        return 0;

    //
    // Take care of the case where starting bit index is not a multiple of 8
    //

    if (n = (startBit & 7)) {

        run = WhiteRuns[(*pbuf << n) & 0xff];
        if (run > BYTEBITS-n)
            run = BYTEBITS-n;
        if (n+run < BYTEBITS)
            return run;
        bits -= run;
        pbuf++;

    } else
        run = 0;

    //
    // Look for consecutive DWORD value = 0
    //

    if (bits >= DWORDBITS * 2) {

        PDWORD  pdw;

        //
        // Align to a DWORD boundary first
        //

        while ((ULONG_PTR) pbuf & 3) {

            if (*pbuf != 0)
                return run + WhiteRuns[*pbuf];

            run += BYTEBITS;
            bits -= BYTEBITS;
            pbuf++;
        }

        pdw = (PDWORD) pbuf;

        while (bits >= DWORDBITS && *pdw == 0) {

            pdw++;
            run += DWORDBITS;
            bits -= DWORDBITS;
        }

        pbuf = (PBYTE) pdw;
    }

    //
    // Look for consecutive BYTE value = 0
    //

    while (bits >= BYTEBITS) {

        if (*pbuf != 0)
            return run + WhiteRuns[*pbuf];

        pbuf++;
        run += BYTEBITS;
        bits -= BYTEBITS;
    }

    //
    // Count the number of white pixels in the last byte
    //

    if (bits > 0)
        run += WhiteRuns[*pbuf];

    return run;
}


INT
FindBlackRun(
    PBYTE       pbuf,
    INT         startBit,
    INT         stopBit
    )

/*++

Routine Description:

    Find the next span of black pixels on the specified line

Arguments:

    pbuf        - Points to uncompressed pixel data for the current line
    startBit    - Starting bit index
    stopBit     - Last bit index

Return Value:

    Length of the next run of black pixels

--*/

{
    static const BYTE BlackRuns[256] = {

        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 8
    };

    INT run, bits, n;

    pbuf += (startBit >> 3);
    if ((bits = stopBit-startBit) <= 0)
        return 0;

    //
    // Take care of the case where starting bit index is not a multiple of 8
    //

    if (n = (startBit & 7)) {

        run = BlackRuns[(*pbuf << n) & 0xff];
        if (run > BYTEBITS-n)
            run = BYTEBITS-n;
        if (n+run < BYTEBITS)
            return run;
        bits -= run;
        pbuf++;

    } else
        run = 0;

    //
    // Look for consecutive DWORD value = 0xffffffff
    //

    if (bits >= DWORDBITS * 2) {

        PDWORD  pdw;

        //
        // Align to a DWORD boundary first
        //

        while ((ULONG_PTR) pbuf & 3) {

            if (*pbuf != 0xff)
                return run + BlackRuns[*pbuf];

            run += BYTEBITS;
            bits -= BYTEBITS;
            pbuf++;
        }

        pdw = (PDWORD) pbuf;

        while (bits >= DWORDBITS && *pdw == 0xffffffff) {

            pdw++;
            run += DWORDBITS;
            bits -= DWORDBITS;
        }

        pbuf = (PBYTE) pdw;
    }

    //
    // Look for consecutive BYTE value = 0xff
    //

    while (bits >= BYTEBITS) {

        if (*pbuf != 0xff)
            return run + BlackRuns[*pbuf];

        pbuf++;
        run += BYTEBITS;
        bits -= BYTEBITS;
    }

    //
    // Count the number of white pixels in the last byte
    //

    if (bits > 0)
        run += BlackRuns[*pbuf];

    return run;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\tiff\src\fasttiff.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fasttiff.c

Abstract:

    This module implements fast MMR/MR/MH encoder/decoder/conversion

Author:

    Rafael Lisitsa (RafaelL) 14-Aug-1996

Revision History:

--*/


#include "tifflibp.h"
#pragma hdrstop

#include "fasttiff.h"


#include "math.h"

//#define RDEBUG  1


// min code length is 2; max index length is 20
#define  MAX_ENTRIES   10

#define  MAX_CODE_LENGTH 13
#define  MIN_GOOD_LINES  1000

#ifdef RDEBUG
    // Debugging
    BOOL DebGlobOut=0;
    BOOL DebGlobOutColors=1;
    BOOL DebGlobOutPrefix=1;

#endif


//#define RDEBUGS  1

#ifdef RDEBUGS
    // Debugging
    BOOL DebGlobOutS=0;
#endif


#pragma pack(1)

typedef struct {
    BYTE        Tail          :4;
    BYTE        TwoColorsSize :4;
} RES_BYTE_LAST;

typedef struct {
    BYTE        Code          :6;
    BYTE        OneColorSize  :1;
    BYTE        Makeup        :1;
} RES_CODE;


typedef struct {
    RES_CODE         Record[4];
    RES_BYTE_LAST    Result;
} RES_RECORD;





#pragma pack()

typedef struct {
    BYTE         ByteRecord[5];
} READ_RECORD;



//
// (andrewr -- we don't share this data anymore, it's a security violation.)
// Share the following Tables among all the processes that use FaxTiff.DLL
//

DWORD       GlobFaxTiffUsage=0;
BYTE        GlobTableWhite[32768][5] = {0};
BYTE        GlobTableBlack[32768][5] = {0};
BYTE        AlignEolTable[32] = {0};
PREF_BYTE   PrefTable[128] = {0};
BOOL        GlobFaxTiffInitialized=FALSE;


WORD Prime(DWORD i)
{
    BYTE  b1 = (BYTE) i;
    BYTE  b2;
    WORD  w1;


    b2 = BitReverseTable[b1];
    b1 = (b2 >> 1)  & 0x7f;

    w1 = (WORD) b1;
    return (w1);


}





void
BuildLookupTables(
    DWORD TableLength
    )
{


    PDECODE_TREE   Tree;
    DWORD          CurrentOffsetStart, CurrentOffsetEnd;
    DWORD          CodeLength;


    DWORD          TotalWhiteErrorCodes=0;
    DWORD          TotalWhiteGood=0;
    DWORD          TotalWhiteGoodNoEnd=0;
    DWORD          TotalWhiteGoodPosEOL=0;


    DWORD          TotalBlackErrorCodes=0;
    DWORD          TotalBlackGood=0;
    DWORD          TotalBlackGoodNoEnd=0;
    DWORD          TotalBlackGoodPosEOL=0;


    DWORD          TotalEntries[2][MAX_ENTRIES];

    DWORD          CurrentEntries;



    typedef struct _ENTRY {
        DWORD       Color;
        DWORD       CodeLength;
        DWORD       RunLength;
    } ENTRY;

    ENTRY          Entry[MAX_ENTRIES];

    RES_RECORD     *pRes_Record;
    RES_RECORD     *ResTableWhite = (RES_RECORD *) GlobTableWhite;
    RES_RECORD     *ResTableBlack = (RES_RECORD *) GlobTableBlack;

    DWORD          i, j;
    DWORD          delta;




    DWORD          N, N0;
    DWORD          Color;
    INT            code;

    DWORD          TableSize;
    BYTE           Color1Change;
    BYTE           Color2Change;

    WORD           w1, w2, w3;
    BYTE           b1, b2;



    // build PrefTable

    PrefTable[Prime(0)].Value = LOOK_FOR_EOL_PREFIX;
    PrefTable[Prime(0)].Tail  = 0;
    PrefTable[Prime(1)].Value = ERROR_PREFIX;
    PrefTable[Prime(1)].Tail  = 0;

    PrefTable[Prime(2)].Value = -3;
    PrefTable[Prime(2)].Tail  = 7;
    PrefTable[Prime(3)].Value = 3;
    PrefTable[Prime(3)].Tail  = 7;

    PrefTable[Prime(4)].Value = -2;
    PrefTable[Prime(4)].Tail  = 6;
    PrefTable[Prime(5)].Value = -2;
    PrefTable[Prime(5)].Tail  = 6;

    PrefTable[Prime(6)].Value = 2;
    PrefTable[Prime(6)].Tail  = 6;
    PrefTable[Prime(7)].Value = 2;
    PrefTable[Prime(7)].Tail  = 6;

    for (i=8; i<=15; i++) {
        PrefTable[Prime(i)].Value = PASS_PREFIX;
        PrefTable[Prime(i)].Tail  = 4;
    }

    for (i=16; i<=31; i++) {
        PrefTable[Prime(i)].Value = HORIZ_PREFIX;
        PrefTable[Prime(i)].Tail  = 3;
    }

    for (i=32; i<=47; i++) {
        PrefTable[Prime(i)].Value = -1;
        PrefTable[Prime(i)].Tail  = 3;
    }

    for (i=48; i<=63; i++) {
        PrefTable[Prime(i)].Value = 1;
        PrefTable[Prime(i)].Tail  = 3;
    }

    for (i=64; i<=127; i++) {
        PrefTable[Prime(i)].Value = 0;
        PrefTable[Prime(i)].Tail  = 1;
    }


    // Build Align EOL Table

    for (i=0; i<=4; i++) {
        AlignEolTable[i] = 15;
    }

    for (i=5; i<=12; i++) {
        AlignEolTable[i] = 23;
    }

    for (i=13; i<=20; i++) {
        AlignEolTable[i] = 31;
    }

    for (i=21; i<=28; i++) {
        AlignEolTable[i] = 7;
    }

    for (i=29; i<=31; i++) {
        AlignEolTable[i] = 15;
    }




    // build MH tables


    TableSize = (DWORD) (1<<TableLength);


    for (i=0; i<2; i++) {
        for (j=0; j<MAX_ENTRIES; j++ ) {
            TotalEntries[i][j]=0;
        }
    }

    delta = sizeof(N)*8 - TableLength;


    for (N0=0; N0 < TableSize; N0++)  {

        CurrentEntries = 0;
        Color = WHITE_COLOR;
        N = N0;
        code = 0;

        // endians... 15 bits -> 7+8

        w1 = (WORD) N0;
        b1 = (BYTE) w1;
        b2 = (BYTE) (w1>>8);
        b1 = BitReverseTable[b1];
        b2 = BitReverseTable[b2];
        w2 = ((WORD) b1 ) << 8;
        w3 = (WORD) b2;

        w1 = w3 + w2;
        w1 >>= 1;
        w1 &= 0x7fff;

        pRes_Record = &(ResTableWhite[w1]);

        N <<= delta;

        Tree = WhiteDecodeTree;
        CurrentOffsetStart = 0;
        CurrentOffsetEnd = 0;
        CodeLength = 0;
        Color1Change = 0;
        Color2Change = 0;

        for (j=0; j<TableLength; j++,N<<=1) {

            code = (N & 0x80000000)  ? Tree[code].Right : Tree[code].Left;

            CodeLength++;
            CurrentOffsetEnd++;

            if (CurrentOffsetEnd > TableLength) {
                break;
            }

            if (CodeLength > MAX_CODE_LENGTH) {
                pRes_Record->Record[CurrentEntries].Makeup = MAKEUP_CODE;
                pRes_Record->Record[CurrentEntries].Code   = ERROR_CODE;

                TotalWhiteErrorCodes++;
                goto lDoBlack;
            }

            if (code < 1) {

                code = (-code);


                Entry[CurrentEntries].Color = Color;
                Entry[CurrentEntries].CodeLength = CodeLength;
                Entry[CurrentEntries].RunLength = code;

                if (code < 64) {
                    //
                    // terminating code
                    //
                    pRes_Record->Record[CurrentEntries].Makeup = TERMINATE_CODE;
                    pRes_Record->Record[CurrentEntries].Code = (BYTE)code;

                    if (Color1Change) {
                        if (!Color2Change) {
                            Color2Change =  (BYTE) CurrentOffsetEnd;
                        }
                    }
                    else {
                        Color1Change = (BYTE) CurrentOffsetEnd;
                    }

                    Color = 1 - Color;
                    Tree = Color ? BlackDecodeTree : WhiteDecodeTree;
                }
                else {
                    pRes_Record->Record[CurrentEntries].Makeup = MAKEUP_CODE;
                    pRes_Record->Record[CurrentEntries].Code = code >> 6;
                }

                code = 0;
                CodeLength = 0;
                CurrentOffsetStart = CurrentOffsetEnd;

                CurrentEntries++;
                if (CurrentEntries >= 4) {
                    goto lDoBlack;
                }

            }


            if (code == BADRUN) {
                pRes_Record->Record[CurrentEntries].Makeup = MAKEUP_CODE;
                pRes_Record->Record[CurrentEntries].Code   = ERROR_CODE;
                TotalWhiteErrorCodes++;

                goto lDoBlack;
            }


            if (code == DECODEEOL) {                                          // means if any valid ==> must be EOL
                if (TableLength - CurrentOffsetStart < 12) {
                    if (N != 0)  {
                        pRes_Record->Record[CurrentEntries].Makeup = MAKEUP_CODE;
                        pRes_Record->Record[CurrentEntries].Code   = ERROR_CODE;

                        TotalWhiteErrorCodes++;

                        goto lDoBlack;
                    }
                    else {
                        // should return EOL_AHEAD
                        TotalWhiteGoodPosEOL++;
                        TotalWhiteGood++;
                        TotalEntries[0][CurrentEntries]++;

                        pRes_Record->Record[CurrentEntries].Makeup = MAKEUP_CODE;
                        pRes_Record->Record[CurrentEntries].Code   = LOOK_FOR_EOL_CODE;

                        goto lDoBlack;
                    }
                }
                else {
                    if (N == 0)  {
                        // should return EOL_AHEAD. Must be FILLER - any length.
                        TotalWhiteGoodPosEOL++;
                        TotalWhiteGood++;
                        TotalEntries[0][CurrentEntries]++;

                        pRes_Record->Record[CurrentEntries].Makeup = MAKEUP_CODE;
                        pRes_Record->Record[CurrentEntries].Code   = LOOK_FOR_EOL_CODE;

                        goto lDoBlack;
                    }
                    else {
                        while (1) {
                            N <<= 1;
                            CurrentOffsetEnd++;
                            if (N & 0x80000000) {
                                Entry[CurrentEntries].Color = Color;
                                Entry[CurrentEntries].CodeLength = CurrentOffsetEnd - CurrentOffsetStart;
                                Entry[CurrentEntries].RunLength = EOL_FOUND;

                                pRes_Record->Record[CurrentEntries].Makeup = MAKEUP_CODE;
                                pRes_Record->Record[CurrentEntries].Code   = EOL_FOUND_CODE;

                                Color = WHITE_COLOR;
                                Tree = WhiteDecodeTree;

                                code = 0;
                                CodeLength = 0;
                                CurrentOffsetStart = CurrentOffsetEnd;

                                CurrentEntries++;
                                if (CurrentEntries >= 4) {
                                    goto lDoBlack;
                                }

                                break;
                            }
                        }
                    }
                }
            }
        }

        if (CurrentEntries < 4) {
            pRes_Record->Record[CurrentEntries].Makeup = MAKEUP_CODE;
            pRes_Record->Record[CurrentEntries].Code   = NO_MORE_RECORDS;
        }

        TotalWhiteGood++;
        TotalEntries[0][CurrentEntries]++;


lDoBlack:

        // finish the White tails

        pRes_Record->Result.Tail = (BYTE) (CurrentOffsetStart);
        pRes_Record->Result.TwoColorsSize = Color2Change;

        pRes_Record->Record[0].OneColorSize = (Color1Change&0x08) ? 1:0 ;
        pRes_Record->Record[1].OneColorSize = (Color1Change&0x04) ? 1:0 ;
        pRes_Record->Record[2].OneColorSize = (Color1Change&0x02) ? 1:0 ;
        pRes_Record->Record[3].OneColorSize = (Color1Change&0x01) ? 1:0 ;




        // blacks


        CurrentEntries = 0;
        Color = 1 - WHITE_COLOR;
        N = N0;
        code = 0;

        pRes_Record = &(ResTableBlack[w1]);

        N <<= delta;

        Tree = BlackDecodeTree;
        CurrentOffsetStart = 0;
        CurrentOffsetEnd = 0;
        CodeLength = 0;
        Color1Change = 0;
        Color2Change = 0;

        for (j=0; j<TableLength; j++,N<<=1) {

            code = (N & 0x80000000)  ? Tree[code].Right : Tree[code].Left;

            CodeLength++;
            CurrentOffsetEnd++;

            if (CurrentOffsetEnd > TableLength) {
                break;
            }

            if (CodeLength > MAX_CODE_LENGTH) {
                pRes_Record->Record[CurrentEntries].Makeup = MAKEUP_CODE;
                pRes_Record->Record[CurrentEntries].Code   = ERROR_CODE;

                TotalBlackErrorCodes++;
                goto lDoLoop;
            }

            if (code < 1) {

                code = (-code);

                Entry[CurrentEntries].Color = Color;
                Entry[CurrentEntries].CodeLength = CodeLength;
                Entry[CurrentEntries].RunLength = code;

                if (code < 64) {
                    //
                    // terminating code
                    //
                    pRes_Record->Record[CurrentEntries].Makeup = TERMINATE_CODE;
                    pRes_Record->Record[CurrentEntries].Code = (BYTE)code;

                    if (Color1Change) {
                        if (!Color2Change) {
                            Color2Change = (BYTE) CurrentOffsetEnd;
                        }
                    }
                    else {
                        Color1Change = (BYTE) CurrentOffsetEnd;
                    }

                    Color = 1 - Color;
                    Tree = Color ? BlackDecodeTree : WhiteDecodeTree;
                }
                else {
                    pRes_Record->Record[CurrentEntries].Makeup = MAKEUP_CODE;
                    pRes_Record->Record[CurrentEntries].Code = code >> 6;
                }

                code = 0;
                CodeLength = 0;
                CurrentOffsetStart = CurrentOffsetEnd;

                CurrentEntries++;
                if (CurrentEntries >= 4) {
                    goto lDoLoop;
                }

            }


            if (code == BADRUN) {
                pRes_Record->Record[CurrentEntries].Makeup = MAKEUP_CODE;
                pRes_Record->Record[CurrentEntries].Code   = ERROR_CODE;
                TotalBlackErrorCodes++;

                goto lDoLoop;
            }


            if (code == DECODEEOL) {                                          // means if any valid ==> must be EOL
                if (TableLength - CurrentOffsetStart < 12) {
                    if (N != 0)  {
                        pRes_Record->Record[CurrentEntries].Makeup = MAKEUP_CODE;
                        pRes_Record->Record[CurrentEntries].Code   = ERROR_CODE;

                        TotalBlackErrorCodes++;

                        goto lDoLoop;
                    }
                    else {
                        // should return EOL_AHEAD
                        TotalBlackGoodPosEOL++;
                        TotalBlackGood++;
                        TotalEntries[1][CurrentEntries]++;

                        pRes_Record->Record[CurrentEntries].Makeup = MAKEUP_CODE;
                        pRes_Record->Record[CurrentEntries].Code   = LOOK_FOR_EOL_CODE;

                        goto lDoLoop;
                    }
                }
                else {
                    if (N == 0)  {
                        // should return EOL_AHEAD. Must be FILLER - any length.
                        TotalBlackGoodPosEOL++;
                        TotalBlackGood++;
                        TotalEntries[1][CurrentEntries]++;

                        pRes_Record->Record[CurrentEntries].Makeup = MAKEUP_CODE;
                        pRes_Record->Record[CurrentEntries].Code   = LOOK_FOR_EOL_CODE;

                        goto lDoLoop;
                    }
                    else {
                        while (1) {
                            N <<= 1;
                            CurrentOffsetEnd++;
                            if (N & 0x80000000) {
                                Entry[CurrentEntries].Color = Color;
                                Entry[CurrentEntries].CodeLength = CurrentOffsetEnd - CurrentOffsetStart;
                                Entry[CurrentEntries].RunLength = EOL_FOUND;

                                pRes_Record->Record[CurrentEntries].Makeup = MAKEUP_CODE;
                                pRes_Record->Record[CurrentEntries].Code   = EOL_FOUND_CODE;

                                Color = WHITE_COLOR;
                                Tree = WhiteDecodeTree;

                                code = 0;
                                CodeLength = 0;
                                CurrentOffsetStart = CurrentOffsetEnd;

                                CurrentEntries++;
                                if (CurrentEntries >= 4) {
                                    goto lDoLoop;
                                }

                                break;
                            }
                        }
                    }
                }
            }
        }


        if (CurrentEntries < 4) {
            pRes_Record->Record[CurrentEntries].Makeup = MAKEUP_CODE;
            pRes_Record->Record[CurrentEntries].Code   = NO_MORE_RECORDS;
        }

        TotalBlackGood++;
        TotalEntries[1][CurrentEntries]++;


lDoLoop:

        pRes_Record->Result.Tail = (BYTE) (CurrentOffsetStart);

        pRes_Record->Result.TwoColorsSize = Color2Change;

        pRes_Record->Record[0].OneColorSize = (Color1Change&0x08) ? 1:0 ;
        pRes_Record->Record[1].OneColorSize = (Color1Change&0x04) ? 1:0 ;
        pRes_Record->Record[2].OneColorSize = (Color1Change&0x02) ? 1:0 ;
        pRes_Record->Record[3].OneColorSize = (Color1Change&0x01) ? 1:0 ;

    }


}






BOOL
DecodeMrPage(
    HANDLE              hTiff,
    LPBYTE              OutputBuffer,
    BOOL                SingleLineBuffer,
    BOOL                HiRes
    )


{

    PTIFF_INSTANCE_DATA TiffInstance = (PTIFF_INSTANCE_DATA) hTiff;
    DWORD               i;
    PBYTE               plinebuf;
    DWORD               lineWidth;
    DWORD               Lines;
    DWORD               EolCount;
    DWORD               BadFaxLines;
    DWORD               ConsecBadLines=0;

    DWORD               AllowedBadFaxLines=5;
    DWORD               AllowedConsecBadLines=5;


    BOOL                LastLineBad;

    BOOL                Color;
    LPDWORD             EndPtr;
    PBYTE               TableWhite = (PBYTE) GlobTableWhite;
    PBYTE               TableBlack = (PBYTE) GlobTableBlack;
    PBYTE               Table;
    PBYTE               pByteTable,  pByteTail;
    BYTE                MakeupT;
    WORD                CodeT;
    BYTE                TailT;
    WORD                RunLength=0;

    DWORD               TableSize=32768;
    DWORD               t0, t1, tdelta;

    WORD                Line1Array[MaxColorTransPerLine];
    WORD                Line2Array[MaxColorTransPerLine];
    WORD                *pRefLine;
    WORD                *pCurLine;
    WORD                *pTmpSwap;
    BYTE                CColor, RColor, RColor1;
    WORD                RIndex, CIndex;
    DWORD               dwIndex;
    WORD                a0;
    WORD                RValue, RValue1;
    BYTE                Num2DLines;
    BYTE                Count2D;
    BOOL                f1D;
    LPDWORD             lpdwResPtr;
    BYTE                ResBit;
    short               iCode;
    BYTE                bShift;
    BYTE                CountHoriz;
    BOOL                fFirstResult;
    PBYTE               pByteTable0;
    BOOL                fTestLength;
    BOOL                fError;


    if (HiRes) {
        Num2DLines = 3;
    }
    else {
        Num2DLines = 1;
    }




    // start Pointers

    pRefLine = Line1Array;
    pCurLine = Line2Array;




    t0 = GetTickCount();

    Lines = 0;
    EolCount = 1;
    BadFaxLines = 0;
    LastLineBad = FALSE;
    TiffInstance->Color = 0;
    TiffInstance->RunLength = 0;
    TiffInstance->StartGood = 0;
    TiffInstance->EndGood = 0;
    plinebuf = TiffInstance->StripData;
    lineWidth = TiffInstance->ImageWidth;



    EndPtr = (LPDWORD) ( (ULONG_PTR) (plinebuf+TiffInstance->StripDataSize-1) & ~(0x3) ) ;
    fTestLength = DO_NOT_TEST_LENGTH;

    //
    // find first EOL
    //

    Count2D = 0;
    f1D = 1;

    lpdwResPtr = (LPDWORD) (((ULONG_PTR) plinebuf) & ~(0x3) );
    ResBit =   (BYTE) (( ( (ULONG_PTR) plinebuf) & 0x3) << 3) ;

    // EOL-loop

    do {


lFindNextEOL:

        if (! FindNextEol (lpdwResPtr, ResBit, EndPtr, &lpdwResPtr, &ResBit, fTestLength, &fError) ) {
            return FALSE;
        }

        if ( (fTestLength == DO_TEST_LENGTH) && fError ) {
            BadFaxLines++;
            if (LastLineBad) {
                ConsecBadLines++;
            }

            if (BadFaxLines > AllowedBadFaxLines ||
                ConsecBadLines > AllowedConsecBadLines) {
                    return FALSE;
            }
        }


lAfterEOL:

#ifdef RDEBUG
        _tprintf( TEXT ("\n After EOL RIndex=%d dwResPtr=%lx bit=%d Ref= \n "), RIndex, lpdwResPtr, ResBit);
        for (i=0; i<RIndex; i++) {
            _tprintf( TEXT ("%d, "), *(pRefLine+i) );
        }
#endif


        if (f1D) {

#ifdef RDEBUG
            _tprintf( TEXT (" Start 1D dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

            if (! ( (*lpdwResPtr) & (0x00000001 << ResBit ) ) )  {

#ifdef RDEBUG
                _tprintf( TEXT ("\n ERROR f1D dwResPtr=%lx bit=%d "), lpdwResPtr, ResBit);
#endif

                BadFaxLines++;
                if (LastLineBad) {
                    ConsecBadLines++;
                }

                if (BadFaxLines > AllowedBadFaxLines ||
                    ConsecBadLines > AllowedConsecBadLines) {
                        return FALSE;
                }

                ResBit++;
                if (ResBit > 31) {
                    lpdwResPtr++;
                    ResBit -= 32;
                }

                fTestLength = DO_NOT_TEST_LENGTH;
                goto lFindNextEOL;
            }

            // decode 1D line starting ResBit+1

            ResBit++;
            if (ResBit > 31) {
                lpdwResPtr++;
                ResBit -= 32;
            }

            RIndex = 0;
            RunLength = 0;

            Table = TableWhite;
            Color = WHITE_COLOR;

            if (EndPtr - lpdwResPtr < 2)  {
                return FALSE;
            }


            // 1-D Table look-up loop
            do {

                if (ResBit <= 17) {
                    dwIndex = (*lpdwResPtr) >> ResBit;
                }
                else {
                    dwIndex = ( (*lpdwResPtr) >> ResBit ) + ( (*(lpdwResPtr+1)) << (32-ResBit) ) ;
                }

                dwIndex &= 0x00007fff;

                pByteTable = Table + (5*dwIndex);
                pByteTail  = pByteTable+4;

                // All bytes

                for (i=0; i<4; i++)  {

                    MakeupT = *pByteTable & 0x80;
                    CodeT   = (WORD) *pByteTable & 0x3f;

                    if (MakeupT) {

                        if (CodeT < 28) {
                            RunLength += (CodeT << 6);
                            EolCount=0;
#ifdef RDEBUG
                            if (Color) {
                                _tprintf( TEXT ("b%d "), (CodeT << 6)  );
                            }
                            else {
                                _tprintf( TEXT ("w%d "), (CodeT << 6)  );
                            }
#endif
                        }

                        else if (CodeT == NO_MORE_RECORDS) {
                            goto lNextIndex1D;
                        }

                        else if (CodeT == LOOK_FOR_EOL_CODE)  {
                            // end of our line AHEAD
                            if (RunLength == lineWidth) {
                                EolCount = 0;
                                f1D = 0;
                                Count2D = 0;

                                fTestLength = DO_TEST_LENGTH;
                                TailT = *pByteTail & 0x0f;

                                ResBit += TailT;

                                if (ResBit > 31) {
                                        lpdwResPtr++;
                                        ResBit -= 32;
                                }

                                goto lFindNextEOL;

                            }
                            else if (RunLength != 0) {
#ifdef RDEBUG
                                _tprintf( TEXT ("\n!!! ERROR 1D RunLength\n"), RunLength  );
#endif

                                BadFaxLines++;
                                if (LastLineBad) {
                                    ConsecBadLines++;
                                }

                                if (BadFaxLines > AllowedBadFaxLines ||
                                    ConsecBadLines > AllowedConsecBadLines) {
                                        return FALSE;
                                }

                                f1D = 1;
                                Count2D = 0;

                                fTestLength = DO_NOT_TEST_LENGTH;
                                goto lFindNextEOL;

                            }
                            else {
                                // zero RunLength
                                EolCount++;

                                if (EolCount >= 5)  {
                                    t1 = GetTickCount();
                                    tdelta = t1 - t0;
                                    return (TRUE);
                                }

                                f1D = 1;
                                Count2D = 0;

                                fTestLength = DO_TEST_LENGTH;
                                TailT = *pByteTail & 0x0f;

                                ResBit += TailT;

                                if (ResBit > 31) {
                                        lpdwResPtr++;
                                        ResBit -= 32;
                                }

                                goto lFindNextEOL;
                            }
                        }

                        else if (CodeT == EOL_FOUND_CODE) {
#ifdef RDEBUG
                            _tprintf( TEXT ("   Res=%d\n"), RunLength  );
#endif

                            ResBit +=  (*pByteTail & 0x0f);
                            if (ResBit > 31) {
                                    lpdwResPtr++;
                                    ResBit -= 32;
                            }

                            if (RunLength == lineWidth) {
                                EolCount = 0;
                                f1D = 0;
                                Count2D = 0;

                                goto lAfterEOL;

                            }
                            else if (RunLength != 0) {
#ifdef RDEBUG
                                _tprintf( TEXT ("!!! ERROR 1D Runlength EOLFOUND \n")  );
#endif

                                BadFaxLines++;
                                if (LastLineBad) {
                                    ConsecBadLines++;
                                }

                                if (BadFaxLines > AllowedBadFaxLines ||
                                    ConsecBadLines > AllowedConsecBadLines) {
                                        return FALSE;
                                }

                                f1D = 1;
                                Count2D = 0;
                                goto lAfterEOL;
                            }
                            else {
                                // zero RunLength
                                EolCount++;

                                if (EolCount >= 5)  {
                                    t1 = GetTickCount();
                                    tdelta = t1 - t0;
                                    return (TRUE);
                                }

                                f1D = 1;
                                Count2D = 0;
                                goto lAfterEOL;
                            }

                        }

                        else if (CodeT == ERROR_CODE) {
#ifdef RDEBUG
                            _tprintf( TEXT (" ERROR CODE 1D dwResPtr=%lx bit=%d "), lpdwResPtr, ResBit);
#endif

                            BadFaxLines++;
                            if (LastLineBad) {
                                ConsecBadLines++;
                            }

                            if (BadFaxLines > AllowedBadFaxLines ||
                                ConsecBadLines > AllowedConsecBadLines) {
                                    return FALSE;
                            }

                            f1D = 1;
                            Count2D = 0;

                            fTestLength = DO_NOT_TEST_LENGTH;
                            goto lFindNextEOL;
                        }

                        else {
#ifdef RDEBUG
                            _tprintf( TEXT("ERROR: WRONG code: index=%04x\n"), dwIndex);
#endif

                            return FALSE;
                        }
                    }

                    else {  // terminating code
                        RunLength += CodeT;
                        *(pRefLine + (RIndex++)) = RunLength;


                        if (RIndex >= MaxColorTransPerLine ) {
#ifdef RDEBUG
                            _tprintf( TEXT (" ERROR 1D TOO MANY COLORS dwResPtr=%lx bit=%d "), lpdwResPtr, ResBit);
#endif

                            BadFaxLines++;
                            if (LastLineBad) {
                                ConsecBadLines++;
                            }

                            if (BadFaxLines > AllowedBadFaxLines ||
                                ConsecBadLines > AllowedConsecBadLines) {
                                    return FALSE;
                            }

                            f1D = 1;
                            Count2D = 0;

                            fTestLength = DO_NOT_TEST_LENGTH;
                            goto lFindNextEOL;
                        }

#ifdef RDEBUG
                        if (Color) {
                            _tprintf( TEXT ("b%d "), (CodeT)  );
                        }
                        else {
                            _tprintf( TEXT ("w%d "), (CodeT)  );
                        }
#endif
                        Color = 1 - Color;
                    }

                    pByteTable++;

                 }



lNextIndex1D:
                Table = Color ? TableBlack : TableWhite;
                TailT = *pByteTail & 0x0f;

                ResBit += TailT;

                if (ResBit > 31) {
                        lpdwResPtr++;
                        ResBit -= 32;
                }
            } while (lpdwResPtr <= EndPtr);

            return FALSE;
        }



        // should be 2D

#ifdef RDEBUG
        _tprintf( TEXT ("\n Start 2D dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

        if ( (*lpdwResPtr) & (0x00000001 << ResBit) )  {
#ifdef RDEBUG
            _tprintf( TEXT ("\n!!! ERROR Start 2D dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

            BadFaxLines++;
            if (LastLineBad) {
                ConsecBadLines++;
            }

            if (BadFaxLines > AllowedBadFaxLines ||
                ConsecBadLines > AllowedConsecBadLines) {
                    return FALSE;
            }

            f1D =  1;
            Count2D = 0;
            goto lAfterEOL;
        }


        // 2D line decode loop
        a0        = 0;
        CIndex    = 0;
        CColor    = 0;
        RunLength = 0;

        RIndex    = 0;
        RValue    = *(pRefLine + RIndex);
        RColor    = 0;

        //BUGBUG incorporate with the next Index calc. to save time

        if (++ResBit > 31) {
            lpdwResPtr++;
            ResBit -= 32;
        }

        // prefix loop
        do {


            if (ResBit <= 25 ) {
                dwIndex = (*lpdwResPtr) >> ResBit;
            }
            else {
                dwIndex = ( (*lpdwResPtr) >> ResBit ) + ( (*(lpdwResPtr+1)) << (32-ResBit) ) ;
            }

            dwIndex &= 0x0000007f;

            pByteTable = (BYTE *) (&PrefTable[dwIndex]);

            // work-around of a PPC compiler bug: incorrect CMP with signed char. NT 1381. 8/31/96. RafaelL
            iCode = ( (short) ((char) (*pByteTable)) ) >> 4;

            bShift = (*pByteTable) & 0x0f;

            if (iCode < 4) {
                // VERTICAL -3...+3
#ifdef RDEBUG
                _tprintf( TEXT (" V%2d "), iCode );
#endif

                if ( (RunLength >= RValue) && (RunLength != 0) ) {
                    while (++RIndex < MaxColorTransPerLine) {
                        if ( (RValue = *(pRefLine + RIndex) ) > RunLength )  {
                            // BUGBUG will change to break; after debugging
                            goto lFound;
                        }
                    }
#ifdef RDEBUG
                    _tprintf( TEXT ("!!! ERROR internal LOGIC RIndex=%d, RValue=%d, RunLength=%d\n "), RIndex, RValue, RunLength );
#endif

                    //DebugBreak();
                    return FALSE;


lFound:
                    RColor = RIndex & 1;
                }

                if (CColor == RColor)  {
                    a0 = RValue + iCode;
                }
                else {
                    if (RValue == LINE_LENGTH) {
                        a0 = RValue + iCode;
                    }
                    else {
                        a0 = *(pRefLine + RIndex + 1) + iCode;
                        //RColor = 1 - RColor;
                        //a0 = RValue + iCode;
                    }
                }

                *(pCurLine + (CIndex++) ) = a0;

#ifdef RDEBUG
                if (CColor) {
                    _tprintf( TEXT ("b%d "), (a0 - RunLength) );
                }
                else {
                    _tprintf( TEXT ("w%d "), (a0 - RunLength) );
                }
#endif
                RunLength = a0;
                CColor = 1 - CColor;

            }

            else if (iCode == HORIZ_PREFIX) {
#ifdef RDEBUG
                _tprintf( TEXT (" H ") );
#endif


                ResBit += bShift;
                if (ResBit > 31) {
                    ResBit -= 32;
                    lpdwResPtr++;
                }


                Table = CColor ? TableBlack : TableWhite;
                Color = CColor;
                CountHoriz = 0;
                fFirstResult = 1;

                if (EndPtr - lpdwResPtr < 2)  {
                    return FALSE;
                }


                // 1-D Table look-up loop
                do {

                    if (ResBit <= 17) {
                        dwIndex = (*lpdwResPtr) >> ResBit;
                    }
                    else {
                        dwIndex = ( (*lpdwResPtr) >> ResBit ) + ( (*(lpdwResPtr+1)) << (32-ResBit) ) ;
                    }


                    dwIndex &= 0x00007fff;

                    pByteTable = Table + (5*dwIndex);
                    pByteTail  = pByteTable+4;
                    pByteTable0 = pByteTable;

                    // All bytes

                    for (i=0; i<4; i++)  {

                        MakeupT = *pByteTable & 0x80;
                        CodeT   = (WORD) *pByteTable & 0x3f;

                        if (MakeupT) {

                            if (CodeT < 28) {
                                RunLength += (CodeT << 6);
#ifdef RDEBUG
                                if (Color) {
                                    _tprintf( TEXT ("b%d "), (CodeT << 6)  );
                                }
                                else {
                                    _tprintf( TEXT ("w%d "), (CodeT << 6)  );
                                }
#endif
                            }

                            else if (CodeT == NO_MORE_RECORDS) {
                                goto lNextIndexHoriz;
                            }

                            else  {
                                // ERROR: LOOK_FOR_EOL_CODE, EOL_FOUND_CODE, ERROR_CODE
#ifdef RDEBUG
                                _tprintf( TEXT ("\n!!! ERROR 2D dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

                                BadFaxLines++;
                                if (LastLineBad) {
                                    ConsecBadLines++;
                                }

                                if (BadFaxLines > AllowedBadFaxLines ||
                                    ConsecBadLines > AllowedConsecBadLines) {
                                        return FALSE;
                                }

                                f1D = 1;
                                Count2D = 0;

                                fTestLength = DO_NOT_TEST_LENGTH;
                                goto lFindNextEOL;
                            }

                        }

                        else {  // terminating code
                            RunLength += CodeT;
                            *(pCurLine + (CIndex++) ) = RunLength;

                            if (RIndex >= MaxColorTransPerLine ) {
                                BadFaxLines++;
                                if (LastLineBad) {
                                    ConsecBadLines++;
                                }

                                if (BadFaxLines > AllowedBadFaxLines ||
                                    ConsecBadLines > AllowedConsecBadLines) {
                                        return FALSE;
                                }

                                f1D = 1;
                                Count2D = 0;

#ifdef RDEBUG
                                _tprintf( TEXT ("\n!!! ERROR 2D TOO MANY Colors dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

                                fTestLength = DO_NOT_TEST_LENGTH;
                                goto lFindNextEOL;
                            }

#ifdef RDEBUG
                            if (Color) {
                                _tprintf( TEXT ("b%d "), (CodeT)  );
                            }
                            else {
                                _tprintf( TEXT ("w%d "), (CodeT)  );
                            }
#endif
                            Color = 1 - Color;
                            if (++CountHoriz >= 2)  {
                                if (fFirstResult) {
                                    bShift =  (*pByteTail & 0xf0) >> 4;
                                }
                                else {
                                    // rare case will take time
                                    bShift =  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 3 );
                                    bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 4 );
                                    bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 5 );
                                    bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 6 );
                                }
                                goto lNextPrefix;
                            }
                        }

                        pByteTable++;

                    }



lNextIndexHoriz:
                    if (Color != CColor) {
                        fFirstResult = 0;
                    }

                    Table = Color ? TableBlack : TableWhite;
                    TailT = *pByteTail & 0x0f;

                    ResBit += TailT;

                    if (ResBit > 31) {
                            lpdwResPtr++;
                            ResBit -= 32;
                    }
                } while (lpdwResPtr <= EndPtr);

                return FALSE;




            }

            else if (iCode == PASS_PREFIX) {
#ifdef RDEBUG
                _tprintf( TEXT (" P ") );
#endif

                if ( (RunLength >= RValue) && (RunLength != 0) ) {
                    while (++RIndex < MaxColorTransPerLine) {
                        if ( (RValue = *(pRefLine + RIndex) ) > RunLength )  {
                            goto lFound2;
                        }
                    }

#ifdef RDEBUG
                    _tprintf( TEXT ("!!! ERROR internal LOGIC RIndex=%d, RValue=%d, RunLength=%d\n "), RIndex, RValue, RunLength );
#endif
                    //DebugBreak();
                    return FALSE;


                }

lFound2:

                RColor = RIndex & 1;


                if (RValue != LINE_LENGTH) {
                    RValue1 = *(pRefLine + RIndex + 1 );

                    RColor1 = 1 - RColor;

                    if ( (RValue1 != LINE_LENGTH) && (RColor1 == CColor) ) {
                        a0 = *(pRefLine + RIndex + 2);
                    }
                    else {
                        a0 = RValue1;
                    }
                }
                else {
                    a0 = LINE_LENGTH;
                }


#ifdef RDEBUG
                if (CColor) {
                    _tprintf( TEXT ("b%d "), (a0 - RunLength) );
                }
                else {
                    _tprintf( TEXT ("w%d "), (a0 - RunLength) );
                }
#endif
                RunLength = a0;

            }

            else if (iCode == LOOK_FOR_EOL_PREFIX) {
#ifdef RDEBUG
                _tprintf( TEXT (" E ") );
#endif

                if (RunLength == lineWidth) {
                    if (++Count2D >= Num2DLines) {
                        Count2D = 0;
                        f1D = 1;
                    }

#ifdef RDEBUG
                    _tprintf( TEXT ("\n 2D done CINdex=%d dwResPtr=%lx bit=%d \n"), CIndex, lpdwResPtr, ResBit);
#endif

                    pTmpSwap = pRefLine;
                    pRefLine = pCurLine;
                    pCurLine = pTmpSwap;
                    RIndex = CIndex;

                    fTestLength = DO_TEST_LENGTH;
                    goto lFindNextEOL;
                }
                else  {

#ifdef RDEBUG
                    _tprintf( TEXT ("\n!!! ERROR 2D WRONG LINE LENGTH dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

                    BadFaxLines++;
                    if (LastLineBad) {
                        ConsecBadLines++;
                    }

                    if (BadFaxLines > AllowedBadFaxLines ||
                        ConsecBadLines > AllowedConsecBadLines) {
                            return FALSE;
                    }

                    f1D = 1;
                    Count2D = 0;

                    fTestLength = DO_NOT_TEST_LENGTH;
                    goto lFindNextEOL;
                }

            }

            else { //ERROR
#ifdef RDEBUG
                _tprintf( TEXT ("\n!!! ERROR 2D PREFIX dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

                BadFaxLines++;
                if (LastLineBad) {
                    ConsecBadLines++;
                }

                if (BadFaxLines > AllowedBadFaxLines ||
                    ConsecBadLines > AllowedConsecBadLines) {
                        return FALSE;
                }

                f1D = 1;
                Count2D = 0;

                fTestLength = DO_NOT_TEST_LENGTH;
                goto lFindNextEOL;
            }

lNextPrefix:
            ResBit += bShift;
            if (ResBit > 31) {
                lpdwResPtr++;
                ResBit -= 32;
            }

        } while (lpdwResPtr < EndPtr);

        return FALSE;

    } while (1);

    return FALSE;

}









BOOL
ScanMhSegment(
    LPDWORD             *lplpdwResPtr,
    BYTE                *lpResBit,
    LPDWORD              EndPtr,
    LPDWORD              EndBuffer,
    DWORD               *Lines,
    DWORD               *BadFaxLines,
    DWORD               *ConsecBadLines,
    DWORD                AllowedBadFaxLines,
    DWORD                AllowedConsecBadLines
    )

{

    LPDWORD             lpdwResPtr = *lplpdwResPtr;
    BYTE                ResBit = *lpResBit;

    DWORD               dwIndex;
    PBYTE               pByteTable,  pByteTail;
    PBYTE               TableWhite = (PBYTE) GlobTableWhite;
    PBYTE               TableBlack = (PBYTE) GlobTableBlack;
    PBYTE               Table;
    WORD                CodeT;
    BYTE                TailT;
    BYTE                MakeupT;
    WORD                RunLength=0;
    BOOL                Color;
    DWORD               i;
    DWORD               lineWidth = LINE_LENGTH;
    BOOL                fTestLength;
    DWORD               EolCount = 1;
    BOOL                LastLineBad = FALSE;
    BOOL                fError;
    BOOL                RetCode;




        Table = TableWhite;
        Color = WHITE_COLOR;


        //
        // EOL loop
        //
        do {

            // Table look-up loop
            do {

                if (ResBit <= 17) {
                    dwIndex = (*lpdwResPtr) >> ResBit;
                }
                else {
                    dwIndex = ( (*lpdwResPtr) >> ResBit ) + ( (*(lpdwResPtr+1)) << (32-ResBit) ) ;
                }

                dwIndex &= 0x00007fff;

                pByteTable = Table + (5*dwIndex);
                pByteTail  = pByteTable+4;


                for (i=0; i<4; i++) {

                    MakeupT = *pByteTable & 0x80;
                    CodeT   = (WORD) *pByteTable & 0x3f;

                    if (MakeupT) {

                        if (CodeT < 28) {
                            RunLength += (CodeT << 6);

                            if (RunLength > lineWidth) {
                                fTestLength =  DO_NOT_TEST_LENGTH;
                                goto lFindNextEOL;
                            }

                            EolCount=0;
#ifdef RDEBUG
                            if (Color) {
                                _tprintf( TEXT ("b%d "), (CodeT << 6)  );
                            }
                            else {
                                _tprintf( TEXT ("w%d "), (CodeT << 6)  );
                            }
#endif
                        }

                        else if (CodeT == NO_MORE_RECORDS) {
                            goto lNextIndex;
                        }

                        else if (CodeT == LOOK_FOR_EOL_CODE)  {
                            fTestLength =  DO_TEST_LENGTH;
                            TailT = *pByteTail & 0x0f;

                            ResBit += TailT;

                            if (ResBit > 31) {
                                    lpdwResPtr++;
                                    ResBit -= 32;
                            }

                            goto lFindNextEOL;
                        }

                        else if (CodeT == EOL_FOUND_CODE) {
#ifdef RDEBUG
                            _tprintf( TEXT ("   Res=%d\n"), RunLength  );
#endif
                            if ( RunLength != lineWidth ) {
                                if (RunLength != 0) {
                                    (*BadFaxLines)++;
                                   if (LastLineBad) {
                                        (*ConsecBadLines)++;
                                    }

                                    if (*BadFaxLines > AllowedBadFaxLines ||
                                        *ConsecBadLines > AllowedConsecBadLines) {

                                            goto bad_exit;
                                    }
                                }
                                else {
                                    // RunLength is 0
                                    EolCount++;

                                    if (EolCount >= 5)  {

                                        goto good_exit;
                                    }

                                }
                            }
                            else {
                                LastLineBad = FALSE;
                                *ConsecBadLines = 0;
                            }

                            (*Lines)++;
                            RunLength = 0;

                            Table = TableWhite;
                            Color = WHITE_COLOR;
                        }

                        else if (CodeT == ERROR_CODE) {
                            (*BadFaxLines)++;
                            if (LastLineBad) {
                                (*ConsecBadLines)++;
                            }

                            if (*BadFaxLines > AllowedBadFaxLines ||
                                *ConsecBadLines > AllowedConsecBadLines) {

                                    goto bad_exit;
                            }

                            fTestLength =  DO_NOT_TEST_LENGTH;
                            goto lFindNextEOL;
                        }
                        else {
#ifdef RDEBUG
                            _tprintf( TEXT("ERROR: WRONG code: index=%04x\n"), dwIndex);
#endif

                            goto bad_exit;
                        }
                    }

                    else {  // terminating code
                        RunLength += CodeT;
                        if (RunLength > lineWidth) {
                            fTestLength =  DO_NOT_TEST_LENGTH;
                            goto lFindNextEOL;
                        }

                        EolCount=0;

#ifdef RDEBUG
                        if (Color) {
                            _tprintf( TEXT ("b%d "), (CodeT)  );
                        }
                        else {
                            _tprintf( TEXT ("w%d "), (CodeT)  );
                        }
#endif
                        Color = 1 - Color;
                    }

                    pByteTable++;
                }


lNextIndex:
                Table = Color ? TableBlack : TableWhite;
                TailT = *pByteTail & 0x0f;

                ResBit += TailT;

                if (ResBit > 31) {
                        lpdwResPtr++;
                        ResBit -= 32;
                }
            } while (lpdwResPtr <= EndBuffer);

            // if we got here it means that line is longer than 4K.

            goto bad_exit;


lFindNextEOL:

#ifdef RDEBUG
            _tprintf( TEXT ("   Res=%d\n"), RunLength  );
#endif

            if (RunLength != lineWidth) {
                if (RunLength != 0) {
                    (*BadFaxLines)++;
                    if (LastLineBad) {
                        (*ConsecBadLines)++;
                    }

                    if (*BadFaxLines > AllowedBadFaxLines ||
                        *ConsecBadLines > AllowedConsecBadLines) {

                            goto bad_exit;
                    }
                }
                else {
                    // RunLength is 0
                    EolCount++;

                    if (EolCount >= 5)  {

                        goto good_exit;
                    }

                }
            }
            else {
                (*Lines)++;
                *ConsecBadLines=0;
            }

            RunLength = 0;

            if (! FindNextEol (lpdwResPtr, ResBit, EndBuffer, &lpdwResPtr, &ResBit, fTestLength, &fError) ) {
                goto bad_exit;
            }

            if (fTestLength == DO_TEST_LENGTH && fError) {
                (*BadFaxLines)++;
                if (LastLineBad) {
                    (*ConsecBadLines)++;
                }

                if (*BadFaxLines > AllowedBadFaxLines ||
                    *ConsecBadLines > AllowedConsecBadLines) {

                        goto bad_exit;
                }
            }

            Table = TableWhite;
            Color = WHITE_COLOR;


        } while (lpdwResPtr <= EndPtr);

        RetCode = TIFF_SCAN_SEG_END;
        goto l_exit;



bad_exit:

        RetCode = TIFF_SCAN_FAILURE;
        goto l_exit;



good_exit:
        RetCode = TIFF_SCAN_SUCCESS;
        goto l_exit;



l_exit:

        *lplpdwResPtr = lpdwResPtr;
        *lpResBit = ResBit;

        return (RetCode);

}

















//
//  We want to stop scanning if either:
//      1. we reached EOP
//      2. we reached last 1D line before EndPtr
//




BOOL
ScanMrSegment(
    LPDWORD             *lplpdwResPtr,
    BYTE                *lpResBit,
    LPDWORD              EndPtr,
    LPDWORD              EndBuffer,
    DWORD               *Lines,
    DWORD               *BadFaxLines,
    DWORD               *ConsecBadLines,
    DWORD                AllowedBadFaxLines,
    DWORD                AllowedConsecBadLines,
    BOOL                *f1D
    )

{


    LPDWORD             lpdwResPtr = *lplpdwResPtr;
    BYTE                ResBit = *lpResBit;

    DWORD               i;
    DWORD               dwTemp;
    DWORD               lineWidth = LINE_LENGTH;
    DWORD               EolCount = 1;
    BOOL                Color;
    PBYTE               TableWhite = (PBYTE) GlobTableWhite;
    PBYTE               TableBlack = (PBYTE) GlobTableBlack;
    PBYTE               Table;
    PBYTE               pByteTable,  pByteTail;
    BYTE                MakeupT;
    WORD                CodeT;
    BYTE                TailT;
    WORD                RunLength=0;

    DWORD               TableSize=32768;
    DWORD               dwIndex;
    BOOL                fTestLength;
    BOOL                fError;

    WORD                Line1Array[MaxColorTransPerLine];
    WORD                Line2Array[MaxColorTransPerLine];
    WORD                *pRefLine = Line1Array;
    WORD                *pCurLine = Line2Array;

    BYTE                CColor, RColor, RColor1;
    WORD                RIndex, CIndex;
    BYTE                Num2DLines = 0;
    BYTE                Count2D = 0;
    WORD                a0;
    WORD                RValue, RValue1;
    short               iCode;
    BYTE                bShift;
    BYTE                CountHoriz;
    BOOL                fFirstResult;
    PBYTE               pByteTable0;
    WORD                *pTmpSwap;
    BOOL                LastLineBad = FALSE;
    BOOL                RetCode;
    LPDWORD             lpdwResPtrLast1D = *lplpdwResPtr;
    BYTE                ResBitLast1D = *lpResBit;



    Table = TableWhite;
    Color = WHITE_COLOR;



        //
        // EOL-loop
        //

        do {

            dwTemp = (*lpdwResPtr) & (0x00000001 << ResBit );

            if (*f1D || dwTemp) {
//l1Dline:

#ifdef RDEBUG
                _tprintf( TEXT (" Start 1D dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

                if (! dwTemp) {

#ifdef RDEBUG
                    _tprintf( TEXT ("\n ERROR f1D dwResPtr=%lx bit=%d "), lpdwResPtr, ResBit);
#endif

                    (*BadFaxLines)++;
                    if (LastLineBad) {
                        (*ConsecBadLines)++;
                    }

                    if (*BadFaxLines > AllowedBadFaxLines ||
                        *ConsecBadLines > AllowedConsecBadLines) {

                            goto bad_exit;
                    }

                    ResBit++;
                    if (ResBit > 31) {
                        lpdwResPtr++;
                        ResBit -= 32;
                    }

                    fTestLength = DO_NOT_TEST_LENGTH;
                    *f1D = 1;
                    goto lFindNextEOL;
                }

                //
                // Remember
                //

                lpdwResPtrLast1D = lpdwResPtr;
                ResBitLast1D = ResBit;


                // decode 1D line starting ResBit+1

                ResBit++;
                if (ResBit > 31) {
                    lpdwResPtr++;
                    ResBit -= 32;
                }

                RIndex = 0;
                RunLength = 0;

                Table = TableWhite;
                Color = WHITE_COLOR;



                // 1-D Table look-up loop
                do {

                    if (ResBit <= 17) {
                        dwIndex = (*lpdwResPtr) >> ResBit;
                    }
                    else {
                        dwIndex = ( (*lpdwResPtr) >> ResBit ) + ( (*(lpdwResPtr+1)) << (32-ResBit) ) ;
                    }

                    dwIndex &= 0x00007fff;

                    pByteTable = Table + (5*dwIndex);
                    pByteTail  = pByteTable+4;

                    // All bytes

                    for (i=0; i<4; i++)  {

                        MakeupT = *pByteTable & 0x80;
                        CodeT   = (WORD) *pByteTable & 0x3f;

                        if (MakeupT) {

                            if (CodeT < 28) {
                                RunLength += (CodeT << 6);

                                if (RunLength > lineWidth) {
                                    (*BadFaxLines)++;
                                    if (LastLineBad) {
                                        *(ConsecBadLines)++;
                                    }

                                    if (*BadFaxLines > AllowedBadFaxLines ||
                                        *ConsecBadLines > AllowedConsecBadLines) {

                                            goto bad_exit;
                                    }

                                    *f1D = 1;
                                    Count2D = 0;

                                    fTestLength = DO_NOT_TEST_LENGTH;
                                    goto lFindNextEOL;
                                }

                                EolCount=0;
#ifdef RDEBUG
                                if (Color) {
                                    _tprintf( TEXT ("b%d "), (CodeT << 6)  );
                                }
                                else {
                                    _tprintf( TEXT ("w%d "), (CodeT << 6)  );
                                }
#endif
                            }

                            else if (CodeT == NO_MORE_RECORDS) {
                                goto lNextIndex1D;
                            }

                            else if (CodeT == LOOK_FOR_EOL_CODE)  {
                                // end of our line AHEAD
                                if (RunLength == lineWidth) {
                                    EolCount = 0;
                                    *f1D = 0;
                                    Count2D = 0;
                                    (*Lines)++;

                                    fTestLength = DO_TEST_LENGTH;
                                    TailT = *pByteTail & 0x0f;

                                    ResBit += TailT;

                                    if (ResBit > 31) {
                                            lpdwResPtr++;
                                            ResBit -= 32;
                                    }

                                    goto lFindNextEOL;

                                }
                                else if (RunLength != 0) {
#ifdef RDEBUG
                                    _tprintf( TEXT ("\n!!! ERROR 1D RunLength\n"), RunLength  );
#endif

                                    (*BadFaxLines)++;
                                    if (LastLineBad) {
                                        (*ConsecBadLines)++;
                                    }

                                    if (*BadFaxLines > AllowedBadFaxLines ||
                                        *ConsecBadLines > AllowedConsecBadLines) {

                                            goto bad_exit;
                                    }

                                    *f1D = 1;
                                    Count2D = 0;

                                    fTestLength = DO_NOT_TEST_LENGTH;
                                    goto lFindNextEOL;

                                }
                                else {
                                    // zero RunLength
                                    EolCount++;

                                    if (EolCount >= 5)  {

                                        goto good_exit;
                                    }

                                    *f1D = 1;
                                    Count2D = 0;

                                    fTestLength = DO_TEST_LENGTH;
                                    TailT = *pByteTail & 0x0f;

                                    ResBit += TailT;

                                    if (ResBit > 31) {
                                            lpdwResPtr++;
                                            ResBit -= 32;
                                    }

                                    goto lFindNextEOL;
                                }
                            }

                            else if (CodeT == EOL_FOUND_CODE) {
#ifdef RDEBUG
                                _tprintf( TEXT ("   Res=%d\n"), RunLength  );
#endif

                                ResBit +=  (*pByteTail & 0x0f);
                                if (ResBit > 31) {
                                        lpdwResPtr++;
                                        ResBit -= 32;
                                }

                                if (RunLength == lineWidth) {
                                    EolCount = 0;
                                    *f1D = 0;
                                    Count2D = 0;
                                    (*Lines)++;

                                    goto lAfterEOL;

                                }
                                else if (RunLength != 0) {
#ifdef RDEBUG
                                    _tprintf( TEXT ("!!! ERROR 1D Runlength EOLFOUND \n")  );
#endif

                                    (*BadFaxLines)++;
                                    if (LastLineBad) {
                                        (*ConsecBadLines)++;
                                    }

                                    if (*BadFaxLines > AllowedBadFaxLines ||
                                        *ConsecBadLines > AllowedConsecBadLines) {

                                            goto bad_exit;
                                    }

                                    *f1D = 1;
                                    Count2D = 0;
                                    goto lAfterEOL;
                                }
                                else {
                                    // zero RunLength
                                    EolCount++;

                                    if (EolCount >= 5)  {

                                        goto good_exit;
                                    }

                                    *f1D = 1;
                                    Count2D = 0;
                                    goto lAfterEOL;
                                }

                            }

                            else if (CodeT == ERROR_CODE) {
#ifdef RDEBUG
                                _tprintf( TEXT (" ERROR CODE 1D dwResPtr=%lx bit=%d "), lpdwResPtr, ResBit);
#endif

                                (*BadFaxLines)++;
                                if (LastLineBad) {
                                    (*ConsecBadLines)++;
                                }

                                if (*BadFaxLines > AllowedBadFaxLines ||
                                    *ConsecBadLines > AllowedConsecBadLines) {

                                        goto bad_exit;
                                }

                                *f1D = 1;
                                Count2D = 0;

                                fTestLength = DO_NOT_TEST_LENGTH;
                                goto lFindNextEOL;
                            }

                            else {
#ifdef RDEBUG
                                _tprintf( TEXT("ERROR: WRONG code: index=%04x\n"), dwIndex);
#endif
                                goto bad_exit;
                            }
                        }

                        else {  // terminating code
                            RunLength += CodeT;

                            if (RunLength > lineWidth) {
                                (*BadFaxLines)++;
                                if (LastLineBad) {
                                    (*ConsecBadLines)++;
                                }

                                if (*BadFaxLines > AllowedBadFaxLines ||
                                    *ConsecBadLines > AllowedConsecBadLines) {

                                        goto bad_exit;
                                }

                                *f1D = 1;
                                Count2D = 0;

                                fTestLength = DO_NOT_TEST_LENGTH;
                                goto lFindNextEOL;
                            }

                            *(pRefLine + (RIndex++)) = RunLength;


                            if (RIndex >= MaxColorTransPerLine ) {
#ifdef RDEBUG
                                _tprintf( TEXT (" ERROR 1D TOO MANY COLORS dwResPtr=%lx bit=%d "), lpdwResPtr, ResBit);
#endif

                                (*BadFaxLines)++;
                                if (LastLineBad) {
                                    (*ConsecBadLines)++;
                                }

                                if (*BadFaxLines > AllowedBadFaxLines ||
                                    *ConsecBadLines > AllowedConsecBadLines) {

                                        goto bad_exit;
                                }

                                *f1D = 1;
                                Count2D = 0;

                                fTestLength = DO_NOT_TEST_LENGTH;
                                goto lFindNextEOL;
                            }

#ifdef RDEBUG
                            if (Color) {
                                _tprintf( TEXT ("b%d "), (CodeT)  );
                            }
                            else {
                                _tprintf( TEXT ("w%d "), (CodeT)  );
                            }
#endif
                            Color = 1 - Color;
                        }

                        pByteTable++;

                     }



lNextIndex1D:
                    Table = Color ? TableBlack : TableWhite;
                    TailT = *pByteTail & 0x0f;

                    ResBit += TailT;

                    if (ResBit > 31) {
                            lpdwResPtr++;
                            ResBit -= 32;
                    }
                } while (lpdwResPtr <= EndBuffer);


                goto bad_exit;
            }


//l2Dline:
            // should be 2D

#ifdef RDEBUG
            _tprintf( TEXT ("\n Start 2D dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

            if ( (*lpdwResPtr) & (0x00000001 << ResBit) )  {
#ifdef RDEBUG
                _tprintf( TEXT ("\n!!! ERROR Start 2D dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

                (*BadFaxLines)++;
                if (LastLineBad) {
                    (*ConsecBadLines)++;
                }

                if (*BadFaxLines > AllowedBadFaxLines ||
                    *ConsecBadLines > AllowedConsecBadLines) {

                        goto bad_exit;
                }

                *f1D =  1;
                Count2D = 0;
                goto lAfterEOL;
            }


            // 2D line decode loop
            a0        = 0;
            CIndex    = 0;
            CColor    = 0;
            RunLength = 0;

            RIndex    = 0;
            RValue    = *(pRefLine + RIndex);
            RColor    = 0;

            //BUGBUG incorporate with the next Index calc. to save time

            if (++ResBit > 31) {
                lpdwResPtr++;
                ResBit -= 32;
            }

            // prefix loop
            do {


                if (ResBit <= 25 ) {
                    dwIndex = (*lpdwResPtr) >> ResBit;
                }
                else {
                    dwIndex = ( (*lpdwResPtr) >> ResBit ) + ( (*(lpdwResPtr+1)) << (32-ResBit) ) ;
                }

                dwIndex &= 0x0000007f;
                pByteTable = (BYTE *) (&PrefTable[dwIndex]);

                // work-around of a PPC compiler bug: incorrect CMP with signed char. NT 1381. 8/31/96. RafaelL
                iCode = ((short)  ( (char) (*pByteTable) ) ) >> 4;
                bShift = (*pByteTable) & 0x0f;

                if (iCode < 4) {
                    // VERTICAL -3...+3
#ifdef RDEBUG
                    _tprintf( TEXT (" V ") );
#endif

                    if ( (RunLength >= RValue) && (RunLength != 0) ) {
                        while (++RIndex < MaxColorTransPerLine) {
                            if ( (RValue = *(pRefLine + RIndex) ) > RunLength )  {
                                // BUGBUG will change to break; after debugging
                                goto lFound;
                            }
                        }
#ifdef RDEBUG
                        _tprintf( TEXT ("!!! ERROR internal LOGIC RIndex=%d, RValue=%d, RunLength=%d\n "), RIndex, RValue, RunLength );
#endif

                        (*BadFaxLines)++;
                        if (LastLineBad) {
                            (*ConsecBadLines)++;
                        }

                        if (*BadFaxLines > AllowedBadFaxLines ||
                            *ConsecBadLines > AllowedConsecBadLines) {

                                goto bad_exit;
                        }

                        *f1D = 1;
                        Count2D = 0;

                        fTestLength = DO_NOT_TEST_LENGTH;
                        goto lFindNextEOL;


lFound:
                        RColor = RIndex & 0x0001;
                    }

                    if (CColor == RColor)  {
                        a0 = RValue + iCode;
                    }
                    else {
                        if (RValue == LINE_LENGTH) {
                            a0 = RValue + iCode;
                        }
                        else {
                            a0 = *(pRefLine + RIndex + 1) + iCode;
                        }
                    }

                    // RSL 111296

                    if ( ( a0 <= RunLength ) && (a0 != 0) ) {
                        (*BadFaxLines)++;
                        if (LastLineBad) {
                            (*ConsecBadLines)++;
                        }

                        if (*BadFaxLines > AllowedBadFaxLines ||
                            *ConsecBadLines > AllowedConsecBadLines) {

                                goto bad_exit;
                        }

                        *f1D = 1;
                        Count2D = 0;

                        fTestLength = DO_NOT_TEST_LENGTH;
                        goto lFindNextEOL;
                    }


                    *(pCurLine + (CIndex++) ) = a0;

#ifdef RDEBUG
                    if (CColor) {
                        _tprintf( TEXT ("b%d "), (a0 - RunLength) );
                    }
                    else {
                        _tprintf( TEXT ("w%d "), (a0 - RunLength) );
                    }
#endif
                    RunLength = a0;
                    CColor = 1 - CColor;

                }

                else if (iCode == HORIZ_PREFIX) {
#ifdef RDEBUG
                    _tprintf( TEXT (" H ") );
#endif


                    ResBit += bShift;
                    if (ResBit > 31) {
                        ResBit -= 32;
                        lpdwResPtr++;
                    }


                    Table = CColor ? TableBlack : TableWhite;
                    Color = CColor;
                    CountHoriz = 0;
                    fFirstResult = 1;



                    // 1-D Table look-up loop
                    do {

                        if (ResBit <= 17) {
                            dwIndex = (*lpdwResPtr) >> ResBit;
                        }
                        else {
                            dwIndex = ( (*lpdwResPtr) >> ResBit ) + ( (*(lpdwResPtr+1)) << (32-ResBit) ) ;
                        }


                        dwIndex &= 0x00007fff;

                        pByteTable = Table + (5*dwIndex);
                        pByteTail  = pByteTable+4;
                        pByteTable0 = pByteTable;

                        // All bytes

                        for (i=0; i<4; i++)  {

                            MakeupT = *pByteTable & 0x80;
                            CodeT   = (WORD) *pByteTable & 0x3f;

                            if (MakeupT) {

                                if (CodeT < 28) {
                                    RunLength += (CodeT << 6);

                                    if (RunLength > lineWidth) {
                                        (*BadFaxLines)++;
                                        if (LastLineBad) {
                                            (*ConsecBadLines)++;
                                        }

                                        if (*BadFaxLines > AllowedBadFaxLines ||
                                            *ConsecBadLines > AllowedConsecBadLines) {

                                                goto bad_exit;
                                        }

                                        *f1D = 1;
                                        Count2D = 0;

                                        fTestLength = DO_NOT_TEST_LENGTH;
                                        goto lFindNextEOL;
                                    }

#ifdef RDEBUG
                                    if (Color) {
                                        _tprintf( TEXT ("b%d "), (CodeT << 6)  );
                                    }
                                    else {
                                        _tprintf( TEXT ("w%d "), (CodeT << 6)  );
                                    }
#endif
                                }

                                else if (CodeT == NO_MORE_RECORDS) {
                                    goto lNextIndexHoriz;
                                }

                                else  {
                                    // ERROR: LOOK_FOR_EOL_CODE, EOL_FOUND_CODE, ERROR_CODE
#ifdef RDEBUG
                                    _tprintf( TEXT ("\n!!! ERROR 2D dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

                                    (*BadFaxLines)++;
                                    if (LastLineBad) {
                                        (*ConsecBadLines)++;
                                    }

                                    if (*BadFaxLines > AllowedBadFaxLines ||
                                        *ConsecBadLines > AllowedConsecBadLines) {

                                            goto bad_exit;
                                    }

                                    *f1D = 1;
                                    Count2D = 0;

                                    fTestLength = DO_NOT_TEST_LENGTH;
                                    goto lFindNextEOL;
                                }

                            }

                            else {  // terminating code
                                RunLength += CodeT;

                                if (RunLength > lineWidth) {
                                    (*BadFaxLines)++;
                                    if (LastLineBad) {
                                        (*ConsecBadLines)++;
                                    }

                                    if (*BadFaxLines > AllowedBadFaxLines ||
                                        *ConsecBadLines > AllowedConsecBadLines) {

                                            goto bad_exit;
                                    }

                                    *f1D = 1;
                                    Count2D = 0;

                                    fTestLength = DO_NOT_TEST_LENGTH;
                                    goto lFindNextEOL;
                                }

                                *(pCurLine + (CIndex++) ) = RunLength;

                                if (CIndex >= MaxColorTransPerLine ) {
                                    (*BadFaxLines)++;
                                    if (LastLineBad) {
                                        (*ConsecBadLines)++;
                                    }

                                    if (*BadFaxLines > AllowedBadFaxLines ||
                                        *ConsecBadLines > AllowedConsecBadLines) {

                                            goto bad_exit;
                                    }

                                    *f1D = 1;
                                    Count2D = 0;

#ifdef RDEBUG
                                    _tprintf( TEXT ("\n!!! ERROR 2D TOO MANY Colors dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

                                    fTestLength = DO_NOT_TEST_LENGTH;
                                    goto lFindNextEOL;
                                }

#ifdef RDEBUG
                                if (Color) {
                                    _tprintf( TEXT ("b%d "), (CodeT)  );
                                }
                                else {
                                    _tprintf( TEXT ("w%d "), (CodeT)  );
                                }
#endif
                                Color = 1 - Color;
                                if (++CountHoriz >= 2)  {
                                    if (fFirstResult) {
                                        bShift =  (*pByteTail & 0xf0) >> 4;
                                    }
                                    else {
                                        // rare case will take time
                                        bShift =  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 3 );
                                        bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 4 );
                                        bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 5 );
                                        bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 6 );
                                    }
                                    goto lNextPrefix;
                                }
                            }

                            pByteTable++;

                        }



lNextIndexHoriz:
                        if (Color != CColor) {
                            fFirstResult = 0;
                        }

                        Table = Color ? TableBlack : TableWhite;
                        TailT = *pByteTail & 0x0f;

                        ResBit += TailT;

                        if (ResBit > 31) {
                                lpdwResPtr++;
                                ResBit -= 32;
                        }
                    } while (lpdwResPtr <= EndBuffer);

                        goto bad_exit;




                }

                else if (iCode == PASS_PREFIX) {
#ifdef RDEBUG
                    _tprintf( TEXT (" P ") );
#endif

                    if ( (RunLength >= RValue) && (RunLength != 0) ) {
                        while (++RIndex < MaxColorTransPerLine) {
                            if ( (RValue = *(pRefLine + RIndex) ) > RunLength )  {
                                goto lFound2;
                            }
                        }

#ifdef RDEBUG
                        _tprintf( TEXT ("!!! ERROR internal LOGIC RIndex=%d, RValue=%d, RunLength=%d\n "), RIndex, RValue, RunLength );
#endif


                        (*BadFaxLines)++;
                        if (LastLineBad) {
                            (*ConsecBadLines)++;
                        }

                        if (*BadFaxLines > AllowedBadFaxLines ||
                            *ConsecBadLines > AllowedConsecBadLines) {

                                goto bad_exit;
                        }

                        *f1D = 1;
                        Count2D = 0;

                        fTestLength = DO_NOT_TEST_LENGTH;
                        goto lFindNextEOL;

                    }

lFound2:

                    RColor = RIndex & 1;


                    if (RValue != LINE_LENGTH) {
                        RValue1 = *(pRefLine + RIndex + 1 );

                        RColor1 = 1 - RColor;

                        if ( (RValue1 != LINE_LENGTH) && (RColor1 == CColor) ) {
                            a0 = *(pRefLine + RIndex + 2);
                        }
                        else {
                            a0 = RValue1;
                        }
                    }
                    else {
                        a0 = LINE_LENGTH;
                    }


#ifdef RDEBUG
                    if (CColor) {
                        _tprintf( TEXT ("b%d "), (a0 - RunLength) );
                    }
                    else {
                        _tprintf( TEXT ("w%d "), (a0 - RunLength) );
                    }
#endif

                    // RSL 111296

                    if ( ( a0 <= RunLength ) && (a0 != 0) ) {
                        (*BadFaxLines)++;
                        if (LastLineBad) {
                            (*ConsecBadLines)++;
                        }

                        if (*BadFaxLines > AllowedBadFaxLines ||
                            *ConsecBadLines > AllowedConsecBadLines) {

                                goto bad_exit;
                        }

                        *f1D = 1;
                        Count2D = 0;

                        fTestLength = DO_NOT_TEST_LENGTH;
                        goto lFindNextEOL;

                    }


                    RunLength = a0;

                }

                else if (iCode == LOOK_FOR_EOL_PREFIX) {
#ifdef RDEBUG
                    _tprintf( TEXT (" E ") );
#endif

                    if (RunLength == lineWidth) {
                        if (++Count2D >= Num2DLines) {
                            Count2D = 0;
                            *f1D = 0;   // relax HiRes/LoRes 2D lines per 1D rules - HP Fax does 3 2D-lines per 1 1D-line in LoRes.

                        }

#ifdef RDEBUG
                        _tprintf( TEXT ("\n 2D done CINdex=%d dwResPtr=%lx bit=%d \n"), CIndex, lpdwResPtr, ResBit);
#endif

                        pTmpSwap = pRefLine;
                        pRefLine = pCurLine;
                        pCurLine = pTmpSwap;
                        RIndex = CIndex;

                        fTestLength = DO_TEST_LENGTH;
                        *f1D = 0;
                        (*Lines)++;

                        goto lFindNextEOL;
                    }
                    else  {

#ifdef RDEBUG
                        _tprintf( TEXT ("\n!!! ERROR 2D WRONG LINE LENGTH dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

                        (*BadFaxLines)++;
                        if (LastLineBad) {
                            (*ConsecBadLines)++;
                        }

                        if (*BadFaxLines > AllowedBadFaxLines ||
                            *ConsecBadLines > AllowedConsecBadLines) {

                                goto bad_exit;
                        }

                        *f1D = 1;
                        Count2D = 0;

                        fTestLength = DO_NOT_TEST_LENGTH;
                        goto lFindNextEOL;
                    }

                }

                else { //ERROR
#ifdef RDEBUG
                    _tprintf( TEXT ("\n!!! ERROR 2D PREFIX dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

                    (*BadFaxLines)++;
                    if (LastLineBad) {
                        (*ConsecBadLines)++;
                    }

                    if (*BadFaxLines > AllowedBadFaxLines ||
                        *ConsecBadLines > AllowedConsecBadLines) {

                            goto bad_exit;
                    }

                    *f1D = 1;
                    Count2D = 0;

                    fTestLength = DO_NOT_TEST_LENGTH;
                    goto lFindNextEOL;
                }

lNextPrefix:
                ResBit += bShift;
                if (ResBit > 31) {
                    lpdwResPtr++;
                    ResBit -= 32;
                }

            } while (lpdwResPtr < EndBuffer);

            goto bad_exit;



lFindNextEOL:

            RunLength = 0;

            if (! FindNextEol (lpdwResPtr, ResBit, EndBuffer, &lpdwResPtr, &ResBit, fTestLength, &fError) ) {
                goto bad_exit;
            }

            if ( (fTestLength == DO_TEST_LENGTH) && fError ) {
                (*BadFaxLines)++;
                if (LastLineBad) {
                    (*ConsecBadLines)++;
                }

                if (*BadFaxLines > AllowedBadFaxLines ||
                    *ConsecBadLines > AllowedConsecBadLines) {

                        goto bad_exit;
                }
            }


lAfterEOL:
            ;

#ifdef RDEBUG
            _tprintf( TEXT ("\n After EOL RIndex=%d dwResPtr=%lx bit=%d Ref= \n "), RIndex, lpdwResPtr, ResBit);
            for (i=0; i<RIndex; i++) {
                _tprintf( TEXT ("%d, "), *(pRefLine+i) );
            }
#endif


        } while (lpdwResPtr <= EndPtr);



        RetCode = TIFF_SCAN_SEG_END;
        goto l_exit;



bad_exit:

        RetCode = TIFF_SCAN_FAILURE;
        goto l_exit;



good_exit:
        RetCode = TIFF_SCAN_SUCCESS;
        goto l_exit;



l_exit:

        *lplpdwResPtr = lpdwResPtrLast1D;
        *lpResBit = ResBitLast1D;

        return (RetCode);


}





















BOOL
DecodeMhPage(
    HANDLE              hTiff,
    LPBYTE              OutputBuffer,
    BOOL                SingleLineBuffer
    )

/*++

Routine Description:

    Decode a single page of 1 dimensionaly compressed
    TIFF data.

Arguments:

    TiffInstance    - Pointer to the TIFF instance data
    OutputBuffer    - Output buffer where the uncompressed data
                      is written.  This buffer must be allocated
                      by the caller and must be large enough for
                      a single page of data.

Return Value:

    NONE

--*/

{
    PTIFF_INSTANCE_DATA TiffInstance = (PTIFF_INSTANCE_DATA) hTiff;
    DWORD               i;
    PBYTE               plinebuf;
    DWORD               lineWidth;
    DWORD               Lines;
    DWORD               EolCount;
    DWORD               BadFaxLines;
    DWORD               ConsecBadLines=0;

    DWORD               AllowedBadFaxLines=255;
    DWORD               AllowedConsecBadLines=255;


    BOOL                LastLineBad;

    BOOL                Color;
    LPDWORD             EndPtr;
    PBYTE               TableWhite = (PBYTE) GlobTableWhite;
    PBYTE               TableBlack = (PBYTE) GlobTableBlack;
    PBYTE               Table;
    PBYTE               pByteTable,  pByteTail;
    BYTE                MakeupT;
    WORD                CodeT;
    BYTE                TailT;
    WORD                RunLength=0;

    DWORD               TableSize=32768;
    DWORD               t0, t1, tdelta;
    LPDWORD             lpdwResPtr;
    BYTE                ResBit;
    DWORD               dwIndex;
    BOOL                fTestLength;
    BOOL                fError;

    //
    // initialization
    //


    t0 = GetTickCount();

    Lines = 0;
    EolCount = 1;
    BadFaxLines = 0;
    LastLineBad = FALSE;
    TiffInstance->Color = 0;
    TiffInstance->RunLength = 0;
    TiffInstance->StartGood = 0;
    TiffInstance->EndGood = 0;
    plinebuf = TiffInstance->StripData;
    lineWidth = TiffInstance->ImageWidth;



    EndPtr = (LPDWORD) ( (ULONG_PTR) (plinebuf+TiffInstance->StripDataSize-1) & ~(0x3) ) ;

    //
    // find first EOL
    //

    lpdwResPtr = (LPDWORD) (((ULONG_PTR) plinebuf) & ~(0x3) );
    ResBit =   (BYTE) (( ( (ULONG_PTR) plinebuf) & 0x3) << 3);


    if (! FindNextEol (lpdwResPtr, ResBit, EndPtr, &lpdwResPtr, &ResBit, DO_NOT_TEST_LENGTH, &fError) ) {
        return FALSE;
    }

    Table = TableWhite;
    Color = WHITE_COLOR;

    // EOL loop
    do {

        // Table look-up loop
        do {

            if (ResBit <= 17) {
                dwIndex = (*lpdwResPtr) >> ResBit;
            }
            else {
                dwIndex = ( (*lpdwResPtr) >> ResBit ) + ( (*(lpdwResPtr+1)) << (32-ResBit) ) ;
            }

            dwIndex &= 0x00007fff;

            pByteTable = Table + (5*dwIndex);
            pByteTail  = pByteTable+4;


            for (i=0; i<4; i++) {

                MakeupT = *pByteTable & 0x80;
                CodeT   = (WORD) *pByteTable & 0x3f;

                if (MakeupT) {

                    if (CodeT < 28) {
                        RunLength += (CodeT << 6);
                        EolCount=0;
#ifdef RDEBUG
                        if (Color) {
                            _tprintf( TEXT ("b%d "), (CodeT << 6)  );
                        }
                        else {
                            _tprintf( TEXT ("w%d "), (CodeT << 6)  );
                        }
#endif
                    }

                    else if (CodeT == NO_MORE_RECORDS) {
                        goto lNextIndex;
                    }

                    else if (CodeT == LOOK_FOR_EOL_CODE)  {
                        fTestLength =  DO_TEST_LENGTH;
                        TailT = *pByteTail & 0x0f;

                        ResBit += TailT;

                        if (ResBit > 31) {
                                lpdwResPtr++;
                                ResBit -= 32;
                        }

                        goto lFindNextEOL;
                    }

                    else if (CodeT == EOL_FOUND_CODE) {
#ifdef RDEBUG
                        _tprintf( TEXT ("   Res=%d\n"), RunLength  );
#endif
                        if (RunLength != lineWidth) {
                            BadFaxLines++;
                            if (LastLineBad) {
                                ConsecBadLines++;
                            }

                            if (BadFaxLines > AllowedBadFaxLines ||
                                ConsecBadLines > AllowedConsecBadLines) {
                                    return FALSE;
                            }
                        }
                        else {
                            LastLineBad = FALSE;
                        }

                        RunLength = 0;
                        EolCount++;

                        if (EolCount >= 5)  {
                            t1 = GetTickCount();
                            tdelta = t1 - t0;
#ifdef RDEBUG
                            _tprintf( TEXT("\n tdelta=%ld\n"),tdelta );
                            return (TRUE);
#endif
                        }

                        Lines++;

                        Table = TableWhite;
                        Color = WHITE_COLOR;

                    }

                    else if (CodeT == ERROR_CODE) {
                        BadFaxLines++;
                        if (LastLineBad) {
                            ConsecBadLines++;
                        }

                        if (BadFaxLines > AllowedBadFaxLines ||
                            ConsecBadLines > AllowedConsecBadLines) {
                                return FALSE;
                        }

                        fTestLength =  DO_NOT_TEST_LENGTH;
                        goto lFindNextEOL;
                    }
                    else {
#ifdef RDEBUG
                        _tprintf( TEXT("ERROR: WRONG code: index=%04x\n"), dwIndex);
#endif
                        return FALSE;
                    }
                }

                else {  // terminating code
                    RunLength += CodeT;
                    EolCount=0;

#ifdef RDEBUG
                    if (Color) {
                        _tprintf( TEXT ("b%d "), (CodeT)  );
                    }
                    else {
                        _tprintf( TEXT ("w%d "), (CodeT)  );
                    }
#endif
                    Color = 1 - Color;
                }

                pByteTable++;
            }


lNextIndex:
            Table = Color ? TableBlack : TableWhite;
            TailT = *pByteTail & 0x0f;

            ResBit += TailT;

            if (ResBit > 31) {
                    lpdwResPtr++;
                    ResBit -= 32;
            }
        } while (lpdwResPtr <= EndPtr);

        return FALSE;



lFindNextEOL:

#ifdef RDEBUG
    _tprintf( TEXT ("   Res=%d\n"), RunLength  );
#endif

    if (RunLength != lineWidth) {
        BadFaxLines++;
        if (LastLineBad) {
            ConsecBadLines++;
        }

        if (BadFaxLines > AllowedBadFaxLines ||
            ConsecBadLines > AllowedConsecBadLines) {
                return FALSE;
        }
    }
    else {
        Lines++;
        ConsecBadLines=0;
        LastLineBad = FALSE;
    }

    RunLength=0;



    if (! FindNextEol (lpdwResPtr, ResBit, EndPtr, &lpdwResPtr, &ResBit, fTestLength, &fError) ) {
        return FALSE;
    }

    if (fTestLength == DO_TEST_LENGTH && fError) {
        BadFaxLines++;
        if (LastLineBad) {
            ConsecBadLines++;
        }

        if (BadFaxLines > AllowedBadFaxLines ||
            ConsecBadLines > AllowedConsecBadLines) {
                return FALSE;
        }
    }

    Table = TableWhite;
    Color = WHITE_COLOR;
    EolCount++;

    if (EolCount >= 5)  {
        t1 = GetTickCount();
        tdelta = t1 - t0;
#ifdef RDEBUG
        _tprintf( TEXT("\n tdelta=%ld\n"),tdelta );
#endif
        return (TRUE);
    }

    } while (lpdwResPtr <= EndPtr);

    return FALSE;

}













BOOL
DecodeMmrPage(
    HANDLE              hTiff,
    LPBYTE              OutputBuffer,
    BOOL                SingleLineBuffer,
    BOOL                HiRes
    )


{

    PTIFF_INSTANCE_DATA TiffInstance = (PTIFF_INSTANCE_DATA) hTiff;
    DWORD               i;
    PBYTE               plinebuf;
    DWORD               lineWidth;
    DWORD               Lines;
    DWORD               EolCount;

    BOOL                Color;
    LPDWORD             EndPtr;
    PBYTE               TableWhite = (PBYTE) GlobTableWhite;
    PBYTE               TableBlack = (PBYTE) GlobTableBlack;
    PBYTE               Table;
    PBYTE               pByteTable,  pByteTail;
    BYTE                MakeupT;
    WORD                CodeT;
    BYTE                TailT;
    WORD                RunLength=0;

    DWORD               TableSize=32768;
    DWORD               t0, t1, tdelta;

    WORD                Line1Array[MaxColorTransPerLine];
    WORD                Line2Array[MaxColorTransPerLine];
    WORD                *pRefLine;
    WORD                *pCurLine;
    WORD                *pTmpSwap;
    BYTE                CColor, RColor, RColor1;
    WORD                RIndex, CIndex;
    DWORD               dwIndex;
    WORD                a0;
    WORD                RValue, RValue1;
    LPDWORD             lpdwResPtr;
    BYTE                ResBit;
    short               iCode;
    BYTE                bShift;
    BYTE                CountHoriz;
    BOOL                fFirstResult;
    PBYTE               pByteTable0;

    // debugging

    DWORD               DbgLinesStop = 0;
    DWORD               DbgStopCnt = 0;



    // start Pointers

    pRefLine = Line1Array;
    pCurLine = Line2Array;


    t0 = GetTickCount();

    Lines = 0;
    EolCount = 1;
    TiffInstance->Color = 0;
    TiffInstance->RunLength = 0;
    TiffInstance->StartGood = 0;
    TiffInstance->EndGood = 0;
    plinebuf = TiffInstance->StripData;
    lineWidth = TiffInstance->ImageWidth;



    EndPtr = (LPDWORD) ( (ULONG_PTR) (plinebuf+TiffInstance->StripDataSize-1) & ~(0x3) ) ;
    lpdwResPtr = (LPDWORD) (((ULONG_PTR) plinebuf) & ~(0x3) );
    ResBit =   (BYTE) (( ( (ULONG_PTR) plinebuf) & 0x3) << 3) ;


    // 2D line decode loop
    a0        = 0;
    CIndex    = 0;
    CColor    = 0;
    RunLength = 0;


    // first REF line is all white
    RIndex    = 1;
    *pRefLine = LINE_LENGTH;
    RValue    = LINE_LENGTH;
    RColor    = 0;



    // prefix loop
    do {

        if (RunLength == lineWidth) {

#ifdef RDEBUG

            if (DebGlobOutColors == 1) {
                for (i=0; i<CIndex; i++) {
                    _tprintf( TEXT("%03d> %04d; "), i, *(pCurLine+i) );
                }
            }

#endif

            if (Lines == DbgLinesStop) {
                DbgStopCnt++;
            }

            Lines++;

#ifdef RDEBUG
            _tprintf( TEXT(" EOL Line=%d\n\n"), Lines );
#endif

            pTmpSwap = pRefLine;
            pRefLine = pCurLine;
            pCurLine = pTmpSwap;
            RIndex   =  0;
            RValue   =  *pRefLine;
            RColor   =  0;

            a0        = 0;
            CIndex    = 0;
            CColor    = 0;
            RunLength = 0;


        }

        if (ResBit <= 25 ) {
            dwIndex = (*lpdwResPtr) >> ResBit;
        }
        else {
            dwIndex = ( (*lpdwResPtr) >> ResBit ) + ( (*(lpdwResPtr+1)) << (32-ResBit) ) ;
        }

        dwIndex &= 0x0000007f;

        pByteTable = (BYTE *) (&PrefTable[dwIndex]);
        iCode = ( (short)  ((char) (*pByteTable)) ) >> 4;
        bShift = (*pByteTable) & 0x0f;

        if (iCode < 4) {
            // VERTICAL -3...+3
#ifdef RDEBUG
            if (DebGlobOutPrefix)
                _tprintf( TEXT (" V%2d "), iCode );
#endif

            if ( (RunLength >= RValue) && (RunLength != 0) ) {
                while (++RIndex < MaxColorTransPerLine) {
                    if ( (RValue = *(pRefLine + RIndex) ) > RunLength )  {
                        // BUGBUG will change to break; after debugging
                        goto lFound;
                    }
                }

#ifdef RDEBUG
                _tprintf( TEXT ("!!! ERROR internal LOGIC RIndex=%d, RValue=%d, RunLength=%d\n "), RIndex, RValue, RunLength );
#endif

                //DebugBreak();
                return FALSE;

lFound:
                RColor = RIndex & 1;
            }

            if (CColor == RColor)  {
                a0 = RValue + iCode;
            }
            else {
                if (RValue == LINE_LENGTH) {
                    a0 = RValue + iCode;
                }
                else {
                    a0 = *(pRefLine + RIndex + 1) + iCode;
                }
            }

            *(pCurLine + (CIndex++) ) = a0;

#ifdef RDEBUG
            if (DebGlobOutPrefix) {
                if (CColor) {
                    _tprintf( TEXT ("b%d "), (a0 - RunLength) );
                }
                else {
                    _tprintf( TEXT ("w%d "), (a0 - RunLength) );
                }
            }
#endif

            // sanity check

            if ( (a0 < RunLength) || (a0 > LINE_LENGTH) ) {
#ifdef RDEBUG
                _tprintf( TEXT ("!!! ERROR MMR src a0=%d, RunLength=%d\n "), a0, RunLength );
#endif
                return FALSE;

            }

            RunLength = a0;
            CColor = 1 - CColor;

        }

        else if (iCode == HORIZ_PREFIX) {
#ifdef RDEBUG
            if (DebGlobOutPrefix)
                _tprintf( TEXT (" H ") );
#endif


            ResBit += bShift;
            if (ResBit > 31) {
                ResBit -= 32;
                lpdwResPtr++;
            }


            Table = CColor ? TableBlack : TableWhite;
            Color = CColor;
            CountHoriz = 0;
            fFirstResult = 1;


            // 1-D Table look-up loop
            do {

                if (ResBit <= 17) {
                    dwIndex = (*lpdwResPtr) >> ResBit;
                }
                else {
                    dwIndex = ( (*lpdwResPtr) >> ResBit ) + ( (*(lpdwResPtr+1)) << (32-ResBit) ) ;
                }


                dwIndex &= 0x00007fff;

                pByteTable = Table + (5*dwIndex);
                pByteTail  = pByteTable+4;
                pByteTable0 = pByteTable;

                // All bytes

                for (i=0; i<4; i++)  {

                    MakeupT = *pByteTable & 0x80;
                    CodeT   = (WORD) *pByteTable & 0x3f;

                    if (MakeupT) {

                        if (CodeT < 28) {
                            RunLength += (CodeT << 6);

                            // sanity check

                            if (RunLength > LINE_LENGTH)  {
#ifdef RDEBUG
                                _tprintf( TEXT ("!!! ERROR MMR src codeT=%d, RunLength=%d\n "), a0, RunLength );
#endif
                                return FALSE;

                            }

#ifdef RDEBUG
                            if (DebGlobOutPrefix) {
                                if (Color) {
                                    _tprintf( TEXT ("b%d "), (CodeT << 6)  );
                                }
                                else {
                                    _tprintf( TEXT ("w%d "), (CodeT << 6)  );
                                }
                            }
#endif
                        }

                        else if (CodeT == NO_MORE_RECORDS) {
                            goto lNextIndexHoriz;
                        }

                        else  {
                            // ERROR: LOOK_FOR_EOL_CODE, EOL_FOUND_CODE, ERROR_CODE
#ifdef RDEBUG
                            _tprintf( TEXT ("\n!!! ERROR 2D dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif
                            return FALSE;

                        }

                    }

                    else {  // terminating code
                        RunLength += CodeT;

                        *(pCurLine + (CIndex++) ) = RunLength;

                        // sanity check

                        if ( (RunLength > LINE_LENGTH) || ( CIndex >= MaxColorTransPerLine ) ) {
#ifdef RDEBUG
                            _tprintf( TEXT ("!!! ERROR MMR RunLength=%d, CodeT=%d, CIndex=%d\n "),
                                            RunLength, CodeT, CIndex );
#endif
                            return FALSE;

                        }


#ifdef RDEBUG
                        if (DebGlobOutPrefix) {
                            if (Color) {
                                _tprintf( TEXT ("b%d "), (CodeT)  );
                            }
                            else {
                                _tprintf( TEXT ("w%d "), (CodeT)  );
                            }
                        }
#endif
                        Color = 1 - Color;
                        if (++CountHoriz >= 2)  {
                            if (fFirstResult) {
                                bShift =  (*pByteTail & 0xf0) >> 4;
                            }
                            else {
                                // rare case will take time
                                bShift =  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 3 );
                                bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 4 );
                                bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 5 );
                                bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 6 );
                            }
                            goto lNextPrefix;
                        }
                    }

                    pByteTable++;

                }



lNextIndexHoriz:
                if (Color != CColor) {
                    fFirstResult = 0;
                }

                Table = Color ? TableBlack : TableWhite;
                TailT = *pByteTail & 0x0f;

                ResBit += TailT;

                if (ResBit > 31) {
                        lpdwResPtr++;
                        ResBit -= 32;
                }
            } while (lpdwResPtr <= EndPtr);

            return FALSE;




        }

        else if (iCode == PASS_PREFIX) {
#ifdef RDEBUG
            if (DebGlobOutPrefix)
                _tprintf( TEXT (" P ") );
#endif

            if ( (RunLength >= RValue) && (RunLength != 0) ) {
                while (++RIndex < MaxColorTransPerLine) {
                    if ( (RValue = *(pRefLine + RIndex) ) > RunLength )  {
                        goto lFound2;
                    }
                }

#ifdef RDEBUG
                _tprintf( TEXT ("!!! ERROR internal LOGIC RIndex=%d, RValue=%d, RunLength=%d\n "), RIndex, RValue, RunLength );
#endif
                //DebugBreak();
                return FALSE;


            }

lFound2:

            RColor = RIndex & 1;


            if (RValue != LINE_LENGTH) {
                RValue1 = *(pRefLine + RIndex + 1 );

                RColor1 = 1 - RColor;

                if ( (RValue1 != LINE_LENGTH) && (RColor1 == CColor) ) {
                    a0 = *(pRefLine + RIndex + 2);
                }
                else {
                    a0 = RValue1;
                }
            }
            else {
                a0 = LINE_LENGTH;
            }

#ifdef RDEBUG
            if (DebGlobOutPrefix) {
                if (CColor) {
                   _tprintf( TEXT ("b%d "), (a0 - RunLength) );
                }
                else {
                    _tprintf( TEXT ("w%d "), (a0 - RunLength) );
                }
            }
#endif


            // sanity check

            if ( (a0 < RunLength) || (a0 > LINE_LENGTH) ) {
#ifdef RDEBUG
                _tprintf( TEXT ("!!! ERROR MMR src a0=%d, RunLength=%d\n "), a0, RunLength );
#endif
                return FALSE;

            }

            RunLength = a0;

        }

        else if (iCode == LOOK_FOR_EOL_PREFIX) {
#ifdef RDEBUG
            // _tprintf( TEXT (" E ") );
#endif

            t1 = GetTickCount();
            tdelta = t1 - t0;
#ifdef RDEBUG
            _tprintf( TEXT ("\nTiming=%ld ms.\n"), tdelta );
#endif

            return TRUE;
        }

        else { //ERROR
#ifdef RDEBUG
            _tprintf( TEXT ("\n!!! ERROR 2D PREFIX dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

            return FALSE;
        }

lNextPrefix:
        ResBit += bShift;
        if (ResBit > 31) {
            lpdwResPtr++;
            ResBit -= 32;
        }

    } while (lpdwResPtr <= EndPtr);

    return FALSE;


}







BOOL
ConvMmrPageToMh(
    HANDLE              hTiff,
    LPDWORD             lpdwOutputBuffer,
    DWORD               *lpdwSizeOutputBuffer,
    BOOL                NegotHiRes,
    BOOL                SrcHiRes
    )


{
    PTIFF_INSTANCE_DATA TiffInstance = (PTIFF_INSTANCE_DATA) hTiff;
    DWORD               i;
    PBYTE               plinebuf;
    DWORD               lineWidth;
    DWORD               Lines;
    DWORD               EolCount;

    BOOL                Color;
    LPDWORD             EndPtr;
    PBYTE               TableWhite = (PBYTE) GlobTableWhite;
    PBYTE               TableBlack = (PBYTE) GlobTableBlack;
    PBYTE               Table;
    PBYTE               pByteTable,  pByteTail;
    BYTE                MakeupT;
    WORD                CodeT;
    BYTE                TailT;
    WORD                RunLength=0;

    DWORD               TableSize=32768;
    DWORD               t0, t1, tdelta;

    WORD                Line1Array[MaxColorTransPerLine];
    WORD                Line2Array[MaxColorTransPerLine];
    WORD                *pRefLine;
    WORD                *pCurLine;
    WORD                *pTmpSwap;
    BYTE                CColor, RColor, RColor1;
    WORD                RIndex, CIndex;
    DWORD               dwIndex;
    WORD                a0;
    WORD                RValue, RValue1;
    LPDWORD             lpdwResPtr;
    BYTE                ResBit;
    short               iCode;
    BYTE                bShift;
    BYTE                CountHoriz;
    BOOL                fFirstResult;
    PBYTE               pByteTable0;

    WORD                PrevValue;
    WORD                CurValue;
    BOOL                CurColor;
    WORD                CurPos;
    WORD                CurRun;
    BYTE                BitOut;
    DWORD               *lpdwOut;
    PCODETABLE          pTableEntry;
    PCODETABLE          pCodeTable;
    BOOL                fOutputLine = 0;
    BOOL                fReduceTwice = 0;

    if (NegotHiRes < SrcHiRes) {
        fReduceTwice = 1;
    }



    // start Pointers

    pRefLine = Line1Array;
    pCurLine = Line2Array;

    lpdwOut = lpdwOutputBuffer;
    BitOut = 0;

    ZeroMemory( (BYTE *) lpdwOutputBuffer, *lpdwSizeOutputBuffer);


    t0 = GetTickCount();

    Lines = 0;
    EolCount = 1;
    TiffInstance->Color = 0;
    TiffInstance->RunLength = 0;
    TiffInstance->StartGood = 0;
    TiffInstance->EndGood = 0;
    plinebuf = TiffInstance->StripData;
    lineWidth = TiffInstance->ImageWidth;



    EndPtr = (LPDWORD) ( (ULONG_PTR) (plinebuf+TiffInstance->StripDataSize-1) & ~(0x3) ) ;
    lpdwResPtr = (LPDWORD) (((ULONG_PTR) plinebuf) & ~(0x3) );
    ResBit =   (BYTE) (( ( (ULONG_PTR) plinebuf) & 0x3) << 3) ;


    // 2D line decode loop
    a0        = 0;
    CIndex    = 0;
    CColor    = 0;
    RunLength = 0;


    // first REF line is all white
    RIndex    = 1;
    *pRefLine = LINE_LENGTH;
    RValue    = LINE_LENGTH;
    RColor    = 0;



    // prefix loop
    do {

        if (RunLength == lineWidth) {

#ifdef RDEBUG
            _tprintf( TEXT(" EOL\n\n") );
#endif
            if (fReduceTwice) {
                fOutputLine = 1 - fOutputLine;
                if (!fOutputLine) {
                    goto lSkipLoRes;
                }
            }


            // Output Dest Line
            // BUGBUG  Use AlignEolTable[] here !
            // 1. Output Dest EOL byte aligned

            if (BitOut <= 4)  {
                *lpdwOut = *lpdwOut + 0x00008000;
                BitOut = 16;
            }
            else if (BitOut <= 12) {
                *lpdwOut = *lpdwOut + 0x00800000;
                BitOut = 24;
            }
            else if (BitOut <= 20) {
                *lpdwOut = *lpdwOut + 0x80000000;
                BitOut = 0;
                lpdwOut++;
            }
            else if (BitOut <= 28) {
                *(++lpdwOut) = 0x00000080;
                BitOut = 8;
            }
            else {
                *(++lpdwOut) = 0x00008000;
                BitOut = 16;
            }

            // 2. Output MH line based on Color Trans. Array

            PrevValue  = 0;
            CurColor = WHITE_COLOR;

            for (CurPos=0;  CurPos < MaxColorTransPerLine; CurPos++) {

                CurValue = *(pCurLine + CurPos);
                CurRun   = CurValue - PrevValue;

                pCodeTable = CurColor ? BlackRunCodesReversed : WhiteRunCodesReversed;

                // output makeup code if exists
                if (CurRun >= 64) {
                    pTableEntry = pCodeTable + (63 + (CurRun >> 6));

                    *lpdwOut = *lpdwOut + (((DWORD) (pTableEntry->code)) << BitOut);

                    if (BitOut + pTableEntry->length > 31)  {
                        *(++lpdwOut) = (((DWORD) (pTableEntry->code)) >> (32 - BitOut) );
                    }

                    BitOut += pTableEntry->length;
                    if (BitOut > 31) {
                        BitOut -= 32;
                    }

                    CurRun &= 0x3f;
                }

                // output terminating code always
                pTableEntry = pCodeTable + CurRun;

                *lpdwOut = *lpdwOut + (((DWORD) (pTableEntry->code)) << BitOut);

                if (BitOut + pTableEntry->length > 31)  {
                    *(++lpdwOut) = (((DWORD) (pTableEntry->code)) >> (32 - BitOut) );
                }

                BitOut += pTableEntry->length;
                if (BitOut > 31) {
                    BitOut -= 32;
                }



                if ( CurValue == LINE_LENGTH) {
                    break;
                }

                PrevValue = CurValue;
                CurColor  = 1 - CurColor;
           }

lSkipLoRes:
            // Next Src Line

            pTmpSwap = pRefLine;
            pRefLine = pCurLine;
            pCurLine = pTmpSwap;
            RIndex   =  0;
            RValue   =  *pRefLine;
            RColor   =  0;

            a0        = 0;
            CIndex    = 0;
            CColor    = 0;
            RunLength = 0;


        }

        if (ResBit <= 25 ) {
            dwIndex = (*lpdwResPtr) >> ResBit;
        }
        else {
            dwIndex = ( (*lpdwResPtr) >> ResBit ) + ( (*(lpdwResPtr+1)) << (32-ResBit) ) ;
        }

        dwIndex &= 0x0000007f;

        pByteTable = (BYTE *) (&PrefTable[dwIndex]);
        iCode = ( (short) ((char) (*pByteTable)) ) >> 4;
        bShift = (*pByteTable) & 0x0f;

        if (iCode < 4) {
            // VERTICAL -3...+3
#ifdef RDEBUG
            _tprintf( TEXT (" V%2d "), iCode );
#endif

            if ( (RunLength >= RValue) && (RunLength != 0) ) {
                while (++RIndex < MaxColorTransPerLine) {
                    if ( (RValue = *(pRefLine + RIndex) ) > RunLength )  {
                        // BUGBUG will change to break; after debugging
                        goto lFound;
                    }
                }

#ifdef RDEBUG
                _tprintf( TEXT ("!!! ERROR internal LOGIC RIndex=%d, RValue=%d, RunLength=%d\n "), RIndex, RValue, RunLength );
#endif
                //DebugBreak();
                return FALSE;


lFound:
                RColor = RIndex & 1;
            }

            if (CColor == RColor)  {
                a0 = RValue + iCode;
            }
            else {
                if (RValue == LINE_LENGTH) {
                    a0 = RValue + iCode;
                }
                else {
                    a0 = *(pRefLine + RIndex + 1) + iCode;
                }
            }

            *(pCurLine + (CIndex++) ) = a0;

#ifdef RDEBUG
            if (CColor) {
                _tprintf( TEXT ("b%d "), (a0 - RunLength) );
            }
            else {
                _tprintf( TEXT ("w%d "), (a0 - RunLength) );
            }
#endif

            // sanity check

            if ( (a0 < RunLength) || (a0 > LINE_LENGTH) ) {
#ifdef RDEBUG
                _tprintf( TEXT ("!!! ERROR MMR src a0=%d, RunLength=%d\n "), a0, RunLength );
#endif
                return FALSE;

            }

            RunLength = a0;
            CColor = 1 - CColor;

        }

        else if (iCode == HORIZ_PREFIX) {
#ifdef RDEBUG
            _tprintf( TEXT (" H ") );
#endif


            ResBit += bShift;
            if (ResBit > 31) {
                ResBit -= 32;
                lpdwResPtr++;
            }


            Table = CColor ? TableBlack : TableWhite;
            Color = CColor;
            CountHoriz = 0;
            fFirstResult = 1;


            // 1-D Table look-up loop
            do {

                if (ResBit <= 17) {
                    dwIndex = (*lpdwResPtr) >> ResBit;
                }
                else {
                    dwIndex = ( (*lpdwResPtr) >> ResBit ) + ( (*(lpdwResPtr+1)) << (32-ResBit) ) ;
                }


                dwIndex &= 0x00007fff;

                pByteTable = Table + (5*dwIndex);
                pByteTail  = pByteTable+4;
                pByteTable0 = pByteTable;

                // All bytes

                for (i=0; i<4; i++)  {

                    MakeupT = *pByteTable & 0x80;
                    CodeT   = (WORD) *pByteTable & 0x3f;

                    if (MakeupT) {

                        if (CodeT < 28) {
                            RunLength += (CodeT << 6);

                            // sanity check

                            if (RunLength > LINE_LENGTH)  {
#ifdef RDEBUG
                                _tprintf( TEXT ("!!! ERROR MMR src codeT=%d, RunLength=%d\n "), a0, RunLength );
#endif
                                return FALSE;

                            }

#ifdef RDEBUG
                            if (Color) {
                                _tprintf( TEXT ("b%d "), (CodeT << 6)  );
                            }
                            else {
                                _tprintf( TEXT ("w%d "), (CodeT << 6)  );
                            }
#endif
                        }

                        else if (CodeT == NO_MORE_RECORDS) {
                            goto lNextIndexHoriz;
                        }

                        else  {
                            // ERROR: LOOK_FOR_EOL_CODE, EOL_FOUND_CODE, ERROR_CODE
#ifdef RDEBUG
                            _tprintf( TEXT ("\n!!! ERROR 2D dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif
                            return FALSE;
                        }

                    }

                    else {  // terminating code
                        RunLength += CodeT;
                        *(pCurLine + (CIndex++) ) = RunLength;

                        // sanity check

                        if ( (RunLength > LINE_LENGTH) || ( CIndex >= MaxColorTransPerLine ) ) {
#ifdef RDEBUG
                            _tprintf( TEXT ("!!! ERROR MMR RunLength=%d, CodeT=%d, CIndex=%d\n "),
                                            RunLength, CodeT, CIndex );
#endif
                            return FALSE;

                        }

#ifdef RDEBUG
                        if (Color) {
                            _tprintf( TEXT ("b%d "), (CodeT)  );
                        }
                        else {
                            _tprintf( TEXT ("w%d "), (CodeT)  );
                        }
#endif
                        Color = 1 - Color;
                        if (++CountHoriz >= 2)  {
                            if (fFirstResult) {
                                bShift =  (*pByteTail & 0xf0) >> 4;
                            }
                            else {
                                // rare case will take time
                                bShift =   ( ( (BYTE) (*pByteTable0++) & 0x40) >> 3 );
                                bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 4 );
                                bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 5 );
                                bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 6 );
                            }
                            goto lNextPrefix;
                        }
                    }

                    pByteTable++;

                }



lNextIndexHoriz:
                if (Color != CColor) {
                    fFirstResult = 0;
                }

                Table = Color ? TableBlack : TableWhite;
                TailT = *pByteTail & 0x0f;

                ResBit += TailT;

                if (ResBit > 31) {
                        lpdwResPtr++;
                        ResBit -= 32;
                }
            } while (lpdwResPtr <= EndPtr);

            return FALSE;




        }

        else if (iCode == PASS_PREFIX) {
#ifdef RDEBUG
            _tprintf( TEXT (" P ") );
#endif

            if ( (RunLength >= RValue) && (RunLength != 0) ) {
                while (++RIndex < MaxColorTransPerLine) {
                    if ( (RValue = *(pRefLine + RIndex) ) > RunLength )  {
                        goto lFound2;
                    }
                }

#ifdef RDEBUG
                _tprintf( TEXT ("!!! ERROR internal LOGIC RIndex=%d, RValue=%d, RunLength=%d\n "), RIndex, RValue, RunLength );
#endif
                //DebugBreak();
                return FALSE;


            }

lFound2:

            RColor = RIndex & 1;


            if (RValue != LINE_LENGTH) {
                RValue1 = *(pRefLine + RIndex + 1 );

                RColor1 = 1 - RColor;

                if ( (RValue1 != LINE_LENGTH) && (RColor1 == CColor) ) {
                    a0 = *(pRefLine + RIndex + 2);
                }
                else {
                    a0 = RValue1;
                }
            }
            else {
                a0 = LINE_LENGTH;
            }


#ifdef RDEBUG
            if (CColor) {
                _tprintf( TEXT ("b%d "), (a0 - RunLength) );
            }
            else {
                _tprintf( TEXT ("w%d "), (a0 - RunLength) );
            }
#endif

            // sanity check

            if ( (a0 < RunLength) || (a0 > LINE_LENGTH) ) {
#ifdef RDEBUG
                _tprintf( TEXT ("!!! ERROR MMR src a0=%d, RunLength=%d\n "), a0, RunLength );
#endif
                return FALSE;

            }

            RunLength = a0;

        }

        else if (iCode == LOOK_FOR_EOL_PREFIX) {
#ifdef RDEBUG
            // _tprintf( TEXT (" E ") );
#endif

            t1 = GetTickCount();
            tdelta = t1 - t0;

            // BUGBUG. In T.30 we send un-aligned RTC by request
            // so we shouldn't send it here. It also conflicts
            // with the filtering and expanding T.30 code

#if 0
            for (i=0; i<6; i++) {

                (*lpdwOut) += ( ((DWORD) (EOL_REVERSED_CODE)) << BitOut);
                if ( (BitOut = BitOut + EOL_LENGTH ) > 31 ) {
                    BitOut -= 32;
                    *(++lpdwOut) = ( (DWORD) (EOL_REVERSED_CODE) ) >> (EOL_LENGTH - BitOut);
                }

            }

            *(++lpdwOut) = 0x80000000;
#endif

            // BUGBUG  Use AlignEolTable[] here !
            // 1. Output EOL byte aligned for the last line.

            if (BitOut <= 4)  {
                *lpdwOut = *lpdwOut + 0x00008000;
                BitOut = 16;
            }
            else if (BitOut <= 12) {
                *lpdwOut = *lpdwOut + 0x00800000;
                BitOut = 24;
            }
            else if (BitOut <= 20) {
                *lpdwOut = *lpdwOut + 0x80000000;
                BitOut = 0;
                lpdwOut++;
            }
            else if (BitOut <= 28) {
                *(++lpdwOut) = 0x00000080;
                BitOut = 8;
            }
            else {
                *(++lpdwOut) = 0x00008000;
                BitOut = 16;
            }

            *lpdwSizeOutputBuffer =
                (DWORD)((lpdwOut - lpdwOutputBuffer) * sizeof (DWORD) + ( BitOut >> 3));
            return TRUE;
        }

        else { //ERROR

#ifdef RDEBUG
           _tprintf( TEXT ("\n!!! ERROR 2D dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif
            return FALSE;

        }

lNextPrefix:
        ResBit += bShift;
        if (ResBit > 31) {
            lpdwResPtr++;
            ResBit -= 32;
        }

    } while (lpdwResPtr <= EndPtr);

    return FALSE;


}
















BOOL
ConvMmrPageToMrSameRes(
    HANDLE              hTiff,
    LPDWORD             lpdwOutputBuffer,
    DWORD               *lpdwSizeOutputBuffer,
    BOOL                NegotHiRes
    )


{

    PTIFF_INSTANCE_DATA TiffInstance = (PTIFF_INSTANCE_DATA) hTiff;
    DWORD               i;
    PBYTE               plinebuf;
    DWORD               lineWidth;
    DWORD               Lines;
    DWORD               EolCount;

    BOOL                Color;
    LPDWORD             EndPtr;
    PBYTE               TableWhite = (PBYTE) GlobTableWhite;
    PBYTE               TableBlack = (PBYTE) GlobTableBlack;
    PBYTE               Table;
    PBYTE               pByteTable,  pByteTail;
    BYTE                MakeupT;
    WORD                CodeT;
    BYTE                TailT;
    WORD                RunLength=0;

    DWORD               TableSize=32768;
    DWORD               t0, t1, tdelta;

    WORD                Line1Array[MaxColorTransPerLine];
    WORD                Line2Array[MaxColorTransPerLine];
    WORD                *pRefLine;
    WORD                *pCurLine;
    WORD                *pTmpSwap;
    BYTE                CColor, RColor, RColor1;
    WORD                RIndex, CIndex;
    DWORD               dwIndex;
    WORD                a0;
    WORD                RValue, RValue1;
    BYTE                Num2DLines;
    LPDWORD             lpdwResPtr;
    BYTE                ResBit;
    short               iCode;
    BYTE                bShift;
    BYTE                CountHoriz;
    BOOL                fFirstResult;
    PBYTE               pByteTable0;

    WORD                PrevValue;
    WORD                CurValue;
    BOOL                CurColor;
    WORD                CurPos;
    WORD                CurRun;
    BYTE                BitOut;
    DWORD               *lpdwOut;
    PCODETABLE          pTableEntry;
    PCODETABLE          pCodeTable;

    BYTE                dwNewBitOut;
    BYTE                dwPrevResBit;
    BYTE                dw1,
                        dw2;
    BOOL                f1D = 1;

    BYTE                Count2D;
    DWORD               dwTmp;
    DWORD               *lpdwPrevResPtr;


    if (NegotHiRes) {
        Num2DLines = 3;
    }
    else {
        Num2DLines = 1;
    }


    // start Pointers

    pRefLine = Line1Array;
    pCurLine = Line2Array;

    lpdwOut = lpdwOutputBuffer;
    BitOut = 0;

    ZeroMemory( (BYTE *) lpdwOutputBuffer, *lpdwSizeOutputBuffer );


    t0 = GetTickCount();

    Lines = 0;
    EolCount = 1;
    TiffInstance->Color = 0;
    TiffInstance->RunLength = 0;
    TiffInstance->StartGood = 0;
    TiffInstance->EndGood = 0;
    plinebuf = TiffInstance->StripData;
    lineWidth = TiffInstance->ImageWidth;



    EndPtr = (LPDWORD) ( (ULONG_PTR) (plinebuf+TiffInstance->StripDataSize-1) & ~(0x3) ) ;
    lpdwResPtr = (LPDWORD) (((ULONG_PTR) plinebuf) & ~(0x3) );
    ResBit =   (BYTE) (( ( (ULONG_PTR) plinebuf) & 0x3) << 3) ;


    lpdwPrevResPtr = lpdwResPtr;
    dwPrevResBit   = ResBit;

    // 2D line decode loop
    a0        = 0;
    CIndex    = 0;
    CColor    = 0;
    RunLength = 0;


    // first REF line is all white
    RIndex    = 1;
    *pRefLine = LINE_LENGTH;
    RValue    = LINE_LENGTH;
    RColor    = 0;

    f1D       = 1;
    Count2D   = 0;

    //
    // prefix loop
    //

    do {


        if (RunLength == lineWidth) {

#ifdef RDEBUG
            _tprintf( TEXT(" EOL\n\n") );
#endif
            //
            // Output Dest Line
            //

            //
            // 1. Output Dest EOL byte aligned followed by a 1D/2D tag.
            //

            dwNewBitOut = AlignEolTable[ BitOut ];
            if (dwNewBitOut < BitOut) {
                lpdwOut++;
            }

            BitOut = dwNewBitOut;

            *lpdwOut += (0x00000001 << (BitOut++) );

            if (BitOut == 32) {
                BitOut = 0;
                lpdwOut++;
            }


            if (f1D) {
                // 2. Output MH line based on Color Trans. Array

                *lpdwOut += (0x00000001 << (BitOut++));

                PrevValue  = 0;
                CurColor = WHITE_COLOR;

                for (CurPos=0;  CurPos < MaxColorTransPerLine; CurPos++) {

                    CurValue = *(pCurLine + CurPos);
                    CurRun   = CurValue - PrevValue;

                    pCodeTable = CurColor ? BlackRunCodesReversed : WhiteRunCodesReversed;

                    // output makeup code if exists
                    if (CurRun >= 64) {
                        pTableEntry = pCodeTable + (63 + (CurRun >> 6));

                        *lpdwOut = *lpdwOut + (((DWORD) (pTableEntry->code)) << BitOut);

                        if (BitOut + pTableEntry->length > 31)  {
                            *(++lpdwOut) = (((DWORD) (pTableEntry->code)) >> (32 - BitOut) );
                        }

                        BitOut += pTableEntry->length;
                        if (BitOut > 31) {
                            BitOut -= 32;
                        }

                        CurRun &= 0x3f;
                    }

                    // output terminating code always
                    pTableEntry = pCodeTable + CurRun;

                    *lpdwOut = *lpdwOut + (((DWORD) (pTableEntry->code)) << BitOut);

                    if (BitOut + pTableEntry->length > 31)  {
                        *(++lpdwOut) = (((DWORD) (pTableEntry->code)) >> (32 - BitOut) );
                    }

                    BitOut += pTableEntry->length;
                    if (BitOut > 31) {
                        BitOut -= 32;
                    }



                    if ( CurValue == LINE_LENGTH) {
                        break;
                    }

                    PrevValue = CurValue;
                    CurColor  = 1 - CurColor;

                }
                f1D = 0;
                Count2D = 0;

            }
            else {
                // 2. Output 2D line - exact copy of an MMR corresponding 2D segment

                BitOut++;  // no need to test < 32 : never happens.

                if (lpdwResPtr == lpdwPrevResPtr) {
                    // insertion is a part of a DWORD

                    dwTmp = *lpdwPrevResPtr & (MINUS_ONE_DWORD << dwPrevResBit);
                    dwTmp &=  (MINUS_ONE_DWORD >> (32 - ResBit) );

                    if (BitOut >= dwPrevResBit) {
                        dw1 = (32 - BitOut);
                        dw2 =  ResBit - dwPrevResBit;

                        *lpdwOut += ( dwTmp << (BitOut - dwPrevResBit) );

                        if ( dw1 < dw2 ) {
                            *(++lpdwOut) = dwTmp >> (dwPrevResBit + dw1) ;
                            BitOut =  dw2 - dw1;
                        }
                        else {
                            if ( (BitOut = BitOut + dw2) > 31 )  {
                                BitOut -= 32;
                                lpdwOut++;
                            }
                        }

                    }
                    else {
                        *lpdwOut += ( dwTmp >> (dwPrevResBit - BitOut) );
                        BitOut += (ResBit - dwPrevResBit);
                    }
                }
                else {
                    // copy first left-justified part of a DWORD

                    dwTmp = *(lpdwPrevResPtr++) & (MINUS_ONE_DWORD << dwPrevResBit);

                    if (BitOut > dwPrevResBit) {
                        dw1 = BitOut - dwPrevResBit;

                        *lpdwOut += ( dwTmp << dw1 );
                        *(++lpdwOut) = dwTmp >> (32 - dw1) ;
                        BitOut = dw1;
                    }
                    else {
                        *lpdwOut += ( dwTmp >> (dwPrevResBit - BitOut) );
                        if ( (BitOut = BitOut + 32 - dwPrevResBit) > 31 )  {
                            BitOut -= 32;
                            lpdwOut++;
                        }
                    }

                    // copy entire DWORDs in a middle

                    while (lpdwPrevResPtr < lpdwResPtr) {
                        if (BitOut == 0) {
                            *(lpdwOut++) = *(lpdwPrevResPtr++);
                        }
                        else {
                            *lpdwOut += ( *lpdwPrevResPtr << BitOut );
                            *(++lpdwOut) = *(lpdwPrevResPtr++) >> (32 - BitOut);
                        }
                    }

                    // copy last right-justified part of a DWORD

                    if (ResBit != 0) {
                        dwTmp = *lpdwPrevResPtr & (MINUS_ONE_DWORD >> (32 - ResBit) );

                        dw1 = (32 - BitOut);
                        *lpdwOut += ( dwTmp << BitOut );

                        if (dw1 < ResBit) {
                            *(++lpdwOut) = dwTmp >> dw1;
                            BitOut = ResBit - dw1;
                        }
                        else {
                             if ( (BitOut = BitOut + ResBit) > 31 )  {
                                 BitOut -= 32;
                                 lpdwOut++;
                             }
                        }
                    }
                }


                if (++Count2D >= Num2DLines) {
                    Count2D = 0;
                    f1D = 1;
                }

            }

            // Remember Prev. line coordinates

            dwPrevResBit   = ResBit;
            lpdwPrevResPtr = lpdwResPtr;


            // Next Src Line

            pTmpSwap = pRefLine;
            pRefLine = pCurLine;
            pCurLine = pTmpSwap;
            RIndex   =  0;
            RValue   =  *pRefLine;
            RColor   =  0;

            a0        = 0;
            CIndex    = 0;
            CColor    = 0;
            RunLength = 0;


        }

        if (ResBit <= 25 ) {
            dwIndex = (*lpdwResPtr) >> ResBit;
        }
        else {
            dwIndex = ( (*lpdwResPtr) >> ResBit ) + ( (*(lpdwResPtr+1)) << (32-ResBit) ) ;
        }

        dwIndex &= 0x0000007f;

        pByteTable = (BYTE *) (&PrefTable[dwIndex]);
        iCode = ( (short)  ((char) (*pByteTable)) ) >> 4;
        bShift = (*pByteTable) & 0x0f;

        if (iCode < 4) {
            // VERTICAL -3...+3
#ifdef RDEBUG
            _tprintf( TEXT (" V%2d "), iCode );
#endif

            if ( (RunLength >= RValue) && (RunLength != 0) ) {
                while (++RIndex < MaxColorTransPerLine) {
                    if ( (RValue = *(pRefLine + RIndex) ) > RunLength )  {
                        // BUGBUG will change to break; after debugging
                        goto lFound;
                    }
                }

#ifdef RDEBUG
                _tprintf( TEXT ("!!! ERROR internal LOGIC RIndex=%d, RValue=%d, RunLength=%d\n "), RIndex, RValue, RunLength );
#endif

                //DebugBreak();
                return FALSE;


lFound:
                RColor = RIndex & 1;
            }

            if (CColor == RColor)  {
                a0 = RValue + iCode;
            }
            else {
                if (RValue == LINE_LENGTH) {
                    a0 = RValue + iCode;
                }
                else {
                    a0 = *(pRefLine + RIndex + 1) + iCode;
                }
            }

            *(pCurLine + (CIndex++) ) = a0;

#ifdef RDEBUG
            if (CColor) {
                _tprintf( TEXT ("b%d "), (a0 - RunLength) );
            }
            else {
                _tprintf( TEXT ("w%d "), (a0 - RunLength) );
            }
#endif

            // sanity check

            if ( (a0 < RunLength) || (a0 > LINE_LENGTH) ) {
#ifdef RDEBUG
                _tprintf( TEXT ("!!! ERROR MMR src a0=%d, RunLength=%d\n "), a0, RunLength );
#endif
                return FALSE;

            }


            RunLength = a0;
            CColor = 1 - CColor;

        }

        else if (iCode == HORIZ_PREFIX) {
#ifdef RDEBUG
            _tprintf( TEXT (" H ") );
#endif


            ResBit += bShift;
            if (ResBit > 31) {
                ResBit -= 32;
                lpdwResPtr++;
            }


            Table = CColor ? TableBlack : TableWhite;
            Color = CColor;
            CountHoriz = 0;
            fFirstResult = 1;


            // 1-D Table look-up loop
            do {

                if (ResBit <= 17) {
                    dwIndex = (*lpdwResPtr) >> ResBit;
                }
                else {
                    dwIndex = ( (*lpdwResPtr) >> ResBit ) + ( (*(lpdwResPtr+1)) << (32-ResBit) ) ;
                }


                dwIndex &= 0x00007fff;

                pByteTable = Table + (5*dwIndex);
                pByteTail  = pByteTable+4;
                pByteTable0 = pByteTable;

                // All bytes

                for (i=0; i<4; i++)  {

                    MakeupT = *pByteTable & 0x80;
                    CodeT   = (WORD) *pByteTable & 0x3f;

                    if (MakeupT) {

                        if (CodeT < 28) {
                            RunLength += (CodeT << 6);

                            // sanity check

                            if (RunLength > LINE_LENGTH)  {
#ifdef RDEBUG
                                _tprintf( TEXT ("!!! ERROR MMR src codeT=%d, RunLength=%d\n "), a0, RunLength );
#endif
                                return FALSE;

                            }

#ifdef RDEBUG
                            if (Color) {
                                _tprintf( TEXT ("b%d "), (CodeT << 6)  );
                            }
                            else {
                                _tprintf( TEXT ("w%d "), (CodeT << 6)  );
                            }
#endif
                        }

                        else if (CodeT == NO_MORE_RECORDS) {
                            goto lNextIndexHoriz;
                        }

                        else  {
                            // ERROR: LOOK_FOR_EOL_CODE, EOL_FOUND_CODE, ERROR_CODE
#ifdef RDEBUG
                            _tprintf( TEXT ("\n!!! ERROR 2D dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

                            return FALSE;
                        }

                    }

                    else {  // terminating code
                        RunLength += CodeT;
                        *(pCurLine + (CIndex++) ) = RunLength;

                        // sanity check

                        if ( (RunLength > LINE_LENGTH) || ( CIndex >= MaxColorTransPerLine ) ) {
#ifdef RDEBUG
                            _tprintf( TEXT ("!!! ERROR MMR RunLength=%d, CodeT=%d, CIndex=%d\n "),
                                            RunLength, CodeT, CIndex );
#endif
                            return FALSE;

                        }


#ifdef RDEBUG
                        if (Color) {
                            _tprintf( TEXT ("b%d "), (CodeT)  );
                        }
                        else {
                            _tprintf( TEXT ("w%d "), (CodeT)  );
                        }
#endif
                        Color = 1 - Color;
                        if (++CountHoriz >= 2)  {
                            if (fFirstResult) {
                                bShift =  (*pByteTail & 0xf0) >> 4;
                            }
                            else {
                                // rare case will take time
                                bShift =  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 3 );
                                bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 4 );
                                bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 5 );
                                bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 6 );
                            }
                            goto lNextPrefix;
                        }
                    }

                    pByteTable++;

                }



lNextIndexHoriz:
                if (Color != CColor) {
                    fFirstResult = 0;
                }

                Table = Color ? TableBlack : TableWhite;
                TailT = *pByteTail & 0x0f;

                ResBit += TailT;

                if (ResBit > 31) {
                        lpdwResPtr++;
                        ResBit -= 32;
                }
            } while (lpdwResPtr <= EndPtr);

            return FALSE;




        }

        else if (iCode == PASS_PREFIX) {
#ifdef RDEBUG
            _tprintf( TEXT (" P ") );
#endif

            if ( (RunLength >= RValue) && (RunLength != 0) ) {
                while (++RIndex < MaxColorTransPerLine) {
                    if ( (RValue = *(pRefLine + RIndex) ) > RunLength )  {
                        goto lFound2;
                    }
                }

#ifdef RDEBUG
                _tprintf( TEXT ("!!! ERROR internal LOGIC RIndex=%d, RValue=%d, RunLength=%d\n "), RIndex, RValue, RunLength );
#endif
                //DebugBreak();
                return FALSE;



            }

lFound2:

            RColor = RIndex & 1;


            if (RValue != LINE_LENGTH) {
                RValue1 = *(pRefLine + RIndex + 1 );

                RColor1 = 1 - RColor;

                if ( (RValue1 != LINE_LENGTH) && (RColor1 == CColor) ) {
                    a0 = *(pRefLine + RIndex + 2);
                }
                else {
                    a0 = RValue1;
                }
            }
            else {
                a0 = LINE_LENGTH;
            }

#ifdef RDEBUG
            if (CColor) {
                _tprintf( TEXT ("b%d "), (a0 - RunLength) );
            }
            else {
                _tprintf( TEXT ("w%d "), (a0 - RunLength) );
            }
#endif

            // sanity check

            if ( (a0 < RunLength) || (a0 > LINE_LENGTH) ) {
#ifdef RDEBUG
                _tprintf( TEXT ("!!! ERROR MMR src a0=%d, RunLength=%d\n "), a0, RunLength );
#endif
                return FALSE;

            }

            RunLength = a0;

        }

        else if (iCode == LOOK_FOR_EOL_PREFIX) {
#ifdef RDEBUG
            // _tprintf( TEXT (" E ") );
#endif

            t1 = GetTickCount();
            tdelta = t1 - t0;

            // BUGBUG. In T.30 we send un-aligned RTC by request
            // so we shouldn't send it here. It also conflicts
            // with the filtering and expanding T.30 code

#if 0

            // EOL for the last line
            (*lpdwOut) += ( ((DWORD) (EOL_REVERSED_CODE)) << BitOut);
            if ( (BitOut = BitOut + EOL_LENGTH ) > 31 ) {
                BitOut -= 32;
                *(++lpdwOut) = ( (DWORD) (EOL_REVERSED_CODE) ) >> (EOL_LENGTH - BitOut);
            }

            // 6 1D-eols
            for (i=0; i<6; i++) {

                (*lpdwOut) += ( ((DWORD) (TAG_1D_EOL_REVERSED_CODE)) << BitOut);
                if ( (BitOut = BitOut + TAG_1D_EOL_LENGTH ) > 31 ) {
                    BitOut -= 32;
                    *(++lpdwOut) = ( (DWORD) (TAG_1D_EOL_REVERSED_CODE) ) >> (TAG_1D_EOL_LENGTH - BitOut);
                }
            }

            *(++lpdwOut) = 0;
#endif

            // BUGBUG  Use AlignEolTable[] here !
            // 1. Output EOL byte aligned for the last line.

            if (BitOut <= 4)  {
                *lpdwOut = *lpdwOut + 0x00008000;
                BitOut = 16;
            }
            else if (BitOut <= 12) {
                *lpdwOut = *lpdwOut + 0x00800000;
                BitOut = 24;
            }
            else if (BitOut <= 20) {
                *lpdwOut = *lpdwOut + 0x80000000;
                BitOut = 0;
                lpdwOut++;
            }
            else if (BitOut <= 28) {
                *(++lpdwOut) = 0x00000080;
                BitOut = 8;
            }
            else {
                *(++lpdwOut) = 0x00008000;
                BitOut = 16;
            }

            *lpdwSizeOutputBuffer = (DWORD)((lpdwOut - lpdwOutputBuffer) * sizeof (DWORD) + ( BitOut >> 3));

            return TRUE;
        }

        else { //ERROR
#ifdef RDEBUG
            _tprintf( TEXT ("\n!!! ERROR 2D PREFIX dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

            return FALSE;
        }

lNextPrefix:
        ResBit += bShift;
        if (ResBit > 31) {
            lpdwResPtr++;
            ResBit -= 32;
        }

    } while (lpdwResPtr <= EndPtr);

    return FALSE;


}






BOOL
ConvMmrPageHiResToMrLoRes(
    HANDLE              hTiff,
    LPDWORD             lpdwOutputBuffer,
    DWORD               *lpdwSizeOutputBuffer
    )


{

    PTIFF_INSTANCE_DATA TiffInstance = (PTIFF_INSTANCE_DATA) hTiff;
    DWORD               i;
    PBYTE               plinebuf;
    DWORD               lineWidth;
    DWORD               Lines;
    DWORD               State;
    DWORD               EolCount;
    BOOL                Color;
    LPDWORD             EndPtr;
    PBYTE               TableWhite = (PBYTE) GlobTableWhite;
    PBYTE               TableBlack = (PBYTE) GlobTableBlack;
    PBYTE               Table;
    PBYTE               pByteTable,  pByteTail;
    BYTE                MakeupT;
    WORD                CodeT;
    BYTE                TailT;
    WORD                RunLength=0;

    DWORD               TableSize=32768;
    DWORD               t0, t1, tdelta;

    WORD                LineMhArray[MaxColorTransPerLine];
    WORD                Line1Array[MaxColorTransPerLine];
    WORD                Line2Array[MaxColorTransPerLine];

    WORD                *pRefLine;
    WORD                *pCurLine;
    WORD                *pMhLine = LineMhArray;
    BYTE                CColor, RColor, RColor1;
    WORD                RIndex, CIndex;
    DWORD               dwIndex;
    WORD                a0;
    WORD                RValue, RValue1;
    LPDWORD             lpdwResPtr;
    BYTE                ResBit;
    short               iCode;
    BYTE                bShift;
    BYTE                CountHoriz;
    BOOL                fFirstResult;
    PBYTE               pByteTable0;

    WORD                PrevValue;
    WORD                CurValue;
    BOOL                CurColor;
    WORD                CurPos;
    WORD                CurRun;
    BYTE                BitOut;
    DWORD               *lpdwOut;
    PCODETABLE          pTableEntry;
    PCODETABLE          pCodeTable;

    BYTE                dwNewBitOut;
    LPDWORD             lpdwOutLimit;



    lpdwOutLimit = lpdwOutputBuffer + ( (*lpdwSizeOutputBuffer) >> 2 );


    // since we need to decode every src MMR line and encode to MR
    // dropping every other line, we will use 3 buffers to hold data
    // and we will NOT copy memory; just re-point to a right location.
    //
    // Action per (Lines%4) :
    //
    // 1 -> MH
    // 2 -> skip
    // 3 -> MR as a delta between last MH and Current lines.
    // 0 -> skip
    //


    // start Pointers


    pRefLine = Line1Array;
    pCurLine = LineMhArray;

    lpdwOut = lpdwOutputBuffer;
    BitOut = 0;

    ZeroMemory( (BYTE *) lpdwOutputBuffer, *lpdwSizeOutputBuffer );


    t0 = GetTickCount();

    Lines = 0;
    EolCount = 1;
    TiffInstance->Color = 0;
    TiffInstance->RunLength = 0;
    TiffInstance->StartGood = 0;
    TiffInstance->EndGood = 0;
    plinebuf = TiffInstance->StripData;
    lineWidth = TiffInstance->ImageWidth;



    EndPtr = (LPDWORD) ( (ULONG_PTR) (plinebuf+TiffInstance->StripDataSize-1) & ~(0x3) ) ;
    lpdwResPtr = (LPDWORD) (((ULONG_PTR) plinebuf) & ~(0x3) );
    ResBit =   (BYTE) (( ( (ULONG_PTR) plinebuf) & 0x3) << 3) ;



    // 2D line decode loop
    a0        = 0;
    CIndex    = 0;
    CColor    = 0;
    RunLength = 0;


    // first REF line is all white
    RIndex    = 1;
    *pRefLine = LINE_LENGTH;
    RValue    = LINE_LENGTH;
    RColor    = 0;


    //
    // prefix loop
    //

    do {


        if (RunLength == lineWidth) {

#ifdef RDEBUG
            _tprintf( TEXT(" EOL\n\n") );
#endif
            //
            // Output Dest Line
            //

            State = (++Lines) % 4;

            if (State == 2) {
                pRefLine = Line1Array;
                pCurLine = Line2Array;
                goto lSkipLoRes;
            }
            else if (State == 0) {
                pRefLine = Line1Array;
                pCurLine = LineMhArray;
                goto lSkipLoRes;
            }

            //
            // 1. Output Dest EOL byte aligned followed by a 1D/2D tag.
            //

            dwNewBitOut = AlignEolTable[ BitOut ];
            if (dwNewBitOut < BitOut) {
                lpdwOut++;
            }

            BitOut = dwNewBitOut;

            *lpdwOut += (0x00000001 << (BitOut++) );

            if (BitOut == 32) {
                BitOut = 0;
                lpdwOut++;
            }


            if (State == 1) {
                // 2. Output MH line based on Color Trans. Array

                *lpdwOut += (0x00000001 << (BitOut++));

                PrevValue  = 0;
                CurColor = WHITE_COLOR;

                for (CurPos=0;  CurPos < MaxColorTransPerLine; CurPos++) {

                    CurValue = *(pCurLine + CurPos);
                    CurRun   = CurValue - PrevValue;

                    pCodeTable = CurColor ? BlackRunCodesReversed : WhiteRunCodesReversed;

                    // output makeup code if exists
                    if (CurRun >= 64) {
                        pTableEntry = pCodeTable + (63 + (CurRun >> 6));

                        *lpdwOut = *lpdwOut + (((DWORD) (pTableEntry->code)) << BitOut);

                        if (BitOut + pTableEntry->length > 31)  {
                            *(++lpdwOut) = (((DWORD) (pTableEntry->code)) >> (32 - BitOut) );
                        }

                        BitOut += pTableEntry->length;
                        if (BitOut > 31) {
                            BitOut -= 32;
                        }

                        CurRun &= 0x3f;
                    }

                    // output terminating code always
                    pTableEntry = pCodeTable + CurRun;

                    *lpdwOut = *lpdwOut + (((DWORD) (pTableEntry->code)) << BitOut);

                    if (BitOut + pTableEntry->length > 31)  {
                        *(++lpdwOut) = (((DWORD) (pTableEntry->code)) >> (32 - BitOut) );
                    }

                    BitOut += pTableEntry->length;
                    if (BitOut > 31) {
                        BitOut -= 32;
                    }



                    if ( CurValue == LINE_LENGTH) {
                        break;
                    }

                    PrevValue = CurValue;
                    CurColor  = 1 - CurColor;

                }

                pRefLine = LineMhArray;
                pCurLine = Line1Array;

            }
            else {
                // 2. Output 2D line - MR(MhRefLine, CurLine)

                BitOut++;  // no need to test < 32 : never happens.

                if (! OutputMmrLine(lpdwOut, BitOut, pCurLine, pMhLine, &lpdwOut, &BitOut, lpdwOutLimit) ) {
                    return FALSE;
                }

                pRefLine = Line2Array;
                pCurLine = Line1Array;

            }

lSkipLoRes:
            // Next Src Line

            RIndex   =  0;
            RValue   =  *pRefLine;
            RColor   =  0;

            a0        = 0;
            CIndex    = 0;
            CColor    = 0;
            RunLength = 0;


        }

        if (ResBit <= 25 ) {
            dwIndex = (*lpdwResPtr) >> ResBit;
        }
        else {
            dwIndex = ( (*lpdwResPtr) >> ResBit ) + ( (*(lpdwResPtr+1)) << (32-ResBit) ) ;
        }

        dwIndex &= 0x0000007f;

        pByteTable = (BYTE *) (&PrefTable[dwIndex]);
        iCode = ( (short)  ((char) (*pByteTable)) ) >> 4;
        bShift = (*pByteTable) & 0x0f;

        if (iCode < 4) {
            // VERTICAL -3...+3
#ifdef RDEBUG
            _tprintf( TEXT (" V%2d "), iCode );
#endif

            if ( (RunLength >= RValue) && (RunLength != 0) ) {
                while (++RIndex < MaxColorTransPerLine) {
                    if ( (RValue = *(pRefLine + RIndex) ) > RunLength )  {
                        // BUGBUG will change to break; after debugging
                        goto lFound;
                    }
                }

#ifdef RDEBUG
                _tprintf( TEXT ("!!! ERROR internal LOGIC RIndex=%d, RValue=%d, RunLength=%d\n "), RIndex, RValue, RunLength );
#endif

                //DebugBreak();
                return FALSE;


lFound:
                RColor = RIndex & 1;
            }

            if (CColor == RColor)  {
                a0 = RValue + iCode;
            }
            else {
                if (RValue == LINE_LENGTH) {
                    a0 = RValue + iCode;
                }
                else {
                    a0 = *(pRefLine + RIndex + 1) + iCode;
                }
            }

            *(pCurLine + (CIndex++) ) = a0;

#ifdef RDEBUG
            if (CColor) {
                _tprintf( TEXT ("b%d "), (a0 - RunLength) );
            }
            else {
                _tprintf( TEXT ("w%d "), (a0 - RunLength) );
            }
#endif

            // sanity check

            if ( (a0 < RunLength) || (a0 > LINE_LENGTH) ) {
#ifdef RDEBUG
                _tprintf( TEXT ("!!! ERROR MMR src a0=%d, RunLength=%d\n "), a0, RunLength );
#endif
                return FALSE;

            }

            RunLength = a0;
            CColor = 1 - CColor;

        }

        else if (iCode == HORIZ_PREFIX) {
#ifdef RDEBUG
            _tprintf( TEXT (" H ") );
#endif


            ResBit += bShift;
            if (ResBit > 31) {
                ResBit -= 32;
                lpdwResPtr++;
            }


            Table = CColor ? TableBlack : TableWhite;
            Color = CColor;
            CountHoriz = 0;
            fFirstResult = 1;


            // 1-D Table look-up loop
            do {

                if (ResBit <= 17) {
                    dwIndex = (*lpdwResPtr) >> ResBit;
                }
                else {
                    dwIndex = ( (*lpdwResPtr) >> ResBit ) + ( (*(lpdwResPtr+1)) << (32-ResBit) ) ;
                }


                dwIndex &= 0x00007fff;

                pByteTable = Table + (5*dwIndex);
                pByteTail  = pByteTable+4;
                pByteTable0 = pByteTable;

                // All bytes

                for (i=0; i<4; i++)  {

                    MakeupT = *pByteTable & 0x80;
                    CodeT   = (WORD) *pByteTable & 0x3f;

                    if (MakeupT) {

                        if (CodeT < 28) {
                            RunLength += (CodeT << 6);

                            // sanity check

                            if (RunLength > LINE_LENGTH)  {
#ifdef RDEBUG
                                _tprintf( TEXT ("!!! ERROR MMR src codeT=%d, RunLength=%d\n "), a0, RunLength );
#endif
                                return FALSE;

                            }

#ifdef RDEBUG
                            if (Color) {
                                _tprintf( TEXT ("b%d "), (CodeT << 6)  );
                            }
                            else {
                                _tprintf( TEXT ("w%d "), (CodeT << 6)  );
                            }
#endif
                        }

                        else if (CodeT == NO_MORE_RECORDS) {
                            goto lNextIndexHoriz;
                        }

                        else  {
                            // ERROR: LOOK_FOR_EOL_CODE, EOL_FOUND_CODE, ERROR_CODE
#ifdef RDEBUG
                            _tprintf( TEXT ("\n!!! ERROR 2D dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif
                            return FALSE;
                        }

                    }

                    else {  // terminating code
                        RunLength += CodeT;
                        *(pCurLine + (CIndex++) ) = RunLength;

                        // sanity check

                        if ( (RunLength > LINE_LENGTH) || ( CIndex >= MaxColorTransPerLine ) ) {
#ifdef RDEBUG
                            _tprintf( TEXT ("!!! ERROR MMR RunLength=%d, CodeT=%d, CIndex=%d\n "),
                                            RunLength, CodeT, CIndex );
#endif
                            return FALSE;

                        }


#ifdef RDEBUG
                        if (Color) {
                            _tprintf( TEXT ("b%d "), (CodeT)  );
                        }
                        else {
                            _tprintf( TEXT ("w%d "), (CodeT)  );
                        }
#endif
                        Color = 1 - Color;
                        if (++CountHoriz >= 2)  {
                            if (fFirstResult) {
                                bShift =  (*pByteTail & 0xf0) >> 4;
                            }
                            else {
                                // rare case will take time
                                bShift =  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 3 );
                                bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 4 );
                                bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 5 );
                                bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 6 );
                            }
                            goto lNextPrefix;
                        }
                    }

                    pByteTable++;

                }



lNextIndexHoriz:
                if (Color != CColor) {
                    fFirstResult = 0;
                }

                Table = Color ? TableBlack : TableWhite;
                TailT = *pByteTail & 0x0f;

                ResBit += TailT;

                if (ResBit > 31) {
                        lpdwResPtr++;
                        ResBit -= 32;
                }
            } while (lpdwResPtr <= EndPtr);

            return FALSE;




        }

        else if (iCode == PASS_PREFIX) {
#ifdef RDEBUG
            _tprintf( TEXT (" P ") );
#endif

            if ( (RunLength >= RValue) && (RunLength != 0) ) {
                while (++RIndex < MaxColorTransPerLine) {
                    if ( (RValue = *(pRefLine + RIndex) ) > RunLength )  {
                        goto lFound2;
                    }
                }

#ifdef RDEBUG
                _tprintf( TEXT ("!!! ERROR internal LOGIC RIndex=%d, RValue=%d, RunLength=%d\n "), RIndex, RValue, RunLength );
#endif
                //DebugBreak();
                return FALSE;



            }

lFound2:

            RColor = RIndex & 1;


            if (RValue != LINE_LENGTH) {
                RValue1 = *(pRefLine + RIndex + 1 );

                RColor1 = 1 - RColor;

                if ( (RValue1 != LINE_LENGTH) && (RColor1 == CColor) ) {
                    a0 = *(pRefLine + RIndex + 2);
                }
                else {
                    a0 = RValue1;
                }
            }
            else {
                a0 = LINE_LENGTH;
            }



#ifdef RDEBUG
            if (CColor) {
                _tprintf( TEXT ("b%d "), (a0 - RunLength) );
            }
            else {
                _tprintf( TEXT ("w%d "), (a0 - RunLength) );
            }
#endif

            // sanity check

            if ( (a0 < RunLength) || (a0 > LINE_LENGTH) ) {
#ifdef RDEBUG
                _tprintf( TEXT ("!!! ERROR MMR src a0=%d, RunLength=%d\n "), a0, RunLength );
#endif
                return FALSE;

            }

            RunLength = a0;

        }

        else if (iCode == LOOK_FOR_EOL_PREFIX) {
#ifdef RDEBUG
            // _tprintf( TEXT (" E ") );
#endif

            t1 = GetTickCount();
            tdelta = t1 - t0;

            // BUGBUG. In T.30 we send un-aligned RTC by request
            // so we shouldn't send it here. It also conflicts
            // with the filtering and expanding T.30 code


#if 0

            // EOL for the last line
            (*lpdwOut) += ( ((DWORD) (EOL_REVERSED_CODE)) << BitOut);
            if ( (BitOut = BitOut + EOL_LENGTH ) > 31 ) {
                BitOut -= 32;
                *(++lpdwOut) = ( (DWORD) (EOL_REVERSED_CODE) ) >> (EOL_LENGTH - BitOut);
            }

            // 6 1D-eols
            for (i=0; i<6; i++) {

                (*lpdwOut) += ( ((DWORD) (TAG_1D_EOL_REVERSED_CODE)) << BitOut);
                if ( (BitOut = BitOut + TAG_1D_EOL_LENGTH ) > 31 ) {
                    BitOut -= 32;
                    *(++lpdwOut) = ( (DWORD) (TAG_1D_EOL_REVERSED_CODE) ) >> (TAG_1D_EOL_LENGTH - BitOut);
                }
            }


            *(++lpdwOut) = 0;
#endif

            // BUGBUG  Use AlignEolTable[] here !
            // 1. Output EOL byte aligned for the last line.

            if (BitOut <= 4)  {
                *lpdwOut = *lpdwOut + 0x00008000;
                BitOut = 16;
            }
            else if (BitOut <= 12) {
                *lpdwOut = *lpdwOut + 0x00800000;
                BitOut = 24;
            }
            else if (BitOut <= 20) {
                *lpdwOut = *lpdwOut + 0x80000000;
                BitOut = 0;
                lpdwOut++;
            }
            else if (BitOut <= 28) {
                *(++lpdwOut) = 0x00000080;
                BitOut = 8;
            }
            else {
                *(++lpdwOut) = 0x00008000;
                BitOut = 16;
            }

            *lpdwSizeOutputBuffer = (DWORD)((lpdwOut - lpdwOutputBuffer) * sizeof (DWORD) + ( BitOut >> 3));

            return TRUE;
        }

        else { //ERROR
#ifdef RDEBUG
            _tprintf( TEXT ("\n!!! ERROR 2D PREFIX dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

            return FALSE;
        }

lNextPrefix:
        ResBit += bShift;
        if (ResBit > 31) {
            lpdwResPtr++;
            ResBit -= 32;
        }

    } while (lpdwResPtr <= EndPtr);

    return FALSE;


}







BOOL
FindNextEol(
    LPDWORD     lpdwStartPtr,
    BYTE        StartBitInDword,
    LPDWORD     lpdwEndPtr,
    LPDWORD    *lpdwResPtr,
    BYTE       *ResBit,
    BOOL        fTestLength,
    BOOL       *fError
    )
{


    DWORD       *pdwCur;
    LPBYTE      lpbCur;
    LPBYTE      BegPtr;
    BYTE        BegFirst1;
    DWORD       deltaBytes;

    BYTE        temp;
    BYTE        StartBit;
    LPBYTE      StartPtr;


    *fError  = 0;
    temp     = StartBitInDword >> 3;
    StartBit = StartBitInDword - (temp << 3);
    StartPtr = ((BYTE *) lpdwStartPtr) + temp;
    lpbCur   = StartPtr+1;                  // EOL can't be at Start: it takes more than 1 byte.
    BegPtr   = StartPtr;


    BegFirst1 = First1[*StartPtr];
    if (BegFirst1 > StartBit) {
        if (fTestLength == DO_TEST_LENGTH) {
            // should not be "1" in same byte
            *fError = 1;
        }
    }
    else {
        BegFirst1 = StartBit;
    }

    // very often there are lots of zeroes, take care of them first.
    // 1. before actual start of encoded bitstream
    // 2. fills

    do {
        if ( *lpbCur == 0 )  {

            // align to DWORD
            while ( ((ULONG_PTR) lpbCur) & 3)  {
                if ( *lpbCur != 0  ||  ++lpbCur >= (BYTE *) lpdwEndPtr )   {
                    goto lNext;
                }
            }

            // DWORD stretch
            pdwCur = (DWORD *) lpbCur;

            do  {
                if ( *pdwCur != 0) {
                    lpbCur = (LPBYTE) pdwCur;

                    // find exactly first non-zero byte
                    while (*lpbCur == 0) {
                        lpbCur++;
                    }

                    goto lNext;
                }
            }  while (pdwCur++ < lpdwEndPtr);


            // rest- BYTE stretch
            lpbCur = (BYTE *) pdwCur;

            while (lpbCur++ <= (BYTE *) lpdwEndPtr)  {
                if ( *lpbCur != 0) {
                    goto lNext;
                }
            }

        }


lNext:
        if (lpbCur >= (BYTE *) lpdwEndPtr)  {
            if ( *lpbCur == 0 ) {
                return FALSE;
            }
        }


        deltaBytes = (DWORD)(lpbCur - BegPtr);

        *ResBit = Last1[*lpbCur];
        if ( (deltaBytes<<3) + (*ResBit - BegFirst1 ) >= 11 ) {
            *lpdwResPtr = (LPDWORD) ( ((ULONG_PTR) lpbCur) & ~(0x3) );
            *ResBit += ( (BYTE) (( ((ULONG_PTR) lpbCur) & 0x3) << 3 ) );

            // return Byte/Bit right after EOL bitstream
            if (++*ResBit > 31) {
                *ResBit -= 32;
                (*lpdwResPtr)++;
            }
            return TRUE;
        }
        // error for DO_TEST_LENGTH case
        else if (fTestLength == DO_TEST_LENGTH)  {
            *fError = 1;
        }

        BegPtr = lpbCur;
        BegFirst1 = First1[*lpbCur];

    } while ( (++lpbCur) <= (BYTE *) lpdwEndPtr);



    return FALSE;
}





BOOL
OutputMmrLine(
    LPDWORD     lpdwOut,
    BYTE        BitOut,
    WORD       *pCurLine,
    WORD       *pRefLine,
    LPDWORD    *lpdwResPtr,
    BYTE       *ResBit,
    LPDWORD     lpdwOutLimit
    )
{


    INT    a0, a1, a2, b1, b2, distance;
    INT    i;
    INT    IsA0Black;
    INT    a0Index = 0;
    INT    b1Index = 0;
    INT    lineWidth = LINE_LENGTH;



#ifdef RDEBUG
    if ( DebGlobOut )
    if (DebGlobOutColors == 1) {
        for (i=0; ;i++) {
            _tprintf( TEXT("%03d> %04d; "), i, *(pCurLine+i) );
            if ( *(pCurLine+i) >= lineWidth ) {
                break;
            }
        }
    }
#endif


    a0 = 0;

    // a1, b1 - 1st black
    a1 = *pCurLine;
    b1 = *pRefLine;



    while (TRUE) {

        if (lpdwOut >= lpdwOutLimit) {
            return FALSE;
        }

        b2 = (b1 >= lineWidth) ? lineWidth :  *(pRefLine + b1Index + 1);

        if (b2 < a1) {

            // Pass mode
            //OutputBits( TiffInstance, PASSCODE_LENGTH, PASSCODE );

#ifdef RDEBUG
            if ( DebGlobOut )
            if (DebGlobOutPrefix) {
                _tprintf( TEXT (" P ") );
                if (a0Index & 1) {
                    _tprintf( TEXT ("b%d "), (b2 - a0) );
                }
                else {
                    _tprintf( TEXT ("w%d "), (b2 - a0) );
                }
            }
#endif


            (*lpdwOut) += ( ((DWORD) (PASSCODE_REVERSED)) << BitOut);
            if ( (BitOut = BitOut + PASSCODE_LENGTH ) > 31 ) {
                BitOut -= 32;
                *(++lpdwOut) = ( (DWORD) (PASSCODE_REVERSED) ) >> (PASSCODE_LENGTH - BitOut);
            }

            a0 = b2;

        } else if ((distance = a1 - b1) <= 3 && distance >= -3) {

            // Vertical mode
            //OutputBits( TiffInstance, VertCodes[distance+3].length, VertCodes[distance+3].code );

#ifdef RDEBUG
            if ( DebGlobOut )
            if (DebGlobOutPrefix) {
                _tprintf( TEXT (" V%2d "), distance );
                if (a0Index & 1) {
                    _tprintf( TEXT ("b%d "), (a1 - a0) );
                }
                else {
                    _tprintf( TEXT ("w%d "), (a1 - a0) );
                }
            }

#endif

            (*lpdwOut) += ( ( (DWORD) VertCodesReversed[distance+3].code) << BitOut);
            if ( (BitOut = BitOut + VertCodesReversed[distance+3].length ) > 31 ) {
                BitOut -= 32;
                *(++lpdwOut) = ( (DWORD) (VertCodesReversed[distance+3].code) ) >> (VertCodesReversed[distance+3].length - BitOut);
            }

            a0 = a1;

        } else {

            // Horizontal mode

            a2 = (a1 >= lineWidth) ? lineWidth :  *(pCurLine + a0Index + 1);

            //OutputBits( TiffInstance, HORZCODE_LENGTH, HORZCODE );

            (*lpdwOut) += ( ((DWORD) (HORZCODE_REVERSED)) << BitOut);
            if ( (BitOut = BitOut + HORZCODE_LENGTH ) > 31 ) {
                BitOut -= 32;
                *(++lpdwOut) = ( (DWORD) (HORZCODE_REVERSED) ) >> (HORZCODE_LENGTH - BitOut);
            }


            for (i=a0Index; i<MaxColorTransPerLine; i++) {
                if ( *(pCurLine + i) > a0 ) {
                    a0Index = i;
                    IsA0Black = i & 1;
                    break;
                }
            }


#ifdef RDEBUG

            if ( DebGlobOut )
            if (DebGlobOutPrefix) {
                _tprintf( TEXT (" H ") );
            }


#endif

            if ( (a1 != 0) && IsA0Black ) {
                OutputRunFastReversed(a1-a0, BLACK, &lpdwOut, &BitOut);
                OutputRunFastReversed(a2-a1, WHITE, &lpdwOut, &BitOut);
            } else {
                OutputRunFastReversed(a1-a0, WHITE, &lpdwOut, &BitOut);
                OutputRunFastReversed(a2-a1, BLACK, &lpdwOut, &BitOut);
            }

            a0 = a2;
        }

        if (a0 >= lineWidth) {
            break;
        }



        // a1 = NextChangingElement( plinebuf, a0, lineWidth, GetBit( plinebuf, a0 ) );

        if (a0 == lineWidth) {
            a1 = a0;
        }
        else {
            while ( *(pCurLine + a0Index) <= a0 ) {
                a0Index++;
            }

            a1 =  *(pCurLine + a0Index);
        }


        // b1 = NextChangingElement( prefline, a0, lineWidth, !GetBit( plinebuf, a0 ) );
        // b1 = NextChangingElement( prefline, b1, lineWidth, GetBit( plinebuf, a0 ) );
        // another words - b1 should be a color trans. after a0 with opposite from SrcLine(a0) color.

        if (a0 == lineWidth) {
            b1 = a0;
        }
        else {
            // b1 can go one index backwards due to color change
            if (b1Index > 0) {
                b1Index--;
            }

            while ( *(pRefLine + b1Index) <= a0 ) {
                b1Index++;
            }

            b1 =  *(pRefLine + b1Index);

            if ( ( b1Index & 1 ) != (a0Index & 1) ) {
                if (b1 < lineWidth) {
                    b1 =  *(pRefLine + (++b1Index));
                }
            }

        }

    }
    *lpdwResPtr = lpdwOut;
    *ResBit = BitOut;
    return TRUE;
}







BOOL
ConvFileMhToMmr(
    LPTSTR              SrcFileName,
    LPTSTR              DestFileName
    )

{


    HANDLE      hTiffSrc;
    DWORD       CurrPage;
    LPBYTE      pSrcBits;

    HANDLE      hTiffDest;
    DWORD       DestSize;
    LPBYTE      pDestBits;


    DWORD       PageCnt;

    BOOL        bRet = FALSE;


    TIFF_INFO           TiffInfoSrc;
    LPDWORD             lpdwResPtr;
    BYTE                ResBit;
    LPDWORD             EndBuffer;
    BOOL                fTestLength;
    BOOL                fError;

    DWORD               *lpdwOutStart;
    DWORD               *lpdwOut;
    BYTE                BitOut;
    WORD                Line1Array[MaxColorTransPerLine];
    WORD                Line2Array[MaxColorTransPerLine];
    WORD                *pRefLine;
    WORD                *pCurLine;
    WORD                *pTmpSwap;

    DWORD               BufferSize;

    WORD                RIndex;
    WORD                CIndex;
    WORD                RValue;
    WORD                RunLength=0;
    DWORD               Lines;
    DWORD               EolCount;
    DWORD               BadFaxLines;
    BOOL                LastLineBad;
    DWORD               lineWidth;
    PBYTE               Table;
    PBYTE               TableWhite = (PBYTE) GlobTableWhite;
    PBYTE               TableBlack = (PBYTE) GlobTableBlack;
    BOOL                Color;
    DWORD               dwIndex;
    PBYTE               pByteTable;
    PBYTE               pByteTail;
    WORD                CodeT;
    BYTE                TailT;
    BYTE                MakeupT;
    DWORD               i;
    DWORD               ConsecBadLines=0;
    DWORD               AllowedBadFaxLines=5;
    DWORD               AllowedConsecBadLines=5;
    PTIFF_INSTANCE_DATA TiffInstanceDest;
    DWORD               DestHiRes;
    LPDWORD             lpdwOutLimit;

    // debugging

    DWORD               DbgLinesStop = 0;
    DWORD               DbgStopCnt = 0;







    CurrPage = 1;

    hTiffSrc = TiffOpen(
        SrcFileName,
        &TiffInfoSrc,
        TRUE,
        FILLORDER_LSB2MSB
        );
    if (! hTiffSrc) {
        return FALSE;
    }

    if (TiffInfoSrc.YResolution == 196) {
        DestHiRes = 1;
    }
    else {
        DestHiRes = 0;
    }


    hTiffDest = TiffCreate(
        DestFileName,
        TIFF_COMPRESSION_MMR,
        1728,
        FILLORDER_LSB2MSB,
        DestHiRes);

    if (! hTiffDest) {
        TiffClose(hTiffSrc);
        return FALSE;
    }

    TiffInstanceDest = (PTIFF_INSTANCE_DATA) hTiffDest;


    pSrcBits = (LPBYTE) VirtualAlloc(
        NULL,
        TiffInfoSrc.ImageHeight * (TiffInfoSrc.ImageWidth / 8),
        MEM_COMMIT,
        PAGE_READWRITE
        );
    if (!pSrcBits) {
        TiffClose(hTiffSrc);
        TiffClose(hTiffDest);
        return FALSE;
    }


    pDestBits = (LPBYTE) VirtualAlloc(
        NULL,
        TiffInfoSrc.ImageHeight * (TiffInfoSrc.ImageWidth / 8),
        MEM_COMMIT,
        PAGE_READWRITE
        );
    if (!pDestBits) {
        TiffClose(hTiffSrc);
        TiffClose(hTiffDest);
        VirtualFree ( pSrcBits, 0 , MEM_RELEASE );
        return FALSE;
    }



    for (PageCnt=0; PageCnt<TiffInfoSrc.PageCount; PageCnt++) {

        if ( ! TiffSeekToPage( hTiffSrc, PageCnt+1, FILLORDER_LSB2MSB) ) {
            goto l_exit;
        }

        if (! TiffStartPage(hTiffDest) ) {
            goto l_exit;
        }

        // here we decode MH page line by line into Color Trans. Array
        // fix all the errors
        // and encode clean data into MMR page

        lpdwResPtr = (LPDWORD) ( (ULONG_PTR) pSrcBits & ~(0x3) );

        BufferSize = TiffInfoSrc.ImageHeight * (TiffInfoSrc.ImageWidth / 8);
        if (!GetTiffBits(hTiffSrc, (LPBYTE) lpdwResPtr, &BufferSize, FILLORDER_LSB2MSB) ) {
            goto l_exit;
        }

        ResBit = 0;
        EndBuffer = lpdwResPtr + (BufferSize / sizeof(DWORD) );

        pRefLine = Line1Array;
        pCurLine = Line2Array;
        lpdwOutStart = lpdwOut = (LPDWORD) ( (ULONG_PTR) pDestBits & ~(0x3) );
        lpdwOutLimit = lpdwOutStart + ( (TiffInfoSrc.ImageHeight * (TiffInfoSrc.ImageWidth / 8) ) >> 2 );

        BitOut = 0;
        ZeroMemory( (BYTE *) lpdwOut, TiffInfoSrc.ImageHeight * (TiffInfoSrc.ImageWidth / 8) );

        CIndex    = 0;
        RunLength = 0;


        // first REF line is all white
        RIndex    = 1;
        *pRefLine = LINE_LENGTH;
        RValue    = LINE_LENGTH;



        Lines = 0;
        EolCount = 1;
        BadFaxLines = 0;
        LastLineBad = FALSE;
        fTestLength = DO_NOT_TEST_LENGTH;
        lineWidth = LINE_LENGTH;


        //
        // find first EOL in a block
        //

        if (! FindNextEol (lpdwResPtr, ResBit, EndBuffer, &lpdwResPtr, &ResBit, fTestLength, &fError) ) {

            goto bad_exit;
        }

        // output first "all white" line
        CIndex    = 1;
        *pCurLine = LINE_LENGTH;

        if (! OutputMmrLine(lpdwOut, BitOut, pCurLine, pRefLine, &lpdwOut, &BitOut, lpdwOutLimit) ) {
            goto bad_exit;
        }


        RIndex = CIndex;
        CIndex = 0;
        Lines++;

        Table = TableWhite;
        Color = WHITE_COLOR;

        //
        // EOL loop
        //
        do {

            // Table look-up loop
            do {

                if (Lines == DbgLinesStop) {
                    DbgStopCnt++;
                }

                if (ResBit <= 17) {
                    dwIndex = (*lpdwResPtr) >> ResBit;
                }
                else {
                    dwIndex = ( (*lpdwResPtr) >> ResBit ) + ( (*(lpdwResPtr+1)) << (32-ResBit) ) ;
                }

                dwIndex &= 0x00007fff;

                pByteTable = Table + (5*dwIndex);
                pByteTail  = pByteTable+4;


                for (i=0; i<4; i++) {

                    MakeupT = *pByteTable & 0x80;
                    CodeT   = (WORD) *pByteTable & 0x3f;

                    if (MakeupT) {

                        if (CodeT < 28) {
                            RunLength += (CodeT << 6);

                            if (RunLength > lineWidth) {
                                fTestLength =  DO_NOT_TEST_LENGTH;
                                goto lFindNextEOL;
                            }

                            EolCount=0;
#ifdef RDEBUGS
                            if (DebGlobOutS)
                            if (Color) {
                                _tprintf( TEXT ("b%d "), (CodeT << 6)  );
                            }
                            else {
                                _tprintf( TEXT ("w%d "), (CodeT << 6)  );
                            }
#endif
                        }

                        else if (CodeT == NO_MORE_RECORDS) {
                            goto lNextIndex;
                        }

                        else if (CodeT == LOOK_FOR_EOL_CODE)  {
                            fTestLength =  DO_TEST_LENGTH;
                            TailT = *pByteTail & 0x0f;

                            ResBit += TailT;

                            if (ResBit > 31) {
                                    lpdwResPtr++;
                                    ResBit -= 32;
                            }

                            goto lFindNextEOL;
                        }

                        else if (CodeT == EOL_FOUND_CODE) {
#ifdef RDEBUG
                            _tprintf( TEXT(" EOL Line=%d\n\n"), Lines );
#endif
                            if ( RunLength != lineWidth ) {
                                if (RunLength != 0) {
                                    BadFaxLines++;
                                   if (LastLineBad) {
                                        ConsecBadLines++;
                                    }

                                    if (BadFaxLines > AllowedBadFaxLines ||
                                        ConsecBadLines > AllowedConsecBadLines) {

                                            goto bad_exit;
                                    }
                                }
                                else {
                                    // RunLength is 0
                                    EolCount++;

                                    if (EolCount >= 5)  {

                                        goto good_exit;
                                    }

                                }
                            }
                            else {
                                LastLineBad = FALSE;
                                ConsecBadLines = 0;

                                // end of a good line.
                                if (! OutputMmrLine(lpdwOut, BitOut, pCurLine, pRefLine, &lpdwOut, &BitOut, lpdwOutLimit) ) {
                                    goto bad_exit;
                                }

                                pTmpSwap = pRefLine;
                                pRefLine = pCurLine;
                                pCurLine = pTmpSwap;
                                RIndex = CIndex;
                                CIndex = 0;


                            }


                            Lines++;
                            RunLength = 0;

                            Table = TableWhite;
                            Color = WHITE_COLOR;
                        }

                        else if (CodeT == ERROR_CODE) {
                            BadFaxLines++;
                            if (LastLineBad) {
                                ConsecBadLines++;
                            }

                            if (BadFaxLines > AllowedBadFaxLines ||
                                ConsecBadLines > AllowedConsecBadLines) {

                                    goto bad_exit;
                            }

                            fTestLength =  DO_NOT_TEST_LENGTH;
                            goto lFindNextEOL;
                        }
                        else {
#ifdef RDEBUG
                            _tprintf( TEXT("ERROR: WRONG code: index=%04x\n"), dwIndex);
#endif


                            //DebugBreak();
                            goto bad_exit;
                        }
                    }

                    else {  // terminating code
                        RunLength += CodeT;
                        if (RunLength > lineWidth) {
                            fTestLength =  DO_NOT_TEST_LENGTH;
                            goto lFindNextEOL;
                        }

                        *(pCurLine + (CIndex++) ) = RunLength;

                        if (CIndex >= MaxColorTransPerLine ) {
                            fTestLength =  DO_NOT_TEST_LENGTH;
                            goto lFindNextEOL;
                        }


                        EolCount=0;

#ifdef RDEBUGS
                        if (DebGlobOutS)
                        if (Color) {
                            _tprintf( TEXT ("b%d "), (CodeT)  );
                        }
                        else {
                            _tprintf( TEXT ("w%d "), (CodeT)  );
                        }
#endif
                        Color = 1 - Color;
                    }

                    pByteTable++;
                }


lNextIndex:
                Table = Color ? TableBlack : TableWhite;
                TailT = *pByteTail & 0x0f;

                ResBit += TailT;

                if (ResBit > 31) {
                        lpdwResPtr++;
                        ResBit -= 32;
                }
            } while (lpdwResPtr <= EndBuffer);

            // if we got here it means that line is longer than 4K.

            goto bad_exit;


lFindNextEOL:

#ifdef RDEBUG
            _tprintf( TEXT(" EOL Line=%d\n\n"), Lines );
#endif

            if (RunLength != lineWidth) {
                if (RunLength != 0) {
                    BadFaxLines++;
                    if (LastLineBad) {
                        ConsecBadLines++;
                    }

                    if (BadFaxLines > AllowedBadFaxLines ||
                        ConsecBadLines > AllowedConsecBadLines) {

                            goto bad_exit;
                    }
                }
                else {
                    // RunLength is 0
                    EolCount++;

                    if (EolCount >= 5)  {

                        goto good_exit;
                    }

                }
            }
            else {
                Lines++;
                ConsecBadLines=0;

                if (! OutputMmrLine(lpdwOut, BitOut, pCurLine, pRefLine, &lpdwOut, &BitOut, lpdwOutLimit) ) {
                    goto bad_exit;
                }

                pTmpSwap = pRefLine;
                pRefLine = pCurLine;
                pCurLine = pTmpSwap;
                RIndex = CIndex;
                CIndex = 0;


            }

            RunLength = 0;

            if (! FindNextEol (lpdwResPtr, ResBit, EndBuffer, &lpdwResPtr, &ResBit, fTestLength, &fError) ) {

                goto bad_exit;
            }

            if (fTestLength == DO_TEST_LENGTH && fError) {
                BadFaxLines++;
                if (LastLineBad) {
                    ConsecBadLines++;
                }

                if (BadFaxLines > AllowedBadFaxLines ||
                    ConsecBadLines > AllowedConsecBadLines) {

                        goto bad_exit;
                }
            }

            Table = TableWhite;
            Color = WHITE_COLOR;


        } while (lpdwResPtr <= EndBuffer);


        goto bad_exit;


bad_exit:


good_exit:

        *(++lpdwOut) = 0x80000000;
        *(++lpdwOut) = 0x80000000;
        Lines--;

        DestSize = (DWORD)((lpdwOut - lpdwOutStart) * sizeof (DWORD));
        if (! TiffWriteRaw( hTiffDest, (LPBYTE) lpdwOutStart, DestSize) ) {
            goto l_exit;
        }

        TiffInstanceDest->Lines        = Lines;

        if (! TiffEndPage(hTiffDest) ) {
            goto l_exit;
        }

    }

    bRet = TRUE;

l_exit:


    VirtualFree ( pSrcBits, 0 , MEM_RELEASE );
    VirtualFree ( pDestBits, 0 , MEM_RELEASE );

    TiffClose(hTiffSrc);
    TiffClose(hTiffDest);

    return bRet;




}



BOOL
TiffPostProcessFast(
    LPTSTR SrcFileName,
    LPTSTR DstFileName
    )

/*++

Routine Description:

    Opens an existing TIFF file for reading.

Arguments:

    FileName            - Full or partial path/file name

Return Value:

    TRUE for success, FALSE for failure.

--*/

{
    PTIFF_INSTANCE_DATA TiffInstance;
    TIFF_INFO TiffInfo;


    TiffInstance = (PTIFF_INSTANCE_DATA) TiffOpen(
        SrcFileName,
        &TiffInfo,
        FALSE,
        FILLORDER_LSB2MSB
        );

    if (!TiffInstance) {
        return FALSE;
    }

    if (TiffInstance->ImageHeight) {
        TiffClose( (HANDLE) TiffInstance );
        return TRUE;
    }

    switch( TiffInstance->CompressionType ) {


        case TIFF_COMPRESSION_MH:

            if (!PostProcessMhToMmr( (HANDLE) TiffInstance, TiffInfo, DstFileName )) {
                return FALSE;
            }

            break;

        case TIFF_COMPRESSION_MR:
            if (!PostProcessMrToMmr( (HANDLE) TiffInstance, TiffInfo, DstFileName )) {
                return FALSE;
            }

            break;
    }


    return TRUE;
}



//#define RDEBUG  1
//#define RDEBUGS  1

BOOL
PostProcessMhToMmr(
    HANDLE      hTiffSrc,
    TIFF_INFO   TiffInfoSrc,
    LPTSTR      NewFileName
    )

{
    PTIFF_INSTANCE_DATA TiffInstance = (PTIFF_INSTANCE_DATA) hTiffSrc;

    TCHAR       DestFileName[MAX_PATH];
    TCHAR       SrcFileName[MAX_PATH];
    DWORD       CurrPage;
    LPBYTE      pSrcBits;

    HANDLE      hTiffDest;
    DWORD       DestSize;
    LPBYTE      pDestBits;


    DWORD       PageCnt;

    BOOL        bRet = FALSE;


    LPDWORD             lpdwResPtr;
    BYTE                ResBit;
    LPDWORD             EndBuffer;
    BOOL                fTestLength;
    BOOL                fError;

    DWORD               *lpdwOutStart;
    DWORD               *lpdwOut;
    BYTE                BitOut;
    WORD                Line1Array[MaxColorTransPerLine];
    WORD                Line2Array[MaxColorTransPerLine];
    WORD                *pRefLine;
    WORD                *pCurLine;
    WORD                *pTmpSwap;

    DWORD               BufferSize;
    DWORD               BufferUsedSize;

    DWORD               DestBufferSize;

    WORD                RIndex;
    WORD                CIndex;
    WORD                RValue;
    WORD                RunLength=0;
    DWORD               Lines;
    DWORD               EolCount;
    DWORD               BadFaxLines=0;
    BOOL                LastLineBad;
    DWORD               lineWidth;
    PBYTE               Table;
    PBYTE               TableWhite = (PBYTE) GlobTableWhite;
    PBYTE               TableBlack = (PBYTE) GlobTableBlack;
    BOOL                Color;
    DWORD               dwIndex;
    PBYTE               pByteTable;
    PBYTE               pByteTail;
    WORD                CodeT;
    BYTE                TailT;
    BYTE                MakeupT;
    DWORD               i;
    DWORD               ConsecBadLines=0;
    DWORD               AllowedBadFaxLines=200;    // since it was ACK by T.30 we don't care much here.
    DWORD               AllowedConsecBadLines=200;
    PTIFF_INSTANCE_DATA TiffInstanceDest;
    DWORD               MaxImageHeight=2400;
    DWORD               DestHiRes;
    LPDWORD             lpdwOutLimit;

    // debugging

    DWORD               DbgLinesStop = 0;
    DWORD               DbgStopCnt = 0;

    //
    // Build Dest. file name from Src. file name
    //

    if (NewFileName == NULL) {
        _tcscpy(DestFileName, TiffInstance->FileName);
        DestFileName[_tcslen(DestFileName) - 1] = TEXT('$');
    } else {
        _tcscpy(DestFileName, NewFileName);
    }

    _tcscpy(SrcFileName, TiffInstance->FileName);
    
    CurrPage = 1;

    if (TiffInfoSrc.YResolution == 196) {
        DestHiRes = 1;
    }
    else {
        DestHiRes = 0;
    }

    hTiffDest = TiffCreate(
        DestFileName,
        TIFF_COMPRESSION_MMR,
        1728,
        FILLORDER_LSB2MSB,
        DestHiRes
        );
    if (! hTiffDest) {
        TiffClose(hTiffSrc);
        return FALSE;
    }

    TiffInstanceDest = (PTIFF_INSTANCE_DATA) hTiffDest;

    BufferSize = MaxImageHeight * (TiffInfoSrc.ImageWidth / 8);

    DestBufferSize = BufferSize + 200000;

    pSrcBits = (LPBYTE) VirtualAlloc(
        NULL,
        BufferSize,
        MEM_COMMIT,
        PAGE_READWRITE
        );
    if (!pSrcBits) {
        TiffClose(hTiffSrc);
        TiffClose(hTiffDest);
        return FALSE;
    }

    pDestBits = (LPBYTE) VirtualAlloc(
        NULL,
        DestBufferSize,
        MEM_COMMIT,
        PAGE_READWRITE
        );
    if (!pDestBits) {
        TiffClose(hTiffSrc);
        TiffClose(hTiffDest);
        VirtualFree ( pSrcBits, 0 , MEM_RELEASE );
        return FALSE;
    }

    for (PageCnt=0; PageCnt<TiffInfoSrc.PageCount; PageCnt++) {

        if ( ! TiffSeekToPage( hTiffSrc, PageCnt+1, FILLORDER_LSB2MSB) ) {
            goto bad_exit;
        }

        if (! TiffStartPage(hTiffDest) ) {
            goto bad_exit;
        }

        // here we decode MH page line by line into Color Trans. Array
        // fix all the errors
        // and encode clean data into MMR page

        lpdwResPtr = (LPDWORD) ( (ULONG_PTR) pSrcBits & ~(0x3) );

        BufferUsedSize = BufferSize;

        if (!GetTiffBits(hTiffSrc, (LPBYTE)lpdwResPtr, &BufferUsedSize, FILLORDER_LSB2MSB) ) {

            if (BufferUsedSize > BufferSize) {
                VirtualFree ( pSrcBits, 0 , MEM_RELEASE );
                VirtualFree ( pDestBits, 0 , MEM_RELEASE );

                BufferSize = BufferUsedSize;
                DestBufferSize = BufferSize + 200000;

                pSrcBits = (LPBYTE) VirtualAlloc(
                    NULL,
                    BufferSize,
                    MEM_COMMIT,
                    PAGE_READWRITE
                    );

                if (! pSrcBits) {
                    TiffClose(hTiffSrc);
                    TiffClose(hTiffDest);
                    DeleteFile(DestFileName);
                    return FALSE;
                }

                pDestBits = (LPBYTE) VirtualAlloc(
                    NULL,
                    DestBufferSize,
                    MEM_COMMIT,
                    PAGE_READWRITE
                    );

                if (! pDestBits) {
                    VirtualFree ( pSrcBits, 0 , MEM_RELEASE );
                    TiffClose(hTiffSrc);
                    TiffClose(hTiffDest);
                    DeleteFile(DestFileName);
                    return FALSE;
                }

                lpdwResPtr = (LPDWORD) ( (ULONG_PTR) pSrcBits & ~(0x3) );

                if (!GetTiffBits(hTiffSrc, (LPBYTE)lpdwResPtr, &BufferUsedSize, FILLORDER_LSB2MSB) ) {
                    goto bad_exit;
                }
            }
            else {
                goto bad_exit;
            }
        }

        ResBit = 0;
        EndBuffer = lpdwResPtr + (BufferUsedSize / sizeof(DWORD) );

        pRefLine = Line1Array;
        pCurLine = Line2Array;
        lpdwOutStart = lpdwOut = (LPDWORD) ( (ULONG_PTR) pDestBits & ~(0x3) );
        lpdwOutLimit = lpdwOutStart + ( DestBufferSize >> 2 );

        BitOut = 0;
        ZeroMemory( (BYTE *) lpdwOut, DestBufferSize );

        CIndex    = 0;
        RunLength = 0;


        // first REF line is all white
        RIndex    = 1;
        *pRefLine = LINE_LENGTH;
        RValue    = LINE_LENGTH;



        Lines = 0;
        EolCount = 1;
        BadFaxLines = 0;
        LastLineBad = FALSE;
        fTestLength = DO_NOT_TEST_LENGTH;
        lineWidth = LINE_LENGTH;


        //
        // find first EOL in a block
        //

        if (! FindNextEol (lpdwResPtr, ResBit, EndBuffer, &lpdwResPtr, &ResBit, fTestLength, &fError) ) {

            goto bad_exit;
        }

        // output first "all white" line
        CIndex    = 1;
        *pCurLine = LINE_LENGTH;

        if (! OutputMmrLine(lpdwOut, BitOut, pCurLine, pRefLine, &lpdwOut, &BitOut, lpdwOutLimit) ) {
            goto bad_exit;
        }


        RIndex = CIndex;
        CIndex = 0;
        Lines++;

        Table = TableWhite;
        Color = WHITE_COLOR;

        //
        // EOL loop
        //
        do {

            // Table look-up loop
            do {

                if (Lines == DbgLinesStop) {
                    DbgStopCnt++;
                }

                if (ResBit <= 17) {
                    dwIndex = (*lpdwResPtr) >> ResBit;
                }
                else {
                    dwIndex = ( (*lpdwResPtr) >> ResBit ) + ( (*(lpdwResPtr+1)) << (32-ResBit) ) ;
                }

                dwIndex &= 0x00007fff;

                pByteTable = Table + (5*dwIndex);
                pByteTail  = pByteTable+4;


                for (i=0; i<4; i++) {

                    MakeupT = *pByteTable & 0x80;
                    CodeT   = (WORD) *pByteTable & 0x3f;

                    if (MakeupT) {

                        if (CodeT < 28) {
                            RunLength += (CodeT << 6);

                            if (RunLength > lineWidth) {
                                fTestLength =  DO_NOT_TEST_LENGTH;
                                goto lFindNextEOL;
                            }

                            EolCount=0;
#ifdef RDEBUGS

                            if (DebGlobOutS)
                            if (Color) {
                                _tprintf( TEXT ("b%d "), (CodeT << 6)  );
                            }
                            else {
                                _tprintf( TEXT ("w%d "), (CodeT << 6)  );
                            }
#endif
                        }

                        else if (CodeT == NO_MORE_RECORDS) {
                            goto lNextIndex;
                        }

                        else if (CodeT == LOOK_FOR_EOL_CODE)  {
                            fTestLength =  DO_TEST_LENGTH;
                            TailT = *pByteTail & 0x0f;

                            ResBit += TailT;

                            if (ResBit > 31) {
                                    lpdwResPtr++;
                                    ResBit -= 32;
                            }

                            goto lFindNextEOL;
                        }

                        else if (CodeT == EOL_FOUND_CODE) {
#ifdef RDEBUG
                            _tprintf( TEXT(" EOL Line=%d\n\n"), Lines );
#endif
                            if ( RunLength != lineWidth ) {
                                if (RunLength != 0) {
                                    BadFaxLines++;
                                   if (LastLineBad) {
                                        ConsecBadLines++;
                                    }

                                    if (BadFaxLines > AllowedBadFaxLines ||
                                        ConsecBadLines > AllowedConsecBadLines) {

                                            goto bad_exit;
                                    }
                                }
                                else {
                                    // RunLength is 0
                                    EolCount++;

                                    if (EolCount >= 5)  {

                                        goto good_exit;
                                    }

                                }
                            }
                            else {
                                LastLineBad = FALSE;
                                ConsecBadLines = 0;

                                // end of a good line.
                                if (! OutputMmrLine(lpdwOut, BitOut, pCurLine, pRefLine, &lpdwOut, &BitOut, lpdwOutLimit) ) {
                                    goto bad_exit;
                                }

                                pTmpSwap = pRefLine;
                                pRefLine = pCurLine;
                                pCurLine = pTmpSwap;
                                RIndex = CIndex;
                                Lines++;

                            }


                            CIndex = 0;
                            RunLength = 0;

                            Table = TableWhite;
                            Color = WHITE_COLOR;
                        }

                        else if (CodeT == ERROR_CODE) {
                            BadFaxLines++;
                            if (LastLineBad) {
                                ConsecBadLines++;
                            }

                            if (BadFaxLines > AllowedBadFaxLines ||
                                ConsecBadLines > AllowedConsecBadLines) {

                                    goto bad_exit;
                            }

                            fTestLength =  DO_NOT_TEST_LENGTH;
                            goto lFindNextEOL;
                        }
                        else {
#ifdef RDEBUG
                            _tprintf( TEXT("ERROR: WRONG code: index=%04x\n"), dwIndex);
#endif



                            goto bad_exit;
                        }
                    }

                    else {  // terminating code
                        RunLength += CodeT;
                        if (RunLength > lineWidth) {
                            fTestLength =  DO_NOT_TEST_LENGTH;
                            goto lFindNextEOL;
                        }

                        *(pCurLine + (CIndex++) ) = RunLength;

                        if (CIndex >= MaxColorTransPerLine ) {
                            fTestLength =  DO_NOT_TEST_LENGTH;
                            goto lFindNextEOL;
                        }


                        EolCount=0;

#ifdef RDEBUGS
                        if (DebGlobOutS)

                        if (Color) {
                            _tprintf( TEXT ("b%d "), (CodeT)  );
                        }
                        else {
                            _tprintf( TEXT ("w%d "), (CodeT)  );
                        }
#endif
                        Color = 1 - Color;
                    }

                    pByteTable++;
                }


lNextIndex:
                Table = Color ? TableBlack : TableWhite;
                TailT = *pByteTail & 0x0f;

                ResBit += TailT;

                if (ResBit > 31) {
                        lpdwResPtr++;
                        ResBit -= 32;
                }
            } while (lpdwResPtr <= EndBuffer);

            // if we got here it means that line is longer than 4K  OR
            // we missed EOF while decoding a BAD line.

            BadFaxLines++;
            if (LastLineBad) {
                ConsecBadLines++;
            }

            if (BadFaxLines > AllowedBadFaxLines ||
                ConsecBadLines > AllowedConsecBadLines ||
                Lines < MIN_GOOD_LINES) {

                    goto bad_exit;
            }

            goto good_exit;


lFindNextEOL:

#ifdef RDEBUG
            _tprintf( TEXT(" EOL Line=%d\n\n"), Lines );
#endif

            if (RunLength != lineWidth) {
                if (RunLength != 0) {
                    BadFaxLines++;
                    if (LastLineBad) {
                        ConsecBadLines++;
                    }

                    if (BadFaxLines > AllowedBadFaxLines ||
                        ConsecBadLines > AllowedConsecBadLines) {

                            goto bad_exit;
                    }
                }
                else {
                    // RunLength is 0
                    EolCount++;

                    if (EolCount >= 5)  {

                        goto good_exit;
                    }

                }
            }
            else {
                Lines++;
                ConsecBadLines=0;

                if (! OutputMmrLine(lpdwOut, BitOut, pCurLine, pRefLine, &lpdwOut, &BitOut, lpdwOutLimit) ) {
                    goto bad_exit;
                }

                pTmpSwap = pRefLine;
                pRefLine = pCurLine;
                pCurLine = pTmpSwap;
                RIndex = CIndex;

            }

            CIndex = 0;
            RunLength = 0;

            if (! FindNextEol (lpdwResPtr, ResBit, EndBuffer, &lpdwResPtr, &ResBit, fTestLength, &fError) ) {

                BadFaxLines++;
                if (LastLineBad) {
                    ConsecBadLines++;
                }

                if (BadFaxLines > AllowedBadFaxLines ||
                    ConsecBadLines > AllowedConsecBadLines ||
                    Lines < MIN_GOOD_LINES) {

                        goto bad_exit;
                }

                goto good_exit;
            }

            if (fTestLength == DO_TEST_LENGTH && fError) {
                BadFaxLines++;
                if (LastLineBad) {
                    ConsecBadLines++;
                }

                if (BadFaxLines > AllowedBadFaxLines ||
                    ConsecBadLines > AllowedConsecBadLines) {

                        goto bad_exit;
                }
            }

            Table = TableWhite;
            Color = WHITE_COLOR;


        } while (lpdwResPtr <= EndBuffer);

        BadFaxLines++;
        if (LastLineBad) {
            ConsecBadLines++;
        }

        if (BadFaxLines > AllowedBadFaxLines ||
            ConsecBadLines > AllowedConsecBadLines ||
            Lines < MIN_GOOD_LINES) {

                goto bad_exit;
        }



good_exit:

        *(++lpdwOut) = 0x80000000;
        *(++lpdwOut) = 0x80000000;
        Lines--;

        DestSize = (DWORD)((lpdwOut - lpdwOutStart) * sizeof (DWORD));
        if (! TiffWriteRaw( hTiffDest, (LPBYTE) lpdwOutStart, DestSize) ) {
            goto bad_exit;
        }

        TiffInstanceDest->Lines        = Lines;

        if (! TiffEndPage(hTiffDest) ) {
            goto bad_exit;
        }

    }

    bRet = TRUE;

bad_exit:

    VirtualFree ( pSrcBits, 0 , MEM_RELEASE );
    VirtualFree ( pDestBits, 0 , MEM_RELEASE );

    TiffClose(hTiffSrc);
    TiffClose(hTiffDest);

    if (bRet == TRUE && NewFileName == NULL) {
        // replace the original MH file by the new clean MMR file
        DeleteFile(SrcFileName);
        MoveFile(DestFileName, SrcFileName);
    }

    return bRet;
}


BOOL
PostProcessMrToMmr(
    HANDLE      hTiffSrc,
    TIFF_INFO   TiffInfoSrc,
    LPTSTR      NewFileName
    )

{

    PTIFF_INSTANCE_DATA TiffInstance = (PTIFF_INSTANCE_DATA) hTiffSrc;
    
    TCHAR       DestFileName[MAX_PATH];
    TCHAR       SrcFileName[MAX_PATH];
    DWORD       CurrPage;
    LPBYTE      pSrcBits;
    HANDLE      hTiffDest;
    DWORD       DestSize;
    LPBYTE      pDestBits;
    DWORD       PageCnt;
    BOOL        bRet = FALSE;

    LPDWORD             lpdwResPtr;
    BYTE                ResBit;
    LPDWORD             EndBuffer;
    BOOL                fTestLength;
    BOOL                fError;

    DWORD               *lpdwOutStart;
    DWORD               *lpdwOut;
    BYTE                BitOut;
    WORD                Line1Array[MaxColorTransPerLine];
    WORD                Line2Array[MaxColorTransPerLine];
    WORD                *pRefLine;
    WORD                *pCurLine;
    WORD                *pTmpSwap;

    DWORD               BufferSize;
    DWORD               BufferUsedSize;

    DWORD               DestBufferSize;

    WORD                RIndex;
    WORD                CIndex;
    WORD                RValue;
    WORD                RunLength=0;
    DWORD               Lines;
    DWORD               EolCount;
    DWORD               BadFaxLines;
    BOOL                LastLineBad;
    DWORD               lineWidth;
    PBYTE               Table;
    PBYTE               TableWhite = (PBYTE) GlobTableWhite;
    PBYTE               TableBlack = (PBYTE) GlobTableBlack;
    BOOL                Color;
    DWORD               dwIndex;
    PBYTE               pByteTable;
    PBYTE               pByteTail;
    WORD                CodeT;
    BYTE                TailT;
    BYTE                MakeupT;
    DWORD               i;
    DWORD               ConsecBadLines=0;
    DWORD               AllowedBadFaxLines=200;    // since it was ACK by T.30 we don't care much here.
    DWORD               AllowedConsecBadLines=200;
    PTIFF_INSTANCE_DATA TiffInstanceDest;

    DWORD               dwTemp;
    BOOL                f1D=1;
    BYTE                Count2D;
    BYTE                CColor, RColor, RColor1;
    WORD                a0;
    WORD                RValue1;
    short               iCode;
    BYTE                bShift;
    BYTE                CountHoriz;
    BOOL                fFirstResult;
    PBYTE               pByteTable0;
    BYTE                Num2DLines=0;
    DWORD               MaxImageHeight=2400;
    DWORD               DestHiRes;
    LPDWORD             lpdwOutLimit;


    //
    // Build Dest. file name from Src. file name
    //

    if (NewFileName == NULL) {
        _tcscpy(DestFileName, TiffInstance->FileName);
        DestFileName[_tcslen(DestFileName) - 1] = TEXT('$');
    } else {
        _tcscpy(DestFileName, NewFileName);
    }

    _tcscpy(SrcFileName, TiffInstance->FileName);
    
    CurrPage = 1;

    if (TiffInfoSrc.YResolution == 196) {
        DestHiRes = 1;
    }
    else {
        DestHiRes = 0;
    }

    hTiffDest = TiffCreate(
        DestFileName,
        TIFF_COMPRESSION_MMR,
        1728,
        FILLORDER_LSB2MSB,
        DestHiRes);

    if (! hTiffDest) {
        TiffClose(hTiffSrc);
        return FALSE;
    }

    TiffInstanceDest = (PTIFF_INSTANCE_DATA) hTiffDest;


    BufferSize = MaxImageHeight * (TiffInfoSrc.ImageWidth / 8);

    DestBufferSize = BufferSize + 200000;

    pSrcBits = (LPBYTE) VirtualAlloc(
        NULL,
        BufferSize,
        MEM_COMMIT,
        PAGE_READWRITE
        );
    if (!pSrcBits) {
        MemFree(DestFileName);
        TiffClose(hTiffSrc);
        TiffClose(hTiffDest);
        return FALSE;
    }


    pDestBits = (LPBYTE) VirtualAlloc(
        NULL,
        DestBufferSize,
        MEM_COMMIT,
        PAGE_READWRITE
        );
    if (!pDestBits) {
        MemFree(DestFileName);
        TiffClose(hTiffSrc);
        TiffClose(hTiffDest);
        VirtualFree ( pSrcBits, 0 , MEM_RELEASE );
        return FALSE;
    }



    for (PageCnt=0; PageCnt<TiffInfoSrc.PageCount; PageCnt++) {

        if ( ! TiffSeekToPage( hTiffSrc, PageCnt+1, FILLORDER_LSB2MSB) ) {
            goto bad_exit;
        }

        if (! TiffStartPage(hTiffDest) ) {
            goto bad_exit;
        }

        // here we decode MR page line by line into Color Trans. Array
        // fix all the errors
        // and encode clean data into MMR page


        lpdwResPtr = (LPDWORD) ( (ULONG_PTR) pSrcBits & ~(0x3) );

        BufferUsedSize = BufferSize;

        if (!GetTiffBits(hTiffSrc, (LPBYTE)lpdwResPtr, &BufferUsedSize, FILLORDER_LSB2MSB) ) {

            if (BufferUsedSize > BufferSize) {
                VirtualFree ( pSrcBits, 0 , MEM_RELEASE );
                VirtualFree ( pDestBits, 0 , MEM_RELEASE );

                BufferSize = BufferUsedSize;
                DestBufferSize = BufferSize + 200000;

                pSrcBits = (LPBYTE) VirtualAlloc(
                    NULL,
                    BufferSize,
                    MEM_COMMIT,
                    PAGE_READWRITE
                    );

                if (! pSrcBits) {
                    TiffClose(hTiffSrc);
                    TiffClose(hTiffDest);

                    DeleteFile(DestFileName);

                    MemFree(DestFileName);

                    return FALSE;
                }

                pDestBits = (LPBYTE) VirtualAlloc(
                    NULL,
                    DestBufferSize,
                    MEM_COMMIT,
                    PAGE_READWRITE
                    );

                if (! pDestBits) {
                    VirtualFree ( pSrcBits, 0 , MEM_RELEASE );

                    TiffClose(hTiffSrc);
                    TiffClose(hTiffDest);

                    DeleteFile(DestFileName);

                    MemFree(DestFileName);

                    return FALSE;
                }

                lpdwResPtr = (LPDWORD) ( (ULONG_PTR) pSrcBits & ~(0x3) );

                if (!GetTiffBits(hTiffSrc, (LPBYTE)lpdwResPtr, &BufferUsedSize, FILLORDER_LSB2MSB) ) {
                    goto bad_exit;
                }
            }
            else {
                goto bad_exit;
            }
        }

        ResBit = 0;
        EndBuffer = lpdwResPtr + (BufferUsedSize / sizeof(DWORD) );

        pRefLine = Line1Array;
        pCurLine = Line2Array;
        lpdwOutStart = lpdwOut = (LPDWORD) ( (ULONG_PTR) pDestBits & ~(0x3) );
        lpdwOutLimit = lpdwOutStart + ( DestBufferSize >> 2 );


        BitOut = 0;
        ZeroMemory( (BYTE *) lpdwOut, DestBufferSize );

        CIndex    = 0;
        RunLength = 0;


        // first REF line is all white
        RIndex    = 1;
        *pRefLine = LINE_LENGTH;
        RValue    = LINE_LENGTH;



        Lines = 0;
        EolCount = 1;
        BadFaxLines = 0;
        LastLineBad = FALSE;
        fTestLength = DO_NOT_TEST_LENGTH;
        lineWidth = LINE_LENGTH;


        //
        // find first EOL in a block
        //

        if (! FindNextEol (lpdwResPtr, ResBit, EndBuffer, &lpdwResPtr, &ResBit, fTestLength, &fError) ) {

            goto bad_exit;
        }

        // output first "all white" line
        CIndex    = 1;
        *pCurLine = LINE_LENGTH;

        if (! OutputMmrLine(lpdwOut, BitOut, pCurLine, pRefLine, &lpdwOut, &BitOut, lpdwOutLimit) ) {
            goto bad_exit;
        }

        RIndex = 0;
        CIndex = 0;
        Lines++;

#ifdef RDEBUG
        if ( DebGlobOut )
        _tprintf( TEXT (" EOL Line=%d\n\n"), Lines );
#endif

        Table = TableWhite;
        Color = WHITE_COLOR;


        // EOL-loop

        do {

            dwTemp = (*lpdwResPtr) & (0x00000001 << ResBit );

            if (f1D || dwTemp) {
//l1Dline:

#ifdef RDEBUG
                // _tprintf( TEXT (" Start 1D dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

                if (! dwTemp) {

#ifdef RDEBUG
                    _tprintf( TEXT ("\n ERROR f1D dwResPtr=%lx bit=%d "), lpdwResPtr, ResBit);
#endif

                    BadFaxLines++;
                    if (LastLineBad) {
                        ConsecBadLines++;
                    }

                    if (BadFaxLines > AllowedBadFaxLines ||
                        ConsecBadLines > AllowedConsecBadLines) {

                            goto bad_exit;
                    }

                    ResBit++;
                    if (ResBit > 31) {
                        lpdwResPtr++;
                        ResBit -= 32;
                    }

                    fTestLength = DO_NOT_TEST_LENGTH;
                    f1D = 1;
                    goto lFindNextEOL;
                }

                // decode 1D line starting ResBit+1

                ResBit++;
                if (ResBit > 31) {
                    lpdwResPtr++;
                    ResBit -= 32;
                }

                RIndex = 0;
                RunLength = 0;

                Table = TableWhite;
                Color = WHITE_COLOR;



                // 1-D Table look-up loop
                do {

                    if (ResBit <= 17) {
                        dwIndex = (*lpdwResPtr) >> ResBit;
                    }
                    else {
                        dwIndex = ( (*lpdwResPtr) >> ResBit ) + ( (*(lpdwResPtr+1)) << (32-ResBit) ) ;
                    }

                    dwIndex &= 0x00007fff;

                    pByteTable = Table + (5*dwIndex);
                    pByteTail  = pByteTable+4;

                    // All bytes

                    for (i=0; i<4; i++)  {

                        MakeupT = *pByteTable & 0x80;
                        CodeT   = (WORD) *pByteTable & 0x3f;

                        if (MakeupT) {

                            if (CodeT < 28) {
                                RunLength += (CodeT << 6);

                                if (RunLength > lineWidth) {
                                    BadFaxLines++;
                                    if (LastLineBad) {
                                        ConsecBadLines++;
                                    }

                                    if (BadFaxLines > AllowedBadFaxLines ||
                                        ConsecBadLines > AllowedConsecBadLines) {

                                            goto bad_exit;
                                    }

                                    f1D = 1;
                                    Count2D = 0;

                                    fTestLength = DO_NOT_TEST_LENGTH;
                                    goto lFindNextEOL;
                                }

                                EolCount=0;
#ifdef RDEBUG
                                if ( DebGlobOut ) {
                                    if (Color) {
                                        _tprintf( TEXT ("b%d "), (CodeT << 6)  );
                                    }
                                    else {
                                        _tprintf( TEXT ("w%d "), (CodeT << 6)  );
                                    }
                                }
#endif
                            }

                            else if (CodeT == NO_MORE_RECORDS) {
                                goto lNextIndex1D;
                            }

                            else if (CodeT == LOOK_FOR_EOL_CODE)  {
                                // end of our line AHEAD
                                if (RunLength == lineWidth) {
                                    EolCount = 0;
                                    f1D = 0;
                                    Count2D = 0;
                                    Lines++;

                                    fTestLength = DO_TEST_LENGTH;
                                    TailT = *pByteTail & 0x0f;

                                    ResBit += TailT;

                                    if (ResBit > 31) {
                                            lpdwResPtr++;
                                            ResBit -= 32;
                                    }
#ifdef RDEBUG
                                    if ( DebGlobOut )
                                        _tprintf( TEXT (" 1D ") );
#endif

                                    goto lFindNextEOL;

                                }
                                else if (RunLength != 0) {
#ifdef RDEBUG
                                    _tprintf( TEXT ("\n!!! ERROR 1D RunLength\n"), RunLength  );
#endif

                                    BadFaxLines++;
                                    if (LastLineBad) {
                                        ConsecBadLines++;
                                    }

                                    if (BadFaxLines > AllowedBadFaxLines ||
                                        ConsecBadLines > AllowedConsecBadLines) {

                                            goto bad_exit;
                                    }

                                    f1D = 1;
                                    Count2D = 0;

                                    fTestLength = DO_NOT_TEST_LENGTH;
                                    goto lFindNextEOL;

                                }
                                else {
                                    // zero RunLength
                                    EolCount++;

                                    if (EolCount >= 5)  {

                                        goto good_exit;
                                    }

                                    f1D = 1;
                                    Count2D = 0;

                                    fTestLength = DO_TEST_LENGTH;
                                    TailT = *pByteTail & 0x0f;

                                    ResBit += TailT;

                                    if (ResBit > 31) {
                                            lpdwResPtr++;
                                            ResBit -= 32;
                                    }

                                    goto lFindNextEOL;
                                }
                            }

                            else if (CodeT == EOL_FOUND_CODE) {
#ifdef RDEBUG
                                // _tprintf( TEXT ("   Res=%d\n"), RunLength  );
#endif

                                ResBit +=  (*pByteTail & 0x0f);
                                if (ResBit > 31) {
                                        lpdwResPtr++;
                                        ResBit -= 32;
                                }

                                if (RunLength == lineWidth) {
                                    EolCount = 0;
                                    f1D = 0;
                                    Count2D = 0;
                                    Lines++;

                                    // end of a good line.
                                    if (! OutputMmrLine(lpdwOut, BitOut, pCurLine, pRefLine, &lpdwOut, &BitOut, lpdwOutLimit) ) {
                                        goto bad_exit;
                                    }

#ifdef RDEBUG
                                    if ( DebGlobOut )
                                        _tprintf( TEXT (" E 1D EOL Line=%d\n\n"), Lines );
#endif
                                    pTmpSwap = pRefLine;
                                    pRefLine = pCurLine;
                                    pCurLine = pTmpSwap;
                                    RIndex = 0; //CIndex;
                                    CIndex = 0;

                                    goto lAfterEOL;

                                }
                                else if (RunLength != 0) {
#ifdef RDEBUG
                                    _tprintf( TEXT ("!!! ERROR 1D Runlength EOLFOUND \n")  );
#endif

                                    BadFaxLines++;
                                    if (LastLineBad) {
                                        ConsecBadLines++;
                                    }

                                    if (BadFaxLines > AllowedBadFaxLines ||
                                        ConsecBadLines > AllowedConsecBadLines) {

                                            goto bad_exit;
                                    }

                                    f1D = 1;
                                    Count2D = 0;
                                    CIndex = 0;
                                    goto lAfterEOL;
                                }
                                else {
                                    // zero RunLength
                                    EolCount++;

                                    if (EolCount >= 5)  {

                                        goto good_exit;
                                    }

                                    f1D = 1;
                                    Count2D = 0;
                                    CIndex = 0;
                                    goto lAfterEOL;
                                }

                            }

                            else if (CodeT == ERROR_CODE) {
#ifdef RDEBUG
                                _tprintf( TEXT (" ERROR CODE 1D dwResPtr=%lx bit=%d "), lpdwResPtr, ResBit);
#endif

                                BadFaxLines++;
                                if (LastLineBad) {
                                    ConsecBadLines++;
                                }

                                if (BadFaxLines > AllowedBadFaxLines ||
                                    ConsecBadLines > AllowedConsecBadLines) {

                                        goto bad_exit;
                                }

                                f1D = 1;
                                Count2D = 0;

                                fTestLength = DO_NOT_TEST_LENGTH;
                                goto lFindNextEOL;
                            }

                            else {
#ifdef RDEBUG
                                _tprintf( TEXT("ERROR: WRONG code: index=%04x\n"), dwIndex);
#endif

                                goto bad_exit;
                            }
                        }

                        else {  // terminating code
                            RunLength += CodeT;

                            if (RunLength > lineWidth) {
                                BadFaxLines++;
                                if (LastLineBad) {
                                    ConsecBadLines++;
                                }

                                if (BadFaxLines > AllowedBadFaxLines ||
                                    ConsecBadLines > AllowedConsecBadLines) {

                                        goto bad_exit;
                                }

                                f1D = 1;
                                Count2D = 0;

                                fTestLength = DO_NOT_TEST_LENGTH;
                                goto lFindNextEOL;
                            }

                            //RSL was error
                            *(pCurLine + (CIndex++)) = RunLength;


                            if (CIndex >= MaxColorTransPerLine ) {
#ifdef RDEBUG
                                _tprintf( TEXT (" ERROR 1D TOO MANY COLORS dwResPtr=%lx bit=%d "), lpdwResPtr, ResBit);
#endif
                                goto bad_exit;
                            }

#ifdef RDEBUG
                            if ( DebGlobOut ) {

                                if (Color) {
                                    _tprintf( TEXT ("b%d "), (CodeT)  );
                                }
                                else {
                                    _tprintf( TEXT ("w%d "), (CodeT)  );
                                }
                            }
#endif
                            Color = 1 - Color;
                        }

                        pByteTable++;

                     }



lNextIndex1D:
                    Table = Color ? TableBlack : TableWhite;
                    TailT = *pByteTail & 0x0f;

                    ResBit += TailT;

                    if (ResBit > 31) {
                            lpdwResPtr++;
                            ResBit -= 32;
                    }
                } while (lpdwResPtr <= EndBuffer);


                BadFaxLines++;
                if (LastLineBad) {
                    ConsecBadLines++;
                }

                if (BadFaxLines > AllowedBadFaxLines ||
                    ConsecBadLines > AllowedConsecBadLines ||
                    Lines < MIN_GOOD_LINES) {

                        goto bad_exit;
                }

                goto good_exit;

            }


//l2Dline:
            // should be 2D

#ifdef RDEBUG
            // _tprintf( TEXT ("\n Start 2D dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

            if ( (*lpdwResPtr) & (0x00000001 << ResBit) )  {
#ifdef RDEBUG
                _tprintf( TEXT ("\n!!! ERROR Start 2D dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

                BadFaxLines++;
                if (LastLineBad) {
                    ConsecBadLines++;
                }

                if (BadFaxLines > AllowedBadFaxLines ||
                    ConsecBadLines > AllowedConsecBadLines) {

                        goto bad_exit;
                }

                f1D =  1;
                Count2D = 0;
                CIndex = 0;
                goto lAfterEOL;
            }


            // 2D line decode loop
            a0        = 0;
            CIndex    = 0;
            CColor    = 0;
            RunLength = 0;

            RIndex    = 0;
            RValue    = *(pRefLine + RIndex);
            RColor    = 0;

            //BUGBUG incorporate with the next Index calc. to save time

            if (++ResBit > 31) {
                lpdwResPtr++;
                ResBit -= 32;
            }

            // prefix loop
            do {


                if (ResBit <= 25 ) {
                    dwIndex = (*lpdwResPtr) >> ResBit;
                }
                else {
                    dwIndex = ( (*lpdwResPtr) >> ResBit ) + ( (*(lpdwResPtr+1)) << (32-ResBit) ) ;
                }

                dwIndex &= 0x0000007f;
                pByteTable = (BYTE *) (&PrefTable[dwIndex]);

                // work-around of a PPC compiler bug: incorrect CMP with signed char. NT 1381. 8/31/96. RafaelL
                iCode = ((short)  ( (char) (*pByteTable) ) ) >> 4;
                bShift = (*pByteTable) & 0x0f;

                if (iCode < 4) {
                    // VERTICAL -3...+3
#ifdef RDEBUG
                    if ( DebGlobOut )
                        _tprintf( TEXT (" V ") );
#endif

                    if ( (RunLength >= RValue) && (RunLength != 0) ) {
                        while (++RIndex < MaxColorTransPerLine) {
                            if ( (RValue = *(pRefLine + RIndex) ) > RunLength )  {
                                // BUGBUG will change to break; after debugging
                                goto lFound;
                            }
                        }
#ifdef RDEBUG
                        _tprintf( TEXT ("!!! ERROR internal LOGIC RIndex=%d, RValue=%d, RunLength=%d\n "), RIndex, RValue, RunLength );
#endif

                        BadFaxLines++;
                        if (LastLineBad) {
                            ConsecBadLines++;
                        }

                        if (BadFaxLines > AllowedBadFaxLines ||
                            ConsecBadLines > AllowedConsecBadLines) {

                                goto bad_exit;
                        }

                        f1D = 1;
                        Count2D = 0;

                        fTestLength = DO_NOT_TEST_LENGTH;
                        goto lFindNextEOL;


lFound:
                        RColor = RIndex & 0x0001;
                    }

                    if (CColor == RColor)  {
                        a0 = RValue + iCode;
                    }
                    else {
                        if (RValue == LINE_LENGTH) {
                            a0 = RValue + iCode;
                        }
                        else {
                            a0 = *(pRefLine + RIndex + 1) + iCode;
                        }
                    }


                    // RSL 111296

                    if ( ( a0 <= RunLength ) && (a0 != 0) ) {

                        BadFaxLines++;
                        if (LastLineBad) {
                            ConsecBadLines++;
                        }

                        if (BadFaxLines > AllowedBadFaxLines ||
                            ConsecBadLines > AllowedConsecBadLines) {

                                goto bad_exit;
                        }

                        f1D = 1;
                        Count2D = 0;

                        fTestLength = DO_NOT_TEST_LENGTH;
                        goto lFindNextEOL;

                    }


                    *(pCurLine + (CIndex++) ) = a0;

#ifdef RDEBUG
                    if ( DebGlobOut ) {

                        if (CColor) {
                            _tprintf( TEXT ("b%d "), (a0 - RunLength) );
                        }
                        else {
                            _tprintf( TEXT ("w%d "), (a0 - RunLength) );
                        }
                    }
#endif
                    RunLength = a0;
                    CColor = 1 - CColor;

                }

                else if (iCode == HORIZ_PREFIX) {
#ifdef RDEBUG
                    if ( DebGlobOut )

                        _tprintf( TEXT (" H ") );
#endif


                    ResBit += bShift;
                    if (ResBit > 31) {
                        ResBit -= 32;
                        lpdwResPtr++;
                    }


                    Table = CColor ? TableBlack : TableWhite;
                    Color = CColor;
                    CountHoriz = 0;
                    fFirstResult = 1;



                    // 1-D Table look-up loop
                    do {

                        if (ResBit <= 17) {
                            dwIndex = (*lpdwResPtr) >> ResBit;
                        }
                        else {
                            dwIndex = ( (*lpdwResPtr) >> ResBit ) + ( (*(lpdwResPtr+1)) << (32-ResBit) ) ;
                        }


                        dwIndex &= 0x00007fff;

                        pByteTable = Table + (5*dwIndex);
                        pByteTail  = pByteTable+4;
                        pByteTable0 = pByteTable;

                        // All bytes

                        for (i=0; i<4; i++)  {

                            MakeupT = *pByteTable & 0x80;
                            CodeT   = (WORD) *pByteTable & 0x3f;

                            if (MakeupT) {

                                if (CodeT < 28) {
                                    RunLength += (CodeT << 6);

                                    if (RunLength > lineWidth) {
                                        BadFaxLines++;
                                        if (LastLineBad) {
                                            ConsecBadLines++;
                                        }

                                        if (BadFaxLines > AllowedBadFaxLines ||
                                            ConsecBadLines > AllowedConsecBadLines) {

                                                goto bad_exit;
                                        }

                                        f1D = 1;
                                        Count2D = 0;

                                        fTestLength = DO_NOT_TEST_LENGTH;
                                        goto lFindNextEOL;
                                    }

#ifdef RDEBUG
                                    if ( DebGlobOut ) {

                                        if (Color) {
                                            _tprintf( TEXT ("b%d "), (CodeT << 6)  );
                                        }
                                        else {
                                            _tprintf( TEXT ("w%d "), (CodeT << 6)  );
                                        }
                                    }
#endif
                                }

                                else if (CodeT == NO_MORE_RECORDS) {
                                    goto lNextIndexHoriz;
                                }

                                else  {
                                    // ERROR: LOOK_FOR_EOL_CODE, EOL_FOUND_CODE, ERROR_CODE
#ifdef RDEBUG

                                    _tprintf( TEXT ("\n!!! ERROR 2D dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

                                    BadFaxLines++;
                                    if (LastLineBad) {
                                        ConsecBadLines++;
                                    }

                                    if (BadFaxLines > AllowedBadFaxLines ||
                                        ConsecBadLines > AllowedConsecBadLines) {

                                            goto bad_exit;
                                    }

                                    f1D = 1;
                                    Count2D = 0;

                                    fTestLength = DO_NOT_TEST_LENGTH;
                                    goto lFindNextEOL;
                                }

                            }

                            else {  // terminating code
                                RunLength += CodeT;

                                if (RunLength > lineWidth) {
                                    BadFaxLines++;
                                    if (LastLineBad) {
                                        ConsecBadLines++;
                                    }

                                    if (BadFaxLines > AllowedBadFaxLines ||
                                        ConsecBadLines > AllowedConsecBadLines) {

                                            goto bad_exit;
                                    }

                                    f1D = 1;
                                    Count2D = 0;

                                    fTestLength = DO_NOT_TEST_LENGTH;
                                    goto lFindNextEOL;
                                }

                                *(pCurLine + (CIndex++) ) = RunLength;

                                if (RIndex >= MaxColorTransPerLine ) {
                                    BadFaxLines++;
                                    if (LastLineBad) {
                                        ConsecBadLines++;
                                    }

                                    if (BadFaxLines > AllowedBadFaxLines ||
                                        ConsecBadLines > AllowedConsecBadLines) {

                                            goto bad_exit;
                                    }

                                    f1D = 1;
                                    Count2D = 0;

#ifdef RDEBUG
                                    _tprintf( TEXT ("\n!!! ERROR 2D TOO MANY Colors dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

                                    fTestLength = DO_NOT_TEST_LENGTH;
                                    goto lFindNextEOL;
                                }

#ifdef RDEBUG

                                if ( DebGlobOut ) {

                                    if (Color) {
                                        _tprintf( TEXT ("b%d "), (CodeT)  );
                                    }
                                    else {
                                        _tprintf( TEXT ("w%d "), (CodeT)  );
                                    }
                                }
#endif
                                Color = 1 - Color;
                                if (++CountHoriz >= 2)  {
                                    if (fFirstResult) {
                                        bShift =  (*pByteTail & 0xf0) >> 4;
                                    }
                                    else {
                                        // rare case will take time
                                        bShift =  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 3 );
                                        bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 4 );
                                        bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 5 );
                                        bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 6 );
                                    }
                                    goto lNextPrefix;
                                }
                            }

                            pByteTable++;

                        }



lNextIndexHoriz:
                        if (Color != CColor) {
                            fFirstResult = 0;
                        }

                        Table = Color ? TableBlack : TableWhite;
                        TailT = *pByteTail & 0x0f;

                        ResBit += TailT;

                        if (ResBit > 31) {
                                lpdwResPtr++;
                                ResBit -= 32;
                        }
                    } while (lpdwResPtr <= EndBuffer);


                    BadFaxLines++;
                    if (LastLineBad) {
                        ConsecBadLines++;
                    }

                    if (BadFaxLines > AllowedBadFaxLines ||
                        ConsecBadLines > AllowedConsecBadLines ||
                        Lines < MIN_GOOD_LINES) {

                            goto bad_exit;
                    }

                    goto good_exit;
                }

                else if (iCode == PASS_PREFIX) {
#ifdef RDEBUG
                    if ( DebGlobOut )

                        _tprintf( TEXT (" P ") );
#endif

                    if ( (RunLength >= RValue) && (RunLength != 0) ) {
                        while (++RIndex < MaxColorTransPerLine) {
                            if ( (RValue = *(pRefLine + RIndex) ) > RunLength )  {
                                goto lFound2;
                            }
                        }

#ifdef RDEBUG
                        _tprintf( TEXT ("!!! ERROR internal LOGIC RIndex=%d, RValue=%d, RunLength=%d\n "), RIndex, RValue, RunLength );
#endif


                        BadFaxLines++;
                        if (LastLineBad) {
                            ConsecBadLines++;
                        }

                        if (BadFaxLines > AllowedBadFaxLines ||
                            ConsecBadLines > AllowedConsecBadLines) {

                                goto bad_exit;
                        }

                        f1D = 1;
                        Count2D = 0;

                        fTestLength = DO_NOT_TEST_LENGTH;
                        goto lFindNextEOL;

                    }

lFound2:

                    RColor = RIndex & 1;


                    if (RValue != LINE_LENGTH) {
                        RValue1 = *(pRefLine + RIndex + 1 );

                        RColor1 = 1 - RColor;

                        if ( (RValue1 != LINE_LENGTH) && (RColor1 == CColor) ) {
                            a0 = *(pRefLine + RIndex + 2);
                        }
                        else {
                            a0 = RValue1;
                        }
                    }
                    else {
                        a0 = LINE_LENGTH;
                    }



#ifdef RDEBUG
                    if ( DebGlobOut ) {

                        if (CColor) {
                            _tprintf( TEXT ("b%d "), (a0 - RunLength) );
                        }
                        else {
                            _tprintf( TEXT ("w%d "), (a0 - RunLength) );
                        }
                    }
#endif


                    // RSL 111296

                    if ( ( a0 <= RunLength ) && (a0 != 0) ) {

                        BadFaxLines++;
                        if (LastLineBad) {
                            ConsecBadLines++;
                        }

                        if (BadFaxLines > AllowedBadFaxLines ||
                            ConsecBadLines > AllowedConsecBadLines) {

                                goto bad_exit;
                        }

                        f1D = 1;
                        Count2D = 0;

                        fTestLength = DO_NOT_TEST_LENGTH;
                        goto lFindNextEOL;

                    }


                    RunLength = a0;

                }

                else if (iCode == LOOK_FOR_EOL_PREFIX) {
#ifdef RDEBUG
                    // _tprintf( TEXT (" EOL Line=%d\n\n"), Lines );
#endif

                    if (RunLength == lineWidth) {
                        if (++Count2D >= Num2DLines) {
                            Count2D = 0;
                            f1D = 0;   // relax HiRes/LoRes 2D lines per 1D rules - HP Fax does 3 2D-lines per 1 1D-line in LoRes.

                        }

#ifdef RDEBUG
                        // _tprintf( TEXT ("\n 2D done CINdex=%d dwResPtr=%lx bit=%d \n"), CIndex, lpdwResPtr, ResBit);
#endif


                        fTestLength = DO_TEST_LENGTH;
                        f1D = 0;
                        Lines++;

#ifdef RDEBUG
                        if ( DebGlobOut )

                            _tprintf( TEXT (" 2D ") );
#endif

                        goto lFindNextEOL;
                    }
                    else  {

#ifdef RDEBUG
                        _tprintf( TEXT ("\n!!! ERROR 2D WRONG LINE LENGTH dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

                        BadFaxLines++;
                        if (LastLineBad) {
                            ConsecBadLines++;
                        }

                        if (BadFaxLines > AllowedBadFaxLines ||
                            ConsecBadLines > AllowedConsecBadLines) {

                                goto bad_exit;
                        }

                        f1D = 1;
                        Count2D = 0;

                        fTestLength = DO_NOT_TEST_LENGTH;
                        goto lFindNextEOL;
                    }

                }

                else { //ERROR
#ifdef RDEBUG
                    _tprintf( TEXT ("\n!!! ERROR 2D PREFIX dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif

                    BadFaxLines++;
                    if (LastLineBad) {
                        ConsecBadLines++;
                    }

                    if (BadFaxLines > AllowedBadFaxLines ||
                        ConsecBadLines > AllowedConsecBadLines) {

                            goto bad_exit;
                    }

                    f1D = 1;
                    Count2D = 0;

                    fTestLength = DO_NOT_TEST_LENGTH;
                    goto lFindNextEOL;
                }

lNextPrefix:
                ResBit += bShift;
                if (ResBit > 31) {
                    lpdwResPtr++;
                    ResBit -= 32;
                }

            } while (lpdwResPtr < EndBuffer);

            BadFaxLines++;
            if (LastLineBad) {
                ConsecBadLines++;
            }

            if (BadFaxLines > AllowedBadFaxLines ||
                ConsecBadLines > AllowedConsecBadLines ||
                Lines < MIN_GOOD_LINES ) {

                    goto bad_exit;
            }

            goto good_exit;



lFindNextEOL:

            if (RunLength == lineWidth) {
                ConsecBadLines=0;

                if (! OutputMmrLine(lpdwOut, BitOut, pCurLine, pRefLine, &lpdwOut, &BitOut, lpdwOutLimit) ) {
                    goto bad_exit;
                }

#ifdef RDEBUG
                 if ( DebGlobOut ) {
                    _tprintf( TEXT (" EOL Line=%d "), Lines );

                    _tprintf( TEXT (" RIndex=%d, CIndex=%d:  "), RIndex, CIndex);

                    for (i=0; i<CIndex; i++) {
                       _tprintf( TEXT ("%04d>%04d, "), i, *(pCurLine+i) );
                        if ( *(pCurLine+i) >= lineWidth ) {
                            break;
                        }
                    }
                    _tprintf( TEXT ("\n\n"));
                 }

#endif

                pTmpSwap = pRefLine;
                pRefLine = pCurLine;
                pCurLine = pTmpSwap;

            }

            RIndex = 0;
            CIndex = 0;
            RunLength = 0;

            if (! FindNextEol (lpdwResPtr, ResBit, EndBuffer, &lpdwResPtr, &ResBit, fTestLength, &fError) ) {

                BadFaxLines++;
                if (LastLineBad) {
                    ConsecBadLines++;
                }

                if (BadFaxLines > AllowedBadFaxLines ||
                    ConsecBadLines > AllowedConsecBadLines ||
                    Lines < MIN_GOOD_LINES) {

                        goto bad_exit;
                }

                goto good_exit;

            }

            if ( (fTestLength == DO_TEST_LENGTH) && fError ) {
                BadFaxLines++;
                if (LastLineBad) {
                    ConsecBadLines++;
                }

                if (BadFaxLines > AllowedBadFaxLines ||
                    ConsecBadLines > AllowedConsecBadLines) {

                        goto bad_exit;
                }
            }


lAfterEOL:
            ;



        } while (lpdwResPtr <= EndBuffer);

        BadFaxLines++;
        if (LastLineBad) {
            ConsecBadLines++;
        }

        if (BadFaxLines > AllowedBadFaxLines ||
            ConsecBadLines > AllowedConsecBadLines ||
            Lines < MIN_GOOD_LINES ) {

                goto bad_exit;
        }


good_exit:

        *(++lpdwOut) = 0x80000000;
        *(++lpdwOut) = 0x80000000;
        Lines--;

        DestSize = (DWORD)((lpdwOut - lpdwOutStart) * sizeof (DWORD));
        if (! TiffWriteRaw( hTiffDest, (LPBYTE) lpdwOutStart, DestSize) ) {
            goto bad_exit;
        }

        TiffInstanceDest->Lines        = Lines;

        if (! TiffEndPage(hTiffDest) ) {
            goto bad_exit;
        }

    }

    bRet = TRUE;

bad_exit:

    VirtualFree ( pSrcBits, 0 , MEM_RELEASE );
    VirtualFree ( pDestBits, 0 , MEM_RELEASE );

    TiffClose(hTiffSrc);
    TiffClose(hTiffDest);

    if (bRet == TRUE && NewFileName == NULL) {
        // replace the original MH file by the new clean MMR file
        DeleteFile(SrcFileName);
        MoveFile(DestFileName, SrcFileName);
    }

    return bRet;
}


BOOL
TiffUncompressMmrPageRaw(
    LPBYTE      StripData,
    DWORD       StripDataSize,
    DWORD       ImageWidth,
    LPDWORD     lpdwOutputBuffer,
    LPDWORD     LinesOut
    )

{
    DWORD               i;
    DWORD               j;
    PBYTE               plinebuf;
    DWORD               lineWidth;
    DWORD               Lines;
    DWORD               EolCount;

    BOOL                Color;
    LPDWORD             EndPtr;
    PBYTE               TableWhite = (PBYTE) GlobTableWhite;
    PBYTE               TableBlack = (PBYTE) GlobTableBlack;
    PBYTE               Table;
    PBYTE               pByteTable,  pByteTail;
    BYTE                MakeupT;
    WORD                CodeT;
    BYTE                TailT;
    WORD                RunLength=0;

    DWORD               TableSize=32768;

    WORD                Line1Array[MaxColorTransPerLine];
    WORD                Line2Array[MaxColorTransPerLine];
    WORD                *pRefLine;
    WORD                *pCurLine;
    WORD                *pTmpSwap;
    BYTE                CColor, RColor, RColor1;
    WORD                RIndex, CIndex;
    DWORD               dwIndex;
    WORD                a0;
    WORD                RValue, RValue1;
    LPDWORD             lpdwResPtr;
    BYTE                ResBit;
    short               iCode;
    BYTE                bShift;
    BYTE                CountHoriz;
    BOOL                fFirstResult;
    PBYTE               pByteTable0;

    WORD                PrevValue;
    WORD                CurValue;
    WORD                CurPos;
    WORD                CurRun;
    WORD                NumBytes;
    WORD                NumDwords;
    BYTE                BitOut;
    LPDWORD             lpdwOut;
    LPBYTE              lpbOut;
    LPBYTE              lpbLineStart;
    BOOL                fOutputLine = 0;
    DWORD               dwSizeOutputBuffer = (*LinesOut * LINE_LENGTH) / 8;
    BOOL                fDoneDwords=0;



    // start Pointers

    pRefLine = Line1Array;
    pCurLine = Line2Array;

    BitOut = 0;

    ZeroMemory( (BYTE *) lpdwOutputBuffer, dwSizeOutputBuffer);

    Lines = 0;
    EolCount = 1;
    plinebuf = StripData;
    lineWidth = ImageWidth;

    EndPtr = (LPDWORD) ( (ULONG_PTR) (plinebuf+StripDataSize-1) & ~(0x3) ) ;
    lpdwResPtr = (LPDWORD) (((ULONG_PTR) plinebuf) & ~(0x3));
    ResBit =   (BYTE) (( ( (ULONG_PTR) plinebuf) & 0x3) << 3) ;

    // 2D line decode loop
    a0        = 0;
    CIndex    = 0;
    CColor    = 0;
    RunLength = 0;

    // first REF line is all white
    RIndex    = 1;
    *pRefLine = LINE_LENGTH;
    RValue    = LINE_LENGTH;
    RColor    = 0;

    lpbLineStart = (LPBYTE) lpdwOutputBuffer;

    // prefix loop
    do {

        if (RunLength == lineWidth) {

#ifdef RDEBUG
            _tprintf( TEXT(" EOL\n\n") );
#endif

            //
            // Output Uncompressed line based on Color Trans. Array
            //

            for (CurPos=0;  CurPos < MaxColorTransPerLine; CurPos+=2) {

                PrevValue = *(pCurLine + CurPos);

                if ( PrevValue == LINE_LENGTH ) {
                    break;
                }

                CurValue = *(pCurLine + CurPos + 1);
                CurRun   = CurValue - PrevValue;

                lpbOut  = lpbLineStart + (PrevValue >> 3);
                BitOut   = PrevValue % 8;

                //
                // black color
                //

                *lpbOut = (*lpbOut) | (MINUS_ONE_BYTE >> BitOut);

                if (BitOut + CurRun <= 7 ) {
                    //
                    // Just a part of the same BYTE.
                    //

                    *lpbOut = (*lpbOut) & All1[BitOut + CurRun];
                    BitOut += CurRun;
                }
                else {
                    //
                    // We crossed the BYTE boundary.
                    //

                    CurRun -= (8 - BitOut);
                    BitOut = 0;
                    lpbOut++;

                    //
                    // Walk the entire DWORDs in a middle of a run.
                    //

                    NumBytes = CurRun >> 3;
                    CurRun  -= (NumBytes << 3);

                    if (NumBytes >= 7) {
                        //
                        // makes sense process DWORDs
                        //

                        fDoneDwords = 0;

                        do {
                            if ( ! (  (((ULONG_PTR) lpbOut) & 3)  ||  fDoneDwords )   ) {
                                //
                                // DWORD stretch
                                //
                                NumDwords = NumBytes >> 2;
                                lpdwOut = (LPDWORD) lpbOut;

                                for (j=0; j<NumDwords; j++) {
                                    *lpdwOut++ = MINUS_ONE_DWORD;
                                }

                                NumBytes -= (NumDwords << 2);
                                lpbOut = (LPBYTE) lpdwOut;
                                fDoneDwords = 1;
                            }
                            else {
                                //
                                // either lead or tail BYTE stretch
                                //
                                *lpbOut++ = MINUS_ONE_BYTE;
                                NumBytes--;
                            }

                        }  while (NumBytes > 0);
                    }

                    else {
                        //
                        // process BYTEs
                        //
                        for (i=0; i<NumBytes; i++) {
                            *lpbOut++ = MINUS_ONE_BYTE;
                        }
                    }

                    //
                    // Last part of a BYTE.
                    //

                    *lpbOut = All1[CurRun];

                    BitOut = (BYTE) CurRun;
                }


                if ( CurValue == LINE_LENGTH ) {
                    break;
                }

           }

           lpbLineStart += (LINE_LENGTH >> 3);

            // Next Src Line

            pTmpSwap = pRefLine;
            pRefLine = pCurLine;
            pCurLine = pTmpSwap;
            RIndex   =  0;
            RValue   =  *pRefLine;
            RColor   =  0;

            a0        = 0;
            CIndex    = 0;
            CColor    = 0;
            RunLength = 0;


        }

        if (ResBit <= 25 ) {
            dwIndex = (*lpdwResPtr) >> ResBit;
        }
        else {
            dwIndex = ( (*lpdwResPtr) >> ResBit ) + ( (*(lpdwResPtr+1)) << (32-ResBit) ) ;
        }

        dwIndex &= 0x0000007f;

        pByteTable = (BYTE *) (&PrefTable[dwIndex]);
        iCode = ( (short) ((char) (*pByteTable)) ) >> 4;
        bShift = (*pByteTable) & 0x0f;

        if (iCode < 4) {
            // VERTICAL -3...+3
#ifdef RDEBUG
            _tprintf( TEXT (" V%2d "), iCode );
#endif

            if ( (RunLength >= RValue) && (RunLength != 0) ) {
                while (++RIndex < MaxColorTransPerLine) {
                    if ( (RValue = *(pRefLine + RIndex) ) > RunLength )  {
                        // BUGBUG will change to break; after debugging
                        goto lFound;
                    }
                }

#ifdef RDEBUG
                _tprintf( TEXT ("!!! ERROR internal LOGIC RIndex=%d, RValue=%d, RunLength=%d\n "), RIndex, RValue, RunLength );
#endif
                //DebugBreak();
                return FALSE;


lFound:
                RColor = RIndex & 1;
            }

            if (CColor == RColor)  {
                a0 = RValue + iCode;
            }
            else {
                if (RValue == LINE_LENGTH) {
                    a0 = RValue + iCode;
                }
                else {
                    a0 = *(pRefLine + RIndex + 1) + iCode;
                }
            }

            *(pCurLine + (CIndex++) ) = a0;

#ifdef RDEBUG
            if (CColor) {
                _tprintf( TEXT ("b%d "), (a0 - RunLength) );
            }
            else {
                _tprintf( TEXT ("w%d "), (a0 - RunLength) );
            }
#endif

            // sanity check

            if ( (a0 < RunLength) || (a0 > LINE_LENGTH) ) {
#ifdef RDEBUG
                _tprintf( TEXT ("!!! ERROR MMR src a0=%d, RunLength=%d\n "), a0, RunLength );
#endif
                return FALSE;

            }

            RunLength = a0;
            CColor = 1 - CColor;

        }

        else if (iCode == HORIZ_PREFIX) {
#ifdef RDEBUG
            _tprintf( TEXT (" H ") );
#endif


            ResBit += bShift;
            if (ResBit > 31) {
                ResBit -= 32;
                lpdwResPtr++;
            }


            Table = CColor ? TableBlack : TableWhite;
            Color = CColor;
            CountHoriz = 0;
            fFirstResult = 1;


            // 1-D Table look-up loop
            do {

                if (ResBit <= 17) {
                    dwIndex = (*lpdwResPtr) >> ResBit;
                }
                else {
                    dwIndex = ( (*lpdwResPtr) >> ResBit ) + ( (*(lpdwResPtr+1)) << (32-ResBit) ) ;
                }


                dwIndex &= 0x00007fff;

                pByteTable = Table + (5*dwIndex);
                pByteTail  = pByteTable+4;
                pByteTable0 = pByteTable;

                // All bytes

                for (i=0; i<4; i++)  {

                    MakeupT = *pByteTable & 0x80;
                    CodeT   = (WORD) *pByteTable & 0x3f;

                    if (MakeupT) {

                        if (CodeT < 28) {
                            RunLength += (CodeT << 6);

                            // sanity check

                            if (RunLength > LINE_LENGTH)  {
#ifdef RDEBUG
                                _tprintf( TEXT ("!!! ERROR MMR src codeT=%d, RunLength=%d\n "), a0, RunLength );
#endif
                                return FALSE;

                            }

#ifdef RDEBUG
                            if (Color) {
                                _tprintf( TEXT ("b%d "), (CodeT << 6)  );
                            }
                            else {
                                _tprintf( TEXT ("w%d "), (CodeT << 6)  );
                            }
#endif
                        }

                        else if (CodeT == NO_MORE_RECORDS) {
                            goto lNextIndexHoriz;
                        }

                        else  {
                            // ERROR: LOOK_FOR_EOL_CODE, EOL_FOUND_CODE, ERROR_CODE
#ifdef RDEBUG
                            _tprintf( TEXT ("\n!!! ERROR 2D dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif
                            return FALSE;
                        }

                    }

                    else {  // terminating code
                        RunLength += CodeT;
                        *(pCurLine + (CIndex++) ) = RunLength;

                        // sanity check

                        if ( (RunLength > LINE_LENGTH) || ( CIndex >= MaxColorTransPerLine ) ) {
#ifdef RDEBUG
                            _tprintf( TEXT ("!!! ERROR MMR RunLength=%d, CodeT=%d, CIndex=%d\n "),
                                            RunLength, CodeT, CIndex );
#endif
                            return FALSE;

                        }

#ifdef RDEBUG
                        if (Color) {
                            _tprintf( TEXT ("b%d "), (CodeT)  );
                        }
                        else {
                            _tprintf( TEXT ("w%d "), (CodeT)  );
                        }
#endif
                        Color = 1 - Color;
                        if (++CountHoriz >= 2)  {
                            if (fFirstResult) {
                                bShift =  (*pByteTail & 0xf0) >> 4;
                            }
                            else {
                                // rare case will take time
                                bShift =   ( ( (BYTE) (*pByteTable0++) & 0x40) >> 3 );
                                bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 4 );
                                bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 5 );
                                bShift +=  ( ( (BYTE) (*pByteTable0++) & 0x40) >> 6 );
                            }
                            goto lNextPrefix;
                        }
                    }

                    pByteTable++;

                }



lNextIndexHoriz:
                if (Color != CColor) {
                    fFirstResult = 0;
                }

                Table = Color ? TableBlack : TableWhite;
                TailT = *pByteTail & 0x0f;

                ResBit += TailT;

                if (ResBit > 31) {
                        lpdwResPtr++;
                        ResBit -= 32;
                }
            } while (lpdwResPtr <= EndPtr);

            return FALSE;




        }

        else if (iCode == PASS_PREFIX) {
#ifdef RDEBUG
            _tprintf( TEXT (" P ") );
#endif

            if ( (RunLength >= RValue) && (RunLength != 0) ) {
                while (++RIndex < MaxColorTransPerLine) {
                    if ( (RValue = *(pRefLine + RIndex) ) > RunLength )  {
                        goto lFound2;
                    }
                }

#ifdef RDEBUG
                _tprintf( TEXT ("!!! ERROR internal LOGIC RIndex=%d, RValue=%d, RunLength=%d\n "), RIndex, RValue, RunLength );
#endif
                //DebugBreak();
                return FALSE;


            }

lFound2:

            RColor = RIndex & 1;


            if (RValue != LINE_LENGTH) {
                RValue1 = *(pRefLine + RIndex + 1 );

                RColor1 = 1 - RColor;

                if ( (RValue1 != LINE_LENGTH) && (RColor1 == CColor) ) {
                    a0 = *(pRefLine + RIndex + 2);
                }
                else {
                    a0 = RValue1;
                }
            }
            else {
                a0 = LINE_LENGTH;
            }


#ifdef RDEBUG
            if (CColor) {
                _tprintf( TEXT ("b%d "), (a0 - RunLength) );
            }
            else {
                _tprintf( TEXT ("w%d "), (a0 - RunLength) );
            }
#endif

            // sanity check

            if ( (a0 < RunLength) || (a0 > LINE_LENGTH) ) {
#ifdef RDEBUG
                _tprintf( TEXT ("!!! ERROR MMR src a0=%d, RunLength=%d\n "), a0, RunLength );
#endif
                return FALSE;

            }

            RunLength = a0;

        }

        else if (iCode == LOOK_FOR_EOL_PREFIX) {
#ifdef RDEBUG
            // _tprintf( TEXT (" E ") );
#endif

            return TRUE;
        }

        else { //ERROR

#ifdef RDEBUG
           _tprintf( TEXT ("\n!!! ERROR 2D dwResPtr=%lx bit=%d \n"), lpdwResPtr, ResBit);
#endif
            return FALSE;

        }

lNextPrefix:
        ResBit += bShift;
        if (ResBit > 31) {
            lpdwResPtr++;
            ResBit -= 32;
        }

    } while (lpdwResPtr <= EndPtr);

    return FALSE;


}


BOOL
TiffUncompressMmrPage(
    HANDLE      hTiff,
    LPDWORD     lpdwOutputBuffer,
    LPDWORD     LinesOut
    )

{
    PTIFF_INSTANCE_DATA TiffInstance = (PTIFF_INSTANCE_DATA) hTiff;


    //
    // check if enough memory
    //

    if (TiffInstance->ImageHeight > *LinesOut) {
        *LinesOut = TiffInstance->ImageHeight;
        return FALSE;
    }

    TiffInstance->Color = 0;
    TiffInstance->RunLength = 0;
    TiffInstance->StartGood = 0;
    TiffInstance->EndGood = 0;

    return TiffUncompressMmrPageRaw(
        TiffInstance->StripData,
        TiffInstance->StripDataSize,
        TiffInstance->ImageWidth,
        lpdwOutputBuffer,
        LinesOut
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\tiff\src\test.c ===
#include "tifflibp.h"
#pragma hdrstop

#include "tifflib.h"


int __cdecl wmain( int argc, WCHAR *argv[])
{
    MS_TAG_INFO MsTagInfo = {0};


    HeapInitialize(NULL,NULL,NULL,0);
    FaxTiffInitialize();

    if (argv[2]) {
        MsTagInfo.RecipName = argv[2];
    }
    if (argv[3]) {
        MsTagInfo.RecipNumber = argv[3];
    }
    if (argv[4]) {
        MsTagInfo.SenderName = argv[4];
    }
    if (argv[5]) {
        MsTagInfo.Routing = argv[5];
    }
    if (argv[6]) {
        MsTagInfo.CallerId = argv[6];
    }
    if (argv[7]) {
        MsTagInfo.Csid = argv[7];
    }
    if (argv[8]) {
        MsTagInfo.Tsid = argv[8];
    }

    TiffAddMsTags( argv[1], &MsTagInfo );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\tiff\src\tifflibp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tifflibp.h

Abstract:

    This file is the private header file for the
    TIFF support library.  All source files in this
    library include this header only.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

#include "faxutil.h"
#include "tifflib.h"
#include "tiff.h"
#include "tifftabl.h"


#define TIFFDBG 0

//
// Find the next pixel on the scanline whose color is opposite of
// the specified color, starting from the specified starting point
//

#define NextChangingElement( pbuf, startBit, stopBit, isBlack ) \
        ((startBit) + ((isBlack) ? FindBlackRun((pbuf), (startBit), (stopBit)) : \
                                   FindWhiteRun((pbuf), (startBit), (stopBit))))

//
// Check if the specified pixel on the scanline is black or white
//  1 - the specified pixel is black
//  0 - the specified pixel is white
//
#define GetBit( pbuf, bit )   (((pbuf)[(bit) >> 3] >> (((bit) ^ 7) & 7)) & 1)


#define Align(p, x)  (((x) & ((p)-1)) ? (((x) & ~((p)-1)) + p) : (x))

#define WHITE       0
#define BLACK       0xff
#define BYTEBITS    8
#define WORDBITS    (sizeof(WORD)  * BYTEBITS)
#define DWORDBITS   (sizeof(DWORD) * BYTEBITS)

//
// IFD entries we generate for each page
//
// ******************************************************
// *->
// *-> WARNING:    these constants must be sorted by
// *->             the ifd values.  it is a T.4
// *->             requirement that all TIFF IFDs be
// *->             sorted.
// *->
// *->             if you change these constants then
// *->             don't forget to go change the
// *->             IFD template in tifflib.c
// *->
// ******************************************************
//

#define IFD_NEWSUBFILETYPE       0               // 254
#define IFD_IMAGEWIDTH           1               // 256
#define IFD_IMAGEHEIGHT          2               // 257
#define IFD_BITSPERSAMPLE        3               // 258
#define IFD_COMPRESSION          4               // 259
#define IFD_PHOTOMETRIC          5               // 262
#define IFD_FILLORDER            6               // 266
#define IFD_STRIPOFFSETS         7               // 273
#define IFD_SAMPLESPERPIXEL      8               // 277
#define IFD_ROWSPERSTRIP         9               // 278
#define IFD_STRIPBYTECOUNTS     10               // 279
#define IFD_XRESOLUTION         11               // 281
#define IFD_YRESOLUTION         12               // 282
#define IFD_G3OPTIONS           13               // 292
#define IFD_RESUNIT             14               // 296
#define IFD_PAGENUMBER          15               // 297
#define IFD_SOFTWARE            16               // 305
#define IFD_CLEANFAXDATA        17               // 327
#define IFD_BADFAXLINES         18               // 328

#define NUM_IFD_ENTRIES         19



#pragma pack(1)
//
// Data structure for representing a single IFD entry
//
typedef struct {
    WORD    tag;        // field tag
    WORD    type;       // field type
    DWORD   count;      // number of values
    DWORD   value;      // value or value offset
} IFDENTRY, *PIFDENTRY;

typedef struct {
    WORD        wIFDEntries;
    IFDENTRY    ifd[NUM_IFD_ENTRIES];
    DWORD       nextIFDOffset;
    DWORD       filler;
    DWORD       xresNum;
    DWORD       xresDenom;
    DWORD       yresNum;
    DWORD       yresDenom;
    CHAR        software[32];
} FAXIFD, *PFAXIFD;
#pragma pack()


typedef struct _STRIP_INFO {
    DWORD           Offset;
    DWORD           Bytes;
    LPBYTE          Data;
} STRIP_INFO, *PSTRIP_INFO;

typedef struct TIFF_INSTANCE_DATA {
    HANDLE          hFile;                          // file handle for TIFF file
    HANDLE          hMap;                           // file mapping handle
    LPBYTE          fPtr;                           // mapped file pointer
    TCHAR           FileName[MAX_PATH];             // tiff file name
    TIFF_HEADER     TiffHdr;                        // TIFF header
    FAXIFD          TiffIfd;                        // ifd
    DWORD           PageCount;                      // number of pages written to the TIFF file
    DWORD           DataOffset;                     // offset to the beginning of current data block
    DWORD           IfdOffset;                      // offset to the current ifd pointer
    DWORD           Lines;                          // number of lines written to the TIFF file
    DWORD           CompressionType;
    DWORD           Bytes;
    BYTE            Buffer[FAXBYTES*3];
    LPBYTE          CurrLine;
    LPBYTE          RefLine;
    DWORD           CurrPage;
    LPVOID          StripData;
    LPBYTE          CurrPtr;
    DWORD           StripDataSize;
    DWORD           RowsPerStrip;
    DWORD           StripOffset;
    DWORD           ImageWidth;
    DWORD           ImageHeight;
    DWORD           Color;
    DWORD           RunLength;
    DWORD           bitdata;
    DWORD           bitcnt;
    PBYTE           bitbuf;
    DWORD           PhotometricInterpretation;
    DWORD           FillOrder;
    PTIFF_TAG       TagImageLength;
    PTIFF_TAG       TagRowsPerStrip;
    PTIFF_TAG       TagStripByteCounts;
    PTIFF_TAG       TagFillOrder;
    PTIFF_TAG       TagCleanFaxData;
    PTIFF_TAG       TagBadFaxLines;
    DWORD           FileSize;
    DWORD           StartGood;
    DWORD           EndGood;
    DWORD           BadFaxLines;
    DWORD           CleanFaxData;
    DWORD           YResolution;
    DWORD           XResolution;
    DWORD           BytesPerLine;
} TIFF_INSTANCE_DATA, *PTIFF_INSTANCE_DATA;


#define SOFTWARE_STR            "Windows NT Fax Server\0         "
#define SOFTWARE_STR_LEN        32
#define SERVICE_SIGNATURE       'xafS'
#define TIFFF_RES_X             204
#define TIFFF_RES_Y             196

//
// Output a sequence of compressed bits
//

__inline void
OutputBits(
    PTIFF_INSTANCE_DATA TiffInstance,
    WORD                Length,
    WORD                Code
    )
{
    TiffInstance->bitdata |= Code << (TiffInstance->bitcnt - Length);
    if ((TiffInstance->bitcnt -= Length) <= 2*BYTEBITS) {
        *TiffInstance->bitbuf++ = (BYTE) (TiffInstance->bitdata >> 3*BYTEBITS);
        *TiffInstance->bitbuf++ = (BYTE) (TiffInstance->bitdata >> 2*BYTEBITS);
        TiffInstance->bitdata <<= 2*BYTEBITS;
        TiffInstance->bitcnt += 2*BYTEBITS;
    }
}

//
// Flush any leftover bits into the compressed bitmap buffer
//

__inline void
FlushBits(
    PTIFF_INSTANCE_DATA TiffInstance
    )
{
    while (TiffInstance->bitcnt < DWORDBITS) {
        TiffInstance->bitcnt += BYTEBITS;
        *TiffInstance->bitbuf++ = (BYTE) (TiffInstance->bitdata >> 3*BYTEBITS);
        TiffInstance->bitdata <<= BYTEBITS;
    }
    TiffInstance->bitdata = 0;
    TiffInstance->bitcnt = DWORDBITS;
}

__inline void
FlushLine(
    PTIFF_INSTANCE_DATA TiffInstance,
    DWORD PadLength
    )
{
    if (TiffInstance->bitcnt < DWORDBITS) {
        TiffInstance->bitcnt += BYTEBITS;
        *TiffInstance->bitbuf++ = (BYTE) (TiffInstance->bitdata >> 3*BYTEBITS);
        TiffInstance->bitdata = 0;
        TiffInstance->bitcnt = DWORDBITS;
    }
    if (PadLength) {
        TiffInstance->bitbuf += ((PadLength / 8) - TiffInstance->BytesPerLine);
    }
}

//
// Output a runlength of white or black bits
//

__inline void
OutputCodeBits(
    PTIFF_INSTANCE_DATA TiffInstance,
    INT                 RunLength
    )
{
    INT i;
    if (RunLength > 0) {

        TiffInstance->RunLength += RunLength;

        if (TiffInstance->Color) {

            //
            // black run
            //

            for (i=0; i<RunLength/BYTEBITS; i++) {
                OutputBits( TiffInstance, BYTEBITS, BLACK );
            }
            if (RunLength%BYTEBITS) {
                OutputBits( TiffInstance, (WORD)(RunLength%BYTEBITS), (WORD)((1<<(RunLength%BYTEBITS))-1) );
            }

        } else {

            //
            // white run
            //

            for (i=0; i<RunLength/BYTEBITS; i++) {
                OutputBits( TiffInstance, BYTEBITS, WHITE );
            }
            if (RunLength%BYTEBITS) {
                OutputBits( TiffInstance, (WORD)(RunLength%BYTEBITS), WHITE );
            }

        }
    }
}


__inline DWORD
GetTagData(
    LPBYTE RefPointer,
    DWORD Index,
    PTIFF_TAG TiffTag
    )

/*++

Routine Description:

    Gets the data associated with a given IFD tag

Arguments:

    RefPointer  -  Beginning of the data block
    Index       -  The index for data values that have an
                   array of values greater than zero
    TiffTag     -  Pointer to valid TIFF IFD tag

Return Value:

    The data value.

--*/

{
    DWORD Value;

    if (TiffTag->DataType == TIFF_SHORT) {

        if (TiffTag->DataCount == 1) {

            Value = (DWORD) TiffTag->DataOffset;

        } else {

            Value = (DWORD)(*(WORD UNALIGNED *)(RefPointer + TiffTag->DataOffset + (sizeof(WORD) * Index)));

        }

    } else if (TiffTag->DataType == TIFF_RATIONAL) {

        Value = *(DWORD UNALIGNED *)(RefPointer + TiffTag->DataOffset + (sizeof(DWORD) * Index));

    } else if (TiffTag->DataType == TIFF_ASCII) {

        if (TiffTag->DataCount < 4 ) {

            Value = (DWORD) TiffTag->DataOffset;

        } else {

            Value = *(DWORD UNALIGNED *)(RefPointer + TiffTag->DataOffset + (sizeof(DWORD) * Index));

        }
    } else {

        if (TiffTag->DataCount == 1) {

            Value = (DWORD) TiffTag->DataOffset;

        } else {

            Value = *(DWORD UNALIGNED *)(RefPointer + TiffTag->DataOffset + (sizeof(DWORD) * Index));

        }

    }

    return Value;
}

__inline VOID
PutTagData(
    LPBYTE RefPointer,
    DWORD Index,
    PTIFF_TAG TiffTag,
    DWORD Value
    )

/*++

Routine Description:

    Gets the data associated with a given IFD tag

Arguments:

    RefPointer  -  Beginning of the data block
    Index       -  The index for data values that have an
                   array of values greater than zero
    TiffTag     -  Pointer to valid TIFF IFD tag

Return Value:

    The data value.

--*/

{
    if (!TiffTag) {
        return;
    }
    if (TiffTag->DataType == TIFF_SHORT) {

        if (TiffTag->DataCount == 1) {

            TiffTag->DataOffset = Value;

        } else {

            *(WORD UNALIGNED *)(RefPointer + TiffTag->DataOffset + (sizeof(WORD) * Index)) = (WORD) Value;

        }

    } else if (TiffTag->DataType == TIFF_ASCII) {

        if (TiffTag->DataCount < 4) {

            TiffTag->DataOffset = Value;

        } else {

            *(WORD UNALIGNED *)(RefPointer + TiffTag->DataOffset + (sizeof(WORD) * Index)) = (WORD) Value;

        }
    } else {

        if (TiffTag->DataCount == 1) {

            TiffTag->DataOffset = Value;

        } else {

            *(DWORD UNALIGNED *)(RefPointer + TiffTag->DataOffset + (sizeof(DWORD) * Index)) = Value;

        }

    }
}


//
// prototypes
//

INT
FindWhiteRun(
    PBYTE       pbuf,
    INT         startBit,
    INT         stopBit
    );

INT
FindBlackRun(
    PBYTE       pbuf,
    INT         startBit,
    INT         stopBit
    );

BOOL
EncodeFaxData(
    PTIFF_INSTANCE_DATA TiffInstance,
    PBYTE               plinebuf,
    INT                 lineWidth,
    DWORD               CompressionType
    );

BOOL
DecodeUnCompressedFaxData(
    PTIFF_INSTANCE_DATA TiffInstance,
    LPBYTE              OutputBuffer,
    BOOL                SingleLineBuffer,
    DWORD               PadLength
    );

BOOL
DecodeMHFaxData(
    PTIFF_INSTANCE_DATA TiffInstance,
    LPBYTE              OutputBuffer,
    BOOL                SingleLineBuffer,
    DWORD               PadLength
    );

BOOL
DecodeMRFaxData(
    PTIFF_INSTANCE_DATA TiffInstance,
    LPBYTE              OutputBuffer,
    BOOL                SingleLineBuffer,
    DWORD               PadLength
    );

BOOL
DecodeMMRFaxData(
    PTIFF_INSTANCE_DATA TiffInstance,
    LPBYTE              OutputBuffer,
    BOOL                SingleLineBuffer,
    DWORD               PadLength
    );

BOOL
EncodeFaxDataNoCompression(
    PTIFF_INSTANCE_DATA TiffInstance,
    PBYTE               plinebuf,
    INT                 lineWidth
    );

BOOL
EncodeFaxDataMhCompression(
    PTIFF_INSTANCE_DATA TiffInstance,
    PBYTE               plinebuf,
    INT                 lineWidth
    );

BOOL
EncodeFaxDataMmrCompression(
    PTIFF_INSTANCE_DATA TiffInstance,
    PBYTE               plinebuf,
    INT                 lineWidth
    );


BOOL
EncodeFaxPageMmrCompression(
    PTIFF_INSTANCE_DATA TiffInstance,
    PBYTE               plinebuf,
    INT                 lineWidth,
    DWORD               ImageHeight,
    DWORD               *DestSize
    );


BOOL
PostProcessMhToMmr(
    HANDLE      hTiffSrc,
    TIFF_INFO TiffInfo,
    LPTSTR      SrcFileName
    );

BOOL
PostProcessMrToMmr(
    HANDLE      hTiffSrc,
    TIFF_INFO TiffInfo,
    LPTSTR      SrcFileName
    );

BOOL
GetTiffBits(
    HANDLE  hTiff,
    LPBYTE Buffer,
    LPDWORD BufferSize,
    DWORD FillOrder
    );

BOOL
EncodeMmrBranding(
    PBYTE               pBrandBits,
    LPDWORD             pMmrBrandBits,
    INT                 BrandHeight,
    INT                 BrandWidth,
    DWORD              *DwordsOut,
    DWORD              *BitsOut
    );




__inline
VOID
OutputRunFastReversed(
    INT                 run,
    INT                 color,
    LPDWORD            *lpdwOut,
    BYTE               *BitOut
    )


{
    PCODETABLE          pCodeTable;
    PCODETABLE          pTableEntry;

    pCodeTable = (color == BLACK) ? BlackRunCodesReversed : WhiteRunCodesReversed;

    // output makeup code if exists
    if (run >= 64) {

#ifdef RDEBUG
        if ( DebGlobOut )
        if (DebGlobOutPrefix) {
            if (color == BLACK) {
                _tprintf( TEXT ("b%d "), (run & 0xffc0) );
            }
            else {
                _tprintf( TEXT ("w%d "), (run & 0xffc0) );
            }
        }
#endif



        pTableEntry = pCodeTable + (63 + (run >> 6));

        **lpdwOut = **lpdwOut + (((DWORD) (pTableEntry->code)) << (*BitOut));

        if ( ( (*BitOut) = (*BitOut) + pTableEntry->length ) > 31)  {
            (*BitOut) -= 32;
            *(++(*lpdwOut)) = (((DWORD) (pTableEntry->code)) >> (pTableEntry->length - (*BitOut)) );
        }


        run &= 0x3f;
    }

    // output terminating code always

#ifdef RDEBUG

    if ( DebGlobOut )
    if (DebGlobOutPrefix) {

        if (color == BLACK) {
            _tprintf( TEXT ("b%d "), run );
        }
        else {
            _tprintf( TEXT ("w%d "), run );
        }
    }
#endif


    pTableEntry = pCodeTable + run;

    **lpdwOut = **lpdwOut + (((DWORD) (pTableEntry->code)) << (*BitOut));

    if ( ( (*BitOut) = (*BitOut) + pTableEntry->length ) > 31)  {
        (*BitOut) -= 32;
        *(++(*lpdwOut)) = (((DWORD) (pTableEntry->code)) >> (pTableEntry->length - (*BitOut)) );
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\tiff\src\tifflib.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tifflib.c

Abstract:

    This file contains all of the public TIFF library functions.
    The following functions are available from this library:

        o TiffCreate            Creates a new TIFF file
        o TiffOpen              Opens an existing TIFF file
        o TiffClose             Closes a previously open or created TIFF file
        o TiffStartPage         Starts a new page for writing
        o TiffEndPage           Ends a page for writing
        o TiffWrite             Writes a line of TIFF data
        o TiffWriteRaw          Writes a line of TIFF data with no-encoding
        o TiffRead              Reads a page of TIFF data
        o TiffSeekToPage        Positions to a page for reading

    This library can be used anywhere in user mode and is thread
    safe for multithreaded apps.

    The encoding methods implemented in this library are coded
    to the ITU specification labeled T.4 03/93.


Environment:

        WIN32 User Mode


Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/


#include "tifflibp.h"
#pragma hdrstop

#include "fasttiff.h"

DWORD TiffDataWidth[] = {
    0,  // nothing
    1,  // TIFF_BYTE
    1,  // TIFF_ASCII
    2,  // TIFF_SHORT
    4,  // TIFF_LONG
    8,  // TIFF_RATIONAL
    1,  // TIFF_SBYTE
    1,  // TIFF_UNDEFINED
    2,  // TIFF_SSHORT
    4,  // TIFF_SLONG
    8,  // TIFF_SRATIONAL
    4,  // TIFF_FLOAT
    8   // TIFF_DOUBLE
};

//
// IFD template for creating a new TIFF data page
//

FAXIFD FaxIFDTemplate = {

    NUM_IFD_ENTRIES,

    {
        { TIFFTAG_SUBFILETYPE,     TIFF_LONG,                    1, FILETYPE_PAGE          },   // 254
        { TIFFTAG_IMAGEWIDTH,      TIFF_LONG,                    1, 0                      },   // 256
        { TIFFTAG_IMAGELENGTH,     TIFF_LONG,                    1, 0                      },   // 257
        { TIFFTAG_BITSPERSAMPLE,   TIFF_SHORT,                   1, 1                      },   // 258
        { TIFFTAG_COMPRESSION,     TIFF_SHORT,                   1, 0                      },   // 259
        { TIFFTAG_PHOTOMETRIC,     TIFF_SHORT,                   1, PHOTOMETRIC_MINISWHITE },   // 262
        { TIFFTAG_FILLORDER,       TIFF_SHORT,                   1, FILLORDER_LSB2MSB      },   // 266
        { TIFFTAG_STRIPOFFSETS,    TIFF_LONG,                    1, 0                      },   // 273
        { TIFFTAG_SAMPLESPERPIXEL, TIFF_SHORT,                   1, 1                      },   // 277
        { TIFFTAG_ROWSPERSTRIP,    TIFF_LONG,                    1, 0                      },   // 278
        { TIFFTAG_STRIPBYTECOUNTS, TIFF_LONG,                    1, 0                      },   // 279
        { TIFFTAG_XRESOLUTION,     TIFF_RATIONAL,                1, 0                      },   // 281
        { TIFFTAG_YRESOLUTION,     TIFF_RATIONAL,                1, 0                      },   // 282
        { TIFFTAG_GROUP3OPTIONS,   TIFF_LONG,                    1, 0                      },   // 292
        { TIFFTAG_RESOLUTIONUNIT,  TIFF_SHORT,                   1, RESUNIT_INCH           },   // 296
        { TIFFTAG_PAGENUMBER,      TIFF_SHORT,                   2, 0                      },   // 297
        { TIFFTAG_SOFTWARE,        TIFF_ASCII,    SOFTWARE_STR_LEN, 0                      },   // 305
        { TIFFTAG_CLEANFAXDATA,    TIFF_SHORT,                   1, 0                      },   // 327
        { TIFFTAG_CONSECUTIVEBADFAXLINES, TIFF_SHORT,            1, 0                      }    // 328
    },

    0,
    SERVICE_SIGNATURE,
    TIFFF_RES_X,
    1,
    TIFFF_RES_Y,
    1,
    SOFTWARE_STR
};



DWORD
FaxTiffDllInit(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )

/*++

Routine Description:

    DLL initialization function.

Arguments:

    hInstance   - Instance handle
    Reason      - Reason for the entrypoint being called
    Context     - Context record

Return Value:

    TRUE        - Initialization succeeded
    FALSE       - Initialization failed

--*/

{

extern DWORD GlobFaxTiffUsage;
extern BOOL  GlobFaxTiffInitialized;

    if (Reason == DLL_PROCESS_ATTACH) {
        BuildLookupTables(15);
        GlobFaxTiffInitialized = TRUE;
        InterlockedIncrement(&GlobFaxTiffUsage);

    }

    if (Reason == DLL_PROCESS_DETACH) {        
        
        InterlockedDecrement(&GlobFaxTiffUsage);        

    }

    return TRUE;
}



BOOL
FaxTiffInitialize()
{
    HeapInitialize(NULL,NULL,NULL,0);
    return TRUE;
}




HANDLE
TiffCreate(
    LPTSTR FileName,
    DWORD  CompressionType,
    DWORD  ImageWidth,
    DWORD  FillOrder,
    DWORD  HiRes
    )

/*++

Routine Description:

    Creates a new TIFF file.  The act of creating a new
    file requires more than just opening the file.  The
    TIFF header is written and instance data is initialized
    for further operations on the new file.

    If FileName is NULL, no file is created.  This is used to
    to in memory decoding/encoding.

Arguments:

    FileName            - Full or partial path/file name
    CompressionType     - Requested compression type, see tifflib.h
    ImageWidth          - Width of the image in pixels

Return Value:

    Handle to the new TIFF file or NULL on error.

--*/

{
    PTIFF_INSTANCE_DATA TiffInstance;
    DWORD               Bytes;



    TiffInstance = MemAlloc( sizeof(TIFF_INSTANCE_DATA) );
    if (!TiffInstance) {
        return NULL;
    }

    if (FileName != NULL) {

        TiffInstance->hFile = CreateFile(
            FileName,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            CREATE_ALWAYS,
            0,
            NULL
            );
        if (TiffInstance->hFile == INVALID_HANDLE_VALUE) {
            return NULL;
        }

    } else {

        TiffInstance->hFile = INVALID_HANDLE_VALUE;

    }

    if (FileName) {
        _tcscpy( TiffInstance->FileName, FileName );
    }

    TiffInstance->TiffHdr.Identifier = 0x4949;
    TiffInstance->TiffHdr.Version    = 0x2a;
    TiffInstance->TiffHdr.IFDOffset  = 0;
    TiffInstance->PageCount          = 0;
    TiffInstance->DataOffset         = 0;
    TiffInstance->IfdOffset          = FIELD_OFFSET( TIFF_HEADER, IFDOffset );
    TiffInstance->CompressionType    = CompressionType;
    TiffInstance->bitdata            = 0;
    TiffInstance->bitcnt             = DWORDBITS;
    TiffInstance->ImageWidth         = ImageWidth;
    TiffInstance->FillOrder          = FillOrder;

    if (HiRes) {
        TiffInstance->YResolution = 196;
    }
    else {
        TiffInstance->YResolution = 98;
    }


    FillMemory( TiffInstance->Buffer, sizeof(TiffInstance->Buffer), WHITE );

    TiffInstance->RefLine  = &TiffInstance->Buffer[0];
    TiffInstance->CurrLine = &TiffInstance->Buffer[FAXBYTES];
    TiffInstance->bitbuf   = &TiffInstance->Buffer[FAXBYTES];

    CopyMemory( &TiffInstance->TiffIfd, &FaxIFDTemplate, sizeof(FaxIFDTemplate) );

    if (TiffInstance->hFile != INVALID_HANDLE_VALUE) {
        if (!WriteFile(
            TiffInstance->hFile,
            &TiffInstance->TiffHdr,
            sizeof(TIFF_HEADER),
            &Bytes,
            NULL
            )) {
                CloseHandle( TiffInstance->hFile );
                DeleteFile( FileName );
                MemFree( TiffInstance );
                return NULL;
        }
    }

    return TiffInstance;
}


HANDLE
TiffOpen(
    LPTSTR FileName,
    PTIFF_INFO TiffInfo,
    BOOL ReadOnly,
    DWORD RequestedFillOrder
    )

/*++

Routine Description:

    Opens an existing TIFF file for reading.

Arguments:

    FileName            - Full or partial path/file name
    ImageWidth          - Optionaly receives the image width in pixels
    ImageLength         - Optionaly receives the image height in lines
    PageCount           - Optionaly receives the page count

Return Value:

    Handle to the open TIFF file or NULL on error.

--*/

{
    PTIFF_INSTANCE_DATA TiffInstance = NULL;
    WORD                NumDirEntries;
    DWORD               IFDOffset;
    

    TiffInstance = MemAlloc( sizeof(TIFF_INSTANCE_DATA) );
    if (!TiffInstance) {
        goto error_exit;
    }

    TiffInstance->hFile = CreateFile(
        FileName,
        ReadOnly ? GENERIC_READ : (GENERIC_READ | GENERIC_WRITE),
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );

    if (TiffInstance->hFile == INVALID_HANDLE_VALUE) {
        goto error_exit;
    }

    TiffInstance->FileSize = GetFileSize(TiffInstance->hFile,NULL);
    if (TiffInstance->FileSize == 0xFFFFFFFF ||
        TiffInstance->FileSize < sizeof(TIFF_HEADER)) {
        goto error_exit;
    }

    TiffInstance->hMap = CreateFileMapping(
        TiffInstance->hFile,
        NULL,
        ReadOnly ? (PAGE_READONLY | SEC_COMMIT) : (PAGE_READWRITE | SEC_COMMIT),
        0,
        0,
        NULL
        );
    if (!TiffInstance->hMap) {
        goto error_exit;
    }

    TiffInstance->fPtr = MapViewOfFile(
        TiffInstance->hMap,
        ReadOnly ? FILE_MAP_READ : (FILE_MAP_READ | FILE_MAP_WRITE),
        0,
        0,
        0
        );
    if (!TiffInstance->fPtr) {
        goto error_exit;
    }

    _tcscpy( TiffInstance->FileName, FileName );

    //
    // read in the TIFF header
    //
    CopyMemory(
        &TiffInstance->TiffHdr,
        TiffInstance->fPtr,
        sizeof(TIFF_HEADER)
        );

    //
    // validate that the file is really a TIFF file
    //
    if ((TiffInstance->TiffHdr.Identifier != TIFF_LITTLEENDIAN) ||
        (TiffInstance->TiffHdr.Version != TIFF_VERSION)) {
            goto error_exit;
    }

    IFDOffset = TiffInstance->TiffHdr.IFDOffset;
    if (IFDOffset > TiffInstance->FileSize) {
        goto error_exit;
    }

    //
    // walk the IFD list to count the number of pages
    //

    while ( IFDOffset ) {

        //
        // get the count of tags in this IFD
        //
        NumDirEntries = *(LPWORD)(TiffInstance->fPtr + IFDOffset);

        //
        // get the next IFD offset
        //
        IFDOffset = *(UNALIGNED DWORD *)(TiffInstance->fPtr + (NumDirEntries * sizeof(TIFF_TAG)) + IFDOffset + sizeof(WORD));
        if (IFDOffset > TiffInstance->FileSize) {
            goto error_exit;
        }
        //
        // increment the page counter
        //
        TiffInstance->PageCount += 1;

    }

    TiffInstance->IfdOffset             = TiffInstance->TiffHdr.IFDOffset;
    TiffInstance->FillOrder             = RequestedFillOrder;
    

    if (!TiffSeekToPage( TiffInstance, 1, RequestedFillOrder )) {
        goto error_exit;
    }

    TiffInfo->PageCount                 = TiffInstance->PageCount;
    TiffInfo->ImageWidth                = TiffInstance->ImageWidth;
    TiffInfo->ImageHeight               = TiffInstance->ImageHeight;
    TiffInfo->PhotometricInterpretation = TiffInstance->PhotometricInterpretation;
    TiffInfo->FillOrder                 = TiffInstance->FillOrder;
    TiffInfo->YResolution               = TiffInstance->YResolution;
    TiffInfo->CompressionType           = TiffInstance->CompressionType;
    TiffInstance->RefLine               = &TiffInstance->Buffer[0];
    TiffInstance->CurrLine              = &TiffInstance->Buffer[FAXBYTES];
    TiffInstance->CurrPage              = 1;

    FillMemory( TiffInstance->Buffer, sizeof(TiffInstance->Buffer), WHITE );

    return TiffInstance;

error_exit:
    if (TiffInstance && TiffInstance->hFile && TiffInstance->hFile != INVALID_HANDLE_VALUE) {
        UnmapViewOfFile( TiffInstance->fPtr );
        CloseHandle( TiffInstance->hMap );
        CloseHandle( TiffInstance->hFile );
    }
    if (TiffInstance) {
        MemFree( TiffInstance );
    }
    return NULL;
}


BOOL
TiffClose(
    HANDLE hTiff
    )

/*++

Routine Description:

    Closes a TIFF file and frees all allocated resources.

Arguments:

    hTiff               - TIFF handle returned by TiffCreate or TiffOpen

Return Value:

    TRUE for success, FALSE on error

--*/

{
    PTIFF_INSTANCE_DATA TiffInstance = (PTIFF_INSTANCE_DATA) hTiff;


    Assert(TiffInstance);

    if (TiffInstance->StripData) {

        VirtualFree(
            TiffInstance->StripData,
            0,
            MEM_RELEASE
            );
  
    }

    if (TiffInstance->hMap) {

        UnmapViewOfFile( TiffInstance->fPtr );
        CloseHandle( TiffInstance->hMap );
        CloseHandle( TiffInstance->hFile );

    } else {

        if (TiffInstance->hFile != INVALID_HANDLE_VALUE)
            CloseHandle( TiffInstance->hFile );

    }

    MemFree( TiffInstance );

    return TRUE;
}


VOID
RemoveGarbage(
    PTIFF_INSTANCE_DATA TiffInstance
    )

/*++

Routine Description:

    Removes the garbage from a page of tiff data.

Arguments:

    TiffInstance    - Pointer to the TIFF instance data

Return Value:

    None.

--*/

{
    if (TiffInstance->StartGood  == 0 || TiffInstance->EndGood == 0) {
        return;
    }

    CopyMemory(
        TiffInstance->fPtr + TiffInstance->StripOffset,
        (LPVOID) ((LPBYTE)TiffInstance->StripData + TiffInstance->StartGood),
        TiffInstance->EndGood - TiffInstance->StartGood
        );


    PutTagData( TiffInstance->fPtr, 0, TiffInstance->TagStripByteCounts, TiffInstance->EndGood-TiffInstance->StartGood );
    PutTagData( TiffInstance->fPtr, 0, TiffInstance->TagFillOrder,       FILLORDER_MSB2LSB );
    if (TiffInstance->BadFaxLines) {
        PutTagData( TiffInstance->fPtr, 0, TiffInstance->TagBadFaxLines, TiffInstance->BadFaxLines );
        PutTagData( TiffInstance->fPtr, 0, TiffInstance->TagCleanFaxData, CLEANFAXDATA_UNCLEAN );
    }
}


BOOL
TiffPostProcess(
    LPTSTR FileName
    )

/*++

Routine Description:

    Opens an existing TIFF file for reading.

Arguments:

    FileName            - Full or partial path/file name

Return Value:

    TRUE for success, FALSE for failure.

--*/

{
    PTIFF_INSTANCE_DATA TiffInstance;
    TIFF_INFO TiffInfo;
    DWORD PageCnt;
    BYTE TiffData[FAXBYTES*10];



    TiffInstance = (PTIFF_INSTANCE_DATA) TiffOpen(
        FileName,
        &TiffInfo,
        FALSE,
        FILLORDER_MSB2LSB
        );

    if (!TiffInstance) {
        return FALSE;
    }

    if (TiffInstance->ImageHeight) {
        TiffClose( (HANDLE) TiffInstance );
        return TRUE;
    }

    ZeroMemory( TiffData, sizeof(TiffData) );

    for (PageCnt=0; PageCnt<TiffInfo.PageCount; PageCnt++) {

        if (!TiffSeekToPage( (HANDLE) TiffInstance, PageCnt+1, FILLORDER_MSB2LSB )) {
            TiffClose( (HANDLE) TiffInstance );
            return TRUE;
        }

        switch( TiffInstance->CompressionType ) {

            case TIFF_COMPRESSION_NONE:

                if (!DecodeUnCompressedFaxData( TiffInstance, TiffData, TRUE, 0 )) {
                    TiffClose( (HANDLE) TiffInstance );
                    return FALSE;
                }
                break;

            case TIFF_COMPRESSION_MH:

                if (!DecodeMHFaxData( TiffInstance, TiffData, TRUE, 0 )) {
                    TiffClose( (HANDLE) TiffInstance );
                    return FALSE;
                }
                RemoveGarbage( TiffInstance );
                break;

            case TIFF_COMPRESSION_MR:

                if (!DecodeMRFaxData( TiffInstance, TiffData, TRUE, 0 )) {
                    TiffClose( (HANDLE) TiffInstance );
                    return FALSE;
                }
                break;

            case TIFF_COMPRESSION_MMR:

                if (!DecodeMMRFaxData( TiffInstance, TiffData, TRUE, 0 )) {
                    TiffClose( (HANDLE) TiffInstance );
                    return FALSE;
                }
                break;

        }

        PutTagData( TiffInstance->fPtr, 0, TiffInstance->TagRowsPerStrip, TiffInstance->Lines );
        PutTagData( TiffInstance->fPtr, 0, TiffInstance->TagImageLength,  TiffInstance->Lines );

    }

    TiffClose( (HANDLE) TiffInstance );

    return TRUE;
}


BOOL
TiffStartPage(
    HANDLE hTiff
    )

/*++

Routine Description:

    Set the file to be ready to write TIFF data to a new page.

Arguments:

    hTiff               - TIFF handle returned by TiffCreate or TiffOpen

Return Value:

    TRUE for success, FALSE on error

--*/

{
    PTIFF_INSTANCE_DATA TiffInstance = (PTIFF_INSTANCE_DATA) hTiff;


    Assert(TiffInstance);

    TiffInstance->DataOffset = SetFilePointer(
        TiffInstance->hFile,
        0,
        NULL,
        FILE_CURRENT
        );
    if (TiffInstance->DataOffset == 0xffffffff) {
        TiffInstance->DataOffset = 0;
        return FALSE;
    }

    return TRUE;
}


BOOL
TiffEndPage(
    HANDLE hTiff
    )

/*++

Routine Description:

    Ends a TIFF page in progress.  This causes the IFDs to be written.

Arguments:

    hTiff               - TIFF handle returned by TiffCreate or TiffOpen

Return Value:

    TRUE for success, FALSE on error

--*/

{
    PTIFF_INSTANCE_DATA TiffInstance = (PTIFF_INSTANCE_DATA) hTiff;
    PFAXIFD             TiffIfd;
    DWORD               Bytes;
    DWORD               CurrOffset;


    Assert(TiffInstance);
    TiffIfd  = &TiffInstance->TiffIfd;

    CurrOffset = SetFilePointer(
        TiffInstance->hFile,
        0,
        NULL,
        FILE_CURRENT
        );

    CurrOffset = Align( 8, CurrOffset );

    SetFilePointer(
        TiffInstance->hFile,
        TiffInstance->IfdOffset,
        NULL,
        FILE_BEGIN
        );

    WriteFile(
        TiffInstance->hFile,
        &CurrOffset,
        sizeof(CurrOffset),
        &Bytes,
        NULL
        );

    SetFilePointer(
        TiffInstance->hFile,
        CurrOffset,
        NULL,
        FILE_BEGIN
        );

    TiffInstance->PageCount += 1;

    TiffIfd->yresNum = TiffInstance->YResolution;

    TiffIfd->ifd[IFD_PAGENUMBER].value      = MAKELONG( TiffInstance->PageCount-1, 0);
    TiffIfd->ifd[IFD_IMAGEWIDTH].value      = TiffInstance->ImageWidth;
    TiffIfd->ifd[IFD_IMAGEHEIGHT].value     = TiffInstance->Lines;
    TiffIfd->ifd[IFD_ROWSPERSTRIP].value    = TiffInstance->Lines;
    TiffIfd->ifd[IFD_STRIPBYTECOUNTS].value = TiffInstance->Bytes;
    TiffIfd->ifd[IFD_STRIPOFFSETS].value    = TiffInstance->DataOffset;
    TiffIfd->ifd[IFD_XRESOLUTION].value     = CurrOffset + FIELD_OFFSET( FAXIFD, xresNum );
    TiffIfd->ifd[IFD_YRESOLUTION].value     = CurrOffset + FIELD_OFFSET( FAXIFD, yresNum );
    TiffIfd->ifd[IFD_SOFTWARE].value        = CurrOffset + FIELD_OFFSET( FAXIFD, software );
    TiffIfd->ifd[IFD_FILLORDER].value       = TiffInstance->FillOrder;

    if (TiffInstance->CompressionType == TIFF_COMPRESSION_NONE) {
        TiffIfd->ifd[IFD_COMPRESSION].value = COMPRESSION_NONE;
        TiffIfd->ifd[IFD_G3OPTIONS].value   = GROUP3OPT_FILLBITS;
    }
    else if (TiffInstance->CompressionType == TIFF_COMPRESSION_MMR) {
        TiffIfd->ifd[IFD_COMPRESSION].value = TIFF_COMPRESSION_MMR;
        TiffIfd->ifd[IFD_G3OPTIONS].value   = GROUP3OPT_FILLBITS |
            (TiffInstance->CompressionType == TIFF_COMPRESSION_MH ? 0 : GROUP3OPT_2DENCODING);
    }
    else {
        TiffIfd->ifd[IFD_COMPRESSION].value = COMPRESSION_CCITTFAX3;
        TiffIfd->ifd[IFD_G3OPTIONS].value   = GROUP3OPT_FILLBITS |
            (TiffInstance->CompressionType == TIFF_COMPRESSION_MH ? 0 : GROUP3OPT_2DENCODING);
    }

    if (!WriteFile(
        TiffInstance->hFile,
        TiffIfd,
        sizeof(FAXIFD),
        &Bytes,
        NULL
        )) {
            return FALSE;
    }

    TiffInstance->IfdOffset = CurrOffset + FIELD_OFFSET( FAXIFD, nextIFDOffset );
    TiffInstance->Bytes = 0;

    return TRUE;
}


BOOL
TiffWrite(
    HANDLE hTiff,
    LPBYTE TiffData
    )

/*++

Routine Description:

    Writes a new line of data to a TIFF file.  The data
    is encoded according to the compression type specified
    when TiffCreate was called.

Arguments:

    hTiff               - TIFF handle returned by TiffCreate or TiffOpen

Return Value:

    TRUE for success, FALSE on error

--*/

{
    PTIFF_INSTANCE_DATA TiffInstance = (PTIFF_INSTANCE_DATA) hTiff;
    DWORD               Bytes;

    Assert(TiffInstance);

    EncodeFaxData(
        TiffInstance,
        TiffData,
        TiffInstance->ImageWidth,
        TiffInstance->CompressionType
        );

    FlushBits( TiffInstance );

    Bytes = (DWORD)(TiffInstance->bitbuf - &TiffInstance->Buffer[FAXBYTES]);
    TiffInstance->bitbuf = &TiffInstance->Buffer[FAXBYTES];

    WriteFile(
        TiffInstance->hFile,
        TiffInstance->bitbuf,
        Bytes,
        &Bytes,
        NULL
        );

    TiffInstance->Bytes += Bytes;

    ZeroMemory( TiffInstance->bitbuf, FAXBYTES );
    TiffInstance->Lines += 1;

    return TRUE;
}


BOOL
TiffWriteRaw(
    HANDLE hTiff,
    LPBYTE TiffData,
    DWORD Size
    )

/*++

Routine Description:

    Writes a new line of data to a TIFF file.  The data
    is encoded according to the compression type specified
    when TiffCreate was called.

Arguments:

    hTiff               - TIFF handle returned by TiffCreate or TiffOpen

Return Value:

    TRUE for success, FALSE on error

--*/

{
    PTIFF_INSTANCE_DATA TiffInstance = (PTIFF_INSTANCE_DATA) hTiff;
    DWORD               Bytes;


    Assert(TiffInstance);

    WriteFile(
        TiffInstance->hFile,
        TiffData,
        Size,
        &Bytes,
        NULL
        );

    TiffInstance->Bytes += Bytes;

    if (Size == FAXBYTES) {
        TiffInstance->Lines += 1;
    }

    return TRUE;
}


BOOL
GetTiffBits(
    HANDLE  hTiff,
    LPBYTE Buffer,
    LPDWORD BufferSize,
    DWORD FillOrder
    )
{
    PTIFF_INSTANCE_DATA TiffInstance = (PTIFF_INSTANCE_DATA) hTiff;
    DWORD i;
    LPBYTE TmpBuffer;


    if (TiffInstance->StripDataSize > *BufferSize) {
        *BufferSize = TiffInstance->StripDataSize;
        return FALSE;
    }

    CopyMemory( Buffer, TiffInstance->StripData, TiffInstance->StripDataSize );

    if (FillOrder != TiffInstance->FillOrder) {
        for (i = 0, TmpBuffer = Buffer; i < TiffInstance->StripDataSize; i++) {
            TmpBuffer[i] = BitReverseTable[TmpBuffer[i]];
        }
    }

    *BufferSize = TiffInstance->StripDataSize;
    return TRUE;
}


BOOL
TiffReadRaw(
    HANDLE  hTiff,
    IN OUT  LPBYTE Buffer,
    IN OUT  LPDWORD BufferSize,
    IN      DWORD RequestedCompressionType,
    IN      DWORD FillOrder,
    IN      BOOL  HiRes
    )

/*++

Routine Description:

    Reads in a page of TIFF data starting at the current
    page.  The current page is set by calling TiffSeekToPage.
    Returns the data with the RequestedCompressionType and FillOrder
    doing conversions if necessary.

Arguments:

    hTiff               - TIFF handle returned by or TiffOpen
    Buffer              - pointer to buffer
    BufferSize          - pointer to size of buffer
    RequestedCompressionType    - type of compression desired
    FillOrder           - desired FillOrder

Return Value:

    TRUE for success, FALSE on error
    If the buffer passed in is not
    big enough, return FALSE and set BufferSize to the required size.
    If another error occurs, set BufferSize to 0 and return FALSE.

--*/

{
    PTIFF_INSTANCE_DATA TiffInstance = (PTIFF_INSTANCE_DATA) hTiff;
    PTIFF_INSTANCE_DATA TmpTiffData;   // temporary used to convert bits into
    LPBYTE              TmpBuffer;     // temporary buffer for above
    LPBYTE              CurLine;       // pointer to current scan line in Buffer
    DWORD               CompLineBytes; // number of bytes in compressed scan line
    DWORD               TotalBytes=0;  // total number of bytes in compress page
    LPBYTE              OutBufPtr;     // pointer to output buffer
    DWORD               BytesInLine;
    LPBYTE              EndOfBuffer;
    DWORD               LineWidth;
    DWORD               PageHeight;
    DWORD               i;
    DWORD               K = HiRes ? 4 : 2;


    LineWidth = TiffInstance->ImageWidth;
    PageHeight = TiffInstance->ImageHeight;

    //
    // create an in-memory tiff header (TIFF_INSTANCE_DATA) to hold the data that is converted
    // this call does not create a file because the filename is NULL
    //
    if (((HANDLE) TmpTiffData =
        TiffCreate(NULL, RequestedCompressionType, LineWidth, FillOrder, 1)) == NULL )
    {
       *BufferSize = 0;
        return FALSE;
    }

    TmpBuffer = VirtualAlloc(
        NULL,
        *BufferSize,
        MEM_COMMIT,
        PAGE_READWRITE
        );
    if (TmpBuffer == NULL) {
        TiffClose(TmpTiffData);
        *BufferSize = 0;
        return FALSE;
    }

    if (!TiffRead(hTiff, TmpBuffer, 0)) {
        VirtualFree( TmpBuffer, 0, MEM_RELEASE ); 
        TiffClose(TmpTiffData);
        *BufferSize = 0;
        return FALSE;
    }

    CurLine = TmpBuffer;
    OutBufPtr = Buffer;
    BytesInLine = TiffInstance->BytesPerLine;
    EndOfBuffer = TmpBuffer + (PageHeight * BytesInLine);

    i = 0;
    while (CurLine < EndOfBuffer)
    {
        switch( RequestedCompressionType ) {
            case TIFF_COMPRESSION_MH:
                EncodeFaxDataMhCompression( TmpTiffData, CurLine, LineWidth );
                break;

            case TIFF_COMPRESSION_MR:
                if (i++ % K == 0) {
                    EncodeFaxDataMhCompression( TmpTiffData, CurLine, LineWidth );
                } else {
                    EncodeFaxDataMmrCompression( TmpTiffData, CurLine, LineWidth );
                }
                break;

            case TIFF_COMPRESSION_MMR:
                EncodeFaxDataMmrCompression( TmpTiffData, CurLine, LineWidth );
                break;
        }

        FlushBits( TmpTiffData );

        CompLineBytes = (DWORD)(TmpTiffData->bitbuf - &TmpTiffData->Buffer[FAXBYTES]);
        TmpTiffData->bitbuf = &TmpTiffData->Buffer[FAXBYTES];

        CopyMemory( OutBufPtr, TmpTiffData->bitbuf, CompLineBytes );
        ZeroMemory(TmpTiffData->bitbuf, FAXBYTES);
        TotalBytes += CompLineBytes;

        CurLine += BytesInLine;
        OutBufPtr += CompLineBytes;
    }

    *BufferSize = TotalBytes;
    VirtualFree( TmpBuffer, 0, MEM_RELEASE);

    TiffClose(TmpTiffData);
    return TRUE;
}


BOOL
TiffRead(
    HANDLE hTiff,
    LPBYTE TiffData,
    DWORD PadLength
    )

/*++

Routine Description:

    Reads in a page of TIFF data starting at the current
    page.  The current page is set by calling TiffSeekToPage.
    This always returns the data with FillOrder FILLORDER_LSB2MSB

Arguments:

    hTiff               - TIFF handle returned by TiffCreate or TiffOpen

Return Value:

    TRUE for success, FALSE on error

--*/

{
    switch( ((PTIFF_INSTANCE_DATA) hTiff)->CompressionType ) {
        case TIFF_COMPRESSION_NONE:
            return DecodeUnCompressedFaxData( (PTIFF_INSTANCE_DATA) hTiff, TiffData, FALSE, PadLength );

        case TIFF_COMPRESSION_MH:
            return DecodeMHFaxData( (PTIFF_INSTANCE_DATA) hTiff, TiffData, FALSE, PadLength );

        case TIFF_COMPRESSION_MR:
            return DecodeMRFaxData( (PTIFF_INSTANCE_DATA) hTiff, TiffData, FALSE, PadLength );

        case TIFF_COMPRESSION_MMR:
            return DecodeMMRFaxData( (PTIFF_INSTANCE_DATA) hTiff, TiffData, FALSE, PadLength );
    }

    return FALSE;
}


BOOL
TiffSeekToPage(
    HANDLE hTiff,
    DWORD PageNumber,
    DWORD FillOrder
    )

/*++

Routine Description:

    Positions the TIFF file to the requested page.  The next
    TiffRead call gets this page's data.

Arguments:

    hTiff               - TIFF handle returned by TiffCreate or TiffOpen
    PageNumber          - Requested page number

Return Value:

    TRUE for success, FALSE on error

--*/

{
    PTIFF_INSTANCE_DATA TiffInstance = (PTIFF_INSTANCE_DATA) hTiff;
    WORD                NumDirEntries;
    DWORD               IfdOffset;
    DWORD               PageCount;
    DWORD               i;
    DWORD               j;
    LPBYTE              dataPtr;
    WORD                PrevTagId;
    PSTRIP_INFO         StripInfo = NULL;
    DWORD               StripCount;
    PTIFF_TAG           TiffTags;
    DWORD               CompressionType;


    Assert(TiffInstance);

    if (PageNumber > TiffInstance->PageCount) {
        return FALSE;
    }

    PageCount = 0;

    if (PageNumber == TiffInstance->CurrPage + 1) {

        //
        // get the count of tags in this IFD
        //

        IfdOffset = TiffInstance->IfdOffset;

        NumDirEntries = *(LPWORD)(TiffInstance->fPtr + IfdOffset);

    } else {

        IfdOffset = TiffInstance->TiffHdr.IFDOffset;

        while ( IfdOffset ) {

            //
            // get the count of tags in this IFD
            //
            NumDirEntries = *(LPWORD)(TiffInstance->fPtr + IfdOffset);

            //
            // increment the page counter and bail if ready
            //
            PageCount += 1;
            if (PageCount == PageNumber) {
                break;
            }

            //
            // get the next IFD offset
            //
            IfdOffset = *(UNALIGNED DWORD *)(TiffInstance->fPtr + (NumDirEntries * sizeof(TIFF_TAG)) + IfdOffset + sizeof(WORD));

        }

    }

    if (!IfdOffset) {
        goto error_exit;
    }

    //
    // set the tag pointer
    //
    TiffTags = (PTIFF_TAG)(TiffInstance->fPtr + IfdOffset + sizeof(WORD));

    //
    // get the next IFD offset
    //
    TiffInstance->IfdOffset = *(UNALIGNED DWORD *)(TiffInstance->fPtr + (NumDirEntries * sizeof(TIFF_TAG)) + IfdOffset + sizeof(WORD));

    //
    // walk the tags and pick out the info we need
    //
    for (i=0,PrevTagId=0; i<NumDirEntries; i++) {

        //
        // verify that the tags are in ascending order
        //
        if (TiffTags[i].TagId < PrevTagId) {
            goto error_exit;
        }

        PrevTagId = TiffTags[i].TagId;

        switch( TiffTags[i].TagId ) {

            case TIFFTAG_STRIPOFFSETS:

                StripInfo = (PSTRIP_INFO) MemAlloc(
                    TiffTags[i].DataCount * sizeof(STRIP_INFO)
                    );

                if (!StripInfo) {
                    goto error_exit;
                }

                StripCount = TiffTags[i].DataCount;

                for (j=0; j<TiffTags[i].DataCount; j++) {

                    StripInfo[j].Offset = GetTagData( TiffInstance->fPtr, j, &TiffTags[i] );
                    StripInfo[j].Data = TiffInstance->fPtr + StripInfo[j].Offset;

                    TiffInstance->StripOffset = StripInfo[j].Offset;

                }
                break;

            case TIFFTAG_ROWSPERSTRIP:

                TiffInstance->TagRowsPerStrip = &TiffTags[i];
                TiffInstance->RowsPerStrip = GetTagData( TiffInstance->fPtr, 0, &TiffTags[i] );
                break;

            case TIFFTAG_STRIPBYTECOUNTS:

                TiffInstance->TagStripByteCounts = &TiffTags[i];
                for (j=0; j<TiffTags[i].DataCount; j++) {

                    StripInfo[j].Bytes = GetTagData( TiffInstance->fPtr, j, &TiffTags[i] );

                    if (StripInfo[j].Offset+StripInfo[j].Bytes > TiffInstance->FileSize) {

                        //
                        // the creator of this tiff file is a liar, trim the bytes
                        //

                        DWORD Delta;

                        Delta = (StripInfo[j].Offset + StripInfo[j].Bytes) - TiffInstance->FileSize;
                        if (Delta >= StripInfo[j].Bytes) {
                            //
                            // the offset lies beyond the end of the file
                            //
                            return FALSE;
                        }

                        StripInfo[j].Bytes -= Delta;

                    }

                }
                break;

            case TIFFTAG_COMPRESSION:

                CompressionType = GetTagData( TiffInstance->fPtr, 0, &TiffTags[i] );

                switch ( CompressionType ) {

                    case COMPRESSION_NONE:
                        TiffInstance->CompressionType = TIFF_COMPRESSION_NONE;
                        break;

                    case COMPRESSION_CCITTRLE:
                        TiffInstance->CompressionType = TIFF_COMPRESSION_MH;
                        break;

                    case COMPRESSION_CCITTFAX3:
                        TiffInstance->CompressionType = TIFF_COMPRESSION_MH;
                        break;

                    case COMPRESSION_CCITTFAX4:
                        TiffInstance->CompressionType = TIFF_COMPRESSION_MMR;
                        break;

                    case COMPRESSION_LZW:
                    case COMPRESSION_OJPEG:
                    case COMPRESSION_JPEG:
                    case COMPRESSION_NEXT:
                    case COMPRESSION_CCITTRLEW:
                    case COMPRESSION_PACKBITS:
                    case COMPRESSION_THUNDERSCAN:
                        //
                        // unsupported compression type
                        //
                        goto error_exit;

                    default:
                        //
                        // unknown compression type
                        //
                        goto error_exit;

                }

                break;

            case TIFFTAG_GROUP3OPTIONS:

                CompressionType = GetTagData( TiffInstance->fPtr, 0, &TiffTags[i] );

                if (CompressionType & GROUP3OPT_2DENCODING) {
                    if (TiffInstance->CompressionType != TIFF_COMPRESSION_MMR) {
                        TiffInstance->CompressionType = TIFF_COMPRESSION_MR;
                    }

                } else if (CompressionType & GROUP3OPT_UNCOMPRESSED) {

                    TiffInstance->CompressionType = TIFF_COMPRESSION_NONE;

                }

                break;

            case TIFFTAG_IMAGEWIDTH:

                TiffInstance->ImageWidth = GetTagData( TiffInstance->fPtr, 0, &TiffTags[i] );
                TiffInstance->BytesPerLine = (TiffInstance->ImageWidth/8)+(TiffInstance->ImageWidth%8?1:0);
                break;

            case TIFFTAG_IMAGELENGTH:

                TiffInstance->TagImageLength = &TiffTags[i];
                TiffInstance->ImageHeight = GetTagData( TiffInstance->fPtr, 0, &TiffTags[i] );
                break;

            case TIFFTAG_XRESOLUTION:

                TiffInstance->XResolution = GetTagData( TiffInstance->fPtr, 0, &TiffTags[i] );
                break;

            case TIFFTAG_YRESOLUTION:

                TiffInstance->YResolution = GetTagData( TiffInstance->fPtr, 0, &TiffTags[i] );
                break;

            case TIFFTAG_PHOTOMETRIC:

                TiffInstance->PhotometricInterpretation = GetTagData( TiffInstance->fPtr, 0, &TiffTags[i] );
                break;

            case TIFFTAG_FILLORDER:

                TiffInstance->TagFillOrder = &TiffTags[i];
                TiffInstance->FillOrder = GetTagData( TiffInstance->fPtr, 0, &TiffTags[i] );
                break;

            case TIFFTAG_CLEANFAXDATA:

                TiffInstance->TagCleanFaxData = &TiffTags[i];
                TiffInstance->CleanFaxData = GetTagData( TiffInstance->fPtr, 0, &TiffTags[i] );
                break;

            case TIFFTAG_CONSECUTIVEBADFAXLINES:

                TiffInstance->TagBadFaxLines = &TiffTags[i];
                TiffInstance->BadFaxLines = GetTagData( TiffInstance->fPtr, 0, &TiffTags[i] );
                break;

        }

    }

    //
    // now go read the strip data
    //

    for (i=0,j=0; i<StripCount; i++) {

        j += StripInfo[i].Bytes;

    }

    if (j >= TiffInstance->StripDataSize) {

        if (TiffInstance->StripData) {

            VirtualFree(
                TiffInstance->StripData,
                0,
                MEM_RELEASE
                );

        }

        TiffInstance->StripDataSize = j;

        TiffInstance->StripData = VirtualAlloc(
            NULL,
            TiffInstance->StripDataSize,
            MEM_COMMIT,
            PAGE_READWRITE
            );

        if (!TiffInstance->StripData) {
            goto error_exit;
        }

    } else {

        if (TiffInstance->StripData) {
            ZeroMemory(
                TiffInstance->StripData,
                TiffInstance->StripDataSize
                );
        }

    }

    for (i=0,dataPtr=TiffInstance->StripData; i<StripCount; i++) {

        __try {

            CopyMemory(
                dataPtr,
                StripInfo[i].Data,
                StripInfo[i].Bytes
                );

            dataPtr += StripInfo[i].Bytes;

        } __except (EXCEPTION_EXECUTE_HANDLER) {


        }

    }

    if (TiffInstance->FillOrder != FillOrder) {
        for (i=0,dataPtr=TiffInstance->StripData; i<TiffInstance->StripDataSize; i++) {
            dataPtr[i] = BitReverseTable[dataPtr[i]];
        }
    }

    TiffInstance->CurrPtr = TiffInstance->StripData;
    TiffInstance->CurrPage = PageNumber;

    MemFree( StripInfo );

    return TRUE;

error_exit:

    if (StripInfo) {
        MemFree( StripInfo );
    }

    return FALSE;
}


BOOL
ConvMmrHiResToLowRes(
    LPTSTR              SrcFileName,
    LPTSTR              DestFileName
    )

{
    LPBYTE      bmiBuf[sizeof(BITMAPINFOHEADER)+(sizeof(RGBQUAD)*2)];
    PBITMAPINFO bmi = (PBITMAPINFO) bmiBuf;
    HBITMAP     hBmp;


    TIFF_INFO   TiffInfoSrc;
    HANDLE      hTiffSrc;
    DWORD       CurrPage;
    LPBYTE      pSrcBits;

    HANDLE      hTiffDest;
    LPBYTE      TiffDataDestMmr;
    DWORD       DestSize;
    LPBYTE      pDestBits;

    DWORD       DestHeight;

    HDC         hdcMem;
    INT         ScanLines;
    INT         DestScanLines;
    int         StretchMode;
    DWORD       PageCnt;
    DWORD       DestHiRes;

    BOOL        bRet = FALSE;



    CurrPage = 1;

    hTiffSrc = TiffOpen(
        SrcFileName,
        &TiffInfoSrc,
        TRUE,
        FILLORDER_MSB2LSB
        );
    if (! hTiffSrc) {
        return FALSE;
    }

    if (TiffInfoSrc.YResolution == 196) {
        DestHiRes = 1;
    }
    else {
        DestHiRes = 0;
    }


    hTiffDest = TiffCreate(
        DestFileName,
        TIFF_COMPRESSION_MMR,
        1728,
        FILLORDER_MSB2LSB,
        DestHiRes);

    if (! hTiffDest) {
        TiffClose(hTiffSrc);
        return FALSE;
    }

    pSrcBits = (LPBYTE) VirtualAlloc(
        NULL,
        TiffInfoSrc.ImageHeight * (TiffInfoSrc.ImageWidth / 8),
        MEM_COMMIT,
        PAGE_READWRITE
        );
    if (!pSrcBits) {
        TiffClose(hTiffSrc);
        TiffClose(hTiffDest);
        return FALSE;
    }


    pDestBits = (LPBYTE) VirtualAlloc(
        NULL,
        TiffInfoSrc.ImageHeight * (TiffInfoSrc.ImageWidth / 8),
        MEM_COMMIT,
        PAGE_READWRITE
        );
    if (!pDestBits) {
        TiffClose(hTiffSrc);
        TiffClose(hTiffDest);
        VirtualFree ( pSrcBits, 0 , MEM_RELEASE );
        return FALSE;
    }

    bmi->bmiHeader.biSize           = sizeof(BITMAPINFOHEADER);
    bmi->bmiHeader.biWidth          = TiffInfoSrc.ImageWidth;
    bmi->bmiHeader.biHeight         = (INT) TiffInfoSrc.ImageHeight;
    bmi->bmiHeader.biPlanes         = 1;
    bmi->bmiHeader.biBitCount       = 1;
    bmi->bmiHeader.biCompression    = 0;
    bmi->bmiHeader.biSizeImage      = 0;
    bmi->bmiHeader.biXPelsPerMeter  = 0;
    bmi->bmiHeader.biYPelsPerMeter  = 0;
    bmi->bmiHeader.biClrUsed        = 0;
    bmi->bmiHeader.biClrImportant   = 0;

    if ( ! TiffInfoSrc.PhotometricInterpretation) {
        bmi->bmiColors[0].rgbBlue       = 0;
        bmi->bmiColors[0].rgbGreen      = 0;
        bmi->bmiColors[0].rgbRed        = 0;
        bmi->bmiColors[0].rgbReserved   = 0;
        bmi->bmiColors[1].rgbBlue       = 0xff;
        bmi->bmiColors[1].rgbGreen      = 0xff;
        bmi->bmiColors[1].rgbRed        = 0xff;
        bmi->bmiColors[1].rgbReserved   = 0;
    } else {
        bmi->bmiColors[0].rgbBlue       = 0xff;
        bmi->bmiColors[0].rgbGreen      = 0xff;
        bmi->bmiColors[0].rgbRed        = 0xff;
        bmi->bmiColors[0].rgbReserved   = 0;
        bmi->bmiColors[1].rgbBlue       = 0;
        bmi->bmiColors[1].rgbGreen      = 0;
        bmi->bmiColors[1].rgbRed        = 0;
        bmi->bmiColors[1].rgbReserved   = 0;
    }


    DestHeight =  TiffInfoSrc.ImageHeight / 2;

    hdcMem = CreateCompatibleDC( NULL );
    hBmp = CreateCompatibleBitmap( hdcMem, TiffInfoSrc.ImageWidth, DestHeight );
    SelectObject( hdcMem, hBmp );

    StretchMode = STRETCH_ORSCANS;
    SetStretchBltMode(hdcMem, StretchMode);

    for (PageCnt=0; PageCnt<TiffInfoSrc.PageCount; PageCnt++) {

        if ( ! TiffSeekToPage( hTiffSrc, PageCnt+1, FILLORDER_MSB2LSB) ) {
            goto l_exit;
        }

        if (!TiffRead( hTiffSrc, (LPBYTE) pSrcBits, 0 )) {
            goto l_exit;
        }
        bmi->bmiHeader.biHeight = (INT) TiffInfoSrc.ImageHeight;

        ScanLines = StretchDIBits(
            hdcMem,
            0,
            0,
            TiffInfoSrc.ImageWidth,
            DestHeight,
            0,
            0,
            TiffInfoSrc.ImageWidth,
            TiffInfoSrc.ImageHeight,
            pSrcBits,
            bmi,
            DIB_RGB_COLORS,
            SRCCOPY
            );

        bmi->bmiHeader.biHeight = (INT) DestHeight;

        DestScanLines = GetDIBits(
            hdcMem,
            hBmp,
            0,
            DestHeight,
            pDestBits,
            bmi,
            DIB_RGB_COLORS
            );

        // reuse pSrcBits buffer
        TiffDataDestMmr = pSrcBits;

        ((PTIFF_INSTANCE_DATA) hTiffDest)->bitbuf = TiffDataDestMmr;
        ((PTIFF_INSTANCE_DATA) hTiffDest)->bitcnt = DWORDBITS;
        ((PTIFF_INSTANCE_DATA) hTiffDest)->bitdata = 0;

        if (! TiffStartPage(hTiffDest) ) {
            goto l_exit;
        }


        if ( ! EncodeFaxPageMmrCompression(
                (PTIFF_INSTANCE_DATA) hTiffDest,
                (PBYTE) pDestBits,
                1728,
                DestScanLines,
                &DestSize) ) {

            goto l_exit;
        }


        if (! TiffWriteRaw( hTiffDest, TiffDataDestMmr, DestSize) ) {
            goto l_exit;
        }

        if (! TiffEndPage(hTiffDest) ) {
            goto l_exit;
        }
    }

    bRet = TRUE;

l_exit:

    DeleteObject(hBmp);
    DeleteDC(hdcMem);

    VirtualFree ( pSrcBits, 0 , MEM_RELEASE );
    VirtualFree ( pDestBits, 0 , MEM_RELEASE );

    TiffClose(hTiffSrc);
    TiffClose(hTiffDest);

    return bRet;
}


BOOL
DrawBannerBitmap(
    LPTSTR  pBannerString,
    INT     width,
    INT     height,
    HBITMAP *phBitmap,
    PVOID   *ppBits
    )

/*++

Routine Description:

    Draw the specified banner string into a memory bitmap

Arguments:

    pBannerString - Specifies the banner string to be drawn
    width, height - Specifies the width and height of the banner bitmap (in pixels)
    phBitmap - Returns a handle to the banner bitmap
    ppBits - Returns a pointer to the banner bitmap data

Return Value:

    TRUE if successful, FALSE if there is an error

Note:

    When this function returns successful, you must call DeleteObject
    on the returned bitmap handle after you're done with the bitmap.

    Scanlines of the bitmap data always start on DWORD boundary.

--*/

{
    //
    // Information about the bitmap which is passed to CreateDIBSection
    //

    struct  {

        BITMAPINFOHEADER bmiHeader;
        RGBQUAD          bmiColors[2];

    } bitmapInfo = {

        {
            sizeof(BITMAPINFOHEADER),
            width,
            -height,
            1,
            1,
            BI_RGB,
            0,
            7874,
            7874,
            0,
            0,
        },

        //
        // Colors used in the bitmap: 0 = white, 1 = black
        //

        {
            { 255, 255, 255 },
            {   0,   0,   0 },
        }
    };

    HDC     hdcMem = NULL;
    HBITMAP hBitmap = NULL, hOldBitmap = NULL;
    PVOID   pBits = NULL;
    HFONT   hFont = NULL, hOldFont = NULL;
    RECT    rect = { 0, 0, width, height };
    LOGFONT logFont;

    //
    // Create a memory DC and a DIBSection and
    // select the bitmap into the memory DC and
    // select an appropriate sized monospace font
    //

    ZeroMemory(&logFont, sizeof(logFont));
    logFont.lfHeight = -height;
    logFont.lfWeight = FW_NORMAL;
    logFont.lfCharSet = DEFAULT_CHARSET;
    logFont.lfOutPrecision = OUT_DEFAULT_PRECIS;
    logFont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    logFont.lfQuality = DEFAULT_QUALITY;
    logFont.lfPitchAndFamily = FIXED_PITCH | FF_DONTCARE;

    if ((pBannerString != NULL && width > 0 && height > 0) &&
        (hdcMem = CreateCompatibleDC(NULL)) &&
        (hBitmap = CreateDIBSection(NULL,
                                    (LPBITMAPINFO) &bitmapInfo,
                                    DIB_RGB_COLORS,
                                    &pBits,
                                    NULL,
                                    0)) &&
        (hOldBitmap = SelectObject(hdcMem, hBitmap)) &&
        (hFont = CreateFontIndirect(&logFont)) &&
        (hOldFont = SelectObject(hdcMem, hFont)))
    {
        //
        // Use monospace system font to draw the banner string
        //

        DrawText(hdcMem,
                 pBannerString,
                 -1,
                 &rect,
                 DT_CENTER | DT_VCENTER | DT_SINGLELINE);

        //
        // Return a handle to the bitmap and a pointer to the bitmap data
        //

        *phBitmap = hBitmap;
        *ppBits = pBits;
    }
    else
    {
        *phBitmap = NULL;
        *ppBits = NULL;
    }

    //
    // Perform any necessary clean up before returning
    //

    if (hOldFont != NULL)
        SelectObject(hdcMem, hOldFont);

    if (hFont != NULL)
        DeleteObject(hFont);

    if (hOldBitmap != NULL)
        SelectObject(hdcMem, hOldBitmap);

    if (pBits == NULL && hBitmap != NULL)
        DeleteObject(hBitmap);

    if (hdcMem != NULL)
        DeleteDC(hdcMem);

    return (*ppBits != NULL);
}


BOOL
MmrAddBranding(
    LPTSTR              SrcFileName,
    LPTSTR              Branding,
    LPTSTR              BrandingEnd,
    INT                 BrandingHeight
    )

{

    INT         BrandingWidth = 1728;
    LPTSTR      DestFileName;
    TIFF_INFO   TiffInfoSrc;
    HANDLE      hTiffSrc;
    DWORD       CurrPage;
    BYTE       *pBrandBits;
    BYTE       *pMmrBrandBitsAlloc;
    DWORD      *lpdwMmrBrandBits;

    BYTE        pCleanBeforeBrandBits[4] = {0xff, 0xff, 0xff, 0xff};   // 32 blank lines at the beginning

    HANDLE      hTiffDest;
    LPDWORD     lpdwSrcBits;
    LPDWORD     lpdwSrc;
    LPDWORD     lpdwSrcEnd;

    DWORD       PageCnt;
    DWORD       DestHiRes;
    DWORD       BrandingLen = _tcslen(Branding);  // without Page#
    BOOL        bRet = FALSE;
    DWORD       DwordsOut;
    DWORD       BytesOut;
    DWORD       BitsOut;
    DWORD       BufferSize;
    DWORD       BufferUsedSize;
    DWORD       StripDataSize;
    HBITMAP     hBitmap;
    PVOID       pBannerBits;
    DWORD       TotalSrcBytes;
    DWORD       NumSrcDwords;

    DWORD       ImageHeight;

    //
    // Build Dest. file name from Src. file name
    //

    if ( (DestFileName = MemAlloc( (_tcslen(SrcFileName)+1) * sizeof (TCHAR) ) ) == NULL ) {
        return FALSE;
    }

    _tcscpy(DestFileName, SrcFileName);
    DestFileName[_tcslen(DestFileName) - 1] = TEXT('$');



    pBrandBits = MemAlloc((BrandingHeight+1) * (BrandingWidth / 8));
    if (!pBrandBits) {
        MemFree(DestFileName);
        return FALSE;
    }

    pMmrBrandBitsAlloc = MemAlloc( sizeof(DWORD) * (BrandingHeight+1) * (BrandingWidth / 8));
    if (!pMmrBrandBitsAlloc) {
        MemFree(DestFileName);
        MemFree(pBrandBits);
        return FALSE;
    }

    // align
    lpdwMmrBrandBits = (LPDWORD) ( ((ULONG_PTR) pMmrBrandBitsAlloc) & ~(3) );



    hTiffSrc = TiffOpen(
        SrcFileName,
        &TiffInfoSrc,
        TRUE,
        FILLORDER_LSB2MSB
        );

    if (! hTiffSrc) {
        MemFree(DestFileName);
        MemFree(pBrandBits);
        MemFree(pMmrBrandBitsAlloc);
        return FALSE;
    }


    BufferSize = TiffInfoSrc.ImageHeight * (TiffInfoSrc.ImageWidth / 8);

    lpdwSrcBits = (LPDWORD) VirtualAlloc(
        NULL,
        BufferSize,
        MEM_COMMIT,
        PAGE_READWRITE
        );

    if (!lpdwSrcBits) {
        MemFree(DestFileName);
        MemFree(pBrandBits);
        MemFree(pMmrBrandBitsAlloc);
        TiffClose(hTiffSrc);
        return FALSE;
    }


    if (TiffInfoSrc.YResolution == 196) {
        DestHiRes = 1;
    }
    else {
        DestHiRes = 0;
    }


    hTiffDest = TiffCreate(
        DestFileName,
        TIFF_COMPRESSION_MMR,
        1728,
        FILLORDER_LSB2MSB,
        DestHiRes);

    if (! hTiffDest) {
        MemFree(DestFileName);
        MemFree(pBrandBits);
        MemFree(pMmrBrandBitsAlloc);
        VirtualFree ( lpdwSrcBits, 0 , MEM_RELEASE );
        TiffClose(hTiffSrc);
        return FALSE;
    }

    CurrPage = 1;

    for (PageCnt=0; PageCnt<TiffInfoSrc.PageCount; PageCnt++) {

        if ( ! TiffSeekToPage( hTiffSrc, PageCnt+1, FILLORDER_LSB2MSB) ) {
            goto l_exit;
        }

        if (! TiffStartPage(hTiffDest) ) {
            goto l_exit;
        }

        //
        //      Create branding for every page.
        //
        //      Last scan line - all white:
        //  1. to isolate branding from the real image.
        //  2. to avoid an MMR-merge with the real image.
        //

        ZeroMemory(pBrandBits, (BrandingHeight+1) * (BrandingWidth / 8) );


        _stprintf( &Branding[BrandingLen], TEXT("%03d %s %03d"),
                                PageCnt+1,
                                BrandingEnd,
                                TiffInfoSrc.PageCount);

        if ( ! DrawBannerBitmap(Branding,   // banner string
                             BrandingWidth,   // width in pixels
                             BrandingHeight,   // height in pixels,
                             &hBitmap,
                             &pBannerBits)) {

            // Handle error case here
            goto l_exit;

        }

        CopyMemory(pBrandBits, pBannerBits, BrandingHeight * (BrandingWidth / 8) );

        //
        // Convert uncompressed branding to an MMR
        //

        ZeroMemory(pMmrBrandBitsAlloc, sizeof(DWORD) * (BrandingHeight+1) * (BrandingWidth / 8) );

        EncodeMmrBranding(pBrandBits, lpdwMmrBrandBits, BrandingHeight+1, BrandingWidth, &DwordsOut, &BitsOut);

        BytesOut = (DwordsOut << 2);

        DeleteObject(hBitmap);

        //
        // write Spaces 4 bytes = 32 bits = 32 blank lines.
        //

        if (! TiffWriteRaw( hTiffDest, pCleanBeforeBrandBits, 4) ) {
            goto l_exit;
        }

        //
        // write branding without the last DWORD
        //


        if (! TiffWriteRaw( hTiffDest, (LPBYTE) lpdwMmrBrandBits, BytesOut) ) {
            goto l_exit;
        }

        //
        // check the current page dimensions. Add memory if needed.
        //

        TiffGetCurrentPageData( hTiffSrc,
                                NULL,
                                &StripDataSize,
                                NULL,
                                &ImageHeight
                                );


        if (StripDataSize > BufferSize) {
            VirtualFree ( lpdwSrcBits, 0 , MEM_RELEASE );

            BufferSize = StripDataSize;

            lpdwSrcBits = (LPDWORD) VirtualAlloc(
                NULL,
                BufferSize,
                MEM_COMMIT,
                PAGE_READWRITE
                );

            if (!lpdwSrcBits) {
                MemFree(pBrandBits);
                MemFree(pMmrBrandBitsAlloc);

                TiffClose(hTiffSrc);
                TiffClose(hTiffDest);

                DeleteFile(DestFileName);

                MemFree(DestFileName);
                return FALSE;
            }
        }

        BufferUsedSize = BufferSize;


        if (BitsOut == 0) {
            //
            // Simple merge
            //
            if (!GetTiffBits( hTiffSrc, (LPBYTE) lpdwSrcBits, &BufferUsedSize, FILLORDER_LSB2MSB)) {
                goto l_exit;
            }

            // add EOLs at the end of each page

            NumSrcDwords = ( ((PTIFF_INSTANCE_DATA) hTiffSrc)->StripDataSize) >> 2;
            lpdwSrc = lpdwSrcBits + NumSrcDwords;

            *(++lpdwSrc) = 0x80000000;
            *(++lpdwSrc) = 0x80000000;
            *(++lpdwSrc) = 0x80000000;

            TotalSrcBytes = (DWORD)((lpdwSrc - lpdwSrcBits) << 2);

        }
        else {


            //
            // Read current page of the Src MMR Image.
            // Save the 1st slot for the bit-shifting merge with the Branding.
            //



            if (!GetTiffBits( hTiffSrc, (LPBYTE) (lpdwSrcBits+1), &BufferUsedSize, FILLORDER_LSB2MSB )) {
                goto l_exit;
            }


            NumSrcDwords =  ( ( ((PTIFF_INSTANCE_DATA) hTiffSrc)->StripDataSize) >> 2) + 1;
            lpdwSrc = lpdwSrcBits;
            lpdwSrcEnd = lpdwSrcBits + NumSrcDwords;

            //
            // Get the last DWORD of lpdwBrandBits
            //

            *lpdwSrcBits = *(lpdwMmrBrandBits + DwordsOut);


            // copy entire DWORDs in a middle


            while (lpdwSrc < lpdwSrcEnd) {
                *lpdwSrc += ( *(lpdwSrc+1) << BitsOut );
                lpdwSrc++;
                *lpdwSrc = *lpdwSrc >> (32 - BitsOut);
            }

            // add EOLs at the end of each page

            *(++lpdwSrc) = 0x80000000;
            *(++lpdwSrc) = 0x80000000;
            *(++lpdwSrc) = 0x80000000;

            TotalSrcBytes = (DWORD)((lpdwSrc - lpdwSrcBits) << 2);
        }


        //
        // write src image
        //

        if (! TiffWriteRaw( hTiffDest, (LPBYTE) lpdwSrcBits, TotalSrcBytes )) {
            goto l_exit;
        }


        //
        //  prepare Lines TAG. Same for all pages; min avail. lines
        //

       ((PTIFF_INSTANCE_DATA) hTiffDest)->Lines = 32 + ImageHeight + BrandingHeight + 1 ;


        if (! TiffEndPage(hTiffDest) ) {
            goto l_exit;
        }
    }

    bRet = TRUE;

l_exit:

    MemFree(pBrandBits);
    MemFree(pMmrBrandBitsAlloc);

    VirtualFree ( lpdwSrcBits, 0 , MEM_RELEASE );

    TiffClose(hTiffSrc);
    TiffClose(hTiffDest);

    if (bRet == TRUE) {
        // replace the original MH file by the new clean MMR file
        DeleteFile(SrcFileName);
        MoveFile(DestFileName, SrcFileName);
    }

    MemFree(DestFileName);

    return bRet;
}


BOOL
TiffGetCurrentPageData(
    HANDLE      hTiff,
    LPDWORD     Lines,
    LPDWORD     StripDataSize,
    LPDWORD     ImageWidth,
    LPDWORD     ImageHeight
    )
{

    PTIFF_INSTANCE_DATA TiffInstance = (PTIFF_INSTANCE_DATA) hTiff;


    Assert(TiffInstance);

    if (Lines) {
        *Lines          = TiffInstance->Lines;
    }

    if (StripDataSize) {
        *StripDataSize  = TiffInstance->StripDataSize;
    }

    if (ImageWidth) {
        *ImageWidth     = TiffInstance->ImageWidth;
    }

    if (ImageHeight) {
        *ImageHeight    = TiffInstance->ImageHeight;
    }

    return TRUE;
}


BOOL
AddStringTag(
    HANDLE hFile,
    LPWSTR String,
    WORD TagId,
    PTIFF_TAG MsTags
    )
{
    BOOL Rval = FALSE;
    LPSTR s;
    DWORD BytesRead;


    s = UnicodeStringToAnsiString( String );
    if (!s) {
        return FALSE;
    }
    MsTags->TagId = TagId;
    MsTags->DataType = TIFF_ASCII;
    MsTags->DataCount = strlen(s) + 1;
    if (strlen(s) < 4) {
        strcpy( (LPSTR) &MsTags->DataOffset, s );
        Rval = TRUE;
    } else {
        MsTags->DataOffset = SetFilePointer( hFile, 0, NULL, FILE_CURRENT );
        if (MsTags->DataOffset != 0xffffffff) {
            if (WriteFile( hFile, (LPVOID) s, strlen(s)+1, &BytesRead, NULL )) {
                Rval = TRUE;
            }
        }
    }
    MemFree( s );
    return Rval;
}


BOOL
TiffExtractFirstPage(
    LPWSTR FileName,
    LPBYTE *Buffer,
    LPDWORD BufferSize,
    LPDWORD ImageWidth,
    LPDWORD ImageHeight
    )
{
    PTIFF_INSTANCE_DATA TiffInstance;
    TIFF_INFO TiffInfo;


    TiffInstance = TiffOpen( FileName, &TiffInfo, TRUE, FILLORDER_MSB2LSB );
    if (!TiffInstance) {
        return FALSE;
    }

    *Buffer = VirtualAlloc(
        NULL,
        TiffInstance->StripDataSize,
        MEM_COMMIT,
        PAGE_READWRITE
        );
    if (!*Buffer) {
        TiffClose( TiffInstance );
        return FALSE;
    }

    CopyMemory( *Buffer, TiffInstance->StripData, TiffInstance->StripDataSize );
    *BufferSize = TiffInstance->StripDataSize;
    *ImageWidth = TiffInstance->ImageWidth;
    *ImageHeight = TiffInstance->ImageHeight;

    TiffClose( TiffInstance );

    return TRUE;
}


BOOL
TiffAddMsTags(
    LPWSTR FileName,
    PMS_TAG_INFO MsTagInfo
    )
{
    HANDLE hFile;
    TIFF_HEADER TiffHeader;
    WORD NumDirEntries;
    DWORD BytesRead;
    BOOL rVal = FALSE;
    PTIFF_TAG TiffTags = NULL;
    DWORD IfdSize;
    DWORD NextIFDOffset;
    DWORD NewIFDOffset;
    DWORD i;

    // Initialize MsTagCnt to 1 because MsTagInfo->FaxTime always gets written
    DWORD MsTagCnt = 1;
    TIFF_TAG MsTags[8] = {0};


    if (MsTagInfo->RecipName) {
        MsTagCnt += 1;
    }

    if (MsTagInfo->RecipNumber) {
        MsTagCnt += 1;
    }

    if (MsTagInfo->SenderName) {
        MsTagCnt += 1;
    }

    if (MsTagInfo->Routing) {
        MsTagCnt += 1;
    }

    if (MsTagInfo->CallerId) {
        MsTagCnt += 1;
    }

    if (MsTagInfo->Csid) {
        MsTagCnt += 1;
    }

    if (MsTagInfo->Tsid) {
        MsTagCnt += 1;
    }

    hFile = CreateFile(
        FileName,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );
    if (hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // read the tiff header
    //

    if (!ReadFile( hFile, (LPVOID) &TiffHeader, sizeof(TIFF_HEADER), &BytesRead, NULL )) {
        goto exit;
    }

    //
    // validate that the file is really a tiff file
    //

    if ((TiffHeader.Identifier != TIFF_LITTLEENDIAN) || (TiffHeader.Version != TIFF_VERSION)) {
        goto exit;
    }

    //
    // position the file to read the ifd's tag count
    //

    if (SetFilePointer( hFile, TiffHeader.IFDOffset, NULL, FILE_BEGIN ) == 0xffffffff) {
        goto exit;
    }

    //
    // read the tag count for the first ifd
    //

    if (!ReadFile( hFile, (LPVOID) &NumDirEntries, sizeof(WORD), &BytesRead, NULL )) {
        goto exit;
    }

    //
    // allocate memory for the first ifd's tags
    //

    IfdSize = NumDirEntries * sizeof(TIFF_TAG);
    TiffTags = (PTIFF_TAG) MemAlloc( IfdSize );
    if (!TiffTags) {
        goto exit;
    }

    //
    // read the the first ifd's tags
    //

    if (!ReadFile( hFile, (LPVOID) TiffTags, IfdSize, &BytesRead, NULL )) {
        goto exit;
    }

    //
    // read the next pointer
    //

    if (!ReadFile( hFile, (LPVOID) &NextIFDOffset, sizeof(DWORD), &BytesRead, NULL )) {
        goto exit;
    }

    //
    // position the file to the end
    //

    if (SetFilePointer( hFile, 0, NULL, FILE_END ) == 0xffffffff) {
        goto exit;
    }

    //
    // write out the strings
    //

    i = 0;

    if (MsTagInfo->RecipName) {
        if (AddStringTag( hFile, MsTagInfo->RecipName, TIFFTAG_RECIP_NAME, &MsTags[i] )) {
            i += 1;
        }
    }

    if (MsTagInfo->RecipNumber) {
        if (AddStringTag( hFile, MsTagInfo->RecipNumber, TIFFTAG_RECIP_NUMBER, &MsTags[i] )) {
            i += 1;
        }
    }

    if (MsTagInfo->SenderName) {
        if (AddStringTag( hFile, MsTagInfo->SenderName, TIFFTAG_SENDER_NAME, &MsTags[i] )) {
            i += 1;
        }
    }

    if (MsTagInfo->Routing) {
        if (AddStringTag( hFile, MsTagInfo->Routing, TIFFTAG_ROUTING, &MsTags[i] )) {
            i += 1;
        }
    }

    if (MsTagInfo->CallerId) {
        if (AddStringTag( hFile, MsTagInfo->CallerId, TIFFTAG_CALLERID, &MsTags[i] )) {
            i += 1;
        }
    }

    if (MsTagInfo->Tsid) {
        if (AddStringTag( hFile, MsTagInfo->Tsid, TIFFTAG_TSID, &MsTags[i] )) {
            i += 1;
        }
    }

    if (MsTagInfo->Csid) {
        if (AddStringTag( hFile, MsTagInfo->Csid, TIFFTAG_CSID, &MsTags[i] )) {
            i += 1;
        }
    }

    MsTags[i].DataOffset = SetFilePointer( hFile, 0, NULL, FILE_CURRENT );
    if (!WriteFile( hFile, (LPVOID) &MsTagInfo->FaxTime, sizeof(MsTagInfo->FaxTime), &BytesRead, NULL )) {
        goto exit;
    }
    MsTags[i].TagId = TIFFTAG_FAX_TIME;
    MsTags[i].DataType = TIFF_SRATIONAL;
    MsTags[i].DataCount = sizeof(MsTagInfo->FaxTime);

    //
    // get the current file position - this is used to set the linked list pointer
    //

    NewIFDOffset = SetFilePointer( hFile, 0, NULL, FILE_CURRENT );
    if (NewIFDOffset == 0xffffffff) {
        goto exit;
    }

    //
    // write the tag count for the first ifd
    //

    NumDirEntries += (WORD) MsTagCnt;

    if (!WriteFile( hFile, (LPVOID) &NumDirEntries, sizeof(WORD), &BytesRead, NULL )) {
        goto exit;
    }

    //
    // write out the original tags
    //

    if (!WriteFile( hFile, (LPVOID) TiffTags, IfdSize, &BytesRead, NULL )) {
        goto exit;
    }

    //
    // write out the microsoft specific tags
    //

    if (!WriteFile( hFile, (LPVOID) &MsTags, sizeof(TIFF_TAG)*MsTagCnt, &BytesRead, NULL )) {
        goto exit;
    }

    //
    // write the next pointer
    //

    if (!WriteFile( hFile, (LPVOID) &NextIFDOffset, sizeof(DWORD), &BytesRead, NULL )) {
        goto exit;
    }

    //
    // re-write the tiff header
    //

    //
    // position the file to the beginning
    //

    if (SetFilePointer( hFile, 0, NULL, FILE_BEGIN ) == 0xffffffff) {
        goto exit;
    }

    //
    // write the tiff header
    //

    TiffHeader.IFDOffset = NewIFDOffset;

    if (!WriteFile( hFile, (LPVOID) &TiffHeader, sizeof(TIFF_HEADER), &BytesRead, NULL )) {
        goto exit;
    }

    rVal = TRUE;

exit:
    MemFree( TiffTags );
    CloseHandle( hFile );
    return rVal;
}


BOOL
PrintTiffFile(
    HDC PrinterDC,
    LPWSTR FileName
    )
{
    BOOL                Rval = TRUE;
    TIFF_INFO           TiffInfo;
    HANDLE              hTiff = NULL;
    PTIFF_INSTANCE_DATA TiffInstance = NULL;
    DWORD               i,j;
    INT                 HorzRes;
    INT                 VertRes;
    BOOL                Result = FALSE;
    DWORD               VertResFactor = 1;
    PTIFF_TAG           TiffTags = NULL;
    DWORD               XRes = 0;
    DWORD               YRes = 0;
    LPBYTE              Bitmap;
    LPBYTE              dPtr;
    LPBYTE              sPtr;
    INT                 DestWidth;
    INT                 DestHeight;
    FLOAT               ScaleX;
    FLOAT               ScaleY;
    FLOAT               Scale;
    DWORD               LineSize;
    struct {

        BITMAPINFOHEADER bmiHeader;
        RGBQUAD bmiColors[2];

    } SrcBitmapInfo = {

        {
            sizeof(BITMAPINFOHEADER),                        //  biSize
            0,                                               //  biWidth
            0,                                               //  biHeight
            1,                                               //  biPlanes
            1,                                               //  biBitCount
            BI_RGB,                                          //  biCompression
            0,                                               //  biSizeImage
            7874,                                            //  biXPelsPerMeter     - 200dpi
            7874,                                            //  biYPelsPerMeter
            0,                                               //  biClrUsed
            0,                                               //  biClrImportant
        },
        {
            {
              0,                                             //  rgbBlue
              0,                                             //  rgbGreen
              0,                                             //  rgbRed
              0                                              //  rgbReserved
            },
            {
              255,                                           //  rgbBlue
              255,                                           //  rgbGreen
              255,                                           //  rgbRed
              0                                              //  rgbReserved
            }
        }
    };


    //
    // open the tiff file
    //

    hTiff = TiffOpen( FileName, &TiffInfo, TRUE, FILLORDER_MSB2LSB );
    if (hTiff == NULL) {
        goto exit;
    }

    TiffInstance = (PTIFF_INSTANCE_DATA) hTiff;

    if (!TiffInfo.PhotometricInterpretation) {
        //
        // white is zero
        //
        SrcBitmapInfo.bmiColors[1].rgbBlue         = 0;
        SrcBitmapInfo.bmiColors[1].rgbGreen        = 0;
        SrcBitmapInfo.bmiColors[1].rgbRed          = 0;
        SrcBitmapInfo.bmiColors[1].rgbReserved     = 0;
        SrcBitmapInfo.bmiColors[0].rgbBlue         = 0xFF;
        SrcBitmapInfo.bmiColors[0].rgbGreen        = 0xFF;
        SrcBitmapInfo.bmiColors[0].rgbRed          = 0xFF;
        SrcBitmapInfo.bmiColors[0].rgbReserved     = 0;
    }    

    HorzRes = GetDeviceCaps( PrinterDC, HORZRES );
    VertRes = GetDeviceCaps( PrinterDC, VERTRES );

    for (i=0; i<TiffInfo.PageCount; i++) {

        if (!TiffSeekToPage( hTiff, i+1, FILLORDER_MSB2LSB )) {
            goto exit;
        }

        if (TiffInstance->YResolution < 100) {
            SrcBitmapInfo.bmiHeader.biYPelsPerMeter /= 2;
            VertResFactor = 2;
        }
        LineSize = TiffInstance->ImageWidth / 8;
        LineSize += (TiffInstance->ImageWidth % 8) ? 1 : 0;
        Bitmap = (LPBYTE) VirtualAlloc( NULL, TiffInstance->StripDataSize+(TiffInstance->ImageHeight*sizeof(DWORD)), MEM_COMMIT, PAGE_READWRITE );
        if (Bitmap) {
            sPtr = TiffInstance->StripData;
            dPtr = Bitmap;
            for (j=0; j<TiffInstance->ImageHeight; j++) {
                CopyMemory( dPtr, sPtr, LineSize );
                sPtr += LineSize;
                dPtr = (LPBYTE) Align( 4, (ULONG_PTR)dPtr+LineSize );
            }
            StartPage( PrinterDC );
            ScaleX = (FLOAT) TiffInstance->ImageWidth / (FLOAT) HorzRes;
            ScaleY = ((FLOAT) TiffInstance->ImageHeight * VertResFactor) / (FLOAT) VertRes;
            Scale = ScaleX > ScaleY ? ScaleX : ScaleY;
            DestWidth = (int) ((FLOAT) TiffInstance->ImageWidth / Scale);
            DestHeight = (int) (((FLOAT) TiffInstance->ImageHeight * VertResFactor) / Scale);
            SrcBitmapInfo.bmiHeader.biWidth = TiffInstance->ImageWidth;
            SrcBitmapInfo.bmiHeader.biHeight = - (INT) TiffInstance->ImageHeight;
            StretchDIBits(
                PrinterDC,
                0,
                0,
                DestWidth,
                DestHeight,
                0,
                0,
                TiffInstance->ImageWidth,
                TiffInstance->ImageHeight,
                Bitmap,
                (BITMAPINFO *) &SrcBitmapInfo,
                DIB_RGB_COLORS,
                SRCCOPY
                );
            EndPage( PrinterDC );
            VirtualFree( Bitmap, 0, MEM_RELEASE );
        } else {
            Rval = FALSE;
        }
    }

exit:    
    if (hTiff) {
        TiffClose( hTiff );
    }

    return Rval;

}


BOOL
ConvertTiffFileToValidFaxFormat(
    LPWSTR TiffFileName,
    LPWSTR NewFileName,
    LPDWORD Flags
    )
{
    BOOL Rval = FALSE;
    DWORD i;
    TIFF_INFO TiffInfo;
    HANDLE hTiff = NULL;
    PTIFF_INSTANCE_DATA TiffInstance = NULL;
    PTIFF_INSTANCE_DATA TiffInstanceMmr = NULL;
    LPBYTE Buffer = NULL;
    DWORD BufferSize;
    DWORD ResultSize;
    LPBYTE CompBuffer;
    FILE_MAPPING fmTemp = {0};
    PTIFF_HEADER TiffHdr;
    LPBYTE p;
    DWORD CurrOffset;
    LPDWORD LastIfdOffset;
    PFAXIFD TiffIfd;
    DWORD CompressionType;
    DWORD G3Options;
    DWORD XResolution;
    DWORD YResolution;
    DWORD PageWidth;
    DWORD PageBytes;
    BOOL ValidFaxTiff;
    PTIFF_TAG TiffTags;
    DWORD IfdOffset;
    WORD NumDirEntries;
    BOOL ProduceUncompressedBits = FALSE;
    DWORD NewFileSize;


    *Flags = 0;

    //
    // open the tiff file
    //

    hTiff = TiffOpen( TiffFileName, &TiffInfo, TRUE, FILLORDER_MSB2LSB );
    if (hTiff == NULL) {
        *Flags |= TIFFCF_NOT_TIFF_FILE;
        goto exit;
    }

    TiffInstance = (PTIFF_INSTANCE_DATA) hTiff;

    //
    // check to see if the if good
    //

    IfdOffset = TiffInstance->TiffHdr.IFDOffset;
    ValidFaxTiff = TRUE;

    while ( IfdOffset ) {

        //
        // get the count of tags in this IFD
        //

        NumDirEntries = *(LPWORD)(TiffInstance->fPtr + IfdOffset);

        //
        // set the tag pointer
        //

        TiffTags = (PTIFF_TAG)(TiffInstance->fPtr + IfdOffset + sizeof(WORD));

        //
        // get the tiff information
        //

        CompressionType = 0;
        G3Options = 0;
        PageWidth = 0;
        XResolution = 0;
        YResolution = 0;

        for (i=0; i<NumDirEntries; i++) {
            switch( TiffTags[i].TagId ) {
                case TIFFTAG_COMPRESSION:
                    CompressionType = GetTagData( TiffInstance->fPtr, 0, &TiffTags[i] );
                    break;

                case TIFFTAG_GROUP3OPTIONS:
                    G3Options = GetTagData( TiffInstance->fPtr, 0, &TiffTags[i] );
                    break;

                case TIFFTAG_XRESOLUTION:
                    XResolution = GetTagData( TiffInstance->fPtr, 0, &TiffTags[i] );
                    break;

                case TIFFTAG_YRESOLUTION:
                    YResolution = GetTagData( TiffInstance->fPtr, 0, &TiffTags[i] );
                    break;

                case TIFFTAG_IMAGEWIDTH:
                    PageWidth = GetTagData( TiffInstance->fPtr, 0, &TiffTags[i] );
                    break;
            }
        }

        if (CompressionType == COMPRESSION_NONE) {
            *Flags |= TIFFCF_UNCOMPRESSED_BITS;
        } else if ((CompressionType == COMPRESSION_CCITTFAX3 && (G3Options & GROUP3OPT_2DENCODING)) ||
                    (CompressionType == COMPRESSION_CCITTFAX4 && PageWidth == FAXBITS))
        {
            ValidFaxTiff = TRUE;
        } else {
            //
            // unsupported compression type
            // try to use imaging program to print the tiff file,it might understand the compression scheme
            //
            ValidFaxTiff = FALSE;
            *Flags = TIFFCF_NOT_TIFF_FILE;
            goto exit;
        }

        //
        // the resolution check must account for offical Class F tiff
        // documents and pseudo fax documents created by scanners and
        // imaging applications.
        //
        // |-------------|----------|----------|---------|
        // |  scan width |  pels    |  xres    |  yres   |
        // |-------------|----------|----------|---------|
        // |             |          |          |         |
        // |   8.46/215  |  1728    |  204     |  98/196 |
        // |             |          |          |         |
        // |   8.50/216  |  1700    |  200     |  200    |
        // |             |          |          |         |
        // |-------------|----------|----------|---------|
        //

        if (XResolution > 204 || YResolution > 200 || PageWidth > FAXBITS) {
            //
            // the file cannot be converted to valid fax bits
            // so we produce a tiff file that has uncompressed bits
            // the caller can then render the uncompressed bits
            // using the fax print driver to get good fax bits
            //
            ProduceUncompressedBits = TRUE;
            *Flags |= TIFFCF_UNCOMPRESSED_BITS;
            ValidFaxTiff = FALSE;
        }

        //
        // get the next IFD offset
        //

        IfdOffset = *(UNALIGNED DWORD *)(TiffInstance->fPtr + (NumDirEntries * sizeof(TIFF_TAG)) + IfdOffset + sizeof(WORD));
    }

    if (ValidFaxTiff) {
        *Flags |= TIFFCF_ORIGINAL_FILE_GOOD;
        Rval = TRUE;
        goto exit;
    }

    PageWidth = max( TiffInstance->ImageWidth, FAXBITS );
    PageBytes = (PageWidth/8)+(PageWidth%8?1:0);

    //
    // open the temporary file to hold the new mmr tiff data
    //

    if (ProduceUncompressedBits) {
        NewFileSize = sizeof(TIFF_HEADER) + (TiffInstance->PageCount * (sizeof(FAXIFD) + (TiffInfo.ImageHeight * PageWidth)));
    } else {
        NewFileSize = GetFileSize( TiffInstance->hFile, NULL );
    }

    if (!MapFileOpen( NewFileName, FALSE, NewFileSize, &fmTemp )) {
        goto exit;
    }

    //
    // allocate a temporary buffer big enough to hold an uncompressed image
    //

    BufferSize = TiffInfo.ImageHeight * PageWidth;

    Buffer = VirtualAlloc(
        NULL,
        BufferSize,
        MEM_COMMIT,
        PAGE_READWRITE
        );
    if (!Buffer) {
        goto exit;
    }

    CompBuffer = VirtualAlloc(
        NULL,
        GetFileSize(TiffInstance->hFile,NULL),
        MEM_COMMIT,
        PAGE_READWRITE
        );
    if (!CompBuffer) {
        goto exit;
    }

    //
    // convert the tiff data to mmr
    //

    TiffHdr = (PTIFF_HEADER) fmTemp.fPtr;

    TiffHdr->Identifier = TIFF_LITTLEENDIAN;
    TiffHdr->Version = TIFF_VERSION;
    TiffHdr->IFDOffset = 0;

    p = fmTemp.fPtr + sizeof(TIFF_HEADER);
    CurrOffset = sizeof(TIFF_HEADER);
    LastIfdOffset = (LPDWORD) (p - sizeof(DWORD));

    TiffInstanceMmr = TiffCreate( NULL, TIFF_COMPRESSION_MMR, PageWidth, FILLORDER_MSB2LSB, 1 );
    if (TiffInstanceMmr == NULL) {
        goto exit;
    }

    for (i=0; i<TiffInfo.PageCount; i++) {

        //
        // position the file pointers and read the raw data
        //

        if (!TiffSeekToPage( hTiff, i+1, FILLORDER_MSB2LSB )) {
            goto exit;
        }

        //
        // get the uncompressed bits
        //

        if (!TiffRead( hTiff, Buffer, ProduceUncompressedBits ? 0 : FAXBITS )) {
            goto exit;
        }

        if (ProduceUncompressedBits) {

            ResultSize = PageBytes * TiffInstance->ImageHeight;
            CopyMemory( p, Buffer, ResultSize );

        } else {

            //
            // compress the bits
            //

            TiffInstanceMmr->bitbuf = CompBuffer;
            TiffInstanceMmr->bitcnt = DWORDBITS;
            TiffInstanceMmr->bitdata = 0;
            TiffInstanceMmr->BytesPerLine = PageBytes;

            EncodeFaxPageMmrCompression(
                TiffInstanceMmr,
                Buffer,
                PageWidth,
                TiffInstance->ImageHeight,
                &ResultSize
                );

            CopyMemory( p, CompBuffer, ResultSize );
        }

        CurrOffset += ResultSize;
        p += ResultSize;

        *LastIfdOffset = (DWORD)(p - fmTemp.fPtr);

        //
        // write the ifd
        //

        TiffIfd = (PFAXIFD) p;

        CopyMemory( TiffIfd, &FaxIFDTemplate, sizeof(FaxIFDTemplate) );

        TiffIfd->yresNum                        = TiffInstance->XResolution;
        TiffIfd->xresNum                        = TiffInstance->YResolution;
        TiffIfd->ifd[IFD_PAGENUMBER].value      = MAKELONG( i+1, 0);
        TiffIfd->ifd[IFD_IMAGEWIDTH].value      = PageWidth;
        TiffIfd->ifd[IFD_IMAGEHEIGHT].value     = TiffInstance->ImageHeight;
        TiffIfd->ifd[IFD_ROWSPERSTRIP].value    = TiffInstance->ImageHeight;
        TiffIfd->ifd[IFD_STRIPBYTECOUNTS].value = ResultSize;
        TiffIfd->ifd[IFD_STRIPOFFSETS].value    = CurrOffset - ResultSize;
        TiffIfd->ifd[IFD_XRESOLUTION].value     = CurrOffset + FIELD_OFFSET( FAXIFD, xresNum );
        TiffIfd->ifd[IFD_YRESOLUTION].value     = CurrOffset + FIELD_OFFSET( FAXIFD, yresNum );
        TiffIfd->ifd[IFD_SOFTWARE].value        = CurrOffset + FIELD_OFFSET( FAXIFD, software );
        TiffIfd->ifd[IFD_FILLORDER].value       = FILLORDER_MSB2LSB;
        TiffIfd->ifd[IFD_COMPRESSION].value     = ProduceUncompressedBits ? COMPRESSION_NONE : TIFF_COMPRESSION_MMR;
        TiffIfd->ifd[IFD_G3OPTIONS].value       = ProduceUncompressedBits ? 0 : GROUP3OPT_FILLBITS | GROUP3OPT_2DENCODING;

        //
        // update the page pointers
        //

        LastIfdOffset = (LPDWORD) (p + FIELD_OFFSET(FAXIFD,nextIFDOffset));
        CurrOffset += sizeof(FAXIFD);
        p += sizeof(FAXIFD);
    }

    Rval = TRUE;

exit:
    if (fmTemp.hFile) {
        MapFileClose( &fmTemp, CurrOffset );
    }
    if (hTiff) {
        TiffClose( hTiff );
    }
    if (TiffInstanceMmr) {
        TiffClose( TiffInstanceMmr );
    }
    if (Buffer) {
        VirtualFree( Buffer, 0, MEM_RELEASE);
    }
    if (CompBuffer) {
        VirtualFree( CompBuffer, 0, MEM_RELEASE);
    }

    return Rval;
}


BOOL
MergeTiffFiles(
    LPWSTR BaseTiffFile,
    LPWSTR NewTiffFile
    )
{
    BOOL Rval = TRUE;
    FILE_MAPPING fmBase;
    FILE_MAPPING fmNew;
    LPBYTE p;
    DWORD NextIfdOffset;
    WORD TagCount;
    PTIFF_TAG TiffTag;
    DWORD i;
    DWORD j;
    LPBYTE StripOffsets;
    DWORD DataSize;
    DWORD Delta;
    DWORD Space;


    //
    // open the files
    //

    if (!MapFileOpen( NewTiffFile, TRUE, 0, &fmNew )) {
        return FALSE;
    }

    if (!MapFileOpen( BaseTiffFile, FALSE, fmNew.fSize, &fmBase )) {
        MapFileClose( &fmNew, 0 );
        return FALSE;
    }

    //
    // append the new file to the end of the base file
    //

    p = fmNew.fPtr + sizeof(TIFF_HEADER);
    CopyMemory( fmBase.fPtr+fmBase.fSize, p, fmNew.fSize-sizeof(TIFF_HEADER) );

    //
    // fix up the ifd pointers in the appended tiff data
    //

    Delta = fmBase.fSize - sizeof(TIFF_HEADER);

    NextIfdOffset = ((PTIFF_HEADER)fmNew.fPtr)->IFDOffset;
    while (NextIfdOffset) {
        p = fmBase.fPtr + NextIfdOffset + Delta;
        TagCount = *((LPWORD)p);
        //
        // fixup the data offsets in the tiff tags
        //
        TiffTag = (PTIFF_TAG) (p + sizeof(WORD));
        for (i=0; i<TagCount; i++) {
            DataSize = TiffDataWidth[TiffTag[i].DataType];
            Space = TiffTag[i].DataCount * DataSize;
            if (Space > 4) {
                TiffTag[i].DataOffset += Delta;
            }
            if (TiffTag[i].TagId == TIFFTAG_STRIPOFFSETS) {
                if (Space > 4) {
                    StripOffsets = (LPBYTE) (fmBase.fPtr + TiffTag[i].DataOffset);
                    for (j=0; j<TiffTag[i].DataCount; j++) {
                        if (TiffTag[i].DataType == TIFF_SHORT) {
                            *((LPWORD)StripOffsets) += (WORD)Delta;
                        } else {
                            *((LPDWORD)StripOffsets) += Delta;
                        }
                        StripOffsets += DataSize;
                    }
                } else {
                    if (TiffTag[i].DataCount > 1) {
                        Rval = FALSE;
                        goto exit;
                    }
                    TiffTag[i].DataOffset += Delta;
                }
            }
        }
        p = p + sizeof(WORD) + (TagCount * sizeof(TIFF_TAG));
        NextIfdOffset = *((LPDWORD)p);
        if (NextIfdOffset) {
            *((LPDWORD)p) = NextIfdOffset + Delta;
        }
    }

    //
    // find the last ifd offset in the chain for the base
    // file and change it to point to the first ifd in the
    // data that was appended
    //

    NextIfdOffset = ((PTIFF_HEADER)fmBase.fPtr)->IFDOffset;
    while (NextIfdOffset) {
        p = fmBase.fPtr + NextIfdOffset;
        TagCount = *((LPWORD)p);
        p = p + sizeof(WORD) + (TagCount * sizeof(TIFF_TAG));
        NextIfdOffset = *((LPDWORD)p);
    }

    *((LPDWORD)p) = (DWORD)(Delta + ((PTIFF_HEADER)fmNew.fPtr)->IFDOffset);

exit:
    //
    // close the files
    //

    MapFileClose( &fmBase, fmBase.fSize+fmNew.fSize-sizeof(TIFF_HEADER) );
    MapFileClose( &fmNew, 0 );

    return Rval;
}

BOOL
TiffRecoverGoodPages(
    LPTSTR SrcFileName,    
    LPDWORD RecoveredPages,
    LPDWORD TotalPages
    )

/*++

Routine Description:

    Try to recover the good data out of the source and put it into the destination file

Arguments:

    SrcFileName            - source file name    
    RecoveredPages         - number of pages we were able to recover
    TotalPages             - total pages in the tiff file

Return Value:

    TRUE for success, FALSE for failure.

--*/

{
    
    TIFF_INFO           TiffInfo;
    PTIFF_INSTANCE_DATA TiffInstance = NULL;
    BOOL                bSuccess = FALSE;


    if (!SrcFileName || !RecoveredPages || !TotalPages) {
        return FALSE;
    }

    *RecoveredPages = 0;
    *TotalPages = 0;
    
    TiffInstance = (PTIFF_INSTANCE_DATA) TiffOpen(SrcFileName,&TiffInfo,FALSE,FILLORDER_LSB2MSB);

    if (!TiffInstance) {
        *TotalPages = 0;
        goto exit;
    }

    *TotalPages = TiffInfo.PageCount;


    if (TiffInstance->ImageHeight) {
        //
        // should be view-able
        //
        TiffClose( (HANDLE) TiffInstance );
        return TRUE;
    }

    if (*TotalPages <=1) {
        //
        // no data to recover
        //
        goto exit;
    }

    switch (TiffInstance->CompressionType) {
    
        case TIFF_COMPRESSION_MH: 
            
            if (!PostProcessMhToMmr( (HANDLE) TiffInstance, TiffInfo, NULL )) {
                *RecoveredPages = TiffInfo.PageCount;                
                goto exit;
            }
            break;

        case TIFF_COMPRESSION_MR:            

            if (!PostProcessMrToMmr( (HANDLE) TiffInstance, TiffInfo, NULL )) {
                goto exit;
            }
            break;

        case TIFF_COMPRESSION_MMR:
            bSuccess = TRUE;
            goto exit;
            break;
        default:
        //
        // unexpected compression type
        //
        DebugPrint((TEXT("TiffRecoverGoodPages: %s: Unexpected Compression type %d\n"),
                   TiffInstance->FileName,
                   TiffInstance->CompressionType));
        goto exit;
    }

    *RecoveredPages = TiffInfo.PageCount;
    *TotalPages    += 1;

    bSuccess = TRUE;

exit:
    
    return bSuccess;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\tiff\test\bmp2tiff.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    bmp2tiff.c

Abstract:

    This file contains support for converting a
    Windows BMP file to a TIFF file.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "test.h"
#pragma hdrstop




DWORD
ConvertBmpToTiff(
    LPTSTR BmpFile,
    LPTSTR TiffFile,
    DWORD CompressionType
    )

/*++

Routine Description:

    Converts a BMP file to a TIFF file.

Arguments:

    BmpFile             - BMP file name
    TiffFile            - TIFF file name
    CompressionType     - Compression method, see tifflib.h

Return Value:

    None.

--*/

{
    HANDLE hFileIn;
    HANDLE hMapIn;
    LPVOID FilePtrIn;
    HANDLE hTiff;
    PBMPINFO BmpInfo;
    DWORD LineWidth;
    DWORD FileSize;
    LPBYTE Bits;
    DWORD i,j;
    LPBYTE SrcPtr;
    DWORD RealWidth;
    BYTE BitBuffer[(1728/8)*2];


    hFileIn = CreateFile(
        BmpFile,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );
    if (hFileIn != INVALID_HANDLE_VALUE) {
        return GetLastError();
    }

    hMapIn = CreateFileMapping(
        hFileIn,
        NULL,
        PAGE_READONLY | SEC_COMMIT,
        0,
        0,
        NULL
        );
    if (!hMapIn) {
        return GetLastError();
    }

    FilePtrIn = MapViewOfFile(
        hMapIn,
        FILE_MAP_READ,
        0,
        0,
        0
        );
    if (!FilePtrIn) {
        return GetLastError();
    }

    FileSize = GetFileSize( hFileIn, NULL );

    BmpInfo = (PBMPINFO) FilePtrIn;

    LineWidth = BmpInfo->SizeImage / BmpInfo->Height;
    Bits = (LPBYTE) ( (LPBYTE)FilePtrIn + BmpInfo->Offset );
    SrcPtr = ((LPBYTE)FilePtrIn + BmpInfo->Offset) + (LineWidth * (BmpInfo->Height - 1));
    RealWidth = Align( 8, BmpInfo->Width ) / 8;

    hTiff = TiffCreate( TiffFile, CompressionType, LineWidth*8, 1, 1 );
    if (!hTiff) {
        return GetLastError();
    }

    TiffStartPage( hTiff );

    for (i=0; i<BmpInfo->Height; i++) {
        FillMemory( BitBuffer, sizeof(BitBuffer), 0xff );
        CopyMemory( BitBuffer, SrcPtr, RealWidth );
        if (BmpInfo->Width % 8) {
            BitBuffer[BmpInfo->Width/8] |= 0xf;
        }
        for (j=0; j<sizeof(BitBuffer); j++) {
            BitBuffer[j] ^= 0xff;
        }
        SrcPtr -= LineWidth;
        TiffWrite( hTiff, BitBuffer );
    }

    TiffEndPage( hTiff );

    UnmapViewOfFile( FilePtrIn );
    CloseHandle( hMapIn );
    CloseHandle( hFileIn );

    TiffClose( hTiff );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\tiff\test\postproc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    test.c

Abstract:

    This file contains the main entrypooint
    for the TIFF library test program.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "test.h"
#pragma hdrstop



VOID
PostProcessTiffFile(
    LPTSTR TiffFile
    )
{
    if (!TiffPostProcess( TiffFile )) {
        _tprintf( TEXT("failed to post process the TIFF file\n") );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\util\debugprint.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "faxreg.h"
#include "faxutil.h"

VOID
ConsoleDebugPrint(
    LPCTSTR buf
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\tiff\test\test.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    test.c

Abstract:

    This file contains the main entrypooint
    for the TIFF library test program.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "test.h"
#pragma hdrstop




int _cdecl
main(
    int argc,
    char *argvA[]
    )

/*++

Routine Description:

    Main entrypoint to test TIFF library program.

Arguments:

    argc    - Argument count
    argvA   - Ansii argument list

Return Value:

    None.

--*/

{
    LPTSTR *argv;
    DWORD i,j;
    DWORD CompressionType = (DWORD)-1;
    BOOL PrintTiff = FALSE;
    BOOL TiffToBmp = FALSE;
    BOOL PostProcess = FALSE;
    BOOL PreProcess = FALSE;
    BOOL Recover = FALSE;

    DWORD Total,Recovered;


#ifdef UNICODE
    argv = CommandLineToArgvW( GetCommandLine(), &argc );
#else
    argv = argvA;
#endif

    HeapInitialize(NULL,NULL,NULL,0);
    FaxTiffInitialize();

    for (i=1; i<(DWORD)argc; i++) {
        if ((argv[i][0] == TEXT('-')) || (argv[i][0] == TEXT('/'))) {
            if (tolower( argv[i][1] ) == TEXT('c')) {
                //
                // specify compression method
                //
                if (argv[i][2] == TEXT(':')) {
                    j = 3;
                } else {
                    j = 2;
                }
                if (_istdigit(argv[i][j])) {
                    if (argv[i][j] == TEXT('0')) {
                        CompressionType = TIFF_COMPRESSION_NONE;
                    } else if (argv[i][j] == TEXT('1')) {
                        CompressionType = TIFF_COMPRESSION_MH;
                    } else if (argv[i][j] == TEXT('2')) {
                        CompressionType = TIFF_COMPRESSION_MR;
                    }
                }
            }

            if (tolower( argv[i][1] ) == TEXT('p')) {
                PrintTiff = TRUE;
            }

            if (tolower( argv[i][1] ) == TEXT('r')) {
                Recover = TRUE;
            }

            if (tolower( argv[i][1] ) == TEXT('d')) {
                TiffToBmp = TRUE;
            }

            if (tolower( argv[i][1] ) == TEXT('z')) {
                PostProcess = TRUE;
            }

            if (tolower( argv[i][1] ) == TEXT('m')) {
                PreProcess = TRUE;
            }

            if (tolower( argv[i][1] ) == TEXT('?')) {
            }

        } else {
            break;
        }
    }

    _tprintf(L"1: %8x\n2: %8x\n", (0xFFFFFFFC) , ~(0x3));

    if (PostProcess) {

        TiffPostProcessFast( argv[i], NULL );

    } else if (PreProcess) {       

       TiffPreProcess( argv[i], CompressionType );
    

    } else if (PrintTiff) {
        TCHAR  Branding[300];
        _stprintf(Branding, TEXT("09/24/1996 12:03AM  FROM: 12345678901234567890  TO: 12345678901234567890 ") );

        MmrAddBranding( argv[i], Branding, TEXT("OF"), 22);


/*
        GetProfileString( TEXT("windows"),
            TEXT("device"),
            NULL,
            (LPTSTR) &Printer,
            256 );

        TiffPrint( argv[i], Printer, &Result );
*/
    } else if (Recover) {
        if (argc < 2) {
            _tprintf( TEXT("missing arguments\n") );
            return -1;
        }

        Recover = TiffRecoverGoodPages( argv[i], &Recovered, &Total );

        _tprintf(L"TiffRecoverPages returns %s, Recovered = %d, Total = %d\n",Recover?L"TRUE":L"FALSE",Recovered,Total);

    } else if (TiffToBmp) {

        if (argc < 2) {
            _tprintf( TEXT("missing arguments\n") );
            return -1;
        }

        ConvertTiffToBmp( argv[i], argv[i+1] );

    } else if (CompressionType != (DWORD)-1) {

        if (argc < 2) {
            _tprintf( TEXT("missing arguments\n") );
            return -1;
        }

        ConvertBmpToTiff( argv[i], argv[i+1], CompressionType );

    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\util\debug.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This file implements the debug code for the
    fax project.  All components that require
    debug prints, asserts, etc.

Author:

    Wesley Witt (wesw) 22-Dec-1995

Environment:

    User Mode

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "faxreg.h"
#include "faxutil.h"


BOOL ConsoleDebugOutput = FALSE;
INT FaxDebugLevel = -1;

#if 0
VOID
ConsoleDebugPrint(
    LPCTSTR buf
    )
{
}
#endif


DWORD
GetDebugLevel(
    VOID
    )
{
    DWORD rc;
    DWORD err;
    DWORD size;
    DWORD type;
    HKEY  hkey;

    err = RegOpenKey(HKEY_LOCAL_MACHINE,
                     REGKEY_FAXSERVER,
                     &hkey);

    if (err != ERROR_SUCCESS)
        return 0;

    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,
                          REGVAL_DBGLEVEL,
                          0,
                          &type,
                          (LPBYTE)&rc,
                          &size);

    if (err != ERROR_SUCCESS || type != REG_DWORD)
        rc = 0;

    RegCloseKey(hkey);

    return rc;
}

void
dprintf(
    LPCTSTR Format,
    ...
    )

/*++

Routine Description:

    Prints a debug string

Arguments:

    format      - printf() format string
    ...         - Variable data

Return Value:

    None.

--*/

{
    TCHAR buf[1024];
    DWORD len;
    va_list arg_ptr;
    static BOOL bChecked = FALSE;

    if (!bChecked) {
        FaxDebugLevel = (INT) GetDebugLevel();
        bChecked = TRUE;
    }

    if (FaxDebugLevel <= 0) {
        return;
    }

    va_start(arg_ptr, Format);

    _vsntprintf(buf, sizeof(buf), Format, arg_ptr);

    ConsoleDebugPrint( buf );

    len = _tcslen( buf );
    if (buf[len-1] != TEXT('\n')) {
        buf[len] = TEXT('\r');
        buf[len+1] = TEXT('\n');
        buf[len+2] = 0;
    }

    OutputDebugString( buf );
}


VOID
AssertError(
    LPCTSTR Expression,
    LPCTSTR File,
    ULONG  LineNumber
    )

/*++

Routine Description:

    Thie function is use together with the Assert MACRO.
    It checks to see if an expression is FALSE.  if the
    expression is FALSE, then you end up here.

Arguments:

    Expression  - The text of the 'C' expression
    File        - The file that caused the assertion
    LineNumber  - The line number in the file.

Return Value:

    None.

--*/

{
    dprintf(
        TEXT("Assertion error: [%s]  %s @ %d\n"),
        Expression,
        File,
        LineNumber
        );

    __try {
        DebugBreak();
    } __except (UnhandledExceptionFilter(GetExceptionInformation())) {
        // Nothing to do in here.
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\tiff\test\tiff2bmp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tiff2bmp.c

Abstract:

    This file contains support for converting a
    TIFF file to a Windows BMP file.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "test.h"
#include "tiff.h"
#include <winfax.h>
#pragma hdrstop



void PrintTheTiff(
    LPTSTR TiffFile
    ) 
{
    FAX_PRINT_INFO PrintInfo;
    FAX_CONTEXT_INFOW ContextInfo;
    LPTSTR FullPath = TEXT("c:\\temp\\thetiff.tif");
    DWORD TmpFaxJobId;
    BOOL Rslt;

    ZeroMemory( &PrintInfo, sizeof(FAX_PRINT_INFOW) );

    PrintInfo.SizeOfStruct = sizeof(FAX_PRINT_INFOW);
    PrintInfo.OutputFileName = FullPath;

    ZeroMemory( &ContextInfo, sizeof(FAX_CONTEXT_INFOW) );
    ContextInfo.SizeOfStruct = sizeof(FAX_CONTEXT_INFOW);

    if (!FaxStartPrintJobW( NULL, &PrintInfo, &TmpFaxJobId, &ContextInfo )) {
        DeleteFile( FullPath );
        SetLastError( ERROR_INVALID_FUNCTION );
        return;
    }

    Rslt = PrintTiffFile( ContextInfo.hDC, TiffFile );

    EndDoc( ContextInfo.hDC );
    DeleteDC( ContextInfo.hDC );

}






DWORD
ConvertTiffToBmp(
    LPTSTR TiffFile,
    LPTSTR BmpFile
    )

/*++

Routine Description:

    Converts a TIFF file to a BMP file.

Arguments:

    TiffFile            - TIFF file name
    BmpFile             - BMP file name

Return Value:

    None.

--*/

{
    HANDLE hTiff;
    HANDLE hBmp;
    HANDLE hMap;
    LPVOID fPtr;
    PBMPINFO BmpInfo;
    PWINRGBQUAD Palette;
    LPBYTE dPtr;
    LPBYTE sPtr;
    DWORD i,j;
    LPBYTE BmpData;
    TIFF_INFO TiffInfo;


    hTiff = TiffOpen( TiffFile, &TiffInfo, TRUE, FILLORDER_MSB2LSB );
    if (!hTiff) {
        _tprintf( TEXT("could not open tiff file\n") );
        return 0;
    }

    _tprintf( TEXT("ImageWidth:\t%d\n"),TiffInfo.ImageWidth);
    _tprintf( TEXT("ImageHeight:\t%d\n"),TiffInfo.ImageHeight);
    _tprintf( TEXT("PageCount:\t%d\n"),TiffInfo.PageCount);
    _tprintf( TEXT("Photometric:\t%d\n"),TiffInfo.PhotometricInterpretation);
    _tprintf( TEXT("ImageSize:\t%d\n"),TiffInfo.ImageSize);
    _tprintf( TEXT("Compression:\t%d\n"),TiffInfo.CompressionType);
    _tprintf( TEXT("FillOrder:\t%d\n"),TiffInfo.FillOrder);
    _tprintf( TEXT("YResolution:\t%d\n"),TiffInfo.YResolution);


    BmpData = VirtualAlloc(
        NULL,
        TiffInfo.ImageHeight * (TiffInfo.ImageWidth / 8),
        MEM_COMMIT,
        PAGE_READWRITE
        );
    if (!BmpData) {
        _tprintf( TEXT("could allocate memory for bmp data\n") );
        return 0;
    }

    if (!TiffRead( hTiff, BmpData,0 )) {
        _tprintf( TEXT("could read tiff data\n") );
        TiffClose( hTiff );
        return 0;
    }

    hBmp = CreateFile(
        BmpFile,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        0,
        NULL
        );
    if (hBmp == INVALID_HANDLE_VALUE) {
        return 0;
    }

    hMap = CreateFileMapping(
        hBmp,
        NULL,
        PAGE_READWRITE | SEC_COMMIT,
        0,
        1024*1024*3,  // 3 meg
        NULL
        );
    if (!hMap) {
        return GetLastError();
    }

    fPtr = MapViewOfFile(
        hMap,
        FILE_MAP_WRITE,
        0,
        0,
        0
        );
    if (!fPtr) {
        return GetLastError();
    }

    BmpInfo = (PBMPINFO) fPtr;
    Palette = (PWINRGBQUAD) (BmpInfo + 1);

    BmpInfo->Type           =  0x4d42;
    BmpInfo->FileSize       =  sizeof(BMPINFO) + ((TiffInfo.ImageWidth / 8) * TiffInfo.ImageHeight);
    BmpInfo->Reserved1      =  0;
    BmpInfo->Reserved2      =  0;
    BmpInfo->Offset         =  sizeof(BMPINFO) + (sizeof(WINRGBQUAD) * 2);
    BmpInfo->Size           =  sizeof(BMPINFO) - FIELD_OFFSET(BMPINFO,Size);
    BmpInfo->Width          =  TiffInfo.ImageWidth;
    BmpInfo->Height         =  TiffInfo.ImageHeight;
    BmpInfo->Planes         =  1;
    BmpInfo->BitCount       =  1;
    BmpInfo->Compression    =  0;
    BmpInfo->SizeImage      =  (TiffInfo.ImageWidth / 8) * TiffInfo.ImageHeight;
    BmpInfo->XPelsPerMeter  =  0;
    BmpInfo->YPelsPerMeter  =  0;
    BmpInfo->ClrUsed        =  0;
    BmpInfo->ClrImportant   =  0;

if (TiffInfo.PhotometricInterpretation) {
    //
    // minimum is black.
    //
    Palette[1].rgbBlue      = 0;
    Palette[1].rgbGreen     = 0;
    Palette[1].rgbRed       = 0;
    Palette[1].rgbReserved  = 0;

    Palette[0].rgbBlue      = 0xff;
    Palette[0].rgbGreen     = 0xff;
    Palette[0].rgbRed       = 0xff;
    Palette[0].rgbReserved  = 0;
} else {
    //
    // minimum is white
    //
    Palette[0].rgbBlue      = 0;
    Palette[0].rgbGreen     = 0;
    Palette[0].rgbRed       = 0;
    Palette[0].rgbReserved  = 0;

    Palette[1].rgbBlue      = 0xff;
    Palette[1].rgbGreen     = 0xff;
    Palette[1].rgbRed       = 0xff;
    Palette[1].rgbReserved  = 0;
}

    sPtr = (LPBYTE) (BmpData + ((TiffInfo.ImageHeight-1)*(TiffInfo.ImageWidth/8)));
    dPtr = (LPBYTE) ((LPBYTE)(Palette + 2));

    //
    // capture the data
    //
    for (i=0; i<TiffInfo.ImageHeight; i++) {

        CopyMemory( dPtr, sPtr, TiffInfo.ImageWidth/8 );

        for (j=0; j<(TiffInfo.ImageWidth/8); j++) {
            dPtr[j] ^= 0xff;
        }

        sPtr -= (TiffInfo.ImageWidth/8);
        dPtr += (TiffInfo.ImageWidth/8);

    }

    UnmapViewOfFile( fPtr );
    CloseHandle( hMap );
    CloseHandle( hBmp );

    TiffClose( hTiff );

    PrintTheTiff(TiffFile);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\tiff\test\test.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    test.h

Abstract:

    This file is the private header file for the
    TIFF test program. All source files in this
    program include this header only.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

#include "tifflib.h"
#include "faxutil.h"
#include "tiff.h"


#define Align(p, x)  (((x) & ((p)-1)) ? (((x) & ~((p)-1)) + p) : (x))


#pragma pack(1)

typedef struct _WINRGBQUAD {
    BYTE   rgbBlue;                 // Blue Intensity Value
    BYTE   rgbGreen;                // Green Intensity Value
    BYTE   rgbRed;                  // Red Intensity Value
    BYTE   rgbReserved;             // Reserved (should be 0)
} WINRGBQUAD, *PWINRGBQUAD;

typedef struct _BMPINFO {
    WORD   Type;                    //  File Type Identifier
    DWORD  FileSize;                //  Size of File
    WORD   Reserved1;               //  Reserved (should be 0)
    WORD   Reserved2;               //  Reserved (should be 0)
    DWORD  Offset;                  //  Offset to bitmap data
    DWORD  Size;                    //  Size of Remianing Header
    DWORD  Width;                   //  Width of Bitmap in Pixels
    DWORD  Height;                  //  Height of Bitmap in Pixels
    WORD   Planes;                  //  Number of Planes
    WORD   BitCount;                //  Bits Per Pixel
    DWORD  Compression;             //  Compression Scheme (0=none)
    DWORD  SizeImage;               //  Size of bitmap in bytes
    DWORD  XPelsPerMeter;           //  Horz. Resolution in Pixels/Meter
    DWORD  YPelsPerMeter;           //  Vert. Resolution in Pixels/Meter
    DWORD  ClrUsed;                 //  Number of Colors in Color Table
    DWORD  ClrImportant;            //  Number of Important Colors
} BMPINFO, *UNALIGNED PBMPINFO;

#pragma pack()

//
// prototypes
//
DWORD
ConvertBmpToTiff(
    LPTSTR BmpFile,
    LPTSTR TiffFile,
    DWORD CompressionType
    );

DWORD
ConvertTiffToBmp(
    LPTSTR TiffFile,
    LPTSTR BmpFile
    );

VOID
PostProcessTiffFile(
    LPTSTR TiffFile
    );


BOOL
TiffPreProcess(
   LPTSTR FileName,
   DWORD CompressionType
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\tiff\test\preproc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    test.c

Abstract:

    This file contains the main entrypooint
    for the TIFF library test program.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "test.h"
#pragma hdrstop


BOOL
TiffPreProcess(
   LPTSTR FileName,
   DWORD tiffCompression
   )
{
    
    BOOL                   NegotHiRes = TRUE;
    BOOL                   SrcHiRes = TRUE;
    WCHAR                  OutFileName[_MAX_FNAME];
    HANDLE                 OutFileHandle;
    HANDLE                 SrcHandle;
    DWORD                 *lpdwOutputBuffer;
    //DWORD                  dwBytesWritten;
    DWORD                  dwSizeOutputBuffer = 500000;
    DWORD                  dwUsedSizeOutputBuffer;
    DWORD                  MaxNeedOutSize;
    DWORD                  StripDataSize;        
    DWORD                  RetCode = FALSE;
    TIFF_INFO              TiffInfo;
    BOOL                   fOutFileNeedsBeClosed = 0;
    BOOL                   fOutBufferNeedsBeFreed = 0;
    DWORD                  CurrentOut = 0;
    DWORD                  FirstOut = 0;
    DWORD                  LastOut = 0;
    BOOL                   fTiffPageDone = FALSE;
    BOOL                   fTiffDocumentDone = FALSE;
    LPTSTR                 p;

    
    lpdwOutputBuffer = (DWORD *) VirtualAlloc(
        NULL,
        dwSizeOutputBuffer,
        MEM_COMMIT,
        PAGE_READWRITE
        );

    if (! lpdwOutputBuffer) {
        _tprintf( L"ERROR TIFF_TX: lpdwOutputBuffer can'r VirtualAlloc \n");        
        goto l_exit;
    }

    fOutBufferNeedsBeFreed = 1;

    _tprintf (L"TIFF_TX: NegotHiRes=%d SrcHiRes=%d Started at %ld \n",
                                         NegotHiRes, SrcHiRes, GetTickCount() );


    SrcHandle = TiffOpen( FileName,
                          &TiffInfo,
                          TRUE,
                          FILLORDER_LSB2MSB
                          );

    if (!SrcHandle) {
       goto l_exit;
    }


    CurrentOut = 1;

    //
    //  loop thru all pages
    //

    p = wcsrchr(FileName,'.');
    *p = (TCHAR) 0;
    wsprintf( OutFileName, L"%snew.tif", FileName );
    *p = '.';

    if (!( OutFileHandle = TiffCreate(OutFileName,
                                      tiffCompression,
                                      1728,
                                      FILLORDER_LSB2MSB,
                                      NegotHiRes) ) ) {
         _tprintf( L"TIFF_TX: ERROR: %lx  CREATING file %s \n", GetLastError(), OutFileName);
         goto l_exit;
    }

    fOutFileNeedsBeClosed = 1;

    
    do {

        fTiffPageDone = 0;

        _tprintf( L"TIFF_TX: Page %d started at %ld\n", CurrentOut, GetTickCount() );

        if (! TiffSeekToPage( (HANDLE) SrcHandle, CurrentOut, FILLORDER_LSB2MSB ) ) {
            _tprintf( L"ERROR: seeking to page \n");
            goto l_exit;
        }
        else {
            _tprintf( L"TIFF_TX: Tiff seeking to page -OK time=%ld\n", GetTickCount() );
        }




        __try {

            //
            // check the current page dimensions. Add memory if needed.
            //

            TiffGetCurrentPageData( (HANDLE) SrcHandle,
                                     NULL,
                                     &StripDataSize,
                                     NULL,
                                     NULL
                                     );

            if ( (StripDataSize < 0) || (StripDataSize > 1500000) ) {
                _tprintf( L"ERROR: Tiff CONVERTING %d page StripSize = %d \n", CurrentOut, StripDataSize);                
                goto l_exit;
            }


            if (tiffCompression == TIFF_COMPRESSION_MR) {
                MaxNeedOutSize = StripDataSize * 3 / 2;
            }
            else {
                MaxNeedOutSize = StripDataSize * 2;
            }


            if (MaxNeedOutSize > dwSizeOutputBuffer) {
                if (MaxNeedOutSize > 1000000) {
                    dwSizeOutputBuffer = 1500000;
                }
                else {
                    dwSizeOutputBuffer = 1000000;
                }

                VirtualFree(lpdwOutputBuffer, 0 , MEM_RELEASE);

                lpdwOutputBuffer = (DWORD *) VirtualAlloc(
                    NULL,
                    dwSizeOutputBuffer,
                    MEM_COMMIT,
                    PAGE_READWRITE
                    );

                if (! lpdwOutputBuffer) {
                    _tprintf( L"ERROR TIFF_TX: lpdwOutputBuffer can't VirtualAlloc %d \n", dwSizeOutputBuffer);                    
                    goto l_exit;
                }

                fOutBufferNeedsBeFreed = 1;

            }


            dwUsedSizeOutputBuffer = dwSizeOutputBuffer;

            if (tiffCompression == TIFF_COMPRESSION_MR) {
                if (NegotHiRes == SrcHiRes) {
                    if (! ConvMmrPageToMrSameRes ( (HANDLE) SrcHandle,
                                                    lpdwOutputBuffer,
                                                    &dwUsedSizeOutputBuffer,
                                                    NegotHiRes) ) {
                        _tprintf( L"ERROR: Tiff CONVERTING %d page \n", CurrentOut);                        
                        goto l_exit;
                    }
                }
                else {
                    if (! ConvMmrPageHiResToMrLoRes ( (HANDLE) SrcHandle,
                                                    lpdwOutputBuffer,
                                                    &dwUsedSizeOutputBuffer) ) {
                        _tprintf( L"ERROR: Tiff CONVERTING %d page \n", CurrentOut);                        
                        goto l_exit;
                    }
                }
            }
            else {
                if (! ConvMmrPageToMh ( (HANDLE) SrcHandle,
                                                lpdwOutputBuffer,
                                                &dwUsedSizeOutputBuffer,
                                                NegotHiRes,
                                                SrcHiRes) ) {
                    _tprintf( L"ERROR: Tiff CONVERTING %d page \n", CurrentOut);                    
                    goto l_exit;
                }
            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            

            if (fOutBufferNeedsBeFreed) {
                VirtualFree(lpdwOutputBuffer, 0 , MEM_RELEASE);
            }

            CloseHandle(OutFileHandle);

            return (FALSE);

        }

        TiffStartPage( OutFileHandle );
        
        if ( ! TiffWriteRaw( OutFileHandle, (LPBYTE) lpdwOutputBuffer, dwUsedSizeOutputBuffer) )  {
            _tprintf( L"ERROR: Tiff writing file %s \n", OutFileName);            
            goto l_exit;
        }

        TiffEndPage( OutFileHandle );

        fTiffPageDone = 1;        

        _tprintf( L"TIFF_TX: Done page %d size=%d at %ld \n", CurrentOut, dwUsedSizeOutputBuffer, GetTickCount() );


        if (!FirstOut) {
            FirstOut = 1;
        }

        LastOut++;

        //
        // check to see if we are done
        //
        if (LastOut >= TiffInfo.PageCount) {
            _tprintf( L"TIFF_TX: Done whole document Last page %d size=%d at %ld \n", CurrentOut, dwUsedSizeOutputBuffer, GetTickCount() );
            fTiffDocumentDone = 1;

            goto good_exit;
        }

        //
        // we want to maintain 2 pages ahead
        //
       
       CurrentOut++;
       _tprintf( L"TIFF_TX: Start page %d at %ld \n", CurrentOut, GetTickCount() );

    } while (1);





good_exit:
    if (SrcHandle) {
        TiffClose( (HANDLE) SrcHandle);        
    }

    RetCode = TRUE;




l_exit:

    if (fOutFileNeedsBeClosed) {
        TiffClose( (HANDLE) OutFileHandle);
    }

    if (fOutBufferNeedsBeFreed) {
        VirtualFree(lpdwOutputBuffer, 0 , MEM_RELEASE);
    }
    
    _tprintf( L"TIFF_TX: TiffConvertThread EXITs at %ld \n", GetTickCount() );

    return (RetCode);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\util\file.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    string.c

Abstract:

    This file implements string functions for fax.

Author:

    Wesley Witt (wesw) 23-Jan-1995

Environment:

    User Mode

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "faxutil.h"


BOOL
MapFileOpen(
    LPTSTR FileName,
    BOOL ReadOnly,
    DWORD ExtendBytes,
    PFILE_MAPPING FileMapping
    )
{
    FileMapping->hFile = NULL;
    FileMapping->hMap = NULL;
    FileMapping->fPtr = NULL;

    FileMapping->hFile = CreateFile(
        FileName,
        ReadOnly ? GENERIC_READ : GENERIC_READ | GENERIC_WRITE,
        ReadOnly ? FILE_SHARE_READ : 0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );
    if (FileMapping->hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    FileMapping->fSize = GetFileSize( FileMapping->hFile, NULL );

    FileMapping->hMap = CreateFileMapping(
        FileMapping->hFile,
        NULL,
        ReadOnly ? PAGE_READONLY : PAGE_READWRITE,
        0,
        FileMapping->fSize + ExtendBytes,
        NULL
        );
    if (FileMapping->hMap == NULL) {
        CloseHandle( FileMapping->hFile );
        return FALSE;
    }

    FileMapping->fPtr = MapViewOfFileEx(
        FileMapping->hMap,
        ReadOnly ? FILE_MAP_READ : FILE_MAP_WRITE,
        0,
        0,
        0,
        NULL
        );
    if (FileMapping->fPtr == NULL) {
        CloseHandle( FileMapping->hFile );
        CloseHandle( FileMapping->hMap );
        return FALSE;
    }

    return TRUE;
}


VOID
MapFileClose(
    PFILE_MAPPING FileMapping,
    DWORD TrimOffset
    )
{
    UnmapViewOfFile( FileMapping->fPtr );
    CloseHandle( FileMapping->hMap );
    if (TrimOffset) {
        SetFilePointer( FileMapping->hFile, TrimOffset, NULL, FILE_BEGIN );
        SetEndOfFile( FileMapping->hFile );
    }
    CloseHandle( FileMapping->hFile );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\util\faxmodem.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxmodem.c

Abstract:

    This module contains code to read the adaptive
    answer modem list from the faxsetup.inf file.

Author:

    Wesley Witt (wesw) 22-Sep-1997


Revision History:

--*/

#include <windows.h>
#include <setupapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "faxreg.h"
#include "faxutil.h"



LPVOID
InitializeAdaptiveAnswerList(
    HINF hInf
    )
{
    BOOL CloseInfHandle = FALSE;
    TCHAR Buffer[MAX_PATH];
    DWORD ErrorLine;
    INFCONTEXT InfLine;
    DWORD ModemCount = 0;
    LPTSTR ModemList = NULL;
    LPTSTR p;
    DWORD Size = 0;



    if (hInf == NULL) {
        ExpandEnvironmentStrings( TEXT("%windir%\\inf\\faxsetup.inf"), Buffer, sizeof(Buffer)/sizeof(TCHAR) );
        hInf = SetupOpenInfFile( Buffer, NULL, INF_STYLE_WIN4, &ErrorLine );
        if (hInf == INVALID_HANDLE_VALUE) {
            goto exit;
        }
        CloseInfHandle = TRUE;
    }


    if (SetupFindFirstLine( hInf, ADAPTIVE_ANSWER_SECTION, NULL, &InfLine )) {
        do {
            if (SetupGetStringField( &InfLine, 1, Buffer, sizeof(Buffer)/sizeof(TCHAR), &ErrorLine )) {
                Size += StringSize( Buffer );
                ModemCount += 1;
            }
        } while(SetupFindNextLine(&InfLine,&InfLine));
    }

    ModemList = MemAlloc( Size + 16 );
    if (ModemList == NULL) {
        goto exit;
    }

    p = ModemList;

    if (SetupFindFirstLine( hInf, ADAPTIVE_ANSWER_SECTION, NULL, &InfLine )) {
        do {
            if (SetupGetStringField( &InfLine, 1, Buffer, sizeof(Buffer)/sizeof(TCHAR), &ErrorLine )) {
                _tcscpy( p, Buffer );
                p += (_tcslen( Buffer ) + 1);
            }
        } while(SetupFindNextLine(&InfLine,&InfLine));
    }

exit:
    if (CloseInfHandle) {
        SetupCloseInfFile( hInf );
    }
    return ModemList;
}


BOOL
IsModemAdaptiveAnswer(
    LPVOID ModemList,
    LPCTSTR ModemId
    )
{
    LPCTSTR p = ModemList;

    while (p && *p) {
        if (_tcsicmp( p, ModemId ) == 0) {
            return TRUE;
        }
        p += (_tcslen( p ) + 1);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\util\product.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    product.c

Abstract:

    This file implements product type api for fax.

Author:

    Wesley Witt (wesw) 12-Feb-1997

Environment:

    User Mode

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "faxreg.h"
#include "faxutil.h"


BOOL
ValidateProductSuite(
    WORD SuiteMask
    )
{
    OSVERSIONINFOEX OsVersionInfo;

    OsVersionInfo.dwOSVersionInfoSize = sizeof(OsVersionInfo);

    if (!GetVersionEx((OSVERSIONINFO *) &OsVersionInfo)) {
        DebugPrint(( TEXT("Couldn't GetVersionEx(), ec = %d\n"), GetLastError() ));
        return FALSE;
    }

    return ((OsVersionInfo.wSuiteMask & SuiteMask) != 0) ; 
    
}


DWORD
GetProductType(
    VOID
    )
{
    OSVERSIONINFOEX OsVersionInfo;

    OsVersionInfo.dwOSVersionInfoSize = sizeof(OsVersionInfo);

    if (!GetVersionEx((OSVERSIONINFO *) &OsVersionInfo)) {
        DebugPrint(( TEXT("Couldn't GetVersionEx(), ec = %d\n"), GetLastError() ));
        return 0;
    }

    if  (OsVersionInfo.wProductType == VER_NT_WORKSTATION) {
        return PRODUCT_TYPE_WINNT;            
    }

    return PRODUCT_TYPE_SERVER;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\util\printers.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    printers.c

Abstract:

    This file implements printer functions for fax.

Author:

    Steven Kehrli (steveke) 18-Aug-1999

Environment:

    User Mode

--*/

#include <windows.h>
#include <winspool.h>
#include <tchar.h>

#include "faxutil.h"




PVOID
MyEnumPrinters(
    LPTSTR  pServerName,
    DWORD   level,
    PDWORD  pcPrinters,
    DWORD   dwFlags
    )

/*++

Routine Description:

    Wrapper function for spooler API EnumPrinters

Arguments:

    pServerName - Specifies the name of the print server
    level - Level of PRINTER_INFO_x structure
    pcPrinters - Returns the number of printers enumerated
    dwFlags - Flag bits passed to EnumPrinters

Return Value:

    Pointer to an array of PRINTER_INFO_x structures
    NULL if there is an error

--*/

{
    PBYTE   pPrinterInfo = NULL;
    DWORD   cb;

    if (! EnumPrinters(dwFlags, pServerName, level, NULL, 0, &cb, pcPrinters) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pPrinterInfo = MemAlloc(cb)) &&
        EnumPrinters(dwFlags, pServerName, level, pPrinterInfo, cb, &cb, pcPrinters))
    {
        return pPrinterInfo;
    }

    DebugPrint(( TEXT("EnumPrinters failed: %d\n"), GetLastError()));
    MemFree(pPrinterInfo);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\util\mem.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mem.c

Abstract:

    This file implements memory allocation functions for fax.

Author:

    Wesley Witt (wesw) 23-Jan-1995

Environment:

    User Mode

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "faxutil.h"



HANDLE hHeap;
DWORD HeapFlags;
PMEMALLOC pMemAllocUser;
PMEMREALLOC pMemReAllocUser;
PMEMFREE pMemFreeUser;


#ifdef FAX_HEAP_DEBUG
LIST_ENTRY HeapHeader;
ULONG TotalMemory;
ULONG MaxTotalMemory;
ULONG MaxTotalAllocs;
VOID PrintAllocations(VOID);
ULONG TotalAllocs;
CRITICAL_SECTION CsHeap;
#endif



BOOL
HeapExistingInitialize(
    HANDLE hExistHeap
    )
{

#ifdef FAX_HEAP_DEBUG
    InitializeListHead( &HeapHeader );
    MaxTotalMemory = 0;
    MaxTotalAllocs = 0;
    InitializeCriticalSection( &CsHeap );
#endif

    if (!hExistHeap) {
        return FALSE;
    }
    else {
        hHeap = hExistHeap;
        return TRUE;
    }

}


HANDLE
HeapInitialize(
    HANDLE hHeapUser,
    PMEMALLOC pMemAlloc,    
    PMEMFREE pMemFree,
    DWORD Flags
    )
{

#ifdef FAX_HEAP_DEBUG
    InitializeListHead( &HeapHeader );
    MaxTotalMemory = 0;
    MaxTotalAllocs = 0;
    InitializeCriticalSection( &CsHeap );
#endif

    HeapFlags = Flags | HEAPINIT_NO_STRINGS;

    if (pMemAlloc && pMemFree) {
        pMemAllocUser = pMemAlloc;
        pMemFreeUser = pMemFree;
        hHeap = NULL;
    } else {
        if (hHeapUser) {
            hHeap = hHeapUser;
        } else {
            hHeap = HeapCreate( 0, HEAP_SIZE, 0 );
        }
        if (!hHeap) {
            return NULL;
        }
    }

    return hHeap;
}

BOOL
HeapCleanup(
    VOID
    )
{
#ifdef FAX_HEAP_DEBUG
    PrintAllocations();
#endif
    if (hHeap) {
        HeapDestroy( hHeap );
    }
    return TRUE;
}

#ifdef FAX_HEAP_DEBUG
VOID
pCheckHeap(
    PVOID MemPtr,
    ULONG Line,
    LPSTR File
    )
{
    HeapValidate( hHeap, 0, MemPtr );
}
#endif

PVOID
pMemAlloc(
    ULONG AllocSize
#ifdef FAX_HEAP_DEBUG
    , ULONG Line,
    LPSTR File
#endif
    )
{
    PVOID MemPtr;
#ifdef FAX_HEAP_DEBUG
    PHEAP_BLOCK hb;
#ifdef UNICODE
    TCHAR fname[MAX_PATH];
#endif
    LPTSTR p = NULL;
    if (pMemAllocUser) {
        hb = (PHEAP_BLOCK) pMemAllocUser( AllocSize + sizeof(HEAP_BLOCK) );
    } else {
        if (hHeap == NULL) {
            HeapInitialize( NULL, NULL, NULL, 0 );
            if (hHeap == NULL) {
                return NULL;
            }
        }
        hb = (PHEAP_BLOCK) HeapAlloc( hHeap, HEAP_ZERO_MEMORY, AllocSize + sizeof(HEAP_BLOCK) );
    }
    if (hb) {
        TotalAllocs += 1;
        TotalMemory += AllocSize;
        if (TotalMemory > MaxTotalMemory) {
            MaxTotalMemory = TotalMemory;
        }
        if (TotalAllocs > MaxTotalAllocs) {
            MaxTotalAllocs = TotalAllocs;
        }
        EnterCriticalSection( &CsHeap );
        InsertTailList( &HeapHeader, &hb->ListEntry );
        hb->Signature = HEAP_SIG;
        hb->Size = AllocSize;
        hb->Line = Line;
#ifdef UNICODE
        MultiByteToWideChar(
            CP_ACP,
            MB_PRECOMPOSED,
            File,
            -1,
            fname,
            sizeof(fname)/sizeof(WCHAR)
            );
        p = wcsrchr( fname, L'\\' );
        if (p) {
            wcscpy( hb->File, p+1 );
        }
#else
        p = strrchr( File, '\\' );
        if (p) {
            strcpy( hb->File, p+1 );
        }
#endif
        MemPtr = (PVOID) ((PUCHAR)hb + sizeof(HEAP_BLOCK));
        LeaveCriticalSection( &CsHeap );
    } else {
        MemPtr = NULL;
    }
#else
    if (pMemAllocUser) {
        MemPtr = (PVOID) pMemAllocUser( AllocSize );
    } else {
        if (hHeap == NULL) {
            HeapInitialize( NULL, NULL, NULL, 0 );
            if (hHeap == NULL) {
                return NULL;
            }
        }
        MemPtr = (PVOID) HeapAlloc( hHeap, HEAP_ZERO_MEMORY, AllocSize );
    }
#endif

    if (!MemPtr) {
        DebugPrint(( TEXT("MemAlloc() failed, size=%d"), AllocSize ));
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    }

    return MemPtr;
}

PVOID
pMemReAlloc(
    PVOID Src,
    ULONG AllocSize
#ifdef FAX_HEAP_DEBUG
    , ULONG Line,
    LPSTR File
#endif
    )
{
    PVOID MemPtr;
#ifdef FAX_HEAP_DEBUG
    PHEAP_BLOCK hb;
#ifdef UNICODE
    TCHAR fname[MAX_PATH];
#endif
    LPTSTR p = NULL;

    EnterCriticalSection( &CsHeap );
     hb = (PHEAP_BLOCK) ((LPBYTE)Src-(ULONG_PTR)sizeof(HEAP_BLOCK));
     RemoveEntryList( &hb->ListEntry );
     TotalMemory -= hb->Size;         
    LeaveCriticalSection( &CsHeap );
   

    if (pMemReAllocUser) {
        hb = (PHEAP_BLOCK) pMemReAllocUser( (LPBYTE)Src-(ULONG_PTR)sizeof(HEAP_BLOCK), 
                                            AllocSize + sizeof(HEAP_BLOCK) );
    } else {
        if (hHeap == NULL) {
            HeapInitialize( NULL, NULL, NULL, 0 );
            if (hHeap == NULL) {
                return NULL;
            }
        }

        //
        // we have to back up a bit since the actual pointer passed in points to the data after the heap block.
        //
        hb = (PHEAP_BLOCK) HeapReAlloc( hHeap, 
                                        HEAP_ZERO_MEMORY, 
                                        (LPBYTE)Src-(ULONG_PTR)sizeof(HEAP_BLOCK), 
                                        AllocSize + sizeof(HEAP_BLOCK) 
                                       );
    }
    if (hb) {
        TotalMemory += AllocSize;
        if (TotalMemory > MaxTotalMemory) {
            MaxTotalMemory = TotalMemory;
        }

        EnterCriticalSection( &CsHeap );
        InsertTailList( &HeapHeader, &hb->ListEntry );
        hb->Signature = HEAP_SIG;
        hb->Size = AllocSize;
        hb->Line = Line;

#ifdef UNICODE
        MultiByteToWideChar(
            CP_ACP,
            MB_PRECOMPOSED,
            File,
            -1,
            fname,
            sizeof(fname)/sizeof(WCHAR)
            );
        p = wcsrchr( fname, L'\\' );
        if (p) {
            wcscpy( hb->File, p+1 );
        }
#else
        p = strrchr( File, '\\' );
        if (p) {
            strcpy( hb->File, p+1 );
        }
#endif
        MemPtr = (PVOID) ((PUCHAR)hb + sizeof(HEAP_BLOCK));
        LeaveCriticalSection( &CsHeap );
    } else {
        MemPtr = NULL;
    }
#else
    if (pMemReAllocUser) {
        MemPtr = (PVOID) pMemReAllocUser( Src, AllocSize );
    } else {
        if (hHeap == NULL) {
            HeapInitialize( NULL, NULL, NULL, 0 );
            if (hHeap == NULL) {
                return NULL;
            }
        }
        MemPtr = (PVOID) HeapReAlloc( hHeap, HEAP_ZERO_MEMORY, Src, AllocSize );
    }
#endif

    if (!MemPtr) {
        DebugPrint(( TEXT("MemReAlloc() failed, src=%x, size=%d"), (ULONG_PTR)Src, AllocSize ));
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    }

    return MemPtr;
}

VOID
pMemFreeForHeap(
    HANDLE hHeap,
    PVOID MemPtr
#ifdef FAX_HEAP_DEBUG
    , ULONG Line,
    LPSTR File
#endif
    )
{
#ifdef FAX_HEAP_DEBUG
    PHEAP_BLOCK hb;
    if (!MemPtr) {
        return;
    }

    hb = (PHEAP_BLOCK) ((PUCHAR)MemPtr - sizeof(HEAP_BLOCK));
    
    if (hb->Signature == HEAP_SIG) {
        EnterCriticalSection( &CsHeap );
        RemoveEntryList( &hb->ListEntry );
        TotalMemory -= hb->Size;
        TotalAllocs -= 1;
        LeaveCriticalSection( &CsHeap );
    } else {
        if (HeapFlags & HEAPINIT_NO_VALIDATION) {
            hb = (PHEAP_BLOCK) MemPtr;            
        } else {
            dprintf( TEXT("MemFree(): Corrupt heap block") );
            PrintAllocations();
            __try {
                DebugBreak();
            } __except (UnhandledExceptionFilter(GetExceptionInformation())) {
            // Nothing to do in here.
            }
        }
    }
    
    if (pMemFreeUser) {
        pMemFreeUser( (PVOID) hb );
    } else {
        HeapFree( hHeap, 0, (PVOID) hb );
    }
    
#else
    if (!MemPtr) {
        return;
    }
    if (pMemFreeUser) {
        pMemFreeUser( (PVOID) MemPtr );
    } else {
        HeapFree( hHeap, 0, (PVOID) MemPtr );
    }
#endif
}

VOID
pMemFree(
    PVOID MemPtr
#ifdef FAX_HEAP_DEBUG
    , ULONG Line,
    LPSTR File
#endif
    )
{
#ifdef FAX_HEAP_DEBUG
    pMemFreeForHeap( hHeap, MemPtr, Line, File );
#else
    pMemFreeForHeap( hHeap, MemPtr );
#endif
}

#ifdef FAX_HEAP_DEBUG
VOID
PrintAllocations(
    VOID
    )
{
    PLIST_ENTRY                 Next;
    PHEAP_BLOCK                 hb;
    LPTSTR                      s;


    dprintf( TEXT("-------------------------------------------------------------------------------------------------------") );
    dprintf( TEXT("Memory Allocations for Heap 0x%08x, Allocs=%d, MaxAllocs=%d, TotalMem=%d, MaxTotalMem=%d"),\
                 hHeap, TotalAllocs, MaxTotalAllocs, TotalMemory, MaxTotalMemory );
    dprintf( TEXT("-------------------------------------------------------------------------------------------------------") );

    EnterCriticalSection( &CsHeap );

    Next = HeapHeader.Flink;
    if (Next == NULL || TotalAllocs == 0) {
        return;
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&HeapHeader) {
        hb = CONTAINING_RECORD( Next, HEAP_BLOCK, ListEntry );
        Next = hb->ListEntry.Flink;
        s = (LPTSTR) ((PUCHAR)hb + sizeof(HEAP_BLOCK));
        dprintf( TEXT("%8d %16s @ %5d    0x%08x"), hb->Size, hb->File, hb->Line, s );
        if (!(HeapFlags & HEAPINIT_NO_STRINGS)) {
            dprintf( TEXT(" \"%s\""), s );
        }
    }

    LeaveCriticalSection( &CsHeap );

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\util\registry.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    This module provides a generic table driven access
    to the registry.

Author:

    Wesley Witt (wesw) 9-June-1996


Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "winfax.h"
#include "faxutil.h"
#include "faxreg.h"



HKEY
OpenRegistryKey(
    HKEY hKey,
    LPCTSTR KeyName,
    BOOL CreateNewKey,
    REGSAM SamDesired
    )
{
    LONG    Rslt;
    HKEY    hKeyNew;
    DWORD   Disposition;


    if (CreateNewKey) {
        Rslt = RegCreateKeyEx(
            hKey,
            KeyName,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            SamDesired == 0 ? KEY_ALL_ACCESS : SamDesired,
            NULL,
            &hKeyNew,
            &Disposition
            );
        if (Rslt != ERROR_SUCCESS) {
            //
            // could not open the registry key
            //
            DebugPrint(( TEXT("RegCreateKeyEx() failed, ec=%d"), Rslt ));
            return NULL;
        }

        if (Disposition == REG_CREATED_NEW_KEY) {
            DebugPrint(( TEXT("Created new fax registry key, ec=%d"), Rslt ));
        }
    } else {
        Rslt = RegOpenKeyEx(
            hKey,
            KeyName,
            0,
            SamDesired == 0 ? KEY_ALL_ACCESS : SamDesired,
            &hKeyNew
            );
        if (Rslt != ERROR_SUCCESS) {
            //
            // could not open the registry key
            //
            DebugPrint(( TEXT("RegOpenKeyEx() failed, ec=%d"), Rslt ));
            return NULL;
        }
    }

    return hKeyNew;
}


LPTSTR
GetRegistryStringValue(
    HKEY hKey,
    DWORD RegType,
    LPCTSTR ValueName,
    LPCTSTR DefaultValue,
    LPDWORD StringSize
    )
{
    BOOL    Success = FALSE;
    DWORD   Size;
    LONG    Rslt;
    DWORD   Type;
    LPBYTE  Buffer = NULL;
    LPBYTE  ExpandBuffer = NULL;


    Rslt = RegQueryValueEx(
        hKey,
        ValueName,
        NULL,
        &Type,
        NULL,
        &Size
        );
    if (Rslt != ERROR_SUCCESS) {
        if (Rslt == ERROR_FILE_NOT_FOUND) {
            Size = StringSize( DefaultValue );
        } else {
            DebugPrint(( TEXT("RegQueryValueEx() failed, ec=%d"), Rslt ));
            goto exit;
        }
    } else {
        if (Type != RegType) {
            return NULL;
        }
    }

    if (Size == 0) {
        Size = 32;
    }

    Buffer = (LPBYTE) MemAlloc( Size );
    if (!Buffer) {
        goto exit;
    }

    Rslt = RegQueryValueEx(
        hKey,
        ValueName,
        NULL,
        &Type,
        Buffer,
        &Size
        );
    if (Rslt != ERROR_SUCCESS) {
        if (Rslt != ERROR_FILE_NOT_FOUND) {
            DebugPrint(( TEXT("RegQueryValueEx() failed, ec=%d"), Rslt ));
            goto exit;
        }
        //
        // create the value since it doesn't exist
        //
        _tcscpy( (LPTSTR) Buffer, DefaultValue );

        Rslt = RegSetValueEx(
            hKey,
            ValueName,
            0,
            RegType,
            Buffer,
            Size
            );
        if (Rslt != ERROR_SUCCESS) {
            //
            // could not set the registry value
            //
            DebugPrint(( TEXT("RegSetValueEx() failed[%s], ec=%d"), ValueName, Rslt ));
            goto exit;
        }
    }
    if (RegType == REG_EXPAND_SZ) {
        Rslt = ExpandEnvironmentStrings( (LPTSTR) Buffer, NULL, 0 );
        if (!Rslt) {
            goto exit;
        }

        ExpandBuffer = (LPBYTE) MemAlloc( (Rslt + 1) * sizeof(WCHAR) );
        if (!ExpandBuffer) {
            goto exit;
        }

        Rslt = ExpandEnvironmentStrings( (LPTSTR) Buffer, (LPTSTR) ExpandBuffer, Rslt );
        if (Rslt == 0) {
            MemFree( ExpandBuffer );
            DebugPrint(( TEXT("ExpandEnvironmentStrings() failed, ec=%d"), GetLastError() ));
            goto exit;
        }
        MemFree( Buffer );
        Buffer = ExpandBuffer;
    }

    Success = TRUE;
    if (StringSize) {
        *StringSize = Size;
    }

exit:
    if (!Success) {
        MemFree( Buffer );
        return StringDup( DefaultValue );
    }

    return (LPTSTR) Buffer;
}


LPTSTR
GetRegistryString(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR DefaultValue
    )
{
    return GetRegistryStringValue( hKey, REG_SZ, ValueName, DefaultValue, NULL );
}


LPTSTR
GetRegistryStringExpand(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR DefaultValue
    )
{
    return GetRegistryStringValue( hKey, REG_EXPAND_SZ, ValueName, DefaultValue, NULL );
}

LPTSTR
GetRegistryStringMultiSz(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR DefaultValue,
    LPDWORD StringSize
    )
{
    return GetRegistryStringValue( hKey, REG_MULTI_SZ, ValueName, DefaultValue, StringSize );
}


DWORD
GetRegistryDword(
    HKEY hKey,
    LPCTSTR ValueName
    )
{
    DWORD   Size = sizeof(DWORD);
    LONG    Rslt;
    DWORD   Type;
    DWORD   Value = 0;


    Rslt = RegQueryValueEx(
        hKey,
        ValueName,
        NULL,
        &Type,
        (LPBYTE) &Value,
        &Size
        );
    if (Rslt != ERROR_SUCCESS) {
        //
        // create the value since it doesn't exist
        //
        Value = 0;

        Rslt = RegSetValueEx(
            hKey,
            ValueName,
            0,
            REG_DWORD,
            (LPBYTE) &Value,
            Size
            );
        if (Rslt != ERROR_SUCCESS) {
            //
            // could not set the registry value
            //
            DebugPrint(( TEXT("RegSetValueEx() failed[%s], ec=%d"), ValueName, Rslt ));
            Value = 0;
        }
    }

    return Value;
}


LPBYTE
GetRegistryBinary(
    HKEY hKey,
    LPCTSTR ValueName,
    LPDWORD DataSize
    )
{
    BOOL    Success = FALSE;
    DWORD   Size;
    LONG    Rslt;
    DWORD   Type;
    LPBYTE  Buffer = NULL;


    Rslt = RegQueryValueEx(
        hKey,
        ValueName,
        NULL,
        &Type,
        NULL,
        &Size
        );
    if (Rslt != ERROR_SUCCESS) {
        if (Rslt == ERROR_FILE_NOT_FOUND) {
            Size = 1;
        } else {
            DebugPrint(( TEXT("RegQueryValueEx() failed, ec=%d"), Rslt ));
            goto exit;
        }
    } else {
        if (Type != REG_BINARY) {
            return NULL;
        }
    }

    if (Size == 0) {
        Size = 1;
    }

    Buffer = (LPBYTE) MemAlloc( Size );
    if (!Buffer) {
        goto exit;
    }

    Rslt = RegQueryValueEx(
        hKey,
        ValueName,
        NULL,
        &Type,
        Buffer,
        &Size
        );
    if (Rslt != ERROR_SUCCESS) {
        if (Rslt != ERROR_FILE_NOT_FOUND) {
            DebugPrint(( TEXT("RegQueryValueEx() failed, ec=%d"), Rslt ));
            goto exit;
        }
        //
        // create the value since it doesn't exist
        //
        Rslt = RegSetValueEx(
            hKey,
            ValueName,
            0,
            REG_BINARY,
            Buffer,
            Size
            );
        if (Rslt != ERROR_SUCCESS) {
            //
            // could not set the registry value
            //
            DebugPrint(( TEXT("RegSetValueEx() failed[%s], ec=%d"), ValueName, Rslt ));
            goto exit;
        }
    }
    Success = TRUE;
    if (DataSize) {
        *DataSize = Size;
    }

exit:
    if (!Success) {
        MemFree( Buffer );
        return NULL;
    }

    return Buffer;
}


DWORD
GetSubKeyCount(
    HKEY hKey
    )
{
    DWORD KeyCount = 0;
    LONG Rval;


    Rval = RegQueryInfoKey( hKey, NULL, NULL, NULL, &KeyCount, NULL, NULL, NULL, NULL, NULL, NULL, NULL );
    if (Rval != ERROR_SUCCESS) {
        return 0;
    }

    return KeyCount;
}


DWORD
GetMaxSubKeyLen(
    HKEY hKey
    )
{
    DWORD MaxSubKeyLen = 0;
    LONG Rval;


    Rval = RegQueryInfoKey( hKey, NULL, NULL, NULL, NULL, &MaxSubKeyLen, NULL, NULL, NULL, NULL, NULL, NULL );
    if (Rval != ERROR_SUCCESS) {
        return 0;
    }

    return MaxSubKeyLen;
}


BOOL
SetRegistryDword(
    HKEY hKey,
    LPCTSTR ValueName,
    DWORD Value
    )
{
    LONG    Rslt;


    Rslt = RegSetValueEx(
        hKey,
        ValueName,
        0,
        REG_DWORD,
        (LPBYTE) &Value,
        sizeof(DWORD)
        );
    if (Rslt != ERROR_SUCCESS) {
        DebugPrint(( TEXT("RegSetValueEx() failed[%s], ec=%d"), ValueName, Rslt ));
        return FALSE;
    }

    return TRUE;
}


BOOL
SetRegistryBinary(
    HKEY hKey,
    LPCTSTR ValueName,
    const LPBYTE Value,
    LONG Length
    )
{
    LONG    Rslt;


    Rslt = RegSetValueEx(
        hKey,
        ValueName,
        0,
        REG_BINARY,
        (LPBYTE) Value,
        Length
        );
    if (Rslt != ERROR_SUCCESS) {
        DebugPrint(( TEXT("RegSetValueEx() failed[%s], ec=%d"), ValueName, Rslt ));
        return FALSE;
    }

    return TRUE;
}


BOOL
SetRegistryStringValue(
    HKEY hKey,
    DWORD RegType,
    LPCTSTR ValueName,
    LPCTSTR Value,
    LONG Length
    )
{
    LONG    Rslt;


    Rslt = RegSetValueEx(
        hKey,
        ValueName,
        0,
        RegType,
        (LPBYTE) Value,
        Length == -1 ? StringSize( Value ) : Length
        );
    if (Rslt != ERROR_SUCCESS) {
        DebugPrint(( TEXT("RegSetValueEx() failed[%s], ec=%d"), ValueName, Rslt ));
        return FALSE;
    }

    return TRUE;
}


BOOL
SetRegistryString(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR Value
    )
{
    return SetRegistryStringValue( hKey, REG_SZ, ValueName, Value, -1 );
}


BOOL
SetRegistryStringExpand(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR Value
    )
{
    return SetRegistryStringValue( hKey, REG_EXPAND_SZ, ValueName, Value, -1 );
}


BOOL
SetRegistryStringMultiSz(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR Value,
    DWORD Length
    )
{
    return SetRegistryStringValue( hKey, REG_MULTI_SZ, ValueName, Value, Length );
}


DWORD
EnumerateRegistryKeys(
    HKEY hKey,
    LPCTSTR KeyName,
    BOOL ChangeValues,
    PREGENUMCALLBACK EnumCallback,
    LPVOID ContextData
    )
{
    LONG    Rslt;
    HKEY    hSubKey = NULL;
    HKEY    hKeyEnum = NULL;
    DWORD   Index = 0;
    DWORD   MaxSubKeyLen;
    DWORD   SubKeyCount;
    LPTSTR  SubKeyName = NULL;



    hSubKey = OpenRegistryKey( hKey, KeyName, ChangeValues, ChangeValues ? KEY_ALL_ACCESS : KEY_READ );
    if (!hSubKey) {
        goto exit;
    }

    Rslt = RegQueryInfoKey(
        hSubKey,
        NULL,
        NULL,
        NULL,
        &SubKeyCount,
        &MaxSubKeyLen,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
        );
    if (Rslt != ERROR_SUCCESS) {
        //
        // could not open the registry key
        //
        DebugPrint(( TEXT("RegQueryInfoKey() failed, ec=%d"), Rslt ));
        goto exit;
    }

    if (!EnumCallback( hSubKey, NULL, SubKeyCount, ContextData )) {
        goto exit;
    }

    MaxSubKeyLen += 4;

    SubKeyName = (LPTSTR) MemAlloc( (MaxSubKeyLen+1) * sizeof(WCHAR) );
    if (!SubKeyName) {
        goto exit;
    }

    while( TRUE ) {
        Rslt = RegEnumKey(
            hSubKey,
            Index,
            (LPTSTR) SubKeyName,
            MaxSubKeyLen
            );
        if (Rslt != ERROR_SUCCESS) {
            if (Rslt == ERROR_NO_MORE_ITEMS) {
                break;
            }
            DebugPrint(( TEXT("RegEnumKey() failed, ec=%d"), Rslt ));
            goto exit;
        }

        hKeyEnum = OpenRegistryKey( hSubKey, SubKeyName, ChangeValues, ChangeValues ? KEY_ALL_ACCESS : KEY_READ );
        if (!hKeyEnum) {
            continue;
        }

        if (!EnumCallback( hKeyEnum, SubKeyName, Index, ContextData )) {
            RegCloseKey( hKeyEnum );
            break;
        }

        RegCloseKey( hKeyEnum );
        Index += 1;
    }

exit:
    if (hSubKey) {
        RegCloseKey( hSubKey );
    }
    MemFree( SubKeyName );

    return Index;
}

BOOL
DeleteRegistryKey(
    HKEY hKey,
    LPCTSTR SubKey
    )
{
    DWORD Count = 0;
    HKEY hKeyCurrent;
    TCHAR szName[100];
    DWORD dwName;
    long rslt;
    
    rslt = RegOpenKey(hKey,SubKey,&hKeyCurrent);
    if (rslt != ERROR_SUCCESS) {
        DebugPrint(( TEXT("RegOpenKey() failed, ec=%d"), rslt ));
        return FALSE;
    }

    while(1) {    

        dwName = sizeof(szName);

        rslt = RegEnumKeyEx(hKeyCurrent,Count,szName,&dwName,NULL,NULL,NULL,NULL);

        if (rslt == ERROR_SUCCESS) {
            DeleteRegistryKey(hKeyCurrent,szName);
            Count++;
        } else if (rslt == ERROR_NO_MORE_ITEMS) {
            break;
        } else {
            //
            // other error
            //
            DebugPrint(( TEXT("RegEnumKeyExKey() failed, ec=%d"), rslt ));
            RegCloseKey(hKeyCurrent);
            return FALSE;
        }                
    }

    RegCloseKey(hKeyCurrent);
    RegDeleteKey(hKey, SubKey);
    
    return TRUE;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\util\shortcut.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    shortcut.c

Abstract:

    This module contains code to manipulate shortcuts.

Author:

    Wesley Witt (wesw) 24-Jul-1997


Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <shlobj.h>
#include <shellapi.h>
#include <commdlg.h>
#include <winspool.h>
#include <tchar.h>

#include "faxreg.h"
#include "faxutil.h"


//
// Cover page filename extension and link filename extension
//

#define CP_FILENAME_EXT     TEXT(".cov")
#define LNK_FILENAME_EXT    TEXT(".lnk")
#define FILENAME_EXT        TEXT('.')
#define MAX_FILENAME_EXT    4

//
// Whether not we've done OLE initialization
//

static BOOL oleInitialized = FALSE;

//
// Find the filename portion given a filename:
//  return a pointer to the '.' character if successful
//  NULL if there is no extension
//

#define FindFilenameExtension(pFilename) _tcsrchr(pFilename, FILENAME_EXT)


static LPTSTR Platforms[] =
{
    TEXT("Windows NT x86"),
    TEXT("Windows NT R4000"),
    TEXT("Windows NT Alpha_AXP"),
    TEXT("Windows NT PowerPC")
};




VOID
InitOle(
    VOID
    )

/*++

Routine Description:

    Perform OLE initialization if necessary

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    if (!oleInitialized) {

        HRESULT hResult = CoInitialize(NULL);

        if (hResult == S_OK || hResult == S_FALSE) {
            oleInitialized = TRUE;
        } else {
            DebugPrint(( TEXT("OLE initialization failed: %d\n"), hResult ));
        }
    }
}



VOID
DeinitOle(
    VOID
    )

/*++

Routine Description:

    Perform OLE deinitialization if necessary

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    if (oleInitialized) {
        CoUninitialize();
    }
}



BOOL
ResolveShortcut(
    LPTSTR  pLinkName,
    LPTSTR  pFileName
    )

/*++

Routine Description:

    Resolve a shortcut to find the destination file

Arguments:

    pLinkName - Specifies the name of a link file
    pFileName - Points to a buffer for storing the destination filename

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    LPTSTR          pExtension;
    HRESULT         hResult;
    IShellLink     *pShellLink;
    IPersistFile   *pPersistFile;
#ifndef UNICODE
    LPWSTR          pLinkNameW;
#endif

    //
    // Default to empty string in case of an error
    //

    *pFileName = 0;

    if (!oleInitialized) {
        InitOle();
        if (!oleInitialized) {
            DebugPrint(( TEXT("OLE wasn't initialized successfully\n") ));
            return FALSE;
        }
    }

    //
    // Make sure the filename has the .LNK extension
    //

    if ((pExtension = FindFilenameExtension(pLinkName)) == NULL ||
        _tcsicmp(pExtension, LNK_FILENAME_EXT) != 0)
    {
        return FALSE;
    }

    //
    // Get a pointer to IShellLink interface
    //

    hResult = CoCreateInstance(&CLSID_ShellLink,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               &IID_IShellLink,
                               &pShellLink);

    if (SUCCEEDED(hResult)) {

        //
        // Get a pointer to IPersistFile interface
        //

        hResult = pShellLink->lpVtbl->QueryInterface(pShellLink,
                                                     &IID_IPersistFile,
                                                     &pPersistFile);

        if (SUCCEEDED(hResult)) {

            //
            // Now resolve the link to find the actually file it refers to
            //

#ifdef UNICODE
            hResult = pPersistFile->lpVtbl->Load(pPersistFile, pLinkName, STGM_READ);
#else
            pLinkNameW = AnsiStringToUnicodeString( pLinkName );
            hResult = pPersistFile->lpVtbl->Load(pPersistFile, pLinkNameW, STGM_READ);
            MemFree( pLinkNameW );
#endif

            if (SUCCEEDED(hResult)) {

                hResult = pShellLink->lpVtbl->Resolve(pShellLink, NULL, SLR_NO_UI | 0x00010000);

                if (SUCCEEDED(hResult))
                    pShellLink->lpVtbl->GetPath(pShellLink, pFileName, MAX_PATH, NULL, 0);
            }

            pPersistFile->lpVtbl->Release(pPersistFile);
        }

        pShellLink->lpVtbl->Release(pShellLink);
    }

    return SUCCEEDED(hResult);
}



BOOL
CreateShortcut(
    LPTSTR  pLinkName,
    LPTSTR  pFileName
    )

/*++

Routine Description:

    Create a shortcut from pLinkName to pFileName

Arguments:

    pLinkName - Name of the link file
    pFileName - Name of the destination file

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    HRESULT         hResult;
    IShellLink      *pShellLink;
    IPersistFile    *pPersistFile;
#ifndef UNICODE
    LPWSTR          pLinkNameW;
#endif


    if (!oleInitialized) {
        InitOle();
        if (!oleInitialized) {
            DebugPrint(( TEXT("OLE wasn't initialized successfully\n") ));
            return FALSE;
        }
    }

    hResult = CoCreateInstance(&CLSID_ShellLink,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               &IID_IShellLink,
                               &pShellLink);

    if (SUCCEEDED(hResult)) {

        hResult = pShellLink->lpVtbl->QueryInterface(pShellLink,
                                                     &IID_IPersistFile,
                                                     &pPersistFile);

        if (SUCCEEDED(hResult)) {

            pShellLink->lpVtbl->SetPath(pShellLink, pFileName);
#ifdef UNICODE
            hResult = pPersistFile->lpVtbl->Save(pPersistFile, pLinkName, STGM_READ);
#else
            pLinkNameW = AnsiStringToUnicodeString( pLinkName );
            hResult = pPersistFile->lpVtbl->Save(pPersistFile, pLinkNameW, STGM_READ);
            MemFree( pLinkNameW );
#endif
            pPersistFile->lpVtbl->Release(pPersistFile);
        }

        pShellLink->lpVtbl->Release(pShellLink);
    }

    return SUCCEEDED(hResult);
}



BOOL
IsCoverPageShortcut(
    LPCTSTR  pLinkName
    )

/*++

Routine Description:

    Check if a link is a shortcut to some cover page file

Arguments:

    pLinkName - Specifies the name of a link file

Return Value:

    TRUE if the link file is a shortcut to a cover page file
    FALSE otherwise

--*/

{
    LPTSTR  pExtension;
    TCHAR   filename[MAX_PATH];

    //
    // Resolve the link if necessary and check if the final filename has
    // the properly extension.
    //

    return ResolveShortcut((LPTSTR)pLinkName, filename) &&
           (pExtension = FindFilenameExtension(filename)) &&
           _tcsicmp(pExtension, CP_FILENAME_EXT) == 0;
}



BOOL GetSpecialPath(
   int nFolder,
   LPTSTR Path
   )
/*++

Routine Description:

    Get a path from a CSIDL constant

Arguments:

    nFolder     - CSIDL_ constant
    Path        - Buffer to receive the path, assume this buffer is at least MAX_PATH+1 chars large

Return Value:

    TRUE for success.
    FALSE for failure.

--*/

{
    HRESULT hr;
    LPITEMIDLIST pIdl = NULL;
    LPMALLOC  IMalloc = NULL;
    BOOL fSuccess = FALSE;
    
    hr = SHGetMalloc(&IMalloc);
    if (FAILED(hr) ) {
        DebugPrint(( TEXT("SHGetMalloc() failed, ec = %x\n"),hr));
        goto exit;
    }

    hr = SHGetSpecialFolderLocation (NULL, 
                                     nFolder, 
                                     &pIdl);

    if (FAILED(hr) ) {
        DebugPrint((TEXT("SHGetSpecialFolderLocation(%d) failed, ec = %x\n"),nFolder,hr));
        goto exit;
    }

    hr = SHGetPathFromIDList(pIdl, Path);
    if (FAILED(hr) ) {
        DebugPrint((TEXT("SHGetPAthFromIDList() failed, ec = %x\n"),hr));
        goto exit;
    }
    
    fSuccess = TRUE;

exit:
    if (IMalloc && pIdl) {
        IMalloc->lpVtbl->Free(IMalloc, (void *) pIdl );
    }
    
    if (IMalloc) {
        IMalloc->lpVtbl->Release(IMalloc) ;
    }
    
    return fSuccess;

}



BOOL
GetClientCpDir(
    LPTSTR CpDir,
    DWORD CpDirSize
    )

/*++

Routine Description:

    Gets the client coverpage directory.

Arguments:

    CpDir       - buffer to hold the coverpage dir
    CpDirSize   - size in bytes of CpDir

Return Value:

    Pointer to the client coverpage direcory.

--*/

{
    HKEY hKey;
    LONG rVal;
    DWORD RegType;
    TCHAR PartialPathBuffer[MAX_PATH];
    DWORD dwSize = sizeof(PartialPathBuffer);

    if (!GetSpecialPath(CSIDL_PERSONAL, CpDir )) {
        return FALSE;
    }

    rVal = RegOpenKey(
        HKEY_CURRENT_USER,
        REGKEY_FAX_SETUP,
        &hKey
        );
    if (rVal != ERROR_SUCCESS) {
        return FALSE;
    }

    rVal = RegQueryValueEx(
        hKey,
        REGVAL_CP_LOCATION,
        0,
        &RegType,
        (LPBYTE) PartialPathBuffer,
        &dwSize
        );
    if (rVal != ERROR_SUCCESS) {
        RegCloseKey( hKey );
        return FALSE;
    }

    RegCloseKey( hKey );


    
    if (PartialPathBuffer[0] && PartialPathBuffer[_tcslen(PartialPathBuffer)-1] != TEXT('\\')) {
        _tcscat( PartialPathBuffer, TEXT("\\") );
    }

    ConcatenatePaths(CpDir, PartialPathBuffer);

    //
    // make sure that directory exists
    //
    MakeDirectory(CpDir);

    return TRUE;
}


BOOL
GetServerCpDir(
    LPCTSTR ServerName OPTIONAL,
    LPTSTR CpDir,
    DWORD CpDirSize
    )

/*++

Routine Description:

    Gets the server coverpage directory.

Arguments:

    ServerName  - server name or NULL
    CpDir       - buffer to hold the coverpage dir
    CpDirSize   - size in bytes of CpDir

Return Value:

    Pointer to the server coverpage direcory.

--*/

{
    TCHAR tmpcp[MAX_PATH];

    #undef IDS_COVERPAGE_DIR
    #define IDS_COVERPAGE_DIR                       627
    
    if (!CpDir) {
        return(FALSE);
    }
    
    if (ServerName) {
        wsprintf( tmpcp, TEXT("\\\\%s\\coverpg$"),ServerName);        
    }  else {
        HINSTANCE hResource;
        TCHAR ResourceDll[MAX_PATH];
        TCHAR RestofPath[MAX_PATH];
        if (!GetSpecialPath(CSIDL_COMMON_DOCUMENTS, tmpcp )) {
            return(FALSE);
        }

        ExpandEnvironmentStrings(TEXT("%systemroot%\\system32\\faxocm.dll"),ResourceDll,sizeof(ResourceDll)/sizeof(TCHAR));

        hResource = LoadLibraryEx( ResourceDll, 0, LOAD_LIBRARY_AS_DATAFILE );
        if (!hResource) {
            return(FALSE);
        }

        if (!MyLoadString(hResource,IDS_COVERPAGE_DIR,RestofPath,sizeof(RestofPath)/sizeof(TCHAR),GetSystemDefaultUILanguage())) {
            FreeLibrary( hResource );
            return(FALSE);
        }

        ConcatenatePaths(tmpcp, RestofPath);

        FreeLibrary( hResource );

    }    

    if ((DWORD) lstrlen(tmpcp) + 1 > CpDirSize) {
        return FALSE;
    }

    lstrcpy( CpDir,tmpcp ) ;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\amd64\chk\fxscount.h ===
//
//  faxcount.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the
//  "First Counter" and "First Help" values fo the device they belong to,
//  in order to determine the  absolute location of the counter and
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//

#define FAXOBJ                           0
#define INBOUND_BYTES                    2
#define INBOUND_FAXES                    4
#define INBOUND_PAGES                    6
#define INBOUND_MINUTES                  8
#define INBOUND_FAILED_RECEIVE          10
#define OUTBOUND_BYTES                  12
#define OUTBOUND_FAXES                  14
#define OUTBOUND_PAGES                  16
#define OUTBOUND_MINUTES                18
#define OUTBOUND_FAILED_CONNECTIONS     20
#define OUTBOUND_FAILED_XMIT            22
#define TOTAL_BYTES                     24
#define TOTAL_FAXES                     26
#define TOTAL_PAGES                     28
#define TOTAL_MINUTES                   30
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\util\string.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    string.c

Abstract:

    This file implements string functions for fax.

Author:

    Wesley Witt (wesw) 23-Jan-1995

Environment:

    User Mode

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "faxutil.h"




LPTSTR
StringDup(
    LPCTSTR String
    )
{
    LPTSTR NewString;

    if (!String) {
        return NULL;
    }

    NewString = (LPTSTR) MemAlloc( (_tcslen( String ) + 1) * sizeof(TCHAR) );
    if (!NewString) {
        return NULL;
    }

    _tcscpy( NewString, String );

    return NewString;
}


VOID
FreeString(
    LPVOID String
    )
{
    MemFree( String );
}


LPWSTR
AnsiStringToUnicodeString(
    LPCSTR AnsiString
    )
{
    DWORD Count;
    LPWSTR UnicodeString;


    //
    // first see how big the buffer needs to be
    //
    Count = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        AnsiString,
        -1,
        NULL,
        0
        );

    //
    // i guess the input string is empty
    //
    if (!Count) {
        return NULL;
    }

    //
    // allocate a buffer for the unicode string
    //
    Count += 1;
    UnicodeString = (LPWSTR) MemAlloc( Count * sizeof(UNICODE_NULL) );
    if (!UnicodeString) {
        return NULL;
    }

    //
    // convert the string
    //
    Count = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        AnsiString,
        -1,
        UnicodeString,
        Count
        );

    //
    // the conversion failed
    //
    if (!Count) {
        MemFree( UnicodeString );
        return NULL;
    }

    return UnicodeString;
}


LPSTR
UnicodeStringToAnsiString(
    LPCWSTR UnicodeString
    )
{
    DWORD Count;
    LPSTR AnsiString;


    //
    // first see how big the buffer needs to be
    //
    Count = WideCharToMultiByte(
        CP_ACP,
        0,
        UnicodeString,
        -1,
        NULL,
        0,
        NULL,
        NULL
        );

    //
    // i guess the input string is empty
    //
    if (!Count) {
        return NULL;
    }

    //
    // allocate a buffer for the unicode string
    //
    Count += 1;
    AnsiString = (LPSTR) MemAlloc( Count );
    if (!AnsiString) {
        return NULL;
    }

    //
    // convert the string
    //
    Count = WideCharToMultiByte(
        CP_ACP,
        0,
        UnicodeString,
        -1,
        AnsiString,
        Count,
        NULL,
        NULL
        );

    //
    // the conversion failed
    //
    if (!Count) {
        MemFree( AnsiString );
        return NULL;
    }

    return AnsiString;
}


VOID
MakeDirectory(
    LPCTSTR Dir
    )

/*++

Routine Description:

    Attempt to create all of the directories in the given path.

Arguments:

    Dir                     - Directory path to create

Return Value:

    TRUE for success, FALSE on error

--*/

{
    LPTSTR p, NewDir;


    NewDir = p = ExpandEnvironmentString( Dir );

    __try {
        if (*p != '\\') p += 2;
        while( *++p ) {
            while(*p && *p != TEXT('\\')) p++;
            if (!*p) {
                CreateDirectory( NewDir, NULL );
                return;
            }
            *p = 0;
            CreateDirectory( NewDir, NULL );
            *p = TEXT('\\');
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
    }

    MemFree( NewDir );
}

VOID
HideDirectory(
   LPTSTR Dir
   )
/*++

Routine Description:

    Hide the specified directory

Arguments:

    Dir                     - Directory path to hide

Return Value:

    none.

--*/
{
   DWORD attrib;

   //
   // make sure it exists
   //
   if (!Dir) {
      return;
   }
   
   MakeDirectory( Dir );

   attrib  = GetFileAttributes(Dir);
   
   if (attrib == 0xFFFFFFFF) {
      return;
   }

   attrib |= FILE_ATTRIBUTE_HIDDEN;

   SetFileAttributes( Dir, attrib );

   return;


}


VOID
DeleteDirectory(
    LPTSTR Dir
    )

/*++

Routine Description:

    Attempt to create all of the directories in the given path.

Arguments:

    Dir                     - Directory path to create

Return Value:

    TRUE for success, FALSE on error

--*/

{
    LPTSTR p;

    __try {
        while (TRUE) {
            if (!RemoveDirectory( Dir )) {
                return;
            }
            p = Dir + _tcslen( Dir ) - 1;
            while (*p != TEXT('\\') && p != Dir) p--;
            if (p == Dir) return;
            *p = 0;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
    }
}


int
FormatElapsedTimeStr(
    FILETIME *ElapsedTime,
    LPTSTR TimeStr,
    DWORD StringSize
    )
/*++

Routine Description:

    Convert ElapsedTime to a string.

Arguments:

    ElaspedTime                     - the elapsed time
    TimeStr                         - buffer to store the string into
    StringSize                      - size of the buffer in bytes

Return Value:

    The return value of GetTimeFormat()

--*/

{
    SYSTEMTIME  SystemTime;
    FileTimeToSystemTime( ElapsedTime, &SystemTime );
    return GetTimeFormat(
        LOCALE_SYSTEM_DEFAULT,
        LOCALE_NOUSEROVERRIDE | TIME_FORCE24HOURFORMAT | TIME_NOTIMEMARKER,
        &SystemTime,
        NULL,
        TimeStr,
        StringSize
        );
}


LPTSTR
ExpandEnvironmentString(
    LPCTSTR EnvString
    )
{
    DWORD Size;
    LPTSTR String;


    Size = ExpandEnvironmentStrings( EnvString, NULL, 0 );
    if (Size == 0) {
        return NULL;
    }

    Size += 1;

    String = (LPTSTR) MemAlloc( Size * sizeof(TCHAR) );
    if (String == NULL) {
        return NULL;
    }

    if (ExpandEnvironmentStrings( EnvString, String, Size ) == 0) {
        MemFree( String );
        return NULL;
    }

    return String;
}


LPTSTR
GetEnvVariable(
    LPCTSTR EnvString
    )
{
    DWORD Size;
    LPTSTR EnvVar;


    Size = GetEnvironmentVariable( EnvString, NULL, 0 );
    if (!Size) {
        return NULL;
    }

    EnvVar = (LPTSTR) MemAlloc( Size * sizeof(TCHAR) );
    if (EnvVar == NULL) {
        return NULL;
    }

    Size = GetEnvironmentVariable( EnvString, EnvVar, Size );
    if (!Size) {
        MemFree( EnvVar );
        return NULL;
    }

    return EnvVar;
}

LPTSTR
ConcatenatePaths(
    LPTSTR BasePath,
    LPCTSTR AppendPath
    )
{
   DWORD len;

   len = _tcslen(BasePath);
   if (BasePath[len-1] != (TCHAR) TEXT('\\')) {
      _tcscat(BasePath, TEXT("\\") );
   }

   _tcscat(BasePath, AppendPath);

   return BasePath;

}

int MyLoadString(
    HINSTANCE  hInstance,
    UINT       uID,
    LPTSTR     lpBuffer,
    int        nBufferMax,
    LANGID     LangID
)
{
    HRSRC   hFindRes;  // Handle from FindResourceEx
    HANDLE  hLoadRes;  // Handle from LoadResource
    LPWSTR  pSearch;   // Pointer to search for correct string
    int     cch = 0;   // Count of characters

#ifndef UNICODE
    LPWSTR  pString;   // Pointer to temporary string
#endif

    //
    //  String Tables are broken up into segments of 16 strings each.  Find the segment containing the string we want.
    //
    if ((!(hFindRes = FindResourceEx(hInstance, RT_STRING, (LPTSTR) ((LONG) (((USHORT) uID >> 4) + 1)), (WORD) LangID)))) {
        //
        //  Could not find resource.  Return 0.
        //
        return (cch);
    }

    //
    //  Load the resource.
    //
    hLoadRes = LoadResource(hInstance, hFindRes);

    //
    //  Lock the resource.
    //
    if (pSearch = (LPWSTR) LockResource(hLoadRes)) {
        //
        //  Move past the other strings in this segment. (16 strings in a segment -> & 0x0F)
        //
        uID &= 0x0F;

        //
        //  Find the correct string in this segment.
        //
        while (TRUE) {
            cch = *((WORD *) pSearch++);
            if (uID-- == 0) {
                break;
            }

            pSearch += cch;
        }

        //
        //  Store the found pointer in the given pointer.
        //
        if (nBufferMax < cch) {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return 0;
        }

#ifndef UNICODE
        pString = MemAlloc(sizeof(WCHAR) * nBufferMax);
        ZeroMemory(pString, sizeof(WCHAR) * nBufferMax);
        CopyMemory(pString, pSearch, sizeof(WCHAR) * cch);

        WideCharToMultiByte(CP_THREAD_ACP, 0, pString, -1, lpBuffer, (cch + 1), NULL, NULL);
        MemFree(pString);
#else
        ZeroMemory(lpBuffer, sizeof(WCHAR) * nBufferMax);
        CopyMemory(lpBuffer, pSearch, sizeof(WCHAR) * cch);
#endif
    }

    //
    //  Return the number of characters in the string.
    //
    return (cch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\amd64\chk\sdk\efsputil.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    efsputil.h

--*/

#ifndef _EFSPUTIL_H_
#define _EFSPUTIL_H_

typedef struct tag_FSPI_BRAND_INFO
{
    DWORD   dwSizeOfStruct;
    LPWSTR  lptstrSenderTsid;
    LPWSTR  lptstrRecipientPhoneNumber;
    LPWSTR  lptstrSenderCompany;
    SYSTEMTIME tmDateTime;
} FSPI_BRAND_INFO;

typedef const FSPI_BRAND_INFO * LPCFSPI_BRAND_INFO;
typedef FSPI_BRAND_INFO * LPFSPI_BRAND_INFO;


#ifdef __cplusplus
extern "C" {
#endif


HRESULT
WINAPI
FaxBrandDocument(
    LPCTSTR lpctstrFile,
    LPCFSPI_BRAND_INFO lpcBrandInfo
);

HRESULT
WINAPI
FaxRenderCoverPage(
  LPCTSTR lpctstrTargetFile,
  LPCFSPI_COVERPAGE_INFO lpCoverPageInfo,
  LPCFSPI_PERSONAL_PROFILE lpRecipientProfile,
  LPCFSPI_PERSONAL_PROFILE lpSenderProfile,
  SYSTEMTIME tmSentTime,
  LPCTSTR lpctstrBodyTiff
);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\web\images\ppmtogif.c ===
/* ppmtogif.c - read a portable pixmap and produce a GIF file
**
** Based on GIFENCOD by David Rowley <mgardi@watdscu.waterloo.edu>.A
** Lempel-Zim compression based on "compress".
**
** Modified by Marcel Wijkstra <wijkstra@fwi.uva.nl>
*/

#include "ppm.h"
#include "ppmcmap.h"

#define MAXCOLORS 256

/*
 * Pointer to function returning an int
 */
typedef int (* ifunptr) ARGS((int, int));

/*
 * a code_int must be able to hold 2**BITS values of type int, and also -1
 */
typedef int             code_int;

#ifdef SIGNED_COMPARE_SLOW
typedef unsigned long int count_int;
typedef unsigned short int count_short;
#else /*SIGNED_COMPARE_SLOW*/
typedef long int          count_int;
#endif /*SIGNED_COMPARE_SLOW*/

static int colorstobpp ARGS(( int colors ));
static int GetPixel ARGS(( int x, int y ));
static void BumpPixel ARGS(( void ));
static int GIFNextPixel ARGS(( ifunptr getpixel ));
static void GIFEncode ARGS(( FILE* fp, int GWidth, int GHeight, int GInterlace, int Background, int Transparent, int BitsPerPixel, int* Red, int* Green, int* Blue, ifunptr GetPixel ));
int Red[MAXCOLORS],Green[MAXCOLORS],Blue[MAXCOLORS],perm[MAXCOLORS],permi[MAXCOLORS];
int colors;
pixval maxtmp;
static void Putword ARGS(( int w, FILE* fp ));
static void compress ARGS(( int init_bits, FILE* outfile, ifunptr ReadValue ));
static void output ARGS(( code_int code ));
static void cl_block ARGS(( void ));
static void cl_hash ARGS(( count_int hsize ));
static void writeerr ARGS(( void ));
static void char_init ARGS(( void ));
static void char_out ARGS(( int c ));
static void flush_char ARGS(( void ));
static int sqr ARGS((int x));
static int closestcolor ARGS((pixel color));

static pixel** pixels;
static colorhash_table cht;

int
main( argc, argv )
    int argc;
    char* argv[];
    {
    FILE* ifp;
    int argn, rows, cols, i,j,k, BitsPerPixel;
    int interlace, sort, map, transparent;
    pixel transcolor;
    char *mapfile;
    pixval maxval;
    colorhist_vector chv;
    char* usage = "[-interlace] [-sort] [-map mapfile] [-transparent color] [ppmfile]";

    ppm_init( &argc, argv );

    argn = 1;
    interlace = 0;
    sort = 0;
    map = 0;
    transparent = -1;

    while ( argn < argc && argv[argn][0] == '-' && argv[argn][1] != '\0' )
        {
        if ( pm_keymatch( argv[argn], "-interlace", 2 ) )
            interlace = 1;
        else if ( pm_keymatch( argv[argn], "-nointerlace", 2 ) )
            interlace = 0;
        else if ( pm_keymatch( argv[argn], "-sort", 2 ) )
            sort = 1;
        else if ( pm_keymatch( argv[argn], "-map", 2 ) ) {
            map = 1;
            if (++argn < argc)
              mapfile = argv[argn];
            else pm_usage(usage); }
	else if ( pm_keymatch( argv[argn], "-transparent", 2 ) ) {
	    transparent = 1;
	    if (++argn < argc)
		transcolor = ppm_parsecolor( argv[argn], 255 );
	    else
		pm_usage(usage);
	}
        else
            pm_usage( usage );
        ++argn;
        }

    /* Read the colormap from another file. */
    if (map) {
      ifp = pm_openr(mapfile);
      pixels = ppm_readppm( ifp, &cols, &rows, &maxval );
      pm_close( ifp );

      /* Figure out the colormap from the <mapfile>. */
      pm_message( "computing other colourmap..." );
      chv = ppm_computecolorhist( pixels, cols, rows, MAXCOLORS, &colors );

      ppm_freearray(pixels,rows); }

    if ( argn < argc )
        {
        ifp = pm_openr( argv[argn] );
        ++argn;
        }
    else
        ifp = stdin;

    if ( argn != argc )
        pm_usage( usage );

    pixels = ppm_readppm( ifp, &cols, &rows, &maxtmp );
    if (!map)
      maxval=maxtmp;

    pm_close( ifp );

    /* Figure out the colormap. */
    if (!map) {
      pm_message( "computing colourmap..." );
      chv = ppm_computecolorhist( pixels, cols, rows, MAXCOLORS, &colors ); }

    if ( chv == (colorhist_vector) 0 )
        pm_error(
            "too many colors - try doing a 'ppmquant %d'", MAXCOLORS );
    pm_message( "%d colours found", colors );

    /* Now turn the ppm colormap into the appropriate GIF colormap. */
    if ( maxval > 255 )
        pm_message(
            "maxval is not 255 - automatically rescaling colors" );
    for ( i = 0; i < colors; ++i )
        {
        if ( maxval == 255 )
            {
            Red[i] = PPM_GETR( chv[i].color );
            Green[i] = PPM_GETG( chv[i].color );
            Blue[i] = PPM_GETB( chv[i].color );
            }
        else
            {
            Red[i] = (int) PPM_GETR( chv[i].color ) * 255 / maxval;
            Green[i] = (int) PPM_GETG( chv[i].color ) * 255 / maxval;
            Blue[i] = (int) PPM_GETB( chv[i].color ) * 255 / maxval;
            }
        }

    /* Sort the colormap */
    for (i=0;i<colors;i++)
      permi[i]=i;
    if (sort) {
      pm_message("sorting colourmap");
      for (i=0;i<colors;i++)
        for (j=i+1;j<colors;j++)
          if (((Red[i]*MAXCOLORS)+Green[i])*MAXCOLORS+Blue[i] >
              ((Red[j]*MAXCOLORS)+Green[j])*MAXCOLORS+Blue[j]) {
            k=permi[i]; permi[i]=permi[j]; permi[j]=k;
            k=Red[i]; Red[i]=Red[j]; Red[j]=k;
            k=Green[i]; Green[i]=Green[j]; Green[j]=k;
            k=Blue[i]; Blue[i]=Blue[j]; Blue[j]=k; } }
    for (i=0;i<colors;i++)
      perm[permi[i]]=i;

    BitsPerPixel = colorstobpp( colors );

    /* And make a hash table for fast lookup. */
    cht = ppm_colorhisttocolorhash( chv, colors );
    ppm_freecolorhist( chv );

    /* figure out the transparent colour index */
    if (transparent > 0) {
    	transparent = ppm_lookupcolor( cht, &transcolor );
	if (transparent == -1)
	    transparent = closestcolor( transcolor );
        else
            transparent = perm[transparent];
    }

    /* All set, let's do it. */
    GIFEncode(
        stdout, cols, rows, interlace, 0, transparent, BitsPerPixel,
        Red, Green, Blue, GetPixel );

    exit( 0 );
    }

static int
colorstobpp( colors )
int colors;
    {
    int bpp;

    if ( colors <= 2 )
        bpp = 1;
    else if ( colors <= 4 )
        bpp = 2;
    else if ( colors <= 8 )
        bpp = 3;
    else if ( colors <= 16 )
        bpp = 4;
    else if ( colors <= 32 )
        bpp = 5;
    else if ( colors <= 64 )
        bpp = 6;
    else if ( colors <= 128 )
        bpp = 7;
    else if ( colors <= 256 )
        bpp = 8;
    else
        pm_error( "can't happen" );

    return bpp;
    }


static int
sqr(x)
int x;
  {
  return x*x;
  }


static int
closestcolor(color)
pixel color;
  {
  int i,r,g,b,d,
      imin,dmin;

  r=(int)PPM_GETR(color)*255/maxtmp;
  g=(int)PPM_GETG(color)*255/maxtmp;
  b=(int)PPM_GETB(color)*255/maxtmp;

  dmin=1000000;
  for (i=0;i<colors;i++) {
    d=sqr(r-Red[i])+sqr(g-Green[i])+sqr(b-Blue[i]);
    if (d<dmin) {
      dmin=d;
      imin=i; } }
  ppm_addtocolorhash(cht,&color,permi[imin]);
  return imin;
  }


static int
GetPixel( x, y )
int x, y;
    {
    int color;

    color = ppm_lookupcolor( cht, &pixels[y][x] );
    if (color == -1)
      color = closestcolor(pixels[y][x]);
    else
      color=perm[color];
    return color;
    }


/*****************************************************************************
 *
 * GIFENCODE.C    - GIF Image compression interface
 *
 * GIFEncode( FName, GHeight, GWidth, GInterlace, Background, Transparent,
 *            BitsPerPixel, Red, Green, Blue, GetPixel )
 *
 *****************************************************************************/

#define TRUE 1
#define FALSE 0

static int Width, Height;
static int curx, cury;
static long CountDown;
static int Pass = 0;
static int Interlace;

/*
 * Bump the 'curx' and 'cury' to point to the next pixel
 */
static void
BumpPixel()
{
        /*
         * Bump the current X position
         */
        ++curx;

        /*
         * If we are at the end of a scan line, set curx back to the beginning
         * If we are interlaced, bump the cury to the appropriate spot,
         * otherwise, just increment it.
         */
        if( curx == Width ) {
                curx = 0;

                if( !Interlace )
                        ++cury;
                else {
                     switch( Pass ) {

                       case 0:
                          cury += 8;
                          if( cury >= Height ) {
                                ++Pass;
                                cury = 4;
                          }
                          break;

                       case 1:
                          cury += 8;
                          if( cury >= Height ) {
                                ++Pass;
                                cury = 2;
                          }
                          break;

                       case 2:
                          cury += 4;
                          if( cury >= Height ) {
                             ++Pass;
                             cury = 1;
                          }
                          break;

                       case 3:
                          cury += 2;
                          break;
                        }
                }
        }
}

/*
 * Return the next pixel from the image
 */
static int
GIFNextPixel( getpixel )
ifunptr getpixel;
{
        int r;

        if( CountDown == 0 )
                return EOF;

        --CountDown;

        r = ( * getpixel )( curx, cury );

        BumpPixel();

        return r;
}

/* public */

static void
GIFEncode( fp, GWidth, GHeight, GInterlace, Background, Transparent,
           BitsPerPixel, Red, Green, Blue, GetPixel )

FILE* fp;
int GWidth, GHeight;
int GInterlace;
int Background;
int Transparent;
int BitsPerPixel;
int Red[], Green[], Blue[];
ifunptr GetPixel;
{
        int B;
        int RWidth, RHeight;
        int LeftOfs, TopOfs;
        int Resolution;
        int ColorMapSize;
        int InitCodeSize;
        int i;

        Interlace = GInterlace;

        ColorMapSize = 1 << BitsPerPixel;

        RWidth = Width = GWidth;
        RHeight = Height = GHeight;
        LeftOfs = TopOfs = 0;

        Resolution = BitsPerPixel;

        /*
         * Calculate number of bits we are expecting
         */
        CountDown = (long)Width * (long)Height;

        /*
         * Indicate which pass we are on (if interlace)
         */
        Pass = 0;

        /*
         * The initial code size
         */
        if( BitsPerPixel <= 1 )
                InitCodeSize = 2;
        else
                InitCodeSize = BitsPerPixel;

        /*
         * Set up the current x and y position
         */
        curx = cury = 0;

        /*
         * Write the Magic header
         */
        fwrite( Transparent < 0 ? "GIF87a" : "GIF89a", 1, 6, fp );

        /*
         * Write out the screen width and height
         */
        Putword( RWidth, fp );
        Putword( RHeight, fp );

        /*
         * Indicate that there is a global colour map
         */
        B = 0x80;       /* Yes, there is a color map */

        /*
         * OR in the resolution
         */
        B |= (Resolution - 1) << 5;

        /*
         * OR in the Bits per Pixel
         */
        B |= (BitsPerPixel - 1);

        /*
         * Write it out
         */
        fputc( B, fp );

        /*
         * Write out the Background colour
         */
        fputc( Background, fp );

        /*
         * Byte of 0's (future expansion)
         */
        fputc( 0, fp );

        /*
         * Write out the Global Colour Map
         */
        for( i=0; i<ColorMapSize; ++i ) {
                fputc( Red[i], fp );
                fputc( Green[i], fp );
                fputc( Blue[i], fp );
        }

	/*
	 * Write out extension for transparent colour index, if necessary.
	 */
	if ( Transparent >= 0 ) {
	    fputc( '!', fp );
	    fputc( 0xf9, fp );
	    fputc( 4, fp );
	    fputc( 1, fp );
	    fputc( 0, fp );
	    fputc( 0, fp );
	    fputc( Transparent, fp );
	    fputc( 0, fp );
	}

        /*
         * Write an Image separator
         */
        fputc( ',', fp );

        /*
         * Write the Image header
         */

        Putword( LeftOfs, fp );
        Putword( TopOfs, fp );
        Putword( Width, fp );
        Putword( Height, fp );

        /*
         * Write out whether or not the image is interlaced
         */
        if( Interlace )
                fputc( 0x40, fp );
        else
                fputc( 0x00, fp );

        /*
         * Write out the initial code size
         */
        fputc( InitCodeSize, fp );

        /*
         * Go and actually compress the data
         */
        compress( InitCodeSize+1, fp, GetPixel );

        /*
         * Write out a Zero-length packet (to end the series)
         */
        fputc( 0, fp );

        /*
         * Write the GIF file terminator
         */
        fputc( ';', fp );

        /*
         * And close the file
         */
        fclose( fp );
}

/*
 * Write out a word to the GIF file
 */
static void
Putword( w, fp )
int w;
FILE* fp;
{
        fputc( w & 0xff, fp );
        fputc( (w / 256) & 0xff, fp );
}


/***************************************************************************
 *
 *  GIFCOMPR.C       - GIF Image compression routines
 *
 *  Lempel-Ziv compression based on 'compress'.  GIF modifications by
 *  David Rowley (mgardi@watdcsu.waterloo.edu)
 *
 ***************************************************************************/

/*
 * General DEFINEs
 */

#define BITS    12

#define HSIZE  5003            /* 80% occupancy */

#ifdef NO_UCHAR
 typedef char   char_type;
#else /*NO_UCHAR*/
 typedef        unsigned char   char_type;
#endif /*NO_UCHAR*/

/*
 *
 * GIF Image compression - modified 'compress'
 *
 * Based on: compress.c - File compression ala IEEE Computer, June 1984.
 *
 * By Authors:  Spencer W. Thomas       (decvax!harpo!utah-cs!utah-gr!thomas)
 *              Jim McKie               (decvax!mcvax!jim)
 *              Steve Davies            (decvax!vax135!petsd!peora!srd)
 *              Ken Turkowski           (decvax!decwrl!turtlevax!ken)
 *              James A. Woods          (decvax!ihnp4!ames!jaw)
 *              Joe Orost               (decvax!vax135!petsd!joe)
 *
 */
#include <ctype.h>

#define ARGVAL() (*++(*argv) || (--argc && *++argv))

static int n_bits;                        /* number of bits/code */
static int maxbits = BITS;                /* user settable max # bits/code */
static code_int maxcode;                  /* maximum code, given n_bits */
static code_int maxmaxcode = (code_int)1 << BITS; /* should NEVER generate this code */
#ifdef COMPATIBLE               /* But wrong! */
# define MAXCODE(n_bits)        ((code_int) 1 << (n_bits) - 1)
#else /*COMPATIBLE*/
# define MAXCODE(n_bits)        (((code_int) 1 << (n_bits)) - 1)
#endif /*COMPATIBLE*/

static count_int htab [HSIZE];
static unsigned short codetab [HSIZE];
#define HashTabOf(i)       htab[i]
#define CodeTabOf(i)    codetab[i]

static code_int hsize = HSIZE;                 /* for dynamic table sizing */

/*
 * To save much memory, we overlay the table used by compress() with those
 * used by decompress().  The tab_prefix table is the same size and type
 * as the codetab.  The tab_suffix table needs 2**BITS characters.  We
 * get this from the beginning of htab.  The output stack uses the rest
 * of htab, and contains characters.  There is plenty of room for any
 * possible stack (stack used to be 8000 characters).
 */

#define tab_prefixof(i) CodeTabOf(i)
#define tab_suffixof(i)        ((char_type*)(htab))[i]
#define de_stack               ((char_type*)&tab_suffixof((code_int)1<<BITS))

static code_int free_ent = 0;                  /* first unused entry */

/*
 * block compression parameters -- after all codes are used up,
 * and compression rate changes, start over.
 */
static int clear_flg = 0;

static int offset;
static long int in_count = 1;            /* length of input */
static long int out_count = 0;           /* # of codes output (for debugging) */

/*
 * compress stdin to stdout
 *
 * Algorithm:  use open addressing double hashing (no chaining) on the
 * prefix code / next character combination.  We do a variant of Knuth's
 * algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime
 * secondary probe.  Here, the modular division first probe is gives way
 * to a faster exclusive-or manipulation.  Also do block compression with
 * an adaptive reset, whereby the code table is cleared when the compression
 * ratio decreases, but after the table fills.  The variable-length output
 * codes are re-sized at this point, and a special CLEAR code is generated
 * for the decompressor.  Late addition:  construct the table according to
 * file size for noticeable speed improvement on small files.  Please direct
 * questions about this implementation to ames!jaw.
 */

static int g_init_bits;
static FILE* g_outfile;

static int ClearCode;
static int EOFCode;

static void
compress( init_bits, outfile, ReadValue )
int init_bits;
FILE* outfile;
ifunptr ReadValue;
{
    register long fcode;
    register code_int i /* = 0 */;
    register int c;
    register code_int ent;
    register code_int disp;
    register code_int hsize_reg;
    register int hshift;

    /*
     * Set up the globals:  g_init_bits - initial number of bits
     *                      g_outfile   - pointer to output file
     */
    g_init_bits = init_bits;
    g_outfile = outfile;

    /*
     * Set up the necessary values
     */
    offset = 0;
    out_count = 0;
    clear_flg = 0;
    in_count = 1;
    maxcode = MAXCODE(n_bits = g_init_bits);

    ClearCode = (1 << (init_bits - 1));
    EOFCode = ClearCode + 1;
    free_ent = ClearCode + 2;

    char_init();

    ent = GIFNextPixel( ReadValue );

    hshift = 0;
    for ( fcode = (long) hsize;  fcode < 65536L; fcode *= 2L )
        ++hshift;
    hshift = 8 - hshift;                /* set hash code range bound */

    hsize_reg = hsize;
    cl_hash( (count_int) hsize_reg);            /* clear hash table */

    output( (code_int)ClearCode );

#ifdef SIGNED_COMPARE_SLOW
    while ( (c = GIFNextPixel( ReadValue )) != (unsigned) EOF ) {
#else /*SIGNED_COMPARE_SLOW*/
    while ( (c = GIFNextPixel( ReadValue )) != EOF ) {  /* } */
#endif /*SIGNED_COMPARE_SLOW*/

        ++in_count;

        fcode = (long) (((long) c << maxbits) + ent);
        i = (((code_int)c << hshift) ^ ent);    /* xor hashing */

        if ( HashTabOf (i) == fcode ) {
            ent = CodeTabOf (i);
            continue;
        } else if ( (long)HashTabOf (i) < 0 )      /* empty slot */
            goto nomatch;
        disp = hsize_reg - i;           /* secondary hash (after G. Knott) */
        if ( i == 0 )
            disp = 1;
probe:
        if ( (i -= disp) < 0 )
            i += hsize_reg;

        if ( HashTabOf (i) == fcode ) {
            ent = CodeTabOf (i);
            continue;
        }
        if ( (long)HashTabOf (i) > 0 )
            goto probe;
nomatch:
        output ( (code_int) ent );
        ++out_count;
        ent = c;
#ifdef SIGNED_COMPARE_SLOW
        if ( (unsigned) free_ent < (unsigned) maxmaxcode) {
#else /*SIGNED_COMPARE_SLOW*/
        if ( free_ent < maxmaxcode ) {  /* } */
#endif /*SIGNED_COMPARE_SLOW*/
            CodeTabOf (i) = free_ent++; /* code -> hashtable */
            HashTabOf (i) = fcode;
        } else
                cl_block();
    }
    /*
     * Put out the final code.
     */
    output( (code_int)ent );
    ++out_count;
    output( (code_int) EOFCode );
}

/*****************************************************************
 * TAG( output )
 *
 * Output the given code.
 * Inputs:
 *      code:   A n_bits-bit integer.  If == -1, then EOF.  This assumes
 *              that n_bits =< (long)wordsize - 1.
 * Outputs:
 *      Outputs code to the file.
 * Assumptions:
 *      Chars are 8 bits long.
 * Algorithm:
 *      Maintain a BITS character long buffer (so that 8 codes will
 * fit in it exactly).  Use the VAX insv instruction to insert each
 * code in turn.  When the buffer fills up empty it and start over.
 */

static unsigned long cur_accum = 0;
static int cur_bits = 0;

static unsigned long masks[] = { 0x0000, 0x0001, 0x0003, 0x0007, 0x000F,
                                  0x001F, 0x003F, 0x007F, 0x00FF,
                                  0x01FF, 0x03FF, 0x07FF, 0x0FFF,
                                  0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF };

static void
output( code )
code_int  code;
{
    cur_accum &= masks[ cur_bits ];

    if( cur_bits > 0 )
        cur_accum |= ((long)code << cur_bits);
    else
        cur_accum = code;

    cur_bits += n_bits;

    while( cur_bits >= 8 ) {
        char_out( (unsigned int)(cur_accum & 0xff) );
        cur_accum >>= 8;
        cur_bits -= 8;
    }

    /*
     * If the next entry is going to be too big for the code size,
     * then increase it, if possible.
     */
   if ( free_ent > maxcode || clear_flg ) {

            if( clear_flg ) {

                maxcode = MAXCODE (n_bits = g_init_bits);
                clear_flg = 0;

            } else {

                ++n_bits;
                if ( n_bits == maxbits )
                    maxcode = maxmaxcode;
                else
                    maxcode = MAXCODE(n_bits);
            }
        }

    if( code == EOFCode ) {
        /*
         * At EOF, write the rest of the buffer.
         */
        while( cur_bits > 0 ) {
                char_out( (unsigned int)(cur_accum & 0xff) );
                cur_accum >>= 8;
                cur_bits -= 8;
        }

        flush_char();

        fflush( g_outfile );

        if( ferror( g_outfile ) )
                writeerr();
    }
}

/*
 * Clear out the hash table
 */
static void
cl_block ()             /* table clear for block compress */
{

        cl_hash ( (count_int) hsize );
        free_ent = ClearCode + 2;
        clear_flg = 1;

        output( (code_int)ClearCode );
}

static void
cl_hash(hsize)          /* reset code table */
register count_int hsize;
{

        register count_int *htab_p = htab+hsize;

        register long i;
        register long m1 = -1;

        i = hsize - 16;
        do {                            /* might use Sys V memset(3) here */
                *(htab_p-16) = m1;
                *(htab_p-15) = m1;
                *(htab_p-14) = m1;
                *(htab_p-13) = m1;
                *(htab_p-12) = m1;
                *(htab_p-11) = m1;
                *(htab_p-10) = m1;
                *(htab_p-9) = m1;
                *(htab_p-8) = m1;
                *(htab_p-7) = m1;
                *(htab_p-6) = m1;
                *(htab_p-5) = m1;
                *(htab_p-4) = m1;
                *(htab_p-3) = m1;
                *(htab_p-2) = m1;
                *(htab_p-1) = m1;
                htab_p -= 16;
        } while ((i -= 16) >= 0);

        for ( i += 16; i > 0; --i )
                *--htab_p = m1;
}

static void
writeerr()
{
        pm_error( "error writing output file" );
}

/******************************************************************************
 *
 * GIF Specific routines
 *
 ******************************************************************************/

/*
 * Number of characters so far in this 'packet'
 */
static int a_count;

/*
 * Set up the 'byte output' routine
 */
static void
char_init()
{
        a_count = 0;
}

/*
 * Define the storage for the packet accumulator
 */
static char accum[ 256 ];

/*
 * Add a character to the end of the current packet, and if it is 254
 * characters, flush the packet to disk.
 */
static void
char_out( c )
int c;
{
        accum[ a_count++ ] = c;
        if( a_count >= 254 )
                flush_char();
}

/*
 * Flush the packet to disk, and reset the accumulator
 */
static void
flush_char()
{
        if( a_count > 0 ) {
                fputc( a_count, g_outfile );
                fwrite( accum, 1, a_count, g_outfile );
                a_count = 0;
        }
}

/* The End */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\web\faxisapi\httpext.h ===
/********
*
*  Copyright (c) 1995  Process Software Corporation
*
*  Copyright (c) 1995  Microsoft Corporation
*
*
*  Module Name  : HttpExt.h
*
*  Abstract :
*
*     This module contains  the structure definitions and prototypes for the
*     version 1.0 HTTP Server Extension interface.
*
******************/

#ifndef _HTTPEXT_H_
#define _HTTPEXT_H_

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

#define   HSE_VERSION_MAJOR           1      // major version of this spec
#define   HSE_VERSION_MINOR           0      // minor version of this spec
#define   HSE_LOG_BUFFER_LEN         80
#define   HSE_MAX_EXT_DLL_NAME_LEN  256

typedef   LPVOID  HCONN;

// the following are the status codes returned by the Extension DLL

#define   HSE_STATUS_SUCCESS                       1
#define   HSE_STATUS_SUCCESS_AND_KEEP_CONN         2
#define   HSE_STATUS_PENDING                       3
#define   HSE_STATUS_ERROR                         4

// The following are the values to request services with the ServerSupportFunction.
//  Values from 0 to 1000 are reserved for future versions of the interface

#define   HSE_REQ_BASE                             0
#define   HSE_REQ_SEND_URL_REDIRECT_RESP           ( HSE_REQ_BASE + 1 )
#define   HSE_REQ_SEND_URL                         ( HSE_REQ_BASE + 2 )
#define   HSE_REQ_SEND_RESPONSE_HEADER             ( HSE_REQ_BASE + 3 )
#define   HSE_REQ_DONE_WITH_SESSION                ( HSE_REQ_BASE + 4 )
#define   HSE_REQ_END_RESERVED                     1000

//
//  These are Microsoft specific extensions
//

#define   HSE_REQ_MAP_URL_TO_PATH                  (HSE_REQ_END_RESERVED+1)
#define   HSE_REQ_GET_SSPI_INFO                    (HSE_REQ_END_RESERVED+2)


//
// passed to GetExtensionVersion
//

typedef struct   _HSE_VERSION_INFO {

    DWORD  dwExtensionVersion;
    CHAR   lpszExtensionDesc[HSE_MAX_EXT_DLL_NAME_LEN];

} HSE_VERSION_INFO, *LPHSE_VERSION_INFO;

//
// passed to extension procedure on a new request
//
typedef struct _EXTENSION_CONTROL_BLOCK {

    DWORD     cbSize;                 // size of this struct.
    DWORD     dwVersion;              // version info of this spec
    HCONN     ConnID;                 // Context number not to be modified!
    DWORD     dwHttpStatusCode;       // HTTP Status code
    CHAR      lpszLogData[HSE_LOG_BUFFER_LEN];// null terminated log info specific to this Extension DLL

    LPSTR     lpszMethod;             // REQUEST_METHOD
    LPSTR     lpszQueryString;        // QUERY_STRING
    LPSTR     lpszPathInfo;           // PATH_INFO
    LPSTR     lpszPathTranslated;     // PATH_TRANSLATED

    DWORD     cbTotalBytes;           // Total bytes indicated from client
    DWORD     cbAvailable;            // Available number of bytes
    LPBYTE    lpbData;                // pointer to cbAvailable bytes

    LPSTR     lpszContentType;        // Content type of client data

    BOOL (WINAPI * GetServerVariable) ( HCONN       hConn,
                                        LPSTR       lpszVariableName, 						                      							  					
				                        LPVOID      lpvBuffer,
                                        LPDWORD     lpdwSize );

    BOOL (WINAPI * WriteClient)  ( HCONN      ConnID,
                                   LPVOID     Buffer,
                                   LPDWORD    lpdwBytes,
                                   DWORD      dwReserved );

    BOOL (WINAPI * ReadClient)  ( HCONN      ConnID,
                                  LPVOID     lpvBuffer,
                                  LPDWORD    lpdwSize );

    BOOL (WINAPI * ServerSupportFunction)( HCONN      hConn,
                                           DWORD      dwHSERRequest,
                                           LPVOID     lpvBuffer,
                                           LPDWORD    lpdwSize,
                                           LPDWORD    lpdwDataType );

} EXTENSION_CONTROL_BLOCK, *LPEXTENSION_CONTROL_BLOCK;

//
//  these are the prototypes that must be exported from the extension DLL
//

BOOL  WINAPI   GetExtensionVersion( HSE_VERSION_INFO  *pVer );
DWORD WINAPI   HttpExtensionProc(  EXTENSION_CONTROL_BLOCK *pECB );

// the following type declarations is for the server side

typedef BOOL  (WINAPI * PFN_GETEXTENSIONVERSION)( HSE_VERSION_INFO  *pVer );
typedef DWORD (WINAPI * PFN_HTTPEXTENSIONPROC )( EXTENSION_CONTROL_BLOCK *pECB );

#ifdef __cplusplus
}
#endif

#endif  // end definition _HTTPEXT_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\web\faxisapi\httpfilt.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    httpfilt.h

Abstract:

    This module contains the Microsoft HTTP filter extension info

Revision History:

--*/

#ifndef _HTTPFILT_H_
#define _HTTPFILT_H_

#ifdef __cplusplus
extern "C" {
#endif

//
//  Current version of the filter spec is 1.0
//

#define HTTP_FILTER_REVISION    MAKELONG( 0, 1);

#define SF_MAX_USERNAME         (256+1)
#define SF_MAX_PASSWORD         (256+1)

#define SF_MAX_FILTER_DESC_LEN  (256+1)

//
//  These values can be used with the pfnSFCallback function supplied in
//  the filter context structure
//

enum SF_REQ_TYPE
{
    //
    //  Sends a complete HTTP server response header including
    //  the status, server version, message time and MIME version.
    //
    //  Server extensions should append other information at the end,
    //  such as Content-type, Content-length etc followed by an extra
    //  '\r\n'.
    //
    //  pData - Zero terminated string pointing to optional
    //      status string (i.e., "401 Access Denied") or NULL for
    //      the default response of "200 OK".
    //
    //  ul1 - Zero terminated string pointing to optional data to be
    //      appended and set with the header.  If NULL, the header will
    //      be terminated with an empty line.
    //

    SF_REQ_SEND_RESPONSE_HEADER,

    //
    //  If the server denies the HTTP request, add the specified headers
    //  to the server error response.
    //
    //  This allows an authentication filter to advertise its services
    //  w/o filtering every request.  Generally the headers will be
    //  WWW-Authenticate headers with custom authentication schemes but
    //  no restriction is placed on what headers may be specified.
    //
    //  pData - Zero terminated string pointing to one or more header lines
    //      with terminating '\r\n'.
    //

    SF_REQ_ADD_HEADERS_ON_DENIAL,

    //
    //  Only used by raw data filters that return SF_STATUS_READ_NEXT
    //
    //  ul1 - size in bytes for the next read
    //

    SF_REQ_SET_NEXT_READ_SIZE
};


//
//  These values are returned by the filter entry point when a new request is
//  received indicating their interest in this particular request
//

enum SF_STATUS_TYPE
{
    //
    //  The filter has handled the HTTP request.  The server should disconnect
    //  the session.
    //

    SF_STATUS_REQ_FINISHED = 0x8000000,

    //
    //  Same as SF_STATUS_FINISHED except the server should keep the TCP
    //  session open if the option was negotiated
    //

    SF_STATUS_REQ_FINISHED_KEEP_CONN,

    //
    //  The next filter in the notification chain should be called
    //

    SF_STATUS_REQ_NEXT_NOTIFICATION,

    //
    //  This filter handled the notification.  No other handles should be
    //  called for this particular notification type
    //

    SF_STATUS_REQ_HANDLED_NOTIFICATION,

    //
    //  An error occurred.  The server should use GetLastError() and indicate
    //  the error to the client
    //

    SF_STATUS_REQ_ERROR,

    //
    //  The filter is an opaque stream filter and we're negotiating the
    //  session parameters.  Only valid for raw read notification.
    //

    SF_STATUS_REQ_READ_NEXT
};

//
//  pvNotification points to this structure for all request notification types
//

typedef struct _HTTP_FILTER_CONTEXT
{
    DWORD          cbSize;

    //
    //  This is the structure revision level.
    //

    DWORD          Revision;

    //
    //  Private context information for the server.
    //

    PVOID          ServerContext;
    DWORD          ulReserved;

    //
    //  TRUE if this request is coming over a secure port
    //

    BOOL           fIsSecurePort;

    //
    //  A context that can be used by the filter
    //

    PVOID          pFilterContext;

    //
    //  Server callbacks
    //

    BOOL (WINAPI * GetServerVariable) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPSTR                         lpszVariableName,
        LPVOID                        lpvBuffer,
        LPDWORD                       lpdwSize
        );

    BOOL (WINAPI * AddResponseHeaders) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPSTR                         lpszHeaders,
        DWORD                         dwReserved
        );

    BOOL (WINAPI * WriteClient)  (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPVOID                        Buffer,
        LPDWORD                       lpdwBytes,
        DWORD                         dwReserved
        );

    VOID * (WINAPI * AllocMem) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        DWORD                         cbSize,
        DWORD                         dwReserved
        );

    BOOL (WINAPI * ServerSupportFunction) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        enum SF_REQ_TYPE              sfReq,
        PVOID                         pData,
        DWORD                         ul1,
        DWORD                         ul2
        );

} HTTP_FILTER_CONTEXT, *PHTTP_FILTER_CONTEXT;

//
//  This structure is the notification info for the read and send raw data
//  notification types
//

typedef struct _HTTP_FILTER_RAW_DATA
{
    //
    //  This is a pointer to the data for the filter to process.
    //

    PVOID         pvInData;
    DWORD         cbInData;       // Number of valid data bytes
    DWORD         cbInBuffer;     // Total size of buffer

    DWORD         dwReserved;

} HTTP_FILTER_RAW_DATA, *PHTTP_FILTER_RAW_DATA;

//
//  This structure is the notification info for when the server is about to
//  process the client headers
//

typedef struct _HTTP_FILTER_PREPROC_HEADERS
{
    //
    //  Retrieves the specified header value.  Header names should include
    //  the trailing ':'.  The special values 'method', 'url' and 'version'
    //  can be used to retrieve the individual portions of the request line
    //

    BOOL (WINAPI * GetHeader) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPSTR                         lpszName,
        LPVOID                        lpvBuffer,
        LPDWORD                       lpdwSize
        );

    //
    //  Replaces this header value to the specified value.  To delete a header,
    //  specified a value of '\0'.
    //

    BOOL (WINAPI * SetHeader) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPSTR                         lpszName,
        LPSTR                         lpszValue
        );

    //
    //  Adds the specified header and value
    //

    BOOL (WINAPI * AddHeader) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPSTR                         lpszName,
        LPSTR                         lpszValue
        );

    DWORD dwReserved;
} HTTP_FILTER_PREPROC_HEADERS, *PHTTP_FILTER_PREPROC_HEADERS;

//
//  Authentication information for this request.
//

typedef struct _HTTP_FILTER_AUTHENT
{
    //
    //  Pointer to username and password, empty strings for the anonymous user
    //
    //  Client's can overwrite these buffers which are guaranteed to be at
    //  least SF_MAX_USERNAME and SF_MAX_PASSWORD bytes large.
    //

    CHAR * pszUser;
    DWORD  cbUserBuff;

    CHAR * pszPassword;
    DWORD  cbPasswordBuff;

} HTTP_FILTER_AUTHENT, *PHTTP_FILTER_AUTHENT;

//
//  Indicates the server is going to use the specific physical mapping for
//  the specified URL.  Filters can modify the physical path in place.
//

typedef struct _HTTP_FILTER_URL_MAP
{
    const CHAR * pszURL;

    CHAR *       pszPhysicalPath;
    DWORD        cbPathBuff;

} HTTP_FILTER_URL_MAP, *PHTTP_FILTER_URL_MAP;

//
//  The log information about to be written to the server log file.  The
//  string pointers can be replaced but the memory must remain valid until
//  the next notification
//

typedef struct _HTTP_FILTER_LOG
{
    const CHAR * pszClientHostName;
    const CHAR * pszClientUserName;
    const CHAR * pszServerName;
    const CHAR * pszOperation;
    const CHAR * pszTarget;
    const CHAR * pszParameters;

    DWORD  dwHttpStatus;
    DWORD  dwWin32Status;

} HTTP_FILTER_LOG, *PHTTP_FILTER_LOG;

//
//  Notification Flags
//
//  SF_NOTIFY_SECURE_PORT
//  SF_NOTIFY_NONSECURE_PORT
//
//      Indicates whether the application wants to be notified for transactions
//      that are happenning on the server port(s) that support data encryption
//      (such as PCT and SSL), on only the non-secure port(s) or both.
//
//  SF_NOTIFY_READ_RAW_DATA
//
//      Applications are notified after the server reads a block of memory
//      from the client but before the server does any processing on the
//      block.  The data block may contain HTTP headers and entity data.
//
//
//

#define SF_NOTIFY_SECURE_PORT               0x00000001
#define SF_NOTIFY_NONSECURE_PORT            0x00000002

#define SF_NOTIFY_READ_RAW_DATA             0x00008000
#define SF_NOTIFY_PREPROC_HEADERS           0x00004000
#define SF_NOTIFY_AUTHENTICATION            0x00002000
#define SF_NOTIFY_URL_MAP                   0x00001000
#define SF_NOTIFY_SEND_RAW_DATA             0x00000400
#define SF_NOTIFY_LOG                       0x00000200
#define SF_NOTIFY_END_OF_NET_SESSION        0x00000100

//
//  Filter ordering flags
//
//  Filters will tend to be notified by their specified
//  ordering.  For ties, notification order is determined by load order.
//
//  SF_NOTIFY_ORDER_HIGH - Authentication or data transformation filters
//  SF_NOTIFY_ORDER_MEDIUM
//  SF_NOTIFY_ORDER_LOW  - Logging filters that want the results of any other
//                      filters might specify this order.
//

#define SF_NOTIFY_ORDER_HIGH               0x00080000
#define SF_NOTIFY_ORDER_MEDIUM             0x00040000
#define SF_NOTIFY_ORDER_LOW                0x00020000
#define SF_NOTIFY_ORDER_DEFAULT            SF_NOTIFY_ORDER_LOW

#define SF_NOTIFY_ORDER_MASK               (SF_NOTIFY_ORDER_HIGH   |    \
                                            SF_NOTIFY_ORDER_MEDIUM |    \
                                            SF_NOTIFY_ORDER_LOW)

//
//  Filter version information, passed to GetFilterVersion
//

typedef struct _HTTP_FILTER_VERSION
{
    //
    //  Version of the spec the server is using
    //

    DWORD  dwServerFilterVersion;

    //
    //  Fields specified by the client
    //

    DWORD  dwFilterVersion;
    CHAR   lpszFilterDesc[SF_MAX_FILTER_DESC_LEN];
    DWORD  dwFlags;


} HTTP_FILTER_VERSION, *PHTTP_FILTER_VERSION;

//
//  A filter DLL's entry point looks like this.  The return code should be
//  an SF_STATUS_TYPE
//
//  NotificationType - Type of notification
//  pvNotification - Pointer to notification specific data
//

DWORD
WINAPI
HttpFilterProc(
    HTTP_FILTER_CONTEXT *      pfc,
    DWORD                      NotificationType,
    VOID *                     pvNotification
    );

BOOL
WINAPI
GetFilterVersion(
    HTTP_FILTER_VERSION * pVer
    );

#ifdef __cplusplus
}
#endif

#endif //_HTTPFILT_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\amd64\chk\sdk\faxdev.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    faxdev.h

Abstract:

    This file contains the prototypes, etc for the
    FAX device provider API.

--*/

#include <commctrl.h>


#ifndef _FAXDEV_
#define _FAXDEV_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// FAX status constants
//

#define FS_INITIALIZING         0x20000000
#define FS_DIALING              0x20000001
#define FS_TRANSMITTING         0x20000002
#define FS_RECEIVING            0x20000004
#define FS_COMPLETED            0x20000008
#define FS_HANDLED              0x20000010
#define FS_LINE_UNAVAILABLE     0x20000020
#define FS_BUSY                 0x20000040
#define FS_NO_ANSWER            0x20000080
#define FS_BAD_ADDRESS          0x20000100
#define FS_NO_DIAL_TONE         0x20000200
#define FS_DISCONNECTED         0x20000400
#define FS_FATAL_ERROR          0x20000800  // see the stringid for the real status
#define FS_NOT_FAX_CALL         0x20001000
#define FS_CALL_DELAYED         0x20002000
#define FS_CALL_BLACKLISTED     0x20004000
#define FS_USER_ABORT           0x20200000
#define FS_ANSWERED             0x20800000


//
// data structures
//

typedef struct _FAX_SEND {
    DWORD   SizeOfStruct;
    LPWSTR  FileName;
    LPWSTR  CallerName;
    LPWSTR  CallerNumber;
    LPWSTR  ReceiverName;
    LPWSTR  ReceiverNumber;
    BOOL    Branding;
    HCALL   CallHandle;
    DWORD   Reserved[3];
} FAX_SEND, *PFAX_SEND;

typedef struct _FAX_RECEIVE {
    DWORD   SizeOfStruct;
    LPWSTR  FileName;
    LPWSTR  ReceiverName;
    LPWSTR  ReceiverNumber;
    DWORD   Reserved[4];
} FAX_RECEIVE, *PFAX_RECEIVE;

typedef struct _FAX_DEV_STATUS {
    DWORD   SizeOfStruct;
    DWORD   StatusId;
    DWORD   StringId;
    DWORD   PageCount;
    LPWSTR  CSI;
    LPWSTR  CallerId;
    LPWSTR  RoutingInfo;
    DWORD   ErrorCode;
    DWORD   Reserved[3];
} FAX_DEV_STATUS, *PFAX_DEV_STATUS;

typedef BOOL
(CALLBACK *PFAX_SERVICE_CALLBACK)(
    IN HANDLE FaxHandle,
    IN DWORD  DeviceId,
    IN DWORD_PTR  Param1,
    IN DWORD_PTR  Param2,
    IN DWORD_PTR  Param3
    );

typedef void
(CALLBACK *PFAX_LINECALLBACK)(
    IN HANDLE FaxHandle,
    IN DWORD hDevice,
    IN DWORD dwMessage,
    IN DWORD_PTR dwInstance,
    IN DWORD_PTR dwParam1,
    IN DWORD_PTR dwParam2,
    IN DWORD_PTR dwParam3
    );

BOOL WINAPI
FaxDevInitialize(
    IN  HLINEAPP LineAppHandle,
    IN  HANDLE HeapHandle,
    OUT PFAX_LINECALLBACK *LineCallbackFunction,
    IN  PFAX_SERVICE_CALLBACK FaxServiceCallback
    );

BOOL WINAPI
FaxDevVirtualDeviceCreation(
    OUT LPDWORD DeviceCount,
    OUT LPWSTR DeviceNamePrefix,
    OUT LPDWORD DeviceIdPrefix,
    IN  HANDLE CompletionPort,
    IN  ULONG_PTR CompletionKey
    );

BOOL WINAPI
FaxDevStartJob(
    IN  HLINE LineHandle,
    IN  DWORD DeviceId,
    OUT PHANDLE FaxHandle,
    IN  HANDLE CompletionPortHandle,
    IN  ULONG_PTR CompletionKey
    );

BOOL WINAPI
FaxDevEndJob(
    IN  HANDLE FaxHandle
    );

typedef BOOL
(CALLBACK *PFAX_SEND_CALLBACK)(
    IN HANDLE FaxHandle,
    IN HCALL CallHandle,
    IN DWORD Reserved1,
    IN DWORD Reserved2
    );

BOOL WINAPI
FaxDevSend(
    IN  HANDLE FaxHandle,
    IN  PFAX_SEND FaxSend,
    IN  PFAX_SEND_CALLBACK FaxSendCallback
    );

#define FAXDEVRECEIVE_SIZE 4096

BOOL WINAPI
FaxDevReceive(
    IN  HANDLE FaxHandle,
    IN  HCALL CallHandle,
    IN OUT PFAX_RECEIVE FaxReceive
    );

#define FAXDEVREPORTSTATUS_SIZE 4096

BOOL WINAPI
FaxDevReportStatus(
    IN  HANDLE FaxHandle OPTIONAL,
    OUT PFAX_DEV_STATUS FaxStatus,
    IN  DWORD FaxStatusSize,
    OUT LPDWORD FaxStatusSizeRequired
    );

BOOL WINAPI
FaxDevAbortOperation(
    IN  HANDLE FaxHandle
    );

BOOL WINAPI
FaxDevConfigure(
    OUT HPROPSHEETPAGE *PropSheetPage
    );


typedef BOOL (WINAPI *PFAXDEVINITIALIZE)                (HLINEAPP,HANDLE,PFAX_LINECALLBACK*,PFAX_SERVICE_CALLBACK);
typedef BOOL (WINAPI *PFAXDEVVIRTUALDEVICECREATION)     (LPDWORD,LPWSTR,LPDWORD,HANDLE,ULONG_PTR);
typedef BOOL (WINAPI *PFAXDEVSTARTJOB)                  (HLINE,DWORD,PHANDLE,HANDLE,ULONG_PTR);
typedef BOOL (WINAPI *PFAXDEVENDJOB)                    (HANDLE);
typedef BOOL (WINAPI *PFAXDEVSEND)                      (HANDLE,PFAX_SEND,PFAX_SEND_CALLBACK);
typedef BOOL (WINAPI *PFAXDEVRECEIVE)                   (HANDLE,HCALL,PFAX_RECEIVE);
typedef BOOL (WINAPI *PFAXDEVREPORTSTATUS)              (HANDLE,PFAX_DEV_STATUS,DWORD,LPDWORD);
typedef BOOL (WINAPI *PFAXDEVABORTOPERATION)            (HANDLE);
typedef BOOL (WINAPI *PFAXDEVCONFIGURE)                 (HPROPSHEETPAGE*);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\amd64\chk\sdk\faxext.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    faxext.h

Abstract:

    Declarations of fax extension configuration and notification functions.

--*/


#ifndef _FAX_EXT_H_
#define _FAX_EXT_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

/************************************
*                                   *
*   Extension configuration data    *
*                                   *
************************************/

typedef enum
{
    DEV_ID_SRC_FAX,         // Device id is generated by the fax server of EFSP
    DEV_ID_SRC_TAPI         // Device id is generated by a TAPI TSP (of FSP).
}   FAX_ENUM_DEVICE_ID_SOURCE;

//
// Prototype of FaxExtGetData 
// 
DWORD
FaxExtGetData (
    DWORD                       dwDeviceId,     // Device id (0 = No device)
    FAX_ENUM_DEVICE_ID_SOURCE   DevIdSrc,       // The source of the device id
    LPCWSTR                     lpcwstrDataGUID,// GUID of data
    LPBYTE                     *ppData,         // (Out) Pointer to allocated data
    LPDWORD                     lpdwDataSize    // (Out) Pointer to data size
);
typedef DWORD (CALLBACK *PFAX_EXT_GET_DATA) (DWORD, FAX_ENUM_DEVICE_ID_SOURCE, LPCWSTR, LPBYTE *, LPDWORD);

//
// Prototype of FaxExtSetData 
// 
DWORD
FaxExtSetData (
    HINSTANCE                   hInst,          // Instance of calling extension
    DWORD                       dwDeviceId,     // Device id (0 = No device)
    FAX_ENUM_DEVICE_ID_SOURCE   DevIdSrc,       // The source of the device id
    LPCWSTR                     lpcwstrDataGUID,// GUID of data
    LPBYTE                      pData,          // Pointer to  data
    DWORD                       dwDataSize      // Data size
);
typedef DWORD (CALLBACK *PFAX_EXT_SET_DATA) (HINSTANCE, DWORD, FAX_ENUM_DEVICE_ID_SOURCE, LPCWSTR, LPBYTE, DWORD);

HRESULT
FaxExtConfigChange (
    DWORD       dwDeviceId,         // The device for which configuration has changed
    LPCWSTR     lpcwstrDataGUID,    // Configuration name
    LPBYTE      lpData,             // New configuration data
    DWORD       dwDataSize          // Size of new configuration data
);
typedef HRESULT (WINAPI *PFAX_EXT_CONFIG_CHANGE) (DWORD, LPCWSTR, LPBYTE, DWORD);

//
// Prototype of FaxExtRegisterForEvents 
//
HANDLE
FaxExtRegisterForEvents (
    HINSTANCE                   hInst,          // Instance of calling extension
    DWORD                       dwDeviceId,     // Device id (0 = No device)
    FAX_ENUM_DEVICE_ID_SOURCE   DevIdSrc,       // The source of the device id
    LPCWSTR                     lpcwstrDataGUID,// GUID of data
    PFAX_EXT_CONFIG_CHANGE      lpConfigChangeCallback
);
typedef HANDLE (CALLBACK *PFAX_EXT_REGISTER_FOR_EVENTS) (HINSTANCE, DWORD, FAX_ENUM_DEVICE_ID_SOURCE, LPCWSTR, PFAX_EXT_CONFIG_CHANGE);

//
// Prototype of FaxExtUnregisterForEvents 
//
DWORD
FaxExtUnregisterForEvents (
    HANDLE      hNotification
);
typedef DWORD (CALLBACK *PFAX_EXT_UNREGISTER_FOR_EVENTS) (HANDLE);

//
// Prototype of FaxExtFreeBuffer
//
VOID
FaxExtFreeBuffer (
    LPVOID lpvBuffer
);
typedef VOID (CALLBACK *PFAX_EXT_FREE_BUFFER) (LPVOID);

//
// The extension should implement and export the following function:
//
HRESULT 
FaxExtInitializeConfig (
    PFAX_EXT_GET_DATA,              // Pointer to FaxExtGetExtensionData in service
    PFAX_EXT_SET_DATA,              // Pointer to FaxExtSetExtensionData in service
    PFAX_EXT_REGISTER_FOR_EVENTS,   // Pointer to FaxExtRegisterForExtensionEvents in service
    PFAX_EXT_UNREGISTER_FOR_EVENTS, // Pointer to FaxExtUnregisterForExtensionEvents in service
    PFAX_EXT_FREE_BUFFER            // Pointer to FaxExtFreeBuffer in service
);
typedef HRESULT (WINAPI *PFAX_EXT_INITIALIZE_CONFIG) (PFAX_EXT_GET_DATA, PFAX_EXT_SET_DATA, PFAX_EXT_REGISTER_FOR_EVENTS, PFAX_EXT_UNREGISTER_FOR_EVENTS, PFAX_EXT_FREE_BUFFER);

#ifdef __cplusplus
}
#endif

#endif // _FAX_EXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\amd64\chk\sdk\faxmmc.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    faxmmc.h

Abstract:

    This header file contains public constants for extension of MMC components.

--*/

#ifndef H_FXS_MMCEXT_H
#define H_FXS_MMCEXT_H

#define FAXSRV_DEVICE_NODETYPE_GUID_STR OLESTR("{3115A19A-6251-46ac-9425-14782858B8C9}")
#define FAXSRV_DEVICE_NODETYPE_GUID { 0x3115a19a, 0x6251, 0x46ac, { 0x94, 0x25, 0x14, 0x78, 0x28, 0x58, 0xb8, 0xc9 } }

#define FAXSRV_DEVICE_PROVIDER_NODETYPE_GUID_STR OLESTR("{BD38E2AC-B926-4161-8640-0F6956EE2BA3}")
#define FAXSRV_DEVICE_PROVIDER_NODETYPE_GUID { 0xbd38e2ac, 0xb926, 0x4161, { 0x86, 0x40, 0x0f, 0x69, 0x56, 0xee, 0x2b, 0xa3 } }

#define FAXSRV_ROUTING_METHOD_NODETYPE_GUID_STR OLESTR("{220D2CB0-85A9-4a43-B6E8-9D66B44F1AF5}")
#define FAXSRV_ROUTING_METHOD_NODETYPE_GUID { 0x220d2cb0, 0x85a9, 0x4a43, { 0xb6, 0xe8, 0x9d, 0x66, 0xb4, 0x4f, 0x1a, 0xf5 } }

#define FAXSRV_MAX_GUID_LEN              sizeof(FAXSRV_DEVICE_NODETYPE_GUID_STR)/sizeof(WCHAR)
#define FAXSRV_MAX_SERVER_NAME           MAX_PATH
#define FAXSRV_MAX_ROUTEEXT_NAME_LEN     MAX_PATH

#define CF_MSFAXSRV_DEVICE_ID           TEXT("FAXSRV_DeviceID")
#define CF_MSFAXSRV_FSP_GUID            TEXT("FAXSRV_FSPGuid")
#define CF_MSFAXSRV_SERVER_NAME         TEXT("FAXSRV_ServerName")
#define CF_MSFAXSRV_ROUTEEXT_NAME       TEXT("FAXSRV_RoutingExtName")
#define CF_MSFAXSRV_ROUTING_METHOD_GUID TEXT("FAXSRV_RoutingMethodGuid")

#endif  //H_FXS_MMCEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\web\faxisapi\faxisapi.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxisapi.c

Abstract:

    This module implements an isapi dll for the
    ms fax server.  The HttpExtensionProc() supports
    the following syntax:

            dir=           directory browser
            status=        fax status display


Author:

    Wesley Witt (wesw) 01-May-1996


Revision History:

--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>

#include "httpext.h"
#include "faxutil.h"
#include "winfax.h"




BOOL WINAPI
GetExtensionVersion(
    HSE_VERSION_INFO *pVer
    )

/*++

Routine Description:

    Provides version information for this dll.


Arguments:

    pVer    - HTTP version structure


Return Value:

    TRUE    - Success
    FALSE   - Failure

--*/

{
    pVer->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR );

    strncpy(
        pVer->lpszExtensionDesc,
        "FAX Server ISAPI Support DLL",
        HSE_MAX_EXT_DLL_NAME_LEN
        );

    return TRUE;
}


LPSTR
AddString(
    LPSTR Buffer,
    LPSTR String,
    ...
    )

/*++

Routine Description:

    Adds a string to end of a buffer.


Arguments:

    Buffer  - Buffer to receive the string
    String  - The string to be added to the buffer
    ...     - varargs data


Return Value:

    Pointer to the end of the buffer.

--*/

{
    DWORD len;
    va_list arg_ptr;


    va_start(arg_ptr, String);
    vsprintf( Buffer, String, arg_ptr);
    va_end(arg_ptr);

    return Buffer + strlen(Buffer);
}


LPSTR
AppendNode(
    LPSTR Directory,
    LPSTR Node
    )

/*++

Routine Description:

    Appends a node to the end of a path.


Arguments:

    Directory   - Current directory.
    Node        - Node to be added to the directory.


Return Value:

    Pointer to a newly allocated directory.

--*/

{
    LPSTR s,dir;


    s = Directory + strlen(Directory);
    while (*s != '\\') s--;
    s[0] = 0;
    dir = MemAlloc( strlen(Directory) + 128 );
    if (!dir) {
        return NULL;
    }
    sprintf( dir, "%s\\%s\\*", Directory, Node );
    s[0] = '\\';

    return dir;
}


LPSTR
ResolvePath(
    LPSTR Directory
    )

/*++

Routine Description:

    Obtains a complete path for a directory.


Arguments:

    Directory   - Current directory.


Return Value:

    Pointer to a newly allocated complete directory.

--*/

{
    LPSTR dir;
    DWORD len;
    LPSTR fname;


    len = strlen(Directory) + 128;
    dir = MemAlloc( len );
    if (!dir) {
        return NULL;
    }

    if (!GetFullPathName( Directory, len, dir, &fname )) {
        MemFree( dir );
        return NULL;
    }

    return dir;
}



LPSTR
PrintFileInfo(
    LPSTR Buffer,
    LPSTR Link,
    LPWIN32_FIND_DATA FindData
    )

/*++

Routine Description:

    Generates a single HTML source line for a file name.


Arguments:

    Buffer      - Buffer to put the HTML source into
    Link        - TRUE=generate href, FALSE=no href
    FindData    - File information


Return Value:

    Pointer to the end of the buffer.

--*/

{
    FILETIME LocalTime;
    SYSTEMTIME SystemTime;

    FileTimeToLocalFileTime( &FindData->ftCreationTime, &LocalTime );
    FileTimeToSystemTime( &LocalTime, &SystemTime );

    Buffer = AddString(
        Buffer,
        "%02d-%02d-%04d   %02d:%02d:%02d   ",
        SystemTime.wMonth,
        SystemTime.wDay,
        SystemTime.wYear,
        SystemTime.wHour,
        SystemTime.wMinute,
        SystemTime.wSecond
        );

    if (Link) {

        Buffer = AddString(
            Buffer,
            "<a href=\"/scripts/faxisapi.dll?%s\">%s</a>\n",
            Link,
            FindData->cFileName
            );


    } else {

        Buffer = AddString( Buffer, "%s\n", FindData->cFileName );

    }

    return Buffer;
}


BOOL
HtmlDirectory(
    LPSTR Directory,
    LPBYTE Buffer
    )

/*++

Routine Description:

    Generates a page of HTML source for a directory.
    This function implements a directory browser that
    allows an HTML client to browse the directories
    on the server's disks.


Arguments:

    Directory   - Directory from which to generate HTML source.
    Buffer      - Buffer to put the HTML source into.


Return Value:

    TRUE    - HTML generation is successful
    FALSE   - NTML generation failed

--*/

{
    LPBYTE p;
    LPSTR dir;
    HANDLE hFind;
    WIN32_FIND_DATA FindData;



    p = Buffer;

    hFind = FindFirstFile( Directory, &FindData );
    if (hFind == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    p = AddString( p, "Content-type: text/html\r\n\r\n" );
    p = AddString( p, "<html>\r\n" );
    p = AddString( p, "<head><title>Tornado FAX Server Project</title></head>\r\n" );
    p = AddString( p, "<body>\r\n" );
    p = AddString( p, "<h1>Directory Listing:<br>%s</h1><hr>\r\n", Directory );
    p = AddString( p, "<p><pre>\n" );

    do {

        if (FindData.cFileName[0] == '.') {
            if (FindData.cFileName[1] == '.') {

                dir = AppendNode( Directory, ".." );

                if (dir) {

                    LPSTR NewDir = ResolvePath( dir );
                    if (NewDir) {
                        MemFree( dir );
                        dir = NewDir;
                    }

                    p = AddString(
                        p,
                        "<a href=\"/scripts/faxisapi.dll?%s\"><img src=\"/images/b_arrow.gif\"  border=0 >Parent Directory</a>\n",
                        dir
                        );

                    p = AddString( p, "<br>" );

                    MemFree( dir );

                }
            }
        } else {
            if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                dir = AppendNode( Directory, FindData.cFileName );

                if (dir) {

                    p = PrintFileInfo( p, dir, &FindData );

                    MemFree( dir );

                }

            } else {

                p = PrintFileInfo( p, NULL, &FindData );

            }
        }

    } while( FindNextFile( hFind, &FindData ) );

    p = AddString( p, "</pre></body></html>\r\n" );

    FindClose( hFind );

    return TRUE;
}


BOOL
HtmlFaxStatus(
    LPBYTE Buffer
    )

/*++

Routine Description:

    Generates a page of HTML source that shows
    a status display for a ms fax server.


Arguments:

    Buffer      - Buffer to put the HTML source into.


Return Value:

    TRUE    - HTML generation is successful
    FALSE   - NTML generation failed

--*/

{
    LPBYTE p;
    PFAX_STATUS FaxStatus = NULL;
    DWORD BytesNeeded;
    DWORD i;
    HFAX FaxHandle = NULL;


    p = Buffer;

    p = AddString( p, "Content-type: text/html\r\n\r\n" );
    p = AddString( p, "<html>\r\n" );
    p = AddString( p, "<head><title>Tornado FAX Server Project</title></head>\r\n" );
    p = AddString( p, "<body>\r\n" );
    p = AddString( p, "<h1>FAX Server Status</h1><hr>\n" );
    p = AddString( p, "<p>\n" );
    p = AddString( p, "<body background=\"/images/softgrid.gif\">" );
    p = AddString( p, "<table border=5 cellpadding=5 cellspacing=10>\n" );
    p = AddString( p, "<tr>\n" );
    p = AddString( p, "  <th>Port Name</th>\n" );
    p = AddString( p, "  <th>Port Number</th>\n" );
    p = AddString( p, "  <th>Status</th>\n" );
    p = AddString( p, "</tr>\n" );

    FaxStatus = (PFAX_STATUS) MemAlloc( 4096 );
    if (!FaxStatus) {
        return FALSE;
    }

    if (!FaxConnectFaxServer( NULL, &FaxHandle )) {
        return FALSE;
    }


    if (!FaxGetDeviceStatus( FaxHandle, 0, (LPBYTE) FaxStatus, 4096, &BytesNeeded )) {
        FaxDisconnectFaxServer( FaxHandle );
        return FALSE;
    }

    for (i=0; i<FaxStatus->DeviceCount; i++) {

        p = AddString( p, "<tr>\n" );
        p = AddString( p, "  <td>%s</td>\n", FaxStatus->DeviceStatus[i].DeviceName );
        p = AddString( p, "  <td>%d</td>\n", FaxStatus->DeviceStatus[i].DeviceId );

        if (FaxStatus->DeviceStatus[i].Status & FPS_SENDING) {

            p = AddString( p, "  <td>Sending</td>\n" );

        } else if (FaxStatus->DeviceStatus[i].Status & FPS_RECEIVING) {

            p = AddString( p, "  <td>Receiving</td>\n" );

        } else if (FaxStatus->DeviceStatus[i].Status & FPS_AVAILABLE) {

            p = AddString( p, "  <td>Idle</td>\n" );

        } else if (FaxStatus->DeviceStatus[i].Status & FPS_ABORTING) {

            p = AddString( p, "  <td>Aborting</td>\n" );

        } else if (FaxStatus->DeviceStatus[i].Status & FPS_ROUTING) {

            p = AddString( p, "  <td>Routing</td>\n" );

        } else if (FaxStatus->DeviceStatus[i].Status & FPS_UNAVAILABLE) {

            p = AddString( p, "  <td>Unavailable</td>\n" );

        } else {

            p = AddString( p, "  <td>*Unknown Status*</td>\n" );

        }

        p = AddString( p, "</tr>\n" );

    }

    MemFree( FaxStatus );

    FaxDisconnectFaxServer( FaxHandle );

    p = AddString( p, "</table>" );
    p = AddString( p, "</body></html>\n" );

    return TRUE;
}


DWORD WINAPI
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK *pECB
    )

/*++

Routine Description:

    Function that is called by the HTTP server.


Arguments:

    pECB        - HTTP extension control block


Return Value:

    HSE_STATUS_ERROR    - failure
    HSE_STATUS_SUCCESS  - success

--*/

{
    #define MAX_BUFFER_SIZE (1024*1024)
    LPBYTE Buffer;
    DWORD Length;
    LPSTR s;


    pECB->dwHttpStatusCode = 0;


    s = strchr( pECB->lpszQueryString, '=' );
    if (!s) {
        return HSE_STATUS_ERROR;
    }

    *s++ = 0;

    if (_stricmp( pECB->lpszQueryString, "dir" ) == 0) {

        Buffer = (LPBYTE) VirtualAlloc( NULL, MAX_BUFFER_SIZE, MEM_COMMIT, PAGE_READWRITE );
        if (!Buffer) {
            return HSE_STATUS_ERROR;
        }

        if (!HtmlDirectory( s, Buffer )) {
            return HSE_STATUS_ERROR;
        }

    } else if (_stricmp( pECB->lpszQueryString, "status" ) == 0) {

        Buffer = (LPBYTE) VirtualAlloc( NULL, MAX_BUFFER_SIZE, MEM_COMMIT, PAGE_READWRITE );
        if (!Buffer) {
            return HSE_STATUS_ERROR;
        }

        if (!HtmlFaxStatus( Buffer )) {
            return HSE_STATUS_ERROR;
        }

    } else {

        return HSE_STATUS_ERROR;

    }

    if (Buffer) {
        Length = strlen( Buffer );


        pECB->ServerSupportFunction(
            pECB->ConnID,
            HSE_REQ_SEND_RESPONSE_HEADER,
            NULL,
            &Length,
            (LPDWORD) Buffer
            );

        pECB->dwHttpStatusCode = 200;

        VirtualFree( Buffer, MAX_BUFFER_SIZE, MEM_DECOMMIT );

    } else {

        return HSE_STATUS_ERROR;

    }

    return HSE_STATUS_SUCCESS;
}


DWORD
FaxIsapiDllEntry(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )

/*++

Routine Description:

    DLL initialization function.

Arguments:

    hInstance   - Instance handle
    Reason      - Reason for the entrypoint being called
    Context     - Context record

Return Value:

    TRUE        - Initialization succeeded
    FALSE       - Initialization failed

--*/

{
    if (Reason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls( hInstance );
        HeapInitialize();
    }

    if (Reason == DLL_PROCESS_DETACH) {
        HeapCleanup();
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\amd64\chk\sdk\faxcomex.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for faxcomex.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __faxcomex_h__
#define __faxcomex_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IFaxJobStatus_FWD_DEFINED__
#define __IFaxJobStatus_FWD_DEFINED__
typedef interface IFaxJobStatus IFaxJobStatus;
#endif 	/* __IFaxJobStatus_FWD_DEFINED__ */


#ifndef __IFaxServer_FWD_DEFINED__
#define __IFaxServer_FWD_DEFINED__
typedef interface IFaxServer IFaxServer;
#endif 	/* __IFaxServer_FWD_DEFINED__ */


#ifndef __IFaxDeviceProviders_FWD_DEFINED__
#define __IFaxDeviceProviders_FWD_DEFINED__
typedef interface IFaxDeviceProviders IFaxDeviceProviders;
#endif 	/* __IFaxDeviceProviders_FWD_DEFINED__ */


#ifndef __IFaxDevices_FWD_DEFINED__
#define __IFaxDevices_FWD_DEFINED__
typedef interface IFaxDevices IFaxDevices;
#endif 	/* __IFaxDevices_FWD_DEFINED__ */


#ifndef __IFaxInboundRouting_FWD_DEFINED__
#define __IFaxInboundRouting_FWD_DEFINED__
typedef interface IFaxInboundRouting IFaxInboundRouting;
#endif 	/* __IFaxInboundRouting_FWD_DEFINED__ */


#ifndef __IFaxFolders_FWD_DEFINED__
#define __IFaxFolders_FWD_DEFINED__
typedef interface IFaxFolders IFaxFolders;
#endif 	/* __IFaxFolders_FWD_DEFINED__ */


#ifndef __IFaxLoggingOptions_FWD_DEFINED__
#define __IFaxLoggingOptions_FWD_DEFINED__
typedef interface IFaxLoggingOptions IFaxLoggingOptions;
#endif 	/* __IFaxLoggingOptions_FWD_DEFINED__ */


#ifndef __IFaxActivity_FWD_DEFINED__
#define __IFaxActivity_FWD_DEFINED__
typedef interface IFaxActivity IFaxActivity;
#endif 	/* __IFaxActivity_FWD_DEFINED__ */


#ifndef __IFaxOutboundRouting_FWD_DEFINED__
#define __IFaxOutboundRouting_FWD_DEFINED__
typedef interface IFaxOutboundRouting IFaxOutboundRouting;
#endif 	/* __IFaxOutboundRouting_FWD_DEFINED__ */


#ifndef __IFaxReceiptOptions_FWD_DEFINED__
#define __IFaxReceiptOptions_FWD_DEFINED__
typedef interface IFaxReceiptOptions IFaxReceiptOptions;
#endif 	/* __IFaxReceiptOptions_FWD_DEFINED__ */


#ifndef __IFaxSecurity_FWD_DEFINED__
#define __IFaxSecurity_FWD_DEFINED__
typedef interface IFaxSecurity IFaxSecurity;
#endif 	/* __IFaxSecurity_FWD_DEFINED__ */


#ifndef __IFaxDocument_FWD_DEFINED__
#define __IFaxDocument_FWD_DEFINED__
typedef interface IFaxDocument IFaxDocument;
#endif 	/* __IFaxDocument_FWD_DEFINED__ */


#ifndef __IFaxAttachments_FWD_DEFINED__
#define __IFaxAttachments_FWD_DEFINED__
typedef interface IFaxAttachments IFaxAttachments;
#endif 	/* __IFaxAttachments_FWD_DEFINED__ */


#ifndef __IFaxSender_FWD_DEFINED__
#define __IFaxSender_FWD_DEFINED__
typedef interface IFaxSender IFaxSender;
#endif 	/* __IFaxSender_FWD_DEFINED__ */


#ifndef __IFaxRecipient_FWD_DEFINED__
#define __IFaxRecipient_FWD_DEFINED__
typedef interface IFaxRecipient IFaxRecipient;
#endif 	/* __IFaxRecipient_FWD_DEFINED__ */


#ifndef __IFaxRecipients_FWD_DEFINED__
#define __IFaxRecipients_FWD_DEFINED__
typedef interface IFaxRecipients IFaxRecipients;
#endif 	/* __IFaxRecipients_FWD_DEFINED__ */


#ifndef __IFaxIncomingArchive_FWD_DEFINED__
#define __IFaxIncomingArchive_FWD_DEFINED__
typedef interface IFaxIncomingArchive IFaxIncomingArchive;
#endif 	/* __IFaxIncomingArchive_FWD_DEFINED__ */


#ifndef __IFaxIncomingQueue_FWD_DEFINED__
#define __IFaxIncomingQueue_FWD_DEFINED__
typedef interface IFaxIncomingQueue IFaxIncomingQueue;
#endif 	/* __IFaxIncomingQueue_FWD_DEFINED__ */


#ifndef __IFaxOutgoingArchive_FWD_DEFINED__
#define __IFaxOutgoingArchive_FWD_DEFINED__
typedef interface IFaxOutgoingArchive IFaxOutgoingArchive;
#endif 	/* __IFaxOutgoingArchive_FWD_DEFINED__ */


#ifndef __IFaxOutgoingQueue_FWD_DEFINED__
#define __IFaxOutgoingQueue_FWD_DEFINED__
typedef interface IFaxOutgoingQueue IFaxOutgoingQueue;
#endif 	/* __IFaxOutgoingQueue_FWD_DEFINED__ */


#ifndef __IFaxIncomingMessageIterator_FWD_DEFINED__
#define __IFaxIncomingMessageIterator_FWD_DEFINED__
typedef interface IFaxIncomingMessageIterator IFaxIncomingMessageIterator;
#endif 	/* __IFaxIncomingMessageIterator_FWD_DEFINED__ */


#ifndef __IFaxIncomingMessage_FWD_DEFINED__
#define __IFaxIncomingMessage_FWD_DEFINED__
typedef interface IFaxIncomingMessage IFaxIncomingMessage;
#endif 	/* __IFaxIncomingMessage_FWD_DEFINED__ */


#ifndef __IFaxOutgoingJobs_FWD_DEFINED__
#define __IFaxOutgoingJobs_FWD_DEFINED__
typedef interface IFaxOutgoingJobs IFaxOutgoingJobs;
#endif 	/* __IFaxOutgoingJobs_FWD_DEFINED__ */


#ifndef __IFaxOutgoingJob_FWD_DEFINED__
#define __IFaxOutgoingJob_FWD_DEFINED__
typedef interface IFaxOutgoingJob IFaxOutgoingJob;
#endif 	/* __IFaxOutgoingJob_FWD_DEFINED__ */


#ifndef __IFaxOutgoingMessageIterator_FWD_DEFINED__
#define __IFaxOutgoingMessageIterator_FWD_DEFINED__
typedef interface IFaxOutgoingMessageIterator IFaxOutgoingMessageIterator;
#endif 	/* __IFaxOutgoingMessageIterator_FWD_DEFINED__ */


#ifndef __IFaxOutgoingMessage_FWD_DEFINED__
#define __IFaxOutgoingMessage_FWD_DEFINED__
typedef interface IFaxOutgoingMessage IFaxOutgoingMessage;
#endif 	/* __IFaxOutgoingMessage_FWD_DEFINED__ */


#ifndef __IFaxIncomingJobs_FWD_DEFINED__
#define __IFaxIncomingJobs_FWD_DEFINED__
typedef interface IFaxIncomingJobs IFaxIncomingJobs;
#endif 	/* __IFaxIncomingJobs_FWD_DEFINED__ */


#ifndef __IFaxIncomingJob_FWD_DEFINED__
#define __IFaxIncomingJob_FWD_DEFINED__
typedef interface IFaxIncomingJob IFaxIncomingJob;
#endif 	/* __IFaxIncomingJob_FWD_DEFINED__ */


#ifndef __IFaxDeviceProvider_FWD_DEFINED__
#define __IFaxDeviceProvider_FWD_DEFINED__
typedef interface IFaxDeviceProvider IFaxDeviceProvider;
#endif 	/* __IFaxDeviceProvider_FWD_DEFINED__ */


#ifndef __IFaxDevice_FWD_DEFINED__
#define __IFaxDevice_FWD_DEFINED__
typedef interface IFaxDevice IFaxDevice;
#endif 	/* __IFaxDevice_FWD_DEFINED__ */


#ifndef __IFaxActivityLogging_FWD_DEFINED__
#define __IFaxActivityLogging_FWD_DEFINED__
typedef interface IFaxActivityLogging IFaxActivityLogging;
#endif 	/* __IFaxActivityLogging_FWD_DEFINED__ */


#ifndef __IFaxEventLogging_FWD_DEFINED__
#define __IFaxEventLogging_FWD_DEFINED__
typedef interface IFaxEventLogging IFaxEventLogging;
#endif 	/* __IFaxEventLogging_FWD_DEFINED__ */


#ifndef __IFaxOutboundRoutingGroups_FWD_DEFINED__
#define __IFaxOutboundRoutingGroups_FWD_DEFINED__
typedef interface IFaxOutboundRoutingGroups IFaxOutboundRoutingGroups;
#endif 	/* __IFaxOutboundRoutingGroups_FWD_DEFINED__ */


#ifndef __IFaxOutboundRoutingGroup_FWD_DEFINED__
#define __IFaxOutboundRoutingGroup_FWD_DEFINED__
typedef interface IFaxOutboundRoutingGroup IFaxOutboundRoutingGroup;
#endif 	/* __IFaxOutboundRoutingGroup_FWD_DEFINED__ */


#ifndef __IFaxDeviceIds_FWD_DEFINED__
#define __IFaxDeviceIds_FWD_DEFINED__
typedef interface IFaxDeviceIds IFaxDeviceIds;
#endif 	/* __IFaxDeviceIds_FWD_DEFINED__ */


#ifndef __IFaxOutboundRoutingRules_FWD_DEFINED__
#define __IFaxOutboundRoutingRules_FWD_DEFINED__
typedef interface IFaxOutboundRoutingRules IFaxOutboundRoutingRules;
#endif 	/* __IFaxOutboundRoutingRules_FWD_DEFINED__ */


#ifndef __IFaxOutboundRoutingRule_FWD_DEFINED__
#define __IFaxOutboundRoutingRule_FWD_DEFINED__
typedef interface IFaxOutboundRoutingRule IFaxOutboundRoutingRule;
#endif 	/* __IFaxOutboundRoutingRule_FWD_DEFINED__ */


#ifndef __IFaxInboundRoutingExtensions_FWD_DEFINED__
#define __IFaxInboundRoutingExtensions_FWD_DEFINED__
typedef interface IFaxInboundRoutingExtensions IFaxInboundRoutingExtensions;
#endif 	/* __IFaxInboundRoutingExtensions_FWD_DEFINED__ */


#ifndef __IFaxInboundRoutingExtension_FWD_DEFINED__
#define __IFaxInboundRoutingExtension_FWD_DEFINED__
typedef interface IFaxInboundRoutingExtension IFaxInboundRoutingExtension;
#endif 	/* __IFaxInboundRoutingExtension_FWD_DEFINED__ */


#ifndef __IFaxInboundRoutingMethods_FWD_DEFINED__
#define __IFaxInboundRoutingMethods_FWD_DEFINED__
typedef interface IFaxInboundRoutingMethods IFaxInboundRoutingMethods;
#endif 	/* __IFaxInboundRoutingMethods_FWD_DEFINED__ */


#ifndef __IFaxInboundRoutingMethod_FWD_DEFINED__
#define __IFaxInboundRoutingMethod_FWD_DEFINED__
typedef interface IFaxInboundRoutingMethod IFaxInboundRoutingMethod;
#endif 	/* __IFaxInboundRoutingMethod_FWD_DEFINED__ */


#ifndef __IFaxServerNotify_FWD_DEFINED__
#define __IFaxServerNotify_FWD_DEFINED__
typedef interface IFaxServerNotify IFaxServerNotify;
#endif 	/* __IFaxServerNotify_FWD_DEFINED__ */


#ifndef __FaxServer_FWD_DEFINED__
#define __FaxServer_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxServer FaxServer;
#else
typedef struct FaxServer FaxServer;
#endif /* __cplusplus */

#endif 	/* __FaxServer_FWD_DEFINED__ */


#ifndef __FaxDeviceProviders_FWD_DEFINED__
#define __FaxDeviceProviders_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxDeviceProviders FaxDeviceProviders;
#else
typedef struct FaxDeviceProviders FaxDeviceProviders;
#endif /* __cplusplus */

#endif 	/* __FaxDeviceProviders_FWD_DEFINED__ */


#ifndef __FaxDevices_FWD_DEFINED__
#define __FaxDevices_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxDevices FaxDevices;
#else
typedef struct FaxDevices FaxDevices;
#endif /* __cplusplus */

#endif 	/* __FaxDevices_FWD_DEFINED__ */


#ifndef __FaxInboundRouting_FWD_DEFINED__
#define __FaxInboundRouting_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxInboundRouting FaxInboundRouting;
#else
typedef struct FaxInboundRouting FaxInboundRouting;
#endif /* __cplusplus */

#endif 	/* __FaxInboundRouting_FWD_DEFINED__ */


#ifndef __FaxFolders_FWD_DEFINED__
#define __FaxFolders_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxFolders FaxFolders;
#else
typedef struct FaxFolders FaxFolders;
#endif /* __cplusplus */

#endif 	/* __FaxFolders_FWD_DEFINED__ */


#ifndef __FaxLoggingOptions_FWD_DEFINED__
#define __FaxLoggingOptions_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxLoggingOptions FaxLoggingOptions;
#else
typedef struct FaxLoggingOptions FaxLoggingOptions;
#endif /* __cplusplus */

#endif 	/* __FaxLoggingOptions_FWD_DEFINED__ */


#ifndef __FaxActivity_FWD_DEFINED__
#define __FaxActivity_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxActivity FaxActivity;
#else
typedef struct FaxActivity FaxActivity;
#endif /* __cplusplus */

#endif 	/* __FaxActivity_FWD_DEFINED__ */


#ifndef __FaxOutboundRouting_FWD_DEFINED__
#define __FaxOutboundRouting_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxOutboundRouting FaxOutboundRouting;
#else
typedef struct FaxOutboundRouting FaxOutboundRouting;
#endif /* __cplusplus */

#endif 	/* __FaxOutboundRouting_FWD_DEFINED__ */


#ifndef __FaxReceiptOptions_FWD_DEFINED__
#define __FaxReceiptOptions_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxReceiptOptions FaxReceiptOptions;
#else
typedef struct FaxReceiptOptions FaxReceiptOptions;
#endif /* __cplusplus */

#endif 	/* __FaxReceiptOptions_FWD_DEFINED__ */


#ifndef __FaxSecurity_FWD_DEFINED__
#define __FaxSecurity_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxSecurity FaxSecurity;
#else
typedef struct FaxSecurity FaxSecurity;
#endif /* __cplusplus */

#endif 	/* __FaxSecurity_FWD_DEFINED__ */


#ifndef __FaxDocument_FWD_DEFINED__
#define __FaxDocument_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxDocument FaxDocument;
#else
typedef struct FaxDocument FaxDocument;
#endif /* __cplusplus */

#endif 	/* __FaxDocument_FWD_DEFINED__ */


#ifndef __FaxAttachments_FWD_DEFINED__
#define __FaxAttachments_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxAttachments FaxAttachments;
#else
typedef struct FaxAttachments FaxAttachments;
#endif /* __cplusplus */

#endif 	/* __FaxAttachments_FWD_DEFINED__ */


#ifndef __FaxSender_FWD_DEFINED__
#define __FaxSender_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxSender FaxSender;
#else
typedef struct FaxSender FaxSender;
#endif /* __cplusplus */

#endif 	/* __FaxSender_FWD_DEFINED__ */


#ifndef __FaxRecipients_FWD_DEFINED__
#define __FaxRecipients_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxRecipients FaxRecipients;
#else
typedef struct FaxRecipients FaxRecipients;
#endif /* __cplusplus */

#endif 	/* __FaxRecipients_FWD_DEFINED__ */


#ifndef __FaxIncomingArchive_FWD_DEFINED__
#define __FaxIncomingArchive_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxIncomingArchive FaxIncomingArchive;
#else
typedef struct FaxIncomingArchive FaxIncomingArchive;
#endif /* __cplusplus */

#endif 	/* __FaxIncomingArchive_FWD_DEFINED__ */


#ifndef __FaxIncomingQueue_FWD_DEFINED__
#define __FaxIncomingQueue_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxIncomingQueue FaxIncomingQueue;
#else
typedef struct FaxIncomingQueue FaxIncomingQueue;
#endif /* __cplusplus */

#endif 	/* __FaxIncomingQueue_FWD_DEFINED__ */


#ifndef __FaxOutgoingArchive_FWD_DEFINED__
#define __FaxOutgoingArchive_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxOutgoingArchive FaxOutgoingArchive;
#else
typedef struct FaxOutgoingArchive FaxOutgoingArchive;
#endif /* __cplusplus */

#endif 	/* __FaxOutgoingArchive_FWD_DEFINED__ */


#ifndef __FaxOutgoingQueue_FWD_DEFINED__
#define __FaxOutgoingQueue_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxOutgoingQueue FaxOutgoingQueue;
#else
typedef struct FaxOutgoingQueue FaxOutgoingQueue;
#endif /* __cplusplus */

#endif 	/* __FaxOutgoingQueue_FWD_DEFINED__ */


#ifndef __FaxIncomingMessageIterator_FWD_DEFINED__
#define __FaxIncomingMessageIterator_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxIncomingMessageIterator FaxIncomingMessageIterator;
#else
typedef struct FaxIncomingMessageIterator FaxIncomingMessageIterator;
#endif /* __cplusplus */

#endif 	/* __FaxIncomingMessageIterator_FWD_DEFINED__ */


#ifndef __FaxIncomingMessage_FWD_DEFINED__
#define __FaxIncomingMessage_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxIncomingMessage FaxIncomingMessage;
#else
typedef struct FaxIncomingMessage FaxIncomingMessage;
#endif /* __cplusplus */

#endif 	/* __FaxIncomingMessage_FWD_DEFINED__ */


#ifndef __FaxOutgoingJobs_FWD_DEFINED__
#define __FaxOutgoingJobs_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxOutgoingJobs FaxOutgoingJobs;
#else
typedef struct FaxOutgoingJobs FaxOutgoingJobs;
#endif /* __cplusplus */

#endif 	/* __FaxOutgoingJobs_FWD_DEFINED__ */


#ifndef __FaxOutgoingJob_FWD_DEFINED__
#define __FaxOutgoingJob_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxOutgoingJob FaxOutgoingJob;
#else
typedef struct FaxOutgoingJob FaxOutgoingJob;
#endif /* __cplusplus */

#endif 	/* __FaxOutgoingJob_FWD_DEFINED__ */


#ifndef __FaxOutgoingMessageIterator_FWD_DEFINED__
#define __FaxOutgoingMessageIterator_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxOutgoingMessageIterator FaxOutgoingMessageIterator;
#else
typedef struct FaxOutgoingMessageIterator FaxOutgoingMessageIterator;
#endif /* __cplusplus */

#endif 	/* __FaxOutgoingMessageIterator_FWD_DEFINED__ */


#ifndef __FaxOutgoingMessage_FWD_DEFINED__
#define __FaxOutgoingMessage_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxOutgoingMessage FaxOutgoingMessage;
#else
typedef struct FaxOutgoingMessage FaxOutgoingMessage;
#endif /* __cplusplus */

#endif 	/* __FaxOutgoingMessage_FWD_DEFINED__ */


#ifndef __FaxIncomingJobs_FWD_DEFINED__
#define __FaxIncomingJobs_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxIncomingJobs FaxIncomingJobs;
#else
typedef struct FaxIncomingJobs FaxIncomingJobs;
#endif /* __cplusplus */

#endif 	/* __FaxIncomingJobs_FWD_DEFINED__ */


#ifndef __FaxIncomingJob_FWD_DEFINED__
#define __FaxIncomingJob_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxIncomingJob FaxIncomingJob;
#else
typedef struct FaxIncomingJob FaxIncomingJob;
#endif /* __cplusplus */

#endif 	/* __FaxIncomingJob_FWD_DEFINED__ */


#ifndef __FaxDeviceProvider_FWD_DEFINED__
#define __FaxDeviceProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxDeviceProvider FaxDeviceProvider;
#else
typedef struct FaxDeviceProvider FaxDeviceProvider;
#endif /* __cplusplus */

#endif 	/* __FaxDeviceProvider_FWD_DEFINED__ */


#ifndef __FaxDevice_FWD_DEFINED__
#define __FaxDevice_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxDevice FaxDevice;
#else
typedef struct FaxDevice FaxDevice;
#endif /* __cplusplus */

#endif 	/* __FaxDevice_FWD_DEFINED__ */


#ifndef __FaxActivityLogging_FWD_DEFINED__
#define __FaxActivityLogging_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxActivityLogging FaxActivityLogging;
#else
typedef struct FaxActivityLogging FaxActivityLogging;
#endif /* __cplusplus */

#endif 	/* __FaxActivityLogging_FWD_DEFINED__ */


#ifndef __FaxEventLogging_FWD_DEFINED__
#define __FaxEventLogging_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxEventLogging FaxEventLogging;
#else
typedef struct FaxEventLogging FaxEventLogging;
#endif /* __cplusplus */

#endif 	/* __FaxEventLogging_FWD_DEFINED__ */


#ifndef __FaxOutboundRoutingGroups_FWD_DEFINED__
#define __FaxOutboundRoutingGroups_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxOutboundRoutingGroups FaxOutboundRoutingGroups;
#else
typedef struct FaxOutboundRoutingGroups FaxOutboundRoutingGroups;
#endif /* __cplusplus */

#endif 	/* __FaxOutboundRoutingGroups_FWD_DEFINED__ */


#ifndef __FaxOutboundRoutingGroup_FWD_DEFINED__
#define __FaxOutboundRoutingGroup_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxOutboundRoutingGroup FaxOutboundRoutingGroup;
#else
typedef struct FaxOutboundRoutingGroup FaxOutboundRoutingGroup;
#endif /* __cplusplus */

#endif 	/* __FaxOutboundRoutingGroup_FWD_DEFINED__ */


#ifndef __FaxDeviceIds_FWD_DEFINED__
#define __FaxDeviceIds_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxDeviceIds FaxDeviceIds;
#else
typedef struct FaxDeviceIds FaxDeviceIds;
#endif /* __cplusplus */

#endif 	/* __FaxDeviceIds_FWD_DEFINED__ */


#ifndef __FaxOutboundRoutingRules_FWD_DEFINED__
#define __FaxOutboundRoutingRules_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxOutboundRoutingRules FaxOutboundRoutingRules;
#else
typedef struct FaxOutboundRoutingRules FaxOutboundRoutingRules;
#endif /* __cplusplus */

#endif 	/* __FaxOutboundRoutingRules_FWD_DEFINED__ */


#ifndef __FaxOutboundRoutingRule_FWD_DEFINED__
#define __FaxOutboundRoutingRule_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxOutboundRoutingRule FaxOutboundRoutingRule;
#else
typedef struct FaxOutboundRoutingRule FaxOutboundRoutingRule;
#endif /* __cplusplus */

#endif 	/* __FaxOutboundRoutingRule_FWD_DEFINED__ */


#ifndef __FaxInboundRoutingExtensions_FWD_DEFINED__
#define __FaxInboundRoutingExtensions_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxInboundRoutingExtensions FaxInboundRoutingExtensions;
#else
typedef struct FaxInboundRoutingExtensions FaxInboundRoutingExtensions;
#endif /* __cplusplus */

#endif 	/* __FaxInboundRoutingExtensions_FWD_DEFINED__ */


#ifndef __FaxInboundRoutingExtension_FWD_DEFINED__
#define __FaxInboundRoutingExtension_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxInboundRoutingExtension FaxInboundRoutingExtension;
#else
typedef struct FaxInboundRoutingExtension FaxInboundRoutingExtension;
#endif /* __cplusplus */

#endif 	/* __FaxInboundRoutingExtension_FWD_DEFINED__ */


#ifndef __FaxInboundRoutingMethods_FWD_DEFINED__
#define __FaxInboundRoutingMethods_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxInboundRoutingMethods FaxInboundRoutingMethods;
#else
typedef struct FaxInboundRoutingMethods FaxInboundRoutingMethods;
#endif /* __cplusplus */

#endif 	/* __FaxInboundRoutingMethods_FWD_DEFINED__ */


#ifndef __FaxInboundRoutingMethod_FWD_DEFINED__
#define __FaxInboundRoutingMethod_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxInboundRoutingMethod FaxInboundRoutingMethod;
#else
typedef struct FaxInboundRoutingMethod FaxInboundRoutingMethod;
#endif /* __cplusplus */

#endif 	/* __FaxInboundRoutingMethod_FWD_DEFINED__ */


#ifndef __FaxJobStatus_FWD_DEFINED__
#define __FaxJobStatus_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxJobStatus FaxJobStatus;
#else
typedef struct FaxJobStatus FaxJobStatus;
#endif /* __cplusplus */

#endif 	/* __FaxJobStatus_FWD_DEFINED__ */


#ifndef __FaxRecipient_FWD_DEFINED__
#define __FaxRecipient_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxRecipient FaxRecipient;
#else
typedef struct FaxRecipient FaxRecipient;
#endif /* __cplusplus */

#endif 	/* __FaxRecipient_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_faxcomex_0000 */
/* [local] */ 

#define	DEFAULT_PREFETCH_SIZE	( 100 )









































extern RPC_IF_HANDLE __MIDL_itf_faxcomex_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_faxcomex_0000_v0_0_s_ifspec;

#ifndef __IFaxJobStatus_INTERFACE_DEFINED__
#define __IFaxJobStatus_INTERFACE_DEFINED__

/* interface IFaxJobStatus */
/* [unique][helpstring][dual][uuid][object] */ 

typedef 
enum FAX_JOB_STATUS_ENUM
    {	fjsPENDING	= 0x1,
	fjsINPROGRESS	= 0x2,
	fjsFAILED	= 0x8,
	fjsPAUSED	= 0x10,
	fjsNOLINE	= 0x20,
	fjsRETRYING	= 0x40,
	fjsRETRIES_EXCEEDED	= 0x80,
	fjsCOMPLETED	= 0x100,
	fjsCANCELED	= 0x200,
	fjsCANCELING	= 0x400,
	fjsROUTING	= 0x800
    } 	FAX_JOB_STATUS_ENUM;

typedef 
enum FAX_JOB_EXTENDED_STATUS_ENUM
    {	fjesNONE	= 0,
	fjesDISCONNECTED	= fjesNONE + 1,
	fjesINITIALIZING	= fjesDISCONNECTED + 1,
	fjesDIALING	= fjesINITIALIZING + 1,
	fjesTRANSMITTING	= fjesDIALING + 1,
	fjesANSWERED	= fjesTRANSMITTING + 1,
	fjesRECEIVING	= fjesANSWERED + 1,
	fjesLINE_UNAVAILABLE	= fjesRECEIVING + 1,
	fjesBUSY	= fjesLINE_UNAVAILABLE + 1,
	fjesNO_ANSWER	= fjesBUSY + 1,
	fjesBAD_ADDRESS	= fjesNO_ANSWER + 1,
	fjesNO_DIAL_TONE	= fjesBAD_ADDRESS + 1,
	fjesFATAL_ERROR	= fjesNO_DIAL_TONE + 1,
	fjesCALL_DELAYED	= fjesFATAL_ERROR + 1,
	fjesCALL_BLACKLISTED	= fjesCALL_DELAYED + 1,
	fjesNOT_FAX_CALL	= fjesCALL_BLACKLISTED + 1,
	fjesPARTIALLY_RECEIVED	= fjesNOT_FAX_CALL + 1,
	fjesHANDLED	= fjesPARTIALLY_RECEIVED + 1,
	fjesCALL_COMPLETED	= fjesHANDLED + 1,
	fjesCALL_ABORTED	= fjesCALL_COMPLETED + 1,
	fjesPROPRIETARY	= 0x1000000
    } 	FAX_JOB_EXTENDED_STATUS_ENUM;

typedef 
enum FAX_JOB_OPERATIONS_ENUM
    {	fjoVIEW	= 0x1,
	fjoPAUSE	= 0x2,
	fjoRESUME	= 0x4,
	fjoRESTART	= 0x8,
	fjoDELETE	= 0x10,
	fjoRECIPIENT_INFO	= 0x20,
	fjoSENDER_INFO	= 0x40
    } 	FAX_JOB_OPERATIONS_ENUM;

typedef 
enum FAX_JOB_TYPE_ENUM
    {	fjtSEND	= 0,
	fjtRECEIVE	= fjtSEND + 1,
	fjtROUTING	= fjtRECEIVE + 1
    } 	FAX_JOB_TYPE_ENUM;


EXTERN_C const IID IID_IFaxJobStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8B86F485-FD7F-4824-886B-40C5CAA617CC")
    IFaxJobStatus : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ FAX_JOB_STATUS_ENUM *pStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Pages( 
            /* [retval][out] */ long *plPages) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Size( 
            /* [retval][out] */ long *plSize) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPage( 
            /* [retval][out] */ long *plCurrentPage) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceId( 
            /* [retval][out] */ long *plDeviceId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CSID( 
            /* [retval][out] */ BSTR *pbstrCSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TSID( 
            /* [retval][out] */ BSTR *pbstrTSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtendedStatusCode( 
            /* [retval][out] */ FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtendedStatus( 
            /* [retval][out] */ BSTR *pbstrExtendedStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AvailableOperations( 
            /* [retval][out] */ FAX_JOB_OPERATIONS_ENUM *pAvailableOperations) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Retries( 
            /* [retval][out] */ long *plRetries) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_JobType( 
            /* [retval][out] */ FAX_JOB_TYPE_ENUM *pJobType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ScheduledTime( 
            /* [retval][out] */ DATE *pdateScheduledTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransmissionStart( 
            /* [retval][out] */ DATE *pdateTransmissionStart) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransmissionEnd( 
            /* [retval][out] */ DATE *pdateTransmissionEnd) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallerId( 
            /* [retval][out] */ BSTR *pbstrCallerId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RoutingInformation( 
            /* [retval][out] */ BSTR *pbstrRoutingInformation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxJobStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxJobStatus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxJobStatus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxJobStatus * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxJobStatus * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxJobStatus * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxJobStatus * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxJobStatus * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IFaxJobStatus * This,
            /* [retval][out] */ FAX_JOB_STATUS_ENUM *pStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Pages )( 
            IFaxJobStatus * This,
            /* [retval][out] */ long *plPages);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Size )( 
            IFaxJobStatus * This,
            /* [retval][out] */ long *plSize);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPage )( 
            IFaxJobStatus * This,
            /* [retval][out] */ long *plCurrentPage);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceId )( 
            IFaxJobStatus * This,
            /* [retval][out] */ long *plDeviceId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CSID )( 
            IFaxJobStatus * This,
            /* [retval][out] */ BSTR *pbstrCSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TSID )( 
            IFaxJobStatus * This,
            /* [retval][out] */ BSTR *pbstrTSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExtendedStatusCode )( 
            IFaxJobStatus * This,
            /* [retval][out] */ FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExtendedStatus )( 
            IFaxJobStatus * This,
            /* [retval][out] */ BSTR *pbstrExtendedStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AvailableOperations )( 
            IFaxJobStatus * This,
            /* [retval][out] */ FAX_JOB_OPERATIONS_ENUM *pAvailableOperations);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Retries )( 
            IFaxJobStatus * This,
            /* [retval][out] */ long *plRetries);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_JobType )( 
            IFaxJobStatus * This,
            /* [retval][out] */ FAX_JOB_TYPE_ENUM *pJobType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ScheduledTime )( 
            IFaxJobStatus * This,
            /* [retval][out] */ DATE *pdateScheduledTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionStart )( 
            IFaxJobStatus * This,
            /* [retval][out] */ DATE *pdateTransmissionStart);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionEnd )( 
            IFaxJobStatus * This,
            /* [retval][out] */ DATE *pdateTransmissionEnd);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallerId )( 
            IFaxJobStatus * This,
            /* [retval][out] */ BSTR *pbstrCallerId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RoutingInformation )( 
            IFaxJobStatus * This,
            /* [retval][out] */ BSTR *pbstrRoutingInformation);
        
        END_INTERFACE
    } IFaxJobStatusVtbl;

    interface IFaxJobStatus
    {
        CONST_VTBL struct IFaxJobStatusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxJobStatus_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxJobStatus_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxJobStatus_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxJobStatus_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxJobStatus_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxJobStatus_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxJobStatus_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxJobStatus_get_Status(This,pStatus)	\
    (This)->lpVtbl -> get_Status(This,pStatus)

#define IFaxJobStatus_get_Pages(This,plPages)	\
    (This)->lpVtbl -> get_Pages(This,plPages)

#define IFaxJobStatus_get_Size(This,plSize)	\
    (This)->lpVtbl -> get_Size(This,plSize)

#define IFaxJobStatus_get_CurrentPage(This,plCurrentPage)	\
    (This)->lpVtbl -> get_CurrentPage(This,plCurrentPage)

#define IFaxJobStatus_get_DeviceId(This,plDeviceId)	\
    (This)->lpVtbl -> get_DeviceId(This,plDeviceId)

#define IFaxJobStatus_get_CSID(This,pbstrCSID)	\
    (This)->lpVtbl -> get_CSID(This,pbstrCSID)

#define IFaxJobStatus_get_TSID(This,pbstrTSID)	\
    (This)->lpVtbl -> get_TSID(This,pbstrTSID)

#define IFaxJobStatus_get_ExtendedStatusCode(This,pExtendedStatusCode)	\
    (This)->lpVtbl -> get_ExtendedStatusCode(This,pExtendedStatusCode)

#define IFaxJobStatus_get_ExtendedStatus(This,pbstrExtendedStatus)	\
    (This)->lpVtbl -> get_ExtendedStatus(This,pbstrExtendedStatus)

#define IFaxJobStatus_get_AvailableOperations(This,pAvailableOperations)	\
    (This)->lpVtbl -> get_AvailableOperations(This,pAvailableOperations)

#define IFaxJobStatus_get_Retries(This,plRetries)	\
    (This)->lpVtbl -> get_Retries(This,plRetries)

#define IFaxJobStatus_get_JobType(This,pJobType)	\
    (This)->lpVtbl -> get_JobType(This,pJobType)

#define IFaxJobStatus_get_ScheduledTime(This,pdateScheduledTime)	\
    (This)->lpVtbl -> get_ScheduledTime(This,pdateScheduledTime)

#define IFaxJobStatus_get_TransmissionStart(This,pdateTransmissionStart)	\
    (This)->lpVtbl -> get_TransmissionStart(This,pdateTransmissionStart)

#define IFaxJobStatus_get_TransmissionEnd(This,pdateTransmissionEnd)	\
    (This)->lpVtbl -> get_TransmissionEnd(This,pdateTransmissionEnd)

#define IFaxJobStatus_get_CallerId(This,pbstrCallerId)	\
    (This)->lpVtbl -> get_CallerId(This,pbstrCallerId)

#define IFaxJobStatus_get_RoutingInformation(This,pbstrRoutingInformation)	\
    (This)->lpVtbl -> get_RoutingInformation(This,pbstrRoutingInformation)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_Status_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ FAX_JOB_STATUS_ENUM *pStatus);


void __RPC_STUB IFaxJobStatus_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_Pages_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ long *plPages);


void __RPC_STUB IFaxJobStatus_get_Pages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_Size_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ long *plSize);


void __RPC_STUB IFaxJobStatus_get_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_CurrentPage_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ long *plCurrentPage);


void __RPC_STUB IFaxJobStatus_get_CurrentPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_DeviceId_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ long *plDeviceId);


void __RPC_STUB IFaxJobStatus_get_DeviceId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_CSID_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ BSTR *pbstrCSID);


void __RPC_STUB IFaxJobStatus_get_CSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_TSID_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ BSTR *pbstrTSID);


void __RPC_STUB IFaxJobStatus_get_TSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_ExtendedStatusCode_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode);


void __RPC_STUB IFaxJobStatus_get_ExtendedStatusCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_ExtendedStatus_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ BSTR *pbstrExtendedStatus);


void __RPC_STUB IFaxJobStatus_get_ExtendedStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_AvailableOperations_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ FAX_JOB_OPERATIONS_ENUM *pAvailableOperations);


void __RPC_STUB IFaxJobStatus_get_AvailableOperations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_Retries_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ long *plRetries);


void __RPC_STUB IFaxJobStatus_get_Retries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_JobType_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ FAX_JOB_TYPE_ENUM *pJobType);


void __RPC_STUB IFaxJobStatus_get_JobType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_ScheduledTime_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ DATE *pdateScheduledTime);


void __RPC_STUB IFaxJobStatus_get_ScheduledTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_TransmissionStart_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ DATE *pdateTransmissionStart);


void __RPC_STUB IFaxJobStatus_get_TransmissionStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_TransmissionEnd_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ DATE *pdateTransmissionEnd);


void __RPC_STUB IFaxJobStatus_get_TransmissionEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_CallerId_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ BSTR *pbstrCallerId);


void __RPC_STUB IFaxJobStatus_get_CallerId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_RoutingInformation_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ BSTR *pbstrRoutingInformation);


void __RPC_STUB IFaxJobStatus_get_RoutingInformation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxJobStatus_INTERFACE_DEFINED__ */


#ifndef __IFaxServer_INTERFACE_DEFINED__
#define __IFaxServer_INTERFACE_DEFINED__

/* interface IFaxServer */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 

typedef 
enum FAX_SERVER_EVENTS_TYPE_ENUM
    {	fsetNONE	= 0,
	fsetIN_QUEUE	= 0x1,
	fsetOUT_QUEUE	= 0x2,
	fsetCONFIG	= 0x4,
	fsetACTIVITY	= 0x8,
	fsetQUEUE_STATE	= 0x10,
	fsetIN_ARCHIVE	= 0x20,
	fsetOUT_ARCHIVE	= 0x40,
	fsetFXSSVC_ENDED	= 0x80,
	fsetDEVICE_STATUS	= 0x100,
	fsetINCOMING_CALL	= 0x200
    } 	FAX_SERVER_EVENTS_TYPE_ENUM;


EXTERN_C const IID IID_IFaxServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("475B6469-90A5-4878-A577-17A86E8E3462")
    IFaxServer : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ BSTR bstrServerName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ServerName( 
            /* [retval][out] */ BSTR *pbstrServerName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDeviceProviders( 
            /* [retval][out] */ IFaxDeviceProviders **ppFaxDeviceProviders) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDevices( 
            /* [retval][out] */ IFaxDevices **ppFaxDevices) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InboundRouting( 
            /* [retval][out] */ IFaxInboundRouting **ppFaxInboundRouting) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Folders( 
            /* [retval][out] */ IFaxFolders **pFaxFolders) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LoggingOptions( 
            /* [retval][out] */ IFaxLoggingOptions **ppFaxLoggingOptions) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MajorVersion( 
            /* [retval][out] */ long *plMajorVersion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinorVersion( 
            /* [retval][out] */ long *plMinorVersion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MajorBuild( 
            /* [retval][out] */ long *plMajorBuild) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinorBuild( 
            /* [retval][out] */ long *plMinorBuild) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Debug( 
            /* [retval][out] */ VARIANT_BOOL *pbDebug) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Activity( 
            /* [retval][out] */ IFaxActivity **ppFaxActivity) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutboundRouting( 
            /* [retval][out] */ IFaxOutboundRouting **ppFaxOutboundRouting) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReceiptOptions( 
            /* [retval][out] */ IFaxReceiptOptions **ppFaxReceiptOptions) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Security( 
            /* [retval][out] */ IFaxSecurity **ppFaxSecurity) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetExtensionProperty( 
            /* [in] */ BSTR bstrGUID,
            /* [retval][out] */ VARIANT *pvProperty) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetExtensionProperty( 
            /* [in] */ BSTR bstrGUID,
            /* [in] */ VARIANT vProperty) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ListenToServerEvents( 
            /* [in] */ FAX_SERVER_EVENTS_TYPE_ENUM EventTypes) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RegisterDeviceProvider( 
            /* [in] */ BSTR bstrGUID,
            /* [in] */ BSTR bstrFriendlyName,
            /* [in] */ BSTR bstrImageName,
            /* [in] */ BSTR TspName,
            /* [in] */ long lFSPIVersion) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnregisterDeviceProvider( 
            /* [in] */ BSTR bstrUniqueName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RegisterInboundRoutingExtension( 
            /* [in] */ BSTR bstrExtensionName,
            /* [in] */ BSTR bstrFriendlyName,
            /* [in] */ BSTR bstrImageName,
            /* [in] */ VARIANT vMethods) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnregisterInboundRoutingExtension( 
            /* [in] */ BSTR bstrExtensionUniqueName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RegisteredEvents( 
            /* [retval][out] */ FAX_SERVER_EVENTS_TYPE_ENUM *pEventTypes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxServer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxServer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxServer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxServer * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxServer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxServer * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxServer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IFaxServer * This,
            /* [in] */ BSTR bstrServerName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServerName )( 
            IFaxServer * This,
            /* [retval][out] */ BSTR *pbstrServerName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDeviceProviders )( 
            IFaxServer * This,
            /* [retval][out] */ IFaxDeviceProviders **ppFaxDeviceProviders);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDevices )( 
            IFaxServer * This,
            /* [retval][out] */ IFaxDevices **ppFaxDevices);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InboundRouting )( 
            IFaxServer * This,
            /* [retval][out] */ IFaxInboundRouting **ppFaxInboundRouting);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Folders )( 
            IFaxServer * This,
            /* [retval][out] */ IFaxFolders **pFaxFolders);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LoggingOptions )( 
            IFaxServer * This,
            /* [retval][out] */ IFaxLoggingOptions **ppFaxLoggingOptions);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MajorVersion )( 
            IFaxServer * This,
            /* [retval][out] */ long *plMajorVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinorVersion )( 
            IFaxServer * This,
            /* [retval][out] */ long *plMinorVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MajorBuild )( 
            IFaxServer * This,
            /* [retval][out] */ long *plMajorBuild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinorBuild )( 
            IFaxServer * This,
            /* [retval][out] */ long *plMinorBuild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Debug )( 
            IFaxServer * This,
            /* [retval][out] */ VARIANT_BOOL *pbDebug);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Activity )( 
            IFaxServer * This,
            /* [retval][out] */ IFaxActivity **ppFaxActivity);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutboundRouting )( 
            IFaxServer * This,
            /* [retval][out] */ IFaxOutboundRouting **ppFaxOutboundRouting);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReceiptOptions )( 
            IFaxServer * This,
            /* [retval][out] */ IFaxReceiptOptions **ppFaxReceiptOptions);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Security )( 
            IFaxServer * This,
            /* [retval][out] */ IFaxSecurity **ppFaxSecurity);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IFaxServer * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetExtensionProperty )( 
            IFaxServer * This,
            /* [in] */ BSTR bstrGUID,
            /* [retval][out] */ VARIANT *pvProperty);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetExtensionProperty )( 
            IFaxServer * This,
            /* [in] */ BSTR bstrGUID,
            /* [in] */ VARIANT vProperty);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ListenToServerEvents )( 
            IFaxServer * This,
            /* [in] */ FAX_SERVER_EVENTS_TYPE_ENUM EventTypes);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RegisterDeviceProvider )( 
            IFaxServer * This,
            /* [in] */ BSTR bstrGUID,
            /* [in] */ BSTR bstrFriendlyName,
            /* [in] */ BSTR bstrImageName,
            /* [in] */ BSTR TspName,
            /* [in] */ long lFSPIVersion);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UnregisterDeviceProvider )( 
            IFaxServer * This,
            /* [in] */ BSTR bstrUniqueName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RegisterInboundRoutingExtension )( 
            IFaxServer * This,
            /* [in] */ BSTR bstrExtensionName,
            /* [in] */ BSTR bstrFriendlyName,
            /* [in] */ BSTR bstrImageName,
            /* [in] */ VARIANT vMethods);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UnregisterInboundRoutingExtension )( 
            IFaxServer * This,
            /* [in] */ BSTR bstrExtensionUniqueName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RegisteredEvents )( 
            IFaxServer * This,
            /* [retval][out] */ FAX_SERVER_EVENTS_TYPE_ENUM *pEventTypes);
        
        END_INTERFACE
    } IFaxServerVtbl;

    interface IFaxServer
    {
        CONST_VTBL struct IFaxServerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxServer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxServer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxServer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxServer_Connect(This,bstrServerName)	\
    (This)->lpVtbl -> Connect(This,bstrServerName)

#define IFaxServer_get_ServerName(This,pbstrServerName)	\
    (This)->lpVtbl -> get_ServerName(This,pbstrServerName)

#define IFaxServer_GetDeviceProviders(This,ppFaxDeviceProviders)	\
    (This)->lpVtbl -> GetDeviceProviders(This,ppFaxDeviceProviders)

#define IFaxServer_GetDevices(This,ppFaxDevices)	\
    (This)->lpVtbl -> GetDevices(This,ppFaxDevices)

#define IFaxServer_get_InboundRouting(This,ppFaxInboundRouting)	\
    (This)->lpVtbl -> get_InboundRouting(This,ppFaxInboundRouting)

#define IFaxServer_get_Folders(This,pFaxFolders)	\
    (This)->lpVtbl -> get_Folders(This,pFaxFolders)

#define IFaxServer_get_LoggingOptions(This,ppFaxLoggingOptions)	\
    (This)->lpVtbl -> get_LoggingOptions(This,ppFaxLoggingOptions)

#define IFaxServer_get_MajorVersion(This,plMajorVersion)	\
    (This)->lpVtbl -> get_MajorVersion(This,plMajorVersion)

#define IFaxServer_get_MinorVersion(This,plMinorVersion)	\
    (This)->lpVtbl -> get_MinorVersion(This,plMinorVersion)

#define IFaxServer_get_MajorBuild(This,plMajorBuild)	\
    (This)->lpVtbl -> get_MajorBuild(This,plMajorBuild)

#define IFaxServer_get_MinorBuild(This,plMinorBuild)	\
    (This)->lpVtbl -> get_MinorBuild(This,plMinorBuild)

#define IFaxServer_get_Debug(This,pbDebug)	\
    (This)->lpVtbl -> get_Debug(This,pbDebug)

#define IFaxServer_get_Activity(This,ppFaxActivity)	\
    (This)->lpVtbl -> get_Activity(This,ppFaxActivity)

#define IFaxServer_get_OutboundRouting(This,ppFaxOutboundRouting)	\
    (This)->lpVtbl -> get_OutboundRouting(This,ppFaxOutboundRouting)

#define IFaxServer_get_ReceiptOptions(This,ppFaxReceiptOptions)	\
    (This)->lpVtbl -> get_ReceiptOptions(This,ppFaxReceiptOptions)

#define IFaxServer_get_Security(This,ppFaxSecurity)	\
    (This)->lpVtbl -> get_Security(This,ppFaxSecurity)

#define IFaxServer_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IFaxServer_GetExtensionProperty(This,bstrGUID,pvProperty)	\
    (This)->lpVtbl -> GetExtensionProperty(This,bstrGUID,pvProperty)

#define IFaxServer_SetExtensionProperty(This,bstrGUID,vProperty)	\
    (This)->lpVtbl -> SetExtensionProperty(This,bstrGUID,vProperty)

#define IFaxServer_ListenToServerEvents(This,EventTypes)	\
    (This)->lpVtbl -> ListenToServerEvents(This,EventTypes)

#define IFaxServer_RegisterDeviceProvider(This,bstrGUID,bstrFriendlyName,bstrImageName,TspName,lFSPIVersion)	\
    (This)->lpVtbl -> RegisterDeviceProvider(This,bstrGUID,bstrFriendlyName,bstrImageName,TspName,lFSPIVersion)

#define IFaxServer_UnregisterDeviceProvider(This,bstrUniqueName)	\
    (This)->lpVtbl -> UnregisterDeviceProvider(This,bstrUniqueName)

#define IFaxServer_RegisterInboundRoutingExtension(This,bstrExtensionName,bstrFriendlyName,bstrImageName,vMethods)	\
    (This)->lpVtbl -> RegisterInboundRoutingExtension(This,bstrExtensionName,bstrFriendlyName,bstrImageName,vMethods)

#define IFaxServer_UnregisterInboundRoutingExtension(This,bstrExtensionUniqueName)	\
    (This)->lpVtbl -> UnregisterInboundRoutingExtension(This,bstrExtensionUniqueName)

#define IFaxServer_get_RegisteredEvents(This,pEventTypes)	\
    (This)->lpVtbl -> get_RegisteredEvents(This,pEventTypes)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_Connect_Proxy( 
    IFaxServer * This,
    /* [in] */ BSTR bstrServerName);


void __RPC_STUB IFaxServer_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_ServerName_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ BSTR *pbstrServerName);


void __RPC_STUB IFaxServer_get_ServerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_GetDeviceProviders_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ IFaxDeviceProviders **ppFaxDeviceProviders);


void __RPC_STUB IFaxServer_GetDeviceProviders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_GetDevices_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ IFaxDevices **ppFaxDevices);


void __RPC_STUB IFaxServer_GetDevices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_InboundRouting_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ IFaxInboundRouting **ppFaxInboundRouting);


void __RPC_STUB IFaxServer_get_InboundRouting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_Folders_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ IFaxFolders **pFaxFolders);


void __RPC_STUB IFaxServer_get_Folders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_LoggingOptions_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ IFaxLoggingOptions **ppFaxLoggingOptions);


void __RPC_STUB IFaxServer_get_LoggingOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_MajorVersion_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ long *plMajorVersion);


void __RPC_STUB IFaxServer_get_MajorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_MinorVersion_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ long *plMinorVersion);


void __RPC_STUB IFaxServer_get_MinorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_MajorBuild_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ long *plMajorBuild);


void __RPC_STUB IFaxServer_get_MajorBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_MinorBuild_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ long *plMinorBuild);


void __RPC_STUB IFaxServer_get_MinorBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_Debug_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ VARIANT_BOOL *pbDebug);


void __RPC_STUB IFaxServer_get_Debug_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_Activity_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ IFaxActivity **ppFaxActivity);


void __RPC_STUB IFaxServer_get_Activity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_OutboundRouting_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ IFaxOutboundRouting **ppFaxOutboundRouting);


void __RPC_STUB IFaxServer_get_OutboundRouting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_ReceiptOptions_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ IFaxReceiptOptions **ppFaxReceiptOptions);


void __RPC_STUB IFaxServer_get_ReceiptOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_Security_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ IFaxSecurity **ppFaxSecurity);


void __RPC_STUB IFaxServer_get_Security_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_Disconnect_Proxy( 
    IFaxServer * This);


void __RPC_STUB IFaxServer_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_GetExtensionProperty_Proxy( 
    IFaxServer * This,
    /* [in] */ BSTR bstrGUID,
    /* [retval][out] */ VARIANT *pvProperty);


void __RPC_STUB IFaxServer_GetExtensionProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_SetExtensionProperty_Proxy( 
    IFaxServer * This,
    /* [in] */ BSTR bstrGUID,
    /* [in] */ VARIANT vProperty);


void __RPC_STUB IFaxServer_SetExtensionProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_ListenToServerEvents_Proxy( 
    IFaxServer * This,
    /* [in] */ FAX_SERVER_EVENTS_TYPE_ENUM EventTypes);


void __RPC_STUB IFaxServer_ListenToServerEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_RegisterDeviceProvider_Proxy( 
    IFaxServer * This,
    /* [in] */ BSTR bstrGUID,
    /* [in] */ BSTR bstrFriendlyName,
    /* [in] */ BSTR bstrImageName,
    /* [in] */ BSTR TspName,
    /* [in] */ long lFSPIVersion);


void __RPC_STUB IFaxServer_RegisterDeviceProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_UnregisterDeviceProvider_Proxy( 
    IFaxServer * This,
    /* [in] */ BSTR bstrUniqueName);


void __RPC_STUB IFaxServer_UnregisterDeviceProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_RegisterInboundRoutingExtension_Proxy( 
    IFaxServer * This,
    /* [in] */ BSTR bstrExtensionName,
    /* [in] */ BSTR bstrFriendlyName,
    /* [in] */ BSTR bstrImageName,
    /* [in] */ VARIANT vMethods);


void __RPC_STUB IFaxServer_RegisterInboundRoutingExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_UnregisterInboundRoutingExtension_Proxy( 
    IFaxServer * This,
    /* [in] */ BSTR bstrExtensionUniqueName);


void __RPC_STUB IFaxServer_UnregisterInboundRoutingExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_RegisteredEvents_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ FAX_SERVER_EVENTS_TYPE_ENUM *pEventTypes);


void __RPC_STUB IFaxServer_get_RegisteredEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxServer_INTERFACE_DEFINED__ */


#ifndef __IFaxDeviceProviders_INTERFACE_DEFINED__
#define __IFaxDeviceProviders_INTERFACE_DEFINED__

/* interface IFaxDeviceProviders */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxDeviceProviders;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9FB76F62-4C7E-43A5-B6FD-502893F7E13E")
    IFaxDeviceProviders : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxDeviceProvider **pFaxDeviceProvider) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxDeviceProvidersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxDeviceProviders * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxDeviceProviders * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxDeviceProviders * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxDeviceProviders * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxDeviceProviders * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxDeviceProviders * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxDeviceProviders * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFaxDeviceProviders * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxDeviceProviders * This,
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxDeviceProvider **pFaxDeviceProvider);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxDeviceProviders * This,
            /* [retval][out] */ long *plCount);
        
        END_INTERFACE
    } IFaxDeviceProvidersVtbl;

    interface IFaxDeviceProviders
    {
        CONST_VTBL struct IFaxDeviceProvidersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxDeviceProviders_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxDeviceProviders_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxDeviceProviders_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxDeviceProviders_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxDeviceProviders_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxDeviceProviders_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxDeviceProviders_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxDeviceProviders_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#define IFaxDeviceProviders_get_Item(This,vIndex,pFaxDeviceProvider)	\
    (This)->lpVtbl -> get_Item(This,vIndex,pFaxDeviceProvider)

#define IFaxDeviceProviders_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProviders_get__NewEnum_Proxy( 
    IFaxDeviceProviders * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFaxDeviceProviders_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProviders_get_Item_Proxy( 
    IFaxDeviceProviders * This,
    /* [in] */ VARIANT vIndex,
    /* [retval][out] */ IFaxDeviceProvider **pFaxDeviceProvider);


void __RPC_STUB IFaxDeviceProviders_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProviders_get_Count_Proxy( 
    IFaxDeviceProviders * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IFaxDeviceProviders_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxDeviceProviders_INTERFACE_DEFINED__ */


#ifndef __IFaxDevices_INTERFACE_DEFINED__
#define __IFaxDevices_INTERFACE_DEFINED__

/* interface IFaxDevices */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxDevices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9E46783E-F34F-482E-A360-0416BECBBD96")
    IFaxDevices : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ IFaxDevice **pFaxDevice) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ItemById( 
            /* [in] */ long lId,
            /* [retval][out] */ IFaxDevice **ppFaxDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxDevicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxDevices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxDevices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxDevices * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxDevices * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxDevices * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxDevices * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxDevices * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFaxDevices * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxDevices * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ IFaxDevice **pFaxDevice);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxDevices * This,
            /* [retval][out] */ long *plCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ItemById )( 
            IFaxDevices * This,
            /* [in] */ long lId,
            /* [retval][out] */ IFaxDevice **ppFaxDevice);
        
        END_INTERFACE
    } IFaxDevicesVtbl;

    interface IFaxDevices
    {
        CONST_VTBL struct IFaxDevicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxDevices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxDevices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxDevices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxDevices_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxDevices_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxDevices_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxDevices_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxDevices_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#define IFaxDevices_get_Item(This,lIndex,pFaxDevice)	\
    (This)->lpVtbl -> get_Item(This,lIndex,pFaxDevice)

#define IFaxDevices_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define IFaxDevices_ItemById(This,lId,ppFaxDevice)	\
    (This)->lpVtbl -> ItemById(This,lId,ppFaxDevice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxDevices_get__NewEnum_Proxy( 
    IFaxDevices * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFaxDevices_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxDevices_get_Item_Proxy( 
    IFaxDevices * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ IFaxDevice **pFaxDevice);


void __RPC_STUB IFaxDevices_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxDevices_get_Count_Proxy( 
    IFaxDevices * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IFaxDevices_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDevices_ItemById_Proxy( 
    IFaxDevices * This,
    /* [in] */ long lId,
    /* [retval][out] */ IFaxDevice **ppFaxDevice);


void __RPC_STUB IFaxDevices_ItemById_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxDevices_INTERFACE_DEFINED__ */


#ifndef __IFaxInboundRouting_INTERFACE_DEFINED__
#define __IFaxInboundRouting_INTERFACE_DEFINED__

/* interface IFaxInboundRouting */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxInboundRouting;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8148C20F-9D52-45B1-BF96-38FC12713527")
    IFaxInboundRouting : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetExtensions( 
            /* [retval][out] */ IFaxInboundRoutingExtensions **pFaxInboundRoutingExtensions) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMethods( 
            /* [retval][out] */ IFaxInboundRoutingMethods **pFaxInboundRoutingMethods) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxInboundRoutingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxInboundRouting * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxInboundRouting * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxInboundRouting * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxInboundRouting * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxInboundRouting * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxInboundRouting * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxInboundRouting * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetExtensions )( 
            IFaxInboundRouting * This,
            /* [retval][out] */ IFaxInboundRoutingExtensions **pFaxInboundRoutingExtensions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMethods )( 
            IFaxInboundRouting * This,
            /* [retval][out] */ IFaxInboundRoutingMethods **pFaxInboundRoutingMethods);
        
        END_INTERFACE
    } IFaxInboundRoutingVtbl;

    interface IFaxInboundRouting
    {
        CONST_VTBL struct IFaxInboundRoutingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxInboundRouting_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxInboundRouting_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxInboundRouting_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxInboundRouting_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxInboundRouting_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxInboundRouting_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxInboundRouting_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxInboundRouting_GetExtensions(This,pFaxInboundRoutingExtensions)	\
    (This)->lpVtbl -> GetExtensions(This,pFaxInboundRoutingExtensions)

#define IFaxInboundRouting_GetMethods(This,pFaxInboundRoutingMethods)	\
    (This)->lpVtbl -> GetMethods(This,pFaxInboundRoutingMethods)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxInboundRouting_GetExtensions_Proxy( 
    IFaxInboundRouting * This,
    /* [retval][out] */ IFaxInboundRoutingExtensions **pFaxInboundRoutingExtensions);


void __RPC_STUB IFaxInboundRouting_GetExtensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxInboundRouting_GetMethods_Proxy( 
    IFaxInboundRouting * This,
    /* [retval][out] */ IFaxInboundRoutingMethods **pFaxInboundRoutingMethods);


void __RPC_STUB IFaxInboundRouting_GetMethods_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxInboundRouting_INTERFACE_DEFINED__ */


#ifndef __IFaxFolders_INTERFACE_DEFINED__
#define __IFaxFolders_INTERFACE_DEFINED__

/* interface IFaxFolders */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxFolders;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCE3B2A8-A7AB-42BC-9D0A-3149457261A0")
    IFaxFolders : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingQueue( 
            /* [retval][out] */ IFaxOutgoingQueue **pFaxOutgoingQueue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IncomingQueue( 
            /* [retval][out] */ IFaxIncomingQueue **pFaxIncomingQueue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IncomingArchive( 
            /* [retval][out] */ IFaxIncomingArchive **pFaxIncomingArchive) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingArchive( 
            /* [retval][out] */ IFaxOutgoingArchive **pFaxOutgoingArchive) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxFoldersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxFolders * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxFolders * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxFolders * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxFolders * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxFolders * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxFolders * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxFolders * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingQueue )( 
            IFaxFolders * This,
            /* [retval][out] */ IFaxOutgoingQueue **pFaxOutgoingQueue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IncomingQueue )( 
            IFaxFolders * This,
            /* [retval][out] */ IFaxIncomingQueue **pFaxIncomingQueue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IncomingArchive )( 
            IFaxFolders * This,
            /* [retval][out] */ IFaxIncomingArchive **pFaxIncomingArchive);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingArchive )( 
            IFaxFolders * This,
            /* [retval][out] */ IFaxOutgoingArchive **pFaxOutgoingArchive);
        
        END_INTERFACE
    } IFaxFoldersVtbl;

    interface IFaxFolders
    {
        CONST_VTBL struct IFaxFoldersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxFolders_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxFolders_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxFolders_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxFolders_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxFolders_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxFolders_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxFolders_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxFolders_get_OutgoingQueue(This,pFaxOutgoingQueue)	\
    (This)->lpVtbl -> get_OutgoingQueue(This,pFaxOutgoingQueue)

#define IFaxFolders_get_IncomingQueue(This,pFaxIncomingQueue)	\
    (This)->lpVtbl -> get_IncomingQueue(This,pFaxIncomingQueue)

#define IFaxFolders_get_IncomingArchive(This,pFaxIncomingArchive)	\
    (This)->lpVtbl -> get_IncomingArchive(This,pFaxIncomingArchive)

#define IFaxFolders_get_OutgoingArchive(This,pFaxOutgoingArchive)	\
    (This)->lpVtbl -> get_OutgoingArchive(This,pFaxOutgoingArchive)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxFolders_get_OutgoingQueue_Proxy( 
    IFaxFolders * This,
    /* [retval][out] */ IFaxOutgoingQueue **pFaxOutgoingQueue);


void __RPC_STUB IFaxFolders_get_OutgoingQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxFolders_get_IncomingQueue_Proxy( 
    IFaxFolders * This,
    /* [retval][out] */ IFaxIncomingQueue **pFaxIncomingQueue);


void __RPC_STUB IFaxFolders_get_IncomingQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxFolders_get_IncomingArchive_Proxy( 
    IFaxFolders * This,
    /* [retval][out] */ IFaxIncomingArchive **pFaxIncomingArchive);


void __RPC_STUB IFaxFolders_get_IncomingArchive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxFolders_get_OutgoingArchive_Proxy( 
    IFaxFolders * This,
    /* [retval][out] */ IFaxOutgoingArchive **pFaxOutgoingArchive);


void __RPC_STUB IFaxFolders_get_OutgoingArchive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxFolders_INTERFACE_DEFINED__ */


#ifndef __IFaxLoggingOptions_INTERFACE_DEFINED__
#define __IFaxLoggingOptions_INTERFACE_DEFINED__

/* interface IFaxLoggingOptions */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxLoggingOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34E64FB9-6B31-4D32-8B27-D286C0C33606")
    IFaxLoggingOptions : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventLogging( 
            /* [retval][out] */ IFaxEventLogging **pFaxEventLogging) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ActivityLogging( 
            /* [retval][out] */ IFaxActivityLogging **pFaxActivityLogging) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxLoggingOptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxLoggingOptions * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxLoggingOptions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxLoggingOptions * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxLoggingOptions * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxLoggingOptions * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxLoggingOptions * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxLoggingOptions * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventLogging )( 
            IFaxLoggingOptions * This,
            /* [retval][out] */ IFaxEventLogging **pFaxEventLogging);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ActivityLogging )( 
            IFaxLoggingOptions * This,
            /* [retval][out] */ IFaxActivityLogging **pFaxActivityLogging);
        
        END_INTERFACE
    } IFaxLoggingOptionsVtbl;

    interface IFaxLoggingOptions
    {
        CONST_VTBL struct IFaxLoggingOptionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxLoggingOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxLoggingOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxLoggingOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxLoggingOptions_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxLoggingOptions_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxLoggingOptions_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxLoggingOptions_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxLoggingOptions_get_EventLogging(This,pFaxEventLogging)	\
    (This)->lpVtbl -> get_EventLogging(This,pFaxEventLogging)

#define IFaxLoggingOptions_get_ActivityLogging(This,pFaxActivityLogging)	\
    (This)->lpVtbl -> get_ActivityLogging(This,pFaxActivityLogging)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxLoggingOptions_get_EventLogging_Proxy( 
    IFaxLoggingOptions * This,
    /* [retval][out] */ IFaxEventLogging **pFaxEventLogging);


void __RPC_STUB IFaxLoggingOptions_get_EventLogging_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxLoggingOptions_get_ActivityLogging_Proxy( 
    IFaxLoggingOptions * This,
    /* [retval][out] */ IFaxActivityLogging **pFaxActivityLogging);


void __RPC_STUB IFaxLoggingOptions_get_ActivityLogging_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxLoggingOptions_INTERFACE_DEFINED__ */


#ifndef __IFaxActivity_INTERFACE_DEFINED__
#define __IFaxActivity_INTERFACE_DEFINED__

/* interface IFaxActivity */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxActivity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4B106F97-3DF5-40F2-BC3C-44CB8115EBDF")
    IFaxActivity : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IncomingMessages( 
            /* [retval][out] */ long *plIncomingMessages) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RoutingMessages( 
            /* [retval][out] */ long *plRoutingMessages) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingMessages( 
            /* [retval][out] */ long *plOutgoingMessages) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_QueuedMessages( 
            /* [retval][out] */ long *plQueuedMessages) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxActivityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxActivity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxActivity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxActivity * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxActivity * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxActivity * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxActivity * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxActivity * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IncomingMessages )( 
            IFaxActivity * This,
            /* [retval][out] */ long *plIncomingMessages);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RoutingMessages )( 
            IFaxActivity * This,
            /* [retval][out] */ long *plRoutingMessages);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingMessages )( 
            IFaxActivity * This,
            /* [retval][out] */ long *plOutgoingMessages);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_QueuedMessages )( 
            IFaxActivity * This,
            /* [retval][out] */ long *plQueuedMessages);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxActivity * This);
        
        END_INTERFACE
    } IFaxActivityVtbl;

    interface IFaxActivity
    {
        CONST_VTBL struct IFaxActivityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxActivity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxActivity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxActivity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxActivity_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxActivity_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxActivity_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxActivity_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxActivity_get_IncomingMessages(This,plIncomingMessages)	\
    (This)->lpVtbl -> get_IncomingMessages(This,plIncomingMessages)

#define IFaxActivity_get_RoutingMessages(This,plRoutingMessages)	\
    (This)->lpVtbl -> get_RoutingMessages(This,plRoutingMessages)

#define IFaxActivity_get_OutgoingMessages(This,plOutgoingMessages)	\
    (This)->lpVtbl -> get_OutgoingMessages(This,plOutgoingMessages)

#define IFaxActivity_get_QueuedMessages(This,plQueuedMessages)	\
    (This)->lpVtbl -> get_QueuedMessages(This,plQueuedMessages)

#define IFaxActivity_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxActivity_get_IncomingMessages_Proxy( 
    IFaxActivity * This,
    /* [retval][out] */ long *plIncomingMessages);


void __RPC_STUB IFaxActivity_get_IncomingMessages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxActivity_get_RoutingMessages_Proxy( 
    IFaxActivity * This,
    /* [retval][out] */ long *plRoutingMessages);


void __RPC_STUB IFaxActivity_get_RoutingMessages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxActivity_get_OutgoingMessages_Proxy( 
    IFaxActivity * This,
    /* [retval][out] */ long *plOutgoingMessages);


void __RPC_STUB IFaxActivity_get_OutgoingMessages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxActivity_get_QueuedMessages_Proxy( 
    IFaxActivity * This,
    /* [retval][out] */ long *plQueuedMessages);


void __RPC_STUB IFaxActivity_get_QueuedMessages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxActivity_Refresh_Proxy( 
    IFaxActivity * This);


void __RPC_STUB IFaxActivity_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxActivity_INTERFACE_DEFINED__ */


#ifndef __IFaxOutboundRouting_INTERFACE_DEFINED__
#define __IFaxOutboundRouting_INTERFACE_DEFINED__

/* interface IFaxOutboundRouting */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxOutboundRouting;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("25DC05A4-9909-41BD-A95B-7E5D1DEC1D43")
    IFaxOutboundRouting : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetGroups( 
            /* [retval][out] */ IFaxOutboundRoutingGroups **pFaxOutboundRoutingGroups) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetRules( 
            /* [retval][out] */ IFaxOutboundRoutingRules **pFaxOutboundRoutingRules) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxOutboundRoutingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxOutboundRouting * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxOutboundRouting * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxOutboundRouting * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxOutboundRouting * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxOutboundRouting * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxOutboundRouting * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxOutboundRouting * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetGroups )( 
            IFaxOutboundRouting * This,
            /* [retval][out] */ IFaxOutboundRoutingGroups **pFaxOutboundRoutingGroups);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetRules )( 
            IFaxOutboundRouting * This,
            /* [retval][out] */ IFaxOutboundRoutingRules **pFaxOutboundRoutingRules);
        
        END_INTERFACE
    } IFaxOutboundRoutingVtbl;

    interface IFaxOutboundRouting
    {
        CONST_VTBL struct IFaxOutboundRoutingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxOutboundRouting_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxOutboundRouting_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxOutboundRouting_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxOutboundRouting_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxOutboundRouting_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxOutboundRouting_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxOutboundRouting_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxOutboundRouting_GetGroups(This,pFaxOutboundRoutingGroups)	\
    (This)->lpVtbl -> GetGroups(This,pFaxOutboundRoutingGroups)

#define IFaxOutboundRouting_GetRules(This,pFaxOutboundRoutingRules)	\
    (This)->lpVtbl -> GetRules(This,pFaxOutboundRoutingRules)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRouting_GetGroups_Proxy( 
    IFaxOutboundRouting * This,
    /* [retval][out] */ IFaxOutboundRoutingGroups **pFaxOutboundRoutingGroups);


void __RPC_STUB IFaxOutboundRouting_GetGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRouting_GetRules_Proxy( 
    IFaxOutboundRouting * This,
    /* [retval][out] */ IFaxOutboundRoutingRules **pFaxOutboundRoutingRules);


void __RPC_STUB IFaxOutboundRouting_GetRules_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxOutboundRouting_INTERFACE_DEFINED__ */


#ifndef __IFaxReceiptOptions_INTERFACE_DEFINED__
#define __IFaxReceiptOptions_INTERFACE_DEFINED__

/* interface IFaxReceiptOptions */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 

typedef 
enum FAX_SMTP_AUTHENTICATION_TYPE_ENUM
    {	fsatANONYMOUS	= 0,
	fsatBASIC	= fsatANONYMOUS + 1,
	fsatNTLM	= fsatBASIC + 1
    } 	FAX_SMTP_AUTHENTICATION_TYPE_ENUM;

typedef 
enum FAX_RECEIPT_TYPE_ENUM
    {	frtNONE	= 0,
	frtMAIL	= 0x1,
	frtMSGBOX	= 0x4
    } 	FAX_RECEIPT_TYPE_ENUM;


EXTERN_C const IID IID_IFaxReceiptOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("378EFAEB-5FCB-4AFB-B2EE-E16E80614487")
    IFaxReceiptOptions : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AuthenticationType( 
            /* [retval][out] */ FAX_SMTP_AUTHENTICATION_TYPE_ENUM *pType) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AuthenticationType( 
            /* [in] */ FAX_SMTP_AUTHENTICATION_TYPE_ENUM Type) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SMTPServer( 
            /* [retval][out] */ BSTR *pbstrSMTPServer) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SMTPServer( 
            /* [in] */ BSTR bstrSMTPServer) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SMTPPort( 
            /* [retval][out] */ long *plSMTPPort) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SMTPPort( 
            /* [in] */ long lSMTPPort) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SMTPSender( 
            /* [retval][out] */ BSTR *pbstrSMTPSender) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SMTPSender( 
            /* [in] */ BSTR bstrSMTPSender) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SMTPUser( 
            /* [retval][out] */ BSTR *pbstrSMTPUser) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SMTPUser( 
            /* [in] */ BSTR bstrSMTPUser) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowedReceipts( 
            /* [retval][out] */ FAX_RECEIPT_TYPE_ENUM *pAllowedReceipts) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowedReceipts( 
            /* [in] */ FAX_RECEIPT_TYPE_ENUM AllowedReceipts) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SMTPPassword( 
            /* [retval][out] */ BSTR *pbstrSMTPPassword) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SMTPPassword( 
            /* [in] */ BSTR bstrSMTPPassword) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UseForInboundRouting( 
            /* [retval][out] */ VARIANT_BOOL *pbUseForInboundRouting) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UseForInboundRouting( 
            /* [in] */ VARIANT_BOOL bUseForInboundRouting) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxReceiptOptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxReceiptOptions * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxReceiptOptions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxReceiptOptions * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxReceiptOptions * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxReceiptOptions * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxReceiptOptions * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxReceiptOptions * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AuthenticationType )( 
            IFaxReceiptOptions * This,
            /* [retval][out] */ FAX_SMTP_AUTHENTICATION_TYPE_ENUM *pType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AuthenticationType )( 
            IFaxReceiptOptions * This,
            /* [in] */ FAX_SMTP_AUTHENTICATION_TYPE_ENUM Type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SMTPServer )( 
            IFaxReceiptOptions * This,
            /* [retval][out] */ BSTR *pbstrSMTPServer);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SMTPServer )( 
            IFaxReceiptOptions * This,
            /* [in] */ BSTR bstrSMTPServer);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SMTPPort )( 
            IFaxReceiptOptions * This,
            /* [retval][out] */ long *plSMTPPort);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SMTPPort )( 
            IFaxReceiptOptions * This,
            /* [in] */ long lSMTPPort);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SMTPSender )( 
            IFaxReceiptOptions * This,
            /* [retval][out] */ BSTR *pbstrSMTPSender);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SMTPSender )( 
            IFaxReceiptOptions * This,
            /* [in] */ BSTR bstrSMTPSender);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SMTPUser )( 
            IFaxReceiptOptions * This,
            /* [retval][out] */ BSTR *pbstrSMTPUser);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SMTPUser )( 
            IFaxReceiptOptions * This,
            /* [in] */ BSTR bstrSMTPUser);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowedReceipts )( 
            IFaxReceiptOptions * This,
            /* [retval][out] */ FAX_RECEIPT_TYPE_ENUM *pAllowedReceipts);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowedReceipts )( 
            IFaxReceiptOptions * This,
            /* [in] */ FAX_RECEIPT_TYPE_ENUM AllowedReceipts);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SMTPPassword )( 
            IFaxReceiptOptions * This,
            /* [retval][out] */ BSTR *pbstrSMTPPassword);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SMTPPassword )( 
            IFaxReceiptOptions * This,
            /* [in] */ BSTR bstrSMTPPassword);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxReceiptOptions * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IFaxReceiptOptions * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseForInboundRouting )( 
            IFaxReceiptOptions * This,
            /* [retval][out] */ VARIANT_BOOL *pbUseForInboundRouting);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseForInboundRouting )( 
            IFaxReceiptOptions * This,
            /* [in] */ VARIANT_BOOL bUseForInboundRouting);
        
        END_INTERFACE
    } IFaxReceiptOptionsVtbl;

    interface IFaxReceiptOptions
    {
        CONST_VTBL struct IFaxReceiptOptionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxReceiptOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxReceiptOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxReceiptOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxReceiptOptions_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxReceiptOptions_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxReceiptOptions_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxReceiptOptions_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxReceiptOptions_get_AuthenticationType(This,pType)	\
    (This)->lpVtbl -> get_AuthenticationType(This,pType)

#define IFaxReceiptOptions_put_AuthenticationType(This,Type)	\
    (This)->lpVtbl -> put_AuthenticationType(This,Type)

#define IFaxReceiptOptions_get_SMTPServer(This,pbstrSMTPServer)	\
    (This)->lpVtbl -> get_SMTPServer(This,pbstrSMTPServer)

#define IFaxReceiptOptions_put_SMTPServer(This,bstrSMTPServer)	\
    (This)->lpVtbl -> put_SMTPServer(This,bstrSMTPServer)

#define IFaxReceiptOptions_get_SMTPPort(This,plSMTPPort)	\
    (This)->lpVtbl -> get_SMTPPort(This,plSMTPPort)

#define IFaxReceiptOptions_put_SMTPPort(This,lSMTPPort)	\
    (This)->lpVtbl -> put_SMTPPort(This,lSMTPPort)

#define IFaxReceiptOptions_get_SMTPSender(This,pbstrSMTPSender)	\
    (This)->lpVtbl -> get_SMTPSender(This,pbstrSMTPSender)

#define IFaxReceiptOptions_put_SMTPSender(This,bstrSMTPSender)	\
    (This)->lpVtbl -> put_SMTPSender(This,bstrSMTPSender)

#define IFaxReceiptOptions_get_SMTPUser(This,pbstrSMTPUser)	\
    (This)->lpVtbl -> get_SMTPUser(This,pbstrSMTPUser)

#define IFaxReceiptOptions_put_SMTPUser(This,bstrSMTPUser)	\
    (This)->lpVtbl -> put_SMTPUser(This,bstrSMTPUser)

#define IFaxReceiptOptions_get_AllowedReceipts(This,pAllowedReceipts)	\
    (This)->lpVtbl -> get_AllowedReceipts(This,pAllowedReceipts)

#define IFaxReceiptOptions_put_AllowedReceipts(This,AllowedReceipts)	\
    (This)->lpVtbl -> put_AllowedReceipts(This,AllowedReceipts)

#define IFaxReceiptOptions_get_SMTPPassword(This,pbstrSMTPPassword)	\
    (This)->lpVtbl -> get_SMTPPassword(This,pbstrSMTPPassword)

#define IFaxReceiptOptions_put_SMTPPassword(This,bstrSMTPPassword)	\
    (This)->lpVtbl -> put_SMTPPassword(This,bstrSMTPPassword)

#define IFaxReceiptOptions_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxReceiptOptions_Save(This)	\
    (This)->lpVtbl -> Save(This)

#define IFaxReceiptOptions_get_UseForInboundRouting(This,pbUseForInboundRouting)	\
    (This)->lpVtbl -> get_UseForInboundRouting(This,pbUseForInboundRouting)

#define IFaxReceiptOptions_put_UseForInboundRouting(This,bUseForInboundRouting)	\
    (This)->lpVtbl -> put_UseForInboundRouting(This,bUseForInboundRouting)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_get_AuthenticationType_Proxy( 
    IFaxReceiptOptions * This,
    /* [retval][out] */ FAX_SMTP_AUTHENTICATION_TYPE_ENUM *pType);


void __RPC_STUB IFaxReceiptOptions_get_AuthenticationType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_put_AuthenticationType_Proxy( 
    IFaxReceiptOptions * This,
    /* [in] */ FAX_SMTP_AUTHENTICATION_TYPE_ENUM Type);


void __RPC_STUB IFaxReceiptOptions_put_AuthenticationType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_get_SMTPServer_Proxy( 
    IFaxReceiptOptions * This,
    /* [retval][out] */ BSTR *pbstrSMTPServer);


void __RPC_STUB IFaxReceiptOptions_get_SMTPServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_put_SMTPServer_Proxy( 
    IFaxReceiptOptions * This,
    /* [in] */ BSTR bstrSMTPServer);


void __RPC_STUB IFaxReceiptOptions_put_SMTPServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_get_SMTPPort_Proxy( 
    IFaxReceiptOptions * This,
    /* [retval][out] */ long *plSMTPPort);


void __RPC_STUB IFaxReceiptOptions_get_SMTPPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_put_SMTPPort_Proxy( 
    IFaxReceiptOptions * This,
    /* [in] */ long lSMTPPort);


void __RPC_STUB IFaxReceiptOptions_put_SMTPPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_get_SMTPSender_Proxy( 
    IFaxReceiptOptions * This,
    /* [retval][out] */ BSTR *pbstrSMTPSender);


void __RPC_STUB IFaxReceiptOptions_get_SMTPSender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_put_SMTPSender_Proxy( 
    IFaxReceiptOptions * This,
    /* [in] */ BSTR bstrSMTPSender);


void __RPC_STUB IFaxReceiptOptions_put_SMTPSender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_get_SMTPUser_Proxy( 
    IFaxReceiptOptions * This,
    /* [retval][out] */ BSTR *pbstrSMTPUser);


void __RPC_STUB IFaxReceiptOptions_get_SMTPUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_put_SMTPUser_Proxy( 
    IFaxReceiptOptions * This,
    /* [in] */ BSTR bstrSMTPUser);


void __RPC_STUB IFaxReceiptOptions_put_SMTPUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_get_AllowedReceipts_Proxy( 
    IFaxReceiptOptions * This,
    /* [retval][out] */ FAX_RECEIPT_TYPE_ENUM *pAllowedReceipts);


void __RPC_STUB IFaxReceiptOptions_get_AllowedReceipts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_put_AllowedReceipts_Proxy( 
    IFaxReceiptOptions * This,
    /* [in] */ FAX_RECEIPT_TYPE_ENUM AllowedReceipts);


void __RPC_STUB IFaxReceiptOptions_put_AllowedReceipts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_get_SMTPPassword_Proxy( 
    IFaxReceiptOptions * This,
    /* [retval][out] */ BSTR *pbstrSMTPPassword);


void __RPC_STUB IFaxReceiptOptions_get_SMTPPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_put_SMTPPassword_Proxy( 
    IFaxReceiptOptions * This,
    /* [in] */ BSTR bstrSMTPPassword);


void __RPC_STUB IFaxReceiptOptions_put_SMTPPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_Refresh_Proxy( 
    IFaxReceiptOptions * This);


void __RPC_STUB IFaxReceiptOptions_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_Save_Proxy( 
    IFaxReceiptOptions * This);


void __RPC_STUB IFaxReceiptOptions_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_get_UseForInboundRouting_Proxy( 
    IFaxReceiptOptions * This,
    /* [retval][out] */ VARIANT_BOOL *pbUseForInboundRouting);


void __RPC_STUB IFaxReceiptOptions_get_UseForInboundRouting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_put_UseForInboundRouting_Proxy( 
    IFaxReceiptOptions * This,
    /* [in] */ VARIANT_BOOL bUseForInboundRouting);


void __RPC_STUB IFaxReceiptOptions_put_UseForInboundRouting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxReceiptOptions_INTERFACE_DEFINED__ */


#ifndef __IFaxSecurity_INTERFACE_DEFINED__
#define __IFaxSecurity_INTERFACE_DEFINED__

/* interface IFaxSecurity */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 

typedef 
enum FAX_ACCESS_RIGHTS_ENUM
    {	farSUBMIT_LOW	= 0x1,
	farSUBMIT_NORMAL	= 0x3,
	farSUBMIT_HIGH	= 0x7,
	farQUERY_JOBS	= 0x8,
	farMANAGE_JOBS	= 0x18,
	farQUERY_CONFIG	= 0x20,
	farMANAGE_CONFIG	= 0x60,
	farQUERY_IN_ARCHIVE	= 0x80,
	farMANAGE_IN_ARCHIVE	= 0x180,
	farQUERY_OUT_ARCHIVE	= 0x200,
	farMANAGE_OUT_ARCHIVE	= 0x600
    } 	FAX_ACCESS_RIGHTS_ENUM;


EXTERN_C const IID IID_IFaxSecurity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77B508C1-09C0-47A2-91EB-FCE7FDF2690E")
    IFaxSecurity : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Descriptor( 
            /* [retval][out] */ VARIANT *pvDescriptor) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Descriptor( 
            /* [in] */ VARIANT vDescriptor) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GrantedRights( 
            /* [retval][out] */ FAX_ACCESS_RIGHTS_ENUM *pGrantedRights) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxSecurityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxSecurity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxSecurity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxSecurity * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxSecurity * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxSecurity * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxSecurity * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxSecurity * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Descriptor )( 
            IFaxSecurity * This,
            /* [retval][out] */ VARIANT *pvDescriptor);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Descriptor )( 
            IFaxSecurity * This,
            /* [in] */ VARIANT vDescriptor);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GrantedRights )( 
            IFaxSecurity * This,
            /* [retval][out] */ FAX_ACCESS_RIGHTS_ENUM *pGrantedRights);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxSecurity * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IFaxSecurity * This);
        
        END_INTERFACE
    } IFaxSecurityVtbl;

    interface IFaxSecurity
    {
        CONST_VTBL struct IFaxSecurityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxSecurity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxSecurity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxSecurity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxSecurity_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxSecurity_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxSecurity_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxSecurity_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxSecurity_get_Descriptor(This,pvDescriptor)	\
    (This)->lpVtbl -> get_Descriptor(This,pvDescriptor)

#define IFaxSecurity_put_Descriptor(This,vDescriptor)	\
    (This)->lpVtbl -> put_Descriptor(This,vDescriptor)

#define IFaxSecurity_get_GrantedRights(This,pGrantedRights)	\
    (This)->lpVtbl -> get_GrantedRights(This,pGrantedRights)

#define IFaxSecurity_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxSecurity_Save(This)	\
    (This)->lpVtbl -> Save(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSecurity_get_Descriptor_Proxy( 
    IFaxSecurity * This,
    /* [retval][out] */ VARIANT *pvDescriptor);


void __RPC_STUB IFaxSecurity_get_Descriptor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSecurity_put_Descriptor_Proxy( 
    IFaxSecurity * This,
    /* [in] */ VARIANT vDescriptor);


void __RPC_STUB IFaxSecurity_put_Descriptor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSecurity_get_GrantedRights_Proxy( 
    IFaxSecurity * This,
    /* [retval][out] */ FAX_ACCESS_RIGHTS_ENUM *pGrantedRights);


void __RPC_STUB IFaxSecurity_get_GrantedRights_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxSecurity_Refresh_Proxy( 
    IFaxSecurity * This);


void __RPC_STUB IFaxSecurity_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxSecurity_Save_Proxy( 
    IFaxSecurity * This);


void __RPC_STUB IFaxSecurity_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxSecurity_INTERFACE_DEFINED__ */


#ifndef __IFaxDocument_INTERFACE_DEFINED__
#define __IFaxDocument_INTERFACE_DEFINED__

/* interface IFaxDocument */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 

typedef 
enum FAX_PRIORITY_TYPE_ENUM
    {	fptLOW	= 0,
	fptNORMAL	= fptLOW + 1,
	fptHIGH	= fptNORMAL + 1
    } 	FAX_PRIORITY_TYPE_ENUM;

typedef 
enum FAX_COVERPAGE_TYPE_ENUM
    {	fcptNONE	= 0,
	fcptLOCAL	= fcptNONE + 1,
	fcptSERVER	= fcptLOCAL + 1
    } 	FAX_COVERPAGE_TYPE_ENUM;

typedef 
enum FAX_SCHEDULE_TYPE_ENUM
    {	fstNOW	= 0,
	fstSPECIFIC_TIME	= fstNOW + 1,
	fstDISCOUNT_PERIOD	= fstSPECIFIC_TIME + 1
    } 	FAX_SCHEDULE_TYPE_ENUM;


EXTERN_C const IID IID_IFaxDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B207A246-09E3-4A4E-A7DC-FEA31D29458F")
    IFaxDocument : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Attachments( 
            /* [retval][out] */ IFaxAttachments **ppFaxAttachments) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Sender( 
            /* [retval][out] */ IFaxSender **ppFaxSender) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Recipients( 
            /* [retval][out] */ IFaxRecipients **ppFaxRecipients) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CoverPage( 
            /* [retval][out] */ BSTR *pbstrCoverPage) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CoverPage( 
            /* [in] */ BSTR bstrCoverPage) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Subject( 
            /* [retval][out] */ BSTR *pbstrSubject) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Subject( 
            /* [in] */ BSTR bstrSubject) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Note( 
            /* [retval][out] */ BSTR *pbstrNote) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Note( 
            /* [in] */ BSTR bstrNote) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ScheduleTime( 
            /* [retval][out] */ DATE *pdateScheduleTime) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ScheduleTime( 
            /* [in] */ DATE dateScheduleTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReceiptAddress( 
            /* [retval][out] */ BSTR *pbstrReceiptAddress) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ReceiptAddress( 
            /* [in] */ BSTR bstrReceiptAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DocumentName( 
            /* [retval][out] */ BSTR *pbstrDocumentName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DocumentName( 
            /* [in] */ BSTR bstrDocumentName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallHandle( 
            /* [retval][out] */ long *plCallHandle) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CallHandle( 
            /* [in] */ long lCallHandle) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CoverPageType( 
            /* [retval][out] */ FAX_COVERPAGE_TYPE_ENUM *pCoverPageType) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CoverPageType( 
            /* [in] */ FAX_COVERPAGE_TYPE_ENUM CoverPageType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ScheduleType( 
            /* [retval][out] */ FAX_SCHEDULE_TYPE_ENUM *pScheduleType) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ScheduleType( 
            /* [in] */ FAX_SCHEDULE_TYPE_ENUM ScheduleType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReceiptType( 
            /* [retval][out] */ FAX_RECEIPT_TYPE_ENUM *pReceiptType) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ReceiptType( 
            /* [in] */ FAX_RECEIPT_TYPE_ENUM ReceiptType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GroupBroadcastReceipts( 
            /* [retval][out] */ VARIANT_BOOL *pbUseGrouping) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_GroupBroadcastReceipts( 
            /* [in] */ VARIANT_BOOL bUseGrouping) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Priority( 
            /* [retval][out] */ FAX_PRIORITY_TYPE_ENUM *pPriority) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Priority( 
            /* [in] */ FAX_PRIORITY_TYPE_ENUM Priority) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TapiConnection( 
            /* [retval][out] */ IDispatch **ppTapiConnection) = 0;
        
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_TapiConnection( 
            /* [in] */ IDispatch *pTapiConnection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Submit( 
            /* [in] */ BSTR bstrFaxServerName,
            /* [retval][out] */ VARIANT *pvFaxOutgoingJobIDs) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConnectedSubmit( 
            /* [in] */ IFaxServer *pFaxServer,
            /* [retval][out] */ VARIANT *pvFaxOutgoingJobIDs) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AttachFaxToReceipt( 
            /* [retval][out] */ VARIANT_BOOL *pbAttachFax) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AttachFaxToReceipt( 
            /* [in] */ VARIANT_BOOL bAttachFax) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GeneratePreview( 
            /* [in] */ BSTR bstrFileName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxDocument * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxDocument * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxDocument * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxDocument * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxDocument * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxDocument * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxDocument * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Attachments )( 
            IFaxDocument * This,
            /* [retval][out] */ IFaxAttachments **ppFaxAttachments);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Sender )( 
            IFaxDocument * This,
            /* [retval][out] */ IFaxSender **ppFaxSender);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Recipients )( 
            IFaxDocument * This,
            /* [retval][out] */ IFaxRecipients **ppFaxRecipients);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CoverPage )( 
            IFaxDocument * This,
            /* [retval][out] */ BSTR *pbstrCoverPage);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CoverPage )( 
            IFaxDocument * This,
            /* [in] */ BSTR bstrCoverPage);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Subject )( 
            IFaxDocument * This,
            /* [retval][out] */ BSTR *pbstrSubject);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Subject )( 
            IFaxDocument * This,
            /* [in] */ BSTR bstrSubject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Note )( 
            IFaxDocument * This,
            /* [retval][out] */ BSTR *pbstrNote);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Note )( 
            IFaxDocument * This,
            /* [in] */ BSTR bstrNote);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ScheduleTime )( 
            IFaxDocument * This,
            /* [retval][out] */ DATE *pdateScheduleTime);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ScheduleTime )( 
            IFaxDocument * This,
            /* [in] */ DATE dateScheduleTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReceiptAddress )( 
            IFaxDocument * This,
            /* [retval][out] */ BSTR *pbstrReceiptAddress);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReceiptAddress )( 
            IFaxDocument * This,
            /* [in] */ BSTR bstrReceiptAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocumentName )( 
            IFaxDocument * This,
            /* [retval][out] */ BSTR *pbstrDocumentName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DocumentName )( 
            IFaxDocument * This,
            /* [in] */ BSTR bstrDocumentName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallHandle )( 
            IFaxDocument * This,
            /* [retval][out] */ long *plCallHandle);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CallHandle )( 
            IFaxDocument * This,
            /* [in] */ long lCallHandle);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CoverPageType )( 
            IFaxDocument * This,
            /* [retval][out] */ FAX_COVERPAGE_TYPE_ENUM *pCoverPageType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CoverPageType )( 
            IFaxDocument * This,
            /* [in] */ FAX_COVERPAGE_TYPE_ENUM CoverPageType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ScheduleType )( 
            IFaxDocument * This,
            /* [retval][out] */ FAX_SCHEDULE_TYPE_ENUM *pScheduleType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ScheduleType )( 
            IFaxDocument * This,
            /* [in] */ FAX_SCHEDULE_TYPE_ENUM ScheduleType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReceiptType )( 
            IFaxDocument * This,
            /* [retval][out] */ FAX_RECEIPT_TYPE_ENUM *pReceiptType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReceiptType )( 
            IFaxDocument * This,
            /* [in] */ FAX_RECEIPT_TYPE_ENUM ReceiptType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GroupBroadcastReceipts )( 
            IFaxDocument * This,
            /* [retval][out] */ VARIANT_BOOL *pbUseGrouping);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_GroupBroadcastReceipts )( 
            IFaxDocument * This,
            /* [in] */ VARIANT_BOOL bUseGrouping);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Priority )( 
            IFaxDocument * This,
            /* [retval][out] */ FAX_PRIORITY_TYPE_ENUM *pPriority);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Priority )( 
            IFaxDocument * This,
            /* [in] */ FAX_PRIORITY_TYPE_ENUM Priority);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TapiConnection )( 
            IFaxDocument * This,
            /* [retval][out] */ IDispatch **ppTapiConnection);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_TapiConnection )( 
            IFaxDocument * This,
            /* [in] */ IDispatch *pTapiConnection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Submit )( 
            IFaxDocument * This,
            /* [in] */ BSTR bstrFaxServerName,
            /* [retval][out] */ VARIANT *pvFaxOutgoingJobIDs);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ConnectedSubmit )( 
            IFaxDocument * This,
            /* [in] */ IFaxServer *pFaxServer,
            /* [retval][out] */ VARIANT *pvFaxOutgoingJobIDs);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AttachFaxToReceipt )( 
            IFaxDocument * This,
            /* [retval][out] */ VARIANT_BOOL *pbAttachFax);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AttachFaxToReceipt )( 
            IFaxDocument * This,
            /* [in] */ VARIANT_BOOL bAttachFax);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GeneratePreview )( 
            IFaxDocument * This,
            /* [in] */ BSTR bstrFileName);
        
        END_INTERFACE
    } IFaxDocumentVtbl;

    interface IFaxDocument
    {
        CONST_VTBL struct IFaxDocumentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxDocument_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxDocument_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxDocument_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxDocument_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxDocument_get_Attachments(This,ppFaxAttachments)	\
    (This)->lpVtbl -> get_Attachments(This,ppFaxAttachments)

#define IFaxDocument_get_Sender(This,ppFaxSender)	\
    (This)->lpVtbl -> get_Sender(This,ppFaxSender)

#define IFaxDocument_get_Recipients(This,ppFaxRecipients)	\
    (This)->lpVtbl -> get_Recipients(This,ppFaxRecipients)

#define IFaxDocument_get_CoverPage(This,pbstrCoverPage)	\
    (This)->lpVtbl -> get_CoverPage(This,pbstrCoverPage)

#define IFaxDocument_put_CoverPage(This,bstrCoverPage)	\
    (This)->lpVtbl -> put_CoverPage(This,bstrCoverPage)

#define IFaxDocument_get_Subject(This,pbstrSubject)	\
    (This)->lpVtbl -> get_Subject(This,pbstrSubject)

#define IFaxDocument_put_Subject(This,bstrSubject)	\
    (This)->lpVtbl -> put_Subject(This,bstrSubject)

#define IFaxDocument_get_Note(This,pbstrNote)	\
    (This)->lpVtbl -> get_Note(This,pbstrNote)

#define IFaxDocument_put_Note(This,bstrNote)	\
    (This)->lpVtbl -> put_Note(This,bstrNote)

#define IFaxDocument_get_ScheduleTime(This,pdateScheduleTime)	\
    (This)->lpVtbl -> get_ScheduleTime(This,pdateScheduleTime)

#define IFaxDocument_put_ScheduleTime(This,dateScheduleTime)	\
    (This)->lpVtbl -> put_ScheduleTime(This,dateScheduleTime)

#define IFaxDocument_get_ReceiptAddress(This,pbstrReceiptAddress)	\
    (This)->lpVtbl -> get_ReceiptAddress(This,pbstrReceiptAddress)

#define IFaxDocument_put_ReceiptAddress(This,bstrReceiptAddress)	\
    (This)->lpVtbl -> put_ReceiptAddress(This,bstrReceiptAddress)

#define IFaxDocument_get_DocumentName(This,pbstrDocumentName)	\
    (This)->lpVtbl -> get_DocumentName(This,pbstrDocumentName)

#define IFaxDocument_put_DocumentName(This,bstrDocumentName)	\
    (This)->lpVtbl -> put_DocumentName(This,bstrDocumentName)

#define IFaxDocument_get_CallHandle(This,plCallHandle)	\
    (This)->lpVtbl -> get_CallHandle(This,plCallHandle)

#define IFaxDocument_put_CallHandle(This,lCallHandle)	\
    (This)->lpVtbl -> put_CallHandle(This,lCallHandle)

#define IFaxDocument_get_CoverPageType(This,pCoverPageType)	\
    (This)->lpVtbl -> get_CoverPageType(This,pCoverPageType)

#define IFaxDocument_put_CoverPageType(This,CoverPageType)	\
    (This)->lpVtbl -> put_CoverPageType(This,CoverPageType)

#define IFaxDocument_get_ScheduleType(This,pScheduleType)	\
    (This)->lpVtbl -> get_ScheduleType(This,pScheduleType)

#define IFaxDocument_put_ScheduleType(This,ScheduleType)	\
    (This)->lpVtbl -> put_ScheduleType(This,ScheduleType)

#define IFaxDocument_get_ReceiptType(This,pReceiptType)	\
    (This)->lpVtbl -> get_ReceiptType(This,pReceiptType)

#define IFaxDocument_put_ReceiptType(This,ReceiptType)	\
    (This)->lpVtbl -> put_ReceiptType(This,ReceiptType)

#define IFaxDocument_get_GroupBroadcastReceipts(This,pbUseGrouping)	\
    (This)->lpVtbl -> get_GroupBroadcastReceipts(This,pbUseGrouping)

#define IFaxDocument_put_GroupBroadcastReceipts(This,bUseGrouping)	\
    (This)->lpVtbl -> put_GroupBroadcastReceipts(This,bUseGrouping)

#define IFaxDocument_get_Priority(This,pPriority)	\
    (This)->lpVtbl -> get_Priority(This,pPriority)

#define IFaxDocument_put_Priority(This,Priority)	\
    (This)->lpVtbl -> put_Priority(This,Priority)

#define IFaxDocument_get_TapiConnection(This,ppTapiConnection)	\
    (This)->lpVtbl -> get_TapiConnection(This,ppTapiConnection)

#define IFaxDocument_putref_TapiConnection(This,pTapiConnection)	\
    (This)->lpVtbl -> putref_TapiConnection(This,pTapiConnection)

#define IFaxDocument_Submit(This,bstrFaxServerName,pvFaxOutgoingJobIDs)	\
    (This)->lpVtbl -> Submit(This,bstrFaxServerName,pvFaxOutgoingJobIDs)

#define IFaxDocument_ConnectedSubmit(This,pFaxServer,pvFaxOutgoingJobIDs)	\
    (This)->lpVtbl -> ConnectedSubmit(This,pFaxServer,pvFaxOutgoingJobIDs)

#define IFaxDocument_get_AttachFaxToReceipt(This,pbAttachFax)	\
    (This)->lpVtbl -> get_AttachFaxToReceipt(This,pbAttachFax)

#define IFaxDocument_put_AttachFaxToReceipt(This,bAttachFax)	\
    (This)->lpVtbl -> put_AttachFaxToReceipt(This,bAttachFax)

#define IFaxDocument_GeneratePreview(This,bstrFileName)	\
    (This)->lpVtbl -> GeneratePreview(This,bstrFileName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_Attachments_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ IFaxAttachments **ppFaxAttachments);


void __RPC_STUB IFaxDocument_get_Attachments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_Sender_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ IFaxSender **ppFaxSender);


void __RPC_STUB IFaxDocument_get_Sender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_Recipients_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ IFaxRecipients **ppFaxRecipients);


void __RPC_STUB IFaxDocument_get_Recipients_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_CoverPage_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ BSTR *pbstrCoverPage);


void __RPC_STUB IFaxDocument_get_CoverPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_CoverPage_Proxy( 
    IFaxDocument * This,
    /* [in] */ BSTR bstrCoverPage);


void __RPC_STUB IFaxDocument_put_CoverPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_Subject_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ BSTR *pbstrSubject);


void __RPC_STUB IFaxDocument_get_Subject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_Subject_Proxy( 
    IFaxDocument * This,
    /* [in] */ BSTR bstrSubject);


void __RPC_STUB IFaxDocument_put_Subject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_Note_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ BSTR *pbstrNote);


void __RPC_STUB IFaxDocument_get_Note_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_Note_Proxy( 
    IFaxDocument * This,
    /* [in] */ BSTR bstrNote);


void __RPC_STUB IFaxDocument_put_Note_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_ScheduleTime_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ DATE *pdateScheduleTime);


void __RPC_STUB IFaxDocument_get_ScheduleTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_ScheduleTime_Proxy( 
    IFaxDocument * This,
    /* [in] */ DATE dateScheduleTime);


void __RPC_STUB IFaxDocument_put_ScheduleTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_ReceiptAddress_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ BSTR *pbstrReceiptAddress);


void __RPC_STUB IFaxDocument_get_ReceiptAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_ReceiptAddress_Proxy( 
    IFaxDocument * This,
    /* [in] */ BSTR bstrReceiptAddress);


void __RPC_STUB IFaxDocument_put_ReceiptAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_DocumentName_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ BSTR *pbstrDocumentName);


void __RPC_STUB IFaxDocument_get_DocumentName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_DocumentName_Proxy( 
    IFaxDocument * This,
    /* [in] */ BSTR bstrDocumentName);


void __RPC_STUB IFaxDocument_put_DocumentName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_CallHandle_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ long *plCallHandle);


void __RPC_STUB IFaxDocument_get_CallHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_CallHandle_Proxy( 
    IFaxDocument * This,
    /* [in] */ long lCallHandle);


void __RPC_STUB IFaxDocument_put_CallHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_CoverPageType_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ FAX_COVERPAGE_TYPE_ENUM *pCoverPageType);


void __RPC_STUB IFaxDocument_get_CoverPageType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_CoverPageType_Proxy( 
    IFaxDocument * This,
    /* [in] */ FAX_COVERPAGE_TYPE_ENUM CoverPageType);


void __RPC_STUB IFaxDocument_put_CoverPageType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_ScheduleType_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ FAX_SCHEDULE_TYPE_ENUM *pScheduleType);


void __RPC_STUB IFaxDocument_get_ScheduleType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_ScheduleType_Proxy( 
    IFaxDocument * This,
    /* [in] */ FAX_SCHEDULE_TYPE_ENUM ScheduleType);


void __RPC_STUB IFaxDocument_put_ScheduleType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_ReceiptType_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ FAX_RECEIPT_TYPE_ENUM *pReceiptType);


void __RPC_STUB IFaxDocument_get_ReceiptType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_ReceiptType_Proxy( 
    IFaxDocument * This,
    /* [in] */ FAX_RECEIPT_TYPE_ENUM ReceiptType);


void __RPC_STUB IFaxDocument_put_ReceiptType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_GroupBroadcastReceipts_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ VARIANT_BOOL *pbUseGrouping);


void __RPC_STUB IFaxDocument_get_GroupBroadcastReceipts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_GroupBroadcastReceipts_Proxy( 
    IFaxDocument * This,
    /* [in] */ VARIANT_BOOL bUseGrouping);


void __RPC_STUB IFaxDocument_put_GroupBroadcastReceipts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_Priority_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ FAX_PRIORITY_TYPE_ENUM *pPriority);


void __RPC_STUB IFaxDocument_get_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_Priority_Proxy( 
    IFaxDocument * This,
    /* [in] */ FAX_PRIORITY_TYPE_ENUM Priority);


void __RPC_STUB IFaxDocument_put_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_TapiConnection_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ IDispatch **ppTapiConnection);


void __RPC_STUB IFaxDocument_get_TapiConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IFaxDocument_putref_TapiConnection_Proxy( 
    IFaxDocument * This,
    /* [in] */ IDispatch *pTapiConnection);


void __RPC_STUB IFaxDocument_putref_TapiConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDocument_Submit_Proxy( 
    IFaxDocument * This,
    /* [in] */ BSTR bstrFaxServerName,
    /* [retval][out] */ VARIANT *pvFaxOutgoingJobIDs);


void __RPC_STUB IFaxDocument_Submit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDocument_ConnectedSubmit_Proxy( 
    IFaxDocument * This,
    /* [in] */ IFaxServer *pFaxServer,
    /* [retval][out] */ VARIANT *pvFaxOutgoingJobIDs);


void __RPC_STUB IFaxDocument_ConnectedSubmit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_AttachFaxToReceipt_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ VARIANT_BOOL *pbAttachFax);


void __RPC_STUB IFaxDocument_get_AttachFaxToReceipt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_AttachFaxToReceipt_Proxy( 
    IFaxDocument * This,
    /* [in] */ VARIANT_BOOL bAttachFax);


void __RPC_STUB IFaxDocument_put_AttachFaxToReceipt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDocument_GeneratePreview_Proxy( 
    IFaxDocument * This,
    /* [in] */ BSTR bstrFileName);


void __RPC_STUB IFaxDocument_GeneratePreview_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxDocument_INTERFACE_DEFINED__ */


#ifndef __IFaxAttachments_INTERFACE_DEFINED__
#define __IFaxAttachments_INTERFACE_DEFINED__

/* interface IFaxAttachments */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxAttachments;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("78E271E4-2C18-40CE-94B2-8132BB6883FD")
    IFaxAttachments : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ BSTR *pbstrAttachmentPath) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrAttachmentPath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxAttachmentsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxAttachments * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxAttachments * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxAttachments * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxAttachments * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxAttachments * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxAttachments * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxAttachments * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFaxAttachments * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxAttachments * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ BSTR *pbstrAttachmentPath);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxAttachments * This,
            /* [retval][out] */ long *plCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IFaxAttachments * This,
            /* [in] */ BSTR bstrAttachmentPath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IFaxAttachments * This,
            /* [in] */ long lIndex);
        
        END_INTERFACE
    } IFaxAttachmentsVtbl;

    interface IFaxAttachments
    {
        CONST_VTBL struct IFaxAttachmentsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxAttachments_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxAttachments_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxAttachments_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxAttachments_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxAttachments_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxAttachments_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxAttachments_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxAttachments_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#define IFaxAttachments_get_Item(This,lIndex,pbstrAttachmentPath)	\
    (This)->lpVtbl -> get_Item(This,lIndex,pbstrAttachmentPath)

#define IFaxAttachments_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define IFaxAttachments_Add(This,bstrAttachmentPath)	\
    (This)->lpVtbl -> Add(This,bstrAttachmentPath)

#define IFaxAttachments_Remove(This,lIndex)	\
    (This)->lpVtbl -> Remove(This,lIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxAttachments_get__NewEnum_Proxy( 
    IFaxAttachments * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFaxAttachments_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxAttachments_get_Item_Proxy( 
    IFaxAttachments * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ BSTR *pbstrAttachmentPath);


void __RPC_STUB IFaxAttachments_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxAttachments_get_Count_Proxy( 
    IFaxAttachments * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IFaxAttachments_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxAttachments_Add_Proxy( 
    IFaxAttachments * This,
    /* [in] */ BSTR bstrAttachmentPath);


void __RPC_STUB IFaxAttachments_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxAttachments_Remove_Proxy( 
    IFaxAttachments * This,
    /* [in] */ long lIndex);


void __RPC_STUB IFaxAttachments_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxAttachments_INTERFACE_DEFINED__ */


#ifndef __IFaxSender_INTERFACE_DEFINED__
#define __IFaxSender_INTERFACE_DEFINED__

/* interface IFaxSender */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxSender;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0D879D7D-F57A-4CC6-A6F9-3EE5D527B46A")
    IFaxSender : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BillingCode( 
            /* [retval][out] */ BSTR *pbstrBillingCode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BillingCode( 
            /* [in] */ BSTR bstrBillingCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_City( 
            /* [retval][out] */ BSTR *pbstrCity) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_City( 
            /* [in] */ BSTR bstrCity) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Company( 
            /* [retval][out] */ BSTR *pbstrCompany) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Company( 
            /* [in] */ BSTR bstrCompany) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Country( 
            /* [retval][out] */ BSTR *pbstrCountry) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Country( 
            /* [in] */ BSTR bstrCountry) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Department( 
            /* [retval][out] */ BSTR *pbstrDepartment) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Department( 
            /* [in] */ BSTR bstrDepartment) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Email( 
            /* [retval][out] */ BSTR *pbstrEmail) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Email( 
            /* [in] */ BSTR bstrEmail) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FaxNumber( 
            /* [retval][out] */ BSTR *pbstrFaxNumber) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FaxNumber( 
            /* [in] */ BSTR bstrFaxNumber) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HomePhone( 
            /* [retval][out] */ BSTR *pbstrHomePhone) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_HomePhone( 
            /* [in] */ BSTR bstrHomePhone) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pbstrName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TSID( 
            /* [retval][out] */ BSTR *pbstrTSID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_TSID( 
            /* [in] */ BSTR bstrTSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OfficePhone( 
            /* [retval][out] */ BSTR *pbstrOfficePhone) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OfficePhone( 
            /* [in] */ BSTR bstrOfficePhone) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OfficeLocation( 
            /* [retval][out] */ BSTR *pbstrOfficeLocation) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OfficeLocation( 
            /* [in] */ BSTR bstrOfficeLocation) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ BSTR *pbstrState) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_State( 
            /* [in] */ BSTR bstrState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreetAddress( 
            /* [retval][out] */ BSTR *pbstrStreetAddress) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StreetAddress( 
            /* [in] */ BSTR bstrStreetAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Title( 
            /* [retval][out] */ BSTR *pbstrTitle) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Title( 
            /* [in] */ BSTR bstrTitle) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ZipCode( 
            /* [retval][out] */ BSTR *pbstrZipCode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ZipCode( 
            /* [in] */ BSTR bstrZipCode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LoadDefaultSender( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveDefaultSender( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxSenderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxSender * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxSender * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxSender * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxSender * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxSender * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxSender * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxSender * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BillingCode )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrBillingCode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BillingCode )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrBillingCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_City )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrCity);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_City )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrCity);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Company )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrCompany);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Company )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrCompany);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Country )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrCountry);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Country )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrCountry);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Department )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrDepartment);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Department )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrDepartment);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Email )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrEmail);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Email )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrEmail);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FaxNumber )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrFaxNumber);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FaxNumber )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrFaxNumber);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HomePhone )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrHomePhone);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_HomePhone )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrHomePhone);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TSID )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrTSID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TSID )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrTSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OfficePhone )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrOfficePhone);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OfficePhone )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrOfficePhone);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OfficeLocation )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrOfficeLocation);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OfficeLocation )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrOfficeLocation);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrState);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_State )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreetAddress )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrStreetAddress);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StreetAddress )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrStreetAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrTitle);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Title )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrTitle);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ZipCode )( 
            IFaxSender * This,
            /* [retval][out] */ BSTR *pbstrZipCode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ZipCode )( 
            IFaxSender * This,
            /* [in] */ BSTR bstrZipCode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LoadDefaultSender )( 
            IFaxSender * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SaveDefaultSender )( 
            IFaxSender * This);
        
        END_INTERFACE
    } IFaxSenderVtbl;

    interface IFaxSender
    {
        CONST_VTBL struct IFaxSenderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxSender_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxSender_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxSender_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxSender_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxSender_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxSender_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxSender_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxSender_get_BillingCode(This,pbstrBillingCode)	\
    (This)->lpVtbl -> get_BillingCode(This,pbstrBillingCode)

#define IFaxSender_put_BillingCode(This,bstrBillingCode)	\
    (This)->lpVtbl -> put_BillingCode(This,bstrBillingCode)

#define IFaxSender_get_City(This,pbstrCity)	\
    (This)->lpVtbl -> get_City(This,pbstrCity)

#define IFaxSender_put_City(This,bstrCity)	\
    (This)->lpVtbl -> put_City(This,bstrCity)

#define IFaxSender_get_Company(This,pbstrCompany)	\
    (This)->lpVtbl -> get_Company(This,pbstrCompany)

#define IFaxSender_put_Company(This,bstrCompany)	\
    (This)->lpVtbl -> put_Company(This,bstrCompany)

#define IFaxSender_get_Country(This,pbstrCountry)	\
    (This)->lpVtbl -> get_Country(This,pbstrCountry)

#define IFaxSender_put_Country(This,bstrCountry)	\
    (This)->lpVtbl -> put_Country(This,bstrCountry)

#define IFaxSender_get_Department(This,pbstrDepartment)	\
    (This)->lpVtbl -> get_Department(This,pbstrDepartment)

#define IFaxSender_put_Department(This,bstrDepartment)	\
    (This)->lpVtbl -> put_Department(This,bstrDepartment)

#define IFaxSender_get_Email(This,pbstrEmail)	\
    (This)->lpVtbl -> get_Email(This,pbstrEmail)

#define IFaxSender_put_Email(This,bstrEmail)	\
    (This)->lpVtbl -> put_Email(This,bstrEmail)

#define IFaxSender_get_FaxNumber(This,pbstrFaxNumber)	\
    (This)->lpVtbl -> get_FaxNumber(This,pbstrFaxNumber)

#define IFaxSender_put_FaxNumber(This,bstrFaxNumber)	\
    (This)->lpVtbl -> put_FaxNumber(This,bstrFaxNumber)

#define IFaxSender_get_HomePhone(This,pbstrHomePhone)	\
    (This)->lpVtbl -> get_HomePhone(This,pbstrHomePhone)

#define IFaxSender_put_HomePhone(This,bstrHomePhone)	\
    (This)->lpVtbl -> put_HomePhone(This,bstrHomePhone)

#define IFaxSender_get_Name(This,pbstrName)	\
    (This)->lpVtbl -> get_Name(This,pbstrName)

#define IFaxSender_put_Name(This,bstrName)	\
    (This)->lpVtbl -> put_Name(This,bstrName)

#define IFaxSender_get_TSID(This,pbstrTSID)	\
    (This)->lpVtbl -> get_TSID(This,pbstrTSID)

#define IFaxSender_put_TSID(This,bstrTSID)	\
    (This)->lpVtbl -> put_TSID(This,bstrTSID)

#define IFaxSender_get_OfficePhone(This,pbstrOfficePhone)	\
    (This)->lpVtbl -> get_OfficePhone(This,pbstrOfficePhone)

#define IFaxSender_put_OfficePhone(This,bstrOfficePhone)	\
    (This)->lpVtbl -> put_OfficePhone(This,bstrOfficePhone)

#define IFaxSender_get_OfficeLocation(This,pbstrOfficeLocation)	\
    (This)->lpVtbl -> get_OfficeLocation(This,pbstrOfficeLocation)

#define IFaxSender_put_OfficeLocation(This,bstrOfficeLocation)	\
    (This)->lpVtbl -> put_OfficeLocation(This,bstrOfficeLocation)

#define IFaxSender_get_State(This,pbstrState)	\
    (This)->lpVtbl -> get_State(This,pbstrState)

#define IFaxSender_put_State(This,bstrState)	\
    (This)->lpVtbl -> put_State(This,bstrState)

#define IFaxSender_get_StreetAddress(This,pbstrStreetAddress)	\
    (This)->lpVtbl -> get_StreetAddress(This,pbstrStreetAddress)

#define IFaxSender_put_StreetAddress(This,bstrStreetAddress)	\
    (This)->lpVtbl -> put_StreetAddress(This,bstrStreetAddress)

#define IFaxSender_get_Title(This,pbstrTitle)	\
    (This)->lpVtbl -> get_Title(This,pbstrTitle)

#define IFaxSender_put_Title(This,bstrTitle)	\
    (This)->lpVtbl -> put_Title(This,bstrTitle)

#define IFaxSender_get_ZipCode(This,pbstrZipCode)	\
    (This)->lpVtbl -> get_ZipCode(This,pbstrZipCode)

#define IFaxSender_put_ZipCode(This,bstrZipCode)	\
    (This)->lpVtbl -> put_ZipCode(This,bstrZipCode)

#define IFaxSender_LoadDefaultSender(This)	\
    (This)->lpVtbl -> LoadDefaultSender(This)

#define IFaxSender_SaveDefaultSender(This)	\
    (This)->lpVtbl -> SaveDefaultSender(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_BillingCode_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrBillingCode);


void __RPC_STUB IFaxSender_get_BillingCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_BillingCode_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrBillingCode);


void __RPC_STUB IFaxSender_put_BillingCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_City_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrCity);


void __RPC_STUB IFaxSender_get_City_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_City_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrCity);


void __RPC_STUB IFaxSender_put_City_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_Company_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrCompany);


void __RPC_STUB IFaxSender_get_Company_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_Company_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrCompany);


void __RPC_STUB IFaxSender_put_Company_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_Country_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrCountry);


void __RPC_STUB IFaxSender_get_Country_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_Country_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrCountry);


void __RPC_STUB IFaxSender_put_Country_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_Department_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrDepartment);


void __RPC_STUB IFaxSender_get_Department_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_Department_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrDepartment);


void __RPC_STUB IFaxSender_put_Department_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_Email_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrEmail);


void __RPC_STUB IFaxSender_get_Email_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_Email_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrEmail);


void __RPC_STUB IFaxSender_put_Email_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_FaxNumber_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrFaxNumber);


void __RPC_STUB IFaxSender_get_FaxNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_FaxNumber_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrFaxNumber);


void __RPC_STUB IFaxSender_put_FaxNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_HomePhone_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrHomePhone);


void __RPC_STUB IFaxSender_get_HomePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_HomePhone_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrHomePhone);


void __RPC_STUB IFaxSender_put_HomePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_Name_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrName);


void __RPC_STUB IFaxSender_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_Name_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB IFaxSender_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_TSID_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrTSID);


void __RPC_STUB IFaxSender_get_TSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_TSID_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrTSID);


void __RPC_STUB IFaxSender_put_TSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_OfficePhone_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrOfficePhone);


void __RPC_STUB IFaxSender_get_OfficePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_OfficePhone_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrOfficePhone);


void __RPC_STUB IFaxSender_put_OfficePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_OfficeLocation_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrOfficeLocation);


void __RPC_STUB IFaxSender_get_OfficeLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_OfficeLocation_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrOfficeLocation);


void __RPC_STUB IFaxSender_put_OfficeLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_State_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrState);


void __RPC_STUB IFaxSender_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_State_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrState);


void __RPC_STUB IFaxSender_put_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_StreetAddress_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrStreetAddress);


void __RPC_STUB IFaxSender_get_StreetAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_StreetAddress_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrStreetAddress);


void __RPC_STUB IFaxSender_put_StreetAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_Title_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrTitle);


void __RPC_STUB IFaxSender_get_Title_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_Title_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrTitle);


void __RPC_STUB IFaxSender_put_Title_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSender_get_ZipCode_Proxy( 
    IFaxSender * This,
    /* [retval][out] */ BSTR *pbstrZipCode);


void __RPC_STUB IFaxSender_get_ZipCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSender_put_ZipCode_Proxy( 
    IFaxSender * This,
    /* [in] */ BSTR bstrZipCode);


void __RPC_STUB IFaxSender_put_ZipCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxSender_LoadDefaultSender_Proxy( 
    IFaxSender * This);


void __RPC_STUB IFaxSender_LoadDefaultSender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxSender_SaveDefaultSender_Proxy( 
    IFaxSender * This);


void __RPC_STUB IFaxSender_SaveDefaultSender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxSender_INTERFACE_DEFINED__ */


#ifndef __IFaxRecipient_INTERFACE_DEFINED__
#define __IFaxRecipient_INTERFACE_DEFINED__

/* interface IFaxRecipient */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxRecipient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9A3DA3A0-538D-42b6-9444-AAA57D0CE2BC")
    IFaxRecipient : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FaxNumber( 
            /* [retval][out] */ BSTR *pbstrFaxNumber) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FaxNumber( 
            /* [in] */ BSTR bstrFaxNumber) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pbstrName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR bstrName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxRecipientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxRecipient * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxRecipient * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxRecipient * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxRecipient * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxRecipient * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxRecipient * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxRecipient * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FaxNumber )( 
            IFaxRecipient * This,
            /* [retval][out] */ BSTR *pbstrFaxNumber);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FaxNumber )( 
            IFaxRecipient * This,
            /* [in] */ BSTR bstrFaxNumber);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IFaxRecipient * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            IFaxRecipient * This,
            /* [in] */ BSTR bstrName);
        
        END_INTERFACE
    } IFaxRecipientVtbl;

    interface IFaxRecipient
    {
        CONST_VTBL struct IFaxRecipientVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxRecipient_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxRecipient_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxRecipient_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxRecipient_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxRecipient_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxRecipient_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxRecipient_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxRecipient_get_FaxNumber(This,pbstrFaxNumber)	\
    (This)->lpVtbl -> get_FaxNumber(This,pbstrFaxNumber)

#define IFaxRecipient_put_FaxNumber(This,bstrFaxNumber)	\
    (This)->lpVtbl -> put_FaxNumber(This,bstrFaxNumber)

#define IFaxRecipient_get_Name(This,pbstrName)	\
    (This)->lpVtbl -> get_Name(This,pbstrName)

#define IFaxRecipient_put_Name(This,bstrName)	\
    (This)->lpVtbl -> put_Name(This,bstrName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRecipient_get_FaxNumber_Proxy( 
    IFaxRecipient * This,
    /* [retval][out] */ BSTR *pbstrFaxNumber);


void __RPC_STUB IFaxRecipient_get_FaxNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxRecipient_put_FaxNumber_Proxy( 
    IFaxRecipient * This,
    /* [in] */ BSTR bstrFaxNumber);


void __RPC_STUB IFaxRecipient_put_FaxNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRecipient_get_Name_Proxy( 
    IFaxRecipient * This,
    /* [retval][out] */ BSTR *pbstrName);


void __RPC_STUB IFaxRecipient_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxRecipient_put_Name_Proxy( 
    IFaxRecipient * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB IFaxRecipient_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxRecipient_INTERFACE_DEFINED__ */


#ifndef __IFaxRecipients_INTERFACE_DEFINED__
#define __IFaxRecipients_INTERFACE_DEFINED__

/* interface IFaxRecipients */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxRecipients;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B9C9DE5A-894E-4492-9FA3-08C627C11D5D")
    IFaxRecipients : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ IFaxRecipient **ppFaxRecipient) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrFaxNumber,
            /* [defaultvalue][in] */ BSTR bstrRecipientName,
            /* [retval][out] */ IFaxRecipient **ppFaxRecipient) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxRecipientsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxRecipients * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxRecipients * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxRecipients * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxRecipients * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxRecipients * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxRecipients * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxRecipients * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFaxRecipients * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxRecipients * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ IFaxRecipient **ppFaxRecipient);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxRecipients * This,
            /* [retval][out] */ long *plCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IFaxRecipients * This,
            /* [in] */ BSTR bstrFaxNumber,
            /* [defaultvalue][in] */ BSTR bstrRecipientName,
            /* [retval][out] */ IFaxRecipient **ppFaxRecipient);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IFaxRecipients * This,
            /* [in] */ long lIndex);
        
        END_INTERFACE
    } IFaxRecipientsVtbl;

    interface IFaxRecipients
    {
        CONST_VTBL struct IFaxRecipientsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxRecipients_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxRecipients_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxRecipients_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxRecipients_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxRecipients_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxRecipients_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxRecipients_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxRecipients_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#define IFaxRecipients_get_Item(This,lIndex,ppFaxRecipient)	\
    (This)->lpVtbl -> get_Item(This,lIndex,ppFaxRecipient)

#define IFaxRecipients_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define IFaxRecipients_Add(This,bstrFaxNumber,bstrRecipientName,ppFaxRecipient)	\
    (This)->lpVtbl -> Add(This,bstrFaxNumber,bstrRecipientName,ppFaxRecipient)

#define IFaxRecipients_Remove(This,lIndex)	\
    (This)->lpVtbl -> Remove(This,lIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxRecipients_get__NewEnum_Proxy( 
    IFaxRecipients * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFaxRecipients_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxRecipients_get_Item_Proxy( 
    IFaxRecipients * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ IFaxRecipient **ppFaxRecipient);


void __RPC_STUB IFaxRecipients_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxRecipients_get_Count_Proxy( 
    IFaxRecipients * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IFaxRecipients_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxRecipients_Add_Proxy( 
    IFaxRecipients * This,
    /* [in] */ BSTR bstrFaxNumber,
    /* [defaultvalue][in] */ BSTR bstrRecipientName,
    /* [retval][out] */ IFaxRecipient **ppFaxRecipient);


void __RPC_STUB IFaxRecipients_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxRecipients_Remove_Proxy( 
    IFaxRecipients * This,
    /* [in] */ long lIndex);


void __RPC_STUB IFaxRecipients_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxRecipients_INTERFACE_DEFINED__ */


#ifndef __IFaxIncomingArchive_INTERFACE_DEFINED__
#define __IFaxIncomingArchive_INTERFACE_DEFINED__

/* interface IFaxIncomingArchive */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxIncomingArchive;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("76062CC7-F714-4FBD-AA06-ED6E4A4B70F3")
    IFaxIncomingArchive : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UseArchive( 
            /* [retval][out] */ VARIANT_BOOL *pbUseArchive) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UseArchive( 
            /* [in] */ VARIANT_BOOL bUseArchive) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ArchiveFolder( 
            /* [retval][out] */ BSTR *pbstrArchiveFolder) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ArchiveFolder( 
            /* [in] */ BSTR bstrArchiveFolder) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SizeQuotaWarning( 
            /* [retval][out] */ VARIANT_BOOL *pbSizeQuotaWarning) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SizeQuotaWarning( 
            /* [in] */ VARIANT_BOOL bSizeQuotaWarning) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HighQuotaWaterMark( 
            /* [retval][out] */ long *plHighQuotaWaterMark) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_HighQuotaWaterMark( 
            /* [in] */ long lHighQuotaWaterMark) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LowQuotaWaterMark( 
            /* [retval][out] */ long *plLowQuotaWaterMark) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LowQuotaWaterMark( 
            /* [in] */ long lLowQuotaWaterMark) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AgeLimit( 
            /* [retval][out] */ long *plAgeLimit) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AgeLimit( 
            /* [in] */ long lAgeLimit) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SizeLow( 
            /* [retval][out] */ long *plSizeLow) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SizeHigh( 
            /* [retval][out] */ long *plSizeHigh) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMessages( 
            /* [defaultvalue][in] */ long lPrefetchSize,
            /* [retval][out] */ IFaxIncomingMessageIterator **pFaxIncomingMessageIterator) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMessage( 
            /* [in] */ BSTR bstrMessageId,
            /* [retval][out] */ IFaxIncomingMessage **pFaxIncomingMessage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxIncomingArchiveVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxIncomingArchive * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxIncomingArchive * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxIncomingArchive * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxIncomingArchive * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxIncomingArchive * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxIncomingArchive * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxIncomingArchive * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseArchive )( 
            IFaxIncomingArchive * This,
            /* [retval][out] */ VARIANT_BOOL *pbUseArchive);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseArchive )( 
            IFaxIncomingArchive * This,
            /* [in] */ VARIANT_BOOL bUseArchive);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ArchiveFolder )( 
            IFaxIncomingArchive * This,
            /* [retval][out] */ BSTR *pbstrArchiveFolder);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ArchiveFolder )( 
            IFaxIncomingArchive * This,
            /* [in] */ BSTR bstrArchiveFolder);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SizeQuotaWarning )( 
            IFaxIncomingArchive * This,
            /* [retval][out] */ VARIANT_BOOL *pbSizeQuotaWarning);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SizeQuotaWarning )( 
            IFaxIncomingArchive * This,
            /* [in] */ VARIANT_BOOL bSizeQuotaWarning);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HighQuotaWaterMark )( 
            IFaxIncomingArchive * This,
            /* [retval][out] */ long *plHighQuotaWaterMark);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_HighQuotaWaterMark )( 
            IFaxIncomingArchive * This,
            /* [in] */ long lHighQuotaWaterMark);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LowQuotaWaterMark )( 
            IFaxIncomingArchive * This,
            /* [retval][out] */ long *plLowQuotaWaterMark);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LowQuotaWaterMark )( 
            IFaxIncomingArchive * This,
            /* [in] */ long lLowQuotaWaterMark);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AgeLimit )( 
            IFaxIncomingArchive * This,
            /* [retval][out] */ long *plAgeLimit);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AgeLimit )( 
            IFaxIncomingArchive * This,
            /* [in] */ long lAgeLimit);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SizeLow )( 
            IFaxIncomingArchive * This,
            /* [retval][out] */ long *plSizeLow);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SizeHigh )( 
            IFaxIncomingArchive * This,
            /* [retval][out] */ long *plSizeHigh);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxIncomingArchive * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IFaxIncomingArchive * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMessages )( 
            IFaxIncomingArchive * This,
            /* [defaultvalue][in] */ long lPrefetchSize,
            /* [retval][out] */ IFaxIncomingMessageIterator **pFaxIncomingMessageIterator);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMessage )( 
            IFaxIncomingArchive * This,
            /* [in] */ BSTR bstrMessageId,
            /* [retval][out] */ IFaxIncomingMessage **pFaxIncomingMessage);
        
        END_INTERFACE
    } IFaxIncomingArchiveVtbl;

    interface IFaxIncomingArchive
    {
        CONST_VTBL struct IFaxIncomingArchiveVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxIncomingArchive_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxIncomingArchive_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxIncomingArchive_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxIncomingArchive_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxIncomingArchive_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxIncomingArchive_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxIncomingArchive_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxIncomingArchive_get_UseArchive(This,pbUseArchive)	\
    (This)->lpVtbl -> get_UseArchive(This,pbUseArchive)

#define IFaxIncomingArchive_put_UseArchive(This,bUseArchive)	\
    (This)->lpVtbl -> put_UseArchive(This,bUseArchive)

#define IFaxIncomingArchive_get_ArchiveFolder(This,pbstrArchiveFolder)	\
    (This)->lpVtbl -> get_ArchiveFolder(This,pbstrArchiveFolder)

#define IFaxIncomingArchive_put_ArchiveFolder(This,bstrArchiveFolder)	\
    (This)->lpVtbl -> put_ArchiveFolder(This,bstrArchiveFolder)

#define IFaxIncomingArchive_get_SizeQuotaWarning(This,pbSizeQuotaWarning)	\
    (This)->lpVtbl -> get_SizeQuotaWarning(This,pbSizeQuotaWarning)

#define IFaxIncomingArchive_put_SizeQuotaWarning(This,bSizeQuotaWarning)	\
    (This)->lpVtbl -> put_SizeQuotaWarning(This,bSizeQuotaWarning)

#define IFaxIncomingArchive_get_HighQuotaWaterMark(This,plHighQuotaWaterMark)	\
    (This)->lpVtbl -> get_HighQuotaWaterMark(This,plHighQuotaWaterMark)

#define IFaxIncomingArchive_put_HighQuotaWaterMark(This,lHighQuotaWaterMark)	\
    (This)->lpVtbl -> put_HighQuotaWaterMark(This,lHighQuotaWaterMark)

#define IFaxIncomingArchive_get_LowQuotaWaterMark(This,plLowQuotaWaterMark)	\
    (This)->lpVtbl -> get_LowQuotaWaterMark(This,plLowQuotaWaterMark)

#define IFaxIncomingArchive_put_LowQuotaWaterMark(This,lLowQuotaWaterMark)	\
    (This)->lpVtbl -> put_LowQuotaWaterMark(This,lLowQuotaWaterMark)

#define IFaxIncomingArchive_get_AgeLimit(This,plAgeLimit)	\
    (This)->lpVtbl -> get_AgeLimit(This,plAgeLimit)

#define IFaxIncomingArchive_put_AgeLimit(This,lAgeLimit)	\
    (This)->lpVtbl -> put_AgeLimit(This,lAgeLimit)

#define IFaxIncomingArchive_get_SizeLow(This,plSizeLow)	\
    (This)->lpVtbl -> get_SizeLow(This,plSizeLow)

#define IFaxIncomingArchive_get_SizeHigh(This,plSizeHigh)	\
    (This)->lpVtbl -> get_SizeHigh(This,plSizeHigh)

#define IFaxIncomingArchive_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxIncomingArchive_Save(This)	\
    (This)->lpVtbl -> Save(This)

#define IFaxIncomingArchive_GetMessages(This,lPrefetchSize,pFaxIncomingMessageIterator)	\
    (This)->lpVtbl -> GetMessages(This,lPrefetchSize,pFaxIncomingMessageIterator)

#define IFaxIncomingArchive_GetMessage(This,bstrMessageId,pFaxIncomingMessage)	\
    (This)->lpVtbl -> GetMessage(This,bstrMessageId,pFaxIncomingMessage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_get_UseArchive_Proxy( 
    IFaxIncomingArchive * This,
    /* [retval][out] */ VARIANT_BOOL *pbUseArchive);


void __RPC_STUB IFaxIncomingArchive_get_UseArchive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_put_UseArchive_Proxy( 
    IFaxIncomingArchive * This,
    /* [in] */ VARIANT_BOOL bUseArchive);


void __RPC_STUB IFaxIncomingArchive_put_UseArchive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_get_ArchiveFolder_Proxy( 
    IFaxIncomingArchive * This,
    /* [retval][out] */ BSTR *pbstrArchiveFolder);


void __RPC_STUB IFaxIncomingArchive_get_ArchiveFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_put_ArchiveFolder_Proxy( 
    IFaxIncomingArchive * This,
    /* [in] */ BSTR bstrArchiveFolder);


void __RPC_STUB IFaxIncomingArchive_put_ArchiveFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_get_SizeQuotaWarning_Proxy( 
    IFaxIncomingArchive * This,
    /* [retval][out] */ VARIANT_BOOL *pbSizeQuotaWarning);


void __RPC_STUB IFaxIncomingArchive_get_SizeQuotaWarning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_put_SizeQuotaWarning_Proxy( 
    IFaxIncomingArchive * This,
    /* [in] */ VARIANT_BOOL bSizeQuotaWarning);


void __RPC_STUB IFaxIncomingArchive_put_SizeQuotaWarning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_get_HighQuotaWaterMark_Proxy( 
    IFaxIncomingArchive * This,
    /* [retval][out] */ long *plHighQuotaWaterMark);


void __RPC_STUB IFaxIncomingArchive_get_HighQuotaWaterMark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_put_HighQuotaWaterMark_Proxy( 
    IFaxIncomingArchive * This,
    /* [in] */ long lHighQuotaWaterMark);


void __RPC_STUB IFaxIncomingArchive_put_HighQuotaWaterMark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_get_LowQuotaWaterMark_Proxy( 
    IFaxIncomingArchive * This,
    /* [retval][out] */ long *plLowQuotaWaterMark);


void __RPC_STUB IFaxIncomingArchive_get_LowQuotaWaterMark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_put_LowQuotaWaterMark_Proxy( 
    IFaxIncomingArchive * This,
    /* [in] */ long lLowQuotaWaterMark);


void __RPC_STUB IFaxIncomingArchive_put_LowQuotaWaterMark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_get_AgeLimit_Proxy( 
    IFaxIncomingArchive * This,
    /* [retval][out] */ long *plAgeLimit);


void __RPC_STUB IFaxIncomingArchive_get_AgeLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_put_AgeLimit_Proxy( 
    IFaxIncomingArchive * This,
    /* [in] */ long lAgeLimit);


void __RPC_STUB IFaxIncomingArchive_put_AgeLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_get_SizeLow_Proxy( 
    IFaxIncomingArchive * This,
    /* [retval][out] */ long *plSizeLow);


void __RPC_STUB IFaxIncomingArchive_get_SizeLow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_get_SizeHigh_Proxy( 
    IFaxIncomingArchive * This,
    /* [retval][out] */ long *plSizeHigh);


void __RPC_STUB IFaxIncomingArchive_get_SizeHigh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_Refresh_Proxy( 
    IFaxIncomingArchive * This);


void __RPC_STUB IFaxIncomingArchive_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_Save_Proxy( 
    IFaxIncomingArchive * This);


void __RPC_STUB IFaxIncomingArchive_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_GetMessages_Proxy( 
    IFaxIncomingArchive * This,
    /* [defaultvalue][in] */ long lPrefetchSize,
    /* [retval][out] */ IFaxIncomingMessageIterator **pFaxIncomingMessageIterator);


void __RPC_STUB IFaxIncomingArchive_GetMessages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingArchive_GetMessage_Proxy( 
    IFaxIncomingArchive * This,
    /* [in] */ BSTR bstrMessageId,
    /* [retval][out] */ IFaxIncomingMessage **pFaxIncomingMessage);


void __RPC_STUB IFaxIncomingArchive_GetMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxIncomingArchive_INTERFACE_DEFINED__ */


#ifndef __IFaxIncomingQueue_INTERFACE_DEFINED__
#define __IFaxIncomingQueue_INTERFACE_DEFINED__

/* interface IFaxIncomingQueue */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxIncomingQueue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("902E64EF-8FD8-4B75-9725-6014DF161545")
    IFaxIncomingQueue : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Blocked( 
            /* [retval][out] */ VARIANT_BOOL *pbBlocked) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Blocked( 
            /* [in] */ VARIANT_BOOL bBlocked) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetJobs( 
            /* [retval][out] */ IFaxIncomingJobs **pFaxIncomingJobs) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetJob( 
            /* [in] */ BSTR bstrJobId,
            /* [retval][out] */ IFaxIncomingJob **pFaxIncomingJob) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxIncomingQueueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxIncomingQueue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxIncomingQueue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxIncomingQueue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxIncomingQueue * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxIncomingQueue * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxIncomingQueue * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxIncomingQueue * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Blocked )( 
            IFaxIncomingQueue * This,
            /* [retval][out] */ VARIANT_BOOL *pbBlocked);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Blocked )( 
            IFaxIncomingQueue * This,
            /* [in] */ VARIANT_BOOL bBlocked);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxIncomingQueue * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IFaxIncomingQueue * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetJobs )( 
            IFaxIncomingQueue * This,
            /* [retval][out] */ IFaxIncomingJobs **pFaxIncomingJobs);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetJob )( 
            IFaxIncomingQueue * This,
            /* [in] */ BSTR bstrJobId,
            /* [retval][out] */ IFaxIncomingJob **pFaxIncomingJob);
        
        END_INTERFACE
    } IFaxIncomingQueueVtbl;

    interface IFaxIncomingQueue
    {
        CONST_VTBL struct IFaxIncomingQueueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxIncomingQueue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxIncomingQueue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxIncomingQueue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxIncomingQueue_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxIncomingQueue_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxIncomingQueue_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxIncomingQueue_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxIncomingQueue_get_Blocked(This,pbBlocked)	\
    (This)->lpVtbl -> get_Blocked(This,pbBlocked)

#define IFaxIncomingQueue_put_Blocked(This,bBlocked)	\
    (This)->lpVtbl -> put_Blocked(This,bBlocked)

#define IFaxIncomingQueue_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxIncomingQueue_Save(This)	\
    (This)->lpVtbl -> Save(This)

#define IFaxIncomingQueue_GetJobs(This,pFaxIncomingJobs)	\
    (This)->lpVtbl -> GetJobs(This,pFaxIncomingJobs)

#define IFaxIncomingQueue_GetJob(This,bstrJobId,pFaxIncomingJob)	\
    (This)->lpVtbl -> GetJob(This,bstrJobId,pFaxIncomingJob)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingQueue_get_Blocked_Proxy( 
    IFaxIncomingQueue * This,
    /* [retval][out] */ VARIANT_BOOL *pbBlocked);


void __RPC_STUB IFaxIncomingQueue_get_Blocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxIncomingQueue_put_Blocked_Proxy( 
    IFaxIncomingQueue * This,
    /* [in] */ VARIANT_BOOL bBlocked);


void __RPC_STUB IFaxIncomingQueue_put_Blocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingQueue_Refresh_Proxy( 
    IFaxIncomingQueue * This);


void __RPC_STUB IFaxIncomingQueue_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingQueue_Save_Proxy( 
    IFaxIncomingQueue * This);


void __RPC_STUB IFaxIncomingQueue_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingQueue_GetJobs_Proxy( 
    IFaxIncomingQueue * This,
    /* [retval][out] */ IFaxIncomingJobs **pFaxIncomingJobs);


void __RPC_STUB IFaxIncomingQueue_GetJobs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingQueue_GetJob_Proxy( 
    IFaxIncomingQueue * This,
    /* [in] */ BSTR bstrJobId,
    /* [retval][out] */ IFaxIncomingJob **pFaxIncomingJob);


void __RPC_STUB IFaxIncomingQueue_GetJob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxIncomingQueue_INTERFACE_DEFINED__ */


#ifndef __IFaxOutgoingArchive_INTERFACE_DEFINED__
#define __IFaxOutgoingArchive_INTERFACE_DEFINED__

/* interface IFaxOutgoingArchive */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxOutgoingArchive;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C9C28F40-8D80-4E53-810F-9A79919B49FD")
    IFaxOutgoingArchive : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UseArchive( 
            /* [retval][out] */ VARIANT_BOOL *pbUseArchive) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UseArchive( 
            /* [in] */ VARIANT_BOOL bUseArchive) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ArchiveFolder( 
            /* [retval][out] */ BSTR *pbstrArchiveFolder) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ArchiveFolder( 
            /* [in] */ BSTR bstrArchiveFolder) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SizeQuotaWarning( 
            /* [retval][out] */ VARIANT_BOOL *pbSizeQuotaWarning) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SizeQuotaWarning( 
            /* [in] */ VARIANT_BOOL bSizeQuotaWarning) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HighQuotaWaterMark( 
            /* [retval][out] */ long *plHighQuotaWaterMark) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_HighQuotaWaterMark( 
            /* [in] */ long lHighQuotaWaterMark) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LowQuotaWaterMark( 
            /* [retval][out] */ long *plLowQuotaWaterMark) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LowQuotaWaterMark( 
            /* [in] */ long lLowQuotaWaterMark) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AgeLimit( 
            /* [retval][out] */ long *plAgeLimit) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AgeLimit( 
            /* [in] */ long lAgeLimit) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SizeLow( 
            /* [retval][out] */ long *plSizeLow) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SizeHigh( 
            /* [retval][out] */ long *plSizeHigh) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMessages( 
            /* [defaultvalue][in] */ long lPrefetchSize,
            /* [retval][out] */ IFaxOutgoingMessageIterator **pFaxOutgoingMessageIterator) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMessage( 
            /* [in] */ BSTR bstrMessageId,
            /* [retval][out] */ IFaxOutgoingMessage **pFaxOutgoingMessage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxOutgoingArchiveVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxOutgoingArchive * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxOutgoingArchive * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxOutgoingArchive * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxOutgoingArchive * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxOutgoingArchive * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxOutgoingArchive * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxOutgoingArchive * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseArchive )( 
            IFaxOutgoingArchive * This,
            /* [retval][out] */ VARIANT_BOOL *pbUseArchive);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseArchive )( 
            IFaxOutgoingArchive * This,
            /* [in] */ VARIANT_BOOL bUseArchive);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ArchiveFolder )( 
            IFaxOutgoingArchive * This,
            /* [retval][out] */ BSTR *pbstrArchiveFolder);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ArchiveFolder )( 
            IFaxOutgoingArchive * This,
            /* [in] */ BSTR bstrArchiveFolder);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SizeQuotaWarning )( 
            IFaxOutgoingArchive * This,
            /* [retval][out] */ VARIANT_BOOL *pbSizeQuotaWarning);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SizeQuotaWarning )( 
            IFaxOutgoingArchive * This,
            /* [in] */ VARIANT_BOOL bSizeQuotaWarning);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HighQuotaWaterMark )( 
            IFaxOutgoingArchive * This,
            /* [retval][out] */ long *plHighQuotaWaterMark);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_HighQuotaWaterMark )( 
            IFaxOutgoingArchive * This,
            /* [in] */ long lHighQuotaWaterMark);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LowQuotaWaterMark )( 
            IFaxOutgoingArchive * This,
            /* [retval][out] */ long *plLowQuotaWaterMark);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LowQuotaWaterMark )( 
            IFaxOutgoingArchive * This,
            /* [in] */ long lLowQuotaWaterMark);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AgeLimit )( 
            IFaxOutgoingArchive * This,
            /* [retval][out] */ long *plAgeLimit);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AgeLimit )( 
            IFaxOutgoingArchive * This,
            /* [in] */ long lAgeLimit);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SizeLow )( 
            IFaxOutgoingArchive * This,
            /* [retval][out] */ long *plSizeLow);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SizeHigh )( 
            IFaxOutgoingArchive * This,
            /* [retval][out] */ long *plSizeHigh);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxOutgoingArchive * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IFaxOutgoingArchive * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMessages )( 
            IFaxOutgoingArchive * This,
            /* [defaultvalue][in] */ long lPrefetchSize,
            /* [retval][out] */ IFaxOutgoingMessageIterator **pFaxOutgoingMessageIterator);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMessage )( 
            IFaxOutgoingArchive * This,
            /* [in] */ BSTR bstrMessageId,
            /* [retval][out] */ IFaxOutgoingMessage **pFaxOutgoingMessage);
        
        END_INTERFACE
    } IFaxOutgoingArchiveVtbl;

    interface IFaxOutgoingArchive
    {
        CONST_VTBL struct IFaxOutgoingArchiveVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxOutgoingArchive_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxOutgoingArchive_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxOutgoingArchive_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxOutgoingArchive_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxOutgoingArchive_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxOutgoingArchive_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxOutgoingArchive_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxOutgoingArchive_get_UseArchive(This,pbUseArchive)	\
    (This)->lpVtbl -> get_UseArchive(This,pbUseArchive)

#define IFaxOutgoingArchive_put_UseArchive(This,bUseArchive)	\
    (This)->lpVtbl -> put_UseArchive(This,bUseArchive)

#define IFaxOutgoingArchive_get_ArchiveFolder(This,pbstrArchiveFolder)	\
    (This)->lpVtbl -> get_ArchiveFolder(This,pbstrArchiveFolder)

#define IFaxOutgoingArchive_put_ArchiveFolder(This,bstrArchiveFolder)	\
    (This)->lpVtbl -> put_ArchiveFolder(This,bstrArchiveFolder)

#define IFaxOutgoingArchive_get_SizeQuotaWarning(This,pbSizeQuotaWarning)	\
    (This)->lpVtbl -> get_SizeQuotaWarning(This,pbSizeQuotaWarning)

#define IFaxOutgoingArchive_put_SizeQuotaWarning(This,bSizeQuotaWarning)	\
    (This)->lpVtbl -> put_SizeQuotaWarning(This,bSizeQuotaWarning)

#define IFaxOutgoingArchive_get_HighQuotaWaterMark(This,plHighQuotaWaterMark)	\
    (This)->lpVtbl -> get_HighQuotaWaterMark(This,plHighQuotaWaterMark)

#define IFaxOutgoingArchive_put_HighQuotaWaterMark(This,lHighQuotaWaterMark)	\
    (This)->lpVtbl -> put_HighQuotaWaterMark(This,lHighQuotaWaterMark)

#define IFaxOutgoingArchive_get_LowQuotaWaterMark(This,plLowQuotaWaterMark)	\
    (This)->lpVtbl -> get_LowQuotaWaterMark(This,plLowQuotaWaterMark)

#define IFaxOutgoingArchive_put_LowQuotaWaterMark(This,lLowQuotaWaterMark)	\
    (This)->lpVtbl -> put_LowQuotaWaterMark(This,lLowQuotaWaterMark)

#define IFaxOutgoingArchive_get_AgeLimit(This,plAgeLimit)	\
    (This)->lpVtbl -> get_AgeLimit(This,plAgeLimit)

#define IFaxOutgoingArchive_put_AgeLimit(This,lAgeLimit)	\
    (This)->lpVtbl -> put_AgeLimit(This,lAgeLimit)

#define IFaxOutgoingArchive_get_SizeLow(This,plSizeLow)	\
    (This)->lpVtbl -> get_SizeLow(This,plSizeLow)

#define IFaxOutgoingArchive_get_SizeHigh(This,plSizeHigh)	\
    (This)->lpVtbl -> get_SizeHigh(This,plSizeHigh)

#define IFaxOutgoingArchive_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxOutgoingArchive_Save(This)	\
    (This)->lpVtbl -> Save(This)

#define IFaxOutgoingArchive_GetMessages(This,lPrefetchSize,pFaxOutgoingMessageIterator)	\
    (This)->lpVtbl -> GetMessages(This,lPrefetchSize,pFaxOutgoingMessageIterator)

#define IFaxOutgoingArchive_GetMessage(This,bstrMessageId,pFaxOutgoingMessage)	\
    (This)->lpVtbl -> GetMessage(This,bstrMessageId,pFaxOutgoingMessage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_get_UseArchive_Proxy( 
    IFaxOutgoingArchive * This,
    /* [retval][out] */ VARIANT_BOOL *pbUseArchive);


void __RPC_STUB IFaxOutgoingArchive_get_UseArchive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_put_UseArchive_Proxy( 
    IFaxOutgoingArchive * This,
    /* [in] */ VARIANT_BOOL bUseArchive);


void __RPC_STUB IFaxOutgoingArchive_put_UseArchive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_get_ArchiveFolder_Proxy( 
    IFaxOutgoingArchive * This,
    /* [retval][out] */ BSTR *pbstrArchiveFolder);


void __RPC_STUB IFaxOutgoingArchive_get_ArchiveFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_put_ArchiveFolder_Proxy( 
    IFaxOutgoingArchive * This,
    /* [in] */ BSTR bstrArchiveFolder);


void __RPC_STUB IFaxOutgoingArchive_put_ArchiveFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_get_SizeQuotaWarning_Proxy( 
    IFaxOutgoingArchive * This,
    /* [retval][out] */ VARIANT_BOOL *pbSizeQuotaWarning);


void __RPC_STUB IFaxOutgoingArchive_get_SizeQuotaWarning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_put_SizeQuotaWarning_Proxy( 
    IFaxOutgoingArchive * This,
    /* [in] */ VARIANT_BOOL bSizeQuotaWarning);


void __RPC_STUB IFaxOutgoingArchive_put_SizeQuotaWarning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_get_HighQuotaWaterMark_Proxy( 
    IFaxOutgoingArchive * This,
    /* [retval][out] */ long *plHighQuotaWaterMark);


void __RPC_STUB IFaxOutgoingArchive_get_HighQuotaWaterMark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_put_HighQuotaWaterMark_Proxy( 
    IFaxOutgoingArchive * This,
    /* [in] */ long lHighQuotaWaterMark);


void __RPC_STUB IFaxOutgoingArchive_put_HighQuotaWaterMark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_get_LowQuotaWaterMark_Proxy( 
    IFaxOutgoingArchive * This,
    /* [retval][out] */ long *plLowQuotaWaterMark);


void __RPC_STUB IFaxOutgoingArchive_get_LowQuotaWaterMark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_put_LowQuotaWaterMark_Proxy( 
    IFaxOutgoingArchive * This,
    /* [in] */ long lLowQuotaWaterMark);


void __RPC_STUB IFaxOutgoingArchive_put_LowQuotaWaterMark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_get_AgeLimit_Proxy( 
    IFaxOutgoingArchive * This,
    /* [retval][out] */ long *plAgeLimit);


void __RPC_STUB IFaxOutgoingArchive_get_AgeLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_put_AgeLimit_Proxy( 
    IFaxOutgoingArchive * This,
    /* [in] */ long lAgeLimit);


void __RPC_STUB IFaxOutgoingArchive_put_AgeLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_get_SizeLow_Proxy( 
    IFaxOutgoingArchive * This,
    /* [retval][out] */ long *plSizeLow);


void __RPC_STUB IFaxOutgoingArchive_get_SizeLow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_get_SizeHigh_Proxy( 
    IFaxOutgoingArchive * This,
    /* [retval][out] */ long *plSizeHigh);


void __RPC_STUB IFaxOutgoingArchive_get_SizeHigh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_Refresh_Proxy( 
    IFaxOutgoingArchive * This);


void __RPC_STUB IFaxOutgoingArchive_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_Save_Proxy( 
    IFaxOutgoingArchive * This);


void __RPC_STUB IFaxOutgoingArchive_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_GetMessages_Proxy( 
    IFaxOutgoingArchive * This,
    /* [defaultvalue][in] */ long lPrefetchSize,
    /* [retval][out] */ IFaxOutgoingMessageIterator **pFaxOutgoingMessageIterator);


void __RPC_STUB IFaxOutgoingArchive_GetMessages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingArchive_GetMessage_Proxy( 
    IFaxOutgoingArchive * This,
    /* [in] */ BSTR bstrMessageId,
    /* [retval][out] */ IFaxOutgoingMessage **pFaxOutgoingMessage);


void __RPC_STUB IFaxOutgoingArchive_GetMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxOutgoingArchive_INTERFACE_DEFINED__ */


#ifndef __IFaxOutgoingQueue_INTERFACE_DEFINED__
#define __IFaxOutgoingQueue_INTERFACE_DEFINED__

/* interface IFaxOutgoingQueue */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxOutgoingQueue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("80B1DF24-D9AC-4333-B373-487CEDC80CE5")
    IFaxOutgoingQueue : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Blocked( 
            /* [retval][out] */ VARIANT_BOOL *pbBlocked) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Blocked( 
            /* [in] */ VARIANT_BOOL bBlocked) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Paused( 
            /* [retval][out] */ VARIANT_BOOL *pbPaused) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Paused( 
            /* [in] */ VARIANT_BOOL bPaused) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowPersonalCoverPages( 
            /* [retval][out] */ VARIANT_BOOL *pbAllowPersonalCoverPages) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowPersonalCoverPages( 
            /* [in] */ VARIANT_BOOL bAllowPersonalCoverPages) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UseDeviceTSID( 
            /* [retval][out] */ VARIANT_BOOL *pbUseDeviceTSID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UseDeviceTSID( 
            /* [in] */ VARIANT_BOOL bUseDeviceTSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Retries( 
            /* [retval][out] */ long *plRetries) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Retries( 
            /* [in] */ long lRetries) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RetryDelay( 
            /* [retval][out] */ long *plRetryDelay) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RetryDelay( 
            /* [in] */ long lRetryDelay) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscountRateStart( 
            /* [retval][out] */ DATE *pdateDiscountRateStart) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DiscountRateStart( 
            /* [in] */ DATE dateDiscountRateStart) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscountRateEnd( 
            /* [retval][out] */ DATE *pdateDiscountRateEnd) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DiscountRateEnd( 
            /* [in] */ DATE dateDiscountRateEnd) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AgeLimit( 
            /* [retval][out] */ long *plAgeLimit) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AgeLimit( 
            /* [in] */ long lAgeLimit) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Branding( 
            /* [retval][out] */ VARIANT_BOOL *pbBranding) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Branding( 
            /* [in] */ VARIANT_BOOL bBranding) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetJobs( 
            /* [retval][out] */ IFaxOutgoingJobs **pFaxOutgoingJobs) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetJob( 
            /* [in] */ BSTR bstrJobId,
            /* [retval][out] */ IFaxOutgoingJob **pFaxOutgoingJob) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxOutgoingQueueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxOutgoingQueue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxOutgoingQueue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxOutgoingQueue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxOutgoingQueue * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxOutgoingQueue * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxOutgoingQueue * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxOutgoingQueue * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Blocked )( 
            IFaxOutgoingQueue * This,
            /* [retval][out] */ VARIANT_BOOL *pbBlocked);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Blocked )( 
            IFaxOutgoingQueue * This,
            /* [in] */ VARIANT_BOOL bBlocked);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Paused )( 
            IFaxOutgoingQueue * This,
            /* [retval][out] */ VARIANT_BOOL *pbPaused);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Paused )( 
            IFaxOutgoingQueue * This,
            /* [in] */ VARIANT_BOOL bPaused);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowPersonalCoverPages )( 
            IFaxOutgoingQueue * This,
            /* [retval][out] */ VARIANT_BOOL *pbAllowPersonalCoverPages);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowPersonalCoverPages )( 
            IFaxOutgoingQueue * This,
            /* [in] */ VARIANT_BOOL bAllowPersonalCoverPages);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseDeviceTSID )( 
            IFaxOutgoingQueue * This,
            /* [retval][out] */ VARIANT_BOOL *pbUseDeviceTSID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseDeviceTSID )( 
            IFaxOutgoingQueue * This,
            /* [in] */ VARIANT_BOOL bUseDeviceTSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Retries )( 
            IFaxOutgoingQueue * This,
            /* [retval][out] */ long *plRetries);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Retries )( 
            IFaxOutgoingQueue * This,
            /* [in] */ long lRetries);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RetryDelay )( 
            IFaxOutgoingQueue * This,
            /* [retval][out] */ long *plRetryDelay);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RetryDelay )( 
            IFaxOutgoingQueue * This,
            /* [in] */ long lRetryDelay);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiscountRateStart )( 
            IFaxOutgoingQueue * This,
            /* [retval][out] */ DATE *pdateDiscountRateStart);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DiscountRateStart )( 
            IFaxOutgoingQueue * This,
            /* [in] */ DATE dateDiscountRateStart);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiscountRateEnd )( 
            IFaxOutgoingQueue * This,
            /* [retval][out] */ DATE *pdateDiscountRateEnd);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DiscountRateEnd )( 
            IFaxOutgoingQueue * This,
            /* [in] */ DATE dateDiscountRateEnd);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AgeLimit )( 
            IFaxOutgoingQueue * This,
            /* [retval][out] */ long *plAgeLimit);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AgeLimit )( 
            IFaxOutgoingQueue * This,
            /* [in] */ long lAgeLimit);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Branding )( 
            IFaxOutgoingQueue * This,
            /* [retval][out] */ VARIANT_BOOL *pbBranding);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Branding )( 
            IFaxOutgoingQueue * This,
            /* [in] */ VARIANT_BOOL bBranding);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxOutgoingQueue * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IFaxOutgoingQueue * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetJobs )( 
            IFaxOutgoingQueue * This,
            /* [retval][out] */ IFaxOutgoingJobs **pFaxOutgoingJobs);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetJob )( 
            IFaxOutgoingQueue * This,
            /* [in] */ BSTR bstrJobId,
            /* [retval][out] */ IFaxOutgoingJob **pFaxOutgoingJob);
        
        END_INTERFACE
    } IFaxOutgoingQueueVtbl;

    interface IFaxOutgoingQueue
    {
        CONST_VTBL struct IFaxOutgoingQueueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxOutgoingQueue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxOutgoingQueue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxOutgoingQueue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxOutgoingQueue_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxOutgoingQueue_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxOutgoingQueue_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxOutgoingQueue_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxOutgoingQueue_get_Blocked(This,pbBlocked)	\
    (This)->lpVtbl -> get_Blocked(This,pbBlocked)

#define IFaxOutgoingQueue_put_Blocked(This,bBlocked)	\
    (This)->lpVtbl -> put_Blocked(This,bBlocked)

#define IFaxOutgoingQueue_get_Paused(This,pbPaused)	\
    (This)->lpVtbl -> get_Paused(This,pbPaused)

#define IFaxOutgoingQueue_put_Paused(This,bPaused)	\
    (This)->lpVtbl -> put_Paused(This,bPaused)

#define IFaxOutgoingQueue_get_AllowPersonalCoverPages(This,pbAllowPersonalCoverPages)	\
    (This)->lpVtbl -> get_AllowPersonalCoverPages(This,pbAllowPersonalCoverPages)

#define IFaxOutgoingQueue_put_AllowPersonalCoverPages(This,bAllowPersonalCoverPages)	\
    (This)->lpVtbl -> put_AllowPersonalCoverPages(This,bAllowPersonalCoverPages)

#define IFaxOutgoingQueue_get_UseDeviceTSID(This,pbUseDeviceTSID)	\
    (This)->lpVtbl -> get_UseDeviceTSID(This,pbUseDeviceTSID)

#define IFaxOutgoingQueue_put_UseDeviceTSID(This,bUseDeviceTSID)	\
    (This)->lpVtbl -> put_UseDeviceTSID(This,bUseDeviceTSID)

#define IFaxOutgoingQueue_get_Retries(This,plRetries)	\
    (This)->lpVtbl -> get_Retries(This,plRetries)

#define IFaxOutgoingQueue_put_Retries(This,lRetries)	\
    (This)->lpVtbl -> put_Retries(This,lRetries)

#define IFaxOutgoingQueue_get_RetryDelay(This,plRetryDelay)	\
    (This)->lpVtbl -> get_RetryDelay(This,plRetryDelay)

#define IFaxOutgoingQueue_put_RetryDelay(This,lRetryDelay)	\
    (This)->lpVtbl -> put_RetryDelay(This,lRetryDelay)

#define IFaxOutgoingQueue_get_DiscountRateStart(This,pdateDiscountRateStart)	\
    (This)->lpVtbl -> get_DiscountRateStart(This,pdateDiscountRateStart)

#define IFaxOutgoingQueue_put_DiscountRateStart(This,dateDiscountRateStart)	\
    (This)->lpVtbl -> put_DiscountRateStart(This,dateDiscountRateStart)

#define IFaxOutgoingQueue_get_DiscountRateEnd(This,pdateDiscountRateEnd)	\
    (This)->lpVtbl -> get_DiscountRateEnd(This,pdateDiscountRateEnd)

#define IFaxOutgoingQueue_put_DiscountRateEnd(This,dateDiscountRateEnd)	\
    (This)->lpVtbl -> put_DiscountRateEnd(This,dateDiscountRateEnd)

#define IFaxOutgoingQueue_get_AgeLimit(This,plAgeLimit)	\
    (This)->lpVtbl -> get_AgeLimit(This,plAgeLimit)

#define IFaxOutgoingQueue_put_AgeLimit(This,lAgeLimit)	\
    (This)->lpVtbl -> put_AgeLimit(This,lAgeLimit)

#define IFaxOutgoingQueue_get_Branding(This,pbBranding)	\
    (This)->lpVtbl -> get_Branding(This,pbBranding)

#define IFaxOutgoingQueue_put_Branding(This,bBranding)	\
    (This)->lpVtbl -> put_Branding(This,bBranding)

#define IFaxOutgoingQueue_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxOutgoingQueue_Save(This)	\
    (This)->lpVtbl -> Save(This)

#define IFaxOutgoingQueue_GetJobs(This,pFaxOutgoingJobs)	\
    (This)->lpVtbl -> GetJobs(This,pFaxOutgoingJobs)

#define IFaxOutgoingQueue_GetJob(This,bstrJobId,pFaxOutgoingJob)	\
    (This)->lpVtbl -> GetJob(This,bstrJobId,pFaxOutgoingJob)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_get_Blocked_Proxy( 
    IFaxOutgoingQueue * This,
    /* [retval][out] */ VARIANT_BOOL *pbBlocked);


void __RPC_STUB IFaxOutgoingQueue_get_Blocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_put_Blocked_Proxy( 
    IFaxOutgoingQueue * This,
    /* [in] */ VARIANT_BOOL bBlocked);


void __RPC_STUB IFaxOutgoingQueue_put_Blocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_get_Paused_Proxy( 
    IFaxOutgoingQueue * This,
    /* [retval][out] */ VARIANT_BOOL *pbPaused);


void __RPC_STUB IFaxOutgoingQueue_get_Paused_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_put_Paused_Proxy( 
    IFaxOutgoingQueue * This,
    /* [in] */ VARIANT_BOOL bPaused);


void __RPC_STUB IFaxOutgoingQueue_put_Paused_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_get_AllowPersonalCoverPages_Proxy( 
    IFaxOutgoingQueue * This,
    /* [retval][out] */ VARIANT_BOOL *pbAllowPersonalCoverPages);


void __RPC_STUB IFaxOutgoingQueue_get_AllowPersonalCoverPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_put_AllowPersonalCoverPages_Proxy( 
    IFaxOutgoingQueue * This,
    /* [in] */ VARIANT_BOOL bAllowPersonalCoverPages);


void __RPC_STUB IFaxOutgoingQueue_put_AllowPersonalCoverPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_get_UseDeviceTSID_Proxy( 
    IFaxOutgoingQueue * This,
    /* [retval][out] */ VARIANT_BOOL *pbUseDeviceTSID);


void __RPC_STUB IFaxOutgoingQueue_get_UseDeviceTSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_put_UseDeviceTSID_Proxy( 
    IFaxOutgoingQueue * This,
    /* [in] */ VARIANT_BOOL bUseDeviceTSID);


void __RPC_STUB IFaxOutgoingQueue_put_UseDeviceTSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_get_Retries_Proxy( 
    IFaxOutgoingQueue * This,
    /* [retval][out] */ long *plRetries);


void __RPC_STUB IFaxOutgoingQueue_get_Retries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_put_Retries_Proxy( 
    IFaxOutgoingQueue * This,
    /* [in] */ long lRetries);


void __RPC_STUB IFaxOutgoingQueue_put_Retries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_get_RetryDelay_Proxy( 
    IFaxOutgoingQueue * This,
    /* [retval][out] */ long *plRetryDelay);


void __RPC_STUB IFaxOutgoingQueue_get_RetryDelay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_put_RetryDelay_Proxy( 
    IFaxOutgoingQueue * This,
    /* [in] */ long lRetryDelay);


void __RPC_STUB IFaxOutgoingQueue_put_RetryDelay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_get_DiscountRateStart_Proxy( 
    IFaxOutgoingQueue * This,
    /* [retval][out] */ DATE *pdateDiscountRateStart);


void __RPC_STUB IFaxOutgoingQueue_get_DiscountRateStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_put_DiscountRateStart_Proxy( 
    IFaxOutgoingQueue * This,
    /* [in] */ DATE dateDiscountRateStart);


void __RPC_STUB IFaxOutgoingQueue_put_DiscountRateStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_get_DiscountRateEnd_Proxy( 
    IFaxOutgoingQueue * This,
    /* [retval][out] */ DATE *pdateDiscountRateEnd);


void __RPC_STUB IFaxOutgoingQueue_get_DiscountRateEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_put_DiscountRateEnd_Proxy( 
    IFaxOutgoingQueue * This,
    /* [in] */ DATE dateDiscountRateEnd);


void __RPC_STUB IFaxOutgoingQueue_put_DiscountRateEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_get_AgeLimit_Proxy( 
    IFaxOutgoingQueue * This,
    /* [retval][out] */ long *plAgeLimit);


void __RPC_STUB IFaxOutgoingQueue_get_AgeLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_put_AgeLimit_Proxy( 
    IFaxOutgoingQueue * This,
    /* [in] */ long lAgeLimit);


void __RPC_STUB IFaxOutgoingQueue_put_AgeLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_get_Branding_Proxy( 
    IFaxOutgoingQueue * This,
    /* [retval][out] */ VARIANT_BOOL *pbBranding);


void __RPC_STUB IFaxOutgoingQueue_get_Branding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_put_Branding_Proxy( 
    IFaxOutgoingQueue * This,
    /* [in] */ VARIANT_BOOL bBranding);


void __RPC_STUB IFaxOutgoingQueue_put_Branding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_Refresh_Proxy( 
    IFaxOutgoingQueue * This);


void __RPC_STUB IFaxOutgoingQueue_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_Save_Proxy( 
    IFaxOutgoingQueue * This);


void __RPC_STUB IFaxOutgoingQueue_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_GetJobs_Proxy( 
    IFaxOutgoingQueue * This,
    /* [retval][out] */ IFaxOutgoingJobs **pFaxOutgoingJobs);


void __RPC_STUB IFaxOutgoingQueue_GetJobs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingQueue_GetJob_Proxy( 
    IFaxOutgoingQueue * This,
    /* [in] */ BSTR bstrJobId,
    /* [retval][out] */ IFaxOutgoingJob **pFaxOutgoingJob);


void __RPC_STUB IFaxOutgoingQueue_GetJob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxOutgoingQueue_INTERFACE_DEFINED__ */


#ifndef __IFaxIncomingMessageIterator_INTERFACE_DEFINED__
#define __IFaxIncomingMessageIterator_INTERFACE_DEFINED__

/* interface IFaxIncomingMessageIterator */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxIncomingMessageIterator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FD73ECC4-6F06-4F52-82A8-F7BA06AE3108")
    IFaxIncomingMessageIterator : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Message( 
            /* [retval][out] */ IFaxIncomingMessage **pFaxIncomingMessage) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PrefetchSize( 
            /* [retval][out] */ long *plPrefetchSize) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PrefetchSize( 
            /* [in] */ long lPrefetchSize) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EOF( 
            /* [retval][out] */ VARIANT_BOOL *pbEOF) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveFirst( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveNext( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxIncomingMessageIteratorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxIncomingMessageIterator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxIncomingMessageIterator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxIncomingMessageIterator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxIncomingMessageIterator * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxIncomingMessageIterator * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxIncomingMessageIterator * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxIncomingMessageIterator * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Message )( 
            IFaxIncomingMessageIterator * This,
            /* [retval][out] */ IFaxIncomingMessage **pFaxIncomingMessage);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrefetchSize )( 
            IFaxIncomingMessageIterator * This,
            /* [retval][out] */ long *plPrefetchSize);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PrefetchSize )( 
            IFaxIncomingMessageIterator * This,
            /* [in] */ long lPrefetchSize);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EOF )( 
            IFaxIncomingMessageIterator * This,
            /* [retval][out] */ VARIANT_BOOL *pbEOF);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *MoveFirst )( 
            IFaxIncomingMessageIterator * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *MoveNext )( 
            IFaxIncomingMessageIterator * This);
        
        END_INTERFACE
    } IFaxIncomingMessageIteratorVtbl;

    interface IFaxIncomingMessageIterator
    {
        CONST_VTBL struct IFaxIncomingMessageIteratorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxIncomingMessageIterator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxIncomingMessageIterator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxIncomingMessageIterator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxIncomingMessageIterator_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxIncomingMessageIterator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxIncomingMessageIterator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxIncomingMessageIterator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxIncomingMessageIterator_get_Message(This,pFaxIncomingMessage)	\
    (This)->lpVtbl -> get_Message(This,pFaxIncomingMessage)

#define IFaxIncomingMessageIterator_get_PrefetchSize(This,plPrefetchSize)	\
    (This)->lpVtbl -> get_PrefetchSize(This,plPrefetchSize)

#define IFaxIncomingMessageIterator_put_PrefetchSize(This,lPrefetchSize)	\
    (This)->lpVtbl -> put_PrefetchSize(This,lPrefetchSize)

#define IFaxIncomingMessageIterator_get_EOF(This,pbEOF)	\
    (This)->lpVtbl -> get_EOF(This,pbEOF)

#define IFaxIncomingMessageIterator_MoveFirst(This)	\
    (This)->lpVtbl -> MoveFirst(This)

#define IFaxIncomingMessageIterator_MoveNext(This)	\
    (This)->lpVtbl -> MoveNext(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessageIterator_get_Message_Proxy( 
    IFaxIncomingMessageIterator * This,
    /* [retval][out] */ IFaxIncomingMessage **pFaxIncomingMessage);


void __RPC_STUB IFaxIncomingMessageIterator_get_Message_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessageIterator_get_PrefetchSize_Proxy( 
    IFaxIncomingMessageIterator * This,
    /* [retval][out] */ long *plPrefetchSize);


void __RPC_STUB IFaxIncomingMessageIterator_get_PrefetchSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessageIterator_put_PrefetchSize_Proxy( 
    IFaxIncomingMessageIterator * This,
    /* [in] */ long lPrefetchSize);


void __RPC_STUB IFaxIncomingMessageIterator_put_PrefetchSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessageIterator_get_EOF_Proxy( 
    IFaxIncomingMessageIterator * This,
    /* [retval][out] */ VARIANT_BOOL *pbEOF);


void __RPC_STUB IFaxIncomingMessageIterator_get_EOF_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessageIterator_MoveFirst_Proxy( 
    IFaxIncomingMessageIterator * This);


void __RPC_STUB IFaxIncomingMessageIterator_MoveFirst_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessageIterator_MoveNext_Proxy( 
    IFaxIncomingMessageIterator * This);


void __RPC_STUB IFaxIncomingMessageIterator_MoveNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxIncomingMessageIterator_INTERFACE_DEFINED__ */


#ifndef __IFaxIncomingMessage_INTERFACE_DEFINED__
#define __IFaxIncomingMessage_INTERFACE_DEFINED__

/* interface IFaxIncomingMessage */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxIncomingMessage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7CAB88FA-2EF9-4851-B2F3-1D148FED8447")
    IFaxIncomingMessage : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ BSTR *pbstrId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Pages( 
            /* [retval][out] */ long *plPages) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Size( 
            /* [retval][out] */ long *plSize) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceName( 
            /* [retval][out] */ BSTR *pbstrDeviceName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Retries( 
            /* [retval][out] */ long *plRetries) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransmissionStart( 
            /* [retval][out] */ DATE *pdateTransmissionStart) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransmissionEnd( 
            /* [retval][out] */ DATE *pdateTransmissionEnd) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CSID( 
            /* [retval][out] */ BSTR *pbstrCSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TSID( 
            /* [retval][out] */ BSTR *pbstrTSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallerId( 
            /* [retval][out] */ BSTR *pbstrCallerId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RoutingInformation( 
            /* [retval][out] */ BSTR *pbstrRoutingInformation) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CopyTiff( 
            /* [in] */ BSTR bstrTiffPath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxIncomingMessageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxIncomingMessage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxIncomingMessage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxIncomingMessage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxIncomingMessage * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxIncomingMessage * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxIncomingMessage * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxIncomingMessage * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            IFaxIncomingMessage * This,
            /* [retval][out] */ BSTR *pbstrId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Pages )( 
            IFaxIncomingMessage * This,
            /* [retval][out] */ long *plPages);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Size )( 
            IFaxIncomingMessage * This,
            /* [retval][out] */ long *plSize);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceName )( 
            IFaxIncomingMessage * This,
            /* [retval][out] */ BSTR *pbstrDeviceName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Retries )( 
            IFaxIncomingMessage * This,
            /* [retval][out] */ long *plRetries);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionStart )( 
            IFaxIncomingMessage * This,
            /* [retval][out] */ DATE *pdateTransmissionStart);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionEnd )( 
            IFaxIncomingMessage * This,
            /* [retval][out] */ DATE *pdateTransmissionEnd);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CSID )( 
            IFaxIncomingMessage * This,
            /* [retval][out] */ BSTR *pbstrCSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TSID )( 
            IFaxIncomingMessage * This,
            /* [retval][out] */ BSTR *pbstrTSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallerId )( 
            IFaxIncomingMessage * This,
            /* [retval][out] */ BSTR *pbstrCallerId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RoutingInformation )( 
            IFaxIncomingMessage * This,
            /* [retval][out] */ BSTR *pbstrRoutingInformation);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyTiff )( 
            IFaxIncomingMessage * This,
            /* [in] */ BSTR bstrTiffPath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IFaxIncomingMessage * This);
        
        END_INTERFACE
    } IFaxIncomingMessageVtbl;

    interface IFaxIncomingMessage
    {
        CONST_VTBL struct IFaxIncomingMessageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxIncomingMessage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxIncomingMessage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxIncomingMessage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxIncomingMessage_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxIncomingMessage_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxIncomingMessage_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxIncomingMessage_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxIncomingMessage_get_Id(This,pbstrId)	\
    (This)->lpVtbl -> get_Id(This,pbstrId)

#define IFaxIncomingMessage_get_Pages(This,plPages)	\
    (This)->lpVtbl -> get_Pages(This,plPages)

#define IFaxIncomingMessage_get_Size(This,plSize)	\
    (This)->lpVtbl -> get_Size(This,plSize)

#define IFaxIncomingMessage_get_DeviceName(This,pbstrDeviceName)	\
    (This)->lpVtbl -> get_DeviceName(This,pbstrDeviceName)

#define IFaxIncomingMessage_get_Retries(This,plRetries)	\
    (This)->lpVtbl -> get_Retries(This,plRetries)

#define IFaxIncomingMessage_get_TransmissionStart(This,pdateTransmissionStart)	\
    (This)->lpVtbl -> get_TransmissionStart(This,pdateTransmissionStart)

#define IFaxIncomingMessage_get_TransmissionEnd(This,pdateTransmissionEnd)	\
    (This)->lpVtbl -> get_TransmissionEnd(This,pdateTransmissionEnd)

#define IFaxIncomingMessage_get_CSID(This,pbstrCSID)	\
    (This)->lpVtbl -> get_CSID(This,pbstrCSID)

#define IFaxIncomingMessage_get_TSID(This,pbstrTSID)	\
    (This)->lpVtbl -> get_TSID(This,pbstrTSID)

#define IFaxIncomingMessage_get_CallerId(This,pbstrCallerId)	\
    (This)->lpVtbl -> get_CallerId(This,pbstrCallerId)

#define IFaxIncomingMessage_get_RoutingInformation(This,pbstrRoutingInformation)	\
    (This)->lpVtbl -> get_RoutingInformation(This,pbstrRoutingInformation)

#define IFaxIncomingMessage_CopyTiff(This,bstrTiffPath)	\
    (This)->lpVtbl -> CopyTiff(This,bstrTiffPath)

#define IFaxIncomingMessage_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_get_Id_Proxy( 
    IFaxIncomingMessage * This,
    /* [retval][out] */ BSTR *pbstrId);


void __RPC_STUB IFaxIncomingMessage_get_Id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_get_Pages_Proxy( 
    IFaxIncomingMessage * This,
    /* [retval][out] */ long *plPages);


void __RPC_STUB IFaxIncomingMessage_get_Pages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_get_Size_Proxy( 
    IFaxIncomingMessage * This,
    /* [retval][out] */ long *plSize);


void __RPC_STUB IFaxIncomingMessage_get_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_get_DeviceName_Proxy( 
    IFaxIncomingMessage * This,
    /* [retval][out] */ BSTR *pbstrDeviceName);


void __RPC_STUB IFaxIncomingMessage_get_DeviceName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_get_Retries_Proxy( 
    IFaxIncomingMessage * This,
    /* [retval][out] */ long *plRetries);


void __RPC_STUB IFaxIncomingMessage_get_Retries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_get_TransmissionStart_Proxy( 
    IFaxIncomingMessage * This,
    /* [retval][out] */ DATE *pdateTransmissionStart);


void __RPC_STUB IFaxIncomingMessage_get_TransmissionStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_get_TransmissionEnd_Proxy( 
    IFaxIncomingMessage * This,
    /* [retval][out] */ DATE *pdateTransmissionEnd);


void __RPC_STUB IFaxIncomingMessage_get_TransmissionEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_get_CSID_Proxy( 
    IFaxIncomingMessage * This,
    /* [retval][out] */ BSTR *pbstrCSID);


void __RPC_STUB IFaxIncomingMessage_get_CSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_get_TSID_Proxy( 
    IFaxIncomingMessage * This,
    /* [retval][out] */ BSTR *pbstrTSID);


void __RPC_STUB IFaxIncomingMessage_get_TSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_get_CallerId_Proxy( 
    IFaxIncomingMessage * This,
    /* [retval][out] */ BSTR *pbstrCallerId);


void __RPC_STUB IFaxIncomingMessage_get_CallerId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_get_RoutingInformation_Proxy( 
    IFaxIncomingMessage * This,
    /* [retval][out] */ BSTR *pbstrRoutingInformation);


void __RPC_STUB IFaxIncomingMessage_get_RoutingInformation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_CopyTiff_Proxy( 
    IFaxIncomingMessage * This,
    /* [in] */ BSTR bstrTiffPath);


void __RPC_STUB IFaxIncomingMessage_CopyTiff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingMessage_Delete_Proxy( 
    IFaxIncomingMessage * This);


void __RPC_STUB IFaxIncomingMessage_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxIncomingMessage_INTERFACE_DEFINED__ */


#ifndef __IFaxOutgoingJobs_INTERFACE_DEFINED__
#define __IFaxOutgoingJobs_INTERFACE_DEFINED__

/* interface IFaxOutgoingJobs */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxOutgoingJobs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2C56D8E6-8C2F-4573-944C-E505F8F5AEED")
    IFaxOutgoingJobs : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxOutgoingJob **pFaxOutgoingJob) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxOutgoingJobsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxOutgoingJobs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxOutgoingJobs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxOutgoingJobs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxOutgoingJobs * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxOutgoingJobs * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxOutgoingJobs * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxOutgoingJobs * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFaxOutgoingJobs * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxOutgoingJobs * This,
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxOutgoingJob **pFaxOutgoingJob);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxOutgoingJobs * This,
            /* [retval][out] */ long *plCount);
        
        END_INTERFACE
    } IFaxOutgoingJobsVtbl;

    interface IFaxOutgoingJobs
    {
        CONST_VTBL struct IFaxOutgoingJobsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxOutgoingJobs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxOutgoingJobs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxOutgoingJobs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxOutgoingJobs_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxOutgoingJobs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxOutgoingJobs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxOutgoingJobs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxOutgoingJobs_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#define IFaxOutgoingJobs_get_Item(This,vIndex,pFaxOutgoingJob)	\
    (This)->lpVtbl -> get_Item(This,vIndex,pFaxOutgoingJob)

#define IFaxOutgoingJobs_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJobs_get__NewEnum_Proxy( 
    IFaxOutgoingJobs * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFaxOutgoingJobs_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJobs_get_Item_Proxy( 
    IFaxOutgoingJobs * This,
    /* [in] */ VARIANT vIndex,
    /* [retval][out] */ IFaxOutgoingJob **pFaxOutgoingJob);


void __RPC_STUB IFaxOutgoingJobs_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJobs_get_Count_Proxy( 
    IFaxOutgoingJobs * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IFaxOutgoingJobs_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxOutgoingJobs_INTERFACE_DEFINED__ */


#ifndef __IFaxOutgoingJob_INTERFACE_DEFINED__
#define __IFaxOutgoingJob_INTERFACE_DEFINED__

/* interface IFaxOutgoingJob */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxOutgoingJob;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6356DAAD-6614-4583-BF7A-3AD67BBFC71C")
    IFaxOutgoingJob : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Subject( 
            /* [retval][out] */ BSTR *pbstrSubject) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DocumentName( 
            /* [retval][out] */ BSTR *pbstrDocumentName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Pages( 
            /* [retval][out] */ long *plPages) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Size( 
            /* [retval][out] */ long *plSize) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubmissionId( 
            /* [retval][out] */ BSTR *pbstrSubmissionId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ BSTR *pbstrId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OriginalScheduledTime( 
            /* [retval][out] */ DATE *pdateOriginalScheduledTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubmissionTime( 
            /* [retval][out] */ DATE *pdateSubmissionTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReceiptType( 
            /* [retval][out] */ FAX_RECEIPT_TYPE_ENUM *pReceiptType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Priority( 
            /* [retval][out] */ FAX_PRIORITY_TYPE_ENUM *pPriority) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Sender( 
            /* [retval][out] */ IFaxSender **ppFaxSender) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Recipient( 
            /* [retval][out] */ IFaxRecipient **ppFaxRecipient) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPage( 
            /* [retval][out] */ long *plCurrentPage) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceId( 
            /* [retval][out] */ long *plDeviceId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ FAX_JOB_STATUS_ENUM *pStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtendedStatusCode( 
            /* [retval][out] */ FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtendedStatus( 
            /* [retval][out] */ BSTR *pbstrExtendedStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AvailableOperations( 
            /* [retval][out] */ FAX_JOB_OPERATIONS_ENUM *pAvailableOperations) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Retries( 
            /* [retval][out] */ long *plRetries) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ScheduledTime( 
            /* [retval][out] */ DATE *pdateScheduledTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransmissionStart( 
            /* [retval][out] */ DATE *pdateTransmissionStart) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransmissionEnd( 
            /* [retval][out] */ DATE *pdateTransmissionEnd) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CSID( 
            /* [retval][out] */ BSTR *pbstrCSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TSID( 
            /* [retval][out] */ BSTR *pbstrTSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GroupBroadcastReceipts( 
            /* [retval][out] */ VARIANT_BOOL *pbGroupBroadcastReceipts) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Restart( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CopyTiff( 
            /* [in] */ BSTR bstrTiffPath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxOutgoingJobVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxOutgoingJob * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxOutgoingJob * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxOutgoingJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxOutgoingJob * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxOutgoingJob * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxOutgoingJob * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxOutgoingJob * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Subject )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ BSTR *pbstrSubject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocumentName )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ BSTR *pbstrDocumentName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Pages )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ long *plPages);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Size )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ long *plSize);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubmissionId )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ BSTR *pbstrSubmissionId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ BSTR *pbstrId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OriginalScheduledTime )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ DATE *pdateOriginalScheduledTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubmissionTime )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ DATE *pdateSubmissionTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReceiptType )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ FAX_RECEIPT_TYPE_ENUM *pReceiptType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Priority )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ FAX_PRIORITY_TYPE_ENUM *pPriority);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Sender )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ IFaxSender **ppFaxSender);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Recipient )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ IFaxRecipient **ppFaxRecipient);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPage )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ long *plCurrentPage);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceId )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ long *plDeviceId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ FAX_JOB_STATUS_ENUM *pStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExtendedStatusCode )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExtendedStatus )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ BSTR *pbstrExtendedStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AvailableOperations )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ FAX_JOB_OPERATIONS_ENUM *pAvailableOperations);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Retries )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ long *plRetries);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ScheduledTime )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ DATE *pdateScheduledTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionStart )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ DATE *pdateTransmissionStart);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionEnd )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ DATE *pdateTransmissionEnd);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CSID )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ BSTR *pbstrCSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TSID )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ BSTR *pbstrTSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GroupBroadcastReceipts )( 
            IFaxOutgoingJob * This,
            /* [retval][out] */ VARIANT_BOOL *pbGroupBroadcastReceipts);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IFaxOutgoingJob * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IFaxOutgoingJob * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Restart )( 
            IFaxOutgoingJob * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyTiff )( 
            IFaxOutgoingJob * This,
            /* [in] */ BSTR bstrTiffPath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxOutgoingJob * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IFaxOutgoingJob * This);
        
        END_INTERFACE
    } IFaxOutgoingJobVtbl;

    interface IFaxOutgoingJob
    {
        CONST_VTBL struct IFaxOutgoingJobVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxOutgoingJob_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxOutgoingJob_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxOutgoingJob_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxOutgoingJob_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxOutgoingJob_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxOutgoingJob_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxOutgoingJob_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxOutgoingJob_get_Subject(This,pbstrSubject)	\
    (This)->lpVtbl -> get_Subject(This,pbstrSubject)

#define IFaxOutgoingJob_get_DocumentName(This,pbstrDocumentName)	\
    (This)->lpVtbl -> get_DocumentName(This,pbstrDocumentName)

#define IFaxOutgoingJob_get_Pages(This,plPages)	\
    (This)->lpVtbl -> get_Pages(This,plPages)

#define IFaxOutgoingJob_get_Size(This,plSize)	\
    (This)->lpVtbl -> get_Size(This,plSize)

#define IFaxOutgoingJob_get_SubmissionId(This,pbstrSubmissionId)	\
    (This)->lpVtbl -> get_SubmissionId(This,pbstrSubmissionId)

#define IFaxOutgoingJob_get_Id(This,pbstrId)	\
    (This)->lpVtbl -> get_Id(This,pbstrId)

#define IFaxOutgoingJob_get_OriginalScheduledTime(This,pdateOriginalScheduledTime)	\
    (This)->lpVtbl -> get_OriginalScheduledTime(This,pdateOriginalScheduledTime)

#define IFaxOutgoingJob_get_SubmissionTime(This,pdateSubmissionTime)	\
    (This)->lpVtbl -> get_SubmissionTime(This,pdateSubmissionTime)

#define IFaxOutgoingJob_get_ReceiptType(This,pReceiptType)	\
    (This)->lpVtbl -> get_ReceiptType(This,pReceiptType)

#define IFaxOutgoingJob_get_Priority(This,pPriority)	\
    (This)->lpVtbl -> get_Priority(This,pPriority)

#define IFaxOutgoingJob_get_Sender(This,ppFaxSender)	\
    (This)->lpVtbl -> get_Sender(This,ppFaxSender)

#define IFaxOutgoingJob_get_Recipient(This,ppFaxRecipient)	\
    (This)->lpVtbl -> get_Recipient(This,ppFaxRecipient)

#define IFaxOutgoingJob_get_CurrentPage(This,plCurrentPage)	\
    (This)->lpVtbl -> get_CurrentPage(This,plCurrentPage)

#define IFaxOutgoingJob_get_DeviceId(This,plDeviceId)	\
    (This)->lpVtbl -> get_DeviceId(This,plDeviceId)

#define IFaxOutgoingJob_get_Status(This,pStatus)	\
    (This)->lpVtbl -> get_Status(This,pStatus)

#define IFaxOutgoingJob_get_ExtendedStatusCode(This,pExtendedStatusCode)	\
    (This)->lpVtbl -> get_ExtendedStatusCode(This,pExtendedStatusCode)

#define IFaxOutgoingJob_get_ExtendedStatus(This,pbstrExtendedStatus)	\
    (This)->lpVtbl -> get_ExtendedStatus(This,pbstrExtendedStatus)

#define IFaxOutgoingJob_get_AvailableOperations(This,pAvailableOperations)	\
    (This)->lpVtbl -> get_AvailableOperations(This,pAvailableOperations)

#define IFaxOutgoingJob_get_Retries(This,plRetries)	\
    (This)->lpVtbl -> get_Retries(This,plRetries)

#define IFaxOutgoingJob_get_ScheduledTime(This,pdateScheduledTime)	\
    (This)->lpVtbl -> get_ScheduledTime(This,pdateScheduledTime)

#define IFaxOutgoingJob_get_TransmissionStart(This,pdateTransmissionStart)	\
    (This)->lpVtbl -> get_TransmissionStart(This,pdateTransmissionStart)

#define IFaxOutgoingJob_get_TransmissionEnd(This,pdateTransmissionEnd)	\
    (This)->lpVtbl -> get_TransmissionEnd(This,pdateTransmissionEnd)

#define IFaxOutgoingJob_get_CSID(This,pbstrCSID)	\
    (This)->lpVtbl -> get_CSID(This,pbstrCSID)

#define IFaxOutgoingJob_get_TSID(This,pbstrTSID)	\
    (This)->lpVtbl -> get_TSID(This,pbstrTSID)

#define IFaxOutgoingJob_get_GroupBroadcastReceipts(This,pbGroupBroadcastReceipts)	\
    (This)->lpVtbl -> get_GroupBroadcastReceipts(This,pbGroupBroadcastReceipts)

#define IFaxOutgoingJob_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IFaxOutgoingJob_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#define IFaxOutgoingJob_Restart(This)	\
    (This)->lpVtbl -> Restart(This)

#define IFaxOutgoingJob_CopyTiff(This,bstrTiffPath)	\
    (This)->lpVtbl -> CopyTiff(This,bstrTiffPath)

#define IFaxOutgoingJob_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxOutgoingJob_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_Subject_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ BSTR *pbstrSubject);


void __RPC_STUB IFaxOutgoingJob_get_Subject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_DocumentName_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ BSTR *pbstrDocumentName);


void __RPC_STUB IFaxOutgoingJob_get_DocumentName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_Pages_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ long *plPages);


void __RPC_STUB IFaxOutgoingJob_get_Pages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_Size_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ long *plSize);


void __RPC_STUB IFaxOutgoingJob_get_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_SubmissionId_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ BSTR *pbstrSubmissionId);


void __RPC_STUB IFaxOutgoingJob_get_SubmissionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_Id_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ BSTR *pbstrId);


void __RPC_STUB IFaxOutgoingJob_get_Id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_OriginalScheduledTime_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ DATE *pdateOriginalScheduledTime);


void __RPC_STUB IFaxOutgoingJob_get_OriginalScheduledTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_SubmissionTime_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ DATE *pdateSubmissionTime);


void __RPC_STUB IFaxOutgoingJob_get_SubmissionTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_ReceiptType_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ FAX_RECEIPT_TYPE_ENUM *pReceiptType);


void __RPC_STUB IFaxOutgoingJob_get_ReceiptType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_Priority_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ FAX_PRIORITY_TYPE_ENUM *pPriority);


void __RPC_STUB IFaxOutgoingJob_get_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_Sender_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ IFaxSender **ppFaxSender);


void __RPC_STUB IFaxOutgoingJob_get_Sender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_Recipient_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ IFaxRecipient **ppFaxRecipient);


void __RPC_STUB IFaxOutgoingJob_get_Recipient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_CurrentPage_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ long *plCurrentPage);


void __RPC_STUB IFaxOutgoingJob_get_CurrentPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_DeviceId_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ long *plDeviceId);


void __RPC_STUB IFaxOutgoingJob_get_DeviceId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_Status_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ FAX_JOB_STATUS_ENUM *pStatus);


void __RPC_STUB IFaxOutgoingJob_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_ExtendedStatusCode_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode);


void __RPC_STUB IFaxOutgoingJob_get_ExtendedStatusCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_ExtendedStatus_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ BSTR *pbstrExtendedStatus);


void __RPC_STUB IFaxOutgoingJob_get_ExtendedStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_AvailableOperations_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ FAX_JOB_OPERATIONS_ENUM *pAvailableOperations);


void __RPC_STUB IFaxOutgoingJob_get_AvailableOperations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_Retries_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ long *plRetries);


void __RPC_STUB IFaxOutgoingJob_get_Retries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_ScheduledTime_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ DATE *pdateScheduledTime);


void __RPC_STUB IFaxOutgoingJob_get_ScheduledTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_TransmissionStart_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ DATE *pdateTransmissionStart);


void __RPC_STUB IFaxOutgoingJob_get_TransmissionStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_TransmissionEnd_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ DATE *pdateTransmissionEnd);


void __RPC_STUB IFaxOutgoingJob_get_TransmissionEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_CSID_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ BSTR *pbstrCSID);


void __RPC_STUB IFaxOutgoingJob_get_CSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_TSID_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ BSTR *pbstrTSID);


void __RPC_STUB IFaxOutgoingJob_get_TSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_get_GroupBroadcastReceipts_Proxy( 
    IFaxOutgoingJob * This,
    /* [retval][out] */ VARIANT_BOOL *pbGroupBroadcastReceipts);


void __RPC_STUB IFaxOutgoingJob_get_GroupBroadcastReceipts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_Pause_Proxy( 
    IFaxOutgoingJob * This);


void __RPC_STUB IFaxOutgoingJob_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_Resume_Proxy( 
    IFaxOutgoingJob * This);


void __RPC_STUB IFaxOutgoingJob_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_Restart_Proxy( 
    IFaxOutgoingJob * This);


void __RPC_STUB IFaxOutgoingJob_Restart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_CopyTiff_Proxy( 
    IFaxOutgoingJob * This,
    /* [in] */ BSTR bstrTiffPath);


void __RPC_STUB IFaxOutgoingJob_CopyTiff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_Refresh_Proxy( 
    IFaxOutgoingJob * This);


void __RPC_STUB IFaxOutgoingJob_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingJob_Cancel_Proxy( 
    IFaxOutgoingJob * This);


void __RPC_STUB IFaxOutgoingJob_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxOutgoingJob_INTERFACE_DEFINED__ */


#ifndef __IFaxOutgoingMessageIterator_INTERFACE_DEFINED__
#define __IFaxOutgoingMessageIterator_INTERFACE_DEFINED__

/* interface IFaxOutgoingMessageIterator */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxOutgoingMessageIterator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F5EC5D4F-B840-432F-9980-112FE42A9B7A")
    IFaxOutgoingMessageIterator : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Message( 
            /* [retval][out] */ IFaxOutgoingMessage **pFaxOutgoingMessage) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EOF( 
            /* [retval][out] */ VARIANT_BOOL *pbEOF) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PrefetchSize( 
            /* [retval][out] */ long *plPrefetchSize) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PrefetchSize( 
            /* [in] */ long lPrefetchSize) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveFirst( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveNext( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxOutgoingMessageIteratorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxOutgoingMessageIterator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxOutgoingMessageIterator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxOutgoingMessageIterator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxOutgoingMessageIterator * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxOutgoingMessageIterator * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxOutgoingMessageIterator * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxOutgoingMessageIterator * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Message )( 
            IFaxOutgoingMessageIterator * This,
            /* [retval][out] */ IFaxOutgoingMessage **pFaxOutgoingMessage);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EOF )( 
            IFaxOutgoingMessageIterator * This,
            /* [retval][out] */ VARIANT_BOOL *pbEOF);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrefetchSize )( 
            IFaxOutgoingMessageIterator * This,
            /* [retval][out] */ long *plPrefetchSize);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PrefetchSize )( 
            IFaxOutgoingMessageIterator * This,
            /* [in] */ long lPrefetchSize);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *MoveFirst )( 
            IFaxOutgoingMessageIterator * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *MoveNext )( 
            IFaxOutgoingMessageIterator * This);
        
        END_INTERFACE
    } IFaxOutgoingMessageIteratorVtbl;

    interface IFaxOutgoingMessageIterator
    {
        CONST_VTBL struct IFaxOutgoingMessageIteratorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxOutgoingMessageIterator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxOutgoingMessageIterator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxOutgoingMessageIterator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxOutgoingMessageIterator_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxOutgoingMessageIterator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxOutgoingMessageIterator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxOutgoingMessageIterator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxOutgoingMessageIterator_get_Message(This,pFaxOutgoingMessage)	\
    (This)->lpVtbl -> get_Message(This,pFaxOutgoingMessage)

#define IFaxOutgoingMessageIterator_get_EOF(This,pbEOF)	\
    (This)->lpVtbl -> get_EOF(This,pbEOF)

#define IFaxOutgoingMessageIterator_get_PrefetchSize(This,plPrefetchSize)	\
    (This)->lpVtbl -> get_PrefetchSize(This,plPrefetchSize)

#define IFaxOutgoingMessageIterator_put_PrefetchSize(This,lPrefetchSize)	\
    (This)->lpVtbl -> put_PrefetchSize(This,lPrefetchSize)

#define IFaxOutgoingMessageIterator_MoveFirst(This)	\
    (This)->lpVtbl -> MoveFirst(This)

#define IFaxOutgoingMessageIterator_MoveNext(This)	\
    (This)->lpVtbl -> MoveNext(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessageIterator_get_Message_Proxy( 
    IFaxOutgoingMessageIterator * This,
    /* [retval][out] */ IFaxOutgoingMessage **pFaxOutgoingMessage);


void __RPC_STUB IFaxOutgoingMessageIterator_get_Message_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessageIterator_get_EOF_Proxy( 
    IFaxOutgoingMessageIterator * This,
    /* [retval][out] */ VARIANT_BOOL *pbEOF);


void __RPC_STUB IFaxOutgoingMessageIterator_get_EOF_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessageIterator_get_PrefetchSize_Proxy( 
    IFaxOutgoingMessageIterator * This,
    /* [retval][out] */ long *plPrefetchSize);


void __RPC_STUB IFaxOutgoingMessageIterator_get_PrefetchSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessageIterator_put_PrefetchSize_Proxy( 
    IFaxOutgoingMessageIterator * This,
    /* [in] */ long lPrefetchSize);


void __RPC_STUB IFaxOutgoingMessageIterator_put_PrefetchSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessageIterator_MoveFirst_Proxy( 
    IFaxOutgoingMessageIterator * This);


void __RPC_STUB IFaxOutgoingMessageIterator_MoveFirst_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessageIterator_MoveNext_Proxy( 
    IFaxOutgoingMessageIterator * This);


void __RPC_STUB IFaxOutgoingMessageIterator_MoveNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxOutgoingMessageIterator_INTERFACE_DEFINED__ */


#ifndef __IFaxOutgoingMessage_INTERFACE_DEFINED__
#define __IFaxOutgoingMessage_INTERFACE_DEFINED__

/* interface IFaxOutgoingMessage */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxOutgoingMessage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F0EA35DE-CAA5-4A7C-82C7-2B60BA5F2BE2")
    IFaxOutgoingMessage : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubmissionId( 
            /* [retval][out] */ BSTR *pbstrSubmissionId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ BSTR *pbstrId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Subject( 
            /* [retval][out] */ BSTR *pbstrSubject) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DocumentName( 
            /* [retval][out] */ BSTR *pbstrDocumentName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Retries( 
            /* [retval][out] */ long *plRetries) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Pages( 
            /* [retval][out] */ long *plPages) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Size( 
            /* [retval][out] */ long *plSize) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OriginalScheduledTime( 
            /* [retval][out] */ DATE *pdateOriginalScheduledTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubmissionTime( 
            /* [retval][out] */ DATE *pdateSubmissionTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Priority( 
            /* [retval][out] */ FAX_PRIORITY_TYPE_ENUM *pPriority) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Sender( 
            /* [retval][out] */ IFaxSender **ppFaxSender) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Recipient( 
            /* [retval][out] */ IFaxRecipient **ppFaxRecipient) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceName( 
            /* [retval][out] */ BSTR *pbstrDeviceName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransmissionStart( 
            /* [retval][out] */ DATE *pdateTransmissionStart) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransmissionEnd( 
            /* [retval][out] */ DATE *pdateTransmissionEnd) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CSID( 
            /* [retval][out] */ BSTR *pbstrCSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TSID( 
            /* [retval][out] */ BSTR *pbstrTSID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CopyTiff( 
            /* [in] */ BSTR bstrTiffPath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxOutgoingMessageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxOutgoingMessage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxOutgoingMessage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxOutgoingMessage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxOutgoingMessage * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxOutgoingMessage * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxOutgoingMessage * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxOutgoingMessage * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubmissionId )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ BSTR *pbstrSubmissionId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ BSTR *pbstrId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Subject )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ BSTR *pbstrSubject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocumentName )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ BSTR *pbstrDocumentName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Retries )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ long *plRetries);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Pages )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ long *plPages);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Size )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ long *plSize);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OriginalScheduledTime )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ DATE *pdateOriginalScheduledTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubmissionTime )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ DATE *pdateSubmissionTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Priority )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ FAX_PRIORITY_TYPE_ENUM *pPriority);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Sender )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ IFaxSender **ppFaxSender);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Recipient )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ IFaxRecipient **ppFaxRecipient);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceName )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ BSTR *pbstrDeviceName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionStart )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ DATE *pdateTransmissionStart);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionEnd )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ DATE *pdateTransmissionEnd);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CSID )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ BSTR *pbstrCSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TSID )( 
            IFaxOutgoingMessage * This,
            /* [retval][out] */ BSTR *pbstrTSID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyTiff )( 
            IFaxOutgoingMessage * This,
            /* [in] */ BSTR bstrTiffPath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IFaxOutgoingMessage * This);
        
        END_INTERFACE
    } IFaxOutgoingMessageVtbl;

    interface IFaxOutgoingMessage
    {
        CONST_VTBL struct IFaxOutgoingMessageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxOutgoingMessage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxOutgoingMessage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxOutgoingMessage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxOutgoingMessage_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxOutgoingMessage_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxOutgoingMessage_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxOutgoingMessage_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxOutgoingMessage_get_SubmissionId(This,pbstrSubmissionId)	\
    (This)->lpVtbl -> get_SubmissionId(This,pbstrSubmissionId)

#define IFaxOutgoingMessage_get_Id(This,pbstrId)	\
    (This)->lpVtbl -> get_Id(This,pbstrId)

#define IFaxOutgoingMessage_get_Subject(This,pbstrSubject)	\
    (This)->lpVtbl -> get_Subject(This,pbstrSubject)

#define IFaxOutgoingMessage_get_DocumentName(This,pbstrDocumentName)	\
    (This)->lpVtbl -> get_DocumentName(This,pbstrDocumentName)

#define IFaxOutgoingMessage_get_Retries(This,plRetries)	\
    (This)->lpVtbl -> get_Retries(This,plRetries)

#define IFaxOutgoingMessage_get_Pages(This,plPages)	\
    (This)->lpVtbl -> get_Pages(This,plPages)

#define IFaxOutgoingMessage_get_Size(This,plSize)	\
    (This)->lpVtbl -> get_Size(This,plSize)

#define IFaxOutgoingMessage_get_OriginalScheduledTime(This,pdateOriginalScheduledTime)	\
    (This)->lpVtbl -> get_OriginalScheduledTime(This,pdateOriginalScheduledTime)

#define IFaxOutgoingMessage_get_SubmissionTime(This,pdateSubmissionTime)	\
    (This)->lpVtbl -> get_SubmissionTime(This,pdateSubmissionTime)

#define IFaxOutgoingMessage_get_Priority(This,pPriority)	\
    (This)->lpVtbl -> get_Priority(This,pPriority)

#define IFaxOutgoingMessage_get_Sender(This,ppFaxSender)	\
    (This)->lpVtbl -> get_Sender(This,ppFaxSender)

#define IFaxOutgoingMessage_get_Recipient(This,ppFaxRecipient)	\
    (This)->lpVtbl -> get_Recipient(This,ppFaxRecipient)

#define IFaxOutgoingMessage_get_DeviceName(This,pbstrDeviceName)	\
    (This)->lpVtbl -> get_DeviceName(This,pbstrDeviceName)

#define IFaxOutgoingMessage_get_TransmissionStart(This,pdateTransmissionStart)	\
    (This)->lpVtbl -> get_TransmissionStart(This,pdateTransmissionStart)

#define IFaxOutgoingMessage_get_TransmissionEnd(This,pdateTransmissionEnd)	\
    (This)->lpVtbl -> get_TransmissionEnd(This,pdateTransmissionEnd)

#define IFaxOutgoingMessage_get_CSID(This,pbstrCSID)	\
    (This)->lpVtbl -> get_CSID(This,pbstrCSID)

#define IFaxOutgoingMessage_get_TSID(This,pbstrTSID)	\
    (This)->lpVtbl -> get_TSID(This,pbstrTSID)

#define IFaxOutgoingMessage_CopyTiff(This,bstrTiffPath)	\
    (This)->lpVtbl -> CopyTiff(This,bstrTiffPath)

#define IFaxOutgoingMessage_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_SubmissionId_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ BSTR *pbstrSubmissionId);


void __RPC_STUB IFaxOutgoingMessage_get_SubmissionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_Id_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ BSTR *pbstrId);


void __RPC_STUB IFaxOutgoingMessage_get_Id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_Subject_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ BSTR *pbstrSubject);


void __RPC_STUB IFaxOutgoingMessage_get_Subject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_DocumentName_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ BSTR *pbstrDocumentName);


void __RPC_STUB IFaxOutgoingMessage_get_DocumentName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_Retries_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ long *plRetries);


void __RPC_STUB IFaxOutgoingMessage_get_Retries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_Pages_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ long *plPages);


void __RPC_STUB IFaxOutgoingMessage_get_Pages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_Size_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ long *plSize);


void __RPC_STUB IFaxOutgoingMessage_get_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_OriginalScheduledTime_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ DATE *pdateOriginalScheduledTime);


void __RPC_STUB IFaxOutgoingMessage_get_OriginalScheduledTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_SubmissionTime_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ DATE *pdateSubmissionTime);


void __RPC_STUB IFaxOutgoingMessage_get_SubmissionTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_Priority_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ FAX_PRIORITY_TYPE_ENUM *pPriority);


void __RPC_STUB IFaxOutgoingMessage_get_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_Sender_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ IFaxSender **ppFaxSender);


void __RPC_STUB IFaxOutgoingMessage_get_Sender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_Recipient_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ IFaxRecipient **ppFaxRecipient);


void __RPC_STUB IFaxOutgoingMessage_get_Recipient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_DeviceName_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ BSTR *pbstrDeviceName);


void __RPC_STUB IFaxOutgoingMessage_get_DeviceName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_TransmissionStart_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ DATE *pdateTransmissionStart);


void __RPC_STUB IFaxOutgoingMessage_get_TransmissionStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_TransmissionEnd_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ DATE *pdateTransmissionEnd);


void __RPC_STUB IFaxOutgoingMessage_get_TransmissionEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_CSID_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ BSTR *pbstrCSID);


void __RPC_STUB IFaxOutgoingMessage_get_CSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_get_TSID_Proxy( 
    IFaxOutgoingMessage * This,
    /* [retval][out] */ BSTR *pbstrTSID);


void __RPC_STUB IFaxOutgoingMessage_get_TSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_CopyTiff_Proxy( 
    IFaxOutgoingMessage * This,
    /* [in] */ BSTR bstrTiffPath);


void __RPC_STUB IFaxOutgoingMessage_CopyTiff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutgoingMessage_Delete_Proxy( 
    IFaxOutgoingMessage * This);


void __RPC_STUB IFaxOutgoingMessage_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxOutgoingMessage_INTERFACE_DEFINED__ */


#ifndef __IFaxIncomingJobs_INTERFACE_DEFINED__
#define __IFaxIncomingJobs_INTERFACE_DEFINED__

/* interface IFaxIncomingJobs */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxIncomingJobs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("011F04E9-4FD6-4C23-9513-B6B66BB26BE9")
    IFaxIncomingJobs : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxIncomingJob **pFaxIncomingJob) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxIncomingJobsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxIncomingJobs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxIncomingJobs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxIncomingJobs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxIncomingJobs * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxIncomingJobs * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxIncomingJobs * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxIncomingJobs * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFaxIncomingJobs * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxIncomingJobs * This,
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxIncomingJob **pFaxIncomingJob);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxIncomingJobs * This,
            /* [retval][out] */ long *plCount);
        
        END_INTERFACE
    } IFaxIncomingJobsVtbl;

    interface IFaxIncomingJobs
    {
        CONST_VTBL struct IFaxIncomingJobsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxIncomingJobs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxIncomingJobs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxIncomingJobs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxIncomingJobs_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxIncomingJobs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxIncomingJobs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxIncomingJobs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxIncomingJobs_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#define IFaxIncomingJobs_get_Item(This,vIndex,pFaxIncomingJob)	\
    (This)->lpVtbl -> get_Item(This,vIndex,pFaxIncomingJob)

#define IFaxIncomingJobs_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJobs_get__NewEnum_Proxy( 
    IFaxIncomingJobs * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFaxIncomingJobs_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJobs_get_Item_Proxy( 
    IFaxIncomingJobs * This,
    /* [in] */ VARIANT vIndex,
    /* [retval][out] */ IFaxIncomingJob **pFaxIncomingJob);


void __RPC_STUB IFaxIncomingJobs_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJobs_get_Count_Proxy( 
    IFaxIncomingJobs * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IFaxIncomingJobs_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxIncomingJobs_INTERFACE_DEFINED__ */


#ifndef __IFaxIncomingJob_INTERFACE_DEFINED__
#define __IFaxIncomingJob_INTERFACE_DEFINED__

/* interface IFaxIncomingJob */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxIncomingJob;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("207529E6-654A-4916-9F88-4D232EE8A107")
    IFaxIncomingJob : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Size( 
            /* [retval][out] */ long *plSize) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ BSTR *pbstrId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPage( 
            /* [retval][out] */ long *plCurrentPage) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceId( 
            /* [retval][out] */ long *plDeviceId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ FAX_JOB_STATUS_ENUM *pStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtendedStatusCode( 
            /* [retval][out] */ FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtendedStatus( 
            /* [retval][out] */ BSTR *pbstrExtendedStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AvailableOperations( 
            /* [retval][out] */ FAX_JOB_OPERATIONS_ENUM *pAvailableOperations) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Retries( 
            /* [retval][out] */ long *plRetries) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransmissionStart( 
            /* [retval][out] */ DATE *pdateTransmissionStart) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransmissionEnd( 
            /* [retval][out] */ DATE *pdateTransmissionEnd) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CSID( 
            /* [retval][out] */ BSTR *pbstrCSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TSID( 
            /* [retval][out] */ BSTR *pbstrTSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallerId( 
            /* [retval][out] */ BSTR *pbstrCallerId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RoutingInformation( 
            /* [retval][out] */ BSTR *pbstrRoutingInformation) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_JobType( 
            /* [retval][out] */ FAX_JOB_TYPE_ENUM *pJobType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CopyTiff( 
            /* [in] */ BSTR bstrTiffPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxIncomingJobVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxIncomingJob * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxIncomingJob * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxIncomingJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxIncomingJob * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxIncomingJob * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxIncomingJob * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxIncomingJob * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Size )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ long *plSize);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ BSTR *pbstrId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPage )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ long *plCurrentPage);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceId )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ long *plDeviceId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ FAX_JOB_STATUS_ENUM *pStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExtendedStatusCode )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExtendedStatus )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ BSTR *pbstrExtendedStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AvailableOperations )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ FAX_JOB_OPERATIONS_ENUM *pAvailableOperations);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Retries )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ long *plRetries);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionStart )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ DATE *pdateTransmissionStart);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionEnd )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ DATE *pdateTransmissionEnd);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CSID )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ BSTR *pbstrCSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TSID )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ BSTR *pbstrTSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallerId )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ BSTR *pbstrCallerId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RoutingInformation )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ BSTR *pbstrRoutingInformation);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_JobType )( 
            IFaxIncomingJob * This,
            /* [retval][out] */ FAX_JOB_TYPE_ENUM *pJobType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IFaxIncomingJob * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxIncomingJob * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyTiff )( 
            IFaxIncomingJob * This,
            /* [in] */ BSTR bstrTiffPath);
        
        END_INTERFACE
    } IFaxIncomingJobVtbl;

    interface IFaxIncomingJob
    {
        CONST_VTBL struct IFaxIncomingJobVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxIncomingJob_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxIncomingJob_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxIncomingJob_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxIncomingJob_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxIncomingJob_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxIncomingJob_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxIncomingJob_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxIncomingJob_get_Size(This,plSize)	\
    (This)->lpVtbl -> get_Size(This,plSize)

#define IFaxIncomingJob_get_Id(This,pbstrId)	\
    (This)->lpVtbl -> get_Id(This,pbstrId)

#define IFaxIncomingJob_get_CurrentPage(This,plCurrentPage)	\
    (This)->lpVtbl -> get_CurrentPage(This,plCurrentPage)

#define IFaxIncomingJob_get_DeviceId(This,plDeviceId)	\
    (This)->lpVtbl -> get_DeviceId(This,plDeviceId)

#define IFaxIncomingJob_get_Status(This,pStatus)	\
    (This)->lpVtbl -> get_Status(This,pStatus)

#define IFaxIncomingJob_get_ExtendedStatusCode(This,pExtendedStatusCode)	\
    (This)->lpVtbl -> get_ExtendedStatusCode(This,pExtendedStatusCode)

#define IFaxIncomingJob_get_ExtendedStatus(This,pbstrExtendedStatus)	\
    (This)->lpVtbl -> get_ExtendedStatus(This,pbstrExtendedStatus)

#define IFaxIncomingJob_get_AvailableOperations(This,pAvailableOperations)	\
    (This)->lpVtbl -> get_AvailableOperations(This,pAvailableOperations)

#define IFaxIncomingJob_get_Retries(This,plRetries)	\
    (This)->lpVtbl -> get_Retries(This,plRetries)

#define IFaxIncomingJob_get_TransmissionStart(This,pdateTransmissionStart)	\
    (This)->lpVtbl -> get_TransmissionStart(This,pdateTransmissionStart)

#define IFaxIncomingJob_get_TransmissionEnd(This,pdateTransmissionEnd)	\
    (This)->lpVtbl -> get_TransmissionEnd(This,pdateTransmissionEnd)

#define IFaxIncomingJob_get_CSID(This,pbstrCSID)	\
    (This)->lpVtbl -> get_CSID(This,pbstrCSID)

#define IFaxIncomingJob_get_TSID(This,pbstrTSID)	\
    (This)->lpVtbl -> get_TSID(This,pbstrTSID)

#define IFaxIncomingJob_get_CallerId(This,pbstrCallerId)	\
    (This)->lpVtbl -> get_CallerId(This,pbstrCallerId)

#define IFaxIncomingJob_get_RoutingInformation(This,pbstrRoutingInformation)	\
    (This)->lpVtbl -> get_RoutingInformation(This,pbstrRoutingInformation)

#define IFaxIncomingJob_get_JobType(This,pJobType)	\
    (This)->lpVtbl -> get_JobType(This,pJobType)

#define IFaxIncomingJob_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#define IFaxIncomingJob_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxIncomingJob_CopyTiff(This,bstrTiffPath)	\
    (This)->lpVtbl -> CopyTiff(This,bstrTiffPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_Size_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ long *plSize);


void __RPC_STUB IFaxIncomingJob_get_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_Id_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ BSTR *pbstrId);


void __RPC_STUB IFaxIncomingJob_get_Id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_CurrentPage_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ long *plCurrentPage);


void __RPC_STUB IFaxIncomingJob_get_CurrentPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_DeviceId_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ long *plDeviceId);


void __RPC_STUB IFaxIncomingJob_get_DeviceId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_Status_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ FAX_JOB_STATUS_ENUM *pStatus);


void __RPC_STUB IFaxIncomingJob_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_ExtendedStatusCode_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode);


void __RPC_STUB IFaxIncomingJob_get_ExtendedStatusCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_ExtendedStatus_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ BSTR *pbstrExtendedStatus);


void __RPC_STUB IFaxIncomingJob_get_ExtendedStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_AvailableOperations_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ FAX_JOB_OPERATIONS_ENUM *pAvailableOperations);


void __RPC_STUB IFaxIncomingJob_get_AvailableOperations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_Retries_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ long *plRetries);


void __RPC_STUB IFaxIncomingJob_get_Retries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_TransmissionStart_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ DATE *pdateTransmissionStart);


void __RPC_STUB IFaxIncomingJob_get_TransmissionStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_TransmissionEnd_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ DATE *pdateTransmissionEnd);


void __RPC_STUB IFaxIncomingJob_get_TransmissionEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_CSID_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ BSTR *pbstrCSID);


void __RPC_STUB IFaxIncomingJob_get_CSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_TSID_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ BSTR *pbstrTSID);


void __RPC_STUB IFaxIncomingJob_get_TSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_CallerId_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ BSTR *pbstrCallerId);


void __RPC_STUB IFaxIncomingJob_get_CallerId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_RoutingInformation_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ BSTR *pbstrRoutingInformation);


void __RPC_STUB IFaxIncomingJob_get_RoutingInformation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_get_JobType_Proxy( 
    IFaxIncomingJob * This,
    /* [retval][out] */ FAX_JOB_TYPE_ENUM *pJobType);


void __RPC_STUB IFaxIncomingJob_get_JobType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_Cancel_Proxy( 
    IFaxIncomingJob * This);


void __RPC_STUB IFaxIncomingJob_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_Refresh_Proxy( 
    IFaxIncomingJob * This);


void __RPC_STUB IFaxIncomingJob_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxIncomingJob_CopyTiff_Proxy( 
    IFaxIncomingJob * This,
    /* [in] */ BSTR bstrTiffPath);


void __RPC_STUB IFaxIncomingJob_CopyTiff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxIncomingJob_INTERFACE_DEFINED__ */


#ifndef __IFaxDeviceProvider_INTERFACE_DEFINED__
#define __IFaxDeviceProvider_INTERFACE_DEFINED__

/* interface IFaxDeviceProvider */
/* [unique][helpstring][dual][uuid][object] */ 

typedef 
enum FAX_PROVIDER_STATUS_ENUM
    {	fpsSUCCESS	= 0,
	fpsSERVER_ERROR	= fpsSUCCESS + 1,
	fpsBAD_GUID	= fpsSERVER_ERROR + 1,
	fpsBAD_VERSION	= fpsBAD_GUID + 1,
	fpsCANT_LOAD	= fpsBAD_VERSION + 1,
	fpsCANT_LINK	= fpsCANT_LOAD + 1,
	fpsCANT_INIT	= fpsCANT_LINK + 1
    } 	FAX_PROVIDER_STATUS_ENUM;


EXTERN_C const IID IID_IFaxDeviceProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("290EAC63-83EC-449C-8417-F148DF8C682A")
    IFaxDeviceProvider : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FriendlyName( 
            /* [retval][out] */ BSTR *pbstrFriendlyName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ImageName( 
            /* [retval][out] */ BSTR *pbstrImageName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UniqueName( 
            /* [retval][out] */ BSTR *pbstrUniqueName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TapiProviderName( 
            /* [retval][out] */ BSTR *pbstrTapiProviderName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MajorVersion( 
            /* [retval][out] */ long *plMajorVersion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinorVersion( 
            /* [retval][out] */ long *plMinorVersion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MajorBuild( 
            /* [retval][out] */ long *plMajorBuild) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinorBuild( 
            /* [retval][out] */ long *plMinorBuild) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Debug( 
            /* [retval][out] */ VARIANT_BOOL *pbDebug) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ FAX_PROVIDER_STATUS_ENUM *pStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InitErrorCode( 
            /* [retval][out] */ long *plInitErrorCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceIds( 
            /* [retval][out] */ VARIANT *pvDeviceIds) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxDeviceProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxDeviceProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxDeviceProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxDeviceProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxDeviceProvider * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxDeviceProvider * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxDeviceProvider * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxDeviceProvider * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FriendlyName )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ BSTR *pbstrFriendlyName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ImageName )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ BSTR *pbstrImageName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UniqueName )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ BSTR *pbstrUniqueName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TapiProviderName )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ BSTR *pbstrTapiProviderName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MajorVersion )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ long *plMajorVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinorVersion )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ long *plMinorVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MajorBuild )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ long *plMajorBuild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinorBuild )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ long *plMinorBuild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Debug )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ VARIANT_BOOL *pbDebug);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ FAX_PROVIDER_STATUS_ENUM *pStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InitErrorCode )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ long *plInitErrorCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceIds )( 
            IFaxDeviceProvider * This,
            /* [retval][out] */ VARIANT *pvDeviceIds);
        
        END_INTERFACE
    } IFaxDeviceProviderVtbl;

    interface IFaxDeviceProvider
    {
        CONST_VTBL struct IFaxDeviceProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxDeviceProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxDeviceProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxDeviceProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxDeviceProvider_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxDeviceProvider_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxDeviceProvider_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxDeviceProvider_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxDeviceProvider_get_FriendlyName(This,pbstrFriendlyName)	\
    (This)->lpVtbl -> get_FriendlyName(This,pbstrFriendlyName)

#define IFaxDeviceProvider_get_ImageName(This,pbstrImageName)	\
    (This)->lpVtbl -> get_ImageName(This,pbstrImageName)

#define IFaxDeviceProvider_get_UniqueName(This,pbstrUniqueName)	\
    (This)->lpVtbl -> get_UniqueName(This,pbstrUniqueName)

#define IFaxDeviceProvider_get_TapiProviderName(This,pbstrTapiProviderName)	\
    (This)->lpVtbl -> get_TapiProviderName(This,pbstrTapiProviderName)

#define IFaxDeviceProvider_get_MajorVersion(This,plMajorVersion)	\
    (This)->lpVtbl -> get_MajorVersion(This,plMajorVersion)

#define IFaxDeviceProvider_get_MinorVersion(This,plMinorVersion)	\
    (This)->lpVtbl -> get_MinorVersion(This,plMinorVersion)

#define IFaxDeviceProvider_get_MajorBuild(This,plMajorBuild)	\
    (This)->lpVtbl -> get_MajorBuild(This,plMajorBuild)

#define IFaxDeviceProvider_get_MinorBuild(This,plMinorBuild)	\
    (This)->lpVtbl -> get_MinorBuild(This,plMinorBuild)

#define IFaxDeviceProvider_get_Debug(This,pbDebug)	\
    (This)->lpVtbl -> get_Debug(This,pbDebug)

#define IFaxDeviceProvider_get_Status(This,pStatus)	\
    (This)->lpVtbl -> get_Status(This,pStatus)

#define IFaxDeviceProvider_get_InitErrorCode(This,plInitErrorCode)	\
    (This)->lpVtbl -> get_InitErrorCode(This,plInitErrorCode)

#define IFaxDeviceProvider_get_DeviceIds(This,pvDeviceIds)	\
    (This)->lpVtbl -> get_DeviceIds(This,pvDeviceIds)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_FriendlyName_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ BSTR *pbstrFriendlyName);


void __RPC_STUB IFaxDeviceProvider_get_FriendlyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_ImageName_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ BSTR *pbstrImageName);


void __RPC_STUB IFaxDeviceProvider_get_ImageName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_UniqueName_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ BSTR *pbstrUniqueName);


void __RPC_STUB IFaxDeviceProvider_get_UniqueName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_TapiProviderName_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ BSTR *pbstrTapiProviderName);


void __RPC_STUB IFaxDeviceProvider_get_TapiProviderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_MajorVersion_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ long *plMajorVersion);


void __RPC_STUB IFaxDeviceProvider_get_MajorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_MinorVersion_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ long *plMinorVersion);


void __RPC_STUB IFaxDeviceProvider_get_MinorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_MajorBuild_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ long *plMajorBuild);


void __RPC_STUB IFaxDeviceProvider_get_MajorBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_MinorBuild_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ long *plMinorBuild);


void __RPC_STUB IFaxDeviceProvider_get_MinorBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_Debug_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ VARIANT_BOOL *pbDebug);


void __RPC_STUB IFaxDeviceProvider_get_Debug_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_Status_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ FAX_PROVIDER_STATUS_ENUM *pStatus);


void __RPC_STUB IFaxDeviceProvider_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_InitErrorCode_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ long *plInitErrorCode);


void __RPC_STUB IFaxDeviceProvider_get_InitErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProvider_get_DeviceIds_Proxy( 
    IFaxDeviceProvider * This,
    /* [retval][out] */ VARIANT *pvDeviceIds);


void __RPC_STUB IFaxDeviceProvider_get_DeviceIds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxDeviceProvider_INTERFACE_DEFINED__ */


#ifndef __IFaxDevice_INTERFACE_DEFINED__
#define __IFaxDevice_INTERFACE_DEFINED__

/* interface IFaxDevice */
/* [unique][helpstring][dual][uuid][object] */ 

typedef 
enum FAX_DEVICE_RECEIVE_MODE_ENUM
    {	fdrmNO_ANSWER	= 0,
	fdrmAUTO_ANSWER	= fdrmNO_ANSWER + 1,
	fdrmMANUAL_ANSWER	= fdrmAUTO_ANSWER + 1
    } 	FAX_DEVICE_RECEIVE_MODE_ENUM;


EXTERN_C const IID IID_IFaxDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49306C59-B52E-4867-9DF4-CA5841C956D0")
    IFaxDevice : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ long *plId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceName( 
            /* [retval][out] */ BSTR *pbstrDeviceName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ProviderUniqueName( 
            /* [retval][out] */ BSTR *pbstrProviderUniqueName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PoweredOff( 
            /* [retval][out] */ VARIANT_BOOL *pbPoweredOff) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReceivingNow( 
            /* [retval][out] */ VARIANT_BOOL *pbReceivingNow) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SendingNow( 
            /* [retval][out] */ VARIANT_BOOL *pbSendingNow) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UsedRoutingMethods( 
            /* [retval][out] */ VARIANT *pvUsedRoutingMethods) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *pbstrDescription) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR bstrDescription) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SendEnabled( 
            /* [retval][out] */ VARIANT_BOOL *pbSendEnabled) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SendEnabled( 
            /* [in] */ VARIANT_BOOL bSendEnabled) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReceiveMode( 
            /* [retval][out] */ FAX_DEVICE_RECEIVE_MODE_ENUM *pReceiveMode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ReceiveMode( 
            /* [in] */ FAX_DEVICE_RECEIVE_MODE_ENUM ReceiveMode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RingsBeforeAnswer( 
            /* [retval][out] */ long *plRingsBeforeAnswer) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RingsBeforeAnswer( 
            /* [in] */ long lRingsBeforeAnswer) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CSID( 
            /* [retval][out] */ BSTR *pbstrCSID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CSID( 
            /* [in] */ BSTR bstrCSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TSID( 
            /* [retval][out] */ BSTR *pbstrTSID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_TSID( 
            /* [in] */ BSTR bstrTSID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetExtensionProperty( 
            /* [in] */ BSTR bstrGUID,
            /* [retval][out] */ VARIANT *pvProperty) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetExtensionProperty( 
            /* [in] */ BSTR bstrGUID,
            /* [in] */ VARIANT vProperty) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UseRoutingMethod( 
            /* [in] */ BSTR bstrMethodGUID,
            /* [in] */ VARIANT_BOOL bUse) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RingingNow( 
            /* [retval][out] */ VARIANT_BOOL *pbRingingNow) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AnswerCall( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxDevice * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxDevice * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxDevice * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxDevice * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxDevice * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxDevice * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            IFaxDevice * This,
            /* [retval][out] */ long *plId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceName )( 
            IFaxDevice * This,
            /* [retval][out] */ BSTR *pbstrDeviceName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderUniqueName )( 
            IFaxDevice * This,
            /* [retval][out] */ BSTR *pbstrProviderUniqueName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PoweredOff )( 
            IFaxDevice * This,
            /* [retval][out] */ VARIANT_BOOL *pbPoweredOff);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReceivingNow )( 
            IFaxDevice * This,
            /* [retval][out] */ VARIANT_BOOL *pbReceivingNow);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SendingNow )( 
            IFaxDevice * This,
            /* [retval][out] */ VARIANT_BOOL *pbSendingNow);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UsedRoutingMethods )( 
            IFaxDevice * This,
            /* [retval][out] */ VARIANT *pvUsedRoutingMethods);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IFaxDevice * This,
            /* [retval][out] */ BSTR *pbstrDescription);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            IFaxDevice * This,
            /* [in] */ BSTR bstrDescription);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SendEnabled )( 
            IFaxDevice * This,
            /* [retval][out] */ VARIANT_BOOL *pbSendEnabled);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SendEnabled )( 
            IFaxDevice * This,
            /* [in] */ VARIANT_BOOL bSendEnabled);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReceiveMode )( 
            IFaxDevice * This,
            /* [retval][out] */ FAX_DEVICE_RECEIVE_MODE_ENUM *pReceiveMode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReceiveMode )( 
            IFaxDevice * This,
            /* [in] */ FAX_DEVICE_RECEIVE_MODE_ENUM ReceiveMode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RingsBeforeAnswer )( 
            IFaxDevice * This,
            /* [retval][out] */ long *plRingsBeforeAnswer);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RingsBeforeAnswer )( 
            IFaxDevice * This,
            /* [in] */ long lRingsBeforeAnswer);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CSID )( 
            IFaxDevice * This,
            /* [retval][out] */ BSTR *pbstrCSID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CSID )( 
            IFaxDevice * This,
            /* [in] */ BSTR bstrCSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TSID )( 
            IFaxDevice * This,
            /* [retval][out] */ BSTR *pbstrTSID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TSID )( 
            IFaxDevice * This,
            /* [in] */ BSTR bstrTSID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxDevice * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IFaxDevice * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetExtensionProperty )( 
            IFaxDevice * This,
            /* [in] */ BSTR bstrGUID,
            /* [retval][out] */ VARIANT *pvProperty);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetExtensionProperty )( 
            IFaxDevice * This,
            /* [in] */ BSTR bstrGUID,
            /* [in] */ VARIANT vProperty);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UseRoutingMethod )( 
            IFaxDevice * This,
            /* [in] */ BSTR bstrMethodGUID,
            /* [in] */ VARIANT_BOOL bUse);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RingingNow )( 
            IFaxDevice * This,
            /* [retval][out] */ VARIANT_BOOL *pbRingingNow);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AnswerCall )( 
            IFaxDevice * This);
        
        END_INTERFACE
    } IFaxDeviceVtbl;

    interface IFaxDevice
    {
        CONST_VTBL struct IFaxDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxDevice_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxDevice_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxDevice_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxDevice_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxDevice_get_Id(This,plId)	\
    (This)->lpVtbl -> get_Id(This,plId)

#define IFaxDevice_get_DeviceName(This,pbstrDeviceName)	\
    (This)->lpVtbl -> get_DeviceName(This,pbstrDeviceName)

#define IFaxDevice_get_ProviderUniqueName(This,pbstrProviderUniqueName)	\
    (This)->lpVtbl -> get_ProviderUniqueName(This,pbstrProviderUniqueName)

#define IFaxDevice_get_PoweredOff(This,pbPoweredOff)	\
    (This)->lpVtbl -> get_PoweredOff(This,pbPoweredOff)

#define IFaxDevice_get_ReceivingNow(This,pbReceivingNow)	\
    (This)->lpVtbl -> get_ReceivingNow(This,pbReceivingNow)

#define IFaxDevice_get_SendingNow(This,pbSendingNow)	\
    (This)->lpVtbl -> get_SendingNow(This,pbSendingNow)

#define IFaxDevice_get_UsedRoutingMethods(This,pvUsedRoutingMethods)	\
    (This)->lpVtbl -> get_UsedRoutingMethods(This,pvUsedRoutingMethods)

#define IFaxDevice_get_Description(This,pbstrDescription)	\
    (This)->lpVtbl -> get_Description(This,pbstrDescription)

#define IFaxDevice_put_Description(This,bstrDescription)	\
    (This)->lpVtbl -> put_Description(This,bstrDescription)

#define IFaxDevice_get_SendEnabled(This,pbSendEnabled)	\
    (This)->lpVtbl -> get_SendEnabled(This,pbSendEnabled)

#define IFaxDevice_put_SendEnabled(This,bSendEnabled)	\
    (This)->lpVtbl -> put_SendEnabled(This,bSendEnabled)

#define IFaxDevice_get_ReceiveMode(This,pReceiveMode)	\
    (This)->lpVtbl -> get_ReceiveMode(This,pReceiveMode)

#define IFaxDevice_put_ReceiveMode(This,ReceiveMode)	\
    (This)->lpVtbl -> put_ReceiveMode(This,ReceiveMode)

#define IFaxDevice_get_RingsBeforeAnswer(This,plRingsBeforeAnswer)	\
    (This)->lpVtbl -> get_RingsBeforeAnswer(This,plRingsBeforeAnswer)

#define IFaxDevice_put_RingsBeforeAnswer(This,lRingsBeforeAnswer)	\
    (This)->lpVtbl -> put_RingsBeforeAnswer(This,lRingsBeforeAnswer)

#define IFaxDevice_get_CSID(This,pbstrCSID)	\
    (This)->lpVtbl -> get_CSID(This,pbstrCSID)

#define IFaxDevice_put_CSID(This,bstrCSID)	\
    (This)->lpVtbl -> put_CSID(This,bstrCSID)

#define IFaxDevice_get_TSID(This,pbstrTSID)	\
    (This)->lpVtbl -> get_TSID(This,pbstrTSID)

#define IFaxDevice_put_TSID(This,bstrTSID)	\
    (This)->lpVtbl -> put_TSID(This,bstrTSID)

#define IFaxDevice_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxDevice_Save(This)	\
    (This)->lpVtbl -> Save(This)

#define IFaxDevice_GetExtensionProperty(This,bstrGUID,pvProperty)	\
    (This)->lpVtbl -> GetExtensionProperty(This,bstrGUID,pvProperty)

#define IFaxDevice_SetExtensionProperty(This,bstrGUID,vProperty)	\
    (This)->lpVtbl -> SetExtensionProperty(This,bstrGUID,vProperty)

#define IFaxDevice_UseRoutingMethod(This,bstrMethodGUID,bUse)	\
    (This)->lpVtbl -> UseRoutingMethod(This,bstrMethodGUID,bUse)

#define IFaxDevice_get_RingingNow(This,pbRingingNow)	\
    (This)->lpVtbl -> get_RingingNow(This,pbRingingNow)

#define IFaxDevice_AnswerCall(This)	\
    (This)->lpVtbl -> AnswerCall(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_Id_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ long *plId);


void __RPC_STUB IFaxDevice_get_Id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_DeviceName_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ BSTR *pbstrDeviceName);


void __RPC_STUB IFaxDevice_get_DeviceName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_ProviderUniqueName_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ BSTR *pbstrProviderUniqueName);


void __RPC_STUB IFaxDevice_get_ProviderUniqueName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_PoweredOff_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ VARIANT_BOOL *pbPoweredOff);


void __RPC_STUB IFaxDevice_get_PoweredOff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_ReceivingNow_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ VARIANT_BOOL *pbReceivingNow);


void __RPC_STUB IFaxDevice_get_ReceivingNow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_SendingNow_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ VARIANT_BOOL *pbSendingNow);


void __RPC_STUB IFaxDevice_get_SendingNow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_UsedRoutingMethods_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ VARIANT *pvUsedRoutingMethods);


void __RPC_STUB IFaxDevice_get_UsedRoutingMethods_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_Description_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ BSTR *pbstrDescription);


void __RPC_STUB IFaxDevice_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDevice_put_Description_Proxy( 
    IFaxDevice * This,
    /* [in] */ BSTR bstrDescription);


void __RPC_STUB IFaxDevice_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_SendEnabled_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ VARIANT_BOOL *pbSendEnabled);


void __RPC_STUB IFaxDevice_get_SendEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDevice_put_SendEnabled_Proxy( 
    IFaxDevice * This,
    /* [in] */ VARIANT_BOOL bSendEnabled);


void __RPC_STUB IFaxDevice_put_SendEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_ReceiveMode_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ FAX_DEVICE_RECEIVE_MODE_ENUM *pReceiveMode);


void __RPC_STUB IFaxDevice_get_ReceiveMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDevice_put_ReceiveMode_Proxy( 
    IFaxDevice * This,
    /* [in] */ FAX_DEVICE_RECEIVE_MODE_ENUM ReceiveMode);


void __RPC_STUB IFaxDevice_put_ReceiveMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_RingsBeforeAnswer_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ long *plRingsBeforeAnswer);


void __RPC_STUB IFaxDevice_get_RingsBeforeAnswer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDevice_put_RingsBeforeAnswer_Proxy( 
    IFaxDevice * This,
    /* [in] */ long lRingsBeforeAnswer);


void __RPC_STUB IFaxDevice_put_RingsBeforeAnswer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_CSID_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ BSTR *pbstrCSID);


void __RPC_STUB IFaxDevice_get_CSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDevice_put_CSID_Proxy( 
    IFaxDevice * This,
    /* [in] */ BSTR bstrCSID);


void __RPC_STUB IFaxDevice_put_CSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_TSID_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ BSTR *pbstrTSID);


void __RPC_STUB IFaxDevice_get_TSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDevice_put_TSID_Proxy( 
    IFaxDevice * This,
    /* [in] */ BSTR bstrTSID);


void __RPC_STUB IFaxDevice_put_TSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDevice_Refresh_Proxy( 
    IFaxDevice * This);


void __RPC_STUB IFaxDevice_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDevice_Save_Proxy( 
    IFaxDevice * This);


void __RPC_STUB IFaxDevice_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDevice_GetExtensionProperty_Proxy( 
    IFaxDevice * This,
    /* [in] */ BSTR bstrGUID,
    /* [retval][out] */ VARIANT *pvProperty);


void __RPC_STUB IFaxDevice_GetExtensionProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDevice_SetExtensionProperty_Proxy( 
    IFaxDevice * This,
    /* [in] */ BSTR bstrGUID,
    /* [in] */ VARIANT vProperty);


void __RPC_STUB IFaxDevice_SetExtensionProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDevice_UseRoutingMethod_Proxy( 
    IFaxDevice * This,
    /* [in] */ BSTR bstrMethodGUID,
    /* [in] */ VARIANT_BOOL bUse);


void __RPC_STUB IFaxDevice_UseRoutingMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDevice_get_RingingNow_Proxy( 
    IFaxDevice * This,
    /* [retval][out] */ VARIANT_BOOL *pbRingingNow);


void __RPC_STUB IFaxDevice_get_RingingNow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDevice_AnswerCall_Proxy( 
    IFaxDevice * This);


void __RPC_STUB IFaxDevice_AnswerCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxDevice_INTERFACE_DEFINED__ */


#ifndef __IFaxActivityLogging_INTERFACE_DEFINED__
#define __IFaxActivityLogging_INTERFACE_DEFINED__

/* interface IFaxActivityLogging */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxActivityLogging;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1E29078B-5A69-497B-9592-49B7E7FADDB5")
    IFaxActivityLogging : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LogIncoming( 
            /* [retval][out] */ VARIANT_BOOL *pbLogIncoming) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LogIncoming( 
            /* [in] */ VARIANT_BOOL bLogIncoming) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LogOutgoing( 
            /* [retval][out] */ VARIANT_BOOL *pbLogOutgoing) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LogOutgoing( 
            /* [in] */ VARIANT_BOOL bLogOutgoing) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DatabasePath( 
            /* [retval][out] */ BSTR *pbstrDatabasePath) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DatabasePath( 
            /* [in] */ BSTR bstrDatabasePath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxActivityLoggingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxActivityLogging * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxActivityLogging * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxActivityLogging * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxActivityLogging * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxActivityLogging * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxActivityLogging * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxActivityLogging * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogIncoming )( 
            IFaxActivityLogging * This,
            /* [retval][out] */ VARIANT_BOOL *pbLogIncoming);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogIncoming )( 
            IFaxActivityLogging * This,
            /* [in] */ VARIANT_BOOL bLogIncoming);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogOutgoing )( 
            IFaxActivityLogging * This,
            /* [retval][out] */ VARIANT_BOOL *pbLogOutgoing);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogOutgoing )( 
            IFaxActivityLogging * This,
            /* [in] */ VARIANT_BOOL bLogOutgoing);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DatabasePath )( 
            IFaxActivityLogging * This,
            /* [retval][out] */ BSTR *pbstrDatabasePath);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DatabasePath )( 
            IFaxActivityLogging * This,
            /* [in] */ BSTR bstrDatabasePath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxActivityLogging * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IFaxActivityLogging * This);
        
        END_INTERFACE
    } IFaxActivityLoggingVtbl;

    interface IFaxActivityLogging
    {
        CONST_VTBL struct IFaxActivityLoggingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxActivityLogging_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxActivityLogging_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxActivityLogging_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxActivityLogging_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxActivityLogging_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxActivityLogging_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxActivityLogging_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxActivityLogging_get_LogIncoming(This,pbLogIncoming)	\
    (This)->lpVtbl -> get_LogIncoming(This,pbLogIncoming)

#define IFaxActivityLogging_put_LogIncoming(This,bLogIncoming)	\
    (This)->lpVtbl -> put_LogIncoming(This,bLogIncoming)

#define IFaxActivityLogging_get_LogOutgoing(This,pbLogOutgoing)	\
    (This)->lpVtbl -> get_LogOutgoing(This,pbLogOutgoing)

#define IFaxActivityLogging_put_LogOutgoing(This,bLogOutgoing)	\
    (This)->lpVtbl -> put_LogOutgoing(This,bLogOutgoing)

#define IFaxActivityLogging_get_DatabasePath(This,pbstrDatabasePath)	\
    (This)->lpVtbl -> get_DatabasePath(This,pbstrDatabasePath)

#define IFaxActivityLogging_put_DatabasePath(This,bstrDatabasePath)	\
    (This)->lpVtbl -> put_DatabasePath(This,bstrDatabasePath)

#define IFaxActivityLogging_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxActivityLogging_Save(This)	\
    (This)->lpVtbl -> Save(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxActivityLogging_get_LogIncoming_Proxy( 
    IFaxActivityLogging * This,
    /* [retval][out] */ VARIANT_BOOL *pbLogIncoming);


void __RPC_STUB IFaxActivityLogging_get_LogIncoming_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxActivityLogging_put_LogIncoming_Proxy( 
    IFaxActivityLogging * This,
    /* [in] */ VARIANT_BOOL bLogIncoming);


void __RPC_STUB IFaxActivityLogging_put_LogIncoming_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxActivityLogging_get_LogOutgoing_Proxy( 
    IFaxActivityLogging * This,
    /* [retval][out] */ VARIANT_BOOL *pbLogOutgoing);


void __RPC_STUB IFaxActivityLogging_get_LogOutgoing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxActivityLogging_put_LogOutgoing_Proxy( 
    IFaxActivityLogging * This,
    /* [in] */ VARIANT_BOOL bLogOutgoing);


void __RPC_STUB IFaxActivityLogging_put_LogOutgoing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxActivityLogging_get_DatabasePath_Proxy( 
    IFaxActivityLogging * This,
    /* [retval][out] */ BSTR *pbstrDatabasePath);


void __RPC_STUB IFaxActivityLogging_get_DatabasePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxActivityLogging_put_DatabasePath_Proxy( 
    IFaxActivityLogging * This,
    /* [in] */ BSTR bstrDatabasePath);


void __RPC_STUB IFaxActivityLogging_put_DatabasePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxActivityLogging_Refresh_Proxy( 
    IFaxActivityLogging * This);


void __RPC_STUB IFaxActivityLogging_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxActivityLogging_Save_Proxy( 
    IFaxActivityLogging * This);


void __RPC_STUB IFaxActivityLogging_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxActivityLogging_INTERFACE_DEFINED__ */


#ifndef __IFaxEventLogging_INTERFACE_DEFINED__
#define __IFaxEventLogging_INTERFACE_DEFINED__

/* interface IFaxEventLogging */
/* [unique][helpstring][dual][uuid][object] */ 

typedef 
enum FAX_LOG_LEVEL_ENUM
    {	fllNONE	= 0,
	fllMIN	= fllNONE + 1,
	fllMED	= fllMIN + 1,
	fllMAX	= fllMED + 1
    } 	FAX_LOG_LEVEL_ENUM;


EXTERN_C const IID IID_IFaxEventLogging;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0880D965-20E8-42E4-8E17-944F192CAAD4")
    IFaxEventLogging : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InitEventsLevel( 
            /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pInitEventLevel) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_InitEventsLevel( 
            /* [in] */ FAX_LOG_LEVEL_ENUM InitEventLevel) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InboundEventsLevel( 
            /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pInboundEventLevel) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_InboundEventsLevel( 
            /* [in] */ FAX_LOG_LEVEL_ENUM InboundEventLevel) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutboundEventsLevel( 
            /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pOutboundEventLevel) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OutboundEventsLevel( 
            /* [in] */ FAX_LOG_LEVEL_ENUM OutboundEventLevel) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GeneralEventsLevel( 
            /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pGeneralEventLevel) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_GeneralEventsLevel( 
            /* [in] */ FAX_LOG_LEVEL_ENUM GeneralEventLevel) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxEventLoggingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxEventLogging * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxEventLogging * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxEventLogging * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxEventLogging * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxEventLogging * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxEventLogging * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxEventLogging * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InitEventsLevel )( 
            IFaxEventLogging * This,
            /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pInitEventLevel);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InitEventsLevel )( 
            IFaxEventLogging * This,
            /* [in] */ FAX_LOG_LEVEL_ENUM InitEventLevel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InboundEventsLevel )( 
            IFaxEventLogging * This,
            /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pInboundEventLevel);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InboundEventsLevel )( 
            IFaxEventLogging * This,
            /* [in] */ FAX_LOG_LEVEL_ENUM InboundEventLevel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutboundEventsLevel )( 
            IFaxEventLogging * This,
            /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pOutboundEventLevel);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OutboundEventsLevel )( 
            IFaxEventLogging * This,
            /* [in] */ FAX_LOG_LEVEL_ENUM OutboundEventLevel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GeneralEventsLevel )( 
            IFaxEventLogging * This,
            /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pGeneralEventLevel);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_GeneralEventsLevel )( 
            IFaxEventLogging * This,
            /* [in] */ FAX_LOG_LEVEL_ENUM GeneralEventLevel);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxEventLogging * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IFaxEventLogging * This);
        
        END_INTERFACE
    } IFaxEventLoggingVtbl;

    interface IFaxEventLogging
    {
        CONST_VTBL struct IFaxEventLoggingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxEventLogging_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxEventLogging_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxEventLogging_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxEventLogging_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxEventLogging_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxEventLogging_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxEventLogging_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxEventLogging_get_InitEventsLevel(This,pInitEventLevel)	\
    (This)->lpVtbl -> get_InitEventsLevel(This,pInitEventLevel)

#define IFaxEventLogging_put_InitEventsLevel(This,InitEventLevel)	\
    (This)->lpVtbl -> put_InitEventsLevel(This,InitEventLevel)

#define IFaxEventLogging_get_InboundEventsLevel(This,pInboundEventLevel)	\
    (This)->lpVtbl -> get_InboundEventsLevel(This,pInboundEventLevel)

#define IFaxEventLogging_put_InboundEventsLevel(This,InboundEventLevel)	\
    (This)->lpVtbl -> put_InboundEventsLevel(This,InboundEventLevel)

#define IFaxEventLogging_get_OutboundEventsLevel(This,pOutboundEventLevel)	\
    (This)->lpVtbl -> get_OutboundEventsLevel(This,pOutboundEventLevel)

#define IFaxEventLogging_put_OutboundEventsLevel(This,OutboundEventLevel)	\
    (This)->lpVtbl -> put_OutboundEventsLevel(This,OutboundEventLevel)

#define IFaxEventLogging_get_GeneralEventsLevel(This,pGeneralEventLevel)	\
    (This)->lpVtbl -> get_GeneralEventsLevel(This,pGeneralEventLevel)

#define IFaxEventLogging_put_GeneralEventsLevel(This,GeneralEventLevel)	\
    (This)->lpVtbl -> put_GeneralEventsLevel(This,GeneralEventLevel)

#define IFaxEventLogging_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxEventLogging_Save(This)	\
    (This)->lpVtbl -> Save(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxEventLogging_get_InitEventsLevel_Proxy( 
    IFaxEventLogging * This,
    /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pInitEventLevel);


void __RPC_STUB IFaxEventLogging_get_InitEventsLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxEventLogging_put_InitEventsLevel_Proxy( 
    IFaxEventLogging * This,
    /* [in] */ FAX_LOG_LEVEL_ENUM InitEventLevel);


void __RPC_STUB IFaxEventLogging_put_InitEventsLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxEventLogging_get_InboundEventsLevel_Proxy( 
    IFaxEventLogging * This,
    /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pInboundEventLevel);


void __RPC_STUB IFaxEventLogging_get_InboundEventsLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxEventLogging_put_InboundEventsLevel_Proxy( 
    IFaxEventLogging * This,
    /* [in] */ FAX_LOG_LEVEL_ENUM InboundEventLevel);


void __RPC_STUB IFaxEventLogging_put_InboundEventsLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxEventLogging_get_OutboundEventsLevel_Proxy( 
    IFaxEventLogging * This,
    /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pOutboundEventLevel);


void __RPC_STUB IFaxEventLogging_get_OutboundEventsLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxEventLogging_put_OutboundEventsLevel_Proxy( 
    IFaxEventLogging * This,
    /* [in] */ FAX_LOG_LEVEL_ENUM OutboundEventLevel);


void __RPC_STUB IFaxEventLogging_put_OutboundEventsLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxEventLogging_get_GeneralEventsLevel_Proxy( 
    IFaxEventLogging * This,
    /* [retval][out] */ FAX_LOG_LEVEL_ENUM *pGeneralEventLevel);


void __RPC_STUB IFaxEventLogging_get_GeneralEventsLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxEventLogging_put_GeneralEventsLevel_Proxy( 
    IFaxEventLogging * This,
    /* [in] */ FAX_LOG_LEVEL_ENUM GeneralEventLevel);


void __RPC_STUB IFaxEventLogging_put_GeneralEventsLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxEventLogging_Refresh_Proxy( 
    IFaxEventLogging * This);


void __RPC_STUB IFaxEventLogging_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxEventLogging_Save_Proxy( 
    IFaxEventLogging * This);


void __RPC_STUB IFaxEventLogging_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxEventLogging_INTERFACE_DEFINED__ */


#ifndef __IFaxOutboundRoutingGroups_INTERFACE_DEFINED__
#define __IFaxOutboundRoutingGroups_INTERFACE_DEFINED__

/* interface IFaxOutboundRoutingGroups */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxOutboundRoutingGroups;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("235CBEF7-C2DE-4BFD-B8DA-75097C82C87F")
    IFaxOutboundRoutingGroups : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxOutboundRoutingGroup **pFaxOutboundRoutingGroup) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ IFaxOutboundRoutingGroup **pFaxOutboundRoutingGroup) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT vIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxOutboundRoutingGroupsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxOutboundRoutingGroups * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxOutboundRoutingGroups * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxOutboundRoutingGroups * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxOutboundRoutingGroups * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxOutboundRoutingGroups * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxOutboundRoutingGroups * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxOutboundRoutingGroups * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFaxOutboundRoutingGroups * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxOutboundRoutingGroups * This,
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxOutboundRoutingGroup **pFaxOutboundRoutingGroup);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxOutboundRoutingGroups * This,
            /* [retval][out] */ long *plCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IFaxOutboundRoutingGroups * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ IFaxOutboundRoutingGroup **pFaxOutboundRoutingGroup);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IFaxOutboundRoutingGroups * This,
            /* [in] */ VARIANT vIndex);
        
        END_INTERFACE
    } IFaxOutboundRoutingGroupsVtbl;

    interface IFaxOutboundRoutingGroups
    {
        CONST_VTBL struct IFaxOutboundRoutingGroupsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxOutboundRoutingGroups_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxOutboundRoutingGroups_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxOutboundRoutingGroups_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxOutboundRoutingGroups_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxOutboundRoutingGroups_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxOutboundRoutingGroups_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxOutboundRoutingGroups_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxOutboundRoutingGroups_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#define IFaxOutboundRoutingGroups_get_Item(This,vIndex,pFaxOutboundRoutingGroup)	\
    (This)->lpVtbl -> get_Item(This,vIndex,pFaxOutboundRoutingGroup)

#define IFaxOutboundRoutingGroups_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define IFaxOutboundRoutingGroups_Add(This,bstrName,pFaxOutboundRoutingGroup)	\
    (This)->lpVtbl -> Add(This,bstrName,pFaxOutboundRoutingGroup)

#define IFaxOutboundRoutingGroups_Remove(This,vIndex)	\
    (This)->lpVtbl -> Remove(This,vIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingGroups_get__NewEnum_Proxy( 
    IFaxOutboundRoutingGroups * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFaxOutboundRoutingGroups_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingGroups_get_Item_Proxy( 
    IFaxOutboundRoutingGroups * This,
    /* [in] */ VARIANT vIndex,
    /* [retval][out] */ IFaxOutboundRoutingGroup **pFaxOutboundRoutingGroup);


void __RPC_STUB IFaxOutboundRoutingGroups_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingGroups_get_Count_Proxy( 
    IFaxOutboundRoutingGroups * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IFaxOutboundRoutingGroups_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingGroups_Add_Proxy( 
    IFaxOutboundRoutingGroups * This,
    /* [in] */ BSTR bstrName,
    /* [retval][out] */ IFaxOutboundRoutingGroup **pFaxOutboundRoutingGroup);


void __RPC_STUB IFaxOutboundRoutingGroups_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingGroups_Remove_Proxy( 
    IFaxOutboundRoutingGroups * This,
    /* [in] */ VARIANT vIndex);


void __RPC_STUB IFaxOutboundRoutingGroups_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxOutboundRoutingGroups_INTERFACE_DEFINED__ */


#ifndef __IFaxOutboundRoutingGroup_INTERFACE_DEFINED__
#define __IFaxOutboundRoutingGroup_INTERFACE_DEFINED__

/* interface IFaxOutboundRoutingGroup */
/* [unique][helpstring][dual][uuid][object] */ 

typedef 
enum FAX_GROUP_STATUS_ENUM
    {	fgsALL_DEV_VALID	= 0,
	fgsEMPTY	= fgsALL_DEV_VALID + 1,
	fgsALL_DEV_NOT_VALID	= fgsEMPTY + 1,
	fgsSOME_DEV_NOT_VALID	= fgsALL_DEV_NOT_VALID + 1
    } 	FAX_GROUP_STATUS_ENUM;


EXTERN_C const IID IID_IFaxOutboundRoutingGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CA6289A1-7E25-4F87-9A0B-93365734962C")
    IFaxOutboundRoutingGroup : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pbstrName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ FAX_GROUP_STATUS_ENUM *pStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceIds( 
            /* [retval][out] */ IFaxDeviceIds **pFaxDeviceIds) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxOutboundRoutingGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxOutboundRoutingGroup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxOutboundRoutingGroup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxOutboundRoutingGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxOutboundRoutingGroup * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxOutboundRoutingGroup * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxOutboundRoutingGroup * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxOutboundRoutingGroup * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IFaxOutboundRoutingGroup * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IFaxOutboundRoutingGroup * This,
            /* [retval][out] */ FAX_GROUP_STATUS_ENUM *pStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceIds )( 
            IFaxOutboundRoutingGroup * This,
            /* [retval][out] */ IFaxDeviceIds **pFaxDeviceIds);
        
        END_INTERFACE
    } IFaxOutboundRoutingGroupVtbl;

    interface IFaxOutboundRoutingGroup
    {
        CONST_VTBL struct IFaxOutboundRoutingGroupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxOutboundRoutingGroup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxOutboundRoutingGroup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxOutboundRoutingGroup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxOutboundRoutingGroup_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxOutboundRoutingGroup_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxOutboundRoutingGroup_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxOutboundRoutingGroup_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxOutboundRoutingGroup_get_Name(This,pbstrName)	\
    (This)->lpVtbl -> get_Name(This,pbstrName)

#define IFaxOutboundRoutingGroup_get_Status(This,pStatus)	\
    (This)->lpVtbl -> get_Status(This,pStatus)

#define IFaxOutboundRoutingGroup_get_DeviceIds(This,pFaxDeviceIds)	\
    (This)->lpVtbl -> get_DeviceIds(This,pFaxDeviceIds)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingGroup_get_Name_Proxy( 
    IFaxOutboundRoutingGroup * This,
    /* [retval][out] */ BSTR *pbstrName);


void __RPC_STUB IFaxOutboundRoutingGroup_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingGroup_get_Status_Proxy( 
    IFaxOutboundRoutingGroup * This,
    /* [retval][out] */ FAX_GROUP_STATUS_ENUM *pStatus);


void __RPC_STUB IFaxOutboundRoutingGroup_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingGroup_get_DeviceIds_Proxy( 
    IFaxOutboundRoutingGroup * This,
    /* [retval][out] */ IFaxDeviceIds **pFaxDeviceIds);


void __RPC_STUB IFaxOutboundRoutingGroup_get_DeviceIds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxOutboundRoutingGroup_INTERFACE_DEFINED__ */


#ifndef __IFaxDeviceIds_INTERFACE_DEFINED__
#define __IFaxDeviceIds_INTERFACE_DEFINED__

/* interface IFaxDeviceIds */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxDeviceIds;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2F0F813F-4CE9-443E-8CA1-738CFAEEE149")
    IFaxDeviceIds : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ long *plDeviceId) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ long lDeviceId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetOrder( 
            /* [in] */ long lDeviceId,
            /* [in] */ long lNewOrder) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxDeviceIdsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxDeviceIds * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxDeviceIds * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxDeviceIds * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxDeviceIds * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxDeviceIds * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxDeviceIds * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxDeviceIds * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFaxDeviceIds * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxDeviceIds * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ long *plDeviceId);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxDeviceIds * This,
            /* [retval][out] */ long *plCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IFaxDeviceIds * This,
            /* [in] */ long lDeviceId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IFaxDeviceIds * This,
            /* [in] */ long lIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetOrder )( 
            IFaxDeviceIds * This,
            /* [in] */ long lDeviceId,
            /* [in] */ long lNewOrder);
        
        END_INTERFACE
    } IFaxDeviceIdsVtbl;

    interface IFaxDeviceIds
    {
        CONST_VTBL struct IFaxDeviceIdsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxDeviceIds_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxDeviceIds_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxDeviceIds_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxDeviceIds_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxDeviceIds_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxDeviceIds_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxDeviceIds_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxDeviceIds_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#define IFaxDeviceIds_get_Item(This,lIndex,plDeviceId)	\
    (This)->lpVtbl -> get_Item(This,lIndex,plDeviceId)

#define IFaxDeviceIds_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define IFaxDeviceIds_Add(This,lDeviceId)	\
    (This)->lpVtbl -> Add(This,lDeviceId)

#define IFaxDeviceIds_Remove(This,lIndex)	\
    (This)->lpVtbl -> Remove(This,lIndex)

#define IFaxDeviceIds_SetOrder(This,lDeviceId,lNewOrder)	\
    (This)->lpVtbl -> SetOrder(This,lDeviceId,lNewOrder)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxDeviceIds_get__NewEnum_Proxy( 
    IFaxDeviceIds * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFaxDeviceIds_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxDeviceIds_get_Item_Proxy( 
    IFaxDeviceIds * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ long *plDeviceId);


void __RPC_STUB IFaxDeviceIds_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxDeviceIds_get_Count_Proxy( 
    IFaxDeviceIds * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IFaxDeviceIds_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDeviceIds_Add_Proxy( 
    IFaxDeviceIds * This,
    /* [in] */ long lDeviceId);


void __RPC_STUB IFaxDeviceIds_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDeviceIds_Remove_Proxy( 
    IFaxDeviceIds * This,
    /* [in] */ long lIndex);


void __RPC_STUB IFaxDeviceIds_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDeviceIds_SetOrder_Proxy( 
    IFaxDeviceIds * This,
    /* [in] */ long lDeviceId,
    /* [in] */ long lNewOrder);


void __RPC_STUB IFaxDeviceIds_SetOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxDeviceIds_INTERFACE_DEFINED__ */


#ifndef __IFaxOutboundRoutingRules_INTERFACE_DEFINED__
#define __IFaxOutboundRoutingRules_INTERFACE_DEFINED__

/* interface IFaxOutboundRoutingRules */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxOutboundRoutingRules;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCEFA1E7-AE7D-4ED6-8521-369EDCCA5120")
    IFaxOutboundRoutingRules : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ IFaxOutboundRoutingRule **pFaxOutboundRoutingRule) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ItemByCountryAndArea( 
            /* [in] */ long lCountryCode,
            /* [in] */ long lAreaCode,
            /* [retval][out] */ IFaxOutboundRoutingRule **pFaxOutboundRoutingRule) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveByCountryAndArea( 
            /* [in] */ long lCountryCode,
            /* [in] */ long lAreaCode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ long lCountryCode,
            /* [in] */ long lAreaCode,
            /* [in] */ VARIANT_BOOL bUseDevice,
            /* [in] */ BSTR bstrGroupName,
            /* [in] */ long lDeviceId,
            /* [retval][out] */ IFaxOutboundRoutingRule **pFaxOutboundRoutingRule) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxOutboundRoutingRulesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxOutboundRoutingRules * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxOutboundRoutingRules * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxOutboundRoutingRules * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxOutboundRoutingRules * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxOutboundRoutingRules * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxOutboundRoutingRules * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxOutboundRoutingRules * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFaxOutboundRoutingRules * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxOutboundRoutingRules * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ IFaxOutboundRoutingRule **pFaxOutboundRoutingRule);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxOutboundRoutingRules * This,
            /* [retval][out] */ long *plCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ItemByCountryAndArea )( 
            IFaxOutboundRoutingRules * This,
            /* [in] */ long lCountryCode,
            /* [in] */ long lAreaCode,
            /* [retval][out] */ IFaxOutboundRoutingRule **pFaxOutboundRoutingRule);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveByCountryAndArea )( 
            IFaxOutboundRoutingRules * This,
            /* [in] */ long lCountryCode,
            /* [in] */ long lAreaCode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IFaxOutboundRoutingRules * This,
            /* [in] */ long lIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IFaxOutboundRoutingRules * This,
            /* [in] */ long lCountryCode,
            /* [in] */ long lAreaCode,
            /* [in] */ VARIANT_BOOL bUseDevice,
            /* [in] */ BSTR bstrGroupName,
            /* [in] */ long lDeviceId,
            /* [retval][out] */ IFaxOutboundRoutingRule **pFaxOutboundRoutingRule);
        
        END_INTERFACE
    } IFaxOutboundRoutingRulesVtbl;

    interface IFaxOutboundRoutingRules
    {
        CONST_VTBL struct IFaxOutboundRoutingRulesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxOutboundRoutingRules_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxOutboundRoutingRules_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxOutboundRoutingRules_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxOutboundRoutingRules_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxOutboundRoutingRules_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxOutboundRoutingRules_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxOutboundRoutingRules_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxOutboundRoutingRules_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#define IFaxOutboundRoutingRules_get_Item(This,lIndex,pFaxOutboundRoutingRule)	\
    (This)->lpVtbl -> get_Item(This,lIndex,pFaxOutboundRoutingRule)

#define IFaxOutboundRoutingRules_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define IFaxOutboundRoutingRules_ItemByCountryAndArea(This,lCountryCode,lAreaCode,pFaxOutboundRoutingRule)	\
    (This)->lpVtbl -> ItemByCountryAndArea(This,lCountryCode,lAreaCode,pFaxOutboundRoutingRule)

#define IFaxOutboundRoutingRules_RemoveByCountryAndArea(This,lCountryCode,lAreaCode)	\
    (This)->lpVtbl -> RemoveByCountryAndArea(This,lCountryCode,lAreaCode)

#define IFaxOutboundRoutingRules_Remove(This,lIndex)	\
    (This)->lpVtbl -> Remove(This,lIndex)

#define IFaxOutboundRoutingRules_Add(This,lCountryCode,lAreaCode,bUseDevice,bstrGroupName,lDeviceId,pFaxOutboundRoutingRule)	\
    (This)->lpVtbl -> Add(This,lCountryCode,lAreaCode,bUseDevice,bstrGroupName,lDeviceId,pFaxOutboundRoutingRule)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRules_get__NewEnum_Proxy( 
    IFaxOutboundRoutingRules * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFaxOutboundRoutingRules_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRules_get_Item_Proxy( 
    IFaxOutboundRoutingRules * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ IFaxOutboundRoutingRule **pFaxOutboundRoutingRule);


void __RPC_STUB IFaxOutboundRoutingRules_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRules_get_Count_Proxy( 
    IFaxOutboundRoutingRules * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IFaxOutboundRoutingRules_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRules_ItemByCountryAndArea_Proxy( 
    IFaxOutboundRoutingRules * This,
    /* [in] */ long lCountryCode,
    /* [in] */ long lAreaCode,
    /* [retval][out] */ IFaxOutboundRoutingRule **pFaxOutboundRoutingRule);


void __RPC_STUB IFaxOutboundRoutingRules_ItemByCountryAndArea_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRules_RemoveByCountryAndArea_Proxy( 
    IFaxOutboundRoutingRules * This,
    /* [in] */ long lCountryCode,
    /* [in] */ long lAreaCode);


void __RPC_STUB IFaxOutboundRoutingRules_RemoveByCountryAndArea_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRules_Remove_Proxy( 
    IFaxOutboundRoutingRules * This,
    /* [in] */ long lIndex);


void __RPC_STUB IFaxOutboundRoutingRules_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRules_Add_Proxy( 
    IFaxOutboundRoutingRules * This,
    /* [in] */ long lCountryCode,
    /* [in] */ long lAreaCode,
    /* [in] */ VARIANT_BOOL bUseDevice,
    /* [in] */ BSTR bstrGroupName,
    /* [in] */ long lDeviceId,
    /* [retval][out] */ IFaxOutboundRoutingRule **pFaxOutboundRoutingRule);


void __RPC_STUB IFaxOutboundRoutingRules_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxOutboundRoutingRules_INTERFACE_DEFINED__ */


#ifndef __IFaxOutboundRoutingRule_INTERFACE_DEFINED__
#define __IFaxOutboundRoutingRule_INTERFACE_DEFINED__

/* interface IFaxOutboundRoutingRule */
/* [unique][helpstring][dual][uuid][object] */ 

typedef 
enum FAX_RULE_STATUS_ENUM
    {	frsVALID	= 0,
	frsEMPTY_GROUP	= frsVALID + 1,
	frsALL_GROUP_DEV_NOT_VALID	= frsEMPTY_GROUP + 1,
	frsSOME_GROUP_DEV_NOT_VALID	= frsALL_GROUP_DEV_NOT_VALID + 1,
	frsBAD_DEVICE	= frsSOME_GROUP_DEV_NOT_VALID + 1
    } 	FAX_RULE_STATUS_ENUM;


EXTERN_C const IID IID_IFaxOutboundRoutingRule;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E1F795D5-07C2-469F-B027-ACACC23219DA")
    IFaxOutboundRoutingRule : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CountryCode( 
            /* [retval][out] */ long *plCountryCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AreaCode( 
            /* [retval][out] */ long *plAreaCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ FAX_RULE_STATUS_ENUM *pStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UseDevice( 
            /* [retval][out] */ VARIANT_BOOL *pbUseDevice) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UseDevice( 
            /* [in] */ VARIANT_BOOL bUseDevice) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceId( 
            /* [retval][out] */ long *plDeviceId) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DeviceId( 
            /* [in] */ long DeviceId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GroupName( 
            /* [retval][out] */ BSTR *pbstrGroupName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_GroupName( 
            /* [in] */ BSTR bstrGroupName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxOutboundRoutingRuleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxOutboundRoutingRule * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxOutboundRoutingRule * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxOutboundRoutingRule * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxOutboundRoutingRule * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxOutboundRoutingRule * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxOutboundRoutingRule * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxOutboundRoutingRule * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CountryCode )( 
            IFaxOutboundRoutingRule * This,
            /* [retval][out] */ long *plCountryCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AreaCode )( 
            IFaxOutboundRoutingRule * This,
            /* [retval][out] */ long *plAreaCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IFaxOutboundRoutingRule * This,
            /* [retval][out] */ FAX_RULE_STATUS_ENUM *pStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseDevice )( 
            IFaxOutboundRoutingRule * This,
            /* [retval][out] */ VARIANT_BOOL *pbUseDevice);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseDevice )( 
            IFaxOutboundRoutingRule * This,
            /* [in] */ VARIANT_BOOL bUseDevice);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceId )( 
            IFaxOutboundRoutingRule * This,
            /* [retval][out] */ long *plDeviceId);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeviceId )( 
            IFaxOutboundRoutingRule * This,
            /* [in] */ long DeviceId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GroupName )( 
            IFaxOutboundRoutingRule * This,
            /* [retval][out] */ BSTR *pbstrGroupName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_GroupName )( 
            IFaxOutboundRoutingRule * This,
            /* [in] */ BSTR bstrGroupName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxOutboundRoutingRule * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IFaxOutboundRoutingRule * This);
        
        END_INTERFACE
    } IFaxOutboundRoutingRuleVtbl;

    interface IFaxOutboundRoutingRule
    {
        CONST_VTBL struct IFaxOutboundRoutingRuleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxOutboundRoutingRule_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxOutboundRoutingRule_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxOutboundRoutingRule_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxOutboundRoutingRule_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxOutboundRoutingRule_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxOutboundRoutingRule_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxOutboundRoutingRule_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxOutboundRoutingRule_get_CountryCode(This,plCountryCode)	\
    (This)->lpVtbl -> get_CountryCode(This,plCountryCode)

#define IFaxOutboundRoutingRule_get_AreaCode(This,plAreaCode)	\
    (This)->lpVtbl -> get_AreaCode(This,plAreaCode)

#define IFaxOutboundRoutingRule_get_Status(This,pStatus)	\
    (This)->lpVtbl -> get_Status(This,pStatus)

#define IFaxOutboundRoutingRule_get_UseDevice(This,pbUseDevice)	\
    (This)->lpVtbl -> get_UseDevice(This,pbUseDevice)

#define IFaxOutboundRoutingRule_put_UseDevice(This,bUseDevice)	\
    (This)->lpVtbl -> put_UseDevice(This,bUseDevice)

#define IFaxOutboundRoutingRule_get_DeviceId(This,plDeviceId)	\
    (This)->lpVtbl -> get_DeviceId(This,plDeviceId)

#define IFaxOutboundRoutingRule_put_DeviceId(This,DeviceId)	\
    (This)->lpVtbl -> put_DeviceId(This,DeviceId)

#define IFaxOutboundRoutingRule_get_GroupName(This,pbstrGroupName)	\
    (This)->lpVtbl -> get_GroupName(This,pbstrGroupName)

#define IFaxOutboundRoutingRule_put_GroupName(This,bstrGroupName)	\
    (This)->lpVtbl -> put_GroupName(This,bstrGroupName)

#define IFaxOutboundRoutingRule_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxOutboundRoutingRule_Save(This)	\
    (This)->lpVtbl -> Save(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRule_get_CountryCode_Proxy( 
    IFaxOutboundRoutingRule * This,
    /* [retval][out] */ long *plCountryCode);


void __RPC_STUB IFaxOutboundRoutingRule_get_CountryCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRule_get_AreaCode_Proxy( 
    IFaxOutboundRoutingRule * This,
    /* [retval][out] */ long *plAreaCode);


void __RPC_STUB IFaxOutboundRoutingRule_get_AreaCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRule_get_Status_Proxy( 
    IFaxOutboundRoutingRule * This,
    /* [retval][out] */ FAX_RULE_STATUS_ENUM *pStatus);


void __RPC_STUB IFaxOutboundRoutingRule_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRule_get_UseDevice_Proxy( 
    IFaxOutboundRoutingRule * This,
    /* [retval][out] */ VARIANT_BOOL *pbUseDevice);


void __RPC_STUB IFaxOutboundRoutingRule_get_UseDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRule_put_UseDevice_Proxy( 
    IFaxOutboundRoutingRule * This,
    /* [in] */ VARIANT_BOOL bUseDevice);


void __RPC_STUB IFaxOutboundRoutingRule_put_UseDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRule_get_DeviceId_Proxy( 
    IFaxOutboundRoutingRule * This,
    /* [retval][out] */ long *plDeviceId);


void __RPC_STUB IFaxOutboundRoutingRule_get_DeviceId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRule_put_DeviceId_Proxy( 
    IFaxOutboundRoutingRule * This,
    /* [in] */ long DeviceId);


void __RPC_STUB IFaxOutboundRoutingRule_put_DeviceId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRule_get_GroupName_Proxy( 
    IFaxOutboundRoutingRule * This,
    /* [retval][out] */ BSTR *pbstrGroupName);


void __RPC_STUB IFaxOutboundRoutingRule_get_GroupName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRule_put_GroupName_Proxy( 
    IFaxOutboundRoutingRule * This,
    /* [in] */ BSTR bstrGroupName);


void __RPC_STUB IFaxOutboundRoutingRule_put_GroupName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRule_Refresh_Proxy( 
    IFaxOutboundRoutingRule * This);


void __RPC_STUB IFaxOutboundRoutingRule_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRoutingRule_Save_Proxy( 
    IFaxOutboundRoutingRule * This);


void __RPC_STUB IFaxOutboundRoutingRule_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxOutboundRoutingRule_INTERFACE_DEFINED__ */


#ifndef __IFaxInboundRoutingExtensions_INTERFACE_DEFINED__
#define __IFaxInboundRoutingExtensions_INTERFACE_DEFINED__

/* interface IFaxInboundRoutingExtensions */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxInboundRoutingExtensions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2F6C9673-7B26-42DE-8EB0-915DCD2A4F4C")
    IFaxInboundRoutingExtensions : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxInboundRoutingExtension **pFaxInboundRoutingExtension) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxInboundRoutingExtensionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxInboundRoutingExtensions * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxInboundRoutingExtensions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxInboundRoutingExtensions * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxInboundRoutingExtensions * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxInboundRoutingExtensions * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxInboundRoutingExtensions * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxInboundRoutingExtensions * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFaxInboundRoutingExtensions * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxInboundRoutingExtensions * This,
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxInboundRoutingExtension **pFaxInboundRoutingExtension);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxInboundRoutingExtensions * This,
            /* [retval][out] */ long *plCount);
        
        END_INTERFACE
    } IFaxInboundRoutingExtensionsVtbl;

    interface IFaxInboundRoutingExtensions
    {
        CONST_VTBL struct IFaxInboundRoutingExtensionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxInboundRoutingExtensions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxInboundRoutingExtensions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxInboundRoutingExtensions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxInboundRoutingExtensions_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxInboundRoutingExtensions_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxInboundRoutingExtensions_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxInboundRoutingExtensions_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxInboundRoutingExtensions_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#define IFaxInboundRoutingExtensions_get_Item(This,vIndex,pFaxInboundRoutingExtension)	\
    (This)->lpVtbl -> get_Item(This,vIndex,pFaxInboundRoutingExtension)

#define IFaxInboundRoutingExtensions_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtensions_get__NewEnum_Proxy( 
    IFaxInboundRoutingExtensions * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFaxInboundRoutingExtensions_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtensions_get_Item_Proxy( 
    IFaxInboundRoutingExtensions * This,
    /* [in] */ VARIANT vIndex,
    /* [retval][out] */ IFaxInboundRoutingExtension **pFaxInboundRoutingExtension);


void __RPC_STUB IFaxInboundRoutingExtensions_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtensions_get_Count_Proxy( 
    IFaxInboundRoutingExtensions * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IFaxInboundRoutingExtensions_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxInboundRoutingExtensions_INTERFACE_DEFINED__ */


#ifndef __IFaxInboundRoutingExtension_INTERFACE_DEFINED__
#define __IFaxInboundRoutingExtension_INTERFACE_DEFINED__

/* interface IFaxInboundRoutingExtension */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxInboundRoutingExtension;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("885B5E08-C26C-4EF9-AF83-51580A750BE1")
    IFaxInboundRoutingExtension : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FriendlyName( 
            /* [retval][out] */ BSTR *pbstrFriendlyName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ImageName( 
            /* [retval][out] */ BSTR *pbstrImageName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UniqueName( 
            /* [retval][out] */ BSTR *pbstrUniqueName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MajorVersion( 
            /* [retval][out] */ long *plMajorVersion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinorVersion( 
            /* [retval][out] */ long *plMinorVersion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MajorBuild( 
            /* [retval][out] */ long *plMajorBuild) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinorBuild( 
            /* [retval][out] */ long *plMinorBuild) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Debug( 
            /* [retval][out] */ VARIANT_BOOL *pbDebug) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ FAX_PROVIDER_STATUS_ENUM *pStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InitErrorCode( 
            /* [retval][out] */ long *plInitErrorCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Methods( 
            /* [retval][out] */ VARIANT *pvMethods) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxInboundRoutingExtensionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxInboundRoutingExtension * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxInboundRoutingExtension * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxInboundRoutingExtension * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxInboundRoutingExtension * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxInboundRoutingExtension * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxInboundRoutingExtension * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxInboundRoutingExtension * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FriendlyName )( 
            IFaxInboundRoutingExtension * This,
            /* [retval][out] */ BSTR *pbstrFriendlyName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ImageName )( 
            IFaxInboundRoutingExtension * This,
            /* [retval][out] */ BSTR *pbstrImageName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UniqueName )( 
            IFaxInboundRoutingExtension * This,
            /* [retval][out] */ BSTR *pbstrUniqueName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MajorVersion )( 
            IFaxInboundRoutingExtension * This,
            /* [retval][out] */ long *plMajorVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinorVersion )( 
            IFaxInboundRoutingExtension * This,
            /* [retval][out] */ long *plMinorVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MajorBuild )( 
            IFaxInboundRoutingExtension * This,
            /* [retval][out] */ long *plMajorBuild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinorBuild )( 
            IFaxInboundRoutingExtension * This,
            /* [retval][out] */ long *plMinorBuild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Debug )( 
            IFaxInboundRoutingExtension * This,
            /* [retval][out] */ VARIANT_BOOL *pbDebug);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IFaxInboundRoutingExtension * This,
            /* [retval][out] */ FAX_PROVIDER_STATUS_ENUM *pStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InitErrorCode )( 
            IFaxInboundRoutingExtension * This,
            /* [retval][out] */ long *plInitErrorCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Methods )( 
            IFaxInboundRoutingExtension * This,
            /* [retval][out] */ VARIANT *pvMethods);
        
        END_INTERFACE
    } IFaxInboundRoutingExtensionVtbl;

    interface IFaxInboundRoutingExtension
    {
        CONST_VTBL struct IFaxInboundRoutingExtensionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxInboundRoutingExtension_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxInboundRoutingExtension_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxInboundRoutingExtension_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxInboundRoutingExtension_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxInboundRoutingExtension_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxInboundRoutingExtension_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxInboundRoutingExtension_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxInboundRoutingExtension_get_FriendlyName(This,pbstrFriendlyName)	\
    (This)->lpVtbl -> get_FriendlyName(This,pbstrFriendlyName)

#define IFaxInboundRoutingExtension_get_ImageName(This,pbstrImageName)	\
    (This)->lpVtbl -> get_ImageName(This,pbstrImageName)

#define IFaxInboundRoutingExtension_get_UniqueName(This,pbstrUniqueName)	\
    (This)->lpVtbl -> get_UniqueName(This,pbstrUniqueName)

#define IFaxInboundRoutingExtension_get_MajorVersion(This,plMajorVersion)	\
    (This)->lpVtbl -> get_MajorVersion(This,plMajorVersion)

#define IFaxInboundRoutingExtension_get_MinorVersion(This,plMinorVersion)	\
    (This)->lpVtbl -> get_MinorVersion(This,plMinorVersion)

#define IFaxInboundRoutingExtension_get_MajorBuild(This,plMajorBuild)	\
    (This)->lpVtbl -> get_MajorBuild(This,plMajorBuild)

#define IFaxInboundRoutingExtension_get_MinorBuild(This,plMinorBuild)	\
    (This)->lpVtbl -> get_MinorBuild(This,plMinorBuild)

#define IFaxInboundRoutingExtension_get_Debug(This,pbDebug)	\
    (This)->lpVtbl -> get_Debug(This,pbDebug)

#define IFaxInboundRoutingExtension_get_Status(This,pStatus)	\
    (This)->lpVtbl -> get_Status(This,pStatus)

#define IFaxInboundRoutingExtension_get_InitErrorCode(This,plInitErrorCode)	\
    (This)->lpVtbl -> get_InitErrorCode(This,plInitErrorCode)

#define IFaxInboundRoutingExtension_get_Methods(This,pvMethods)	\
    (This)->lpVtbl -> get_Methods(This,pvMethods)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtension_get_FriendlyName_Proxy( 
    IFaxInboundRoutingExtension * This,
    /* [retval][out] */ BSTR *pbstrFriendlyName);


void __RPC_STUB IFaxInboundRoutingExtension_get_FriendlyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtension_get_ImageName_Proxy( 
    IFaxInboundRoutingExtension * This,
    /* [retval][out] */ BSTR *pbstrImageName);


void __RPC_STUB IFaxInboundRoutingExtension_get_ImageName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtension_get_UniqueName_Proxy( 
    IFaxInboundRoutingExtension * This,
    /* [retval][out] */ BSTR *pbstrUniqueName);


void __RPC_STUB IFaxInboundRoutingExtension_get_UniqueName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtension_get_MajorVersion_Proxy( 
    IFaxInboundRoutingExtension * This,
    /* [retval][out] */ long *plMajorVersion);


void __RPC_STUB IFaxInboundRoutingExtension_get_MajorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtension_get_MinorVersion_Proxy( 
    IFaxInboundRoutingExtension * This,
    /* [retval][out] */ long *plMinorVersion);


void __RPC_STUB IFaxInboundRoutingExtension_get_MinorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtension_get_MajorBuild_Proxy( 
    IFaxInboundRoutingExtension * This,
    /* [retval][out] */ long *plMajorBuild);


void __RPC_STUB IFaxInboundRoutingExtension_get_MajorBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtension_get_MinorBuild_Proxy( 
    IFaxInboundRoutingExtension * This,
    /* [retval][out] */ long *plMinorBuild);


void __RPC_STUB IFaxInboundRoutingExtension_get_MinorBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtension_get_Debug_Proxy( 
    IFaxInboundRoutingExtension * This,
    /* [retval][out] */ VARIANT_BOOL *pbDebug);


void __RPC_STUB IFaxInboundRoutingExtension_get_Debug_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtension_get_Status_Proxy( 
    IFaxInboundRoutingExtension * This,
    /* [retval][out] */ FAX_PROVIDER_STATUS_ENUM *pStatus);


void __RPC_STUB IFaxInboundRoutingExtension_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtension_get_InitErrorCode_Proxy( 
    IFaxInboundRoutingExtension * This,
    /* [retval][out] */ long *plInitErrorCode);


void __RPC_STUB IFaxInboundRoutingExtension_get_InitErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingExtension_get_Methods_Proxy( 
    IFaxInboundRoutingExtension * This,
    /* [retval][out] */ VARIANT *pvMethods);


void __RPC_STUB IFaxInboundRoutingExtension_get_Methods_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxInboundRoutingExtension_INTERFACE_DEFINED__ */


#ifndef __IFaxInboundRoutingMethods_INTERFACE_DEFINED__
#define __IFaxInboundRoutingMethods_INTERFACE_DEFINED__

/* interface IFaxInboundRoutingMethods */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxInboundRoutingMethods;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("783FCA10-8908-4473-9D69-F67FBEA0C6B9")
    IFaxInboundRoutingMethods : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxInboundRoutingMethod **pFaxInboundRoutingMethod) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxInboundRoutingMethodsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxInboundRoutingMethods * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxInboundRoutingMethods * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxInboundRoutingMethods * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxInboundRoutingMethods * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxInboundRoutingMethods * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxInboundRoutingMethods * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxInboundRoutingMethods * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFaxInboundRoutingMethods * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxInboundRoutingMethods * This,
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxInboundRoutingMethod **pFaxInboundRoutingMethod);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxInboundRoutingMethods * This,
            /* [retval][out] */ long *plCount);
        
        END_INTERFACE
    } IFaxInboundRoutingMethodsVtbl;

    interface IFaxInboundRoutingMethods
    {
        CONST_VTBL struct IFaxInboundRoutingMethodsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxInboundRoutingMethods_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxInboundRoutingMethods_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxInboundRoutingMethods_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxInboundRoutingMethods_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxInboundRoutingMethods_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxInboundRoutingMethods_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxInboundRoutingMethods_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxInboundRoutingMethods_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#define IFaxInboundRoutingMethods_get_Item(This,vIndex,pFaxInboundRoutingMethod)	\
    (This)->lpVtbl -> get_Item(This,vIndex,pFaxInboundRoutingMethod)

#define IFaxInboundRoutingMethods_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethods_get__NewEnum_Proxy( 
    IFaxInboundRoutingMethods * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFaxInboundRoutingMethods_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethods_get_Item_Proxy( 
    IFaxInboundRoutingMethods * This,
    /* [in] */ VARIANT vIndex,
    /* [retval][out] */ IFaxInboundRoutingMethod **pFaxInboundRoutingMethod);


void __RPC_STUB IFaxInboundRoutingMethods_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethods_get_Count_Proxy( 
    IFaxInboundRoutingMethods * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IFaxInboundRoutingMethods_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxInboundRoutingMethods_INTERFACE_DEFINED__ */


#ifndef __IFaxInboundRoutingMethod_INTERFACE_DEFINED__
#define __IFaxInboundRoutingMethod_INTERFACE_DEFINED__

/* interface IFaxInboundRoutingMethod */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxInboundRoutingMethod;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("45700061-AD9D-4776-A8C4-64065492CF4B")
    IFaxInboundRoutingMethod : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pbstrName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GUID( 
            /* [retval][out] */ BSTR *pbstrGUID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FunctionName( 
            /* [retval][out] */ BSTR *pbstrFunctionName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtensionFriendlyName( 
            /* [retval][out] */ BSTR *pbstrExtensionFriendlyName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtensionImageName( 
            /* [retval][out] */ BSTR *pbstrExtensionImageName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Priority( 
            /* [retval][out] */ long *plPriority) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Priority( 
            /* [in] */ long lPriority) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxInboundRoutingMethodVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxInboundRoutingMethod * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxInboundRoutingMethod * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxInboundRoutingMethod * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxInboundRoutingMethod * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxInboundRoutingMethod * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxInboundRoutingMethod * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxInboundRoutingMethod * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IFaxInboundRoutingMethod * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GUID )( 
            IFaxInboundRoutingMethod * This,
            /* [retval][out] */ BSTR *pbstrGUID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FunctionName )( 
            IFaxInboundRoutingMethod * This,
            /* [retval][out] */ BSTR *pbstrFunctionName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExtensionFriendlyName )( 
            IFaxInboundRoutingMethod * This,
            /* [retval][out] */ BSTR *pbstrExtensionFriendlyName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExtensionImageName )( 
            IFaxInboundRoutingMethod * This,
            /* [retval][out] */ BSTR *pbstrExtensionImageName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Priority )( 
            IFaxInboundRoutingMethod * This,
            /* [retval][out] */ long *plPriority);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Priority )( 
            IFaxInboundRoutingMethod * This,
            /* [in] */ long lPriority);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxInboundRoutingMethod * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IFaxInboundRoutingMethod * This);
        
        END_INTERFACE
    } IFaxInboundRoutingMethodVtbl;

    interface IFaxInboundRoutingMethod
    {
        CONST_VTBL struct IFaxInboundRoutingMethodVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxInboundRoutingMethod_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxInboundRoutingMethod_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxInboundRoutingMethod_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxInboundRoutingMethod_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxInboundRoutingMethod_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxInboundRoutingMethod_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxInboundRoutingMethod_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxInboundRoutingMethod_get_Name(This,pbstrName)	\
    (This)->lpVtbl -> get_Name(This,pbstrName)

#define IFaxInboundRoutingMethod_get_GUID(This,pbstrGUID)	\
    (This)->lpVtbl -> get_GUID(This,pbstrGUID)

#define IFaxInboundRoutingMethod_get_FunctionName(This,pbstrFunctionName)	\
    (This)->lpVtbl -> get_FunctionName(This,pbstrFunctionName)

#define IFaxInboundRoutingMethod_get_ExtensionFriendlyName(This,pbstrExtensionFriendlyName)	\
    (This)->lpVtbl -> get_ExtensionFriendlyName(This,pbstrExtensionFriendlyName)

#define IFaxInboundRoutingMethod_get_ExtensionImageName(This,pbstrExtensionImageName)	\
    (This)->lpVtbl -> get_ExtensionImageName(This,pbstrExtensionImageName)

#define IFaxInboundRoutingMethod_get_Priority(This,plPriority)	\
    (This)->lpVtbl -> get_Priority(This,plPriority)

#define IFaxInboundRoutingMethod_put_Priority(This,lPriority)	\
    (This)->lpVtbl -> put_Priority(This,lPriority)

#define IFaxInboundRoutingMethod_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxInboundRoutingMethod_Save(This)	\
    (This)->lpVtbl -> Save(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethod_get_Name_Proxy( 
    IFaxInboundRoutingMethod * This,
    /* [retval][out] */ BSTR *pbstrName);


void __RPC_STUB IFaxInboundRoutingMethod_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethod_get_GUID_Proxy( 
    IFaxInboundRoutingMethod * This,
    /* [retval][out] */ BSTR *pbstrGUID);


void __RPC_STUB IFaxInboundRoutingMethod_get_GUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethod_get_FunctionName_Proxy( 
    IFaxInboundRoutingMethod * This,
    /* [retval][out] */ BSTR *pbstrFunctionName);


void __RPC_STUB IFaxInboundRoutingMethod_get_FunctionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethod_get_ExtensionFriendlyName_Proxy( 
    IFaxInboundRoutingMethod * This,
    /* [retval][out] */ BSTR *pbstrExtensionFriendlyName);


void __RPC_STUB IFaxInboundRoutingMethod_get_ExtensionFriendlyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethod_get_ExtensionImageName_Proxy( 
    IFaxInboundRoutingMethod * This,
    /* [retval][out] */ BSTR *pbstrExtensionImageName);


void __RPC_STUB IFaxInboundRoutingMethod_get_ExtensionImageName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethod_get_Priority_Proxy( 
    IFaxInboundRoutingMethod * This,
    /* [retval][out] */ long *plPriority);


void __RPC_STUB IFaxInboundRoutingMethod_get_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethod_put_Priority_Proxy( 
    IFaxInboundRoutingMethod * This,
    /* [in] */ long lPriority);


void __RPC_STUB IFaxInboundRoutingMethod_put_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethod_Refresh_Proxy( 
    IFaxInboundRoutingMethod * This);


void __RPC_STUB IFaxInboundRoutingMethod_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxInboundRoutingMethod_Save_Proxy( 
    IFaxInboundRoutingMethod * This);


void __RPC_STUB IFaxInboundRoutingMethod_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxInboundRoutingMethod_INTERFACE_DEFINED__ */



#ifndef __FAXCOMEXLib_LIBRARY_DEFINED__
#define __FAXCOMEXLib_LIBRARY_DEFINED__

/* library FAXCOMEXLib */
/* [helpstring][version][uuid] */ 

typedef 
enum FAX_ROUTING_RULE_CODE_ENUM
    {	frrcANY_CODE	= 0
    } 	FAX_ROUTING_RULE_CODE_ENUM;


EXTERN_C const IID LIBID_FAXCOMEXLib;

#ifndef __IFaxServerNotify_DISPINTERFACE_DEFINED__
#define __IFaxServerNotify_DISPINTERFACE_DEFINED__

/* dispinterface IFaxServerNotify */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID_IFaxServerNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("2E037B27-CF8A-4abd-B1E0-5704943BEA6F")
    IFaxServerNotify : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IFaxServerNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxServerNotify * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxServerNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxServerNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxServerNotify * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxServerNotify * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxServerNotify * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxServerNotify * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IFaxServerNotifyVtbl;

    interface IFaxServerNotify
    {
        CONST_VTBL struct IFaxServerNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxServerNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxServerNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxServerNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxServerNotify_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxServerNotify_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxServerNotify_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxServerNotify_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IFaxServerNotify_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_FaxServer;

#ifdef __cplusplus

class DECLSPEC_UUID("CDA8ACB0-8CF5-4F6C-9BA2-5931D40C8CAE")
FaxServer;
#endif

EXTERN_C const CLSID CLSID_FaxDeviceProviders;

#ifdef __cplusplus

class DECLSPEC_UUID("EB8FE768-875A-4F5F-82C5-03F23AAC1BD7")
FaxDeviceProviders;
#endif

EXTERN_C const CLSID CLSID_FaxDevices;

#ifdef __cplusplus

class DECLSPEC_UUID("5589E28E-23CB-4919-8808-E6101846E80D")
FaxDevices;
#endif

EXTERN_C const CLSID CLSID_FaxInboundRouting;

#ifdef __cplusplus

class DECLSPEC_UUID("E80248ED-AD65-4218-8108-991924D4E7ED")
FaxInboundRouting;
#endif

EXTERN_C const CLSID CLSID_FaxFolders;

#ifdef __cplusplus

class DECLSPEC_UUID("C35211D7-5776-48CB-AF44-C31BE3B2CFE5")
FaxFolders;
#endif

EXTERN_C const CLSID CLSID_FaxLoggingOptions;

#ifdef __cplusplus

class DECLSPEC_UUID("1BF9EEA6-ECE0-4785-A18B-DE56E9EEF96A")
FaxLoggingOptions;
#endif

EXTERN_C const CLSID CLSID_FaxActivity;

#ifdef __cplusplus

class DECLSPEC_UUID("CFEF5D0E-E84D-462E-AABB-87D31EB04FEF")
FaxActivity;
#endif

EXTERN_C const CLSID CLSID_FaxOutboundRouting;

#ifdef __cplusplus

class DECLSPEC_UUID("C81B385E-B869-4AFD-86C0-616498ED9BE2")
FaxOutboundRouting;
#endif

EXTERN_C const CLSID CLSID_FaxReceiptOptions;

#ifdef __cplusplus

class DECLSPEC_UUID("6982487B-227B-4C96-A61C-248348B05AB6")
FaxReceiptOptions;
#endif

EXTERN_C const CLSID CLSID_FaxSecurity;

#ifdef __cplusplus

class DECLSPEC_UUID("10C4DDDE-ABF0-43DF-964F-7F3AC21A4C7B")
FaxSecurity;
#endif

EXTERN_C const CLSID CLSID_FaxDocument;

#ifdef __cplusplus

class DECLSPEC_UUID("0F3F9F91-C838-415E-A4F3-3E828CA445E0")
FaxDocument;
#endif

EXTERN_C const CLSID CLSID_FaxAttachments;

#ifdef __cplusplus

class DECLSPEC_UUID("27C8B712-5B26-4ABB-8F1B-0561C925ECF1")
FaxAttachments;
#endif

EXTERN_C const CLSID CLSID_FaxSender;

#ifdef __cplusplus

class DECLSPEC_UUID("265D84D0-1850-4360-B7C8-758BBB5F0B96")
FaxSender;
#endif

EXTERN_C const CLSID CLSID_FaxRecipients;

#ifdef __cplusplus

class DECLSPEC_UUID("EA9BDF53-10A9-4D4F-A067-63C8F84F01B0")
FaxRecipients;
#endif

EXTERN_C const CLSID CLSID_FaxIncomingArchive;

#ifdef __cplusplus

class DECLSPEC_UUID("8426C56A-35A1-4C6F-AF93-FC952422E2C2")
FaxIncomingArchive;
#endif

EXTERN_C const CLSID CLSID_FaxIncomingQueue;

#ifdef __cplusplus

class DECLSPEC_UUID("69131717-F3F1-40E3-809D-A6CBF7BD85E5")
FaxIncomingQueue;
#endif

EXTERN_C const CLSID CLSID_FaxOutgoingArchive;

#ifdef __cplusplus

class DECLSPEC_UUID("43C28403-E04F-474D-990C-B94669148F59")
FaxOutgoingArchive;
#endif

EXTERN_C const CLSID CLSID_FaxOutgoingQueue;

#ifdef __cplusplus

class DECLSPEC_UUID("7421169E-8C43-4B0D-BB16-645C8FA40357")
FaxOutgoingQueue;
#endif

EXTERN_C const CLSID CLSID_FaxIncomingMessageIterator;

#ifdef __cplusplus

class DECLSPEC_UUID("6088E1D8-3FC8-45C2-87B1-909A29607EA9")
FaxIncomingMessageIterator;
#endif

EXTERN_C const CLSID CLSID_FaxIncomingMessage;

#ifdef __cplusplus

class DECLSPEC_UUID("1932FCF7-9D43-4D5A-89FF-03861B321736")
FaxIncomingMessage;
#endif

EXTERN_C const CLSID CLSID_FaxOutgoingJobs;

#ifdef __cplusplus

class DECLSPEC_UUID("92BF2A6C-37BE-43FA-A37D-CB0E5F753B35")
FaxOutgoingJobs;
#endif

EXTERN_C const CLSID CLSID_FaxOutgoingJob;

#ifdef __cplusplus

class DECLSPEC_UUID("71BB429C-0EF9-4915-BEC5-A5D897A3E924")
FaxOutgoingJob;
#endif

EXTERN_C const CLSID CLSID_FaxOutgoingMessageIterator;

#ifdef __cplusplus

class DECLSPEC_UUID("8A3224D0-D30B-49DE-9813-CB385790FBBB")
FaxOutgoingMessageIterator;
#endif

EXTERN_C const CLSID CLSID_FaxOutgoingMessage;

#ifdef __cplusplus

class DECLSPEC_UUID("91B4A378-4AD8-4AEF-A4DC-97D96E939A3A")
FaxOutgoingMessage;
#endif

EXTERN_C const CLSID CLSID_FaxIncomingJobs;

#ifdef __cplusplus

class DECLSPEC_UUID("A1BB8A43-8866-4FB7-A15D-6266C875A5CC")
FaxIncomingJobs;
#endif

EXTERN_C const CLSID CLSID_FaxIncomingJob;

#ifdef __cplusplus

class DECLSPEC_UUID("C47311EC-AE32-41B8-AE4B-3EAE0629D0C9")
FaxIncomingJob;
#endif

EXTERN_C const CLSID CLSID_FaxDeviceProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("17CF1AA3-F5EB-484A-9C9A-4440A5BAABFC")
FaxDeviceProvider;
#endif

EXTERN_C const CLSID CLSID_FaxDevice;

#ifdef __cplusplus

class DECLSPEC_UUID("59E3A5B2-D676-484B-A6DE-720BFA89B5AF")
FaxDevice;
#endif

EXTERN_C const CLSID CLSID_FaxActivityLogging;

#ifdef __cplusplus

class DECLSPEC_UUID("F0A0294E-3BBD-48B8-8F13-8C591A55BDBC")
FaxActivityLogging;
#endif

EXTERN_C const CLSID CLSID_FaxEventLogging;

#ifdef __cplusplus

class DECLSPEC_UUID("A6850930-A0F6-4A6F-95B7-DB2EBF3D02E3")
FaxEventLogging;
#endif

EXTERN_C const CLSID CLSID_FaxOutboundRoutingGroups;

#ifdef __cplusplus

class DECLSPEC_UUID("CCBEA1A5-E2B4-4B57-9421-B04B6289464B")
FaxOutboundRoutingGroups;
#endif

EXTERN_C const CLSID CLSID_FaxOutboundRoutingGroup;

#ifdef __cplusplus

class DECLSPEC_UUID("0213F3E0-6791-4D77-A271-04D2357C50D6")
FaxOutboundRoutingGroup;
#endif

EXTERN_C const CLSID CLSID_FaxDeviceIds;

#ifdef __cplusplus

class DECLSPEC_UUID("CDC539EA-7277-460E-8DE0-48A0A5760D1F")
FaxDeviceIds;
#endif

EXTERN_C const CLSID CLSID_FaxOutboundRoutingRules;

#ifdef __cplusplus

class DECLSPEC_UUID("D385BECA-E624-4473-BFAA-9F4000831F54")
FaxOutboundRoutingRules;
#endif

EXTERN_C const CLSID CLSID_FaxOutboundRoutingRule;

#ifdef __cplusplus

class DECLSPEC_UUID("6549EEBF-08D1-475A-828B-3BF105952FA0")
FaxOutboundRoutingRule;
#endif

EXTERN_C const CLSID CLSID_FaxInboundRoutingExtensions;

#ifdef __cplusplus

class DECLSPEC_UUID("189A48ED-623C-4C0D-80F2-D66C7B9EFEC2")
FaxInboundRoutingExtensions;
#endif

EXTERN_C const CLSID CLSID_FaxInboundRoutingExtension;

#ifdef __cplusplus

class DECLSPEC_UUID("1D7DFB51-7207-4436-A0D9-24E32EE56988")
FaxInboundRoutingExtension;
#endif

EXTERN_C const CLSID CLSID_FaxInboundRoutingMethods;

#ifdef __cplusplus

class DECLSPEC_UUID("25FCB76A-B750-4B82-9266-FBBBAE8922BA")
FaxInboundRoutingMethods;
#endif

EXTERN_C const CLSID CLSID_FaxInboundRoutingMethod;

#ifdef __cplusplus

class DECLSPEC_UUID("4B9FD75C-0194-4B72-9CE5-02A8205AC7D4")
FaxInboundRoutingMethod;
#endif

EXTERN_C const CLSID CLSID_FaxJobStatus;

#ifdef __cplusplus

class DECLSPEC_UUID("7BF222F4-BE8D-442f-841D-6132742423BB")
FaxJobStatus;
#endif

EXTERN_C const CLSID CLSID_FaxRecipient;

#ifdef __cplusplus

class DECLSPEC_UUID("60BF3301-7DF8-4bd8-9148-7B5801F9EFDF")
FaxRecipient;
#endif
#endif /* __FAXCOMEXLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\amd64\chk\sdk\faxroute.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    faxroute.h

Abstract:

    This file contains the prototypes, etc for the
    FAX routing extension API.


--*/

#include <commctrl.h>

#ifndef _FAXROUTE_
#define _FAXROUTE_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


//
// microsoft routing guids
//

#define MS_FAXROUTE_PRINTING_GUID               TEXT("{aec1b37c-9af2-11d0-abf7-00c04fd91a4e}")
#define MS_FAXROUTE_FOLDER_GUID                 TEXT("{92041a90-9af2-11d0-abf7-00c04fd91a4e}")
#define MS_FAXROUTE_EMAIL_GUID                  TEXT("{6bbf7bfe-9af2-11d0-abf7-00c04fd91a4e}")

//
// callback routines
//

typedef LONG (WINAPI *PFAXROUTEADDFILE)(DWORD JobId, LPCWSTR FileName, GUID *Guid);
typedef LONG (WINAPI *PFAXROUTEDELETEFILE)(DWORD JobId, LPCWSTR FileName);
typedef BOOL (WINAPI *PFAXROUTEGETFILE)(DWORD JobId, DWORD Index, LPWSTR FileNameBuffer, LPDWORD RequiredSize);
typedef BOOL (WINAPI *PFAXROUTEENUMFILE)(DWORD JobId, GUID *GuidOwner, GUID *GuidCaller, LPCWSTR FileName, PVOID Context);
typedef BOOL (WINAPI *PFAXROUTEENUMFILES)(DWORD JobId, GUID *Guid,PFAXROUTEENUMFILE FileEnumerator, PVOID Context);
typedef BOOL (WINAPI *PFAXROUTEMODIFYROUTINGDATA)(DWORD JobId, LPCWSTR RoutingGuid, LPBYTE RoutingData, DWORD RoutingDataSize );


typedef struct _FAX_ROUTE_CALLBACKROUTINES {
    DWORD                       SizeOfStruct;                // size of the struct set by the fax service
    PFAXROUTEADDFILE            FaxRouteAddFile;
    PFAXROUTEDELETEFILE         FaxRouteDeleteFile;
    PFAXROUTEGETFILE            FaxRouteGetFile;
    PFAXROUTEENUMFILES          FaxRouteEnumFiles;
    PFAXROUTEMODIFYROUTINGDATA  FaxRouteModifyRoutingData;
} FAX_ROUTE_CALLBACKROUTINES, *PFAX_ROUTE_CALLBACKROUTINES;


//
// routing data structure
//

typedef struct _FAX_ROUTE {
    DWORD           SizeOfStruct;       // size of the struct set by the fax service
    DWORD           JobId;              // Fax job identifier
    DWORDLONG       ElapsedTime;        // Elapsed time for whole fax job in Coordinated Universal Time (UTC)
    DWORDLONG       ReceiveTime;        // Starting time for fax job in Coordinated Universal Time (UTC)
    DWORD           PageCount;          // Number of pages received
    LPCWSTR         Csid;               // Called station identifier
    LPCWSTR         Tsid;               // Transmitting station identifier
    LPCWSTR         CallerId;           // Caller id
    LPCWSTR         RoutingInfo;        // Routing info such as DID, T.30-subaddress, etc.
    LPCWSTR         ReceiverName;       // Receiver's name
    LPCWSTR         ReceiverNumber;     // Receiver's fax number
    LPCWSTR         DeviceName;         // Device name for the line that received the fax
    DWORD           DeviceId;           // Permenant line identifier for the receiving device
    LPBYTE          RoutingInfoData;    // Routing infor data to override configured info
    DWORD           RoutingInfoDataSize;// Size of routing info data
} FAX_ROUTE, *PFAX_ROUTE;

enum FAXROUTE_ENABLE {
    QUERY_STATUS = -1,
    STATUS_DISABLE = 0,
    STATUS_ENABLE = 1
};


//
// prototypes
//

BOOL WINAPI
FaxRouteInitialize(
    IN HANDLE HeapHandle,
    IN PFAX_ROUTE_CALLBACKROUTINES FaxRouteCallbackRoutines
    );

BOOL WINAPI
FaxRouteDeviceEnable(
    IN  LPCWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  LONG Enabled
    );

BOOL WINAPI
FaxRouteDeviceChangeNotification(
    IN  DWORD DeviceId,
    IN  BOOL  NewDevice
    );

BOOL WINAPI
FaxRouteGetRoutingInfo(
    IN  LPCWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  LPBYTE RoutingInfo,
    OUT LPDWORD RoutingInfoSize
    );

BOOL WINAPI
FaxRouteSetRoutingInfo(
    IN  LPCWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  const BYTE *RoutingInfo,
    IN  DWORD RoutingInfoSize
    );


typedef BOOL (WINAPI *PFAXROUTEINITIALIZE)               (HANDLE,PFAX_ROUTE_CALLBACKROUTINES);
typedef BOOL (WINAPI *PFAXROUTEMETHOD)                   (const FAX_ROUTE*,PVOID*,LPDWORD);
typedef BOOL (WINAPI *PFAXROUTEDEVICEENABLE)             (LPCWSTR,DWORD,LONG);
typedef BOOL (WINAPI *PFAXROUTEDEVICECHANGENOTIFICATION) (DWORD,BOOL);
typedef BOOL (WINAPI *PFAXROUTEGETROUTINGINFO)           (LPCWSTR,DWORD,LPBYTE,LPDWORD);
typedef BOOL (WINAPI *PFAXROUTESETROUTINGINFO)           (LPCWSTR,DWORD,const BYTE*,DWORD);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\amd64\chk\sdk\faxcom.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for faxcom.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __faxcom_h__
#define __faxcom_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IFaxTiff_FWD_DEFINED__
#define __IFaxTiff_FWD_DEFINED__
typedef interface IFaxTiff IFaxTiff;
#endif 	/* __IFaxTiff_FWD_DEFINED__ */


#ifndef __IFaxServer_FWD_DEFINED__
#define __IFaxServer_FWD_DEFINED__
typedef interface IFaxServer IFaxServer;
#endif 	/* __IFaxServer_FWD_DEFINED__ */


#ifndef __IFaxPort_FWD_DEFINED__
#define __IFaxPort_FWD_DEFINED__
typedef interface IFaxPort IFaxPort;
#endif 	/* __IFaxPort_FWD_DEFINED__ */


#ifndef __IFaxPorts_FWD_DEFINED__
#define __IFaxPorts_FWD_DEFINED__
typedef interface IFaxPorts IFaxPorts;
#endif 	/* __IFaxPorts_FWD_DEFINED__ */


#ifndef __IFaxRoutingMethod_FWD_DEFINED__
#define __IFaxRoutingMethod_FWD_DEFINED__
typedef interface IFaxRoutingMethod IFaxRoutingMethod;
#endif 	/* __IFaxRoutingMethod_FWD_DEFINED__ */


#ifndef __IFaxRoutingMethods_FWD_DEFINED__
#define __IFaxRoutingMethods_FWD_DEFINED__
typedef interface IFaxRoutingMethods IFaxRoutingMethods;
#endif 	/* __IFaxRoutingMethods_FWD_DEFINED__ */


#ifndef __IFaxStatus_FWD_DEFINED__
#define __IFaxStatus_FWD_DEFINED__
typedef interface IFaxStatus IFaxStatus;
#endif 	/* __IFaxStatus_FWD_DEFINED__ */


#ifndef __IFaxDoc_FWD_DEFINED__
#define __IFaxDoc_FWD_DEFINED__
typedef interface IFaxDoc IFaxDoc;
#endif 	/* __IFaxDoc_FWD_DEFINED__ */


#ifndef __IFaxJobs_FWD_DEFINED__
#define __IFaxJobs_FWD_DEFINED__
typedef interface IFaxJobs IFaxJobs;
#endif 	/* __IFaxJobs_FWD_DEFINED__ */


#ifndef __IFaxJob_FWD_DEFINED__
#define __IFaxJob_FWD_DEFINED__
typedef interface IFaxJob IFaxJob;
#endif 	/* __IFaxJob_FWD_DEFINED__ */


#ifndef __FaxTiff_FWD_DEFINED__
#define __FaxTiff_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxTiff FaxTiff;
#else
typedef struct FaxTiff FaxTiff;
#endif /* __cplusplus */

#endif 	/* __FaxTiff_FWD_DEFINED__ */


#ifndef __FaxServer_FWD_DEFINED__
#define __FaxServer_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxServer FaxServer;
#else
typedef struct FaxServer FaxServer;
#endif /* __cplusplus */

#endif 	/* __FaxServer_FWD_DEFINED__ */


#ifndef __FaxPort_FWD_DEFINED__
#define __FaxPort_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxPort FaxPort;
#else
typedef struct FaxPort FaxPort;
#endif /* __cplusplus */

#endif 	/* __FaxPort_FWD_DEFINED__ */


#ifndef __FaxPorts_FWD_DEFINED__
#define __FaxPorts_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxPorts FaxPorts;
#else
typedef struct FaxPorts FaxPorts;
#endif /* __cplusplus */

#endif 	/* __FaxPorts_FWD_DEFINED__ */


#ifndef __FaxRoutingMethod_FWD_DEFINED__
#define __FaxRoutingMethod_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxRoutingMethod FaxRoutingMethod;
#else
typedef struct FaxRoutingMethod FaxRoutingMethod;
#endif /* __cplusplus */

#endif 	/* __FaxRoutingMethod_FWD_DEFINED__ */


#ifndef __FaxRoutingMethods_FWD_DEFINED__
#define __FaxRoutingMethods_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxRoutingMethods FaxRoutingMethods;
#else
typedef struct FaxRoutingMethods FaxRoutingMethods;
#endif /* __cplusplus */

#endif 	/* __FaxRoutingMethods_FWD_DEFINED__ */


#ifndef __FaxStatus_FWD_DEFINED__
#define __FaxStatus_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxStatus FaxStatus;
#else
typedef struct FaxStatus FaxStatus;
#endif /* __cplusplus */

#endif 	/* __FaxStatus_FWD_DEFINED__ */


#ifndef __FaxDoc_FWD_DEFINED__
#define __FaxDoc_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxDoc FaxDoc;
#else
typedef struct FaxDoc FaxDoc;
#endif /* __cplusplus */

#endif 	/* __FaxDoc_FWD_DEFINED__ */


#ifndef __FaxJobs_FWD_DEFINED__
#define __FaxJobs_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxJobs FaxJobs;
#else
typedef struct FaxJobs FaxJobs;
#endif /* __cplusplus */

#endif 	/* __FaxJobs_FWD_DEFINED__ */


#ifndef __FaxJob_FWD_DEFINED__
#define __FaxJob_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxJob FaxJob;
#else
typedef struct FaxJob FaxJob;
#endif /* __cplusplus */

#endif 	/* __FaxJob_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IFaxTiff_INTERFACE_DEFINED__
#define __IFaxTiff_INTERFACE_DEFINED__

/* interface IFaxTiff */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxTiff;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b19bb45f-b91c-11d1-83e1-00c04fb6e984")
    IFaxTiff : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReceiveTime( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Image( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Image( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Routing( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallerId( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Csid( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Tsid( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientNumber( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RawReceiveTime( 
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TiffTagString( 
            /* [in] */ int tagID,
            /* [retval][out] */ BSTR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxTiffVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxTiff * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxTiff * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxTiff * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxTiff * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxTiff * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxTiff * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxTiff * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReceiveTime )( 
            IFaxTiff * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Image )( 
            IFaxTiff * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Image )( 
            IFaxTiff * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientName )( 
            IFaxTiff * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderName )( 
            IFaxTiff * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Routing )( 
            IFaxTiff * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallerId )( 
            IFaxTiff * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Csid )( 
            IFaxTiff * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Tsid )( 
            IFaxTiff * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientNumber )( 
            IFaxTiff * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawReceiveTime )( 
            IFaxTiff * This,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TiffTagString )( 
            IFaxTiff * This,
            /* [in] */ int tagID,
            /* [retval][out] */ BSTR *pVal);
        
        END_INTERFACE
    } IFaxTiffVtbl;

    interface IFaxTiff
    {
        CONST_VTBL struct IFaxTiffVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxTiff_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxTiff_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxTiff_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxTiff_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxTiff_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxTiff_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxTiff_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxTiff_get_ReceiveTime(This,pVal)	\
    (This)->lpVtbl -> get_ReceiveTime(This,pVal)

#define IFaxTiff_get_Image(This,pVal)	\
    (This)->lpVtbl -> get_Image(This,pVal)

#define IFaxTiff_put_Image(This,newVal)	\
    (This)->lpVtbl -> put_Image(This,newVal)

#define IFaxTiff_get_RecipientName(This,pVal)	\
    (This)->lpVtbl -> get_RecipientName(This,pVal)

#define IFaxTiff_get_SenderName(This,pVal)	\
    (This)->lpVtbl -> get_SenderName(This,pVal)

#define IFaxTiff_get_Routing(This,pVal)	\
    (This)->lpVtbl -> get_Routing(This,pVal)

#define IFaxTiff_get_CallerId(This,pVal)	\
    (This)->lpVtbl -> get_CallerId(This,pVal)

#define IFaxTiff_get_Csid(This,pVal)	\
    (This)->lpVtbl -> get_Csid(This,pVal)

#define IFaxTiff_get_Tsid(This,pVal)	\
    (This)->lpVtbl -> get_Tsid(This,pVal)

#define IFaxTiff_get_RecipientNumber(This,pVal)	\
    (This)->lpVtbl -> get_RecipientNumber(This,pVal)

#define IFaxTiff_get_RawReceiveTime(This,pVal)	\
    (This)->lpVtbl -> get_RawReceiveTime(This,pVal)

#define IFaxTiff_get_TiffTagString(This,tagID,pVal)	\
    (This)->lpVtbl -> get_TiffTagString(This,tagID,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_ReceiveTime_Proxy( 
    IFaxTiff * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxTiff_get_ReceiveTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_Image_Proxy( 
    IFaxTiff * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxTiff_get_Image_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxTiff_put_Image_Proxy( 
    IFaxTiff * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxTiff_put_Image_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_RecipientName_Proxy( 
    IFaxTiff * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxTiff_get_RecipientName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_SenderName_Proxy( 
    IFaxTiff * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxTiff_get_SenderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_Routing_Proxy( 
    IFaxTiff * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxTiff_get_Routing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_CallerId_Proxy( 
    IFaxTiff * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxTiff_get_CallerId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_Csid_Proxy( 
    IFaxTiff * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxTiff_get_Csid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_Tsid_Proxy( 
    IFaxTiff * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxTiff_get_Tsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_RecipientNumber_Proxy( 
    IFaxTiff * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxTiff_get_RecipientNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_RawReceiveTime_Proxy( 
    IFaxTiff * This,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IFaxTiff_get_RawReceiveTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_TiffTagString_Proxy( 
    IFaxTiff * This,
    /* [in] */ int tagID,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxTiff_get_TiffTagString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxTiff_INTERFACE_DEFINED__ */


#ifndef __IFaxServer_INTERFACE_DEFINED__
#define __IFaxServer_INTERFACE_DEFINED__

/* interface IFaxServer */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D73733C7-CC80-11D0-B225-00C04FB6C2F5")
    IFaxServer : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            BSTR ServerName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPorts( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateDocument( 
            BSTR FileName,
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetJobs( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Retries( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Retries( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RetryDelay( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RetryDelay( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DirtyDays( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DirtyDays( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Branding( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Branding( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UseDeviceTsid( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UseDeviceTsid( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ServerCoverpage( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ServerCoverpage( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PauseServerQueue( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PauseServerQueue( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ArchiveOutboundFaxes( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ArchiveOutboundFaxes( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ArchiveDirectory( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ArchiveDirectory( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ServerMapiProfile( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ServerMapiProfile( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscountRateStartHour( 
            /* [retval][out] */ short *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DiscountRateStartHour( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscountRateStartMinute( 
            /* [retval][out] */ short *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DiscountRateStartMinute( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscountRateEndHour( 
            /* [retval][out] */ short *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DiscountRateEndHour( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscountRateEndMinute( 
            /* [retval][out] */ short *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DiscountRateEndMinute( 
            /* [in] */ short newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxServer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxServer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxServer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxServer * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxServer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxServer * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxServer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IFaxServer * This,
            BSTR ServerName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IFaxServer * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPorts )( 
            IFaxServer * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateDocument )( 
            IFaxServer * This,
            BSTR FileName,
            /* [retval][out] */ VARIANT *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetJobs )( 
            IFaxServer * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Retries )( 
            IFaxServer * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Retries )( 
            IFaxServer * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RetryDelay )( 
            IFaxServer * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RetryDelay )( 
            IFaxServer * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DirtyDays )( 
            IFaxServer * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DirtyDays )( 
            IFaxServer * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Branding )( 
            IFaxServer * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Branding )( 
            IFaxServer * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseDeviceTsid )( 
            IFaxServer * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseDeviceTsid )( 
            IFaxServer * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServerCoverpage )( 
            IFaxServer * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ServerCoverpage )( 
            IFaxServer * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PauseServerQueue )( 
            IFaxServer * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PauseServerQueue )( 
            IFaxServer * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ArchiveOutboundFaxes )( 
            IFaxServer * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ArchiveOutboundFaxes )( 
            IFaxServer * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ArchiveDirectory )( 
            IFaxServer * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ArchiveDirectory )( 
            IFaxServer * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServerMapiProfile )( 
            IFaxServer * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ServerMapiProfile )( 
            IFaxServer * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiscountRateStartHour )( 
            IFaxServer * This,
            /* [retval][out] */ short *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DiscountRateStartHour )( 
            IFaxServer * This,
            /* [in] */ short newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiscountRateStartMinute )( 
            IFaxServer * This,
            /* [retval][out] */ short *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DiscountRateStartMinute )( 
            IFaxServer * This,
            /* [in] */ short newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiscountRateEndHour )( 
            IFaxServer * This,
            /* [retval][out] */ short *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DiscountRateEndHour )( 
            IFaxServer * This,
            /* [in] */ short newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiscountRateEndMinute )( 
            IFaxServer * This,
            /* [retval][out] */ short *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DiscountRateEndMinute )( 
            IFaxServer * This,
            /* [in] */ short newVal);
        
        END_INTERFACE
    } IFaxServerVtbl;

    interface IFaxServer
    {
        CONST_VTBL struct IFaxServerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxServer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxServer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxServer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxServer_Connect(This,ServerName)	\
    (This)->lpVtbl -> Connect(This,ServerName)

#define IFaxServer_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IFaxServer_GetPorts(This,retval)	\
    (This)->lpVtbl -> GetPorts(This,retval)

#define IFaxServer_CreateDocument(This,FileName,retval)	\
    (This)->lpVtbl -> CreateDocument(This,FileName,retval)

#define IFaxServer_GetJobs(This,retval)	\
    (This)->lpVtbl -> GetJobs(This,retval)

#define IFaxServer_get_Retries(This,pVal)	\
    (This)->lpVtbl -> get_Retries(This,pVal)

#define IFaxServer_put_Retries(This,newVal)	\
    (This)->lpVtbl -> put_Retries(This,newVal)

#define IFaxServer_get_RetryDelay(This,pVal)	\
    (This)->lpVtbl -> get_RetryDelay(This,pVal)

#define IFaxServer_put_RetryDelay(This,newVal)	\
    (This)->lpVtbl -> put_RetryDelay(This,newVal)

#define IFaxServer_get_DirtyDays(This,pVal)	\
    (This)->lpVtbl -> get_DirtyDays(This,pVal)

#define IFaxServer_put_DirtyDays(This,newVal)	\
    (This)->lpVtbl -> put_DirtyDays(This,newVal)

#define IFaxServer_get_Branding(This,pVal)	\
    (This)->lpVtbl -> get_Branding(This,pVal)

#define IFaxServer_put_Branding(This,newVal)	\
    (This)->lpVtbl -> put_Branding(This,newVal)

#define IFaxServer_get_UseDeviceTsid(This,pVal)	\
    (This)->lpVtbl -> get_UseDeviceTsid(This,pVal)

#define IFaxServer_put_UseDeviceTsid(This,newVal)	\
    (This)->lpVtbl -> put_UseDeviceTsid(This,newVal)

#define IFaxServer_get_ServerCoverpage(This,pVal)	\
    (This)->lpVtbl -> get_ServerCoverpage(This,pVal)

#define IFaxServer_put_ServerCoverpage(This,newVal)	\
    (This)->lpVtbl -> put_ServerCoverpage(This,newVal)

#define IFaxServer_get_PauseServerQueue(This,pVal)	\
    (This)->lpVtbl -> get_PauseServerQueue(This,pVal)

#define IFaxServer_put_PauseServerQueue(This,newVal)	\
    (This)->lpVtbl -> put_PauseServerQueue(This,newVal)

#define IFaxServer_get_ArchiveOutboundFaxes(This,pVal)	\
    (This)->lpVtbl -> get_ArchiveOutboundFaxes(This,pVal)

#define IFaxServer_put_ArchiveOutboundFaxes(This,newVal)	\
    (This)->lpVtbl -> put_ArchiveOutboundFaxes(This,newVal)

#define IFaxServer_get_ArchiveDirectory(This,pVal)	\
    (This)->lpVtbl -> get_ArchiveDirectory(This,pVal)

#define IFaxServer_put_ArchiveDirectory(This,newVal)	\
    (This)->lpVtbl -> put_ArchiveDirectory(This,newVal)

#define IFaxServer_get_ServerMapiProfile(This,pVal)	\
    (This)->lpVtbl -> get_ServerMapiProfile(This,pVal)

#define IFaxServer_put_ServerMapiProfile(This,newVal)	\
    (This)->lpVtbl -> put_ServerMapiProfile(This,newVal)

#define IFaxServer_get_DiscountRateStartHour(This,pVal)	\
    (This)->lpVtbl -> get_DiscountRateStartHour(This,pVal)

#define IFaxServer_put_DiscountRateStartHour(This,newVal)	\
    (This)->lpVtbl -> put_DiscountRateStartHour(This,newVal)

#define IFaxServer_get_DiscountRateStartMinute(This,pVal)	\
    (This)->lpVtbl -> get_DiscountRateStartMinute(This,pVal)

#define IFaxServer_put_DiscountRateStartMinute(This,newVal)	\
    (This)->lpVtbl -> put_DiscountRateStartMinute(This,newVal)

#define IFaxServer_get_DiscountRateEndHour(This,pVal)	\
    (This)->lpVtbl -> get_DiscountRateEndHour(This,pVal)

#define IFaxServer_put_DiscountRateEndHour(This,newVal)	\
    (This)->lpVtbl -> put_DiscountRateEndHour(This,newVal)

#define IFaxServer_get_DiscountRateEndMinute(This,pVal)	\
    (This)->lpVtbl -> get_DiscountRateEndMinute(This,pVal)

#define IFaxServer_put_DiscountRateEndMinute(This,newVal)	\
    (This)->lpVtbl -> put_DiscountRateEndMinute(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_Connect_Proxy( 
    IFaxServer * This,
    BSTR ServerName);


void __RPC_STUB IFaxServer_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_Disconnect_Proxy( 
    IFaxServer * This);


void __RPC_STUB IFaxServer_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_GetPorts_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IFaxServer_GetPorts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_CreateDocument_Proxy( 
    IFaxServer * This,
    BSTR FileName,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IFaxServer_CreateDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_GetJobs_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IFaxServer_GetJobs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_Retries_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxServer_get_Retries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_Retries_Proxy( 
    IFaxServer * This,
    /* [in] */ long newVal);


void __RPC_STUB IFaxServer_put_Retries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_RetryDelay_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxServer_get_RetryDelay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_RetryDelay_Proxy( 
    IFaxServer * This,
    /* [in] */ long newVal);


void __RPC_STUB IFaxServer_put_RetryDelay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_DirtyDays_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxServer_get_DirtyDays_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_DirtyDays_Proxy( 
    IFaxServer * This,
    /* [in] */ long newVal);


void __RPC_STUB IFaxServer_put_DirtyDays_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_Branding_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxServer_get_Branding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_Branding_Proxy( 
    IFaxServer * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxServer_put_Branding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_UseDeviceTsid_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxServer_get_UseDeviceTsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_UseDeviceTsid_Proxy( 
    IFaxServer * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxServer_put_UseDeviceTsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_ServerCoverpage_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxServer_get_ServerCoverpage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_ServerCoverpage_Proxy( 
    IFaxServer * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxServer_put_ServerCoverpage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_PauseServerQueue_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxServer_get_PauseServerQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_PauseServerQueue_Proxy( 
    IFaxServer * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxServer_put_PauseServerQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_ArchiveOutboundFaxes_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxServer_get_ArchiveOutboundFaxes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_ArchiveOutboundFaxes_Proxy( 
    IFaxServer * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxServer_put_ArchiveOutboundFaxes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_ArchiveDirectory_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxServer_get_ArchiveDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_ArchiveDirectory_Proxy( 
    IFaxServer * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxServer_put_ArchiveDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_ServerMapiProfile_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxServer_get_ServerMapiProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_ServerMapiProfile_Proxy( 
    IFaxServer * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxServer_put_ServerMapiProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_DiscountRateStartHour_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ short *pVal);


void __RPC_STUB IFaxServer_get_DiscountRateStartHour_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_DiscountRateStartHour_Proxy( 
    IFaxServer * This,
    /* [in] */ short newVal);


void __RPC_STUB IFaxServer_put_DiscountRateStartHour_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_DiscountRateStartMinute_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ short *pVal);


void __RPC_STUB IFaxServer_get_DiscountRateStartMinute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_DiscountRateStartMinute_Proxy( 
    IFaxServer * This,
    /* [in] */ short newVal);


void __RPC_STUB IFaxServer_put_DiscountRateStartMinute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_DiscountRateEndHour_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ short *pVal);


void __RPC_STUB IFaxServer_get_DiscountRateEndHour_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_DiscountRateEndHour_Proxy( 
    IFaxServer * This,
    /* [in] */ short newVal);


void __RPC_STUB IFaxServer_put_DiscountRateEndHour_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_DiscountRateEndMinute_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ short *pVal);


void __RPC_STUB IFaxServer_get_DiscountRateEndMinute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_DiscountRateEndMinute_Proxy( 
    IFaxServer * This,
    /* [in] */ short newVal);


void __RPC_STUB IFaxServer_put_DiscountRateEndMinute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxServer_INTERFACE_DEFINED__ */


#ifndef __IFaxPort_INTERFACE_DEFINED__
#define __IFaxPort_INTERFACE_DEFINED__

/* interface IFaxPort */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxPort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D73733CC-CC80-11D0-B225-00C04FB6C2F5")
    IFaxPort : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceId( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Rings( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Rings( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Csid( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Csid( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Tsid( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Tsid( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Send( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Send( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Receive( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Receive( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Priority( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Priority( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetRoutingMethods( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CanModify( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxPortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxPort * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxPort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxPort * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxPort * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxPort * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxPort * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxPort * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IFaxPort * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceId )( 
            IFaxPort * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Rings )( 
            IFaxPort * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Rings )( 
            IFaxPort * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Csid )( 
            IFaxPort * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Csid )( 
            IFaxPort * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Tsid )( 
            IFaxPort * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Tsid )( 
            IFaxPort * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Send )( 
            IFaxPort * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Send )( 
            IFaxPort * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Receive )( 
            IFaxPort * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Receive )( 
            IFaxPort * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Priority )( 
            IFaxPort * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Priority )( 
            IFaxPort * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetRoutingMethods )( 
            IFaxPort * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanModify )( 
            IFaxPort * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IFaxPort * This,
            /* [retval][out] */ VARIANT *retval);
        
        END_INTERFACE
    } IFaxPortVtbl;

    interface IFaxPort
    {
        CONST_VTBL struct IFaxPortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxPort_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxPort_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxPort_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxPort_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxPort_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxPort_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxPort_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxPort_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IFaxPort_get_DeviceId(This,pVal)	\
    (This)->lpVtbl -> get_DeviceId(This,pVal)

#define IFaxPort_get_Rings(This,pVal)	\
    (This)->lpVtbl -> get_Rings(This,pVal)

#define IFaxPort_put_Rings(This,newVal)	\
    (This)->lpVtbl -> put_Rings(This,newVal)

#define IFaxPort_get_Csid(This,pVal)	\
    (This)->lpVtbl -> get_Csid(This,pVal)

#define IFaxPort_put_Csid(This,newVal)	\
    (This)->lpVtbl -> put_Csid(This,newVal)

#define IFaxPort_get_Tsid(This,pVal)	\
    (This)->lpVtbl -> get_Tsid(This,pVal)

#define IFaxPort_put_Tsid(This,newVal)	\
    (This)->lpVtbl -> put_Tsid(This,newVal)

#define IFaxPort_get_Send(This,pVal)	\
    (This)->lpVtbl -> get_Send(This,pVal)

#define IFaxPort_put_Send(This,newVal)	\
    (This)->lpVtbl -> put_Send(This,newVal)

#define IFaxPort_get_Receive(This,pVal)	\
    (This)->lpVtbl -> get_Receive(This,pVal)

#define IFaxPort_put_Receive(This,newVal)	\
    (This)->lpVtbl -> put_Receive(This,newVal)

#define IFaxPort_get_Priority(This,pVal)	\
    (This)->lpVtbl -> get_Priority(This,pVal)

#define IFaxPort_put_Priority(This,newVal)	\
    (This)->lpVtbl -> put_Priority(This,newVal)

#define IFaxPort_GetRoutingMethods(This,retval)	\
    (This)->lpVtbl -> GetRoutingMethods(This,retval)

#define IFaxPort_get_CanModify(This,pVal)	\
    (This)->lpVtbl -> get_CanModify(This,pVal)

#define IFaxPort_GetStatus(This,retval)	\
    (This)->lpVtbl -> GetStatus(This,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_Name_Proxy( 
    IFaxPort * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxPort_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_DeviceId_Proxy( 
    IFaxPort * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxPort_get_DeviceId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_Rings_Proxy( 
    IFaxPort * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxPort_get_Rings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxPort_put_Rings_Proxy( 
    IFaxPort * This,
    /* [in] */ long newVal);


void __RPC_STUB IFaxPort_put_Rings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_Csid_Proxy( 
    IFaxPort * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxPort_get_Csid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxPort_put_Csid_Proxy( 
    IFaxPort * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxPort_put_Csid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_Tsid_Proxy( 
    IFaxPort * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxPort_get_Tsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxPort_put_Tsid_Proxy( 
    IFaxPort * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxPort_put_Tsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_Send_Proxy( 
    IFaxPort * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxPort_get_Send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxPort_put_Send_Proxy( 
    IFaxPort * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxPort_put_Send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_Receive_Proxy( 
    IFaxPort * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxPort_get_Receive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxPort_put_Receive_Proxy( 
    IFaxPort * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxPort_put_Receive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_Priority_Proxy( 
    IFaxPort * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxPort_get_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxPort_put_Priority_Proxy( 
    IFaxPort * This,
    /* [in] */ long newVal);


void __RPC_STUB IFaxPort_put_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxPort_GetRoutingMethods_Proxy( 
    IFaxPort * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IFaxPort_GetRoutingMethods_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_CanModify_Proxy( 
    IFaxPort * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxPort_get_CanModify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxPort_GetStatus_Proxy( 
    IFaxPort * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IFaxPort_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxPort_INTERFACE_DEFINED__ */


#ifndef __IFaxPorts_INTERFACE_DEFINED__
#define __IFaxPorts_INTERFACE_DEFINED__

/* interface IFaxPorts */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxPorts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D73733D5-CC80-11D0-B225-00C04FB6C2F5")
    IFaxPorts : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            long Index,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxPortsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxPorts * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxPorts * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxPorts * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxPorts * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxPorts * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxPorts * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxPorts * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxPorts * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxPorts * This,
            long Index,
            /* [retval][out] */ VARIANT *pVal);
        
        END_INTERFACE
    } IFaxPortsVtbl;

    interface IFaxPorts
    {
        CONST_VTBL struct IFaxPortsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxPorts_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxPorts_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxPorts_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxPorts_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxPorts_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxPorts_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxPorts_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxPorts_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IFaxPorts_get_Item(This,Index,pVal)	\
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPorts_get_Count_Proxy( 
    IFaxPorts * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxPorts_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPorts_get_Item_Proxy( 
    IFaxPorts * This,
    long Index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IFaxPorts_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxPorts_INTERFACE_DEFINED__ */


#ifndef __IFaxRoutingMethod_INTERFACE_DEFINED__
#define __IFaxRoutingMethod_INTERFACE_DEFINED__

/* interface IFaxRoutingMethod */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxRoutingMethod;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2199F5F3-CEFC-11D0-A341-0000F800E68D")
    IFaxRoutingMethod : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceId( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Enable( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Enable( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Guid( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FunctionName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ImageName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FriendlyName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtensionName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RoutingData( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxRoutingMethodVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxRoutingMethod * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxRoutingMethod * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxRoutingMethod * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxRoutingMethod * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxRoutingMethod * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxRoutingMethod * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxRoutingMethod * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceId )( 
            IFaxRoutingMethod * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Enable )( 
            IFaxRoutingMethod * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Enable )( 
            IFaxRoutingMethod * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceName )( 
            IFaxRoutingMethod * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Guid )( 
            IFaxRoutingMethod * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FunctionName )( 
            IFaxRoutingMethod * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ImageName )( 
            IFaxRoutingMethod * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FriendlyName )( 
            IFaxRoutingMethod * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExtensionName )( 
            IFaxRoutingMethod * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RoutingData )( 
            IFaxRoutingMethod * This,
            /* [retval][out] */ BSTR *pVal);
        
        END_INTERFACE
    } IFaxRoutingMethodVtbl;

    interface IFaxRoutingMethod
    {
        CONST_VTBL struct IFaxRoutingMethodVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxRoutingMethod_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxRoutingMethod_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxRoutingMethod_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxRoutingMethod_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxRoutingMethod_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxRoutingMethod_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxRoutingMethod_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxRoutingMethod_get_DeviceId(This,pVal)	\
    (This)->lpVtbl -> get_DeviceId(This,pVal)

#define IFaxRoutingMethod_get_Enable(This,pVal)	\
    (This)->lpVtbl -> get_Enable(This,pVal)

#define IFaxRoutingMethod_put_Enable(This,newVal)	\
    (This)->lpVtbl -> put_Enable(This,newVal)

#define IFaxRoutingMethod_get_DeviceName(This,pVal)	\
    (This)->lpVtbl -> get_DeviceName(This,pVal)

#define IFaxRoutingMethod_get_Guid(This,pVal)	\
    (This)->lpVtbl -> get_Guid(This,pVal)

#define IFaxRoutingMethod_get_FunctionName(This,pVal)	\
    (This)->lpVtbl -> get_FunctionName(This,pVal)

#define IFaxRoutingMethod_get_ImageName(This,pVal)	\
    (This)->lpVtbl -> get_ImageName(This,pVal)

#define IFaxRoutingMethod_get_FriendlyName(This,pVal)	\
    (This)->lpVtbl -> get_FriendlyName(This,pVal)

#define IFaxRoutingMethod_get_ExtensionName(This,pVal)	\
    (This)->lpVtbl -> get_ExtensionName(This,pVal)

#define IFaxRoutingMethod_get_RoutingData(This,pVal)	\
    (This)->lpVtbl -> get_RoutingData(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_DeviceId_Proxy( 
    IFaxRoutingMethod * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxRoutingMethod_get_DeviceId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_Enable_Proxy( 
    IFaxRoutingMethod * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxRoutingMethod_get_Enable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_put_Enable_Proxy( 
    IFaxRoutingMethod * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxRoutingMethod_put_Enable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_DeviceName_Proxy( 
    IFaxRoutingMethod * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxRoutingMethod_get_DeviceName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_Guid_Proxy( 
    IFaxRoutingMethod * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxRoutingMethod_get_Guid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_FunctionName_Proxy( 
    IFaxRoutingMethod * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxRoutingMethod_get_FunctionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_ImageName_Proxy( 
    IFaxRoutingMethod * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxRoutingMethod_get_ImageName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_FriendlyName_Proxy( 
    IFaxRoutingMethod * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxRoutingMethod_get_FriendlyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_ExtensionName_Proxy( 
    IFaxRoutingMethod * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxRoutingMethod_get_ExtensionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_RoutingData_Proxy( 
    IFaxRoutingMethod * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxRoutingMethod_get_RoutingData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxRoutingMethod_INTERFACE_DEFINED__ */


#ifndef __IFaxRoutingMethods_INTERFACE_DEFINED__
#define __IFaxRoutingMethods_INTERFACE_DEFINED__

/* interface IFaxRoutingMethods */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxRoutingMethods;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2199F5F5-CEFC-11D0-A341-0000F800E68D")
    IFaxRoutingMethods : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxRoutingMethodsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxRoutingMethods * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxRoutingMethods * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxRoutingMethods * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxRoutingMethods * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxRoutingMethods * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxRoutingMethods * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxRoutingMethods * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxRoutingMethods * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxRoutingMethods * This,
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal);
        
        END_INTERFACE
    } IFaxRoutingMethodsVtbl;

    interface IFaxRoutingMethods
    {
        CONST_VTBL struct IFaxRoutingMethodsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxRoutingMethods_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxRoutingMethods_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxRoutingMethods_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxRoutingMethods_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxRoutingMethods_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxRoutingMethods_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxRoutingMethods_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxRoutingMethods_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IFaxRoutingMethods_get_Item(This,Index,pVal)	\
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethods_get_Count_Proxy( 
    IFaxRoutingMethods * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxRoutingMethods_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethods_get_Item_Proxy( 
    IFaxRoutingMethods * This,
    /* [in] */ long Index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IFaxRoutingMethods_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxRoutingMethods_INTERFACE_DEFINED__ */


#ifndef __IFaxStatus_INTERFACE_DEFINED__
#define __IFaxStatus_INTERFACE_DEFINED__

/* interface IFaxStatus */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8B97E605-D054-11D0-B226-00C04FB6C2F5")
    IFaxStatus : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallerId( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Csid( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPage( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceId( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DocumentName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Send( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Receive( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Address( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RoutingString( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DocumentSize( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PageCount( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Tsid( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartTime( 
            /* [retval][out] */ DATE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubmittedTime( 
            /* [retval][out] */ DATE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ElapsedTime( 
            /* [retval][out] */ DATE *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxStatus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxStatus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxStatus * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxStatus * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxStatus * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxStatus * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxStatus * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallerId )( 
            IFaxStatus * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Csid )( 
            IFaxStatus * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPage )( 
            IFaxStatus * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceId )( 
            IFaxStatus * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceName )( 
            IFaxStatus * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocumentName )( 
            IFaxStatus * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Send )( 
            IFaxStatus * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Receive )( 
            IFaxStatus * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Address )( 
            IFaxStatus * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RoutingString )( 
            IFaxStatus * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderName )( 
            IFaxStatus * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientName )( 
            IFaxStatus * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocumentSize )( 
            IFaxStatus * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IFaxStatus * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PageCount )( 
            IFaxStatus * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Tsid )( 
            IFaxStatus * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartTime )( 
            IFaxStatus * This,
            /* [retval][out] */ DATE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubmittedTime )( 
            IFaxStatus * This,
            /* [retval][out] */ DATE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ElapsedTime )( 
            IFaxStatus * This,
            /* [retval][out] */ DATE *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxStatus * This);
        
        END_INTERFACE
    } IFaxStatusVtbl;

    interface IFaxStatus
    {
        CONST_VTBL struct IFaxStatusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxStatus_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxStatus_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxStatus_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxStatus_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxStatus_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxStatus_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxStatus_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxStatus_get_CallerId(This,pVal)	\
    (This)->lpVtbl -> get_CallerId(This,pVal)

#define IFaxStatus_get_Csid(This,pVal)	\
    (This)->lpVtbl -> get_Csid(This,pVal)

#define IFaxStatus_get_CurrentPage(This,pVal)	\
    (This)->lpVtbl -> get_CurrentPage(This,pVal)

#define IFaxStatus_get_DeviceId(This,pVal)	\
    (This)->lpVtbl -> get_DeviceId(This,pVal)

#define IFaxStatus_get_DeviceName(This,pVal)	\
    (This)->lpVtbl -> get_DeviceName(This,pVal)

#define IFaxStatus_get_DocumentName(This,pVal)	\
    (This)->lpVtbl -> get_DocumentName(This,pVal)

#define IFaxStatus_get_Send(This,pVal)	\
    (This)->lpVtbl -> get_Send(This,pVal)

#define IFaxStatus_get_Receive(This,pVal)	\
    (This)->lpVtbl -> get_Receive(This,pVal)

#define IFaxStatus_get_Address(This,pVal)	\
    (This)->lpVtbl -> get_Address(This,pVal)

#define IFaxStatus_get_RoutingString(This,pVal)	\
    (This)->lpVtbl -> get_RoutingString(This,pVal)

#define IFaxStatus_get_SenderName(This,pVal)	\
    (This)->lpVtbl -> get_SenderName(This,pVal)

#define IFaxStatus_get_RecipientName(This,pVal)	\
    (This)->lpVtbl -> get_RecipientName(This,pVal)

#define IFaxStatus_get_DocumentSize(This,pVal)	\
    (This)->lpVtbl -> get_DocumentSize(This,pVal)

#define IFaxStatus_get_Description(This,pVal)	\
    (This)->lpVtbl -> get_Description(This,pVal)

#define IFaxStatus_get_PageCount(This,pVal)	\
    (This)->lpVtbl -> get_PageCount(This,pVal)

#define IFaxStatus_get_Tsid(This,pVal)	\
    (This)->lpVtbl -> get_Tsid(This,pVal)

#define IFaxStatus_get_StartTime(This,pVal)	\
    (This)->lpVtbl -> get_StartTime(This,pVal)

#define IFaxStatus_get_SubmittedTime(This,pVal)	\
    (This)->lpVtbl -> get_SubmittedTime(This,pVal)

#define IFaxStatus_get_ElapsedTime(This,pVal)	\
    (This)->lpVtbl -> get_ElapsedTime(This,pVal)

#define IFaxStatus_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_CallerId_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxStatus_get_CallerId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_Csid_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxStatus_get_Csid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_CurrentPage_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxStatus_get_CurrentPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_DeviceId_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxStatus_get_DeviceId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_DeviceName_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxStatus_get_DeviceName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_DocumentName_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxStatus_get_DocumentName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_Send_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxStatus_get_Send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_Receive_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxStatus_get_Receive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_Address_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxStatus_get_Address_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_RoutingString_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxStatus_get_RoutingString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_SenderName_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxStatus_get_SenderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_RecipientName_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxStatus_get_RecipientName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_DocumentSize_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxStatus_get_DocumentSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_Description_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxStatus_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_PageCount_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxStatus_get_PageCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_Tsid_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxStatus_get_Tsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_StartTime_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ DATE *pVal);


void __RPC_STUB IFaxStatus_get_StartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_SubmittedTime_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ DATE *pVal);


void __RPC_STUB IFaxStatus_get_SubmittedTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_ElapsedTime_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ DATE *pVal);


void __RPC_STUB IFaxStatus_get_ElapsedTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxStatus_Refresh_Proxy( 
    IFaxStatus * This);


void __RPC_STUB IFaxStatus_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxStatus_INTERFACE_DEFINED__ */


#ifndef __IFaxDoc_INTERFACE_DEFINED__
#define __IFaxDoc_INTERFACE_DEFINED__

/* interface IFaxDoc */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxDoc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FA21F4C5-5C4C-11D1-83CF-00C04FB6E984")
    IFaxDoc : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FileName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FileName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CoverpageName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CoverpageName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SendCoverpage( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SendCoverpage( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ServerCoverpage( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ServerCoverpage( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscountSend( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DiscountSend( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientCompany( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientCompany( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientAddress( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientAddress( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientCity( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientCity( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientState( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientState( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientZip( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientZip( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientCountry( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientCountry( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientTitle( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientTitle( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientDepartment( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientDepartment( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientOffice( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientOffice( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientHomePhone( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientHomePhone( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientOfficePhone( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientOfficePhone( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderCompany( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderCompany( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderAddress( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderAddress( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderTitle( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderTitle( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderDepartment( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderDepartment( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderOffice( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderOffice( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderHomePhone( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderHomePhone( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderOfficePhone( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderOfficePhone( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CoverpageNote( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CoverpageNote( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CoverpageSubject( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CoverpageSubject( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Tsid( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Tsid( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BillingCode( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BillingCode( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EmailAddress( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EmailAddress( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DisplayName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Send( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FaxNumber( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FaxNumber( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_ConnectionObject( 
            /* [in] */ IDispatch *newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallHandle( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CallHandle( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderFax( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderFax( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxDocVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxDoc * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxDoc * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxDoc * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxDoc * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxDoc * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxDoc * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxDoc * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CoverpageName )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CoverpageName )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SendCoverpage )( 
            IFaxDoc * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SendCoverpage )( 
            IFaxDoc * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServerCoverpage )( 
            IFaxDoc * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ServerCoverpage )( 
            IFaxDoc * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiscountSend )( 
            IFaxDoc * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DiscountSend )( 
            IFaxDoc * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientName )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientName )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientCompany )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientCompany )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientAddress )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientAddress )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientCity )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientCity )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientState )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientState )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientZip )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientZip )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientCountry )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientCountry )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientTitle )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientTitle )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientDepartment )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientDepartment )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientOffice )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientOffice )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientHomePhone )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientHomePhone )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientOfficePhone )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientOfficePhone )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderName )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SenderName )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderCompany )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SenderCompany )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderAddress )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SenderAddress )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderTitle )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SenderTitle )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderDepartment )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SenderDepartment )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderOffice )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SenderOffice )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderHomePhone )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SenderHomePhone )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderOfficePhone )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SenderOfficePhone )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CoverpageNote )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CoverpageNote )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CoverpageSubject )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CoverpageSubject )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Tsid )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Tsid )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BillingCode )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BillingCode )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EmailAddress )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EmailAddress )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayName )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayName )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Send )( 
            IFaxDoc * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FaxNumber )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FaxNumber )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_ConnectionObject )( 
            IFaxDoc * This,
            /* [in] */ IDispatch *newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallHandle )( 
            IFaxDoc * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CallHandle )( 
            IFaxDoc * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderFax )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SenderFax )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IFaxDocVtbl;

    interface IFaxDoc
    {
        CONST_VTBL struct IFaxDocVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxDoc_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxDoc_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxDoc_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxDoc_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxDoc_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxDoc_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxDoc_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxDoc_get_FileName(This,pVal)	\
    (This)->lpVtbl -> get_FileName(This,pVal)

#define IFaxDoc_put_FileName(This,newVal)	\
    (This)->lpVtbl -> put_FileName(This,newVal)

#define IFaxDoc_get_CoverpageName(This,pVal)	\
    (This)->lpVtbl -> get_CoverpageName(This,pVal)

#define IFaxDoc_put_CoverpageName(This,newVal)	\
    (This)->lpVtbl -> put_CoverpageName(This,newVal)

#define IFaxDoc_get_SendCoverpage(This,pVal)	\
    (This)->lpVtbl -> get_SendCoverpage(This,pVal)

#define IFaxDoc_put_SendCoverpage(This,newVal)	\
    (This)->lpVtbl -> put_SendCoverpage(This,newVal)

#define IFaxDoc_get_ServerCoverpage(This,pVal)	\
    (This)->lpVtbl -> get_ServerCoverpage(This,pVal)

#define IFaxDoc_put_ServerCoverpage(This,newVal)	\
    (This)->lpVtbl -> put_ServerCoverpage(This,newVal)

#define IFaxDoc_get_DiscountSend(This,pVal)	\
    (This)->lpVtbl -> get_DiscountSend(This,pVal)

#define IFaxDoc_put_DiscountSend(This,newVal)	\
    (This)->lpVtbl -> put_DiscountSend(This,newVal)

#define IFaxDoc_get_RecipientName(This,pVal)	\
    (This)->lpVtbl -> get_RecipientName(This,pVal)

#define IFaxDoc_put_RecipientName(This,newVal)	\
    (This)->lpVtbl -> put_RecipientName(This,newVal)

#define IFaxDoc_get_RecipientCompany(This,pVal)	\
    (This)->lpVtbl -> get_RecipientCompany(This,pVal)

#define IFaxDoc_put_RecipientCompany(This,newVal)	\
    (This)->lpVtbl -> put_RecipientCompany(This,newVal)

#define IFaxDoc_get_RecipientAddress(This,pVal)	\
    (This)->lpVtbl -> get_RecipientAddress(This,pVal)

#define IFaxDoc_put_RecipientAddress(This,newVal)	\
    (This)->lpVtbl -> put_RecipientAddress(This,newVal)

#define IFaxDoc_get_RecipientCity(This,pVal)	\
    (This)->lpVtbl -> get_RecipientCity(This,pVal)

#define IFaxDoc_put_RecipientCity(This,newVal)	\
    (This)->lpVtbl -> put_RecipientCity(This,newVal)

#define IFaxDoc_get_RecipientState(This,pVal)	\
    (This)->lpVtbl -> get_RecipientState(This,pVal)

#define IFaxDoc_put_RecipientState(This,newVal)	\
    (This)->lpVtbl -> put_RecipientState(This,newVal)

#define IFaxDoc_get_RecipientZip(This,pVal)	\
    (This)->lpVtbl -> get_RecipientZip(This,pVal)

#define IFaxDoc_put_RecipientZip(This,newVal)	\
    (This)->lpVtbl -> put_RecipientZip(This,newVal)

#define IFaxDoc_get_RecipientCountry(This,pVal)	\
    (This)->lpVtbl -> get_RecipientCountry(This,pVal)

#define IFaxDoc_put_RecipientCountry(This,newVal)	\
    (This)->lpVtbl -> put_RecipientCountry(This,newVal)

#define IFaxDoc_get_RecipientTitle(This,pVal)	\
    (This)->lpVtbl -> get_RecipientTitle(This,pVal)

#define IFaxDoc_put_RecipientTitle(This,newVal)	\
    (This)->lpVtbl -> put_RecipientTitle(This,newVal)

#define IFaxDoc_get_RecipientDepartment(This,pVal)	\
    (This)->lpVtbl -> get_RecipientDepartment(This,pVal)

#define IFaxDoc_put_RecipientDepartment(This,newVal)	\
    (This)->lpVtbl -> put_RecipientDepartment(This,newVal)

#define IFaxDoc_get_RecipientOffice(This,pVal)	\
    (This)->lpVtbl -> get_RecipientOffice(This,pVal)

#define IFaxDoc_put_RecipientOffice(This,newVal)	\
    (This)->lpVtbl -> put_RecipientOffice(This,newVal)

#define IFaxDoc_get_RecipientHomePhone(This,pVal)	\
    (This)->lpVtbl -> get_RecipientHomePhone(This,pVal)

#define IFaxDoc_put_RecipientHomePhone(This,newVal)	\
    (This)->lpVtbl -> put_RecipientHomePhone(This,newVal)

#define IFaxDoc_get_RecipientOfficePhone(This,pVal)	\
    (This)->lpVtbl -> get_RecipientOfficePhone(This,pVal)

#define IFaxDoc_put_RecipientOfficePhone(This,newVal)	\
    (This)->lpVtbl -> put_RecipientOfficePhone(This,newVal)

#define IFaxDoc_get_SenderName(This,pVal)	\
    (This)->lpVtbl -> get_SenderName(This,pVal)

#define IFaxDoc_put_SenderName(This,newVal)	\
    (This)->lpVtbl -> put_SenderName(This,newVal)

#define IFaxDoc_get_SenderCompany(This,pVal)	\
    (This)->lpVtbl -> get_SenderCompany(This,pVal)

#define IFaxDoc_put_SenderCompany(This,newVal)	\
    (This)->lpVtbl -> put_SenderCompany(This,newVal)

#define IFaxDoc_get_SenderAddress(This,pVal)	\
    (This)->lpVtbl -> get_SenderAddress(This,pVal)

#define IFaxDoc_put_SenderAddress(This,newVal)	\
    (This)->lpVtbl -> put_SenderAddress(This,newVal)

#define IFaxDoc_get_SenderTitle(This,pVal)	\
    (This)->lpVtbl -> get_SenderTitle(This,pVal)

#define IFaxDoc_put_SenderTitle(This,newVal)	\
    (This)->lpVtbl -> put_SenderTitle(This,newVal)

#define IFaxDoc_get_SenderDepartment(This,pVal)	\
    (This)->lpVtbl -> get_SenderDepartment(This,pVal)

#define IFaxDoc_put_SenderDepartment(This,newVal)	\
    (This)->lpVtbl -> put_SenderDepartment(This,newVal)

#define IFaxDoc_get_SenderOffice(This,pVal)	\
    (This)->lpVtbl -> get_SenderOffice(This,pVal)

#define IFaxDoc_put_SenderOffice(This,newVal)	\
    (This)->lpVtbl -> put_SenderOffice(This,newVal)

#define IFaxDoc_get_SenderHomePhone(This,pVal)	\
    (This)->lpVtbl -> get_SenderHomePhone(This,pVal)

#define IFaxDoc_put_SenderHomePhone(This,newVal)	\
    (This)->lpVtbl -> put_SenderHomePhone(This,newVal)

#define IFaxDoc_get_SenderOfficePhone(This,pVal)	\
    (This)->lpVtbl -> get_SenderOfficePhone(This,pVal)

#define IFaxDoc_put_SenderOfficePhone(This,newVal)	\
    (This)->lpVtbl -> put_SenderOfficePhone(This,newVal)

#define IFaxDoc_get_CoverpageNote(This,pVal)	\
    (This)->lpVtbl -> get_CoverpageNote(This,pVal)

#define IFaxDoc_put_CoverpageNote(This,newVal)	\
    (This)->lpVtbl -> put_CoverpageNote(This,newVal)

#define IFaxDoc_get_CoverpageSubject(This,pVal)	\
    (This)->lpVtbl -> get_CoverpageSubject(This,pVal)

#define IFaxDoc_put_CoverpageSubject(This,newVal)	\
    (This)->lpVtbl -> put_CoverpageSubject(This,newVal)

#define IFaxDoc_get_Tsid(This,pVal)	\
    (This)->lpVtbl -> get_Tsid(This,pVal)

#define IFaxDoc_put_Tsid(This,newVal)	\
    (This)->lpVtbl -> put_Tsid(This,newVal)

#define IFaxDoc_get_BillingCode(This,pVal)	\
    (This)->lpVtbl -> get_BillingCode(This,pVal)

#define IFaxDoc_put_BillingCode(This,newVal)	\
    (This)->lpVtbl -> put_BillingCode(This,newVal)

#define IFaxDoc_get_EmailAddress(This,pVal)	\
    (This)->lpVtbl -> get_EmailAddress(This,pVal)

#define IFaxDoc_put_EmailAddress(This,newVal)	\
    (This)->lpVtbl -> put_EmailAddress(This,newVal)

#define IFaxDoc_get_DisplayName(This,pVal)	\
    (This)->lpVtbl -> get_DisplayName(This,pVal)

#define IFaxDoc_put_DisplayName(This,newVal)	\
    (This)->lpVtbl -> put_DisplayName(This,newVal)

#define IFaxDoc_Send(This,pVal)	\
    (This)->lpVtbl -> Send(This,pVal)

#define IFaxDoc_get_FaxNumber(This,pVal)	\
    (This)->lpVtbl -> get_FaxNumber(This,pVal)

#define IFaxDoc_put_FaxNumber(This,newVal)	\
    (This)->lpVtbl -> put_FaxNumber(This,newVal)

#define IFaxDoc_putref_ConnectionObject(This,newVal)	\
    (This)->lpVtbl -> putref_ConnectionObject(This,newVal)

#define IFaxDoc_get_CallHandle(This,pVal)	\
    (This)->lpVtbl -> get_CallHandle(This,pVal)

#define IFaxDoc_put_CallHandle(This,newVal)	\
    (This)->lpVtbl -> put_CallHandle(This,newVal)

#define IFaxDoc_get_SenderFax(This,pVal)	\
    (This)->lpVtbl -> get_SenderFax(This,pVal)

#define IFaxDoc_put_SenderFax(This,newVal)	\
    (This)->lpVtbl -> put_SenderFax(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_FileName_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_FileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_FileName_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_FileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_CoverpageName_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_CoverpageName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_CoverpageName_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_CoverpageName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SendCoverpage_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxDoc_get_SendCoverpage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SendCoverpage_Proxy( 
    IFaxDoc * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxDoc_put_SendCoverpage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_ServerCoverpage_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxDoc_get_ServerCoverpage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_ServerCoverpage_Proxy( 
    IFaxDoc * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxDoc_put_ServerCoverpage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_DiscountSend_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxDoc_get_DiscountSend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_DiscountSend_Proxy( 
    IFaxDoc * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxDoc_put_DiscountSend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientName_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientName_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientCompany_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientCompany_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientCompany_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientCompany_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientAddress_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientAddress_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientCity_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientCity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientCity_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientCity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientState_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientState_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientZip_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientZip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientZip_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientZip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientCountry_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientCountry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientCountry_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientCountry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientTitle_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientTitle_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientDepartment_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientDepartment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientDepartment_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientDepartment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientOffice_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientOffice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientOffice_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientOffice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientHomePhone_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientHomePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientHomePhone_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientHomePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientOfficePhone_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientOfficePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientOfficePhone_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientOfficePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderName_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_SenderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderName_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderCompany_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_SenderCompany_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderCompany_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderCompany_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderAddress_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_SenderAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderAddress_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderTitle_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_SenderTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderTitle_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderDepartment_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_SenderDepartment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderDepartment_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderDepartment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderOffice_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_SenderOffice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderOffice_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderOffice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderHomePhone_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_SenderHomePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderHomePhone_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderHomePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderOfficePhone_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_SenderOfficePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderOfficePhone_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderOfficePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_CoverpageNote_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_CoverpageNote_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_CoverpageNote_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_CoverpageNote_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_CoverpageSubject_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_CoverpageSubject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_CoverpageSubject_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_CoverpageSubject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_Tsid_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_Tsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_Tsid_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_Tsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_BillingCode_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_BillingCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_BillingCode_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_BillingCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_EmailAddress_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_EmailAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_EmailAddress_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_EmailAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_DisplayName_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_DisplayName_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDoc_Send_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxDoc_Send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_FaxNumber_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_FaxNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_FaxNumber_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_FaxNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IFaxDoc_putref_ConnectionObject_Proxy( 
    IFaxDoc * This,
    /* [in] */ IDispatch *newVal);


void __RPC_STUB IFaxDoc_putref_ConnectionObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_CallHandle_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxDoc_get_CallHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_CallHandle_Proxy( 
    IFaxDoc * This,
    /* [in] */ long newVal);


void __RPC_STUB IFaxDoc_put_CallHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderFax_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_SenderFax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderFax_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderFax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxDoc_INTERFACE_DEFINED__ */


#ifndef __IFaxJobs_INTERFACE_DEFINED__
#define __IFaxJobs_INTERFACE_DEFINED__

/* interface IFaxJobs */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxJobs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("55DABFD3-5C9E-11D1-B791-000000000000")
    IFaxJobs : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            long Index,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxJobsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxJobs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxJobs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxJobs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxJobs * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxJobs * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxJobs * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxJobs * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxJobs * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxJobs * This,
            long Index,
            /* [retval][out] */ VARIANT *pVal);
        
        END_INTERFACE
    } IFaxJobsVtbl;

    interface IFaxJobs
    {
        CONST_VTBL struct IFaxJobsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxJobs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxJobs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxJobs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxJobs_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxJobs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxJobs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxJobs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxJobs_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IFaxJobs_get_Item(This,Index,pVal)	\
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobs_get_Count_Proxy( 
    IFaxJobs * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxJobs_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobs_get_Item_Proxy( 
    IFaxJobs * This,
    long Index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IFaxJobs_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxJobs_INTERFACE_DEFINED__ */


#ifndef __IFaxJob_INTERFACE_DEFINED__
#define __IFaxJob_INTERFACE_DEFINED__

/* interface IFaxJob */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxJob;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("55DABFD5-5C9E-11D1-B791-000000000000")
    IFaxJob : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_JobId( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UserName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_QueueStatus( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceStatus( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PageCount( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FaxNumber( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Tsid( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderCompany( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderDept( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BillingCode( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscountSend( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            long Command) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxJobVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxJob * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxJob * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxJob * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxJob * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxJob * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxJob * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_JobId )( 
            IFaxJob * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IFaxJob * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserName )( 
            IFaxJob * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_QueueStatus )( 
            IFaxJob * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceStatus )( 
            IFaxJob * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PageCount )( 
            IFaxJob * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FaxNumber )( 
            IFaxJob * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientName )( 
            IFaxJob * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Tsid )( 
            IFaxJob * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderName )( 
            IFaxJob * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderCompany )( 
            IFaxJob * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderDept )( 
            IFaxJob * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BillingCode )( 
            IFaxJob * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayName )( 
            IFaxJob * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiscountSend )( 
            IFaxJob * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            IFaxJob * This,
            long Command);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxJob * This);
        
        END_INTERFACE
    } IFaxJobVtbl;

    interface IFaxJob
    {
        CONST_VTBL struct IFaxJobVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxJob_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxJob_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxJob_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxJob_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxJob_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxJob_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxJob_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxJob_get_JobId(This,pVal)	\
    (This)->lpVtbl -> get_JobId(This,pVal)

#define IFaxJob_get_Type(This,pVal)	\
    (This)->lpVtbl -> get_Type(This,pVal)

#define IFaxJob_get_UserName(This,pVal)	\
    (This)->lpVtbl -> get_UserName(This,pVal)

#define IFaxJob_get_QueueStatus(This,pVal)	\
    (This)->lpVtbl -> get_QueueStatus(This,pVal)

#define IFaxJob_get_DeviceStatus(This,pVal)	\
    (This)->lpVtbl -> get_DeviceStatus(This,pVal)

#define IFaxJob_get_PageCount(This,pVal)	\
    (This)->lpVtbl -> get_PageCount(This,pVal)

#define IFaxJob_get_FaxNumber(This,pVal)	\
    (This)->lpVtbl -> get_FaxNumber(This,pVal)

#define IFaxJob_get_RecipientName(This,pVal)	\
    (This)->lpVtbl -> get_RecipientName(This,pVal)

#define IFaxJob_get_Tsid(This,pVal)	\
    (This)->lpVtbl -> get_Tsid(This,pVal)

#define IFaxJob_get_SenderName(This,pVal)	\
    (This)->lpVtbl -> get_SenderName(This,pVal)

#define IFaxJob_get_SenderCompany(This,pVal)	\
    (This)->lpVtbl -> get_SenderCompany(This,pVal)

#define IFaxJob_get_SenderDept(This,pVal)	\
    (This)->lpVtbl -> get_SenderDept(This,pVal)

#define IFaxJob_get_BillingCode(This,pVal)	\
    (This)->lpVtbl -> get_BillingCode(This,pVal)

#define IFaxJob_get_DisplayName(This,pVal)	\
    (This)->lpVtbl -> get_DisplayName(This,pVal)

#define IFaxJob_get_DiscountSend(This,pVal)	\
    (This)->lpVtbl -> get_DiscountSend(This,pVal)

#define IFaxJob_SetStatus(This,Command)	\
    (This)->lpVtbl -> SetStatus(This,Command)

#define IFaxJob_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_JobId_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxJob_get_JobId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_Type_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxJob_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_UserName_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxJob_get_UserName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_QueueStatus_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxJob_get_QueueStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_DeviceStatus_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxJob_get_DeviceStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_PageCount_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxJob_get_PageCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_FaxNumber_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxJob_get_FaxNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_RecipientName_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxJob_get_RecipientName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_Tsid_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxJob_get_Tsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_SenderName_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxJob_get_SenderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_SenderCompany_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxJob_get_SenderCompany_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_SenderDept_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxJob_get_SenderDept_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_BillingCode_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxJob_get_BillingCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_DisplayName_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxJob_get_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_DiscountSend_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxJob_get_DiscountSend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxJob_SetStatus_Proxy( 
    IFaxJob * This,
    long Command);


void __RPC_STUB IFaxJob_SetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxJob_Refresh_Proxy( 
    IFaxJob * This);


void __RPC_STUB IFaxJob_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxJob_INTERFACE_DEFINED__ */



#ifndef __FAXCOMLib_LIBRARY_DEFINED__
#define __FAXCOMLib_LIBRARY_DEFINED__

/* library FAXCOMLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_FAXCOMLib;

EXTERN_C const CLSID CLSID_FaxTiff;

#ifdef __cplusplus

class DECLSPEC_UUID("87099231-C7AF-11D0-B225-00C04FB6C2F5")
FaxTiff;
#endif

EXTERN_C const CLSID CLSID_FaxServer;

#ifdef __cplusplus

class DECLSPEC_UUID("D73733C8-CC80-11D0-B225-00C04FB6C2F5")
FaxServer;
#endif

EXTERN_C const CLSID CLSID_FaxPort;

#ifdef __cplusplus

class DECLSPEC_UUID("D73733CD-CC80-11D0-B225-00C04FB6C2F5")
FaxPort;
#endif

EXTERN_C const CLSID CLSID_FaxPorts;

#ifdef __cplusplus

class DECLSPEC_UUID("D73733D6-CC80-11D0-B225-00C04FB6C2F5")
FaxPorts;
#endif

EXTERN_C const CLSID CLSID_FaxRoutingMethod;

#ifdef __cplusplus

class DECLSPEC_UUID("2199F5F4-CEFC-11D0-A341-0000F800E68D")
FaxRoutingMethod;
#endif

EXTERN_C const CLSID CLSID_FaxRoutingMethods;

#ifdef __cplusplus

class DECLSPEC_UUID("2199F5F6-CEFC-11D0-A341-0000F800E68D")
FaxRoutingMethods;
#endif

EXTERN_C const CLSID CLSID_FaxStatus;

#ifdef __cplusplus

class DECLSPEC_UUID("8B97E606-D054-11D0-B226-00C04FB6C2F5")
FaxStatus;
#endif

EXTERN_C const CLSID CLSID_FaxDoc;

#ifdef __cplusplus

class DECLSPEC_UUID("FA21F4C6-5C4C-11D1-83CF-00C04FB6E984")
FaxDoc;
#endif

EXTERN_C const CLSID CLSID_FaxJobs;

#ifdef __cplusplus

class DECLSPEC_UUID("55DABFD4-5C9E-11D1-B791-000000000000")
FaxJobs;
#endif

EXTERN_C const CLSID CLSID_FaxJob;

#ifdef __cplusplus

class DECLSPEC_UUID("55DABFD6-5C9E-11D1-B791-000000000000")
FaxJob;
#endif
#endif /* __FAXCOMLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\amd64\fre\sdk\efsputil.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    efsputil.h

--*/

#ifndef _EFSPUTIL_H_
#define _EFSPUTIL_H_

typedef struct tag_FSPI_BRAND_INFO
{
    DWORD   dwSizeOfStruct;
    LPWSTR  lptstrSenderTsid;
    LPWSTR  lptstrRecipientPhoneNumber;
    LPWSTR  lptstrSenderCompany;
    SYSTEMTIME tmDateTime;
} FSPI_BRAND_INFO;

typedef const FSPI_BRAND_INFO * LPCFSPI_BRAND_INFO;
typedef FSPI_BRAND_INFO * LPFSPI_BRAND_INFO;


#ifdef __cplusplus
extern "C" {
#endif


HRESULT
WINAPI
FaxBrandDocument(
    LPCTSTR lpctstrFile,
    LPCFSPI_BRAND_INFO lpcBrandInfo
);

HRESULT
WINAPI
FaxRenderCoverPage(
  LPCTSTR lpctstrTargetFile,
  LPCFSPI_COVERPAGE_INFO lpCoverPageInfo,
  LPCFSPI_PERSONAL_PROFILE lpRecipientProfile,
  LPCFSPI_PERSONAL_PROFILE lpSenderProfile,
  SYSTEMTIME tmSentTime,
  LPCTSTR lpctstrBodyTiff
);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\amd64\fre\fxscount.h ===
//
//  faxcount.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the
//  "First Counter" and "First Help" values fo the device they belong to,
//  in order to determine the  absolute location of the counter and
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//

#define FAXOBJ                           0
#define INBOUND_BYTES                    2
#define INBOUND_FAXES                    4
#define INBOUND_PAGES                    6
#define INBOUND_MINUTES                  8
#define INBOUND_FAILED_RECEIVE          10
#define OUTBOUND_BYTES                  12
#define OUTBOUND_FAXES                  14
#define OUTBOUND_PAGES                  16
#define OUTBOUND_MINUTES                18
#define OUTBOUND_FAILED_CONNECTIONS     20
#define OUTBOUND_FAILED_XMIT            22
#define TOTAL_BYTES                     24
#define TOTAL_FAXES                     26
#define TOTAL_PAGES                     28
#define TOTAL_MINUTES                   30
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\amd64\fre\sdk\faxdev.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    faxdev.h

Abstract:

    This file contains the prototypes, etc for the
    FAX device provider API.

--*/

#include <commctrl.h>


#ifndef _FAXDEV_
#define _FAXDEV_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// FAX status constants
//

#define FS_INITIALIZING         0x20000000
#define FS_DIALING              0x20000001
#define FS_TRANSMITTING         0x20000002
#define FS_RECEIVING            0x20000004
#define FS_COMPLETED            0x20000008
#define FS_HANDLED              0x20000010
#define FS_LINE_UNAVAILABLE     0x20000020
#define FS_BUSY                 0x20000040
#define FS_NO_ANSWER            0x20000080
#define FS_BAD_ADDRESS          0x20000100
#define FS_NO_DIAL_TONE         0x20000200
#define FS_DISCONNECTED         0x20000400
#define FS_FATAL_ERROR          0x20000800  // see the stringid for the real status
#define FS_NOT_FAX_CALL         0x20001000
#define FS_CALL_DELAYED         0x20002000
#define FS_CALL_BLACKLISTED     0x20004000
#define FS_USER_ABORT           0x20200000
#define FS_ANSWERED             0x20800000


//
// data structures
//

typedef struct _FAX_SEND {
    DWORD   SizeOfStruct;
    LPWSTR  FileName;
    LPWSTR  CallerName;
    LPWSTR  CallerNumber;
    LPWSTR  ReceiverName;
    LPWSTR  ReceiverNumber;
    BOOL    Branding;
    HCALL   CallHandle;
    DWORD   Reserved[3];
} FAX_SEND, *PFAX_SEND;

typedef struct _FAX_RECEIVE {
    DWORD   SizeOfStruct;
    LPWSTR  FileName;
    LPWSTR  ReceiverName;
    LPWSTR  ReceiverNumber;
    DWORD   Reserved[4];
} FAX_RECEIVE, *PFAX_RECEIVE;

typedef struct _FAX_DEV_STATUS {
    DWORD   SizeOfStruct;
    DWORD   StatusId;
    DWORD   StringId;
    DWORD   PageCount;
    LPWSTR  CSI;
    LPWSTR  CallerId;
    LPWSTR  RoutingInfo;
    DWORD   ErrorCode;
    DWORD   Reserved[3];
} FAX_DEV_STATUS, *PFAX_DEV_STATUS;

typedef BOOL
(CALLBACK *PFAX_SERVICE_CALLBACK)(
    IN HANDLE FaxHandle,
    IN DWORD  DeviceId,
    IN DWORD_PTR  Param1,
    IN DWORD_PTR  Param2,
    IN DWORD_PTR  Param3
    );

typedef void
(CALLBACK *PFAX_LINECALLBACK)(
    IN HANDLE FaxHandle,
    IN DWORD hDevice,
    IN DWORD dwMessage,
    IN DWORD_PTR dwInstance,
    IN DWORD_PTR dwParam1,
    IN DWORD_PTR dwParam2,
    IN DWORD_PTR dwParam3
    );

BOOL WINAPI
FaxDevInitialize(
    IN  HLINEAPP LineAppHandle,
    IN  HANDLE HeapHandle,
    OUT PFAX_LINECALLBACK *LineCallbackFunction,
    IN  PFAX_SERVICE_CALLBACK FaxServiceCallback
    );

BOOL WINAPI
FaxDevVirtualDeviceCreation(
    OUT LPDWORD DeviceCount,
    OUT LPWSTR DeviceNamePrefix,
    OUT LPDWORD DeviceIdPrefix,
    IN  HANDLE CompletionPort,
    IN  ULONG_PTR CompletionKey
    );

BOOL WINAPI
FaxDevStartJob(
    IN  HLINE LineHandle,
    IN  DWORD DeviceId,
    OUT PHANDLE FaxHandle,
    IN  HANDLE CompletionPortHandle,
    IN  ULONG_PTR CompletionKey
    );

BOOL WINAPI
FaxDevEndJob(
    IN  HANDLE FaxHandle
    );

typedef BOOL
(CALLBACK *PFAX_SEND_CALLBACK)(
    IN HANDLE FaxHandle,
    IN HCALL CallHandle,
    IN DWORD Reserved1,
    IN DWORD Reserved2
    );

BOOL WINAPI
FaxDevSend(
    IN  HANDLE FaxHandle,
    IN  PFAX_SEND FaxSend,
    IN  PFAX_SEND_CALLBACK FaxSendCallback
    );

#define FAXDEVRECEIVE_SIZE 4096

BOOL WINAPI
FaxDevReceive(
    IN  HANDLE FaxHandle,
    IN  HCALL CallHandle,
    IN OUT PFAX_RECEIVE FaxReceive
    );

#define FAXDEVREPORTSTATUS_SIZE 4096

BOOL WINAPI
FaxDevReportStatus(
    IN  HANDLE FaxHandle OPTIONAL,
    OUT PFAX_DEV_STATUS FaxStatus,
    IN  DWORD FaxStatusSize,
    OUT LPDWORD FaxStatusSizeRequired
    );

BOOL WINAPI
FaxDevAbortOperation(
    IN  HANDLE FaxHandle
    );

BOOL WINAPI
FaxDevConfigure(
    OUT HPROPSHEETPAGE *PropSheetPage
    );


typedef BOOL (WINAPI *PFAXDEVINITIALIZE)                (HLINEAPP,HANDLE,PFAX_LINECALLBACK*,PFAX_SERVICE_CALLBACK);
typedef BOOL (WINAPI *PFAXDEVVIRTUALDEVICECREATION)     (LPDWORD,LPWSTR,LPDWORD,HANDLE,ULONG_PTR);
typedef BOOL (WINAPI *PFAXDEVSTARTJOB)                  (HLINE,DWORD,PHANDLE,HANDLE,ULONG_PTR);
typedef BOOL (WINAPI *PFAXDEVENDJOB)                    (HANDLE);
typedef BOOL (WINAPI *PFAXDEVSEND)                      (HANDLE,PFAX_SEND,PFAX_SEND_CALLBACK);
typedef BOOL (WINAPI *PFAXDEVRECEIVE)                   (HANDLE,HCALL,PFAX_RECEIVE);
typedef BOOL (WINAPI *PFAXDEVREPORTSTATUS)              (HANDLE,PFAX_DEV_STATUS,DWORD,LPDWORD);
typedef BOOL (WINAPI *PFAXDEVABORTOPERATION)            (HANDLE);
typedef BOOL (WINAPI *PFAXDEVCONFIGURE)                 (HPROPSHEETPAGE*);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\amd64\fre\sdk\faxroute.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    faxroute.h

Abstract:

    This file contains the prototypes, etc for the
    FAX routing extension API.


--*/

#include <commctrl.h>

#ifndef _FAXROUTE_
#define _FAXROUTE_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


//
// microsoft routing guids
//

#define MS_FAXROUTE_PRINTING_GUID               TEXT("{aec1b37c-9af2-11d0-abf7-00c04fd91a4e}")
#define MS_FAXROUTE_FOLDER_GUID                 TEXT("{92041a90-9af2-11d0-abf7-00c04fd91a4e}")
#define MS_FAXROUTE_EMAIL_GUID                  TEXT("{6bbf7bfe-9af2-11d0-abf7-00c04fd91a4e}")

//
// callback routines
//

typedef LONG (WINAPI *PFAXROUTEADDFILE)(DWORD JobId, LPCWSTR FileName, GUID *Guid);
typedef LONG (WINAPI *PFAXROUTEDELETEFILE)(DWORD JobId, LPCWSTR FileName);
typedef BOOL (WINAPI *PFAXROUTEGETFILE)(DWORD JobId, DWORD Index, LPWSTR FileNameBuffer, LPDWORD RequiredSize);
typedef BOOL (WINAPI *PFAXROUTEENUMFILE)(DWORD JobId, GUID *GuidOwner, GUID *GuidCaller, LPCWSTR FileName, PVOID Context);
typedef BOOL (WINAPI *PFAXROUTEENUMFILES)(DWORD JobId, GUID *Guid,PFAXROUTEENUMFILE FileEnumerator, PVOID Context);
typedef BOOL (WINAPI *PFAXROUTEMODIFYROUTINGDATA)(DWORD JobId, LPCWSTR RoutingGuid, LPBYTE RoutingData, DWORD RoutingDataSize );


typedef struct _FAX_ROUTE_CALLBACKROUTINES {
    DWORD                       SizeOfStruct;                // size of the struct set by the fax service
    PFAXROUTEADDFILE            FaxRouteAddFile;
    PFAXROUTEDELETEFILE         FaxRouteDeleteFile;
    PFAXROUTEGETFILE            FaxRouteGetFile;
    PFAXROUTEENUMFILES          FaxRouteEnumFiles;
    PFAXROUTEMODIFYROUTINGDATA  FaxRouteModifyRoutingData;
} FAX_ROUTE_CALLBACKROUTINES, *PFAX_ROUTE_CALLBACKROUTINES;


//
// routing data structure
//

typedef struct _FAX_ROUTE {
    DWORD           SizeOfStruct;       // size of the struct set by the fax service
    DWORD           JobId;              // Fax job identifier
    DWORDLONG       ElapsedTime;        // Elapsed time for whole fax job in Coordinated Universal Time (UTC)
    DWORDLONG       ReceiveTime;        // Starting time for fax job in Coordinated Universal Time (UTC)
    DWORD           PageCount;          // Number of pages received
    LPCWSTR         Csid;               // Called station identifier
    LPCWSTR         Tsid;               // Transmitting station identifier
    LPCWSTR         CallerId;           // Caller id
    LPCWSTR         RoutingInfo;        // Routing info such as DID, T.30-subaddress, etc.
    LPCWSTR         ReceiverName;       // Receiver's name
    LPCWSTR         ReceiverNumber;     // Receiver's fax number
    LPCWSTR         DeviceName;         // Device name for the line that received the fax
    DWORD           DeviceId;           // Permenant line identifier for the receiving device
    LPBYTE          RoutingInfoData;    // Routing infor data to override configured info
    DWORD           RoutingInfoDataSize;// Size of routing info data
} FAX_ROUTE, *PFAX_ROUTE;

enum FAXROUTE_ENABLE {
    QUERY_STATUS = -1,
    STATUS_DISABLE = 0,
    STATUS_ENABLE = 1
};


//
// prototypes
//

BOOL WINAPI
FaxRouteInitialize(
    IN HANDLE HeapHandle,
    IN PFAX_ROUTE_CALLBACKROUTINES FaxRouteCallbackRoutines
    );

BOOL WINAPI
FaxRouteDeviceEnable(
    IN  LPCWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  LONG Enabled
    );

BOOL WINAPI
FaxRouteDeviceChangeNotification(
    IN  DWORD DeviceId,
    IN  BOOL  NewDevice
    );

BOOL WINAPI
FaxRouteGetRoutingInfo(
    IN  LPCWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  LPBYTE RoutingInfo,
    OUT LPDWORD RoutingInfoSize
    );

BOOL WINAPI
FaxRouteSetRoutingInfo(
    IN  LPCWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  const BYTE *RoutingInfo,
    IN  DWORD RoutingInfoSize
    );


typedef BOOL (WINAPI *PFAXROUTEINITIALIZE)               (HANDLE,PFAX_ROUTE_CALLBACKROUTINES);
typedef BOOL (WINAPI *PFAXROUTEMETHOD)                   (const FAX_ROUTE*,PVOID*,LPDWORD);
typedef BOOL (WINAPI *PFAXROUTEDEVICEENABLE)             (LPCWSTR,DWORD,LONG);
typedef BOOL (WINAPI *PFAXROUTEDEVICECHANGENOTIFICATION) (DWORD,BOOL);
typedef BOOL (WINAPI *PFAXROUTEGETROUTINGINFO)           (LPCWSTR,DWORD,LPBYTE,LPDWORD);
typedef BOOL (WINAPI *PFAXROUTESETROUTINGINFO)           (LPCWSTR,DWORD,const BYTE*,DWORD);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\amd64\fre\sdk\faxmmc.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    faxmmc.h

Abstract:

    This header file contains public constants for extension of MMC components.

--*/

#ifndef H_FXS_MMCEXT_H
#define H_FXS_MMCEXT_H

#define FAXSRV_DEVICE_NODETYPE_GUID_STR OLESTR("{3115A19A-6251-46ac-9425-14782858B8C9}")
#define FAXSRV_DEVICE_NODETYPE_GUID { 0x3115a19a, 0x6251, 0x46ac, { 0x94, 0x25, 0x14, 0x78, 0x28, 0x58, 0xb8, 0xc9 } }

#define FAXSRV_DEVICE_PROVIDER_NODETYPE_GUID_STR OLESTR("{BD38E2AC-B926-4161-8640-0F6956EE2BA3}")
#define FAXSRV_DEVICE_PROVIDER_NODETYPE_GUID { 0xbd38e2ac, 0xb926, 0x4161, { 0x86, 0x40, 0x0f, 0x69, 0x56, 0xee, 0x2b, 0xa3 } }

#define FAXSRV_ROUTING_METHOD_NODETYPE_GUID_STR OLESTR("{220D2CB0-85A9-4a43-B6E8-9D66B44F1AF5}")
#define FAXSRV_ROUTING_METHOD_NODETYPE_GUID { 0x220d2cb0, 0x85a9, 0x4a43, { 0xb6, 0xe8, 0x9d, 0x66, 0xb4, 0x4f, 0x1a, 0xf5 } }

#define FAXSRV_MAX_GUID_LEN              sizeof(FAXSRV_DEVICE_NODETYPE_GUID_STR)/sizeof(WCHAR)
#define FAXSRV_MAX_SERVER_NAME           MAX_PATH
#define FAXSRV_MAX_ROUTEEXT_NAME_LEN     MAX_PATH

#define CF_MSFAXSRV_DEVICE_ID           TEXT("FAXSRV_DeviceID")
#define CF_MSFAXSRV_FSP_GUID            TEXT("FAXSRV_FSPGuid")
#define CF_MSFAXSRV_SERVER_NAME         TEXT("FAXSRV_ServerName")
#define CF_MSFAXSRV_ROUTEEXT_NAME       TEXT("FAXSRV_RoutingExtName")
#define CF_MSFAXSRV_ROUTING_METHOD_GUID TEXT("FAXSRV_RoutingMethodGuid")

#endif  //H_FXS_MMCEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\amd64\fre\sdk\faxext.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    faxext.h

Abstract:

    Declarations of fax extension configuration and notification functions.

--*/


#ifndef _FAX_EXT_H_
#define _FAX_EXT_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

/************************************
*                                   *
*   Extension configuration data    *
*                                   *
************************************/

typedef enum
{
    DEV_ID_SRC_FAX,         // Device id is generated by the fax server of EFSP
    DEV_ID_SRC_TAPI         // Device id is generated by a TAPI TSP (of FSP).
}   FAX_ENUM_DEVICE_ID_SOURCE;

//
// Prototype of FaxExtGetData 
// 
DWORD
FaxExtGetData (
    DWORD                       dwDeviceId,     // Device id (0 = No device)
    FAX_ENUM_DEVICE_ID_SOURCE   DevIdSrc,       // The source of the device id
    LPCWSTR                     lpcwstrDataGUID,// GUID of data
    LPBYTE                     *ppData,         // (Out) Pointer to allocated data
    LPDWORD                     lpdwDataSize    // (Out) Pointer to data size
);
typedef DWORD (CALLBACK *PFAX_EXT_GET_DATA) (DWORD, FAX_ENUM_DEVICE_ID_SOURCE, LPCWSTR, LPBYTE *, LPDWORD);

//
// Prototype of FaxExtSetData 
// 
DWORD
FaxExtSetData (
    HINSTANCE                   hInst,          // Instance of calling extension
    DWORD                       dwDeviceId,     // Device id (0 = No device)
    FAX_ENUM_DEVICE_ID_SOURCE   DevIdSrc,       // The source of the device id
    LPCWSTR                     lpcwstrDataGUID,// GUID of data
    LPBYTE                      pData,          // Pointer to  data
    DWORD                       dwDataSize      // Data size
);
typedef DWORD (CALLBACK *PFAX_EXT_SET_DATA) (HINSTANCE, DWORD, FAX_ENUM_DEVICE_ID_SOURCE, LPCWSTR, LPBYTE, DWORD);

HRESULT
FaxExtConfigChange (
    DWORD       dwDeviceId,         // The device for which configuration has changed
    LPCWSTR     lpcwstrDataGUID,    // Configuration name
    LPBYTE      lpData,             // New configuration data
    DWORD       dwDataSize          // Size of new configuration data
);
typedef HRESULT (WINAPI *PFAX_EXT_CONFIG_CHANGE) (DWORD, LPCWSTR, LPBYTE, DWORD);

//
// Prototype of FaxExtRegisterForEvents 
//
HANDLE
FaxExtRegisterForEvents (
    HINSTANCE                   hInst,          // Instance of calling extension
    DWORD                       dwDeviceId,     // Device id (0 = No device)
    FAX_ENUM_DEVICE_ID_SOURCE   DevIdSrc,       // The source of the device id
    LPCWSTR                     lpcwstrDataGUID,// GUID of data
    PFAX_EXT_CONFIG_CHANGE      lpConfigChangeCallback
);
typedef HANDLE (CALLBACK *PFAX_EXT_REGISTER_FOR_EVENTS) (HINSTANCE, DWORD, FAX_ENUM_DEVICE_ID_SOURCE, LPCWSTR, PFAX_EXT_CONFIG_CHANGE);

//
// Prototype of FaxExtUnregisterForEvents 
//
DWORD
FaxExtUnregisterForEvents (
    HANDLE      hNotification
);
typedef DWORD (CALLBACK *PFAX_EXT_UNREGISTER_FOR_EVENTS) (HANDLE);

//
// Prototype of FaxExtFreeBuffer
//
VOID
FaxExtFreeBuffer (
    LPVOID lpvBuffer
);
typedef VOID (CALLBACK *PFAX_EXT_FREE_BUFFER) (LPVOID);

//
// The extension should implement and export the following function:
//
HRESULT 
FaxExtInitializeConfig (
    PFAX_EXT_GET_DATA,              // Pointer to FaxExtGetExtensionData in service
    PFAX_EXT_SET_DATA,              // Pointer to FaxExtSetExtensionData in service
    PFAX_EXT_REGISTER_FOR_EVENTS,   // Pointer to FaxExtRegisterForExtensionEvents in service
    PFAX_EXT_UNREGISTER_FOR_EVENTS, // Pointer to FaxExtUnregisterForExtensionEvents in service
    PFAX_EXT_FREE_BUFFER            // Pointer to FaxExtFreeBuffer in service
);
typedef HRESULT (WINAPI *PFAX_EXT_INITIALIZE_CONFIG) (PFAX_EXT_GET_DATA, PFAX_EXT_SET_DATA, PFAX_EXT_REGISTER_FOR_EVENTS, PFAX_EXT_UNREGISTER_FOR_EVENTS, PFAX_EXT_FREE_BUFFER);

#ifdef __cplusplus
}
#endif

#endif // _FAX_EXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\amd64\chk\sdk\winfax.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    winfax.h

Abstract:

    This module contains the WIN32 FAX APIs.

--*/



#ifndef _FAXAPI_
#define _FAXAPI_


#ifndef MIDL_PASS
#include <tapi.h>
#endif

#if !defined(_WINFAX_)
#define WINFAXAPI DECLSPEC_IMPORT
#else
#define WINFAXAPI
#endif



#ifdef __cplusplus
extern "C" {
#endif



typedef enum
{
    FAXLOG_LEVEL_NONE            = 0,
    FAXLOG_LEVEL_MIN,
    FAXLOG_LEVEL_MED,
    FAXLOG_LEVEL_MAX
} FAX_ENUM_LOG_LEVELS;

typedef enum
{
    FAXLOG_CATEGORY_INIT        = 1,        // Initialization / shutdown
    FAXLOG_CATEGORY_OUTBOUND,               // Outbound messages
    FAXLOG_CATEGORY_INBOUND,                // Inbound messages
    FAXLOG_CATEGORY_UNKNOWN                 // Unknown category (all others)
} FAX_ENUM_LOG_CATEGORIES;

typedef struct _FAX_LOG_CATEGORYA
{
    LPCSTR              Name;                       // logging category name
    DWORD               Category;                   // logging category number
    DWORD               Level;                      // logging level for the category
} FAX_LOG_CATEGORYA, *PFAX_LOG_CATEGORYA;
typedef struct _FAX_LOG_CATEGORYW
{
    LPCWSTR             Name;                       // logging category name
    DWORD               Category;                   // logging category number
    DWORD               Level;                      // logging level for the category
} FAX_LOG_CATEGORYW, *PFAX_LOG_CATEGORYW;
#ifdef UNICODE
typedef FAX_LOG_CATEGORYW FAX_LOG_CATEGORY;
typedef PFAX_LOG_CATEGORYW PFAX_LOG_CATEGORY;
#else
typedef FAX_LOG_CATEGORYA FAX_LOG_CATEGORY;
typedef PFAX_LOG_CATEGORYA PFAX_LOG_CATEGORY;
#endif // UNICODE

typedef struct _FAX_TIME
{
    WORD    Hour;
    WORD    Minute;
} FAX_TIME, *PFAX_TIME;

typedef struct _FAX_CONFIGURATIONA
{
    DWORD               SizeOfStruct;                   // size of this structure
    DWORD               Retries;                        // number of retries for fax send
    DWORD               RetryDelay;                     // number of minutes between retries
    DWORD               DirtyDays;                      // number of days to keep an unsent job in the queue
    BOOL                Branding;                       // fsp should brand outgoing faxes
    BOOL                UseDeviceTsid;                  // server uses device tsid only
    BOOL                ServerCp;                       // clients must use cover pages on the server
    BOOL                PauseServerQueue;               // is the server queue paused?
    FAX_TIME            StartCheapTime;                 // start of discount rate period
    FAX_TIME            StopCheapTime;                  // end of discount rate period
    BOOL                ArchiveOutgoingFaxes;           // whether outgoing faxes should be archived
    LPCSTR              ArchiveDirectory;               // archive directory for outgoing faxes
    LPCSTR              Reserved;                       // Reserved; must be NULL
} FAX_CONFIGURATIONA, *PFAX_CONFIGURATIONA;
typedef struct _FAX_CONFIGURATIONW
{
    DWORD               SizeOfStruct;                   // size of this structure
    DWORD               Retries;                        // number of retries for fax send
    DWORD               RetryDelay;                     // number of minutes between retries
    DWORD               DirtyDays;                      // number of days to keep an unsent job in the queue
    BOOL                Branding;                       // fsp should brand outgoing faxes
    BOOL                UseDeviceTsid;                  // server uses device tsid only
    BOOL                ServerCp;                       // clients must use cover pages on the server
    BOOL                PauseServerQueue;               // is the server queue paused?
    FAX_TIME            StartCheapTime;                 // start of discount rate period
    FAX_TIME            StopCheapTime;                  // end of discount rate period
    BOOL                ArchiveOutgoingFaxes;           // whether outgoing faxes should be archived
    LPCWSTR             ArchiveDirectory;               // archive directory for outgoing faxes
    LPCWSTR             Reserved;                       // Reserved; must be NULL
} FAX_CONFIGURATIONW, *PFAX_CONFIGURATIONW;
#ifdef UNICODE
typedef FAX_CONFIGURATIONW FAX_CONFIGURATION;
typedef PFAX_CONFIGURATIONW PFAX_CONFIGURATION;
#else
typedef FAX_CONFIGURATIONA FAX_CONFIGURATION;
typedef PFAX_CONFIGURATIONA PFAX_CONFIGURATION;
#endif // UNICODE


//
// FaxSetJob() command codes
//

typedef enum
{
    JC_UNKNOWN      = 0,
    JC_DELETE,
    JC_PAUSE,
    JC_RESUME
} FAX_ENUM_JOB_COMMANDS;

#define JC_RESTART   JC_RESUME


//
// job type defines
//

#define JT_UNKNOWN                  0
#define JT_SEND                     1
#define JT_RECEIVE                  2
#define JT_ROUTING                  3
#define JT_FAIL_RECEIVE             4

//
// job status defines
//
#define JS_PENDING                  0x00000000
#define JS_INPROGRESS               0x00000001
#define JS_DELETING                 0x00000002
#define JS_FAILED                   0x00000004
#define JS_PAUSED                   0x00000008
#define JS_NOLINE                   0x00000010
#define JS_RETRYING                 0x00000020
#define JS_RETRIES_EXCEEDED         0x00000040



typedef struct _FAX_DEVICE_STATUSA
{
    DWORD               SizeOfStruct;               // size of this structure
    LPCSTR              CallerId;                   // caller id string
    LPCSTR              Csid;                       // station identifier
    DWORD               CurrentPage;                // current page
    DWORD               DeviceId;                   // permanent line id
    LPCSTR              DeviceName;                 // device name
    LPCSTR              DocumentName;               // document name
    DWORD               JobType;                    // send or receive?
    LPCSTR              PhoneNumber;                // sending phone number
    LPCSTR              RoutingString;              // routing information
    LPCSTR              SenderName;                 // sender name
    LPCSTR              RecipientName;              // recipient name
    DWORD               Size;                       // size in bytes of the document
    FILETIME            StartTime;                  // starting time of the fax send/receive
    DWORD               Status;                     // current status of the device, see FPS_??? masks
    LPCSTR              StatusString;               // status string if the Status field is zero.  this may be NULL.
    FILETIME            SubmittedTime;              // time the document was submitted
    DWORD               TotalPages;                 // total number of pages in this job
    LPCSTR              Tsid;                       // transmitting station identifier
    LPCSTR              UserName;                   // user that submitted the active job
} FAX_DEVICE_STATUSA, *PFAX_DEVICE_STATUSA;
typedef struct _FAX_DEVICE_STATUSW
{
    DWORD               SizeOfStruct;               // size of this structure
    LPCWSTR             CallerId;                   // caller id string
    LPCWSTR             Csid;                       // station identifier
    DWORD               CurrentPage;                // current page
    DWORD               DeviceId;                   // permanent line id
    LPCWSTR             DeviceName;                 // device name
    LPCWSTR             DocumentName;               // document name
    DWORD               JobType;                    // send or receive?
    LPCWSTR             PhoneNumber;                // sending phone number
    LPCWSTR             RoutingString;              // routing information
    LPCWSTR             SenderName;                 // sender name
    LPCWSTR             RecipientName;              // recipient name
    DWORD               Size;                       // size in bytes of the document
    FILETIME            StartTime;                  // starting time of the fax send/receive
    DWORD               Status;                     // current status of the device, see FPS_??? masks
    LPCWSTR             StatusString;               // status string if the Status field is zero.  this may be NULL.
    FILETIME            SubmittedTime;              // time the document was submitted
    DWORD               TotalPages;                 // total number of pages in this job
    LPCWSTR             Tsid;                       // transmitting station identifier
    LPCWSTR             UserName;                   // user that submitted the active job
} FAX_DEVICE_STATUSW, *PFAX_DEVICE_STATUSW;
#ifdef UNICODE
typedef FAX_DEVICE_STATUSW FAX_DEVICE_STATUS;
typedef PFAX_DEVICE_STATUSW PFAX_DEVICE_STATUS;
#else
typedef FAX_DEVICE_STATUSA FAX_DEVICE_STATUS;
typedef PFAX_DEVICE_STATUSA PFAX_DEVICE_STATUS;
#endif // UNICODE

typedef struct _FAX_JOB_ENTRYA
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               JobId;                      // fax job id
    LPCSTR              UserName;                   // user who submitted the job
    DWORD               JobType;                    // job type, see JT defines
    DWORD               QueueStatus;                // job queue status, see JS defines
    DWORD               Status;                     // current status of the device, see FPS_??? masks
    DWORD               Size;                       // size in bytes of the document
    DWORD               PageCount;                  // total page count
    LPCSTR              RecipientNumber;            // recipient fax number
    LPCSTR              RecipientName;              // recipient name
    LPCSTR              Tsid;                       // transmitter's id
    LPCSTR              SenderName;                 // sender name
    LPCSTR              SenderCompany;              // sender company
    LPCSTR              SenderDept;                 // sender department
    LPCSTR              BillingCode;                // billing code
    DWORD               ScheduleAction;             // when to schedule the fax, see JSA defines
    SYSTEMTIME          ScheduleTime;               // time to send the fax when JSA_SPECIFIC_TIME is used (must be local time)
    DWORD               DeliveryReportType;         // delivery report type, see DRT defines
    LPCSTR              DeliveryReportAddress;      // email address for delivery report (ndr or dr) thru MAPI / SMTP
    LPCSTR              DocumentName;               // document name
} FAX_JOB_ENTRYA, *PFAX_JOB_ENTRYA;
typedef struct _FAX_JOB_ENTRYW
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               JobId;                      // fax job id
    LPCWSTR             UserName;                   // user who submitted the job
    DWORD               JobType;                    // job type, see JT defines
    DWORD               QueueStatus;                // job queue status, see JS defines
    DWORD               Status;                     // current status of the device, see FPS_??? masks
    DWORD               Size;                       // size in bytes of the document
    DWORD               PageCount;                  // total page count
    LPCWSTR             RecipientNumber;            // recipient fax number
    LPCWSTR             RecipientName;              // recipient name
    LPCWSTR             Tsid;                       // transmitter's id
    LPCWSTR             SenderName;                 // sender name
    LPCWSTR             SenderCompany;              // sender company
    LPCWSTR             SenderDept;                 // sender department
    LPCWSTR             BillingCode;                // billing code
    DWORD               ScheduleAction;             // when to schedule the fax, see JSA defines
    SYSTEMTIME          ScheduleTime;               // time to send the fax when JSA_SPECIFIC_TIME is used (must be local time)
    DWORD               DeliveryReportType;         // delivery report type, see DRT defines
    LPCWSTR             DeliveryReportAddress;      // email address for delivery report (ndr or dr) thru MAPI / SMTP
    LPCWSTR             DocumentName;               // document name
} FAX_JOB_ENTRYW, *PFAX_JOB_ENTRYW;
#ifdef UNICODE
typedef FAX_JOB_ENTRYW FAX_JOB_ENTRY;
typedef PFAX_JOB_ENTRYW PFAX_JOB_ENTRY;
#else
typedef FAX_JOB_ENTRYA FAX_JOB_ENTRY;
typedef PFAX_JOB_ENTRYA PFAX_JOB_ENTRY;
#endif // UNICODE

//
// fax port state masks
//
// if you change these defines the be sure to
// change the resources in the fax service.
//

#define FPS_DIALING              0x20000001
#define FPS_SENDING              0x20000002
#define FPS_RECEIVING            0x20000004
#define FPS_COMPLETED            0x20000008
#define FPS_HANDLED              0x20000010
#define FPS_UNAVAILABLE          0x20000020
#define FPS_BUSY                 0x20000040
#define FPS_NO_ANSWER            0x20000080
#define FPS_BAD_ADDRESS          0x20000100
#define FPS_NO_DIAL_TONE         0x20000200
#define FPS_DISCONNECTED         0x20000400
#define FPS_FATAL_ERROR          0x20000800
#define FPS_NOT_FAX_CALL         0x20001000
#define FPS_CALL_DELAYED         0x20002000
#define FPS_CALL_BLACKLISTED     0x20004000
#define FPS_INITIALIZING         0x20008000
#define FPS_OFFLINE              0x20010000
#define FPS_RINGING              0x20020000

#define FPS_AVAILABLE            0x20100000
#define FPS_ABORTING             0x20200000
#define FPS_ROUTING              0x20400000
#define FPS_ANSWERED             0x20800000

//
// fax port capability mask
//

#define FPF_RECEIVE       0x00000001        // Automatically receive faxes
#define FPF_SEND          0x00000002
#define FPF_VIRTUAL       0x00000004

typedef struct _FAX_PORT_INFOA
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               DeviceId;                   // Device ID
    DWORD               State;                      // State of the device
    DWORD               Flags;                      // Device specific flags
    DWORD               Rings;                      // Number of rings before answer
    DWORD               Priority;                   // Device priority
    LPCSTR              DeviceName;                 // Device name
    LPCSTR              Tsid;                       // Device Tsid
    LPCSTR              Csid;                       // Device Csid
} FAX_PORT_INFOA, *PFAX_PORT_INFOA;
typedef struct _FAX_PORT_INFOW
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               DeviceId;                   // Device ID
    DWORD               State;                      // State of the device
    DWORD               Flags;                      // Device specific flags
    DWORD               Rings;                      // Number of rings before answer
    DWORD               Priority;                   // Device priority
    LPCWSTR             DeviceName;                 // Device name
    LPCWSTR             Tsid;                       // Device Tsid
    LPCWSTR             Csid;                       // Device Csid
} FAX_PORT_INFOW, *PFAX_PORT_INFOW;
#ifdef UNICODE
typedef FAX_PORT_INFOW FAX_PORT_INFO;
typedef PFAX_PORT_INFOW PFAX_PORT_INFO;
#else
typedef FAX_PORT_INFOA FAX_PORT_INFO;
typedef PFAX_PORT_INFOA PFAX_PORT_INFO;
#endif // UNICODE


typedef struct _FAX_ROUTING_METHODA
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               DeviceId;                   // device identifier
    BOOL                Enabled;                    // is this method enabled for this device?
    LPCSTR              DeviceName;                 // device name
    LPCSTR              Guid;                       // guid that identifies this routing method
    LPCSTR              FriendlyName;               // friendly name for this method
    LPCSTR              FunctionName;               // exported function name that identifies this method
    LPCSTR              ExtensionImageName;         // module (dll) name that implements this method
    LPCSTR              ExtensionFriendlyName;      // displayable string that identifies the extension
} FAX_ROUTING_METHODA, *PFAX_ROUTING_METHODA;
typedef struct _FAX_ROUTING_METHODW
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               DeviceId;                   // device identifier
    BOOL                Enabled;                    // is this method enabled for this device?
    LPCWSTR             DeviceName;                 // device name
    LPCWSTR             Guid;                       // guid that identifies this routing method
    LPCWSTR             FriendlyName;               // friendly name for this method
    LPCWSTR             FunctionName;               // exported function name that identifies this method
    LPCWSTR             ExtensionImageName;         // module (dll) name that implements this method
    LPCWSTR             ExtensionFriendlyName;      // displayable string that identifies the extension
} FAX_ROUTING_METHODW, *PFAX_ROUTING_METHODW;
#ifdef UNICODE
typedef FAX_ROUTING_METHODW FAX_ROUTING_METHOD;
typedef PFAX_ROUTING_METHODW PFAX_ROUTING_METHOD;
#else
typedef FAX_ROUTING_METHODA FAX_ROUTING_METHOD;
typedef PFAX_ROUTING_METHODA PFAX_ROUTING_METHOD;
#endif // UNICODE


typedef struct _FAX_GLOBAL_ROUTING_INFOA
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               Priority;                   // priority of this device
    LPCSTR              Guid;                       // guid that identifies this routing method
    LPCSTR              FriendlyName;               // friendly name for this method
    LPCSTR              FunctionName;               // exported function name that identifies this method
    LPCSTR              ExtensionImageName;         // module (dll) name that implements this method
    LPCSTR              ExtensionFriendlyName;      // displayable string that identifies the extension
} FAX_GLOBAL_ROUTING_INFOA, *PFAX_GLOBAL_ROUTING_INFOA;
typedef struct _FAX_GLOBAL_ROUTING_INFOW
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               Priority;                   // priority of this device
    LPCWSTR             Guid;                       // guid that identifies this routing method
    LPCWSTR             FriendlyName;               // friendly name for this method
    LPCWSTR             FunctionName;               // exported function name that identifies this method
    LPCWSTR             ExtensionImageName;         // module (dll) name that implements this method
    LPCWSTR             ExtensionFriendlyName;      // displayable string that identifies the extension
} FAX_GLOBAL_ROUTING_INFOW, *PFAX_GLOBAL_ROUTING_INFOW;
#ifdef UNICODE
typedef FAX_GLOBAL_ROUTING_INFOW FAX_GLOBAL_ROUTING_INFO;
typedef PFAX_GLOBAL_ROUTING_INFOW PFAX_GLOBAL_ROUTING_INFO;
#else
typedef FAX_GLOBAL_ROUTING_INFOA FAX_GLOBAL_ROUTING_INFO;
typedef PFAX_GLOBAL_ROUTING_INFOA PFAX_GLOBAL_ROUTING_INFO;
#endif // UNICODE


typedef struct _FAX_COVERPAGE_INFOA
{
    DWORD               SizeOfStruct;               // Size of this structure
    //
    // general
    //
    LPCSTR              CoverPageName;              // coverpage document name
    BOOL                UseServerCoverPage;         // coverpage exists on the fax server
    //
    // Recipient information
    //
    LPCSTR              RecName;                    //
    LPCSTR              RecFaxNumber;               //
    LPCSTR              RecCompany;                 //
    LPCSTR              RecStreetAddress;           //
    LPCSTR              RecCity;                    //
    LPCSTR              RecState;                   //
    LPCSTR              RecZip;                     //
    LPCSTR              RecCountry;                 //
    LPCSTR              RecTitle;                   //
    LPCSTR              RecDepartment;              //
    LPCSTR              RecOfficeLocation;          //
    LPCSTR              RecHomePhone;               //
    LPCSTR              RecOfficePhone;             //
    //
    // Sender information
    //
    LPCSTR              SdrName;                    //
    LPCSTR              SdrFaxNumber;               //
    LPCSTR              SdrCompany;                 //
    LPCSTR              SdrAddress;                 //
    LPCSTR              SdrTitle;                   //
    LPCSTR              SdrDepartment;              //
    LPCSTR              SdrOfficeLocation;          //
    LPCSTR              SdrHomePhone;               //
    LPCSTR              SdrOfficePhone;             //
    //
    // Misc information
    //
    LPCSTR              Note;                       //
    LPCSTR              Subject;                    //
    SYSTEMTIME          TimeSent;                   // Time the fax was sent
    DWORD               PageCount;                  // Number of pages
} FAX_COVERPAGE_INFOA, *PFAX_COVERPAGE_INFOA;
typedef struct _FAX_COVERPAGE_INFOW
{
    DWORD               SizeOfStruct;               // Size of this structure
    //
    // general
    //
    LPCWSTR             CoverPageName;              // coverpage document name
    BOOL                UseServerCoverPage;         // coverpage exists on the fax server
    //
    // Recipient information
    //
    LPCWSTR             RecName;                    //
    LPCWSTR             RecFaxNumber;               //
    LPCWSTR             RecCompany;                 //
    LPCWSTR             RecStreetAddress;           //
    LPCWSTR             RecCity;                    //
    LPCWSTR             RecState;                   //
    LPCWSTR             RecZip;                     //
    LPCWSTR             RecCountry;                 //
    LPCWSTR             RecTitle;                   //
    LPCWSTR             RecDepartment;              //
    LPCWSTR             RecOfficeLocation;          //
    LPCWSTR             RecHomePhone;               //
    LPCWSTR             RecOfficePhone;             //
    //
    // Sender information
    //
    LPCWSTR             SdrName;                    //
    LPCWSTR             SdrFaxNumber;               //
    LPCWSTR             SdrCompany;                 //
    LPCWSTR             SdrAddress;                 //
    LPCWSTR             SdrTitle;                   //
    LPCWSTR             SdrDepartment;              //
    LPCWSTR             SdrOfficeLocation;          //
    LPCWSTR             SdrHomePhone;               //
    LPCWSTR             SdrOfficePhone;             //
    //
    // Misc information
    //
    LPCWSTR             Note;                       //
    LPCWSTR             Subject;                    //
    SYSTEMTIME          TimeSent;                   // Time the fax was sent
    DWORD               PageCount;                  // Number of pages
} FAX_COVERPAGE_INFOW, *PFAX_COVERPAGE_INFOW;
#ifdef UNICODE
typedef FAX_COVERPAGE_INFOW FAX_COVERPAGE_INFO;
typedef PFAX_COVERPAGE_INFOW PFAX_COVERPAGE_INFO;
#else
typedef FAX_COVERPAGE_INFOA FAX_COVERPAGE_INFO;
typedef PFAX_COVERPAGE_INFOA PFAX_COVERPAGE_INFO;
#endif // UNICODE

typedef enum
{
    JSA_NOW                  = 0,   // Send now
    JSA_SPECIFIC_TIME,              // Send at specific time
    JSA_DISCOUNT_PERIOD             // Send at server configured discount period
} FAX_ENUM_JOB_SEND_ATTRIBUTES;

typedef enum
{
    DRT_NONE                = 0x0000,       // Do not send receipt
    DRT_EMAIL               = 0x0001,       // Send receipt by email
    DRT_INBOX               = 0x0002        // send receipt to local inbox
} FAX_ENUM_DELIVERY_REPORT_TYPES;

typedef struct _FAX_JOB_PARAMA
{
    DWORD               SizeOfStruct;               // size of this structure
    LPCSTR              RecipientNumber;            // recipient fax number
    LPCSTR              RecipientName;              // recipient name
    LPCSTR              Tsid;                       // transmitter's id
    LPCSTR              SenderName;                 // sender name
    LPCSTR              SenderCompany;              // sender company
    LPCSTR              SenderDept;                 // sender department
    LPCSTR              BillingCode;                // billing code
    DWORD               ScheduleAction;             // when to schedule the fax, see JSA defines
    SYSTEMTIME          ScheduleTime;               // time to send the fax when JSA_SPECIFIC_TIME is used (must be local time)
    DWORD               DeliveryReportType;         // delivery report type, see DRT defines
    LPCSTR              DeliveryReportAddress;      // email address for delivery report (ndr or dr) thru MAPI / SMTP
    LPCSTR              DocumentName;               // document name (optional)
    HCALL               CallHandle;                 // optional call handle
    DWORD_PTR           Reserved[3];                // reserved for ms use only
} FAX_JOB_PARAMA, *PFAX_JOB_PARAMA;
typedef struct _FAX_JOB_PARAMW
{
    DWORD               SizeOfStruct;               // size of this structure
    LPCWSTR             RecipientNumber;            // recipient fax number
    LPCWSTR             RecipientName;              // recipient name
    LPCWSTR             Tsid;                       // transmitter's id
    LPCWSTR             SenderName;                 // sender name
    LPCWSTR             SenderCompany;              // sender company
    LPCWSTR             SenderDept;                 // sender department
    LPCWSTR             BillingCode;                // billing code
    DWORD               ScheduleAction;             // when to schedule the fax, see JSA defines
    SYSTEMTIME          ScheduleTime;               // time to send the fax when JSA_SPECIFIC_TIME is used (must be local time)
    DWORD               DeliveryReportType;         // delivery report type, see DRT defines
    LPCWSTR             DeliveryReportAddress;      // email address for delivery report (ndr or dr) thru MAPI / SMTP
    LPCWSTR             DocumentName;               // document name (optional)
    HCALL               CallHandle;                 // optional call handle
    DWORD_PTR           Reserved[3];                // reserved for ms use only
} FAX_JOB_PARAMW, *PFAX_JOB_PARAMW;
#ifdef UNICODE
typedef FAX_JOB_PARAMW FAX_JOB_PARAM;
typedef PFAX_JOB_PARAMW PFAX_JOB_PARAM;
#else
typedef FAX_JOB_PARAMA FAX_JOB_PARAM;
typedef PFAX_JOB_PARAMA PFAX_JOB_PARAM;
#endif // UNICODE

//
// Event Ids
//
// FEI_NEVENTS is the number of events
//

#define FEI_DIALING                 0x00000001
#define FEI_SENDING                 0x00000002
#define FEI_RECEIVING               0x00000003
#define FEI_COMPLETED               0x00000004
#define FEI_BUSY                    0x00000005
#define FEI_NO_ANSWER               0x00000006
#define FEI_BAD_ADDRESS             0x00000007
#define FEI_NO_DIAL_TONE            0x00000008
#define FEI_DISCONNECTED            0x00000009
#define FEI_FATAL_ERROR             0x0000000a
#define FEI_NOT_FAX_CALL            0x0000000b
#define FEI_CALL_DELAYED            0x0000000c
#define FEI_CALL_BLACKLISTED        0x0000000d
#define FEI_RINGING                 0x0000000e
#define FEI_ABORTING                0x0000000f
#define FEI_ROUTING                 0x00000010
#define FEI_MODEM_POWERED_ON        0x00000011
#define FEI_MODEM_POWERED_OFF       0x00000012
#define FEI_IDLE                    0x00000013
#define FEI_FAXSVC_ENDED            0x00000014
#define FEI_ANSWERED                0x00000015
#define FEI_JOB_QUEUED              0x00000016
#define FEI_DELETED                 0x00000017
#define FEI_INITIALIZING            0x00000018
#define FEI_LINE_UNAVAILABLE        0x00000019
#define FEI_HANDLED                 0x0000001a
#define FEI_FAXSVC_STARTED          0x0000001b

#define FEI_NEVENTS                 FEI_FAXSVC_STARTED

typedef struct _FAX_EVENTA
{
    DWORD               SizeOfStruct;               // Size of this structure
    FILETIME            TimeStamp;                  // Timestamp for when the event was generated
    DWORD               DeviceId;                   // Permanent line id
    DWORD               EventId;                    // Current event id
    DWORD               JobId;                      // Fax Job Id, 0xffffffff indicates inactive job
} FAX_EVENTA, *PFAX_EVENTA;
typedef struct _FAX_EVENTW
{
    DWORD               SizeOfStruct;               // Size of this structure
    FILETIME            TimeStamp;                  // Timestamp for when the event was generated
    DWORD               DeviceId;                   // Permanent line id
    DWORD               EventId;                    // Current event id
    DWORD               JobId;                      // Fax Job Id, 0xffffffff indicates inactive job
} FAX_EVENTW, *PFAX_EVENTW;
#ifdef UNICODE
typedef FAX_EVENTW FAX_EVENT;
typedef PFAX_EVENTW PFAX_EVENT;
#else
typedef FAX_EVENTA FAX_EVENT;
typedef PFAX_EVENTA PFAX_EVENT;
#endif // UNICODE


typedef struct _FAX_PRINT_INFOA
{
    DWORD               SizeOfStruct;               // Size of this structure
    LPCSTR              DocName;                    // Document name that appears in the spooler
    LPCSTR              RecipientName;              // Recipient name
    LPCSTR              RecipientNumber;            // Recipient fax number (non-canonical number)
    LPCSTR              SenderName;                 // Sender name
    LPCSTR              SenderCompany;              // Sender company (optional)
    LPCSTR              SenderDept;                 // Sender department
    LPCSTR              SenderBillingCode;          // Billing code
    LPCSTR              Reserved;                   // Reserved; must be NULL
    LPCSTR              DrEmailAddress;             // E.Mail address for delivery report
    LPCSTR              OutputFileName;             // for print to file, resulting file name
} FAX_PRINT_INFOA, *PFAX_PRINT_INFOA;
typedef struct _FAX_PRINT_INFOW
{
    DWORD               SizeOfStruct;               // Size of this structure
    LPCWSTR             DocName;                    // Document name that appears in the spooler
    LPCWSTR             RecipientName;              // Recipient name
    LPCWSTR             RecipientNumber;            // Recipient fax number (non-canonical number)
    LPCWSTR             SenderName;                 // Sender name
    LPCWSTR             SenderCompany;              // Sender company (optional)
    LPCWSTR             SenderDept;                 // Sender department
    LPCWSTR             SenderBillingCode;          // Billing code
    LPCWSTR             Reserved;                   // Reserved; must be NULL
    LPCWSTR             DrEmailAddress;             // E.Mail address for delivery report
    LPCWSTR             OutputFileName;             // for print to file, resulting file name
} FAX_PRINT_INFOW, *PFAX_PRINT_INFOW;
#ifdef UNICODE
typedef FAX_PRINT_INFOW FAX_PRINT_INFO;
typedef PFAX_PRINT_INFOW PFAX_PRINT_INFO;
#else
typedef FAX_PRINT_INFOA FAX_PRINT_INFO;
typedef PFAX_PRINT_INFOA PFAX_PRINT_INFO;
#endif // UNICODE


typedef struct _FAX_CONTEXT_INFOA
{
    DWORD               SizeOfStruct;                           // Size of this structure
    HDC                 hDC;                                    // Device Context
    CHAR                ServerName[MAX_COMPUTERNAME_LENGTH+1];  // Server name
} FAX_CONTEXT_INFOA, *PFAX_CONTEXT_INFOA;
typedef struct _FAX_CONTEXT_INFOW
{
    DWORD               SizeOfStruct;                           // Size of this structure
    HDC                 hDC;                                    // Device Context
    WCHAR               ServerName[MAX_COMPUTERNAME_LENGTH+1];  // Server name
} FAX_CONTEXT_INFOW, *PFAX_CONTEXT_INFOW;
#ifdef UNICODE
typedef FAX_CONTEXT_INFOW FAX_CONTEXT_INFO;
typedef PFAX_CONTEXT_INFOW PFAX_CONTEXT_INFO;
#else
typedef FAX_CONTEXT_INFOA FAX_CONTEXT_INFO;
typedef PFAX_CONTEXT_INFOA PFAX_CONTEXT_INFO;
#endif // UNICODE


//
// prototypes
//

WINFAXAPI
BOOL
WINAPI
FaxConnectFaxServerA(
    IN  LPCSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    );
WINFAXAPI
BOOL
WINAPI
FaxConnectFaxServerW(
    IN  LPCWSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    );
#ifdef UNICODE
#define FaxConnectFaxServer  FaxConnectFaxServerW
#else
#define FaxConnectFaxServer  FaxConnectFaxServerA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXCONNECTFAXSERVERA)(
    IN  LPCSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    );
typedef BOOL
(WINAPI *PFAXCONNECTFAXSERVERW)(
    IN  LPCWSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    );
#ifdef UNICODE
#define PFAXCONNECTFAXSERVER  PFAXCONNECTFAXSERVERW
#else
#define PFAXCONNECTFAXSERVER  PFAXCONNECTFAXSERVERA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxClose(
    IN HANDLE FaxHandle
    );

typedef BOOL
(WINAPI *PFAXCLOSE)(
    IN HANDLE FaxHandle
    );

typedef enum
{
    PORT_OPEN_QUERY     = 1,
    PORT_OPEN_MODIFY
} FAX_ENUM_PORT_OPEN_TYPE;

WINFAXAPI
BOOL
WINAPI
FaxOpenPort(
    IN  HANDLE FaxHandle,
    IN  DWORD DeviceId,
    IN  DWORD Flags,
    OUT LPHANDLE FaxPortHandle
    );

typedef BOOL
(WINAPI *PFAXOPENPORT)(
    IN  HANDLE FaxHandle,
    IN  DWORD DeviceId,
    IN  DWORD Flags,
    OUT LPHANDLE FaxPortHandle
    );

WINFAXAPI
BOOL
WINAPI
FaxCompleteJobParamsA(
    IN OUT PFAX_JOB_PARAMA *JobParams,
    IN OUT PFAX_COVERPAGE_INFOA *CoverpageInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxCompleteJobParamsW(
    IN OUT PFAX_JOB_PARAMW *JobParams,
    IN OUT PFAX_COVERPAGE_INFOW *CoverpageInfo
    );
#ifdef UNICODE
#define FaxCompleteJobParams  FaxCompleteJobParamsW
#else
#define FaxCompleteJobParams  FaxCompleteJobParamsA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXCOMPLETEJOBPARAMSA)(
    IN OUT PFAX_JOB_PARAMA *JobParams,
    IN OUT PFAX_COVERPAGE_INFOA *CoverpageInfo
    );
typedef BOOL
(WINAPI *PFAXCOMPLETEJOBPARAMSW)(
    IN OUT PFAX_JOB_PARAMW *JobParams,
    IN OUT PFAX_COVERPAGE_INFOW *CoverpageInfo
    );
#ifdef UNICODE
#define PFAXCOMPLETEJOBPARAMS  PFAXCOMPLETEJOBPARAMSW
#else
#define PFAXCOMPLETEJOBPARAMS  PFAXCOMPLETEJOBPARAMSA
#endif // !UNICODE



WINFAXAPI
BOOL
WINAPI
FaxSendDocumentA(
    IN HANDLE FaxHandle,
    IN LPCSTR FileName,
    IN PFAX_JOB_PARAMA JobParams,
    IN const FAX_COVERPAGE_INFOA *CoverpageInfo, OPTIONAL
    OUT LPDWORD FaxJobId OPTIONAL
    );
WINFAXAPI
BOOL
WINAPI
FaxSendDocumentW(
    IN HANDLE FaxHandle,
    IN LPCWSTR FileName,
    IN PFAX_JOB_PARAMW JobParams,
    IN const FAX_COVERPAGE_INFOW *CoverpageInfo, OPTIONAL
    OUT LPDWORD FaxJobId OPTIONAL
    );
#ifdef UNICODE
#define FaxSendDocument  FaxSendDocumentW
#else
#define FaxSendDocument  FaxSendDocumentA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSENDDOCUMENTA)(
    IN HANDLE FaxHandle,
    IN LPCSTR FileName,
    IN PFAX_JOB_PARAMA JobParams,
    IN const FAX_COVERPAGE_INFOA *CoverpageInfo, OPTIONAL
    OUT LPDWORD FaxJobId OPTIONAL
    );
typedef BOOL
(WINAPI *PFAXSENDDOCUMENTW)(
    IN HANDLE FaxHandle,
    IN LPCWSTR FileName,
    IN PFAX_JOB_PARAMW JobParams,
    IN const FAX_COVERPAGE_INFOW *CoverpageInfo, OPTIONAL
    OUT LPDWORD FaxJobId OPTIONAL
    );
#ifdef UNICODE
#define PFAXSENDDOCUMENT  PFAXSENDDOCUMENTW
#else
#define PFAXSENDDOCUMENT  PFAXSENDDOCUMENTA
#endif // !UNICODE

typedef BOOL
(CALLBACK *PFAX_RECIPIENT_CALLBACKA)(
    IN HANDLE FaxHandle,
    IN DWORD RecipientNumber,
    IN LPVOID Context,
    IN OUT PFAX_JOB_PARAMA JobParams,
    IN OUT PFAX_COVERPAGE_INFOA CoverpageInfo OPTIONAL
    );
typedef BOOL
(CALLBACK *PFAX_RECIPIENT_CALLBACKW)(
    IN HANDLE FaxHandle,
    IN DWORD RecipientNumber,
    IN LPVOID Context,
    IN OUT PFAX_JOB_PARAMW JobParams,
    IN OUT PFAX_COVERPAGE_INFOW CoverpageInfo OPTIONAL
    );
#ifdef UNICODE
#define PFAX_RECIPIENT_CALLBACK  PFAX_RECIPIENT_CALLBACKW
#else
#define PFAX_RECIPIENT_CALLBACK  PFAX_RECIPIENT_CALLBACKA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSendDocumentForBroadcastA(
    IN HANDLE FaxHandle,
    IN LPCSTR FileName,
    OUT LPDWORD FaxJobId,
    IN PFAX_RECIPIENT_CALLBACKA FaxRecipientCallback,
    IN LPVOID Context
    );
WINFAXAPI
BOOL
WINAPI
FaxSendDocumentForBroadcastW(
    IN HANDLE FaxHandle,
    IN LPCWSTR FileName,
    OUT LPDWORD FaxJobId,
    IN PFAX_RECIPIENT_CALLBACKW FaxRecipientCallback,
    IN LPVOID Context
    );
#ifdef UNICODE
#define FaxSendDocumentForBroadcast  FaxSendDocumentForBroadcastW
#else
#define FaxSendDocumentForBroadcast  FaxSendDocumentForBroadcastA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSENDDOCUMENTFORBROADCASTA)(
    IN  HANDLE FaxHandle,
    IN  LPCSTR FileName,
    OUT LPDWORD FaxJobId,
    IN  PFAX_RECIPIENT_CALLBACKA FaxRecipientCallback,
    IN  LPVOID Context
    );
typedef BOOL
(WINAPI *PFAXSENDDOCUMENTFORBROADCASTW)(
    IN  HANDLE FaxHandle,
    IN  LPCWSTR FileName,
    OUT LPDWORD FaxJobId,
    IN  PFAX_RECIPIENT_CALLBACKW FaxRecipientCallback,
    IN  LPVOID Context
    );
#ifdef UNICODE
#define PFAXSENDDOCUMENTFORBROADCAST  PFAXSENDDOCUMENTFORBROADCASTW
#else
#define PFAXSENDDOCUMENTFORBROADCAST  PFAXSENDDOCUMENTFORBROADCASTA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxEnumJobsA(
    IN  HANDLE FaxHandle,
    OUT PFAX_JOB_ENTRYA *JobEntry,
    OUT LPDWORD JobsReturned
    );
WINFAXAPI
BOOL
WINAPI
FaxEnumJobsW(
    IN  HANDLE FaxHandle,
    OUT PFAX_JOB_ENTRYW *JobEntry,
    OUT LPDWORD JobsReturned
    );
#ifdef UNICODE
#define FaxEnumJobs  FaxEnumJobsW
#else
#define FaxEnumJobs  FaxEnumJobsA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXENUMJOBSA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_JOB_ENTRYA *JobEntry,
    OUT LPDWORD JobsReturned
    );
typedef BOOL
(WINAPI *PFAXENUMJOBSW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_JOB_ENTRYW *JobEntry,
    OUT LPDWORD JobsReturned
    );
#ifdef UNICODE
#define PFAXENUMJOBS  PFAXENUMJOBSW
#else
#define PFAXENUMJOBS  PFAXENUMJOBSA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxGetJobA(
   IN  HANDLE FaxHandle,
   IN  DWORD JobId,
   OUT PFAX_JOB_ENTRYA *JobEntry
   );
WINFAXAPI
BOOL
WINAPI
FaxGetJobW(
   IN  HANDLE FaxHandle,
   IN  DWORD JobId,
   OUT PFAX_JOB_ENTRYW *JobEntry
   );
#ifdef UNICODE
#define FaxGetJob  FaxGetJobW
#else
#define FaxGetJob  FaxGetJobA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETJOBA)(
    IN  HANDLE FaxHandle,
    IN  DWORD JobId,
    OUT PFAX_JOB_ENTRYA *JobEntry
    );
typedef BOOL
(WINAPI *PFAXGETJOBW)(
    IN  HANDLE FaxHandle,
    IN  DWORD JobId,
    OUT PFAX_JOB_ENTRYW *JobEntry
    );
#ifdef UNICODE
#define PFAXGETJOB  PFAXGETJOBW
#else
#define PFAXGETJOB  PFAXGETJOBA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxSetJobA(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   IN DWORD Command,
   IN const FAX_JOB_ENTRYA *JobEntry
   );
WINFAXAPI
BOOL
WINAPI
FaxSetJobW(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   IN DWORD Command,
   IN const FAX_JOB_ENTRYW *JobEntry
   );
#ifdef UNICODE
#define FaxSetJob  FaxSetJobW
#else
#define FaxSetJob  FaxSetJobA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETJOBA)(
    IN HANDLE FaxHandle,
    IN DWORD JobId,
    IN DWORD Command,
    IN const FAX_JOB_ENTRYA *JobEntry
    );
typedef BOOL
(WINAPI *PFAXSETJOBW)(
    IN HANDLE FaxHandle,
    IN DWORD JobId,
    IN DWORD Command,
    IN const FAX_JOB_ENTRYW *JobEntry
    );
#ifdef UNICODE
#define PFAXSETJOB  PFAXSETJOBW
#else
#define PFAXSETJOB  PFAXSETJOBA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetPageData(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   OUT LPBYTE *Buffer,
   OUT LPDWORD BufferSize,
   OUT LPDWORD ImageWidth,
   OUT LPDWORD ImageHeight
   );

typedef BOOL
(WINAPI *PFAXGETPAGEDATA)(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   OUT LPBYTE *Buffer,
   OUT LPDWORD BufferSize,
   OUT LPDWORD ImageWidth,
   OUT LPDWORD ImageHeight
   );

WINFAXAPI
BOOL
WINAPI
FaxGetDeviceStatusA(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_DEVICE_STATUSA *DeviceStatus
    );
WINFAXAPI
BOOL
WINAPI
FaxGetDeviceStatusW(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_DEVICE_STATUSW *DeviceStatus
    );
#ifdef UNICODE
#define FaxGetDeviceStatus  FaxGetDeviceStatusW
#else
#define FaxGetDeviceStatus  FaxGetDeviceStatusA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETDEVICESTATUSA)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_DEVICE_STATUSA *DeviceStatus
    );
typedef BOOL
(WINAPI *PFAXGETDEVICESTATUSW)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_DEVICE_STATUSW *DeviceStatus
    );
#ifdef UNICODE
#define PFAXGETDEVICESTATUS  PFAXGETDEVICESTATUSW
#else
#define PFAXGETDEVICESTATUS  PFAXGETDEVICESTATUSA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxAbort(
    IN HANDLE FaxHandle,
    IN DWORD JobId
    );

typedef BOOL
(WINAPI *PFAXABORT)(
    IN HANDLE FaxHandle,
    IN DWORD JobId
    );

WINFAXAPI
BOOL
WINAPI
FaxGetConfigurationA(
    IN  HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONA *FaxConfig
    );
WINFAXAPI
BOOL
WINAPI
FaxGetConfigurationW(
    IN  HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONW *FaxConfig
    );
#ifdef UNICODE
#define FaxGetConfiguration  FaxGetConfigurationW
#else
#define FaxGetConfiguration  FaxGetConfigurationA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETCONFIGURATIONA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONA *FaxConfig
    );
typedef BOOL
(WINAPI *PFAXGETCONFIGURATIONW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONW *FaxConfig
    );
#ifdef UNICODE
#define PFAXGETCONFIGURATION  PFAXGETCONFIGURATIONW
#else
#define PFAXGETCONFIGURATION  PFAXGETCONFIGURATIONA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetConfigurationA(
    IN  HANDLE FaxHandle,
    IN  const FAX_CONFIGURATIONA *FaxConfig
    );
WINFAXAPI
BOOL
WINAPI
FaxSetConfigurationW(
    IN  HANDLE FaxHandle,
    IN  const FAX_CONFIGURATIONW *FaxConfig
    );
#ifdef UNICODE
#define FaxSetConfiguration  FaxSetConfigurationW
#else
#define FaxSetConfiguration  FaxSetConfigurationA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETCONFIGURATIONA)(
    IN  HANDLE FaxHandle,
    IN  const FAX_CONFIGURATIONA *FaxConfig
    );
typedef BOOL
(WINAPI *PFAXSETCONFIGURATIONW)(
    IN  HANDLE FaxHandle,
    IN  const FAX_CONFIGURATIONW *FaxConfig
    );
#ifdef UNICODE
#define PFAXSETCONFIGURATION  PFAXSETCONFIGURATIONW
#else
#define PFAXSETCONFIGURATION  PFAXSETCONFIGURATIONA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetLoggingCategoriesA(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYA *Categories,
    OUT LPDWORD NumberCategories
    );
WINFAXAPI
BOOL
WINAPI
FaxGetLoggingCategoriesW(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYW *Categories,
    OUT LPDWORD NumberCategories
    );
#ifdef UNICODE
#define FaxGetLoggingCategories  FaxGetLoggingCategoriesW
#else
#define FaxGetLoggingCategories  FaxGetLoggingCategoriesA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETLOGGINGCATEGORIESA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYA *Categories,
    OUT LPDWORD NumberCategories
    );
typedef BOOL
(WINAPI *PFAXGETLOGGINGCATEGORIESW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYW *Categories,
    OUT LPDWORD NumberCategories
    );
#ifdef UNICODE
#define PFAXGETLOGGINGCATEGORIES  PFAXGETLOGGINGCATEGORIESW
#else
#define PFAXGETLOGGINGCATEGORIES  PFAXGETLOGGINGCATEGORIESA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetLoggingCategoriesA(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYA *Categories,
    IN  DWORD NumberCategories
    );
WINFAXAPI
BOOL
WINAPI
FaxSetLoggingCategoriesW(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYW *Categories,
    IN  DWORD NumberCategories
    );
#ifdef UNICODE
#define FaxSetLoggingCategories  FaxSetLoggingCategoriesW
#else
#define FaxSetLoggingCategories  FaxSetLoggingCategoriesA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETLOGGINGCATEGORIESA)(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYA *Categories,
    IN  DWORD NumberCategories
    );
typedef BOOL
(WINAPI *PFAXSETLOGGINGCATEGORIESW)(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYW *Categories,
    IN  DWORD NumberCategories
    );
#ifdef UNICODE
#define PFAXSETLOGGINGCATEGORIES  PFAXSETLOGGINGCATEGORIESW
#else
#define PFAXSETLOGGINGCATEGORIES  PFAXSETLOGGINGCATEGORIESA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnumPortsA(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOA *PortInfo,
    OUT LPDWORD PortsReturned
    );
WINFAXAPI
BOOL
WINAPI
FaxEnumPortsW(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOW *PortInfo,
    OUT LPDWORD PortsReturned
    );
#ifdef UNICODE
#define FaxEnumPorts  FaxEnumPortsW
#else
#define FaxEnumPorts  FaxEnumPortsA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXENUMPORTSA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOA *PortInfo,
    OUT LPDWORD PortsReturned
    );
typedef BOOL
(WINAPI *PFAXENUMPORTSW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOW *PortInfo,
    OUT LPDWORD PortsReturned
    );
#ifdef UNICODE
#define PFAXENUMPORTS  PFAXENUMPORTSW
#else
#define PFAXENUMPORTS  PFAXENUMPORTSA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxGetPortA(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOA *PortInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxGetPortW(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOW *PortInfo
    );
#ifdef UNICODE
#define FaxGetPort  FaxGetPortW
#else
#define FaxGetPort  FaxGetPortA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETPORTA)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOA *PortInfo
    );
typedef BOOL
(WINAPI *PFAXGETPORTW)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOW *PortInfo
    );
#ifdef UNICODE
#define PFAXGETPORT  PFAXGETPORTW
#else
#define PFAXGETPORT  PFAXGETPORTA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxSetPortA(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_PORT_INFOA *PortInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxSetPortW(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_PORT_INFOW *PortInfo
    );
#ifdef UNICODE
#define FaxSetPort  FaxSetPortW
#else
#define FaxSetPort  FaxSetPortA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETPORTA)(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_PORT_INFOA *PortInfo
    );
typedef BOOL
(WINAPI *PFAXSETPORTW)(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_PORT_INFOW *PortInfo
    );
#ifdef UNICODE
#define PFAXSETPORT  PFAXSETPORTW
#else
#define PFAXSETPORT  PFAXSETPORTA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnumRoutingMethodsA(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODA *RoutingMethod,
    OUT LPDWORD MethodsReturned
    );
WINFAXAPI
BOOL
WINAPI
FaxEnumRoutingMethodsW(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODW *RoutingMethod,
    OUT LPDWORD MethodsReturned
    );
#ifdef UNICODE
#define FaxEnumRoutingMethods  FaxEnumRoutingMethodsW
#else
#define FaxEnumRoutingMethods  FaxEnumRoutingMethodsA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXENUMROUTINGMETHODSA)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODA *RoutingMethod,
    OUT LPDWORD MethodsReturned
    );
typedef BOOL
(WINAPI *PFAXENUMROUTINGMETHODSW)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODW *RoutingMethod,
    OUT LPDWORD MethodsReturned
    );
#ifdef UNICODE
#define PFAXENUMROUTINGMETHODS  PFAXENUMROUTINGMETHODSW
#else
#define PFAXENUMROUTINGMETHODS  PFAXENUMROUTINGMETHODSA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnableRoutingMethodA(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    IN  BOOL Enabled
    );
WINFAXAPI
BOOL
WINAPI
FaxEnableRoutingMethodW(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    IN  BOOL Enabled
    );
#ifdef UNICODE
#define FaxEnableRoutingMethod  FaxEnableRoutingMethodW
#else
#define FaxEnableRoutingMethod  FaxEnableRoutingMethodA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXENABLEROUTINGMETHODA)(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    IN  BOOL Enabled
    );
typedef BOOL
(WINAPI *PFAXENABLEROUTINGMETHODW)(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    IN  BOOL Enabled
    );
#ifdef UNICODE
#define PFAXENABLEROUTINGMETHOD  PFAXENABLEROUTINGMETHODW
#else
#define PFAXENABLEROUTINGMETHOD  PFAXENABLEROUTINGMETHODA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxEnumGlobalRoutingInfoA(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOA *RoutingInfo,
    OUT LPDWORD MethodsReturned
    );
WINFAXAPI
BOOL
WINAPI
FaxEnumGlobalRoutingInfoW(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOW *RoutingInfo,
    OUT LPDWORD MethodsReturned
    );
#ifdef UNICODE
#define FaxEnumGlobalRoutingInfo  FaxEnumGlobalRoutingInfoW
#else
#define FaxEnumGlobalRoutingInfo  FaxEnumGlobalRoutingInfoA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXENUMGLOBALROUTINGINFOA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOA *RoutingInfo,
    OUT LPDWORD MethodsReturned
    );
typedef BOOL
(WINAPI *PFAXENUMGLOBALROUTINGINFOW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOW *RoutingInfo,
    OUT LPDWORD MethodsReturned
    );
#ifdef UNICODE
#define PFAXENUMGLOBALROUTINGINFO  PFAXENUMGLOBALROUTINGINFOW
#else
#define PFAXENUMGLOBALROUTINGINFO  PFAXENUMGLOBALROUTINGINFOA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetGlobalRoutingInfoA(
    IN  HANDLE FaxHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOA *RoutingInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxSetGlobalRoutingInfoW(
    IN  HANDLE FaxHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOW *RoutingInfo
    );
#ifdef UNICODE
#define FaxSetGlobalRoutingInfo  FaxSetGlobalRoutingInfoW
#else
#define FaxSetGlobalRoutingInfo  FaxSetGlobalRoutingInfoA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETGLOBALROUTINGINFOA)(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOA *RoutingInfo
    );
typedef BOOL
(WINAPI *PFAXSETGLOBALROUTINGINFOW)(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOW *RoutingInfo
    );
#ifdef UNICODE
#define PFAXSETGLOBALROUTINGINFO  PFAXSETGLOBALROUTINGINFOW
#else
#define PFAXSETGLOBALROUTINGINFO  PFAXSETGLOBALROUTINGINFOA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetRoutingInfoA(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    );
WINFAXAPI
BOOL
WINAPI
FaxGetRoutingInfoW(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    );
#ifdef UNICODE
#define FaxGetRoutingInfo  FaxGetRoutingInfoW
#else
#define FaxGetRoutingInfo  FaxGetRoutingInfoA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETROUTINGINFOA)(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    );
typedef BOOL
(WINAPI *PFAXGETROUTINGINFOW)(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    );
#ifdef UNICODE
#define PFAXGETROUTINGINFO  PFAXGETROUTINGINFOW
#else
#define PFAXGETROUTINGINFO  PFAXGETROUTINGINFOA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxSetRoutingInfoA(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    IN  const BYTE *RoutingInfoBuffer,
    IN  DWORD RoutingInfoBufferSize
    );
WINFAXAPI
BOOL
WINAPI
FaxSetRoutingInfoW(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    IN  const BYTE *RoutingInfoBuffer,
    IN  DWORD RoutingInfoBufferSize
    );
#ifdef UNICODE
#define FaxSetRoutingInfo  FaxSetRoutingInfoW
#else
#define FaxSetRoutingInfo  FaxSetRoutingInfoA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETROUTINGINFOA)(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    IN  const BYTE *RoutingInfoBuffer,
    IN  DWORD RoutingInfoBufferSize
    );
typedef BOOL
(WINAPI *PFAXSETROUTINGINFOW)(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    IN  const BYTE *RoutingInfoBuffer,
    IN  DWORD RoutingInfoBufferSize
    );
#ifdef UNICODE
#define PFAXSETROUTINGINFO  PFAXSETROUTINGINFOW
#else
#define PFAXSETROUTINGINFO  PFAXSETROUTINGINFOA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxInitializeEventQueue(
    IN HANDLE FaxHandle,
    IN HANDLE CompletionPort,
    IN ULONG_PTR CompletionKey,
    IN HWND hWnd,
    IN UINT MessageStart
    );

typedef BOOL
(WINAPI *PFAXINITIALIZEEVENTQUEUE)(
    IN HANDLE FaxHandle,
    IN HANDLE CompletionPort,
    IN ULONG_PTR CompletionKey,
    IN HWND hWnd,
    IN UINT MessageStart
    );

WINFAXAPI
VOID
WINAPI
FaxFreeBuffer(
    LPVOID Buffer
    );

typedef VOID
(WINAPI *PFAXFREEBUFFER)(
    LPVOID Buffer
    );

WINFAXAPI
BOOL
WINAPI
FaxStartPrintJobA(
    IN  LPCSTR PrinterName,
    IN  const FAX_PRINT_INFOA *PrintInfo,
    OUT LPDWORD FaxJobId,
    OUT PFAX_CONTEXT_INFOA FaxContextInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxStartPrintJobW(
    IN  LPCWSTR PrinterName,
    IN  const FAX_PRINT_INFOW *PrintInfo,
    OUT LPDWORD FaxJobId,
    OUT PFAX_CONTEXT_INFOW FaxContextInfo
    );
#ifdef UNICODE
#define FaxStartPrintJob  FaxStartPrintJobW
#else
#define FaxStartPrintJob  FaxStartPrintJobA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSTARTPRINTJOBA)(
    IN  LPCSTR PrinterName,
    IN  const FAX_PRINT_INFOA *PrintInfo,
    OUT LPDWORD FaxJobId,
    OUT PFAX_CONTEXT_INFOA FaxContextInfo
    );
typedef BOOL
(WINAPI *PFAXSTARTPRINTJOBW)(
    IN  LPCWSTR PrinterName,
    IN  const FAX_PRINT_INFOW *PrintInfo,
    OUT LPDWORD FaxJobId,
    OUT PFAX_CONTEXT_INFOW FaxContextInfo
    );
#ifdef UNICODE
#define PFAXSTARTPRINTJOB  PFAXSTARTPRINTJOBW
#else
#define PFAXSTARTPRINTJOB  PFAXSTARTPRINTJOBA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxPrintCoverPageA(
    IN const FAX_CONTEXT_INFOA *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOA *CoverPageInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxPrintCoverPageW(
    IN const FAX_CONTEXT_INFOW *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOW *CoverPageInfo
    );
#ifdef UNICODE
#define FaxPrintCoverPage  FaxPrintCoverPageW
#else
#define FaxPrintCoverPage  FaxPrintCoverPageA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXPRINTCOVERPAGEA)(
    IN const FAX_CONTEXT_INFOA *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOA *CoverPageInfo
    );
typedef BOOL
(WINAPI *PFAXPRINTCOVERPAGEW)(
    IN const FAX_CONTEXT_INFOW *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOW *CoverPageInfo
    );
#ifdef UNICODE
#define PFAXPRINTCOVERPAGE  PFAXPRINTCOVERPAGEW
#else
#define PFAXPRINTCOVERPAGE  PFAXPRINTCOVERPAGEA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxRegisterServiceProviderW(
    IN LPCWSTR DeviceProvider,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN LPCWSTR TspName
    );

#define FaxRegisterServiceProvider  FaxRegisterServiceProviderW

typedef BOOL
(WINAPI *PFAXREGISTERSERVICEPROVIDERW)(
    IN LPCWSTR DeviceProvider,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN LPCWSTR TspName
    );

#define PFAXREGISTERSERVICEPROVIDER PFAXREGISTERSERVICEPROVIDERW

typedef BOOL
(CALLBACK *PFAX_ROUTING_INSTALLATION_CALLBACKW)(
    IN HANDLE FaxHandle,
    IN LPVOID Context,
    IN OUT LPWSTR MethodName,
    IN OUT LPWSTR FriendlyName,
    IN OUT LPWSTR FunctionName,
    IN OUT LPWSTR Guid
    );

#define PFAX_ROUTING_INSTALLATION_CALLBACK PFAX_ROUTING_INSTALLATION_CALLBACKW


WINFAXAPI
BOOL
WINAPI
FaxRegisterRoutingExtensionW(
    IN HANDLE  FaxHandle,
    IN LPCWSTR ExtensionName,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN PFAX_ROUTING_INSTALLATION_CALLBACKW CallBack,
    IN LPVOID Context
    );

#define FaxRegisterRoutingExtension FaxRegisterRoutingExtensionW


typedef BOOL
(WINAPI *PFAXREGISTERROUTINGEXTENSIONW)(
    IN HANDLE  FaxHandle,
    IN LPCWSTR ExtensionName,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN PFAX_ROUTING_INSTALLATION_CALLBACKW CallBack,
    IN LPVOID Context
    );

#define PFAXREGISTERROUTINGEXTENSION PFAXREGISTERROUTINGEXTENSIONW

WINFAXAPI
BOOL
WINAPI
FaxUnregisterRoutingExtensionA(
    IN HANDLE           hFaxHandle,
    IN LPCSTR         lpctstrExtensionName
);
WINFAXAPI
BOOL
WINAPI
FaxUnregisterRoutingExtensionW(
    IN HANDLE           hFaxHandle,
    IN LPCWSTR         lpctstrExtensionName
);
#ifdef UNICODE
#define FaxUnregisterRoutingExtension  FaxUnregisterRoutingExtensionW
#else
#define FaxUnregisterRoutingExtension  FaxUnregisterRoutingExtensionA
#endif // !UNICODE




WINFAXAPI
BOOL
WINAPI
FaxAccessCheck(
    IN HANDLE FaxHandle,
    IN DWORD  AccessMask
    );

typedef BOOL
(WINAPI *PFAXACCESSCHECK)(
    IN HANDLE FaxHandle,
    IN DWORD  AccessMask
    );

//
// Fax Specific Access Rights
//

#define FAX_JOB_SUBMIT          (0x0001)
#define FAX_JOB_QUERY           (0x0002)
#define FAX_CONFIG_QUERY        (0x0004)
#define FAX_CONFIG_SET          (0x0008)
#define FAX_PORT_QUERY          (0x0010)
#define FAX_PORT_SET            (0x0020)
#define FAX_JOB_MANAGE          (0x0040)

#define FAX_READ                (STANDARD_RIGHTS_READ        |\
                                 FAX_JOB_QUERY               |\
                                 FAX_CONFIG_QUERY            |\
                                 FAX_PORT_QUERY)

#define FAX_WRITE               (STANDARD_RIGHTS_WRITE       |\
                                 FAX_JOB_SUBMIT )

#define FAX_ALL_ACCESS          (STANDARD_RIGHTS_ALL         |\
                                 FAX_JOB_SUBMIT              |\
                                 FAX_JOB_QUERY               |\
                                 FAX_CONFIG_QUERY            |\
                                 FAX_CONFIG_SET              |\
                                 FAX_PORT_QUERY              |\
                                 FAX_PORT_SET                |\
                                 FAX_JOB_MANAGE)



#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\i386\chk\fxscount.h ===
//
//  faxcount.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the
//  "First Counter" and "First Help" values fo the device they belong to,
//  in order to determine the  absolute location of the counter and
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//

#define FAXOBJ                           0
#define INBOUND_BYTES                    2
#define INBOUND_FAXES                    4
#define INBOUND_PAGES                    6
#define INBOUND_MINUTES                  8
#define INBOUND_FAILED_RECEIVE          10
#define OUTBOUND_BYTES                  12
#define OUTBOUND_FAXES                  14
#define OUTBOUND_PAGES                  16
#define OUTBOUND_MINUTES                18
#define OUTBOUND_FAILED_CONNECTIONS     20
#define OUTBOUND_FAILED_XMIT            22
#define TOTAL_BYTES                     24
#define TOTAL_FAXES                     26
#define TOTAL_PAGES                     28
#define TOTAL_MINUTES                   30
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\amd64\fre\sdk\faxcom.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for faxcom.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __faxcom_h__
#define __faxcom_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IFaxTiff_FWD_DEFINED__
#define __IFaxTiff_FWD_DEFINED__
typedef interface IFaxTiff IFaxTiff;
#endif 	/* __IFaxTiff_FWD_DEFINED__ */


#ifndef __IFaxServer_FWD_DEFINED__
#define __IFaxServer_FWD_DEFINED__
typedef interface IFaxServer IFaxServer;
#endif 	/* __IFaxServer_FWD_DEFINED__ */


#ifndef __IFaxPort_FWD_DEFINED__
#define __IFaxPort_FWD_DEFINED__
typedef interface IFaxPort IFaxPort;
#endif 	/* __IFaxPort_FWD_DEFINED__ */


#ifndef __IFaxPorts_FWD_DEFINED__
#define __IFaxPorts_FWD_DEFINED__
typedef interface IFaxPorts IFaxPorts;
#endif 	/* __IFaxPorts_FWD_DEFINED__ */


#ifndef __IFaxRoutingMethod_FWD_DEFINED__
#define __IFaxRoutingMethod_FWD_DEFINED__
typedef interface IFaxRoutingMethod IFaxRoutingMethod;
#endif 	/* __IFaxRoutingMethod_FWD_DEFINED__ */


#ifndef __IFaxRoutingMethods_FWD_DEFINED__
#define __IFaxRoutingMethods_FWD_DEFINED__
typedef interface IFaxRoutingMethods IFaxRoutingMethods;
#endif 	/* __IFaxRoutingMethods_FWD_DEFINED__ */


#ifndef __IFaxStatus_FWD_DEFINED__
#define __IFaxStatus_FWD_DEFINED__
typedef interface IFaxStatus IFaxStatus;
#endif 	/* __IFaxStatus_FWD_DEFINED__ */


#ifndef __IFaxDoc_FWD_DEFINED__
#define __IFaxDoc_FWD_DEFINED__
typedef interface IFaxDoc IFaxDoc;
#endif 	/* __IFaxDoc_FWD_DEFINED__ */


#ifndef __IFaxJobs_FWD_DEFINED__
#define __IFaxJobs_FWD_DEFINED__
typedef interface IFaxJobs IFaxJobs;
#endif 	/* __IFaxJobs_FWD_DEFINED__ */


#ifndef __IFaxJob_FWD_DEFINED__
#define __IFaxJob_FWD_DEFINED__
typedef interface IFaxJob IFaxJob;
#endif 	/* __IFaxJob_FWD_DEFINED__ */


#ifndef __FaxTiff_FWD_DEFINED__
#define __FaxTiff_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxTiff FaxTiff;
#else
typedef struct FaxTiff FaxTiff;
#endif /* __cplusplus */

#endif 	/* __FaxTiff_FWD_DEFINED__ */


#ifndef __FaxServer_FWD_DEFINED__
#define __FaxServer_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxServer FaxServer;
#else
typedef struct FaxServer FaxServer;
#endif /* __cplusplus */

#endif 	/* __FaxServer_FWD_DEFINED__ */


#ifndef __FaxPort_FWD_DEFINED__
#define __FaxPort_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxPort FaxPort;
#else
typedef struct FaxPort FaxPort;
#endif /* __cplusplus */

#endif 	/* __FaxPort_FWD_DEFINED__ */


#ifndef __FaxPorts_FWD_DEFINED__
#define __FaxPorts_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxPorts FaxPorts;
#else
typedef struct FaxPorts FaxPorts;
#endif /* __cplusplus */

#endif 	/* __FaxPorts_FWD_DEFINED__ */


#ifndef __FaxRoutingMethod_FWD_DEFINED__
#define __FaxRoutingMethod_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxRoutingMethod FaxRoutingMethod;
#else
typedef struct FaxRoutingMethod FaxRoutingMethod;
#endif /* __cplusplus */

#endif 	/* __FaxRoutingMethod_FWD_DEFINED__ */


#ifndef __FaxRoutingMethods_FWD_DEFINED__
#define __FaxRoutingMethods_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxRoutingMethods FaxRoutingMethods;
#else
typedef struct FaxRoutingMethods FaxRoutingMethods;
#endif /* __cplusplus */

#endif 	/* __FaxRoutingMethods_FWD_DEFINED__ */


#ifndef __FaxStatus_FWD_DEFINED__
#define __FaxStatus_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxStatus FaxStatus;
#else
typedef struct FaxStatus FaxStatus;
#endif /* __cplusplus */

#endif 	/* __FaxStatus_FWD_DEFINED__ */


#ifndef __FaxDoc_FWD_DEFINED__
#define __FaxDoc_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxDoc FaxDoc;
#else
typedef struct FaxDoc FaxDoc;
#endif /* __cplusplus */

#endif 	/* __FaxDoc_FWD_DEFINED__ */


#ifndef __FaxJobs_FWD_DEFINED__
#define __FaxJobs_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxJobs FaxJobs;
#else
typedef struct FaxJobs FaxJobs;
#endif /* __cplusplus */

#endif 	/* __FaxJobs_FWD_DEFINED__ */


#ifndef __FaxJob_FWD_DEFINED__
#define __FaxJob_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxJob FaxJob;
#else
typedef struct FaxJob FaxJob;
#endif /* __cplusplus */

#endif 	/* __FaxJob_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IFaxTiff_INTERFACE_DEFINED__
#define __IFaxTiff_INTERFACE_DEFINED__

/* interface IFaxTiff */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxTiff;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b19bb45f-b91c-11d1-83e1-00c04fb6e984")
    IFaxTiff : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReceiveTime( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Image( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Image( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Routing( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallerId( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Csid( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Tsid( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientNumber( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RawReceiveTime( 
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TiffTagString( 
            /* [in] */ int tagID,
            /* [retval][out] */ BSTR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxTiffVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxTiff * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxTiff * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxTiff * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxTiff * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxTiff * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxTiff * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxTiff * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReceiveTime )( 
            IFaxTiff * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Image )( 
            IFaxTiff * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Image )( 
            IFaxTiff * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientName )( 
            IFaxTiff * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderName )( 
            IFaxTiff * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Routing )( 
            IFaxTiff * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallerId )( 
            IFaxTiff * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Csid )( 
            IFaxTiff * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Tsid )( 
            IFaxTiff * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientNumber )( 
            IFaxTiff * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawReceiveTime )( 
            IFaxTiff * This,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TiffTagString )( 
            IFaxTiff * This,
            /* [in] */ int tagID,
            /* [retval][out] */ BSTR *pVal);
        
        END_INTERFACE
    } IFaxTiffVtbl;

    interface IFaxTiff
    {
        CONST_VTBL struct IFaxTiffVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxTiff_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxTiff_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxTiff_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxTiff_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxTiff_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxTiff_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxTiff_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxTiff_get_ReceiveTime(This,pVal)	\
    (This)->lpVtbl -> get_ReceiveTime(This,pVal)

#define IFaxTiff_get_Image(This,pVal)	\
    (This)->lpVtbl -> get_Image(This,pVal)

#define IFaxTiff_put_Image(This,newVal)	\
    (This)->lpVtbl -> put_Image(This,newVal)

#define IFaxTiff_get_RecipientName(This,pVal)	\
    (This)->lpVtbl -> get_RecipientName(This,pVal)

#define IFaxTiff_get_SenderName(This,pVal)	\
    (This)->lpVtbl -> get_SenderName(This,pVal)

#define IFaxTiff_get_Routing(This,pVal)	\
    (This)->lpVtbl -> get_Routing(This,pVal)

#define IFaxTiff_get_CallerId(This,pVal)	\
    (This)->lpVtbl -> get_CallerId(This,pVal)

#define IFaxTiff_get_Csid(This,pVal)	\
    (This)->lpVtbl -> get_Csid(This,pVal)

#define IFaxTiff_get_Tsid(This,pVal)	\
    (This)->lpVtbl -> get_Tsid(This,pVal)

#define IFaxTiff_get_RecipientNumber(This,pVal)	\
    (This)->lpVtbl -> get_RecipientNumber(This,pVal)

#define IFaxTiff_get_RawReceiveTime(This,pVal)	\
    (This)->lpVtbl -> get_RawReceiveTime(This,pVal)

#define IFaxTiff_get_TiffTagString(This,tagID,pVal)	\
    (This)->lpVtbl -> get_TiffTagString(This,tagID,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_ReceiveTime_Proxy( 
    IFaxTiff * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxTiff_get_ReceiveTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_Image_Proxy( 
    IFaxTiff * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxTiff_get_Image_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxTiff_put_Image_Proxy( 
    IFaxTiff * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxTiff_put_Image_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_RecipientName_Proxy( 
    IFaxTiff * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxTiff_get_RecipientName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_SenderName_Proxy( 
    IFaxTiff * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxTiff_get_SenderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_Routing_Proxy( 
    IFaxTiff * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxTiff_get_Routing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_CallerId_Proxy( 
    IFaxTiff * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxTiff_get_CallerId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_Csid_Proxy( 
    IFaxTiff * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxTiff_get_Csid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_Tsid_Proxy( 
    IFaxTiff * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxTiff_get_Tsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_RecipientNumber_Proxy( 
    IFaxTiff * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxTiff_get_RecipientNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_RawReceiveTime_Proxy( 
    IFaxTiff * This,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IFaxTiff_get_RawReceiveTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_TiffTagString_Proxy( 
    IFaxTiff * This,
    /* [in] */ int tagID,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxTiff_get_TiffTagString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxTiff_INTERFACE_DEFINED__ */


#ifndef __IFaxServer_INTERFACE_DEFINED__
#define __IFaxServer_INTERFACE_DEFINED__

/* interface IFaxServer */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D73733C7-CC80-11D0-B225-00C04FB6C2F5")
    IFaxServer : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            BSTR ServerName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPorts( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateDocument( 
            BSTR FileName,
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetJobs( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Retries( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Retries( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RetryDelay( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RetryDelay( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DirtyDays( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DirtyDays( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Branding( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Branding( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UseDeviceTsid( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UseDeviceTsid( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ServerCoverpage( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ServerCoverpage( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PauseServerQueue( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PauseServerQueue( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ArchiveOutboundFaxes( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ArchiveOutboundFaxes( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ArchiveDirectory( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ArchiveDirectory( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ServerMapiProfile( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ServerMapiProfile( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscountRateStartHour( 
            /* [retval][out] */ short *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DiscountRateStartHour( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscountRateStartMinute( 
            /* [retval][out] */ short *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DiscountRateStartMinute( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscountRateEndHour( 
            /* [retval][out] */ short *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DiscountRateEndHour( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscountRateEndMinute( 
            /* [retval][out] */ short *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DiscountRateEndMinute( 
            /* [in] */ short newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxServer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxServer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxServer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxServer * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxServer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxServer * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxServer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IFaxServer * This,
            BSTR ServerName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IFaxServer * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPorts )( 
            IFaxServer * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateDocument )( 
            IFaxServer * This,
            BSTR FileName,
            /* [retval][out] */ VARIANT *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetJobs )( 
            IFaxServer * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Retries )( 
            IFaxServer * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Retries )( 
            IFaxServer * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RetryDelay )( 
            IFaxServer * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RetryDelay )( 
            IFaxServer * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DirtyDays )( 
            IFaxServer * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DirtyDays )( 
            IFaxServer * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Branding )( 
            IFaxServer * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Branding )( 
            IFaxServer * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseDeviceTsid )( 
            IFaxServer * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseDeviceTsid )( 
            IFaxServer * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServerCoverpage )( 
            IFaxServer * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ServerCoverpage )( 
            IFaxServer * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PauseServerQueue )( 
            IFaxServer * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PauseServerQueue )( 
            IFaxServer * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ArchiveOutboundFaxes )( 
            IFaxServer * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ArchiveOutboundFaxes )( 
            IFaxServer * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ArchiveDirectory )( 
            IFaxServer * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ArchiveDirectory )( 
            IFaxServer * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServerMapiProfile )( 
            IFaxServer * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ServerMapiProfile )( 
            IFaxServer * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiscountRateStartHour )( 
            IFaxServer * This,
            /* [retval][out] */ short *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DiscountRateStartHour )( 
            IFaxServer * This,
            /* [in] */ short newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiscountRateStartMinute )( 
            IFaxServer * This,
            /* [retval][out] */ short *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DiscountRateStartMinute )( 
            IFaxServer * This,
            /* [in] */ short newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiscountRateEndHour )( 
            IFaxServer * This,
            /* [retval][out] */ short *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DiscountRateEndHour )( 
            IFaxServer * This,
            /* [in] */ short newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiscountRateEndMinute )( 
            IFaxServer * This,
            /* [retval][out] */ short *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DiscountRateEndMinute )( 
            IFaxServer * This,
            /* [in] */ short newVal);
        
        END_INTERFACE
    } IFaxServerVtbl;

    interface IFaxServer
    {
        CONST_VTBL struct IFaxServerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxServer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxServer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxServer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxServer_Connect(This,ServerName)	\
    (This)->lpVtbl -> Connect(This,ServerName)

#define IFaxServer_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IFaxServer_GetPorts(This,retval)	\
    (This)->lpVtbl -> GetPorts(This,retval)

#define IFaxServer_CreateDocument(This,FileName,retval)	\
    (This)->lpVtbl -> CreateDocument(This,FileName,retval)

#define IFaxServer_GetJobs(This,retval)	\
    (This)->lpVtbl -> GetJobs(This,retval)

#define IFaxServer_get_Retries(This,pVal)	\
    (This)->lpVtbl -> get_Retries(This,pVal)

#define IFaxServer_put_Retries(This,newVal)	\
    (This)->lpVtbl -> put_Retries(This,newVal)

#define IFaxServer_get_RetryDelay(This,pVal)	\
    (This)->lpVtbl -> get_RetryDelay(This,pVal)

#define IFaxServer_put_RetryDelay(This,newVal)	\
    (This)->lpVtbl -> put_RetryDelay(This,newVal)

#define IFaxServer_get_DirtyDays(This,pVal)	\
    (This)->lpVtbl -> get_DirtyDays(This,pVal)

#define IFaxServer_put_DirtyDays(This,newVal)	\
    (This)->lpVtbl -> put_DirtyDays(This,newVal)

#define IFaxServer_get_Branding(This,pVal)	\
    (This)->lpVtbl -> get_Branding(This,pVal)

#define IFaxServer_put_Branding(This,newVal)	\
    (This)->lpVtbl -> put_Branding(This,newVal)

#define IFaxServer_get_UseDeviceTsid(This,pVal)	\
    (This)->lpVtbl -> get_UseDeviceTsid(This,pVal)

#define IFaxServer_put_UseDeviceTsid(This,newVal)	\
    (This)->lpVtbl -> put_UseDeviceTsid(This,newVal)

#define IFaxServer_get_ServerCoverpage(This,pVal)	\
    (This)->lpVtbl -> get_ServerCoverpage(This,pVal)

#define IFaxServer_put_ServerCoverpage(This,newVal)	\
    (This)->lpVtbl -> put_ServerCoverpage(This,newVal)

#define IFaxServer_get_PauseServerQueue(This,pVal)	\
    (This)->lpVtbl -> get_PauseServerQueue(This,pVal)

#define IFaxServer_put_PauseServerQueue(This,newVal)	\
    (This)->lpVtbl -> put_PauseServerQueue(This,newVal)

#define IFaxServer_get_ArchiveOutboundFaxes(This,pVal)	\
    (This)->lpVtbl -> get_ArchiveOutboundFaxes(This,pVal)

#define IFaxServer_put_ArchiveOutboundFaxes(This,newVal)	\
    (This)->lpVtbl -> put_ArchiveOutboundFaxes(This,newVal)

#define IFaxServer_get_ArchiveDirectory(This,pVal)	\
    (This)->lpVtbl -> get_ArchiveDirectory(This,pVal)

#define IFaxServer_put_ArchiveDirectory(This,newVal)	\
    (This)->lpVtbl -> put_ArchiveDirectory(This,newVal)

#define IFaxServer_get_ServerMapiProfile(This,pVal)	\
    (This)->lpVtbl -> get_ServerMapiProfile(This,pVal)

#define IFaxServer_put_ServerMapiProfile(This,newVal)	\
    (This)->lpVtbl -> put_ServerMapiProfile(This,newVal)

#define IFaxServer_get_DiscountRateStartHour(This,pVal)	\
    (This)->lpVtbl -> get_DiscountRateStartHour(This,pVal)

#define IFaxServer_put_DiscountRateStartHour(This,newVal)	\
    (This)->lpVtbl -> put_DiscountRateStartHour(This,newVal)

#define IFaxServer_get_DiscountRateStartMinute(This,pVal)	\
    (This)->lpVtbl -> get_DiscountRateStartMinute(This,pVal)

#define IFaxServer_put_DiscountRateStartMinute(This,newVal)	\
    (This)->lpVtbl -> put_DiscountRateStartMinute(This,newVal)

#define IFaxServer_get_DiscountRateEndHour(This,pVal)	\
    (This)->lpVtbl -> get_DiscountRateEndHour(This,pVal)

#define IFaxServer_put_DiscountRateEndHour(This,newVal)	\
    (This)->lpVtbl -> put_DiscountRateEndHour(This,newVal)

#define IFaxServer_get_DiscountRateEndMinute(This,pVal)	\
    (This)->lpVtbl -> get_DiscountRateEndMinute(This,pVal)

#define IFaxServer_put_DiscountRateEndMinute(This,newVal)	\
    (This)->lpVtbl -> put_DiscountRateEndMinute(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_Connect_Proxy( 
    IFaxServer * This,
    BSTR ServerName);


void __RPC_STUB IFaxServer_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_Disconnect_Proxy( 
    IFaxServer * This);


void __RPC_STUB IFaxServer_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_GetPorts_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IFaxServer_GetPorts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_CreateDocument_Proxy( 
    IFaxServer * This,
    BSTR FileName,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IFaxServer_CreateDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_GetJobs_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IFaxServer_GetJobs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_Retries_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxServer_get_Retries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_Retries_Proxy( 
    IFaxServer * This,
    /* [in] */ long newVal);


void __RPC_STUB IFaxServer_put_Retries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_RetryDelay_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxServer_get_RetryDelay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_RetryDelay_Proxy( 
    IFaxServer * This,
    /* [in] */ long newVal);


void __RPC_STUB IFaxServer_put_RetryDelay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_DirtyDays_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxServer_get_DirtyDays_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_DirtyDays_Proxy( 
    IFaxServer * This,
    /* [in] */ long newVal);


void __RPC_STUB IFaxServer_put_DirtyDays_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_Branding_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxServer_get_Branding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_Branding_Proxy( 
    IFaxServer * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxServer_put_Branding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_UseDeviceTsid_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxServer_get_UseDeviceTsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_UseDeviceTsid_Proxy( 
    IFaxServer * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxServer_put_UseDeviceTsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_ServerCoverpage_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxServer_get_ServerCoverpage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_ServerCoverpage_Proxy( 
    IFaxServer * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxServer_put_ServerCoverpage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_PauseServerQueue_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxServer_get_PauseServerQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_PauseServerQueue_Proxy( 
    IFaxServer * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxServer_put_PauseServerQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_ArchiveOutboundFaxes_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxServer_get_ArchiveOutboundFaxes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_ArchiveOutboundFaxes_Proxy( 
    IFaxServer * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxServer_put_ArchiveOutboundFaxes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_ArchiveDirectory_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxServer_get_ArchiveDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_ArchiveDirectory_Proxy( 
    IFaxServer * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxServer_put_ArchiveDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_ServerMapiProfile_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxServer_get_ServerMapiProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_ServerMapiProfile_Proxy( 
    IFaxServer * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxServer_put_ServerMapiProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_DiscountRateStartHour_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ short *pVal);


void __RPC_STUB IFaxServer_get_DiscountRateStartHour_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_DiscountRateStartHour_Proxy( 
    IFaxServer * This,
    /* [in] */ short newVal);


void __RPC_STUB IFaxServer_put_DiscountRateStartHour_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_DiscountRateStartMinute_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ short *pVal);


void __RPC_STUB IFaxServer_get_DiscountRateStartMinute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_DiscountRateStartMinute_Proxy( 
    IFaxServer * This,
    /* [in] */ short newVal);


void __RPC_STUB IFaxServer_put_DiscountRateStartMinute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_DiscountRateEndHour_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ short *pVal);


void __RPC_STUB IFaxServer_get_DiscountRateEndHour_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_DiscountRateEndHour_Proxy( 
    IFaxServer * This,
    /* [in] */ short newVal);


void __RPC_STUB IFaxServer_put_DiscountRateEndHour_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_DiscountRateEndMinute_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ short *pVal);


void __RPC_STUB IFaxServer_get_DiscountRateEndMinute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_DiscountRateEndMinute_Proxy( 
    IFaxServer * This,
    /* [in] */ short newVal);


void __RPC_STUB IFaxServer_put_DiscountRateEndMinute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxServer_INTERFACE_DEFINED__ */


#ifndef __IFaxPort_INTERFACE_DEFINED__
#define __IFaxPort_INTERFACE_DEFINED__

/* interface IFaxPort */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxPort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D73733CC-CC80-11D0-B225-00C04FB6C2F5")
    IFaxPort : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceId( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Rings( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Rings( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Csid( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Csid( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Tsid( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Tsid( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Send( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Send( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Receive( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Receive( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Priority( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Priority( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetRoutingMethods( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CanModify( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [retval][out] */ VARIANT *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxPortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxPort * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxPort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxPort * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxPort * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxPort * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxPort * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxPort * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IFaxPort * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceId )( 
            IFaxPort * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Rings )( 
            IFaxPort * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Rings )( 
            IFaxPort * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Csid )( 
            IFaxPort * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Csid )( 
            IFaxPort * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Tsid )( 
            IFaxPort * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Tsid )( 
            IFaxPort * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Send )( 
            IFaxPort * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Send )( 
            IFaxPort * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Receive )( 
            IFaxPort * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Receive )( 
            IFaxPort * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Priority )( 
            IFaxPort * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Priority )( 
            IFaxPort * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetRoutingMethods )( 
            IFaxPort * This,
            /* [retval][out] */ VARIANT *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanModify )( 
            IFaxPort * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IFaxPort * This,
            /* [retval][out] */ VARIANT *retval);
        
        END_INTERFACE
    } IFaxPortVtbl;

    interface IFaxPort
    {
        CONST_VTBL struct IFaxPortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxPort_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxPort_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxPort_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxPort_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxPort_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxPort_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxPort_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxPort_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IFaxPort_get_DeviceId(This,pVal)	\
    (This)->lpVtbl -> get_DeviceId(This,pVal)

#define IFaxPort_get_Rings(This,pVal)	\
    (This)->lpVtbl -> get_Rings(This,pVal)

#define IFaxPort_put_Rings(This,newVal)	\
    (This)->lpVtbl -> put_Rings(This,newVal)

#define IFaxPort_get_Csid(This,pVal)	\
    (This)->lpVtbl -> get_Csid(This,pVal)

#define IFaxPort_put_Csid(This,newVal)	\
    (This)->lpVtbl -> put_Csid(This,newVal)

#define IFaxPort_get_Tsid(This,pVal)	\
    (This)->lpVtbl -> get_Tsid(This,pVal)

#define IFaxPort_put_Tsid(This,newVal)	\
    (This)->lpVtbl -> put_Tsid(This,newVal)

#define IFaxPort_get_Send(This,pVal)	\
    (This)->lpVtbl -> get_Send(This,pVal)

#define IFaxPort_put_Send(This,newVal)	\
    (This)->lpVtbl -> put_Send(This,newVal)

#define IFaxPort_get_Receive(This,pVal)	\
    (This)->lpVtbl -> get_Receive(This,pVal)

#define IFaxPort_put_Receive(This,newVal)	\
    (This)->lpVtbl -> put_Receive(This,newVal)

#define IFaxPort_get_Priority(This,pVal)	\
    (This)->lpVtbl -> get_Priority(This,pVal)

#define IFaxPort_put_Priority(This,newVal)	\
    (This)->lpVtbl -> put_Priority(This,newVal)

#define IFaxPort_GetRoutingMethods(This,retval)	\
    (This)->lpVtbl -> GetRoutingMethods(This,retval)

#define IFaxPort_get_CanModify(This,pVal)	\
    (This)->lpVtbl -> get_CanModify(This,pVal)

#define IFaxPort_GetStatus(This,retval)	\
    (This)->lpVtbl -> GetStatus(This,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_Name_Proxy( 
    IFaxPort * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxPort_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_DeviceId_Proxy( 
    IFaxPort * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxPort_get_DeviceId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_Rings_Proxy( 
    IFaxPort * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxPort_get_Rings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxPort_put_Rings_Proxy( 
    IFaxPort * This,
    /* [in] */ long newVal);


void __RPC_STUB IFaxPort_put_Rings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_Csid_Proxy( 
    IFaxPort * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxPort_get_Csid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxPort_put_Csid_Proxy( 
    IFaxPort * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxPort_put_Csid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_Tsid_Proxy( 
    IFaxPort * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxPort_get_Tsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxPort_put_Tsid_Proxy( 
    IFaxPort * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxPort_put_Tsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_Send_Proxy( 
    IFaxPort * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxPort_get_Send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxPort_put_Send_Proxy( 
    IFaxPort * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxPort_put_Send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_Receive_Proxy( 
    IFaxPort * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxPort_get_Receive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxPort_put_Receive_Proxy( 
    IFaxPort * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxPort_put_Receive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_Priority_Proxy( 
    IFaxPort * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxPort_get_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxPort_put_Priority_Proxy( 
    IFaxPort * This,
    /* [in] */ long newVal);


void __RPC_STUB IFaxPort_put_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxPort_GetRoutingMethods_Proxy( 
    IFaxPort * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IFaxPort_GetRoutingMethods_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_CanModify_Proxy( 
    IFaxPort * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxPort_get_CanModify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxPort_GetStatus_Proxy( 
    IFaxPort * This,
    /* [retval][out] */ VARIANT *retval);


void __RPC_STUB IFaxPort_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxPort_INTERFACE_DEFINED__ */


#ifndef __IFaxPorts_INTERFACE_DEFINED__
#define __IFaxPorts_INTERFACE_DEFINED__

/* interface IFaxPorts */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxPorts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D73733D5-CC80-11D0-B225-00C04FB6C2F5")
    IFaxPorts : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            long Index,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxPortsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxPorts * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxPorts * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxPorts * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxPorts * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxPorts * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxPorts * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxPorts * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxPorts * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxPorts * This,
            long Index,
            /* [retval][out] */ VARIANT *pVal);
        
        END_INTERFACE
    } IFaxPortsVtbl;

    interface IFaxPorts
    {
        CONST_VTBL struct IFaxPortsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxPorts_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxPorts_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxPorts_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxPorts_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxPorts_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxPorts_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxPorts_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxPorts_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IFaxPorts_get_Item(This,Index,pVal)	\
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPorts_get_Count_Proxy( 
    IFaxPorts * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxPorts_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPorts_get_Item_Proxy( 
    IFaxPorts * This,
    long Index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IFaxPorts_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxPorts_INTERFACE_DEFINED__ */


#ifndef __IFaxRoutingMethod_INTERFACE_DEFINED__
#define __IFaxRoutingMethod_INTERFACE_DEFINED__

/* interface IFaxRoutingMethod */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxRoutingMethod;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2199F5F3-CEFC-11D0-A341-0000F800E68D")
    IFaxRoutingMethod : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceId( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Enable( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Enable( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Guid( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FunctionName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ImageName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FriendlyName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtensionName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RoutingData( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxRoutingMethodVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxRoutingMethod * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxRoutingMethod * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxRoutingMethod * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxRoutingMethod * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxRoutingMethod * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxRoutingMethod * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxRoutingMethod * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceId )( 
            IFaxRoutingMethod * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Enable )( 
            IFaxRoutingMethod * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Enable )( 
            IFaxRoutingMethod * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceName )( 
            IFaxRoutingMethod * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Guid )( 
            IFaxRoutingMethod * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FunctionName )( 
            IFaxRoutingMethod * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ImageName )( 
            IFaxRoutingMethod * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FriendlyName )( 
            IFaxRoutingMethod * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExtensionName )( 
            IFaxRoutingMethod * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RoutingData )( 
            IFaxRoutingMethod * This,
            /* [retval][out] */ BSTR *pVal);
        
        END_INTERFACE
    } IFaxRoutingMethodVtbl;

    interface IFaxRoutingMethod
    {
        CONST_VTBL struct IFaxRoutingMethodVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxRoutingMethod_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxRoutingMethod_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxRoutingMethod_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxRoutingMethod_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxRoutingMethod_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxRoutingMethod_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxRoutingMethod_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxRoutingMethod_get_DeviceId(This,pVal)	\
    (This)->lpVtbl -> get_DeviceId(This,pVal)

#define IFaxRoutingMethod_get_Enable(This,pVal)	\
    (This)->lpVtbl -> get_Enable(This,pVal)

#define IFaxRoutingMethod_put_Enable(This,newVal)	\
    (This)->lpVtbl -> put_Enable(This,newVal)

#define IFaxRoutingMethod_get_DeviceName(This,pVal)	\
    (This)->lpVtbl -> get_DeviceName(This,pVal)

#define IFaxRoutingMethod_get_Guid(This,pVal)	\
    (This)->lpVtbl -> get_Guid(This,pVal)

#define IFaxRoutingMethod_get_FunctionName(This,pVal)	\
    (This)->lpVtbl -> get_FunctionName(This,pVal)

#define IFaxRoutingMethod_get_ImageName(This,pVal)	\
    (This)->lpVtbl -> get_ImageName(This,pVal)

#define IFaxRoutingMethod_get_FriendlyName(This,pVal)	\
    (This)->lpVtbl -> get_FriendlyName(This,pVal)

#define IFaxRoutingMethod_get_ExtensionName(This,pVal)	\
    (This)->lpVtbl -> get_ExtensionName(This,pVal)

#define IFaxRoutingMethod_get_RoutingData(This,pVal)	\
    (This)->lpVtbl -> get_RoutingData(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_DeviceId_Proxy( 
    IFaxRoutingMethod * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxRoutingMethod_get_DeviceId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_Enable_Proxy( 
    IFaxRoutingMethod * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxRoutingMethod_get_Enable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_put_Enable_Proxy( 
    IFaxRoutingMethod * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxRoutingMethod_put_Enable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_DeviceName_Proxy( 
    IFaxRoutingMethod * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxRoutingMethod_get_DeviceName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_Guid_Proxy( 
    IFaxRoutingMethod * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxRoutingMethod_get_Guid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_FunctionName_Proxy( 
    IFaxRoutingMethod * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxRoutingMethod_get_FunctionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_ImageName_Proxy( 
    IFaxRoutingMethod * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxRoutingMethod_get_ImageName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_FriendlyName_Proxy( 
    IFaxRoutingMethod * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxRoutingMethod_get_FriendlyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_ExtensionName_Proxy( 
    IFaxRoutingMethod * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxRoutingMethod_get_ExtensionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_RoutingData_Proxy( 
    IFaxRoutingMethod * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxRoutingMethod_get_RoutingData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxRoutingMethod_INTERFACE_DEFINED__ */


#ifndef __IFaxRoutingMethods_INTERFACE_DEFINED__
#define __IFaxRoutingMethods_INTERFACE_DEFINED__

/* interface IFaxRoutingMethods */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxRoutingMethods;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2199F5F5-CEFC-11D0-A341-0000F800E68D")
    IFaxRoutingMethods : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxRoutingMethodsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxRoutingMethods * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxRoutingMethods * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxRoutingMethods * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxRoutingMethods * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxRoutingMethods * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxRoutingMethods * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxRoutingMethods * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxRoutingMethods * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxRoutingMethods * This,
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal);
        
        END_INTERFACE
    } IFaxRoutingMethodsVtbl;

    interface IFaxRoutingMethods
    {
        CONST_VTBL struct IFaxRoutingMethodsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxRoutingMethods_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxRoutingMethods_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxRoutingMethods_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxRoutingMethods_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxRoutingMethods_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxRoutingMethods_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxRoutingMethods_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxRoutingMethods_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IFaxRoutingMethods_get_Item(This,Index,pVal)	\
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethods_get_Count_Proxy( 
    IFaxRoutingMethods * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxRoutingMethods_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethods_get_Item_Proxy( 
    IFaxRoutingMethods * This,
    /* [in] */ long Index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IFaxRoutingMethods_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxRoutingMethods_INTERFACE_DEFINED__ */


#ifndef __IFaxStatus_INTERFACE_DEFINED__
#define __IFaxStatus_INTERFACE_DEFINED__

/* interface IFaxStatus */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8B97E605-D054-11D0-B226-00C04FB6C2F5")
    IFaxStatus : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallerId( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Csid( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPage( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceId( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DocumentName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Send( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Receive( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Address( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RoutingString( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DocumentSize( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PageCount( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Tsid( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartTime( 
            /* [retval][out] */ DATE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubmittedTime( 
            /* [retval][out] */ DATE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ElapsedTime( 
            /* [retval][out] */ DATE *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxStatus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxStatus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxStatus * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxStatus * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxStatus * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxStatus * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxStatus * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallerId )( 
            IFaxStatus * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Csid )( 
            IFaxStatus * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPage )( 
            IFaxStatus * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceId )( 
            IFaxStatus * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceName )( 
            IFaxStatus * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocumentName )( 
            IFaxStatus * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Send )( 
            IFaxStatus * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Receive )( 
            IFaxStatus * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Address )( 
            IFaxStatus * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RoutingString )( 
            IFaxStatus * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderName )( 
            IFaxStatus * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientName )( 
            IFaxStatus * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocumentSize )( 
            IFaxStatus * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IFaxStatus * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PageCount )( 
            IFaxStatus * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Tsid )( 
            IFaxStatus * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartTime )( 
            IFaxStatus * This,
            /* [retval][out] */ DATE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubmittedTime )( 
            IFaxStatus * This,
            /* [retval][out] */ DATE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ElapsedTime )( 
            IFaxStatus * This,
            /* [retval][out] */ DATE *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxStatus * This);
        
        END_INTERFACE
    } IFaxStatusVtbl;

    interface IFaxStatus
    {
        CONST_VTBL struct IFaxStatusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxStatus_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxStatus_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxStatus_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxStatus_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxStatus_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxStatus_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxStatus_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxStatus_get_CallerId(This,pVal)	\
    (This)->lpVtbl -> get_CallerId(This,pVal)

#define IFaxStatus_get_Csid(This,pVal)	\
    (This)->lpVtbl -> get_Csid(This,pVal)

#define IFaxStatus_get_CurrentPage(This,pVal)	\
    (This)->lpVtbl -> get_CurrentPage(This,pVal)

#define IFaxStatus_get_DeviceId(This,pVal)	\
    (This)->lpVtbl -> get_DeviceId(This,pVal)

#define IFaxStatus_get_DeviceName(This,pVal)	\
    (This)->lpVtbl -> get_DeviceName(This,pVal)

#define IFaxStatus_get_DocumentName(This,pVal)	\
    (This)->lpVtbl -> get_DocumentName(This,pVal)

#define IFaxStatus_get_Send(This,pVal)	\
    (This)->lpVtbl -> get_Send(This,pVal)

#define IFaxStatus_get_Receive(This,pVal)	\
    (This)->lpVtbl -> get_Receive(This,pVal)

#define IFaxStatus_get_Address(This,pVal)	\
    (This)->lpVtbl -> get_Address(This,pVal)

#define IFaxStatus_get_RoutingString(This,pVal)	\
    (This)->lpVtbl -> get_RoutingString(This,pVal)

#define IFaxStatus_get_SenderName(This,pVal)	\
    (This)->lpVtbl -> get_SenderName(This,pVal)

#define IFaxStatus_get_RecipientName(This,pVal)	\
    (This)->lpVtbl -> get_RecipientName(This,pVal)

#define IFaxStatus_get_DocumentSize(This,pVal)	\
    (This)->lpVtbl -> get_DocumentSize(This,pVal)

#define IFaxStatus_get_Description(This,pVal)	\
    (This)->lpVtbl -> get_Description(This,pVal)

#define IFaxStatus_get_PageCount(This,pVal)	\
    (This)->lpVtbl -> get_PageCount(This,pVal)

#define IFaxStatus_get_Tsid(This,pVal)	\
    (This)->lpVtbl -> get_Tsid(This,pVal)

#define IFaxStatus_get_StartTime(This,pVal)	\
    (This)->lpVtbl -> get_StartTime(This,pVal)

#define IFaxStatus_get_SubmittedTime(This,pVal)	\
    (This)->lpVtbl -> get_SubmittedTime(This,pVal)

#define IFaxStatus_get_ElapsedTime(This,pVal)	\
    (This)->lpVtbl -> get_ElapsedTime(This,pVal)

#define IFaxStatus_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_CallerId_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxStatus_get_CallerId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_Csid_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxStatus_get_Csid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_CurrentPage_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxStatus_get_CurrentPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_DeviceId_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxStatus_get_DeviceId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_DeviceName_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxStatus_get_DeviceName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_DocumentName_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxStatus_get_DocumentName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_Send_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxStatus_get_Send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_Receive_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxStatus_get_Receive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_Address_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxStatus_get_Address_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_RoutingString_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxStatus_get_RoutingString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_SenderName_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxStatus_get_SenderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_RecipientName_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxStatus_get_RecipientName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_DocumentSize_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxStatus_get_DocumentSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_Description_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxStatus_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_PageCount_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxStatus_get_PageCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_Tsid_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxStatus_get_Tsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_StartTime_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ DATE *pVal);


void __RPC_STUB IFaxStatus_get_StartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_SubmittedTime_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ DATE *pVal);


void __RPC_STUB IFaxStatus_get_SubmittedTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_ElapsedTime_Proxy( 
    IFaxStatus * This,
    /* [retval][out] */ DATE *pVal);


void __RPC_STUB IFaxStatus_get_ElapsedTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxStatus_Refresh_Proxy( 
    IFaxStatus * This);


void __RPC_STUB IFaxStatus_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxStatus_INTERFACE_DEFINED__ */


#ifndef __IFaxDoc_INTERFACE_DEFINED__
#define __IFaxDoc_INTERFACE_DEFINED__

/* interface IFaxDoc */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxDoc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FA21F4C5-5C4C-11D1-83CF-00C04FB6E984")
    IFaxDoc : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FileName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FileName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CoverpageName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CoverpageName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SendCoverpage( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SendCoverpage( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ServerCoverpage( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ServerCoverpage( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscountSend( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DiscountSend( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientCompany( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientCompany( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientAddress( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientAddress( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientCity( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientCity( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientState( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientState( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientZip( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientZip( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientCountry( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientCountry( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientTitle( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientTitle( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientDepartment( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientDepartment( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientOffice( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientOffice( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientHomePhone( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientHomePhone( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientOfficePhone( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientOfficePhone( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderCompany( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderCompany( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderAddress( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderAddress( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderTitle( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderTitle( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderDepartment( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderDepartment( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderOffice( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderOffice( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderHomePhone( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderHomePhone( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderOfficePhone( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderOfficePhone( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CoverpageNote( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CoverpageNote( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CoverpageSubject( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CoverpageSubject( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Tsid( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Tsid( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BillingCode( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BillingCode( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EmailAddress( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EmailAddress( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DisplayName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Send( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FaxNumber( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FaxNumber( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_ConnectionObject( 
            /* [in] */ IDispatch *newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallHandle( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CallHandle( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderFax( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderFax( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxDocVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxDoc * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxDoc * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxDoc * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxDoc * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxDoc * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxDoc * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxDoc * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CoverpageName )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CoverpageName )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SendCoverpage )( 
            IFaxDoc * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SendCoverpage )( 
            IFaxDoc * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServerCoverpage )( 
            IFaxDoc * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ServerCoverpage )( 
            IFaxDoc * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiscountSend )( 
            IFaxDoc * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DiscountSend )( 
            IFaxDoc * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientName )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientName )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientCompany )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientCompany )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientAddress )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientAddress )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientCity )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientCity )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientState )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientState )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientZip )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientZip )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientCountry )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientCountry )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientTitle )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientTitle )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientDepartment )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientDepartment )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientOffice )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientOffice )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientHomePhone )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientHomePhone )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientOfficePhone )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RecipientOfficePhone )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderName )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SenderName )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderCompany )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SenderCompany )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderAddress )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SenderAddress )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderTitle )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SenderTitle )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderDepartment )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SenderDepartment )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderOffice )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SenderOffice )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderHomePhone )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SenderHomePhone )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderOfficePhone )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SenderOfficePhone )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CoverpageNote )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CoverpageNote )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CoverpageSubject )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CoverpageSubject )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Tsid )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Tsid )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BillingCode )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BillingCode )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EmailAddress )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EmailAddress )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayName )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayName )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Send )( 
            IFaxDoc * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FaxNumber )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FaxNumber )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_ConnectionObject )( 
            IFaxDoc * This,
            /* [in] */ IDispatch *newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallHandle )( 
            IFaxDoc * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CallHandle )( 
            IFaxDoc * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderFax )( 
            IFaxDoc * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SenderFax )( 
            IFaxDoc * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IFaxDocVtbl;

    interface IFaxDoc
    {
        CONST_VTBL struct IFaxDocVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxDoc_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxDoc_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxDoc_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxDoc_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxDoc_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxDoc_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxDoc_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxDoc_get_FileName(This,pVal)	\
    (This)->lpVtbl -> get_FileName(This,pVal)

#define IFaxDoc_put_FileName(This,newVal)	\
    (This)->lpVtbl -> put_FileName(This,newVal)

#define IFaxDoc_get_CoverpageName(This,pVal)	\
    (This)->lpVtbl -> get_CoverpageName(This,pVal)

#define IFaxDoc_put_CoverpageName(This,newVal)	\
    (This)->lpVtbl -> put_CoverpageName(This,newVal)

#define IFaxDoc_get_SendCoverpage(This,pVal)	\
    (This)->lpVtbl -> get_SendCoverpage(This,pVal)

#define IFaxDoc_put_SendCoverpage(This,newVal)	\
    (This)->lpVtbl -> put_SendCoverpage(This,newVal)

#define IFaxDoc_get_ServerCoverpage(This,pVal)	\
    (This)->lpVtbl -> get_ServerCoverpage(This,pVal)

#define IFaxDoc_put_ServerCoverpage(This,newVal)	\
    (This)->lpVtbl -> put_ServerCoverpage(This,newVal)

#define IFaxDoc_get_DiscountSend(This,pVal)	\
    (This)->lpVtbl -> get_DiscountSend(This,pVal)

#define IFaxDoc_put_DiscountSend(This,newVal)	\
    (This)->lpVtbl -> put_DiscountSend(This,newVal)

#define IFaxDoc_get_RecipientName(This,pVal)	\
    (This)->lpVtbl -> get_RecipientName(This,pVal)

#define IFaxDoc_put_RecipientName(This,newVal)	\
    (This)->lpVtbl -> put_RecipientName(This,newVal)

#define IFaxDoc_get_RecipientCompany(This,pVal)	\
    (This)->lpVtbl -> get_RecipientCompany(This,pVal)

#define IFaxDoc_put_RecipientCompany(This,newVal)	\
    (This)->lpVtbl -> put_RecipientCompany(This,newVal)

#define IFaxDoc_get_RecipientAddress(This,pVal)	\
    (This)->lpVtbl -> get_RecipientAddress(This,pVal)

#define IFaxDoc_put_RecipientAddress(This,newVal)	\
    (This)->lpVtbl -> put_RecipientAddress(This,newVal)

#define IFaxDoc_get_RecipientCity(This,pVal)	\
    (This)->lpVtbl -> get_RecipientCity(This,pVal)

#define IFaxDoc_put_RecipientCity(This,newVal)	\
    (This)->lpVtbl -> put_RecipientCity(This,newVal)

#define IFaxDoc_get_RecipientState(This,pVal)	\
    (This)->lpVtbl -> get_RecipientState(This,pVal)

#define IFaxDoc_put_RecipientState(This,newVal)	\
    (This)->lpVtbl -> put_RecipientState(This,newVal)

#define IFaxDoc_get_RecipientZip(This,pVal)	\
    (This)->lpVtbl -> get_RecipientZip(This,pVal)

#define IFaxDoc_put_RecipientZip(This,newVal)	\
    (This)->lpVtbl -> put_RecipientZip(This,newVal)

#define IFaxDoc_get_RecipientCountry(This,pVal)	\
    (This)->lpVtbl -> get_RecipientCountry(This,pVal)

#define IFaxDoc_put_RecipientCountry(This,newVal)	\
    (This)->lpVtbl -> put_RecipientCountry(This,newVal)

#define IFaxDoc_get_RecipientTitle(This,pVal)	\
    (This)->lpVtbl -> get_RecipientTitle(This,pVal)

#define IFaxDoc_put_RecipientTitle(This,newVal)	\
    (This)->lpVtbl -> put_RecipientTitle(This,newVal)

#define IFaxDoc_get_RecipientDepartment(This,pVal)	\
    (This)->lpVtbl -> get_RecipientDepartment(This,pVal)

#define IFaxDoc_put_RecipientDepartment(This,newVal)	\
    (This)->lpVtbl -> put_RecipientDepartment(This,newVal)

#define IFaxDoc_get_RecipientOffice(This,pVal)	\
    (This)->lpVtbl -> get_RecipientOffice(This,pVal)

#define IFaxDoc_put_RecipientOffice(This,newVal)	\
    (This)->lpVtbl -> put_RecipientOffice(This,newVal)

#define IFaxDoc_get_RecipientHomePhone(This,pVal)	\
    (This)->lpVtbl -> get_RecipientHomePhone(This,pVal)

#define IFaxDoc_put_RecipientHomePhone(This,newVal)	\
    (This)->lpVtbl -> put_RecipientHomePhone(This,newVal)

#define IFaxDoc_get_RecipientOfficePhone(This,pVal)	\
    (This)->lpVtbl -> get_RecipientOfficePhone(This,pVal)

#define IFaxDoc_put_RecipientOfficePhone(This,newVal)	\
    (This)->lpVtbl -> put_RecipientOfficePhone(This,newVal)

#define IFaxDoc_get_SenderName(This,pVal)	\
    (This)->lpVtbl -> get_SenderName(This,pVal)

#define IFaxDoc_put_SenderName(This,newVal)	\
    (This)->lpVtbl -> put_SenderName(This,newVal)

#define IFaxDoc_get_SenderCompany(This,pVal)	\
    (This)->lpVtbl -> get_SenderCompany(This,pVal)

#define IFaxDoc_put_SenderCompany(This,newVal)	\
    (This)->lpVtbl -> put_SenderCompany(This,newVal)

#define IFaxDoc_get_SenderAddress(This,pVal)	\
    (This)->lpVtbl -> get_SenderAddress(This,pVal)

#define IFaxDoc_put_SenderAddress(This,newVal)	\
    (This)->lpVtbl -> put_SenderAddress(This,newVal)

#define IFaxDoc_get_SenderTitle(This,pVal)	\
    (This)->lpVtbl -> get_SenderTitle(This,pVal)

#define IFaxDoc_put_SenderTitle(This,newVal)	\
    (This)->lpVtbl -> put_SenderTitle(This,newVal)

#define IFaxDoc_get_SenderDepartment(This,pVal)	\
    (This)->lpVtbl -> get_SenderDepartment(This,pVal)

#define IFaxDoc_put_SenderDepartment(This,newVal)	\
    (This)->lpVtbl -> put_SenderDepartment(This,newVal)

#define IFaxDoc_get_SenderOffice(This,pVal)	\
    (This)->lpVtbl -> get_SenderOffice(This,pVal)

#define IFaxDoc_put_SenderOffice(This,newVal)	\
    (This)->lpVtbl -> put_SenderOffice(This,newVal)

#define IFaxDoc_get_SenderHomePhone(This,pVal)	\
    (This)->lpVtbl -> get_SenderHomePhone(This,pVal)

#define IFaxDoc_put_SenderHomePhone(This,newVal)	\
    (This)->lpVtbl -> put_SenderHomePhone(This,newVal)

#define IFaxDoc_get_SenderOfficePhone(This,pVal)	\
    (This)->lpVtbl -> get_SenderOfficePhone(This,pVal)

#define IFaxDoc_put_SenderOfficePhone(This,newVal)	\
    (This)->lpVtbl -> put_SenderOfficePhone(This,newVal)

#define IFaxDoc_get_CoverpageNote(This,pVal)	\
    (This)->lpVtbl -> get_CoverpageNote(This,pVal)

#define IFaxDoc_put_CoverpageNote(This,newVal)	\
    (This)->lpVtbl -> put_CoverpageNote(This,newVal)

#define IFaxDoc_get_CoverpageSubject(This,pVal)	\
    (This)->lpVtbl -> get_CoverpageSubject(This,pVal)

#define IFaxDoc_put_CoverpageSubject(This,newVal)	\
    (This)->lpVtbl -> put_CoverpageSubject(This,newVal)

#define IFaxDoc_get_Tsid(This,pVal)	\
    (This)->lpVtbl -> get_Tsid(This,pVal)

#define IFaxDoc_put_Tsid(This,newVal)	\
    (This)->lpVtbl -> put_Tsid(This,newVal)

#define IFaxDoc_get_BillingCode(This,pVal)	\
    (This)->lpVtbl -> get_BillingCode(This,pVal)

#define IFaxDoc_put_BillingCode(This,newVal)	\
    (This)->lpVtbl -> put_BillingCode(This,newVal)

#define IFaxDoc_get_EmailAddress(This,pVal)	\
    (This)->lpVtbl -> get_EmailAddress(This,pVal)

#define IFaxDoc_put_EmailAddress(This,newVal)	\
    (This)->lpVtbl -> put_EmailAddress(This,newVal)

#define IFaxDoc_get_DisplayName(This,pVal)	\
    (This)->lpVtbl -> get_DisplayName(This,pVal)

#define IFaxDoc_put_DisplayName(This,newVal)	\
    (This)->lpVtbl -> put_DisplayName(This,newVal)

#define IFaxDoc_Send(This,pVal)	\
    (This)->lpVtbl -> Send(This,pVal)

#define IFaxDoc_get_FaxNumber(This,pVal)	\
    (This)->lpVtbl -> get_FaxNumber(This,pVal)

#define IFaxDoc_put_FaxNumber(This,newVal)	\
    (This)->lpVtbl -> put_FaxNumber(This,newVal)

#define IFaxDoc_putref_ConnectionObject(This,newVal)	\
    (This)->lpVtbl -> putref_ConnectionObject(This,newVal)

#define IFaxDoc_get_CallHandle(This,pVal)	\
    (This)->lpVtbl -> get_CallHandle(This,pVal)

#define IFaxDoc_put_CallHandle(This,newVal)	\
    (This)->lpVtbl -> put_CallHandle(This,newVal)

#define IFaxDoc_get_SenderFax(This,pVal)	\
    (This)->lpVtbl -> get_SenderFax(This,pVal)

#define IFaxDoc_put_SenderFax(This,newVal)	\
    (This)->lpVtbl -> put_SenderFax(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_FileName_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_FileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_FileName_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_FileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_CoverpageName_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_CoverpageName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_CoverpageName_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_CoverpageName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SendCoverpage_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxDoc_get_SendCoverpage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SendCoverpage_Proxy( 
    IFaxDoc * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxDoc_put_SendCoverpage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_ServerCoverpage_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxDoc_get_ServerCoverpage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_ServerCoverpage_Proxy( 
    IFaxDoc * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxDoc_put_ServerCoverpage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_DiscountSend_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxDoc_get_DiscountSend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_DiscountSend_Proxy( 
    IFaxDoc * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxDoc_put_DiscountSend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientName_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientName_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientCompany_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientCompany_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientCompany_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientCompany_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientAddress_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientAddress_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientCity_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientCity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientCity_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientCity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientState_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientState_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientZip_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientZip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientZip_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientZip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientCountry_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientCountry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientCountry_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientCountry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientTitle_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientTitle_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientDepartment_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientDepartment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientDepartment_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientDepartment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientOffice_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientOffice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientOffice_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientOffice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientHomePhone_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientHomePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientHomePhone_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientHomePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientOfficePhone_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientOfficePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientOfficePhone_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientOfficePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderName_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_SenderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderName_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderCompany_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_SenderCompany_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderCompany_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderCompany_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderAddress_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_SenderAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderAddress_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderTitle_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_SenderTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderTitle_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderDepartment_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_SenderDepartment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderDepartment_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderDepartment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderOffice_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_SenderOffice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderOffice_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderOffice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderHomePhone_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_SenderHomePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderHomePhone_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderHomePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderOfficePhone_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_SenderOfficePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderOfficePhone_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderOfficePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_CoverpageNote_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_CoverpageNote_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_CoverpageNote_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_CoverpageNote_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_CoverpageSubject_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_CoverpageSubject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_CoverpageSubject_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_CoverpageSubject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_Tsid_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_Tsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_Tsid_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_Tsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_BillingCode_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_BillingCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_BillingCode_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_BillingCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_EmailAddress_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_EmailAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_EmailAddress_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_EmailAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_DisplayName_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_DisplayName_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDoc_Send_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxDoc_Send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_FaxNumber_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_FaxNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_FaxNumber_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_FaxNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IFaxDoc_putref_ConnectionObject_Proxy( 
    IFaxDoc * This,
    /* [in] */ IDispatch *newVal);


void __RPC_STUB IFaxDoc_putref_ConnectionObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_CallHandle_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxDoc_get_CallHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_CallHandle_Proxy( 
    IFaxDoc * This,
    /* [in] */ long newVal);


void __RPC_STUB IFaxDoc_put_CallHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderFax_Proxy( 
    IFaxDoc * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxDoc_get_SenderFax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderFax_Proxy( 
    IFaxDoc * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderFax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxDoc_INTERFACE_DEFINED__ */


#ifndef __IFaxJobs_INTERFACE_DEFINED__
#define __IFaxJobs_INTERFACE_DEFINED__

/* interface IFaxJobs */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxJobs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("55DABFD3-5C9E-11D1-B791-000000000000")
    IFaxJobs : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            long Index,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxJobsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxJobs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxJobs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxJobs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxJobs * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxJobs * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxJobs * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxJobs * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxJobs * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxJobs * This,
            long Index,
            /* [retval][out] */ VARIANT *pVal);
        
        END_INTERFACE
    } IFaxJobsVtbl;

    interface IFaxJobs
    {
        CONST_VTBL struct IFaxJobsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxJobs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxJobs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxJobs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxJobs_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxJobs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxJobs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxJobs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxJobs_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IFaxJobs_get_Item(This,Index,pVal)	\
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobs_get_Count_Proxy( 
    IFaxJobs * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxJobs_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobs_get_Item_Proxy( 
    IFaxJobs * This,
    long Index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IFaxJobs_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxJobs_INTERFACE_DEFINED__ */


#ifndef __IFaxJob_INTERFACE_DEFINED__
#define __IFaxJob_INTERFACE_DEFINED__

/* interface IFaxJob */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxJob;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("55DABFD5-5C9E-11D1-B791-000000000000")
    IFaxJob : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_JobId( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UserName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_QueueStatus( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceStatus( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PageCount( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FaxNumber( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Tsid( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderCompany( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderDept( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BillingCode( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscountSend( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            long Command) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxJobVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxJob * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxJob * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxJob * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxJob * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxJob * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxJob * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_JobId )( 
            IFaxJob * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IFaxJob * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserName )( 
            IFaxJob * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_QueueStatus )( 
            IFaxJob * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceStatus )( 
            IFaxJob * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PageCount )( 
            IFaxJob * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FaxNumber )( 
            IFaxJob * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecipientName )( 
            IFaxJob * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Tsid )( 
            IFaxJob * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderName )( 
            IFaxJob * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderCompany )( 
            IFaxJob * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SenderDept )( 
            IFaxJob * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BillingCode )( 
            IFaxJob * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayName )( 
            IFaxJob * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiscountSend )( 
            IFaxJob * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            IFaxJob * This,
            long Command);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxJob * This);
        
        END_INTERFACE
    } IFaxJobVtbl;

    interface IFaxJob
    {
        CONST_VTBL struct IFaxJobVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxJob_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxJob_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxJob_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxJob_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxJob_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxJob_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxJob_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxJob_get_JobId(This,pVal)	\
    (This)->lpVtbl -> get_JobId(This,pVal)

#define IFaxJob_get_Type(This,pVal)	\
    (This)->lpVtbl -> get_Type(This,pVal)

#define IFaxJob_get_UserName(This,pVal)	\
    (This)->lpVtbl -> get_UserName(This,pVal)

#define IFaxJob_get_QueueStatus(This,pVal)	\
    (This)->lpVtbl -> get_QueueStatus(This,pVal)

#define IFaxJob_get_DeviceStatus(This,pVal)	\
    (This)->lpVtbl -> get_DeviceStatus(This,pVal)

#define IFaxJob_get_PageCount(This,pVal)	\
    (This)->lpVtbl -> get_PageCount(This,pVal)

#define IFaxJob_get_FaxNumber(This,pVal)	\
    (This)->lpVtbl -> get_FaxNumber(This,pVal)

#define IFaxJob_get_RecipientName(This,pVal)	\
    (This)->lpVtbl -> get_RecipientName(This,pVal)

#define IFaxJob_get_Tsid(This,pVal)	\
    (This)->lpVtbl -> get_Tsid(This,pVal)

#define IFaxJob_get_SenderName(This,pVal)	\
    (This)->lpVtbl -> get_SenderName(This,pVal)

#define IFaxJob_get_SenderCompany(This,pVal)	\
    (This)->lpVtbl -> get_SenderCompany(This,pVal)

#define IFaxJob_get_SenderDept(This,pVal)	\
    (This)->lpVtbl -> get_SenderDept(This,pVal)

#define IFaxJob_get_BillingCode(This,pVal)	\
    (This)->lpVtbl -> get_BillingCode(This,pVal)

#define IFaxJob_get_DisplayName(This,pVal)	\
    (This)->lpVtbl -> get_DisplayName(This,pVal)

#define IFaxJob_get_DiscountSend(This,pVal)	\
    (This)->lpVtbl -> get_DiscountSend(This,pVal)

#define IFaxJob_SetStatus(This,Command)	\
    (This)->lpVtbl -> SetStatus(This,Command)

#define IFaxJob_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_JobId_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxJob_get_JobId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_Type_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxJob_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_UserName_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxJob_get_UserName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_QueueStatus_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxJob_get_QueueStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_DeviceStatus_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxJob_get_DeviceStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_PageCount_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IFaxJob_get_PageCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_FaxNumber_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxJob_get_FaxNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_RecipientName_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxJob_get_RecipientName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_Tsid_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxJob_get_Tsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_SenderName_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxJob_get_SenderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_SenderCompany_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxJob_get_SenderCompany_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_SenderDept_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxJob_get_SenderDept_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_BillingCode_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxJob_get_BillingCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_DisplayName_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IFaxJob_get_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_DiscountSend_Proxy( 
    IFaxJob * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IFaxJob_get_DiscountSend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxJob_SetStatus_Proxy( 
    IFaxJob * This,
    long Command);


void __RPC_STUB IFaxJob_SetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxJob_Refresh_Proxy( 
    IFaxJob * This);


void __RPC_STUB IFaxJob_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxJob_INTERFACE_DEFINED__ */



#ifndef __FAXCOMLib_LIBRARY_DEFINED__
#define __FAXCOMLib_LIBRARY_DEFINED__

/* library FAXCOMLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_FAXCOMLib;

EXTERN_C const CLSID CLSID_FaxTiff;

#ifdef __cplusplus

class DECLSPEC_UUID("87099231-C7AF-11D0-B225-00C04FB6C2F5")
FaxTiff;
#endif

EXTERN_C const CLSID CLSID_FaxServer;

#ifdef __cplusplus

class DECLSPEC_UUID("D73733C8-CC80-11D0-B225-00C04FB6C2F5")
FaxServer;
#endif

EXTERN_C const CLSID CLSID_FaxPort;

#ifdef __cplusplus

class DECLSPEC_UUID("D73733CD-CC80-11D0-B225-00C04FB6C2F5")
FaxPort;
#endif

EXTERN_C const CLSID CLSID_FaxPorts;

#ifdef __cplusplus

class DECLSPEC_UUID("D73733D6-CC80-11D0-B225-00C04FB6C2F5")
FaxPorts;
#endif

EXTERN_C const CLSID CLSID_FaxRoutingMethod;

#ifdef __cplusplus

class DECLSPEC_UUID("2199F5F4-CEFC-11D0-A341-0000F800E68D")
FaxRoutingMethod;
#endif

EXTERN_C const CLSID CLSID_FaxRoutingMethods;

#ifdef __cplusplus

class DECLSPEC_UUID("2199F5F6-CEFC-11D0-A341-0000F800E68D")
FaxRoutingMethods;
#endif

EXTERN_C const CLSID CLSID_FaxStatus;

#ifdef __cplusplus

class DECLSPEC_UUID("8B97E606-D054-11D0-B226-00C04FB6C2F5")
FaxStatus;
#endif

EXTERN_C const CLSID CLSID_FaxDoc;

#ifdef __cplusplus

class DECLSPEC_UUID("FA21F4C6-5C4C-11D1-83CF-00C04FB6E984")
FaxDoc;
#endif

EXTERN_C const CLSID CLSID_FaxJobs;

#ifdef __cplusplus

class DECLSPEC_UUID("55DABFD4-5C9E-11D1-B791-000000000000")
FaxJobs;
#endif

EXTERN_C const CLSID CLSID_FaxJob;

#ifdef __cplusplus

class DECLSPEC_UUID("55DABFD6-5C9E-11D1-B791-000000000000")
FaxJob;
#endif
#endif /* __FAXCOMLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\binaries\amd64\fre\sdk\faxcomex.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for faxcomex.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __faxcomex_h__
#define __faxcomex_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IFaxJobStatus_FWD_DEFINED__
#define __IFaxJobStatus_FWD_DEFINED__
typedef interface IFaxJobStatus IFaxJobStatus;
#endif 	/* __IFaxJobStatus_FWD_DEFINED__ */


#ifndef __IFaxServer_FWD_DEFINED__
#define __IFaxServer_FWD_DEFINED__
typedef interface IFaxServer IFaxServer;
#endif 	/* __IFaxServer_FWD_DEFINED__ */


#ifndef __IFaxDeviceProviders_FWD_DEFINED__
#define __IFaxDeviceProviders_FWD_DEFINED__
typedef interface IFaxDeviceProviders IFaxDeviceProviders;
#endif 	/* __IFaxDeviceProviders_FWD_DEFINED__ */


#ifndef __IFaxDevices_FWD_DEFINED__
#define __IFaxDevices_FWD_DEFINED__
typedef interface IFaxDevices IFaxDevices;
#endif 	/* __IFaxDevices_FWD_DEFINED__ */


#ifndef __IFaxInboundRouting_FWD_DEFINED__
#define __IFaxInboundRouting_FWD_DEFINED__
typedef interface IFaxInboundRouting IFaxInboundRouting;
#endif 	/* __IFaxInboundRouting_FWD_DEFINED__ */


#ifndef __IFaxFolders_FWD_DEFINED__
#define __IFaxFolders_FWD_DEFINED__
typedef interface IFaxFolders IFaxFolders;
#endif 	/* __IFaxFolders_FWD_DEFINED__ */


#ifndef __IFaxLoggingOptions_FWD_DEFINED__
#define __IFaxLoggingOptions_FWD_DEFINED__
typedef interface IFaxLoggingOptions IFaxLoggingOptions;
#endif 	/* __IFaxLoggingOptions_FWD_DEFINED__ */


#ifndef __IFaxActivity_FWD_DEFINED__
#define __IFaxActivity_FWD_DEFINED__
typedef interface IFaxActivity IFaxActivity;
#endif 	/* __IFaxActivity_FWD_DEFINED__ */


#ifndef __IFaxOutboundRouting_FWD_DEFINED__
#define __IFaxOutboundRouting_FWD_DEFINED__
typedef interface IFaxOutboundRouting IFaxOutboundRouting;
#endif 	/* __IFaxOutboundRouting_FWD_DEFINED__ */


#ifndef __IFaxReceiptOptions_FWD_DEFINED__
#define __IFaxReceiptOptions_FWD_DEFINED__
typedef interface IFaxReceiptOptions IFaxReceiptOptions;
#endif 	/* __IFaxReceiptOptions_FWD_DEFINED__ */


#ifndef __IFaxSecurity_FWD_DEFINED__
#define __IFaxSecurity_FWD_DEFINED__
typedef interface IFaxSecurity IFaxSecurity;
#endif 	/* __IFaxSecurity_FWD_DEFINED__ */


#ifndef __IFaxDocument_FWD_DEFINED__
#define __IFaxDocument_FWD_DEFINED__
typedef interface IFaxDocument IFaxDocument;
#endif 	/* __IFaxDocument_FWD_DEFINED__ */


#ifndef __IFaxAttachments_FWD_DEFINED__
#define __IFaxAttachments_FWD_DEFINED__
typedef interface IFaxAttachments IFaxAttachments;
#endif 	/* __IFaxAttachments_FWD_DEFINED__ */


#ifndef __IFaxSender_FWD_DEFINED__
#define __IFaxSender_FWD_DEFINED__
typedef interface IFaxSender IFaxSender;
#endif 	/* __IFaxSender_FWD_DEFINED__ */


#ifndef __IFaxRecipient_FWD_DEFINED__
#define __IFaxRecipient_FWD_DEFINED__
typedef interface IFaxRecipient IFaxRecipient;
#endif 	/* __IFaxRecipient_FWD_DEFINED__ */


#ifndef __IFaxRecipients_FWD_DEFINED__
#define __IFaxRecipients_FWD_DEFINED__
typedef interface IFaxRecipients IFaxRecipients;
#endif 	/* __IFaxRecipients_FWD_DEFINED__ */


#ifndef __IFaxIncomingArchive_FWD_DEFINED__
#define __IFaxIncomingArchive_FWD_DEFINED__
typedef interface IFaxIncomingArchive IFaxIncomingArchive;
#endif 	/* __IFaxIncomingArchive_FWD_DEFINED__ */


#ifndef __IFaxIncomingQueue_FWD_DEFINED__
#define __IFaxIncomingQueue_FWD_DEFINED__
typedef interface IFaxIncomingQueue IFaxIncomingQueue;
#endif 	/* __IFaxIncomingQueue_FWD_DEFINED__ */


#ifndef __IFaxOutgoingArchive_FWD_DEFINED__
#define __IFaxOutgoingArchive_FWD_DEFINED__
typedef interface IFaxOutgoingArchive IFaxOutgoingArchive;
#endif 	/* __IFaxOutgoingArchive_FWD_DEFINED__ */


#ifndef __IFaxOutgoingQueue_FWD_DEFINED__
#define __IFaxOutgoingQueue_FWD_DEFINED__
typedef interface IFaxOutgoingQueue IFaxOutgoingQueue;
#endif 	/* __IFaxOutgoingQueue_FWD_DEFINED__ */


#ifndef __IFaxIncomingMessageIterator_FWD_DEFINED__
#define __IFaxIncomingMessageIterator_FWD_DEFINED__
typedef interface IFaxIncomingMessageIterator IFaxIncomingMessageIterator;
#endif 	/* __IFaxIncomingMessageIterator_FWD_DEFINED__ */


#ifndef __IFaxIncomingMessage_FWD_DEFINED__
#define __IFaxIncomingMessage_FWD_DEFINED__
typedef interface IFaxIncomingMessage IFaxIncomingMessage;
#endif 	/* __IFaxIncomingMessage_FWD_DEFINED__ */


#ifndef __IFaxOutgoingJobs_FWD_DEFINED__
#define __IFaxOutgoingJobs_FWD_DEFINED__
typedef interface IFaxOutgoingJobs IFaxOutgoingJobs;
#endif 	/* __IFaxOutgoingJobs_FWD_DEFINED__ */


#ifndef __IFaxOutgoingJob_FWD_DEFINED__
#define __IFaxOutgoingJob_FWD_DEFINED__
typedef interface IFaxOutgoingJob IFaxOutgoingJob;
#endif 	/* __IFaxOutgoingJob_FWD_DEFINED__ */


#ifndef __IFaxOutgoingMessageIterator_FWD_DEFINED__
#define __IFaxOutgoingMessageIterator_FWD_DEFINED__
typedef interface IFaxOutgoingMessageIterator IFaxOutgoingMessageIterator;
#endif 	/* __IFaxOutgoingMessageIterator_FWD_DEFINED__ */


#ifndef __IFaxOutgoingMessage_FWD_DEFINED__
#define __IFaxOutgoingMessage_FWD_DEFINED__
typedef interface IFaxOutgoingMessage IFaxOutgoingMessage;
#endif 	/* __IFaxOutgoingMessage_FWD_DEFINED__ */


#ifndef __IFaxIncomingJobs_FWD_DEFINED__
#define __IFaxIncomingJobs_FWD_DEFINED__
typedef interface IFaxIncomingJobs IFaxIncomingJobs;
#endif 	/* __IFaxIncomingJobs_FWD_DEFINED__ */


#ifndef __IFaxIncomingJob_FWD_DEFINED__
#define __IFaxIncomingJob_FWD_DEFINED__
typedef interface IFaxIncomingJob IFaxIncomingJob;
#endif 	/* __IFaxIncomingJob_FWD_DEFINED__ */


#ifndef __IFaxDeviceProvider_FWD_DEFINED__
#define __IFaxDeviceProvider_FWD_DEFINED__
typedef interface IFaxDeviceProvider IFaxDeviceProvider;
#endif 	/* __IFaxDeviceProvider_FWD_DEFINED__ */


#ifndef __IFaxDevice_FWD_DEFINED__
#define __IFaxDevice_FWD_DEFINED__
typedef interface IFaxDevice IFaxDevice;
#endif 	/* __IFaxDevice_FWD_DEFINED__ */


#ifndef __IFaxActivityLogging_FWD_DEFINED__
#define __IFaxActivityLogging_FWD_DEFINED__
typedef interface IFaxActivityLogging IFaxActivityLogging;
#endif 	/* __IFaxActivityLogging_FWD_DEFINED__ */


#ifndef __IFaxEventLogging_FWD_DEFINED__
#define __IFaxEventLogging_FWD_DEFINED__
typedef interface IFaxEventLogging IFaxEventLogging;
#endif 	/* __IFaxEventLogging_FWD_DEFINED__ */


#ifndef __IFaxOutboundRoutingGroups_FWD_DEFINED__
#define __IFaxOutboundRoutingGroups_FWD_DEFINED__
typedef interface IFaxOutboundRoutingGroups IFaxOutboundRoutingGroups;
#endif 	/* __IFaxOutboundRoutingGroups_FWD_DEFINED__ */


#ifndef __IFaxOutboundRoutingGroup_FWD_DEFINED__
#define __IFaxOutboundRoutingGroup_FWD_DEFINED__
typedef interface IFaxOutboundRoutingGroup IFaxOutboundRoutingGroup;
#endif 	/* __IFaxOutboundRoutingGroup_FWD_DEFINED__ */


#ifndef __IFaxDeviceIds_FWD_DEFINED__
#define __IFaxDeviceIds_FWD_DEFINED__
typedef interface IFaxDeviceIds IFaxDeviceIds;
#endif 	/* __IFaxDeviceIds_FWD_DEFINED__ */


#ifndef __IFaxOutboundRoutingRules_FWD_DEFINED__
#define __IFaxOutboundRoutingRules_FWD_DEFINED__
typedef interface IFaxOutboundRoutingRules IFaxOutboundRoutingRules;
#endif 	/* __IFaxOutboundRoutingRules_FWD_DEFINED__ */


#ifndef __IFaxOutboundRoutingRule_FWD_DEFINED__
#define __IFaxOutboundRoutingRule_FWD_DEFINED__
typedef interface IFaxOutboundRoutingRule IFaxOutboundRoutingRule;
#endif 	/* __IFaxOutboundRoutingRule_FWD_DEFINED__ */


#ifndef __IFaxInboundRoutingExtensions_FWD_DEFINED__
#define __IFaxInboundRoutingExtensions_FWD_DEFINED__
typedef interface IFaxInboundRoutingExtensions IFaxInboundRoutingExtensions;
#endif 	/* __IFaxInboundRoutingExtensions_FWD_DEFINED__ */


#ifndef __IFaxInboundRoutingExtension_FWD_DEFINED__
#define __IFaxInboundRoutingExtension_FWD_DEFINED__
typedef interface IFaxInboundRoutingExtension IFaxInboundRoutingExtension;
#endif 	/* __IFaxInboundRoutingExtension_FWD_DEFINED__ */


#ifndef __IFaxInboundRoutingMethods_FWD_DEFINED__
#define __IFaxInboundRoutingMethods_FWD_DEFINED__
typedef interface IFaxInboundRoutingMethods IFaxInboundRoutingMethods;
#endif 	/* __IFaxInboundRoutingMethods_FWD_DEFINED__ */


#ifndef __IFaxInboundRoutingMethod_FWD_DEFINED__
#define __IFaxInboundRoutingMethod_FWD_DEFINED__
typedef interface IFaxInboundRoutingMethod IFaxInboundRoutingMethod;
#endif 	/* __IFaxInboundRoutingMethod_FWD_DEFINED__ */


#ifndef __IFaxServerNotify_FWD_DEFINED__
#define __IFaxServerNotify_FWD_DEFINED__
typedef interface IFaxServerNotify IFaxServerNotify;
#endif 	/* __IFaxServerNotify_FWD_DEFINED__ */


#ifndef __FaxServer_FWD_DEFINED__
#define __FaxServer_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxServer FaxServer;
#else
typedef struct FaxServer FaxServer;
#endif /* __cplusplus */

#endif 	/* __FaxServer_FWD_DEFINED__ */


#ifndef __FaxDeviceProviders_FWD_DEFINED__
#define __FaxDeviceProviders_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxDeviceProviders FaxDeviceProviders;
#else
typedef struct FaxDeviceProviders FaxDeviceProviders;
#endif /* __cplusplus */

#endif 	/* __FaxDeviceProviders_FWD_DEFINED__ */


#ifndef __FaxDevices_FWD_DEFINED__
#define __FaxDevices_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxDevices FaxDevices;
#else
typedef struct FaxDevices FaxDevices;
#endif /* __cplusplus */

#endif 	/* __FaxDevices_FWD_DEFINED__ */


#ifndef __FaxInboundRouting_FWD_DEFINED__
#define __FaxInboundRouting_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxInboundRouting FaxInboundRouting;
#else
typedef struct FaxInboundRouting FaxInboundRouting;
#endif /* __cplusplus */

#endif 	/* __FaxInboundRouting_FWD_DEFINED__ */


#ifndef __FaxFolders_FWD_DEFINED__
#define __FaxFolders_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxFolders FaxFolders;
#else
typedef struct FaxFolders FaxFolders;
#endif /* __cplusplus */

#endif 	/* __FaxFolders_FWD_DEFINED__ */


#ifndef __FaxLoggingOptions_FWD_DEFINED__
#define __FaxLoggingOptions_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxLoggingOptions FaxLoggingOptions;
#else
typedef struct FaxLoggingOptions FaxLoggingOptions;
#endif /* __cplusplus */

#endif 	/* __FaxLoggingOptions_FWD_DEFINED__ */


#ifndef __FaxActivity_FWD_DEFINED__
#define __FaxActivity_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxActivity FaxActivity;
#else
typedef struct FaxActivity FaxActivity;
#endif /* __cplusplus */

#endif 	/* __FaxActivity_FWD_DEFINED__ */


#ifndef __FaxOutboundRouting_FWD_DEFINED__
#define __FaxOutboundRouting_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxOutboundRouting FaxOutboundRouting;
#else
typedef struct FaxOutboundRouting FaxOutboundRouting;
#endif /* __cplusplus */

#endif 	/* __FaxOutboundRouting_FWD_DEFINED__ */


#ifndef __FaxReceiptOptions_FWD_DEFINED__
#define __FaxReceiptOptions_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxReceiptOptions FaxReceiptOptions;
#else
typedef struct FaxReceiptOptions FaxReceiptOptions;
#endif /* __cplusplus */

#endif 	/* __FaxReceiptOptions_FWD_DEFINED__ */


#ifndef __FaxSecurity_FWD_DEFINED__
#define __FaxSecurity_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxSecurity FaxSecurity;
#else
typedef struct FaxSecurity FaxSecurity;
#endif /* __cplusplus */

#endif 	/* __FaxSecurity_FWD_DEFINED__ */


#ifndef __FaxDocument_FWD_DEFINED__
#define __FaxDocument_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxDocument FaxDocument;
#else
typedef struct FaxDocument FaxDocument;
#endif /* __cplusplus */

#endif 	/* __FaxDocument_FWD_DEFINED__ */


#ifndef __FaxAttachments_FWD_DEFINED__
#define __FaxAttachments_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxAttachments FaxAttachments;
#else
typedef struct FaxAttachments FaxAttachments;
#endif /* __cplusplus */

#endif 	/* __FaxAttachments_FWD_DEFINED__ */


#ifndef __FaxSender_FWD_DEFINED__
#define __FaxSender_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxSender FaxSender;
#else
typedef struct FaxSender FaxSender;
#endif /* __cplusplus */

#endif 	/* __FaxSender_FWD_DEFINED__ */


#ifndef __FaxRecipients_FWD_DEFINED__
#define __FaxRecipients_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxRecipients FaxRecipients;
#else
typedef struct FaxRecipients FaxRecipients;
#endif /* __cplusplus */

#endif 	/* __FaxRecipients_FWD_DEFINED__ */


#ifndef __FaxIncomingArchive_FWD_DEFINED__
#define __FaxIncomingArchive_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxIncomingArchive FaxIncomingArchive;
#else
typedef struct FaxIncomingArchive FaxIncomingArchive;
#endif /* __cplusplus */

#endif 	/* __FaxIncomingArchive_FWD_DEFINED__ */


#ifndef __FaxIncomingQueue_FWD_DEFINED__
#define __FaxIncomingQueue_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxIncomingQueue FaxIncomingQueue;
#else
typedef struct FaxIncomingQueue FaxIncomingQueue;
#endif /* __cplusplus */

#endif 	/* __FaxIncomingQueue_FWD_DEFINED__ */


#ifndef __FaxOutgoingArchive_FWD_DEFINED__
#define __FaxOutgoingArchive_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxOutgoingArchive FaxOutgoingArchive;
#else
typedef struct FaxOutgoingArchive FaxOutgoingArchive;
#endif /* __cplusplus */

#endif 	/* __FaxOutgoingArchive_FWD_DEFINED__ */


#ifndef __FaxOutgoingQueue_FWD_DEFINED__
#define __FaxOutgoingQueue_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxOutgoingQueue FaxOutgoingQueue;
#else
typedef struct FaxOutgoingQueue FaxOutgoingQueue;
#endif /* __cplusplus */

#endif 	/* __FaxOutgoingQueue_FWD_DEFINED__ */


#ifndef __FaxIncomingMessageIterator_FWD_DEFINED__
#define __FaxIncomingMessageIterator_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxIncomingMessageIterator FaxIncomingMessageIterator;
#else
typedef struct FaxIncomingMessageIterator FaxIncomingMessageIterator;
#endif /* __cplusplus */

#endif 	/* __FaxIncomingMessageIterator_FWD_DEFINED__ */


#ifndef __FaxIncomingMessage_FWD_DEFINED__
#define __FaxIncomingMessage_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxIncomingMessage FaxIncomingMessage;
#else
typedef struct FaxIncomingMessage FaxIncomingMessage;
#endif /* __cplusplus */

#endif 	/* __FaxIncomingMessage_FWD_DEFINED__ */


#ifndef __FaxOutgoingJobs_FWD_DEFINED__
#define __FaxOutgoingJobs_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxOutgoingJobs FaxOutgoingJobs;
#else
typedef struct FaxOutgoingJobs FaxOutgoingJobs;
#endif /* __cplusplus */

#endif 	/* __FaxOutgoingJobs_FWD_DEFINED__ */


#ifndef __FaxOutgoingJob_FWD_DEFINED__
#define __FaxOutgoingJob_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxOutgoingJob FaxOutgoingJob;
#else
typedef struct FaxOutgoingJob FaxOutgoingJob;
#endif /* __cplusplus */

#endif 	/* __FaxOutgoingJob_FWD_DEFINED__ */


#ifndef __FaxOutgoingMessageIterator_FWD_DEFINED__
#define __FaxOutgoingMessageIterator_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxOutgoingMessageIterator FaxOutgoingMessageIterator;
#else
typedef struct FaxOutgoingMessageIterator FaxOutgoingMessageIterator;
#endif /* __cplusplus */

#endif 	/* __FaxOutgoingMessageIterator_FWD_DEFINED__ */


#ifndef __FaxOutgoingMessage_FWD_DEFINED__
#define __FaxOutgoingMessage_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxOutgoingMessage FaxOutgoingMessage;
#else
typedef struct FaxOutgoingMessage FaxOutgoingMessage;
#endif /* __cplusplus */

#endif 	/* __FaxOutgoingMessage_FWD_DEFINED__ */


#ifndef __FaxIncomingJobs_FWD_DEFINED__
#define __FaxIncomingJobs_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxIncomingJobs FaxIncomingJobs;
#else
typedef struct FaxIncomingJobs FaxIncomingJobs;
#endif /* __cplusplus */

#endif 	/* __FaxIncomingJobs_FWD_DEFINED__ */


#ifndef __FaxIncomingJob_FWD_DEFINED__
#define __FaxIncomingJob_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxIncomingJob FaxIncomingJob;
#else
typedef struct FaxIncomingJob FaxIncomingJob;
#endif /* __cplusplus */

#endif 	/* __FaxIncomingJob_FWD_DEFINED__ */


#ifndef __FaxDeviceProvider_FWD_DEFINED__
#define __FaxDeviceProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxDeviceProvider FaxDeviceProvider;
#else
typedef struct FaxDeviceProvider FaxDeviceProvider;
#endif /* __cplusplus */

#endif 	/* __FaxDeviceProvider_FWD_DEFINED__ */


#ifndef __FaxDevice_FWD_DEFINED__
#define __FaxDevice_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxDevice FaxDevice;
#else
typedef struct FaxDevice FaxDevice;
#endif /* __cplusplus */

#endif 	/* __FaxDevice_FWD_DEFINED__ */


#ifndef __FaxActivityLogging_FWD_DEFINED__
#define __FaxActivityLogging_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxActivityLogging FaxActivityLogging;
#else
typedef struct FaxActivityLogging FaxActivityLogging;
#endif /* __cplusplus */

#endif 	/* __FaxActivityLogging_FWD_DEFINED__ */


#ifndef __FaxEventLogging_FWD_DEFINED__
#define __FaxEventLogging_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxEventLogging FaxEventLogging;
#else
typedef struct FaxEventLogging FaxEventLogging;
#endif /* __cplusplus */

#endif 	/* __FaxEventLogging_FWD_DEFINED__ */


#ifndef __FaxOutboundRoutingGroups_FWD_DEFINED__
#define __FaxOutboundRoutingGroups_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxOutboundRoutingGroups FaxOutboundRoutingGroups;
#else
typedef struct FaxOutboundRoutingGroups FaxOutboundRoutingGroups;
#endif /* __cplusplus */

#endif 	/* __FaxOutboundRoutingGroups_FWD_DEFINED__ */


#ifndef __FaxOutboundRoutingGroup_FWD_DEFINED__
#define __FaxOutboundRoutingGroup_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxOutboundRoutingGroup FaxOutboundRoutingGroup;
#else
typedef struct FaxOutboundRoutingGroup FaxOutboundRoutingGroup;
#endif /* __cplusplus */

#endif 	/* __FaxOutboundRoutingGroup_FWD_DEFINED__ */


#ifndef __FaxDeviceIds_FWD_DEFINED__
#define __FaxDeviceIds_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxDeviceIds FaxDeviceIds;
#else
typedef struct FaxDeviceIds FaxDeviceIds;
#endif /* __cplusplus */

#endif 	/* __FaxDeviceIds_FWD_DEFINED__ */


#ifndef __FaxOutboundRoutingRules_FWD_DEFINED__
#define __FaxOutboundRoutingRules_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxOutboundRoutingRules FaxOutboundRoutingRules;
#else
typedef struct FaxOutboundRoutingRules FaxOutboundRoutingRules;
#endif /* __cplusplus */

#endif 	/* __FaxOutboundRoutingRules_FWD_DEFINED__ */


#ifndef __FaxOutboundRoutingRule_FWD_DEFINED__
#define __FaxOutboundRoutingRule_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxOutboundRoutingRule FaxOutboundRoutingRule;
#else
typedef struct FaxOutboundRoutingRule FaxOutboundRoutingRule;
#endif /* __cplusplus */

#endif 	/* __FaxOutboundRoutingRule_FWD_DEFINED__ */


#ifndef __FaxInboundRoutingExtensions_FWD_DEFINED__
#define __FaxInboundRoutingExtensions_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxInboundRoutingExtensions FaxInboundRoutingExtensions;
#else
typedef struct FaxInboundRoutingExtensions FaxInboundRoutingExtensions;
#endif /* __cplusplus */

#endif 	/* __FaxInboundRoutingExtensions_FWD_DEFINED__ */


#ifndef __FaxInboundRoutingExtension_FWD_DEFINED__
#define __FaxInboundRoutingExtension_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxInboundRoutingExtension FaxInboundRoutingExtension;
#else
typedef struct FaxInboundRoutingExtension FaxInboundRoutingExtension;
#endif /* __cplusplus */

#endif 	/* __FaxInboundRoutingExtension_FWD_DEFINED__ */


#ifndef __FaxInboundRoutingMethods_FWD_DEFINED__
#define __FaxInboundRoutingMethods_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxInboundRoutingMethods FaxInboundRoutingMethods;
#else
typedef struct FaxInboundRoutingMethods FaxInboundRoutingMethods;
#endif /* __cplusplus */

#endif 	/* __FaxInboundRoutingMethods_FWD_DEFINED__ */


#ifndef __FaxInboundRoutingMethod_FWD_DEFINED__
#define __FaxInboundRoutingMethod_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxInboundRoutingMethod FaxInboundRoutingMethod;
#else
typedef struct FaxInboundRoutingMethod FaxInboundRoutingMethod;
#endif /* __cplusplus */

#endif 	/* __FaxInboundRoutingMethod_FWD_DEFINED__ */


#ifndef __FaxJobStatus_FWD_DEFINED__
#define __FaxJobStatus_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxJobStatus FaxJobStatus;
#else
typedef struct FaxJobStatus FaxJobStatus;
#endif /* __cplusplus */

#endif 	/* __FaxJobStatus_FWD_DEFINED__ */


#ifndef __FaxRecipient_FWD_DEFINED__
#define __FaxRecipient_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxRecipient FaxRecipient;
#else
typedef struct FaxRecipient FaxRecipient;
#endif /* __cplusplus */

#endif 	/* __FaxRecipient_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_faxcomex_0000 */
/* [local] */ 

#define	DEFAULT_PREFETCH_SIZE	( 100 )









































extern RPC_IF_HANDLE __MIDL_itf_faxcomex_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_faxcomex_0000_v0_0_s_ifspec;

#ifndef __IFaxJobStatus_INTERFACE_DEFINED__
#define __IFaxJobStatus_INTERFACE_DEFINED__

/* interface IFaxJobStatus */
/* [unique][helpstring][dual][uuid][object] */ 

typedef 
enum FAX_JOB_STATUS_ENUM
    {	fjsPENDING	= 0x1,
	fjsINPROGRESS	= 0x2,
	fjsFAILED	= 0x8,
	fjsPAUSED	= 0x10,
	fjsNOLINE	= 0x20,
	fjsRETRYING	= 0x40,
	fjsRETRIES_EXCEEDED	= 0x80,
	fjsCOMPLETED	= 0x100,
	fjsCANCELED	= 0x200,
	fjsCANCELING	= 0x400,
	fjsROUTING	= 0x800
    } 	FAX_JOB_STATUS_ENUM;

typedef 
enum FAX_JOB_EXTENDED_STATUS_ENUM
    {	fjesNONE	= 0,
	fjesDISCONNECTED	= fjesNONE + 1,
	fjesINITIALIZING	= fjesDISCONNECTED + 1,
	fjesDIALING	= fjesINITIALIZING + 1,
	fjesTRANSMITTING	= fjesDIALING + 1,
	fjesANSWERED	= fjesTRANSMITTING + 1,
	fjesRECEIVING	= fjesANSWERED + 1,
	fjesLINE_UNAVAILABLE	= fjesRECEIVING + 1,
	fjesBUSY	= fjesLINE_UNAVAILABLE + 1,
	fjesNO_ANSWER	= fjesBUSY + 1,
	fjesBAD_ADDRESS	= fjesNO_ANSWER + 1,
	fjesNO_DIAL_TONE	= fjesBAD_ADDRESS + 1,
	fjesFATAL_ERROR	= fjesNO_DIAL_TONE + 1,
	fjesCALL_DELAYED	= fjesFATAL_ERROR + 1,
	fjesCALL_BLACKLISTED	= fjesCALL_DELAYED + 1,
	fjesNOT_FAX_CALL	= fjesCALL_BLACKLISTED + 1,
	fjesPARTIALLY_RECEIVED	= fjesNOT_FAX_CALL + 1,
	fjesHANDLED	= fjesPARTIALLY_RECEIVED + 1,
	fjesCALL_COMPLETED	= fjesHANDLED + 1,
	fjesCALL_ABORTED	= fjesCALL_COMPLETED + 1,
	fjesPROPRIETARY	= 0x1000000
    } 	FAX_JOB_EXTENDED_STATUS_ENUM;

typedef 
enum FAX_JOB_OPERATIONS_ENUM
    {	fjoVIEW	= 0x1,
	fjoPAUSE	= 0x2,
	fjoRESUME	= 0x4,
	fjoRESTART	= 0x8,
	fjoDELETE	= 0x10,
	fjoRECIPIENT_INFO	= 0x20,
	fjoSENDER_INFO	= 0x40
    } 	FAX_JOB_OPERATIONS_ENUM;

typedef 
enum FAX_JOB_TYPE_ENUM
    {	fjtSEND	= 0,
	fjtRECEIVE	= fjtSEND + 1,
	fjtROUTING	= fjtRECEIVE + 1
    } 	FAX_JOB_TYPE_ENUM;


EXTERN_C const IID IID_IFaxJobStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8B86F485-FD7F-4824-886B-40C5CAA617CC")
    IFaxJobStatus : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ FAX_JOB_STATUS_ENUM *pStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Pages( 
            /* [retval][out] */ long *plPages) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Size( 
            /* [retval][out] */ long *plSize) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPage( 
            /* [retval][out] */ long *plCurrentPage) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceId( 
            /* [retval][out] */ long *plDeviceId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CSID( 
            /* [retval][out] */ BSTR *pbstrCSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TSID( 
            /* [retval][out] */ BSTR *pbstrTSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtendedStatusCode( 
            /* [retval][out] */ FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtendedStatus( 
            /* [retval][out] */ BSTR *pbstrExtendedStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AvailableOperations( 
            /* [retval][out] */ FAX_JOB_OPERATIONS_ENUM *pAvailableOperations) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Retries( 
            /* [retval][out] */ long *plRetries) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_JobType( 
            /* [retval][out] */ FAX_JOB_TYPE_ENUM *pJobType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ScheduledTime( 
            /* [retval][out] */ DATE *pdateScheduledTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransmissionStart( 
            /* [retval][out] */ DATE *pdateTransmissionStart) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransmissionEnd( 
            /* [retval][out] */ DATE *pdateTransmissionEnd) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallerId( 
            /* [retval][out] */ BSTR *pbstrCallerId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RoutingInformation( 
            /* [retval][out] */ BSTR *pbstrRoutingInformation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxJobStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxJobStatus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxJobStatus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxJobStatus * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxJobStatus * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxJobStatus * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxJobStatus * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxJobStatus * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IFaxJobStatus * This,
            /* [retval][out] */ FAX_JOB_STATUS_ENUM *pStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Pages )( 
            IFaxJobStatus * This,
            /* [retval][out] */ long *plPages);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Size )( 
            IFaxJobStatus * This,
            /* [retval][out] */ long *plSize);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPage )( 
            IFaxJobStatus * This,
            /* [retval][out] */ long *plCurrentPage);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceId )( 
            IFaxJobStatus * This,
            /* [retval][out] */ long *plDeviceId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CSID )( 
            IFaxJobStatus * This,
            /* [retval][out] */ BSTR *pbstrCSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TSID )( 
            IFaxJobStatus * This,
            /* [retval][out] */ BSTR *pbstrTSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExtendedStatusCode )( 
            IFaxJobStatus * This,
            /* [retval][out] */ FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExtendedStatus )( 
            IFaxJobStatus * This,
            /* [retval][out] */ BSTR *pbstrExtendedStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AvailableOperations )( 
            IFaxJobStatus * This,
            /* [retval][out] */ FAX_JOB_OPERATIONS_ENUM *pAvailableOperations);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Retries )( 
            IFaxJobStatus * This,
            /* [retval][out] */ long *plRetries);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_JobType )( 
            IFaxJobStatus * This,
            /* [retval][out] */ FAX_JOB_TYPE_ENUM *pJobType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ScheduledTime )( 
            IFaxJobStatus * This,
            /* [retval][out] */ DATE *pdateScheduledTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionStart )( 
            IFaxJobStatus * This,
            /* [retval][out] */ DATE *pdateTransmissionStart);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionEnd )( 
            IFaxJobStatus * This,
            /* [retval][out] */ DATE *pdateTransmissionEnd);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallerId )( 
            IFaxJobStatus * This,
            /* [retval][out] */ BSTR *pbstrCallerId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RoutingInformation )( 
            IFaxJobStatus * This,
            /* [retval][out] */ BSTR *pbstrRoutingInformation);
        
        END_INTERFACE
    } IFaxJobStatusVtbl;

    interface IFaxJobStatus
    {
        CONST_VTBL struct IFaxJobStatusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxJobStatus_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxJobStatus_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxJobStatus_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxJobStatus_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxJobStatus_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxJobStatus_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxJobStatus_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxJobStatus_get_Status(This,pStatus)	\
    (This)->lpVtbl -> get_Status(This,pStatus)

#define IFaxJobStatus_get_Pages(This,plPages)	\
    (This)->lpVtbl -> get_Pages(This,plPages)

#define IFaxJobStatus_get_Size(This,plSize)	\
    (This)->lpVtbl -> get_Size(This,plSize)

#define IFaxJobStatus_get_CurrentPage(This,plCurrentPage)	\
    (This)->lpVtbl -> get_CurrentPage(This,plCurrentPage)

#define IFaxJobStatus_get_DeviceId(This,plDeviceId)	\
    (This)->lpVtbl -> get_DeviceId(This,plDeviceId)

#define IFaxJobStatus_get_CSID(This,pbstrCSID)	\
    (This)->lpVtbl -> get_CSID(This,pbstrCSID)

#define IFaxJobStatus_get_TSID(This,pbstrTSID)	\
    (This)->lpVtbl -> get_TSID(This,pbstrTSID)

#define IFaxJobStatus_get_ExtendedStatusCode(This,pExtendedStatusCode)	\
    (This)->lpVtbl -> get_ExtendedStatusCode(This,pExtendedStatusCode)

#define IFaxJobStatus_get_ExtendedStatus(This,pbstrExtendedStatus)	\
    (This)->lpVtbl -> get_ExtendedStatus(This,pbstrExtendedStatus)

#define IFaxJobStatus_get_AvailableOperations(This,pAvailableOperations)	\
    (This)->lpVtbl -> get_AvailableOperations(This,pAvailableOperations)

#define IFaxJobStatus_get_Retries(This,plRetries)	\
    (This)->lpVtbl -> get_Retries(This,plRetries)

#define IFaxJobStatus_get_JobType(This,pJobType)	\
    (This)->lpVtbl -> get_JobType(This,pJobType)

#define IFaxJobStatus_get_ScheduledTime(This,pdateScheduledTime)	\
    (This)->lpVtbl -> get_ScheduledTime(This,pdateScheduledTime)

#define IFaxJobStatus_get_TransmissionStart(This,pdateTransmissionStart)	\
    (This)->lpVtbl -> get_TransmissionStart(This,pdateTransmissionStart)

#define IFaxJobStatus_get_TransmissionEnd(This,pdateTransmissionEnd)	\
    (This)->lpVtbl -> get_TransmissionEnd(This,pdateTransmissionEnd)

#define IFaxJobStatus_get_CallerId(This,pbstrCallerId)	\
    (This)->lpVtbl -> get_CallerId(This,pbstrCallerId)

#define IFaxJobStatus_get_RoutingInformation(This,pbstrRoutingInformation)	\
    (This)->lpVtbl -> get_RoutingInformation(This,pbstrRoutingInformation)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_Status_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ FAX_JOB_STATUS_ENUM *pStatus);


void __RPC_STUB IFaxJobStatus_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_Pages_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ long *plPages);


void __RPC_STUB IFaxJobStatus_get_Pages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_Size_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ long *plSize);


void __RPC_STUB IFaxJobStatus_get_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_CurrentPage_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ long *plCurrentPage);


void __RPC_STUB IFaxJobStatus_get_CurrentPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_DeviceId_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ long *plDeviceId);


void __RPC_STUB IFaxJobStatus_get_DeviceId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_CSID_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ BSTR *pbstrCSID);


void __RPC_STUB IFaxJobStatus_get_CSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_TSID_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ BSTR *pbstrTSID);


void __RPC_STUB IFaxJobStatus_get_TSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_ExtendedStatusCode_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode);


void __RPC_STUB IFaxJobStatus_get_ExtendedStatusCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_ExtendedStatus_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ BSTR *pbstrExtendedStatus);


void __RPC_STUB IFaxJobStatus_get_ExtendedStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_AvailableOperations_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ FAX_JOB_OPERATIONS_ENUM *pAvailableOperations);


void __RPC_STUB IFaxJobStatus_get_AvailableOperations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_Retries_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ long *plRetries);


void __RPC_STUB IFaxJobStatus_get_Retries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_JobType_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ FAX_JOB_TYPE_ENUM *pJobType);


void __RPC_STUB IFaxJobStatus_get_JobType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_ScheduledTime_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ DATE *pdateScheduledTime);


void __RPC_STUB IFaxJobStatus_get_ScheduledTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_TransmissionStart_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ DATE *pdateTransmissionStart);


void __RPC_STUB IFaxJobStatus_get_TransmissionStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_TransmissionEnd_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ DATE *pdateTransmissionEnd);


void __RPC_STUB IFaxJobStatus_get_TransmissionEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_CallerId_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ BSTR *pbstrCallerId);


void __RPC_STUB IFaxJobStatus_get_CallerId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobStatus_get_RoutingInformation_Proxy( 
    IFaxJobStatus * This,
    /* [retval][out] */ BSTR *pbstrRoutingInformation);


void __RPC_STUB IFaxJobStatus_get_RoutingInformation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxJobStatus_INTERFACE_DEFINED__ */


#ifndef __IFaxServer_INTERFACE_DEFINED__
#define __IFaxServer_INTERFACE_DEFINED__

/* interface IFaxServer */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 

typedef 
enum FAX_SERVER_EVENTS_TYPE_ENUM
    {	fsetNONE	= 0,
	fsetIN_QUEUE	= 0x1,
	fsetOUT_QUEUE	= 0x2,
	fsetCONFIG	= 0x4,
	fsetACTIVITY	= 0x8,
	fsetQUEUE_STATE	= 0x10,
	fsetIN_ARCHIVE	= 0x20,
	fsetOUT_ARCHIVE	= 0x40,
	fsetFXSSVC_ENDED	= 0x80,
	fsetDEVICE_STATUS	= 0x100,
	fsetINCOMING_CALL	= 0x200
    } 	FAX_SERVER_EVENTS_TYPE_ENUM;


EXTERN_C const IID IID_IFaxServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("475B6469-90A5-4878-A577-17A86E8E3462")
    IFaxServer : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ BSTR bstrServerName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ServerName( 
            /* [retval][out] */ BSTR *pbstrServerName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDeviceProviders( 
            /* [retval][out] */ IFaxDeviceProviders **ppFaxDeviceProviders) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDevices( 
            /* [retval][out] */ IFaxDevices **ppFaxDevices) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InboundRouting( 
            /* [retval][out] */ IFaxInboundRouting **ppFaxInboundRouting) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Folders( 
            /* [retval][out] */ IFaxFolders **pFaxFolders) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LoggingOptions( 
            /* [retval][out] */ IFaxLoggingOptions **ppFaxLoggingOptions) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MajorVersion( 
            /* [retval][out] */ long *plMajorVersion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinorVersion( 
            /* [retval][out] */ long *plMinorVersion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MajorBuild( 
            /* [retval][out] */ long *plMajorBuild) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinorBuild( 
            /* [retval][out] */ long *plMinorBuild) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Debug( 
            /* [retval][out] */ VARIANT_BOOL *pbDebug) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Activity( 
            /* [retval][out] */ IFaxActivity **ppFaxActivity) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutboundRouting( 
            /* [retval][out] */ IFaxOutboundRouting **ppFaxOutboundRouting) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReceiptOptions( 
            /* [retval][out] */ IFaxReceiptOptions **ppFaxReceiptOptions) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Security( 
            /* [retval][out] */ IFaxSecurity **ppFaxSecurity) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetExtensionProperty( 
            /* [in] */ BSTR bstrGUID,
            /* [retval][out] */ VARIANT *pvProperty) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetExtensionProperty( 
            /* [in] */ BSTR bstrGUID,
            /* [in] */ VARIANT vProperty) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ListenToServerEvents( 
            /* [in] */ FAX_SERVER_EVENTS_TYPE_ENUM EventTypes) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RegisterDeviceProvider( 
            /* [in] */ BSTR bstrGUID,
            /* [in] */ BSTR bstrFriendlyName,
            /* [in] */ BSTR bstrImageName,
            /* [in] */ BSTR TspName,
            /* [in] */ long lFSPIVersion) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnregisterDeviceProvider( 
            /* [in] */ BSTR bstrUniqueName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RegisterInboundRoutingExtension( 
            /* [in] */ BSTR bstrExtensionName,
            /* [in] */ BSTR bstrFriendlyName,
            /* [in] */ BSTR bstrImageName,
            /* [in] */ VARIANT vMethods) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnregisterInboundRoutingExtension( 
            /* [in] */ BSTR bstrExtensionUniqueName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RegisteredEvents( 
            /* [retval][out] */ FAX_SERVER_EVENTS_TYPE_ENUM *pEventTypes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxServer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxServer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxServer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxServer * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxServer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxServer * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxServer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IFaxServer * This,
            /* [in] */ BSTR bstrServerName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServerName )( 
            IFaxServer * This,
            /* [retval][out] */ BSTR *pbstrServerName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDeviceProviders )( 
            IFaxServer * This,
            /* [retval][out] */ IFaxDeviceProviders **ppFaxDeviceProviders);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDevices )( 
            IFaxServer * This,
            /* [retval][out] */ IFaxDevices **ppFaxDevices);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InboundRouting )( 
            IFaxServer * This,
            /* [retval][out] */ IFaxInboundRouting **ppFaxInboundRouting);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Folders )( 
            IFaxServer * This,
            /* [retval][out] */ IFaxFolders **pFaxFolders);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LoggingOptions )( 
            IFaxServer * This,
            /* [retval][out] */ IFaxLoggingOptions **ppFaxLoggingOptions);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MajorVersion )( 
            IFaxServer * This,
            /* [retval][out] */ long *plMajorVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinorVersion )( 
            IFaxServer * This,
            /* [retval][out] */ long *plMinorVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MajorBuild )( 
            IFaxServer * This,
            /* [retval][out] */ long *plMajorBuild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinorBuild )( 
            IFaxServer * This,
            /* [retval][out] */ long *plMinorBuild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Debug )( 
            IFaxServer * This,
            /* [retval][out] */ VARIANT_BOOL *pbDebug);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Activity )( 
            IFaxServer * This,
            /* [retval][out] */ IFaxActivity **ppFaxActivity);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutboundRouting )( 
            IFaxServer * This,
            /* [retval][out] */ IFaxOutboundRouting **ppFaxOutboundRouting);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReceiptOptions )( 
            IFaxServer * This,
            /* [retval][out] */ IFaxReceiptOptions **ppFaxReceiptOptions);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Security )( 
            IFaxServer * This,
            /* [retval][out] */ IFaxSecurity **ppFaxSecurity);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IFaxServer * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetExtensionProperty )( 
            IFaxServer * This,
            /* [in] */ BSTR bstrGUID,
            /* [retval][out] */ VARIANT *pvProperty);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetExtensionProperty )( 
            IFaxServer * This,
            /* [in] */ BSTR bstrGUID,
            /* [in] */ VARIANT vProperty);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ListenToServerEvents )( 
            IFaxServer * This,
            /* [in] */ FAX_SERVER_EVENTS_TYPE_ENUM EventTypes);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RegisterDeviceProvider )( 
            IFaxServer * This,
            /* [in] */ BSTR bstrGUID,
            /* [in] */ BSTR bstrFriendlyName,
            /* [in] */ BSTR bstrImageName,
            /* [in] */ BSTR TspName,
            /* [in] */ long lFSPIVersion);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UnregisterDeviceProvider )( 
            IFaxServer * This,
            /* [in] */ BSTR bstrUniqueName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RegisterInboundRoutingExtension )( 
            IFaxServer * This,
            /* [in] */ BSTR bstrExtensionName,
            /* [in] */ BSTR bstrFriendlyName,
            /* [in] */ BSTR bstrImageName,
            /* [in] */ VARIANT vMethods);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UnregisterInboundRoutingExtension )( 
            IFaxServer * This,
            /* [in] */ BSTR bstrExtensionUniqueName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RegisteredEvents )( 
            IFaxServer * This,
            /* [retval][out] */ FAX_SERVER_EVENTS_TYPE_ENUM *pEventTypes);
        
        END_INTERFACE
    } IFaxServerVtbl;

    interface IFaxServer
    {
        CONST_VTBL struct IFaxServerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxServer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxServer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxServer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxServer_Connect(This,bstrServerName)	\
    (This)->lpVtbl -> Connect(This,bstrServerName)

#define IFaxServer_get_ServerName(This,pbstrServerName)	\
    (This)->lpVtbl -> get_ServerName(This,pbstrServerName)

#define IFaxServer_GetDeviceProviders(This,ppFaxDeviceProviders)	\
    (This)->lpVtbl -> GetDeviceProviders(This,ppFaxDeviceProviders)

#define IFaxServer_GetDevices(This,ppFaxDevices)	\
    (This)->lpVtbl -> GetDevices(This,ppFaxDevices)

#define IFaxServer_get_InboundRouting(This,ppFaxInboundRouting)	\
    (This)->lpVtbl -> get_InboundRouting(This,ppFaxInboundRouting)

#define IFaxServer_get_Folders(This,pFaxFolders)	\
    (This)->lpVtbl -> get_Folders(This,pFaxFolders)

#define IFaxServer_get_LoggingOptions(This,ppFaxLoggingOptions)	\
    (This)->lpVtbl -> get_LoggingOptions(This,ppFaxLoggingOptions)

#define IFaxServer_get_MajorVersion(This,plMajorVersion)	\
    (This)->lpVtbl -> get_MajorVersion(This,plMajorVersion)

#define IFaxServer_get_MinorVersion(This,plMinorVersion)	\
    (This)->lpVtbl -> get_MinorVersion(This,plMinorVersion)

#define IFaxServer_get_MajorBuild(This,plMajorBuild)	\
    (This)->lpVtbl -> get_MajorBuild(This,plMajorBuild)

#define IFaxServer_get_MinorBuild(This,plMinorBuild)	\
    (This)->lpVtbl -> get_MinorBuild(This,plMinorBuild)

#define IFaxServer_get_Debug(This,pbDebug)	\
    (This)->lpVtbl -> get_Debug(This,pbDebug)

#define IFaxServer_get_Activity(This,ppFaxActivity)	\
    (This)->lpVtbl -> get_Activity(This,ppFaxActivity)

#define IFaxServer_get_OutboundRouting(This,ppFaxOutboundRouting)	\
    (This)->lpVtbl -> get_OutboundRouting(This,ppFaxOutboundRouting)

#define IFaxServer_get_ReceiptOptions(This,ppFaxReceiptOptions)	\
    (This)->lpVtbl -> get_ReceiptOptions(This,ppFaxReceiptOptions)

#define IFaxServer_get_Security(This,ppFaxSecurity)	\
    (This)->lpVtbl -> get_Security(This,ppFaxSecurity)

#define IFaxServer_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IFaxServer_GetExtensionProperty(This,bstrGUID,pvProperty)	\
    (This)->lpVtbl -> GetExtensionProperty(This,bstrGUID,pvProperty)

#define IFaxServer_SetExtensionProperty(This,bstrGUID,vProperty)	\
    (This)->lpVtbl -> SetExtensionProperty(This,bstrGUID,vProperty)

#define IFaxServer_ListenToServerEvents(This,EventTypes)	\
    (This)->lpVtbl -> ListenToServerEvents(This,EventTypes)

#define IFaxServer_RegisterDeviceProvider(This,bstrGUID,bstrFriendlyName,bstrImageName,TspName,lFSPIVersion)	\
    (This)->lpVtbl -> RegisterDeviceProvider(This,bstrGUID,bstrFriendlyName,bstrImageName,TspName,lFSPIVersion)

#define IFaxServer_UnregisterDeviceProvider(This,bstrUniqueName)	\
    (This)->lpVtbl -> UnregisterDeviceProvider(This,bstrUniqueName)

#define IFaxServer_RegisterInboundRoutingExtension(This,bstrExtensionName,bstrFriendlyName,bstrImageName,vMethods)	\
    (This)->lpVtbl -> RegisterInboundRoutingExtension(This,bstrExtensionName,bstrFriendlyName,bstrImageName,vMethods)

#define IFaxServer_UnregisterInboundRoutingExtension(This,bstrExtensionUniqueName)	\
    (This)->lpVtbl -> UnregisterInboundRoutingExtension(This,bstrExtensionUniqueName)

#define IFaxServer_get_RegisteredEvents(This,pEventTypes)	\
    (This)->lpVtbl -> get_RegisteredEvents(This,pEventTypes)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_Connect_Proxy( 
    IFaxServer * This,
    /* [in] */ BSTR bstrServerName);


void __RPC_STUB IFaxServer_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_ServerName_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ BSTR *pbstrServerName);


void __RPC_STUB IFaxServer_get_ServerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_GetDeviceProviders_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ IFaxDeviceProviders **ppFaxDeviceProviders);


void __RPC_STUB IFaxServer_GetDeviceProviders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_GetDevices_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ IFaxDevices **ppFaxDevices);


void __RPC_STUB IFaxServer_GetDevices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_InboundRouting_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ IFaxInboundRouting **ppFaxInboundRouting);


void __RPC_STUB IFaxServer_get_InboundRouting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_Folders_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ IFaxFolders **pFaxFolders);


void __RPC_STUB IFaxServer_get_Folders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_LoggingOptions_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ IFaxLoggingOptions **ppFaxLoggingOptions);


void __RPC_STUB IFaxServer_get_LoggingOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_MajorVersion_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ long *plMajorVersion);


void __RPC_STUB IFaxServer_get_MajorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_MinorVersion_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ long *plMinorVersion);


void __RPC_STUB IFaxServer_get_MinorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_MajorBuild_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ long *plMajorBuild);


void __RPC_STUB IFaxServer_get_MajorBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_MinorBuild_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ long *plMinorBuild);


void __RPC_STUB IFaxServer_get_MinorBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_Debug_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ VARIANT_BOOL *pbDebug);


void __RPC_STUB IFaxServer_get_Debug_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_Activity_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ IFaxActivity **ppFaxActivity);


void __RPC_STUB IFaxServer_get_Activity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_OutboundRouting_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ IFaxOutboundRouting **ppFaxOutboundRouting);


void __RPC_STUB IFaxServer_get_OutboundRouting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_ReceiptOptions_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ IFaxReceiptOptions **ppFaxReceiptOptions);


void __RPC_STUB IFaxServer_get_ReceiptOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_Security_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ IFaxSecurity **ppFaxSecurity);


void __RPC_STUB IFaxServer_get_Security_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_Disconnect_Proxy( 
    IFaxServer * This);


void __RPC_STUB IFaxServer_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_GetExtensionProperty_Proxy( 
    IFaxServer * This,
    /* [in] */ BSTR bstrGUID,
    /* [retval][out] */ VARIANT *pvProperty);


void __RPC_STUB IFaxServer_GetExtensionProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_SetExtensionProperty_Proxy( 
    IFaxServer * This,
    /* [in] */ BSTR bstrGUID,
    /* [in] */ VARIANT vProperty);


void __RPC_STUB IFaxServer_SetExtensionProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_ListenToServerEvents_Proxy( 
    IFaxServer * This,
    /* [in] */ FAX_SERVER_EVENTS_TYPE_ENUM EventTypes);


void __RPC_STUB IFaxServer_ListenToServerEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_RegisterDeviceProvider_Proxy( 
    IFaxServer * This,
    /* [in] */ BSTR bstrGUID,
    /* [in] */ BSTR bstrFriendlyName,
    /* [in] */ BSTR bstrImageName,
    /* [in] */ BSTR TspName,
    /* [in] */ long lFSPIVersion);


void __RPC_STUB IFaxServer_RegisterDeviceProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_UnregisterDeviceProvider_Proxy( 
    IFaxServer * This,
    /* [in] */ BSTR bstrUniqueName);


void __RPC_STUB IFaxServer_UnregisterDeviceProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_RegisterInboundRoutingExtension_Proxy( 
    IFaxServer * This,
    /* [in] */ BSTR bstrExtensionName,
    /* [in] */ BSTR bstrFriendlyName,
    /* [in] */ BSTR bstrImageName,
    /* [in] */ VARIANT vMethods);


void __RPC_STUB IFaxServer_RegisterInboundRoutingExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_UnregisterInboundRoutingExtension_Proxy( 
    IFaxServer * This,
    /* [in] */ BSTR bstrExtensionUniqueName);


void __RPC_STUB IFaxServer_UnregisterInboundRoutingExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_RegisteredEvents_Proxy( 
    IFaxServer * This,
    /* [retval][out] */ FAX_SERVER_EVENTS_TYPE_ENUM *pEventTypes);


void __RPC_STUB IFaxServer_get_RegisteredEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxServer_INTERFACE_DEFINED__ */


#ifndef __IFaxDeviceProviders_INTERFACE_DEFINED__
#define __IFaxDeviceProviders_INTERFACE_DEFINED__

/* interface IFaxDeviceProviders */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxDeviceProviders;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9FB76F62-4C7E-43A5-B6FD-502893F7E13E")
    IFaxDeviceProviders : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxDeviceProvider **pFaxDeviceProvider) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxDeviceProvidersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxDeviceProviders * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxDeviceProviders * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxDeviceProviders * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxDeviceProviders * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxDeviceProviders * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxDeviceProviders * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxDeviceProviders * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFaxDeviceProviders * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxDeviceProviders * This,
            /* [in] */ VARIANT vIndex,
            /* [retval][out] */ IFaxDeviceProvider **pFaxDeviceProvider);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxDeviceProviders * This,
            /* [retval][out] */ long *plCount);
        
        END_INTERFACE
    } IFaxDeviceProvidersVtbl;

    interface IFaxDeviceProviders
    {
        CONST_VTBL struct IFaxDeviceProvidersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxDeviceProviders_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxDeviceProviders_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxDeviceProviders_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxDeviceProviders_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxDeviceProviders_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxDeviceProviders_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxDeviceProviders_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxDeviceProviders_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#define IFaxDeviceProviders_get_Item(This,vIndex,pFaxDeviceProvider)	\
    (This)->lpVtbl -> get_Item(This,vIndex,pFaxDeviceProvider)

#define IFaxDeviceProviders_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProviders_get__NewEnum_Proxy( 
    IFaxDeviceProviders * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFaxDeviceProviders_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProviders_get_Item_Proxy( 
    IFaxDeviceProviders * This,
    /* [in] */ VARIANT vIndex,
    /* [retval][out] */ IFaxDeviceProvider **pFaxDeviceProvider);


void __RPC_STUB IFaxDeviceProviders_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxDeviceProviders_get_Count_Proxy( 
    IFaxDeviceProviders * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IFaxDeviceProviders_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxDeviceProviders_INTERFACE_DEFINED__ */


#ifndef __IFaxDevices_INTERFACE_DEFINED__
#define __IFaxDevices_INTERFACE_DEFINED__

/* interface IFaxDevices */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxDevices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9E46783E-F34F-482E-A360-0416BECBBD96")
    IFaxDevices : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ IFaxDevice **pFaxDevice) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ItemById( 
            /* [in] */ long lId,
            /* [retval][out] */ IFaxDevice **ppFaxDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxDevicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxDevices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxDevices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxDevices * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxDevices * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxDevices * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxDevices * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxDevices * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFaxDevices * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxDevices * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ IFaxDevice **pFaxDevice);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxDevices * This,
            /* [retval][out] */ long *plCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ItemById )( 
            IFaxDevices * This,
            /* [in] */ long lId,
            /* [retval][out] */ IFaxDevice **ppFaxDevice);
        
        END_INTERFACE
    } IFaxDevicesVtbl;

    interface IFaxDevices
    {
        CONST_VTBL struct IFaxDevicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxDevices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxDevices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxDevices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxDevices_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxDevices_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxDevices_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxDevices_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxDevices_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#define IFaxDevices_get_Item(This,lIndex,pFaxDevice)	\
    (This)->lpVtbl -> get_Item(This,lIndex,pFaxDevice)

#define IFaxDevices_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define IFaxDevices_ItemById(This,lId,ppFaxDevice)	\
    (This)->lpVtbl -> ItemById(This,lId,ppFaxDevice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxDevices_get__NewEnum_Proxy( 
    IFaxDevices * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFaxDevices_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxDevices_get_Item_Proxy( 
    IFaxDevices * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ IFaxDevice **pFaxDevice);


void __RPC_STUB IFaxDevices_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxDevices_get_Count_Proxy( 
    IFaxDevices * This,
    /* [retval][out] */ long *plCount);


void __RPC_STUB IFaxDevices_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDevices_ItemById_Proxy( 
    IFaxDevices * This,
    /* [in] */ long lId,
    /* [retval][out] */ IFaxDevice **ppFaxDevice);


void __RPC_STUB IFaxDevices_ItemById_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxDevices_INTERFACE_DEFINED__ */


#ifndef __IFaxInboundRouting_INTERFACE_DEFINED__
#define __IFaxInboundRouting_INTERFACE_DEFINED__

/* interface IFaxInboundRouting */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxInboundRouting;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8148C20F-9D52-45B1-BF96-38FC12713527")
    IFaxInboundRouting : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetExtensions( 
            /* [retval][out] */ IFaxInboundRoutingExtensions **pFaxInboundRoutingExtensions) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMethods( 
            /* [retval][out] */ IFaxInboundRoutingMethods **pFaxInboundRoutingMethods) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxInboundRoutingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxInboundRouting * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxInboundRouting * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxInboundRouting * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxInboundRouting * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxInboundRouting * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxInboundRouting * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxInboundRouting * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetExtensions )( 
            IFaxInboundRouting * This,
            /* [retval][out] */ IFaxInboundRoutingExtensions **pFaxInboundRoutingExtensions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMethods )( 
            IFaxInboundRouting * This,
            /* [retval][out] */ IFaxInboundRoutingMethods **pFaxInboundRoutingMethods);
        
        END_INTERFACE
    } IFaxInboundRoutingVtbl;

    interface IFaxInboundRouting
    {
        CONST_VTBL struct IFaxInboundRoutingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxInboundRouting_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxInboundRouting_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxInboundRouting_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxInboundRouting_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxInboundRouting_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxInboundRouting_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxInboundRouting_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxInboundRouting_GetExtensions(This,pFaxInboundRoutingExtensions)	\
    (This)->lpVtbl -> GetExtensions(This,pFaxInboundRoutingExtensions)

#define IFaxInboundRouting_GetMethods(This,pFaxInboundRoutingMethods)	\
    (This)->lpVtbl -> GetMethods(This,pFaxInboundRoutingMethods)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxInboundRouting_GetExtensions_Proxy( 
    IFaxInboundRouting * This,
    /* [retval][out] */ IFaxInboundRoutingExtensions **pFaxInboundRoutingExtensions);


void __RPC_STUB IFaxInboundRouting_GetExtensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxInboundRouting_GetMethods_Proxy( 
    IFaxInboundRouting * This,
    /* [retval][out] */ IFaxInboundRoutingMethods **pFaxInboundRoutingMethods);


void __RPC_STUB IFaxInboundRouting_GetMethods_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxInboundRouting_INTERFACE_DEFINED__ */


#ifndef __IFaxFolders_INTERFACE_DEFINED__
#define __IFaxFolders_INTERFACE_DEFINED__

/* interface IFaxFolders */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxFolders;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCE3B2A8-A7AB-42BC-9D0A-3149457261A0")
    IFaxFolders : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingQueue( 
            /* [retval][out] */ IFaxOutgoingQueue **pFaxOutgoingQueue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IncomingQueue( 
            /* [retval][out] */ IFaxIncomingQueue **pFaxIncomingQueue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IncomingArchive( 
            /* [retval][out] */ IFaxIncomingArchive **pFaxIncomingArchive) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingArchive( 
            /* [retval][out] */ IFaxOutgoingArchive **pFaxOutgoingArchive) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxFoldersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxFolders * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxFolders * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxFolders * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxFolders * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxFolders * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxFolders * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxFolders * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingQueue )( 
            IFaxFolders * This,
            /* [retval][out] */ IFaxOutgoingQueue **pFaxOutgoingQueue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IncomingQueue )( 
            IFaxFolders * This,
            /* [retval][out] */ IFaxIncomingQueue **pFaxIncomingQueue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IncomingArchive )( 
            IFaxFolders * This,
            /* [retval][out] */ IFaxIncomingArchive **pFaxIncomingArchive);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingArchive )( 
            IFaxFolders * This,
            /* [retval][out] */ IFaxOutgoingArchive **pFaxOutgoingArchive);
        
        END_INTERFACE
    } IFaxFoldersVtbl;

    interface IFaxFolders
    {
        CONST_VTBL struct IFaxFoldersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxFolders_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxFolders_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxFolders_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxFolders_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxFolders_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxFolders_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxFolders_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxFolders_get_OutgoingQueue(This,pFaxOutgoingQueue)	\
    (This)->lpVtbl -> get_OutgoingQueue(This,pFaxOutgoingQueue)

#define IFaxFolders_get_IncomingQueue(This,pFaxIncomingQueue)	\
    (This)->lpVtbl -> get_IncomingQueue(This,pFaxIncomingQueue)

#define IFaxFolders_get_IncomingArchive(This,pFaxIncomingArchive)	\
    (This)->lpVtbl -> get_IncomingArchive(This,pFaxIncomingArchive)

#define IFaxFolders_get_OutgoingArchive(This,pFaxOutgoingArchive)	\
    (This)->lpVtbl -> get_OutgoingArchive(This,pFaxOutgoingArchive)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxFolders_get_OutgoingQueue_Proxy( 
    IFaxFolders * This,
    /* [retval][out] */ IFaxOutgoingQueue **pFaxOutgoingQueue);


void __RPC_STUB IFaxFolders_get_OutgoingQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxFolders_get_IncomingQueue_Proxy( 
    IFaxFolders * This,
    /* [retval][out] */ IFaxIncomingQueue **pFaxIncomingQueue);


void __RPC_STUB IFaxFolders_get_IncomingQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxFolders_get_IncomingArchive_Proxy( 
    IFaxFolders * This,
    /* [retval][out] */ IFaxIncomingArchive **pFaxIncomingArchive);


void __RPC_STUB IFaxFolders_get_IncomingArchive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxFolders_get_OutgoingArchive_Proxy( 
    IFaxFolders * This,
    /* [retval][out] */ IFaxOutgoingArchive **pFaxOutgoingArchive);


void __RPC_STUB IFaxFolders_get_OutgoingArchive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxFolders_INTERFACE_DEFINED__ */


#ifndef __IFaxLoggingOptions_INTERFACE_DEFINED__
#define __IFaxLoggingOptions_INTERFACE_DEFINED__

/* interface IFaxLoggingOptions */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxLoggingOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34E64FB9-6B31-4D32-8B27-D286C0C33606")
    IFaxLoggingOptions : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventLogging( 
            /* [retval][out] */ IFaxEventLogging **pFaxEventLogging) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ActivityLogging( 
            /* [retval][out] */ IFaxActivityLogging **pFaxActivityLogging) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxLoggingOptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxLoggingOptions * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxLoggingOptions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxLoggingOptions * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxLoggingOptions * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxLoggingOptions * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxLoggingOptions * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxLoggingOptions * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventLogging )( 
            IFaxLoggingOptions * This,
            /* [retval][out] */ IFaxEventLogging **pFaxEventLogging);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ActivityLogging )( 
            IFaxLoggingOptions * This,
            /* [retval][out] */ IFaxActivityLogging **pFaxActivityLogging);
        
        END_INTERFACE
    } IFaxLoggingOptionsVtbl;

    interface IFaxLoggingOptions
    {
        CONST_VTBL struct IFaxLoggingOptionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxLoggingOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxLoggingOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxLoggingOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxLoggingOptions_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxLoggingOptions_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxLoggingOptions_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxLoggingOptions_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxLoggingOptions_get_EventLogging(This,pFaxEventLogging)	\
    (This)->lpVtbl -> get_EventLogging(This,pFaxEventLogging)

#define IFaxLoggingOptions_get_ActivityLogging(This,pFaxActivityLogging)	\
    (This)->lpVtbl -> get_ActivityLogging(This,pFaxActivityLogging)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxLoggingOptions_get_EventLogging_Proxy( 
    IFaxLoggingOptions * This,
    /* [retval][out] */ IFaxEventLogging **pFaxEventLogging);


void __RPC_STUB IFaxLoggingOptions_get_EventLogging_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxLoggingOptions_get_ActivityLogging_Proxy( 
    IFaxLoggingOptions * This,
    /* [retval][out] */ IFaxActivityLogging **pFaxActivityLogging);


void __RPC_STUB IFaxLoggingOptions_get_ActivityLogging_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxLoggingOptions_INTERFACE_DEFINED__ */


#ifndef __IFaxActivity_INTERFACE_DEFINED__
#define __IFaxActivity_INTERFACE_DEFINED__

/* interface IFaxActivity */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxActivity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4B106F97-3DF5-40F2-BC3C-44CB8115EBDF")
    IFaxActivity : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IncomingMessages( 
            /* [retval][out] */ long *plIncomingMessages) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RoutingMessages( 
            /* [retval][out] */ long *plRoutingMessages) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutgoingMessages( 
            /* [retval][out] */ long *plOutgoingMessages) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_QueuedMessages( 
            /* [retval][out] */ long *plQueuedMessages) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxActivityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxActivity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxActivity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxActivity * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxActivity * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxActivity * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxActivity * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxActivity * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IncomingMessages )( 
            IFaxActivity * This,
            /* [retval][out] */ long *plIncomingMessages);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RoutingMessages )( 
            IFaxActivity * This,
            /* [retval][out] */ long *plRoutingMessages);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutgoingMessages )( 
            IFaxActivity * This,
            /* [retval][out] */ long *plOutgoingMessages);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_QueuedMessages )( 
            IFaxActivity * This,
            /* [retval][out] */ long *plQueuedMessages);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxActivity * This);
        
        END_INTERFACE
    } IFaxActivityVtbl;

    interface IFaxActivity
    {
        CONST_VTBL struct IFaxActivityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxActivity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxActivity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxActivity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxActivity_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxActivity_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxActivity_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxActivity_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxActivity_get_IncomingMessages(This,plIncomingMessages)	\
    (This)->lpVtbl -> get_IncomingMessages(This,plIncomingMessages)

#define IFaxActivity_get_RoutingMessages(This,plRoutingMessages)	\
    (This)->lpVtbl -> get_RoutingMessages(This,plRoutingMessages)

#define IFaxActivity_get_OutgoingMessages(This,plOutgoingMessages)	\
    (This)->lpVtbl -> get_OutgoingMessages(This,plOutgoingMessages)

#define IFaxActivity_get_QueuedMessages(This,plQueuedMessages)	\
    (This)->lpVtbl -> get_QueuedMessages(This,plQueuedMessages)

#define IFaxActivity_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxActivity_get_IncomingMessages_Proxy( 
    IFaxActivity * This,
    /* [retval][out] */ long *plIncomingMessages);


void __RPC_STUB IFaxActivity_get_IncomingMessages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxActivity_get_RoutingMessages_Proxy( 
    IFaxActivity * This,
    /* [retval][out] */ long *plRoutingMessages);


void __RPC_STUB IFaxActivity_get_RoutingMessages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxActivity_get_OutgoingMessages_Proxy( 
    IFaxActivity * This,
    /* [retval][out] */ long *plOutgoingMessages);


void __RPC_STUB IFaxActivity_get_OutgoingMessages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxActivity_get_QueuedMessages_Proxy( 
    IFaxActivity * This,
    /* [retval][out] */ long *plQueuedMessages);


void __RPC_STUB IFaxActivity_get_QueuedMessages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxActivity_Refresh_Proxy( 
    IFaxActivity * This);


void __RPC_STUB IFaxActivity_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxActivity_INTERFACE_DEFINED__ */


#ifndef __IFaxOutboundRouting_INTERFACE_DEFINED__
#define __IFaxOutboundRouting_INTERFACE_DEFINED__

/* interface IFaxOutboundRouting */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxOutboundRouting;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("25DC05A4-9909-41BD-A95B-7E5D1DEC1D43")
    IFaxOutboundRouting : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetGroups( 
            /* [retval][out] */ IFaxOutboundRoutingGroups **pFaxOutboundRoutingGroups) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetRules( 
            /* [retval][out] */ IFaxOutboundRoutingRules **pFaxOutboundRoutingRules) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxOutboundRoutingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxOutboundRouting * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxOutboundRouting * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxOutboundRouting * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxOutboundRouting * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxOutboundRouting * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxOutboundRouting * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxOutboundRouting * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetGroups )( 
            IFaxOutboundRouting * This,
            /* [retval][out] */ IFaxOutboundRoutingGroups **pFaxOutboundRoutingGroups);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetRules )( 
            IFaxOutboundRouting * This,
            /* [retval][out] */ IFaxOutboundRoutingRules **pFaxOutboundRoutingRules);
        
        END_INTERFACE
    } IFaxOutboundRoutingVtbl;

    interface IFaxOutboundRouting
    {
        CONST_VTBL struct IFaxOutboundRoutingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxOutboundRouting_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxOutboundRouting_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxOutboundRouting_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxOutboundRouting_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxOutboundRouting_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxOutboundRouting_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxOutboundRouting_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxOutboundRouting_GetGroups(This,pFaxOutboundRoutingGroups)	\
    (This)->lpVtbl -> GetGroups(This,pFaxOutboundRoutingGroups)

#define IFaxOutboundRouting_GetRules(This,pFaxOutboundRoutingRules)	\
    (This)->lpVtbl -> GetRules(This,pFaxOutboundRoutingRules)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRouting_GetGroups_Proxy( 
    IFaxOutboundRouting * This,
    /* [retval][out] */ IFaxOutboundRoutingGroups **pFaxOutboundRoutingGroups);


void __RPC_STUB IFaxOutboundRouting_GetGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxOutboundRouting_GetRules_Proxy( 
    IFaxOutboundRouting * This,
    /* [retval][out] */ IFaxOutboundRoutingRules **pFaxOutboundRoutingRules);


void __RPC_STUB IFaxOutboundRouting_GetRules_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxOutboundRouting_INTERFACE_DEFINED__ */


#ifndef __IFaxReceiptOptions_INTERFACE_DEFINED__
#define __IFaxReceiptOptions_INTERFACE_DEFINED__

/* interface IFaxReceiptOptions */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 

typedef 
enum FAX_SMTP_AUTHENTICATION_TYPE_ENUM
    {	fsatANONYMOUS	= 0,
	fsatBASIC	= fsatANONYMOUS + 1,
	fsatNTLM	= fsatBASIC + 1
    } 	FAX_SMTP_AUTHENTICATION_TYPE_ENUM;

typedef 
enum FAX_RECEIPT_TYPE_ENUM
    {	frtNONE	= 0,
	frtMAIL	= 0x1,
	frtMSGBOX	= 0x4
    } 	FAX_RECEIPT_TYPE_ENUM;


EXTERN_C const IID IID_IFaxReceiptOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("378EFAEB-5FCB-4AFB-B2EE-E16E80614487")
    IFaxReceiptOptions : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AuthenticationType( 
            /* [retval][out] */ FAX_SMTP_AUTHENTICATION_TYPE_ENUM *pType) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AuthenticationType( 
            /* [in] */ FAX_SMTP_AUTHENTICATION_TYPE_ENUM Type) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SMTPServer( 
            /* [retval][out] */ BSTR *pbstrSMTPServer) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SMTPServer( 
            /* [in] */ BSTR bstrSMTPServer) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SMTPPort( 
            /* [retval][out] */ long *plSMTPPort) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SMTPPort( 
            /* [in] */ long lSMTPPort) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SMTPSender( 
            /* [retval][out] */ BSTR *pbstrSMTPSender) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SMTPSender( 
            /* [in] */ BSTR bstrSMTPSender) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SMTPUser( 
            /* [retval][out] */ BSTR *pbstrSMTPUser) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SMTPUser( 
            /* [in] */ BSTR bstrSMTPUser) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowedReceipts( 
            /* [retval][out] */ FAX_RECEIPT_TYPE_ENUM *pAllowedReceipts) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowedReceipts( 
            /* [in] */ FAX_RECEIPT_TYPE_ENUM AllowedReceipts) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SMTPPassword( 
            /* [retval][out] */ BSTR *pbstrSMTPPassword) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SMTPPassword( 
            /* [in] */ BSTR bstrSMTPPassword) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UseForInboundRouting( 
            /* [retval][out] */ VARIANT_BOOL *pbUseForInboundRouting) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UseForInboundRouting( 
            /* [in] */ VARIANT_BOOL bUseForInboundRouting) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxReceiptOptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxReceiptOptions * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxReceiptOptions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxReceiptOptions * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxReceiptOptions * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxReceiptOptions * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxReceiptOptions * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxReceiptOptions * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AuthenticationType )( 
            IFaxReceiptOptions * This,
            /* [retval][out] */ FAX_SMTP_AUTHENTICATION_TYPE_ENUM *pType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AuthenticationType )( 
            IFaxReceiptOptions * This,
            /* [in] */ FAX_SMTP_AUTHENTICATION_TYPE_ENUM Type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SMTPServer )( 
            IFaxReceiptOptions * This,
            /* [retval][out] */ BSTR *pbstrSMTPServer);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SMTPServer )( 
            IFaxReceiptOptions * This,
            /* [in] */ BSTR bstrSMTPServer);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SMTPPort )( 
            IFaxReceiptOptions * This,
            /* [retval][out] */ long *plSMTPPort);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SMTPPort )( 
            IFaxReceiptOptions * This,
            /* [in] */ long lSMTPPort);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SMTPSender )( 
            IFaxReceiptOptions * This,
            /* [retval][out] */ BSTR *pbstrSMTPSender);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SMTPSender )( 
            IFaxReceiptOptions * This,
            /* [in] */ BSTR bstrSMTPSender);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SMTPUser )( 
            IFaxReceiptOptions * This,
            /* [retval][out] */ BSTR *pbstrSMTPUser);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SMTPUser )( 
            IFaxReceiptOptions * This,
            /* [in] */ BSTR bstrSMTPUser);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowedReceipts )( 
            IFaxReceiptOptions * This,
            /* [retval][out] */ FAX_RECEIPT_TYPE_ENUM *pAllowedReceipts);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowedReceipts )( 
            IFaxReceiptOptions * This,
            /* [in] */ FAX_RECEIPT_TYPE_ENUM AllowedReceipts);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SMTPPassword )( 
            IFaxReceiptOptions * This,
            /* [retval][out] */ BSTR *pbstrSMTPPassword);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SMTPPassword )( 
            IFaxReceiptOptions * This,
            /* [in] */ BSTR bstrSMTPPassword);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxReceiptOptions * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IFaxReceiptOptions * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseForInboundRouting )( 
            IFaxReceiptOptions * This,
            /* [retval][out] */ VARIANT_BOOL *pbUseForInboundRouting);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseForInboundRouting )( 
            IFaxReceiptOptions * This,
            /* [in] */ VARIANT_BOOL bUseForInboundRouting);
        
        END_INTERFACE
    } IFaxReceiptOptionsVtbl;

    interface IFaxReceiptOptions
    {
        CONST_VTBL struct IFaxReceiptOptionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxReceiptOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxReceiptOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxReceiptOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxReceiptOptions_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxReceiptOptions_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxReceiptOptions_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxReceiptOptions_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxReceiptOptions_get_AuthenticationType(This,pType)	\
    (This)->lpVtbl -> get_AuthenticationType(This,pType)

#define IFaxReceiptOptions_put_AuthenticationType(This,Type)	\
    (This)->lpVtbl -> put_AuthenticationType(This,Type)

#define IFaxReceiptOptions_get_SMTPServer(This,pbstrSMTPServer)	\
    (This)->lpVtbl -> get_SMTPServer(This,pbstrSMTPServer)

#define IFaxReceiptOptions_put_SMTPServer(This,bstrSMTPServer)	\
    (This)->lpVtbl -> put_SMTPServer(This,bstrSMTPServer)

#define IFaxReceiptOptions_get_SMTPPort(This,plSMTPPort)	\
    (This)->lpVtbl -> get_SMTPPort(This,plSMTPPort)

#define IFaxReceiptOptions_put_SMTPPort(This,lSMTPPort)	\
    (This)->lpVtbl -> put_SMTPPort(This,lSMTPPort)

#define IFaxReceiptOptions_get_SMTPSender(This,pbstrSMTPSender)	\
    (This)->lpVtbl -> get_SMTPSender(This,pbstrSMTPSender)

#define IFaxReceiptOptions_put_SMTPSender(This,bstrSMTPSender)	\
    (This)->lpVtbl -> put_SMTPSender(This,bstrSMTPSender)

#define IFaxReceiptOptions_get_SMTPUser(This,pbstrSMTPUser)	\
    (This)->lpVtbl -> get_SMTPUser(This,pbstrSMTPUser)

#define IFaxReceiptOptions_put_SMTPUser(This,bstrSMTPUser)	\
    (This)->lpVtbl -> put_SMTPUser(This,bstrSMTPUser)

#define IFaxReceiptOptions_get_AllowedReceipts(This,pAllowedReceipts)	\
    (This)->lpVtbl -> get_AllowedReceipts(This,pAllowedReceipts)

#define IFaxReceiptOptions_put_AllowedReceipts(This,AllowedReceipts)	\
    (This)->lpVtbl -> put_AllowedReceipts(This,AllowedReceipts)

#define IFaxReceiptOptions_get_SMTPPassword(This,pbstrSMTPPassword)	\
    (This)->lpVtbl -> get_SMTPPassword(This,pbstrSMTPPassword)

#define IFaxReceiptOptions_put_SMTPPassword(This,bstrSMTPPassword)	\
    (This)->lpVtbl -> put_SMTPPassword(This,bstrSMTPPassword)

#define IFaxReceiptOptions_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxReceiptOptions_Save(This)	\
    (This)->lpVtbl -> Save(This)

#define IFaxReceiptOptions_get_UseForInboundRouting(This,pbUseForInboundRouting)	\
    (This)->lpVtbl -> get_UseForInboundRouting(This,pbUseForInboundRouting)

#define IFaxReceiptOptions_put_UseForInboundRouting(This,bUseForInboundRouting)	\
    (This)->lpVtbl -> put_UseForInboundRouting(This,bUseForInboundRouting)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_get_AuthenticationType_Proxy( 
    IFaxReceiptOptions * This,
    /* [retval][out] */ FAX_SMTP_AUTHENTICATION_TYPE_ENUM *pType);


void __RPC_STUB IFaxReceiptOptions_get_AuthenticationType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_put_AuthenticationType_Proxy( 
    IFaxReceiptOptions * This,
    /* [in] */ FAX_SMTP_AUTHENTICATION_TYPE_ENUM Type);


void __RPC_STUB IFaxReceiptOptions_put_AuthenticationType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_get_SMTPServer_Proxy( 
    IFaxReceiptOptions * This,
    /* [retval][out] */ BSTR *pbstrSMTPServer);


void __RPC_STUB IFaxReceiptOptions_get_SMTPServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_put_SMTPServer_Proxy( 
    IFaxReceiptOptions * This,
    /* [in] */ BSTR bstrSMTPServer);


void __RPC_STUB IFaxReceiptOptions_put_SMTPServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_get_SMTPPort_Proxy( 
    IFaxReceiptOptions * This,
    /* [retval][out] */ long *plSMTPPort);


void __RPC_STUB IFaxReceiptOptions_get_SMTPPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_put_SMTPPort_Proxy( 
    IFaxReceiptOptions * This,
    /* [in] */ long lSMTPPort);


void __RPC_STUB IFaxReceiptOptions_put_SMTPPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_get_SMTPSender_Proxy( 
    IFaxReceiptOptions * This,
    /* [retval][out] */ BSTR *pbstrSMTPSender);


void __RPC_STUB IFaxReceiptOptions_get_SMTPSender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_put_SMTPSender_Proxy( 
    IFaxReceiptOptions * This,
    /* [in] */ BSTR bstrSMTPSender);


void __RPC_STUB IFaxReceiptOptions_put_SMTPSender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_get_SMTPUser_Proxy( 
    IFaxReceiptOptions * This,
    /* [retval][out] */ BSTR *pbstrSMTPUser);


void __RPC_STUB IFaxReceiptOptions_get_SMTPUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_put_SMTPUser_Proxy( 
    IFaxReceiptOptions * This,
    /* [in] */ BSTR bstrSMTPUser);


void __RPC_STUB IFaxReceiptOptions_put_SMTPUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_get_AllowedReceipts_Proxy( 
    IFaxReceiptOptions * This,
    /* [retval][out] */ FAX_RECEIPT_TYPE_ENUM *pAllowedReceipts);


void __RPC_STUB IFaxReceiptOptions_get_AllowedReceipts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_put_AllowedReceipts_Proxy( 
    IFaxReceiptOptions * This,
    /* [in] */ FAX_RECEIPT_TYPE_ENUM AllowedReceipts);


void __RPC_STUB IFaxReceiptOptions_put_AllowedReceipts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_get_SMTPPassword_Proxy( 
    IFaxReceiptOptions * This,
    /* [retval][out] */ BSTR *pbstrSMTPPassword);


void __RPC_STUB IFaxReceiptOptions_get_SMTPPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_put_SMTPPassword_Proxy( 
    IFaxReceiptOptions * This,
    /* [in] */ BSTR bstrSMTPPassword);


void __RPC_STUB IFaxReceiptOptions_put_SMTPPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_Refresh_Proxy( 
    IFaxReceiptOptions * This);


void __RPC_STUB IFaxReceiptOptions_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_Save_Proxy( 
    IFaxReceiptOptions * This);


void __RPC_STUB IFaxReceiptOptions_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_get_UseForInboundRouting_Proxy( 
    IFaxReceiptOptions * This,
    /* [retval][out] */ VARIANT_BOOL *pbUseForInboundRouting);


void __RPC_STUB IFaxReceiptOptions_get_UseForInboundRouting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxReceiptOptions_put_UseForInboundRouting_Proxy( 
    IFaxReceiptOptions * This,
    /* [in] */ VARIANT_BOOL bUseForInboundRouting);


void __RPC_STUB IFaxReceiptOptions_put_UseForInboundRouting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxReceiptOptions_INTERFACE_DEFINED__ */


#ifndef __IFaxSecurity_INTERFACE_DEFINED__
#define __IFaxSecurity_INTERFACE_DEFINED__

/* interface IFaxSecurity */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 

typedef 
enum FAX_ACCESS_RIGHTS_ENUM
    {	farSUBMIT_LOW	= 0x1,
	farSUBMIT_NORMAL	= 0x3,
	farSUBMIT_HIGH	= 0x7,
	farQUERY_JOBS	= 0x8,
	farMANAGE_JOBS	= 0x18,
	farQUERY_CONFIG	= 0x20,
	farMANAGE_CONFIG	= 0x60,
	farQUERY_IN_ARCHIVE	= 0x80,
	farMANAGE_IN_ARCHIVE	= 0x180,
	farQUERY_OUT_ARCHIVE	= 0x200,
	farMANAGE_OUT_ARCHIVE	= 0x600
    } 	FAX_ACCESS_RIGHTS_ENUM;


EXTERN_C const IID IID_IFaxSecurity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77B508C1-09C0-47A2-91EB-FCE7FDF2690E")
    IFaxSecurity : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Descriptor( 
            /* [retval][out] */ VARIANT *pvDescriptor) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Descriptor( 
            /* [in] */ VARIANT vDescriptor) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GrantedRights( 
            /* [retval][out] */ FAX_ACCESS_RIGHTS_ENUM *pGrantedRights) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxSecurityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxSecurity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxSecurity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxSecurity * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxSecurity * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxSecurity * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxSecurity * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxSecurity * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Descriptor )( 
            IFaxSecurity * This,
            /* [retval][out] */ VARIANT *pvDescriptor);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Descriptor )( 
            IFaxSecurity * This,
            /* [in] */ VARIANT vDescriptor);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GrantedRights )( 
            IFaxSecurity * This,
            /* [retval][out] */ FAX_ACCESS_RIGHTS_ENUM *pGrantedRights);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IFaxSecurity * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            IFaxSecurity * This);
        
        END_INTERFACE
    } IFaxSecurityVtbl;

    interface IFaxSecurity
    {
        CONST_VTBL struct IFaxSecurityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxSecurity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxSecurity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxSecurity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxSecurity_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxSecurity_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxSecurity_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxSecurity_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxSecurity_get_Descriptor(This,pvDescriptor)	\
    (This)->lpVtbl -> get_Descriptor(This,pvDescriptor)

#define IFaxSecurity_put_Descriptor(This,vDescriptor)	\
    (This)->lpVtbl -> put_Descriptor(This,vDescriptor)

#define IFaxSecurity_get_GrantedRights(This,pGrantedRights)	\
    (This)->lpVtbl -> get_GrantedRights(This,pGrantedRights)

#define IFaxSecurity_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IFaxSecurity_Save(This)	\
    (This)->lpVtbl -> Save(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSecurity_get_Descriptor_Proxy( 
    IFaxSecurity * This,
    /* [retval][out] */ VARIANT *pvDescriptor);


void __RPC_STUB IFaxSecurity_get_Descriptor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxSecurity_put_Descriptor_Proxy( 
    IFaxSecurity * This,
    /* [in] */ VARIANT vDescriptor);


void __RPC_STUB IFaxSecurity_put_Descriptor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxSecurity_get_GrantedRights_Proxy( 
    IFaxSecurity * This,
    /* [retval][out] */ FAX_ACCESS_RIGHTS_ENUM *pGrantedRights);


void __RPC_STUB IFaxSecurity_get_GrantedRights_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxSecurity_Refresh_Proxy( 
    IFaxSecurity * This);


void __RPC_STUB IFaxSecurity_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxSecurity_Save_Proxy( 
    IFaxSecurity * This);


void __RPC_STUB IFaxSecurity_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxSecurity_INTERFACE_DEFINED__ */


#ifndef __IFaxDocument_INTERFACE_DEFINED__
#define __IFaxDocument_INTERFACE_DEFINED__

/* interface IFaxDocument */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 

typedef 
enum FAX_PRIORITY_TYPE_ENUM
    {	fptLOW	= 0,
	fptNORMAL	= fptLOW + 1,
	fptHIGH	= fptNORMAL + 1
    } 	FAX_PRIORITY_TYPE_ENUM;

typedef 
enum FAX_COVERPAGE_TYPE_ENUM
    {	fcptNONE	= 0,
	fcptLOCAL	= fcptNONE + 1,
	fcptSERVER	= fcptLOCAL + 1
    } 	FAX_COVERPAGE_TYPE_ENUM;

typedef 
enum FAX_SCHEDULE_TYPE_ENUM
    {	fstNOW	= 0,
	fstSPECIFIC_TIME	= fstNOW + 1,
	fstDISCOUNT_PERIOD	= fstSPECIFIC_TIME + 1
    } 	FAX_SCHEDULE_TYPE_ENUM;


EXTERN_C const IID IID_IFaxDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B207A246-09E3-4A4E-A7DC-FEA31D29458F")
    IFaxDocument : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Attachments( 
            /* [retval][out] */ IFaxAttachments **ppFaxAttachments) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Sender( 
            /* [retval][out] */ IFaxSender **ppFaxSender) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Recipients( 
            /* [retval][out] */ IFaxRecipients **ppFaxRecipients) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CoverPage( 
            /* [retval][out] */ BSTR *pbstrCoverPage) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CoverPage( 
            /* [in] */ BSTR bstrCoverPage) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Subject( 
            /* [retval][out] */ BSTR *pbstrSubject) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Subject( 
            /* [in] */ BSTR bstrSubject) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Note( 
            /* [retval][out] */ BSTR *pbstrNote) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Note( 
            /* [in] */ BSTR bstrNote) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ScheduleTime( 
            /* [retval][out] */ DATE *pdateScheduleTime) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ScheduleTime( 
            /* [in] */ DATE dateScheduleTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReceiptAddress( 
            /* [retval][out] */ BSTR *pbstrReceiptAddress) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ReceiptAddress( 
            /* [in] */ BSTR bstrReceiptAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DocumentName( 
            /* [retval][out] */ BSTR *pbstrDocumentName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DocumentName( 
            /* [in] */ BSTR bstrDocumentName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallHandle( 
            /* [retval][out] */ long *plCallHandle) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CallHandle( 
            /* [in] */ long lCallHandle) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CoverPageType( 
            /* [retval][out] */ FAX_COVERPAGE_TYPE_ENUM *pCoverPageType) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CoverPageType( 
            /* [in] */ FAX_COVERPAGE_TYPE_ENUM CoverPageType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ScheduleType( 
            /* [retval][out] */ FAX_SCHEDULE_TYPE_ENUM *pScheduleType) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ScheduleType( 
            /* [in] */ FAX_SCHEDULE_TYPE_ENUM ScheduleType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReceiptType( 
            /* [retval][out] */ FAX_RECEIPT_TYPE_ENUM *pReceiptType) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ReceiptType( 
            /* [in] */ FAX_RECEIPT_TYPE_ENUM ReceiptType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GroupBroadcastReceipts( 
            /* [retval][out] */ VARIANT_BOOL *pbUseGrouping) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_GroupBroadcastReceipts( 
            /* [in] */ VARIANT_BOOL bUseGrouping) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Priority( 
            /* [retval][out] */ FAX_PRIORITY_TYPE_ENUM *pPriority) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Priority( 
            /* [in] */ FAX_PRIORITY_TYPE_ENUM Priority) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TapiConnection( 
            /* [retval][out] */ IDispatch **ppTapiConnection) = 0;
        
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_TapiConnection( 
            /* [in] */ IDispatch *pTapiConnection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Submit( 
            /* [in] */ BSTR bstrFaxServerName,
            /* [retval][out] */ VARIANT *pvFaxOutgoingJobIDs) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConnectedSubmit( 
            /* [in] */ IFaxServer *pFaxServer,
            /* [retval][out] */ VARIANT *pvFaxOutgoingJobIDs) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AttachFaxToReceipt( 
            /* [retval][out] */ VARIANT_BOOL *pbAttachFax) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AttachFaxToReceipt( 
            /* [in] */ VARIANT_BOOL bAttachFax) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GeneratePreview( 
            /* [in] */ BSTR bstrFileName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxDocument * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxDocument * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxDocument * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxDocument * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxDocument * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxDocument * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxDocument * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Attachments )( 
            IFaxDocument * This,
            /* [retval][out] */ IFaxAttachments **ppFaxAttachments);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Sender )( 
            IFaxDocument * This,
            /* [retval][out] */ IFaxSender **ppFaxSender);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Recipients )( 
            IFaxDocument * This,
            /* [retval][out] */ IFaxRecipients **ppFaxRecipients);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CoverPage )( 
            IFaxDocument * This,
            /* [retval][out] */ BSTR *pbstrCoverPage);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CoverPage )( 
            IFaxDocument * This,
            /* [in] */ BSTR bstrCoverPage);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Subject )( 
            IFaxDocument * This,
            /* [retval][out] */ BSTR *pbstrSubject);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Subject )( 
            IFaxDocument * This,
            /* [in] */ BSTR bstrSubject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Note )( 
            IFaxDocument * This,
            /* [retval][out] */ BSTR *pbstrNote);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Note )( 
            IFaxDocument * This,
            /* [in] */ BSTR bstrNote);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ScheduleTime )( 
            IFaxDocument * This,
            /* [retval][out] */ DATE *pdateScheduleTime);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ScheduleTime )( 
            IFaxDocument * This,
            /* [in] */ DATE dateScheduleTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReceiptAddress )( 
            IFaxDocument * This,
            /* [retval][out] */ BSTR *pbstrReceiptAddress);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReceiptAddress )( 
            IFaxDocument * This,
            /* [in] */ BSTR bstrReceiptAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocumentName )( 
            IFaxDocument * This,
            /* [retval][out] */ BSTR *pbstrDocumentName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DocumentName )( 
            IFaxDocument * This,
            /* [in] */ BSTR bstrDocumentName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallHandle )( 
            IFaxDocument * This,
            /* [retval][out] */ long *plCallHandle);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CallHandle )( 
            IFaxDocument * This,
            /* [in] */ long lCallHandle);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CoverPageType )( 
            IFaxDocument * This,
            /* [retval][out] */ FAX_COVERPAGE_TYPE_ENUM *pCoverPageType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CoverPageType )( 
            IFaxDocument * This,
            /* [in] */ FAX_COVERPAGE_TYPE_ENUM CoverPageType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ScheduleType )( 
            IFaxDocument * This,
            /* [retval][out] */ FAX_SCHEDULE_TYPE_ENUM *pScheduleType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ScheduleType )( 
            IFaxDocument * This,
            /* [in] */ FAX_SCHEDULE_TYPE_ENUM ScheduleType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReceiptType )( 
            IFaxDocument * This,
            /* [retval][out] */ FAX_RECEIPT_TYPE_ENUM *pReceiptType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReceiptType )( 
            IFaxDocument * This,
            /* [in] */ FAX_RECEIPT_TYPE_ENUM ReceiptType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GroupBroadcastReceipts )( 
            IFaxDocument * This,
            /* [retval][out] */ VARIANT_BOOL *pbUseGrouping);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_GroupBroadcastReceipts )( 
            IFaxDocument * This,
            /* [in] */ VARIANT_BOOL bUseGrouping);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Priority )( 
            IFaxDocument * This,
            /* [retval][out] */ FAX_PRIORITY_TYPE_ENUM *pPriority);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Priority )( 
            IFaxDocument * This,
            /* [in] */ FAX_PRIORITY_TYPE_ENUM Priority);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TapiConnection )( 
            IFaxDocument * This,
            /* [retval][out] */ IDispatch **ppTapiConnection);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_TapiConnection )( 
            IFaxDocument * This,
            /* [in] */ IDispatch *pTapiConnection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Submit )( 
            IFaxDocument * This,
            /* [in] */ BSTR bstrFaxServerName,
            /* [retval][out] */ VARIANT *pvFaxOutgoingJobIDs);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ConnectedSubmit )( 
            IFaxDocument * This,
            /* [in] */ IFaxServer *pFaxServer,
            /* [retval][out] */ VARIANT *pvFaxOutgoingJobIDs);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AttachFaxToReceipt )( 
            IFaxDocument * This,
            /* [retval][out] */ VARIANT_BOOL *pbAttachFax);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AttachFaxToReceipt )( 
            IFaxDocument * This,
            /* [in] */ VARIANT_BOOL bAttachFax);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GeneratePreview )( 
            IFaxDocument * This,
            /* [in] */ BSTR bstrFileName);
        
        END_INTERFACE
    } IFaxDocumentVtbl;

    interface IFaxDocument
    {
        CONST_VTBL struct IFaxDocumentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxDocument_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxDocument_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxDocument_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxDocument_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxDocument_get_Attachments(This,ppFaxAttachments)	\
    (This)->lpVtbl -> get_Attachments(This,ppFaxAttachments)

#define IFaxDocument_get_Sender(This,ppFaxSender)	\
    (This)->lpVtbl -> get_Sender(This,ppFaxSender)

#define IFaxDocument_get_Recipients(This,ppFaxRecipients)	\
    (This)->lpVtbl -> get_Recipients(This,ppFaxRecipients)

#define IFaxDocument_get_CoverPage(This,pbstrCoverPage)	\
    (This)->lpVtbl -> get_CoverPage(This,pbstrCoverPage)

#define IFaxDocument_put_CoverPage(This,bstrCoverPage)	\
    (This)->lpVtbl -> put_CoverPage(This,bstrCoverPage)

#define IFaxDocument_get_Subject(This,pbstrSubject)	\
    (This)->lpVtbl -> get_Subject(This,pbstrSubject)

#define IFaxDocument_put_Subject(This,bstrSubject)	\
    (This)->lpVtbl -> put_Subject(This,bstrSubject)

#define IFaxDocument_get_Note(This,pbstrNote)	\
    (This)->lpVtbl -> get_Note(This,pbstrNote)

#define IFaxDocument_put_Note(This,bstrNote)	\
    (This)->lpVtbl -> put_Note(This,bstrNote)

#define IFaxDocument_get_ScheduleTime(This,pdateScheduleTime)	\
    (This)->lpVtbl -> get_ScheduleTime(This,pdateScheduleTime)

#define IFaxDocument_put_ScheduleTime(This,dateScheduleTime)	\
    (This)->lpVtbl -> put_ScheduleTime(This,dateScheduleTime)

#define IFaxDocument_get_ReceiptAddress(This,pbstrReceiptAddress)	\
    (This)->lpVtbl -> get_ReceiptAddress(This,pbstrReceiptAddress)

#define IFaxDocument_put_ReceiptAddress(This,bstrReceiptAddress)	\
    (This)->lpVtbl -> put_ReceiptAddress(This,bstrReceiptAddress)

#define IFaxDocument_get_DocumentName(This,pbstrDocumentName)	\
    (This)->lpVtbl -> get_DocumentName(This,pbstrDocumentName)

#define IFaxDocument_put_DocumentName(This,bstrDocumentName)	\
    (This)->lpVtbl -> put_DocumentName(This,bstrDocumentName)

#define IFaxDocument_get_CallHandle(This,plCallHandle)	\
    (This)->lpVtbl -> get_CallHandle(This,plCallHandle)

#define IFaxDocument_put_CallHandle(This,lCallHandle)	\
    (This)->lpVtbl -> put_CallHandle(This,lCallHandle)

#define IFaxDocument_get_CoverPageType(This,pCoverPageType)	\
    (This)->lpVtbl -> get_CoverPageType(This,pCoverPageType)

#define IFaxDocument_put_CoverPageType(This,CoverPageType)	\
    (This)->lpVtbl -> put_CoverPageType(This,CoverPageType)

#define IFaxDocument_get_ScheduleType(This,pScheduleType)	\
    (This)->lpVtbl -> get_ScheduleType(This,pScheduleType)

#define IFaxDocument_put_ScheduleType(This,ScheduleType)	\
    (This)->lpVtbl -> put_ScheduleType(This,ScheduleType)

#define IFaxDocument_get_ReceiptType(This,pReceiptType)	\
    (This)->lpVtbl -> get_ReceiptType(This,pReceiptType)

#define IFaxDocument_put_ReceiptType(This,ReceiptType)	\
    (This)->lpVtbl -> put_ReceiptType(This,ReceiptType)

#define IFaxDocument_get_GroupBroadcastReceipts(This,pbUseGrouping)	\
    (This)->lpVtbl -> get_GroupBroadcastReceipts(This,pbUseGrouping)

#define IFaxDocument_put_GroupBroadcastReceipts(This,bUseGrouping)	\
    (This)->lpVtbl -> put_GroupBroadcastReceipts(This,bUseGrouping)

#define IFaxDocument_get_Priority(This,pPriority)	\
    (This)->lpVtbl -> get_Priority(This,pPriority)

#define IFaxDocument_put_Priority(This,Priority)	\
    (This)->lpVtbl -> put_Priority(This,Priority)

#define IFaxDocument_get_TapiConnection(This,ppTapiConnection)	\
    (This)->lpVtbl -> get_TapiConnection(This,ppTapiConnection)

#define IFaxDocument_putref_TapiConnection(This,pTapiConnection)	\
    (This)->lpVtbl -> putref_TapiConnection(This,pTapiConnection)

#define IFaxDocument_Submit(This,bstrFaxServerName,pvFaxOutgoingJobIDs)	\
    (This)->lpVtbl -> Submit(This,bstrFaxServerName,pvFaxOutgoingJobIDs)

#define IFaxDocument_ConnectedSubmit(This,pFaxServer,pvFaxOutgoingJobIDs)	\
    (This)->lpVtbl -> ConnectedSubmit(This,pFaxServer,pvFaxOutgoingJobIDs)

#define IFaxDocument_get_AttachFaxToReceipt(This,pbAttachFax)	\
    (This)->lpVtbl -> get_AttachFaxToReceipt(This,pbAttachFax)

#define IFaxDocument_put_AttachFaxToReceipt(This,bAttachFax)	\
    (This)->lpVtbl -> put_AttachFaxToReceipt(This,bAttachFax)

#define IFaxDocument_GeneratePreview(This,bstrFileName)	\
    (This)->lpVtbl -> GeneratePreview(This,bstrFileName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_Attachments_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ IFaxAttachments **ppFaxAttachments);


void __RPC_STUB IFaxDocument_get_Attachments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_Sender_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ IFaxSender **ppFaxSender);


void __RPC_STUB IFaxDocument_get_Sender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_Recipients_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ IFaxRecipients **ppFaxRecipients);


void __RPC_STUB IFaxDocument_get_Recipients_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_CoverPage_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ BSTR *pbstrCoverPage);


void __RPC_STUB IFaxDocument_get_CoverPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_CoverPage_Proxy( 
    IFaxDocument * This,
    /* [in] */ BSTR bstrCoverPage);


void __RPC_STUB IFaxDocument_put_CoverPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_Subject_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ BSTR *pbstrSubject);


void __RPC_STUB IFaxDocument_get_Subject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_Subject_Proxy( 
    IFaxDocument * This,
    /* [in] */ BSTR bstrSubject);


void __RPC_STUB IFaxDocument_put_Subject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_Note_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ BSTR *pbstrNote);


void __RPC_STUB IFaxDocument_get_Note_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_Note_Proxy( 
    IFaxDocument * This,
    /* [in] */ BSTR bstrNote);


void __RPC_STUB IFaxDocument_put_Note_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_ScheduleTime_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ DATE *pdateScheduleTime);


void __RPC_STUB IFaxDocument_get_ScheduleTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_ScheduleTime_Proxy( 
    IFaxDocument * This,
    /* [in] */ DATE dateScheduleTime);


void __RPC_STUB IFaxDocument_put_ScheduleTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_ReceiptAddress_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ BSTR *pbstrReceiptAddress);


void __RPC_STUB IFaxDocument_get_ReceiptAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_ReceiptAddress_Proxy( 
    IFaxDocument * This,
    /* [in] */ BSTR bstrReceiptAddress);


void __RPC_STUB IFaxDocument_put_ReceiptAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_DocumentName_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ BSTR *pbstrDocumentName);


void __RPC_STUB IFaxDocument_get_DocumentName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_DocumentName_Proxy( 
    IFaxDocument * This,
    /* [in] */ BSTR bstrDocumentName);


void __RPC_STUB IFaxDocument_put_DocumentName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_CallHandle_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ long *plCallHandle);


void __RPC_STUB IFaxDocument_get_CallHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_CallHandle_Proxy( 
    IFaxDocument * This,
    /* [in] */ long lCallHandle);


void __RPC_STUB IFaxDocument_put_CallHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_CoverPageType_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ FAX_COVERPAGE_TYPE_ENUM *pCoverPageType);


void __RPC_STUB IFaxDocument_get_CoverPageType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_CoverPageType_Proxy( 
    IFaxDocument * This,
    /* [in] */ FAX_COVERPAGE_TYPE_ENUM CoverPageType);


void __RPC_STUB IFaxDocument_put_CoverPageType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_ScheduleType_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ FAX_SCHEDULE_TYPE_ENUM *pScheduleType);


void __RPC_STUB IFaxDocument_get_ScheduleType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_ScheduleType_Proxy( 
    IFaxDocument * This,
    /* [in] */ FAX_SCHEDULE_TYPE_ENUM ScheduleType);


void __RPC_STUB IFaxDocument_put_ScheduleType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_ReceiptType_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ FAX_RECEIPT_TYPE_ENUM *pReceiptType);


void __RPC_STUB IFaxDocument_get_ReceiptType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_ReceiptType_Proxy( 
    IFaxDocument * This,
    /* [in] */ FAX_RECEIPT_TYPE_ENUM ReceiptType);


void __RPC_STUB IFaxDocument_put_ReceiptType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_GroupBroadcastReceipts_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ VARIANT_BOOL *pbUseGrouping);


void __RPC_STUB IFaxDocument_get_GroupBroadcastReceipts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_GroupBroadcastReceipts_Proxy( 
    IFaxDocument * This,
    /* [in] */ VARIANT_BOOL bUseGrouping);


void __RPC_STUB IFaxDocument_put_GroupBroadcastReceipts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_Priority_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ FAX_PRIORITY_TYPE_ENUM *pPriority);


void __RPC_STUB IFaxDocument_get_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_Priority_Proxy( 
    IFaxDocument * This,
    /* [in] */ FAX_PRIORITY_TYPE_ENUM Priority);


void __RPC_STUB IFaxDocument_put_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_TapiConnection_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ IDispatch **ppTapiConnection);


void __RPC_STUB IFaxDocument_get_TapiConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IFaxDocument_putref_TapiConnection_Proxy( 
    IFaxDocument * This,
    /* [in] */ IDispatch *pTapiConnection);


void __RPC_STUB IFaxDocument_putref_TapiConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDocument_Submit_Proxy( 
    IFaxDocument * This,
    /* [in] */ BSTR bstrFaxServerName,
    /* [retval][out] */ VARIANT *pvFaxOutgoingJobIDs);


void __RPC_STUB IFaxDocument_Submit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDocument_ConnectedSubmit_Proxy( 
    IFaxDocument * This,
    /* [in] */ IFaxServer *pFaxServer,
    /* [retval][out] */ VARIANT *pvFaxOutgoingJobIDs);


void __RPC_STUB IFaxDocument_ConnectedSubmit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDocument_get_AttachFaxToReceipt_Proxy( 
    IFaxDocument * This,
    /* [retval][out] */ VARIANT_BOOL *pbAttachFax);


void __RPC_STUB IFaxDocument_get_AttachFaxToReceipt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDocument_put_AttachFaxToReceipt_Proxy( 
    IFaxDocument * This,
    /* [in] */ VARIANT_BOOL bAttachFax);


void __RPC_STUB IFaxDocument_put_AttachFaxToReceipt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDocument_GeneratePreview_Proxy( 
    IFaxDocument * This,
    /* [in] */ BSTR bstrFileName);


void __RPC_STUB IFaxDocument_GeneratePreview_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxDocument_INTERFACE_DEFINED__ */


#ifndef __IFaxAttachments_INTERFACE_DEFINED__
#define __IFaxAttachments_INTERFACE_DEFINED__

/* interface IFaxAttachments */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxAttachments;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("78E271E4-2C18-40CE-94B2-8132BB6883FD")
    IFaxAttachments : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ BSTR *pbstrAttachmentPath) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrAttachmentPath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxAttachmentsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFaxAttachments * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFaxAttachments * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFaxAttachments * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFaxAttachments * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFaxAttachments * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFaxAttachments * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFaxAttachments * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFaxAttachments * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFaxAttachments * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ BSTR *pbstrAttachmentPath);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFaxAttachments * This,
            /* [retval][out] */ long *plCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IFaxAttachments * This,
            /* [in] */ BSTR bstrAttachmentPath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IFaxAttachments * This,
            /* [in] */ long lIndex);
        
        END_INTERFACE
    } IFaxAttachmentsVtbl;

    interface IFaxAttachments
    {
        CONST_VTBL struct IFaxAttachmentsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxAttachments_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxAttachments_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxAttachments_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxAttachments_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxAttachments_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxAttachments_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxAttachments_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxAttachments_get__NewEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnk)

#define IFaxAttachments_get_Item(This,lIndex,pbstrAttachmentPath)	\
    (This)->lpVtbl -> get_Item(This,lIndex,pbstrAttachmentPath)

#define IFaxAttachments_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define IFaxAttachments_Add(This,bstrAttachmentPath)	\
    (This)->lpVtbl -> Add(This,bstrAttachmentPath)

#define IFaxAttachments_Remove(This,lIndex)	\
    (This)->lpVtbl -> Remove(This,lIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxAttachments_get__NewEnum_Proxy( 
    IFaxAttachments * This,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IFaxAttachments_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxAttachments_get_Item_Proxy( 
    IFaxAttachments * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ BSTR *pbstrAttachmentPath);


void __RPC_STUB IFaxAttachments_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IFaxAttachments_get_Count_Proxy( 
    IFaxAttachments * This,
    /* [retval][out] */ long *plCount);


voi