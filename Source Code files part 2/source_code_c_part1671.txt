e only with a Visual BASIC shell command
// DO NOT USE - USE TESTIT instead
// it is used only within BVTCOM.VBP (module: tiffcompare.bas)


int __cdecl main(int argc, char* argvA[])
{
    LPTSTR *argv;
	FILE *fp;
    int cbDifferentPixels;
	int iRetVal = EOF;

#ifdef UNICODE
    argv = CommandLineToArgvW( GetCommandLine(), &argc );
#else
    argv = argvA;
#endif

    if (4 != argc)
    {
        _tprintf(TEXT("Usage: %s <1st tiff> <2nd tiff> <bool: fSkipFirstLineOfSecondFile>\n"), argv[0]);
        _tprintf(TEXT("Example: %s c:\\sent.tif c:\\recv.tif 1\n"), argv[0]);
        _tprintf(TEXT("Example: %s c:\\sent.tif c:\\recv.tif 0\n"), argv[0]);
        _tprintf(TEXT("Example: %s c:\\sent1.tif c:\\sent2.tif 0\n"), argv[0]);
        return -1;
    }

    cbDifferentPixels = TiffCompare(argv[1], argv[2], _ttoi(argv[3]));
	
	fp=fopen("testit.out","w");
	if (NULL == fp)
	{
		_tprintf(TEXT("fopen(testit.out,w) failed with ec=0x08%X\n"), GetLastError());
        return -1;
	}
	fprintf (fp,"%d",cbDifferentPixels);
	iRetVal = fclose(fp);
	if (EOF == iRetVal)
	{
		_tprintf(TEXT("fclose(testit.out) failed with ec=0x08%X\n"), GetLastError());
        return -1;
	}

	return cbDifferentPixels;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\tapitools\tapidevice\tapidevice.cpp ===
//TapiDevice.cpp

#include <iostream.h>
#include <tapi3.h>
#include "Log.h"
#include <crtdbg.h>
#include <exception>
#include "TapiDevice.h"
#include "exception.h"
#include <atlconv.h>
#include <atlconv.cpp>



//
//STREAMING MACROS
//

//DATA (must be ANSI strings, send directly to comm port)
#define ANSWERER_DATA_STRING_1		"HELLO"
#define CALLER_DATA_STRING_1		"HELLO_SEEN"
#define ANSWERER_DATA_STRING_2		"MODEM_SYNC"


//VOICE
#define ANSWERER_VOICE_DTMF_1		TEXT("1")
#define CALLER_VOICE_DTMF_1			TEXT("2222")
#define ANSWERER_VOICE_DTMF_2		TEXT("3333")

#define DUMMY_ANSWERER_VOICE_DTMF	TEXT("*")




//
//TIMEOUTS MACROS
//
#define STREAMING_HANDSHAKE_TIMEOUT			(15000)
#define DATA_STREAMING_HANDSHAKE_TIMEOUT	STREAMING_HANDSHAKE_TIMEOUT	
#define VOICE_STREAMING_HANDSHAKE_TIMEOUT	STREAMING_HANDSHAKE_TIMEOUT	
#define FAX_STREAMING_HANDSHAKE_TIMEOUT		STREAMING_HANDSHAKE_TIMEOUT	

#define DUMMY_VOICE_STREAMING_HANDSHAKE_TIMEOUT		2000

#define CONNECT_RESPONSE_TIMEOUT	(30000)
#define MODEM_RESPONSE_TIMEOUT		(2000)
#define DELAY_BEFORE_SENDING_NEXT_MODEM_COMMAND	2000



//
//MODEM COMMANDS MACROS(must be ANSI strings, send directly to comm port)
//

//AT Commands
#define MODEM_INIT_AT__COMMAND					"ATZ\r\n"
#define MODEM_ECHO_OFF__AT_COMMAND				"ATE0\r\n"
#define MODEM_FAX_CLASS1_ENABLED__AT_COMMAND	"AT+FCLASS=1\r\n"
#define MODEM_DIAL_TONE__AT_COMMAND				"ATDT"
#define MODEM_ANSWER__AT_COMMAND				"ATA\r\n"
#define MODEM_HANGUP__AT_COMMAND				"ATH\r\n"


//Other Commands
#define MODEM_ESCAPE_SEQUENCE_COMMAND			"+++" 
#define VOICE_CALL_DISABLE						"AT#CLS=0\r\n"

//Modem responses
#define MODEM_RESPONSE_TO_AT_COMMANDS			"OK"
#define MODEM_RESPONSE_TO_CONNECT				"CONNECT"


#define MAX_DATA_RESPONSE						100
#define MAX_DTMF_RESPONSE						100



CTapiDevice::CTapiDevice(DWORD dwId):
	m_dwId(dwId),
	m_modemCommPortHandle(NULL),
	m_isFaxCall(false)
{
}

CTapiDevice::~CTapiDevice()
{
}




//*********************************************************************************
//* Name:	SendCallerVoiceStream
//* Author: Guy Merin / 14-oct-98
//*********************************************************************************
//* DESCRIPTION:
//*		SYNC with the remote modem using DTMF
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//* REMARKS:
//*		Voice streaming algorithem:
//*			Answerer sends a ANSWERER_VOICE_DTMF_1 digits
//*			Caller respondes with CALLER_VOICE_DTMF_1 digit
//*			Answerer replies to caller with ANSWERER_VOICE_DTMF_2 digit
//*********************************************************************************
void CTapiDevice::SendCallerVoiceStream()
{
	PrepareForStreaming(VOICE_STREAMING,CALLER_STREAMING);

	TCHAR DTMFresponse[MAX_DTMF_RESPONSE];
	
	TapiLogDetail(LOG_X, 8, TEXT("CTapiDevice::SendCallerVoiceStream(), Waiting for DUMMY DTMF(%s) or for ANSWERER_VOICE_DTMF_1(%s)"),DUMMY_ANSWERER_VOICE_DTMF,ANSWERER_VOICE_DTMF_1);
	receiveDTMF(DTMFresponse,1,VOICE_STREAMING_HANDSHAKE_TIMEOUT*2);
	TapiLogDetail(LOG_X, 8, TEXT("CTapiDevice::SendCallerVoiceStream(), Received %s"),DTMFresponse);

	if (_tcsnccmp(DTMFresponse,DUMMY_ANSWERER_VOICE_DTMF,1 ) == 0)
	{
		TapiLogDetail(LOG_X, 8, TEXT("CTapiDevice::SendCallerVoiceStream(), Waiting for ANSWERER_VOICE_DTMF_1(%s)"),ANSWERER_VOICE_DTMF_1);
		receiveDTMF(DTMFresponse,1,VOICE_STREAMING_HANDSHAKE_TIMEOUT);
		TapiLogDetail(LOG_X, 8, TEXT("CTapiDevice::SendCallerVoiceStream(), Received %s"),DTMFresponse);
	}
	
	if (_tcsnccmp(DTMFresponse,ANSWERER_VOICE_DTMF_1,1 ) != 0)
	{
		throw CException(
			TEXT("CTapiDevice::SendCallerVoiceStream(), voice SYNC failed, didn't receive %s digits string from answerer, receive the digits %s"),
			ANSWERER_VOICE_DTMF_1,
			DTMFresponse
			);
	}

	::Sleep(1000);
	TapiLogDetail(LOG_X, 8, TEXT("CTapiDevice::SendCallerVoiceStream(), Sending CALLER_VOICE_DTMF_1(%s)"),CALLER_VOICE_DTMF_1);
	sendDTMF(CALLER_VOICE_DTMF_1);

	DWORD dwNumberOfDigitsToCollect = (sizeof(ANSWERER_VOICE_DTMF_2) / sizeof(TCHAR) ) -1;
	
	TapiLogDetail(LOG_X, 8, TEXT("CTapiDevice::SendCallerVoiceStream(), Waiting for ANSWERER_VOICE_DTMF_2(%s)"),ANSWERER_VOICE_DTMF_2);
	receiveDTMF(DTMFresponse,dwNumberOfDigitsToCollect ,VOICE_STREAMING_HANDSHAKE_TIMEOUT);
	TapiLogDetail(LOG_X, 8, TEXT("CTapiDevice::SendCallerVoiceStream(), Received %s"),DTMFresponse);
	
	if (_tcsnccmp(DTMFresponse,ANSWERER_VOICE_DTMF_2,dwNumberOfDigitsToCollect ) != 0)
	{
		throw CException(
			TEXT("CTapiDevice::SendCallerVoiceStream(), voice SYNC failed, didn't receive %s digits string from answerer, receive the digits %s"),
			ANSWERER_VOICE_DTMF_2,
			DTMFresponse
			);
	}
	
}//CTapiDevice::SendCallerVoiceStream()


//*********************************************************************************
//* Name:	SendAnswerVoiceStream
//* Author: Guy Merin / 14-oct-98
//*********************************************************************************
//* DESCRIPTION:
//*		SYNC with the remote modem using DTMF
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//* REMARKS:
//*		Voice streaming algorithem:
//*			Answerer sends a ANSWERER_VOICE_DTMF_1 digits
//*			Caller respondes with CALLER_VOICE_DTMF_1 digit
//*			Answerer replies to caller with ANSWERER_VOICE_DTMF_2 digit
//*********************************************************************************
void CTapiDevice::SendAnswerVoiceStream()
{
	PrepareForStreaming(VOICE_STREAMING,ANSWERER_STREAMING);
	
	::Sleep(2000);

	TapiLogDetail(LOG_X, 8, TEXT("CTapiDevice::SendAnswerVoiceStream(), Sending DUMMY DTMF(%s)"),DUMMY_ANSWERER_VOICE_DTMF);

	sendDTMF(DUMMY_ANSWERER_VOICE_DTMF);
	
	::Sleep(10000);

	TapiLogDetail(LOG_X, 8, TEXT("CTapiDevice::SendAnswerVoiceStream(), Sending ANSWERER_VOICE_DTMF_1(%s)"),ANSWERER_VOICE_DTMF_1);
	sendDTMF(ANSWERER_VOICE_DTMF_1);

	TCHAR DTMFresponse[MAX_DTMF_RESPONSE];
	DWORD dwNumberOfDigitsToCollect = (sizeof(CALLER_VOICE_DTMF_1) / sizeof(TCHAR) ) -1;
	
	TapiLogDetail(LOG_X, 8, TEXT("CTapiDevice::SendAnswerVoiceStream(), Waiting for CALLER_VOICE_DTMF_1(%s)"),CALLER_VOICE_DTMF_1);
	receiveDTMF(DTMFresponse,dwNumberOfDigitsToCollect ,VOICE_STREAMING_HANDSHAKE_TIMEOUT);
	TapiLogDetail(LOG_X, 8, TEXT("CTapiDevice::SendAnswerVoiceStream(), Received %s"),DTMFresponse);
	
	if (_tcsnccmp(DTMFresponse,CALLER_VOICE_DTMF_1,dwNumberOfDigitsToCollect) != 0)
	{
		throw CException(
			TEXT("CTapiDevice::SendAnswerVoiceStream(), voice SYNC failed, didn't receive %s digits string from caller, receive the digits %s"),
			CALLER_VOICE_DTMF_1,
			DTMFresponse
			);
	}

	::Sleep(1000);
	TapiLogDetail(LOG_X, 8, TEXT("CTapiDevice::SendAnswerVoiceStream(), Sending ANSWERER_VOICE_DTMF_2(%s)"),ANSWERER_VOICE_DTMF_2);
	sendDTMF(ANSWERER_VOICE_DTMF_2);
	
}//CTapiDevice::SendAnswerVoiceStream()



//*********************************************************************************
//* Name:	SendCallerFaxStream
//* Author: Guy Merin / 14-oct-98
//*********************************************************************************
//* DESCRIPTION:
//*		NIY
//*********************************************************************************
void CTapiDevice::SendCallerFaxStream()
{
	PrepareForStreaming(FAX_STREAMING,CALLER_STREAMING);

	TapiLogDetail(LOG_X, 5, TEXT("CTapiDevice::SendCallerFaxStream(), NIY"));
	::Sleep(10000);
	
	//NIY
	return;
}//CTapiDevice::SendCallerFaxStream()



//*********************************************************************************
//* Name:	SendAnswerFaxStream
//* Author: Guy Merin / 14-oct-98
//*********************************************************************************
//* DESCRIPTION:
//*		NIY
//*********************************************************************************
void CTapiDevice::SendAnswerFaxStream()
{
	PrepareForStreaming(FAX_STREAMING,ANSWERER_STREAMING);
	
	TapiLogDetail(LOG_X, 5, TEXT("CTapiDevice::SendAnswerFaxStream(), NIY"));
	::Sleep(10000);
	
	//NIY
	return;
}//CTapiDevice::SendAnswerFaxStream()


//*********************************************************************************
//* Name:	SendCallerDataStream
//* Author: Guy Merin / 14-oct-98
//*********************************************************************************
//* DESCRIPTION:
//*		SYNC with the remote modem using a direct connection to the com port
//*		and using WriteFile()
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//* REMARKS:
//*		Data streaming algorithem:
//*			Answerer sends a ANSWERER_DATA_STRING_1 digits
//*			Caller respondes with CALLER_DATA_STRING_1 digit
//*			Answerer replies to caller with ANSWERER_DATA_STRING_2 digit
//*********************************************************************************
void CTapiDevice::SendCallerDataStream()
{
	PrepareForStreaming(DATA_STREAMING,CALLER_STREAMING);

	//
	//sleep for 5 sec to be sure the caller is already connected
	//
	::Sleep(5000);

	TapiLogDetail(LOG_X, 8, TEXT("CTapiDevice::SendCallerDataStream(), Waiting for ANSWERER_DATA_STRING_1"));
	WaitForModemResponse(ANSWERER_DATA_STRING_1,sizeof(ANSWERER_DATA_STRING_1),DATA_STREAMING_HANDSHAKE_TIMEOUT);
	
	TapiLogDetail(LOG_X, 8, TEXT("CTapiDevice::SendCallerDataStream(), Sending CALLER_DATA_STRING_1"));
	SendData(CALLER_DATA_STRING_1"\r\n");
	
	TapiLogDetail(LOG_X, 8, TEXT("CTapiDevice::SendCallerDataStream(), Waiting for ANSWERER_DATA_STRING_2"));
	WaitForModemResponse(ANSWERER_DATA_STRING_2,sizeof(ANSWERER_DATA_STRING_2),DATA_STREAMING_HANDSHAKE_TIMEOUT);
	
}//CTapiDevice::SendCallerDataStream()






//*********************************************************************************
//* Name:	SendAnswerDataStream
//* Author: Guy Merin / 14-oct-98
//*********************************************************************************
//* DESCRIPTION:
//*		SYNC with the remote modem using a direct connection to the com port
//*		and using WriteFile()
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//* REMARKS:
//*		Data streaming algorithem:
//*			Answerer sends a ANSWERER_DATA_STRING_1 digits
//*			Caller respondes with CALLER_DATA_STRING_1 digit
//*			Answerer replies to caller with ANSWERER_DATA_STRING_2 digit
//*********************************************************************************
void CTapiDevice::SendAnswerDataStream()
{
	PrepareForStreaming(DATA_STREAMING,ANSWERER_STREAMING);

	TapiLogDetail(LOG_X, 8, TEXT("CTapiDevice::SendAnswerDataStream(), Sending ANSWERER_DATA_STRING_1"));
	SendData(ANSWERER_DATA_STRING_1"\r\n");
	
	TapiLogDetail(LOG_X, 8, TEXT("CTapiDevice::SendAnswerDataStream(), Waiting for CALLER_DATA_STRING_1"));
	WaitForModemResponse(CALLER_DATA_STRING_1,sizeof(CALLER_DATA_STRING_1),DATA_STREAMING_HANDSHAKE_TIMEOUT);
	
	TapiLogDetail(LOG_X, 8, TEXT("CTapiDevice::SendAnswerDataStream(), Sending ANSWERER_DATA_STRING_2"));
	SendData(ANSWERER_DATA_STRING_2"\r\n");
	
}//CTapiDevice::SendAnswerDataStream()


//*********************************************************************************
//* Name:	SetOverlappedStruct
//* Author: Guy Merin / 08-Oct-98
//*********************************************************************************
//* DESCRIPTION:
//*		return an initialized overlapped structure
//* PARAMETERS:
//*		[OUT]	OVERLAPPED * const ol
//*					overlapped variable to be initilazed
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapiDevice::SetOverlappedStruct(OVERLAPPED * const ol)
{
    ol->OffsetHigh = ol->Offset = 0;
    ol->hEvent = CreateEvent (NULL, TRUE,  FALSE, NULL);
    if (NULL == ol->hEvent)
    {
        throw CException(
            TEXT("CTapiDevice::SetOverlappedStruct() : CreateEvent() failed with %d."),
            ::GetLastError()
            );
    }
}//CTapiDevice::SetOverlappedStruct


//*****************************************************************************
//* Name:	SynchReadFile
//* Author: Guy Merin/ 27-Sep-98
//*****************************************************************************
//* DESCRIPTION:
//*		Performs SYNCHRONOUS file read using overllaped IO.
//* PARAMETERS:
//*		[IN]	LPVOID lpBuffer:
//*					see documentation for Win32 WriteFile API
//*		[OUT]	DWORD nNumberOfBytesToWrite:
//*					see documentation for Win32 WriteFile API
//*		[IN]  	LPDWORD lpNumberOfBytesWritten:
//*					see documentation for Win32 WriteFile API
//*	RETURN VALUE:
//*		TRUE
//*			The write operation was successful
//*		FALSE
//*			The write operation failed
//*****************************************************************************
bool CTapiDevice::SynchReadFile(
	LPVOID lpBuffer,                
	DWORD nNumberOfBytesToRead,    
	LPDWORD lpNumberOfBytesRead
	) const
{

	OVERLAPPED ol_read;
	::ZeroMemory(&ol_read,sizeof(ol_read));
	SetOverlappedStruct(&ol_read);

	_ASSERT(m_modemCommPortHandle);
	_ASSERT(lpBuffer);
	_ASSERT(lpNumberOfBytesRead);

	if (!::ReadFile(
				m_modemCommPortHandle,
				lpBuffer,nNumberOfBytesToRead,
				lpNumberOfBytesRead,
				&ol_read
				))
	{
		if (ERROR_IO_PENDING == ::GetLastError())
		{
			//OVERLAPPED IO was started
			BOOL bRes;
			*lpNumberOfBytesRead=0;
			bRes = ::GetOverlappedResult(
						m_modemCommPortHandle,
						&ol_read,
						lpNumberOfBytesRead,
						TRUE
						);
			if (TRUE == bRes)
			{
				goto SynchReadFile_SUCCESS;
			}
			else
			{
				goto SynchReadFile_ERROR;
			}
		} 
		else
		{
			//Write operation failed
			goto SynchReadFile_ERROR;
		}
	} 
	else
	{
		//Read operation successful and was performed synchronously
		goto SynchReadFile_SUCCESS;
	}

SynchReadFile_SUCCESS:
	if ( !CloseHandle(ol_read.hEvent) )
	{
		throw CException(
			TEXT("%s(%d): CTapiDevice::SynchReadFile(), CloseHandle() failed, error code:%d"), 
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
	}
	return (true);

SynchReadFile_ERROR:
	if ( !CloseHandle(ol_read.hEvent) )
	{
		throw CException(
			TEXT("%s(%d): CTapiDevice::SynchReadFile(), CloseHandle() failed, error code:%d"), 
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
	}
	return (false);



}//CTapiDevice::SynchReadFile()



//*****************************************************************************
//* Name:	ReadResponse
//* Author: Guy Merin / 27-Sep-98
//*****************************************************************************
//* DESCRIPTION:
//*		Reads the next modem response.
//*		The function skips any CR or LF chars that perceed the response and 
//*		then reads into the result buffer all the chars up to the next (not 
//*		including the next CR or LF char).
//*		The function implies timeout constraints.
//*		If the first response char is not received within dwTimeOut a timeout
//*		error will be returned. 
//*		If while reading the next chars of the response a delay of more than
//*		150ms occurs a timeout error will be returned as well.
//*	
//* PARAMETERS:
//*		[OUT]	char * szResponse:
//*					A pointer to a buffer where the response string will be 
//*					placed. The string is always ANSI string.
//*		[IN]	int nResponseMaxSize:
//*					The total size of the response buffer.
//*		[OUT]	DWORD *pdwActualRead:
//*					The number of bytes that were read into the response
//*					buffer (not including terminating NULL char).
//*		[IN]	DWORD dwTimeOut:
//*					The number of milliseconds to wait for the first
//*					char of the response.
//*	RETURN VALUE:
//*		READRESPONSE_TIMEOUT: 
//*			If a timeout occurred waiting for the first response char or while
//*			reading the reminder of the response.
//*		READRESPONSE_SUCCESS:
//*			If the response was read succesffuly
//*		READRESPONSE_BUFFERFULL:
//*			If the provided buffer is too small for the response
//*		READRESPONSE_FAIL:
//*			If an error other then timeout occurred while reading the response
//*****************************************************************************
ReadResponseErros CTapiDevice::ReadResponse(
	char * szResponse, 
	int nResponseMaxSize,
	DWORD *pdwActualRead,
	DWORD dwTimeOut
	) const
{
	USES_CONVERSION;

	COMMTIMEOUTS to;
	char chNext;
	int nCharIdx;
	DWORD dwRead;
	
	_ASSERT(m_modemCommPortHandle);
	_ASSERT(szResponse);
	_ASSERT(pdwActualRead);

	::memset(szResponse,0,nResponseMaxSize);

	//Set the timeouts for the read operation.
	//Since we read 1 char at a time we use the TotalTimeoutMultiplier
	//To set the time we are willing to wait for the next char to show up.
	//We do not use the ReadIntervalTimeout and ReadTotalTimeoutConstants
	//since we read only 1 char at a time.
	//(see the documentation for COMMTIMEOUTS for a detailed description
	// of this mechanism).
	
	::GetCommTimeouts(m_modemCommPortHandle,&to);
	to.ReadIntervalTimeout=50; 
	to.ReadTotalTimeoutMultiplier=dwTimeOut;
	to.ReadTotalTimeoutConstant=0;
	::SetCommTimeouts(m_modemCommPortHandle,&to);


//	PurgeComm(hComm,PURGE_RXCLEAR);

	
	chNext=0;
	nCharIdx=0;
	*pdwActualRead=0;

	//Skip any CR or LF chars that might be left from the previous response.
		
	//read the next available input char. If it is #10 or #13 try reading another char.
	//otherwise get out of the loop and start processing the response (the char we just got
	//is the first char of the response).
	//If timeout is encountered or failure return the appropriate return code.
	do
	{
		if (!SynchReadFile(&chNext,1,&dwRead))
		{
			return READRESPONSE_FAIL;
		}
		if (!dwRead)
		{
			return READRESPONSE_TIMEOUT;
		}
	} while (chNext==10 || chNext==13);


	//Continue reading the actual response. 
	//The dwTimeout parameter specified how much time to wait for the 
	//start of the response. 
	//Once the first char of the response (past CR,LF) was read we go 
	//down to a usually lower timeout that will allow us to detect communication
	//errors sooner. (i.e. dwTimeOut will be 30 seconds after ATA but when reading the 
	//"CONNECT" response we do not want to use 30 seconds timeout between chars.)

	to.ReadIntervalTimeout=50;
	to.ReadTotalTimeoutMultiplier=0;
	to.ReadTotalTimeoutConstant=150; //this should be enough even for 300 bps DTE-DCE connection
	SetCommTimeouts(m_modemCommPortHandle,&to);
	//read all that response chars until the next #10 or #13
    do
	{
		//add the last read char to the response string
		szResponse[nCharIdx]=chNext;
		nCharIdx++;
		if (nCharIdx==nResponseMaxSize-1)
		{ //leave room for terminating NULL
			*pdwActualRead=nCharIdx;
			szResponse[nCharIdx]=0;
			return READRESPONSE_BUFFERFULL;
		}
		if (!SynchReadFile(&chNext,1,&dwRead))
		{
			return READRESPONSE_FAIL;
		}
		if (!dwRead)
		{
			return READRESPONSE_TIMEOUT;
		}
	}	while (chNext!=10 && chNext!=13);
	
	//response read successfully
	*pdwActualRead=nCharIdx;
	szResponse[nCharIdx]=0; //turn it into a null terminated string
	TapiLogDetail(LOG_X, 8, TEXT("Got a response from modem:%s"),A2T(szResponse));
	return READRESPONSE_SUCCESS;
}//CTapiDevice::ReadResponse



//*********************************************************************************
//* Name:	WaitForModemResponse
//* Author: Guy Merin / 09-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Wait for a specific response from the modem
//* PARAMETERS:
//*		[IN]  	LPCSTR szWantedResponse 
//*					response to wait for.
//*		[IN]	DWORD dwWantedResponseSize
//*					buffer size
//*		[IN]	const DWORD dwTimeout
//*					timeout in milliseconds 
//*	RETURN VALUE:
//*		NONE
//* REMARKS:
//*********************************************************************************
void CTapiDevice::WaitForModemResponse(LPCSTR szWantedResponse, DWORD dwWantedResponseSize, const DWORD dwTimeout) const
{
	USES_CONVERSION;
	TapiLogDetail(LOG_X, 8, TEXT("Waiting for response from modem:%s"),A2T(szWantedResponse));

	ReadResponseErros readResponseStatus = READRESPONSE_SUCCESS;
	char response[MAX_DATA_RESPONSE];
	::ZeroMemory(response,sizeof(response));
	DWORD pdwActualRead = 0;
	

	DWORD dwStartTickCount = GetTickCount();
	DWORD dwDiffernceTickCount = 0;
	
	DWORD dwReminingTimeout = dwTimeout;


	while(dwDiffernceTickCount <= dwTimeout)
	{
		readResponseStatus = ReadResponse(
			response, 
			MAX_DATA_RESPONSE,
			&pdwActualRead,
			(dwReminingTimeout)
			);

		switch (readResponseStatus)
		{
		
		case READRESPONSE_SUCCESS:
			if (strncmp(response,szWantedResponse,dwWantedResponseSize) == 0)
			{
				return;
			}
			else
			{
				//DWORD
				//recalculate the new timeout and continue
				//
				dwDiffernceTickCount = GetTickDiff(dwStartTickCount);
				dwReminingTimeout = dwTimeout - dwDiffernceTickCount;
				continue;
			}
		
		case READRESPONSE_FAIL:
			throw CException(TEXT("CTapiDevice::WaitForModemResponse(), ReadResponse() return FAIL"));
			break;
		
		case READRESPONSE_BUFFERFULL:
			throw CException(TEXT("CTapiDevice::WaitForModemResponse(), ReadResponse() BUFFER_FULL"));
			break;
		
		case READRESPONSE_TIMEOUT:
		{
			throw CException(
				TEXT("CTapiDevice::WaitForModemResponse(), TIMEOUT for receiveing %s"),
				A2T(szWantedResponse)
				);
			break;
		}

		default:
			throw CException(
				TEXT("CTapiDevice::WaitForModemResponse(), ReadResponse() return unknown error %d"),
				readResponseStatus
				);
		}//switch
	}//while



	//
	//TIMEOUT
	//
	if (response)
	{
		throw CException(
			TEXT("CTapiDevice::WaitForModemResponse(), timeout for receiving %s, received %s"),
			A2T(szWantedResponse),		//converted string
			A2T(response)				//converted string
			);
	}
	else
	{
		throw CException(
			TEXT("CTapiDevice::WaitForModemResponse(), timeout for receiving %s, received %s"),
			A2T(szWantedResponse)		//converted string
			);
	}
}



//*********************************************************************************
//* Name:	ClearCommInputBuffer
//* Author: Guy Merin / 09-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Clears the comm port TX(output) buffer
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//* REMARKS:
//*		Call this function to clear the buffer before waiting for a specific 
//*		response.
//*********************************************************************************
void CTapiDevice::ClearCommInputBuffer() const
{
	_ASSERT(NULL != m_modemCommPortHandle);

	if (!PurgeComm(
		m_modemCommPortHandle,	// handle to communications resource
		PURGE_RXCLEAR			// action to perform
		))
	{
		throw CException(
			TEXT("%s(%d): CTapiDevice::ClearCommInputBuffer(), PurgeComm() failed, error code:%d"), 
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
	}

}//void CTapiDevice::ClearCommInputBuffer()



//*********************************************************************************
//* Name:	ReadData
//* Author: Guy Merin / 05-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		read data stream from modem using the ReadResponse function
//* PARAMETERS:
//*		[IN]	char * szResponse
//*					buffer to read into
//*		[IN]	int nResponseMaxSize
//*					size of buffer
//*		[IN]	const DWORD dwTimeout
//*					timeout to wait for the read operation
//*	RETURN VALUE:
//*		NONE
//* REMARKS:
//*		this function is a wrapper function for ReadResponse()
//*********************************************************************************
void CTapiDevice::ReadData(char * szResponse,int nResponseMaxSize,const DWORD dwTimeout) const
{
	DWORD pdwActualRead = 0;

	ReadResponseErros readResponseStatus = ReadResponse(
		szResponse, 
		nResponseMaxSize,
		&pdwActualRead,
		dwTimeout
		);
	
	if (READRESPONSE_SUCCESS != readResponseStatus)
	{
		switch (readResponseStatus)
		{
		
		case READRESPONSE_SUCCESS:
			return;
		
		case READRESPONSE_FAIL:
			throw CException(TEXT("CTapiDevice::ReadData(), ReadResponse() returned FAIL"));
		
		case READRESPONSE_BUFFERFULL:
			throw CException(TEXT("CTapiDevice::ReadData(), ReadResponse() returned buffer full"));
		
		case READRESPONSE_TIMEOUT:
			throw CException(TEXT("CTapiDevice::ReadData(), ReadResponse() returned TIMEOUT"));
		}
	}	

}//void CTapiDevice::ReadData()



//*********************************************************************************
//* Name:	SendData
//* Author: Guy Merin / 24-Sep-98
//*********************************************************************************
//* DESCRIPTION:
//*		Writes the specified command to the provided port followed by a carriage
//*		return character.
//* PARAMETERS:
//*		[IN]  	SynchFileHandle * pSynchFile:
//*					Pointer to a SynchFileHandle that holds the comm port handle
//*					to which the command is to be sent.
//*		[IN] 	const char const *szCommand:
//*					The command to send.
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapiDevice::SendData(const char *szCommand) const
{
	_ASSERT(m_modemCommPortHandle);
	_ASSERT(szCommand);

	USES_CONVERSION;
	TapiLogDetail(LOG_X, 8, TEXT("Sending to modem:%s"),A2T(szCommand));

	OVERLAPPED ol_write;
	::ZeroMemory(&ol_write,sizeof(ol_write));
	SetOverlappedStruct(&ol_write);

	DWORD dwAct;
	int nCommandLen = strlen(szCommand);
	if (!::WriteFile(m_modemCommPortHandle,szCommand,nCommandLen,&dwAct,&ol_write))
	{
		DWORD dwLastError = ::GetLastError(); 
		if (ERROR_IO_PENDING == dwLastError)
		{
			//
			//OVERLAPPED IO was started
			//
			dwAct=0;
			BOOL bRes = ::GetOverlappedResult(m_modemCommPortHandle,&ol_write,&dwAct,TRUE);
			if (FALSE == bRes)
			{
				throw CException(TEXT("CTapiDevice::SendData(), GetOverlappedResult() failed"));
			}
		} 
		else
		{
			throw CException(TEXT("CTapiDevice::SendData(), WriteFile() failed, error code: %d"),dwLastError);
		}
	}
	if ( !CloseHandle(ol_write.hEvent) )
	{
		throw CException(
			TEXT("%s(%d): CTapiDevice::SendData(), CloseHandle() failed, error code:%d"), 
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
	}
}//CTapiDevice::SendData()



//*********************************************************************************
//* Name:	SendFaxCallAtCommands
//* Author: Guy Merin / 24-Sep-98
//*********************************************************************************
//* DESCRIPTION:
//*		send AT commands to the open comm port
//* PARAMETERS:
//*		[IN]  	LPCTSTR szNum
//*					destination address
//*	RETURN VALUE:
//*		NONE
//* REMARKS:
//*		the AT commands are:
//*			ATZ								-	modem reset
//*			AT+FCLASS=1						-	modem in fax class 1 protocol
//*			ATDT <destination address>		-	dial using tones to the dest. address
//*		the functions then waits for a CONNECT response.
//*		NOTE: this function does not wait for OK responses for the sent AT commands
//*********************************************************************************
void CTapiDevice::SendFaxCallAtCommands(LPCTSTR szNum) const
{
	USES_CONVERSION;

	_ASSERT(m_modemCommPortHandle);
	_ASSERT(m_isFaxCall);
	
	//
	//send modem init command and wait for response
	//
	ClearCommInputBuffer();
	SendData(MODEM_INIT_AT__COMMAND);
	WaitForModemResponse(MODEM_RESPONSE_TO_AT_COMMANDS,sizeof(MODEM_RESPONSE_TO_AT_COMMANDS),MODEM_RESPONSE_TIMEOUT);
	
	//
	//send echo off command and wait for response
	//echo is set to off so that every modem sent command wouldn't be queued at the
	// RX queue.
	//
	ClearCommInputBuffer();
	SendData(MODEM_ECHO_OFF__AT_COMMAND);
	WaitForModemResponse(MODEM_RESPONSE_TO_AT_COMMANDS,sizeof(MODEM_RESPONSE_TO_AT_COMMANDS),MODEM_RESPONSE_TIMEOUT);
	
	//
	//send fax class1 enabled command and wait for response
	//
	ClearCommInputBuffer();
	SendData(MODEM_FAX_CLASS1_ENABLED__AT_COMMAND);
	WaitForModemResponse(MODEM_RESPONSE_TO_AT_COMMANDS,sizeof(MODEM_RESPONSE_TO_AT_COMMANDS),MODEM_RESPONSE_TIMEOUT);
	
	//
	//dial the desired number and wait for connect response
	//
	
	//
	//prepare the atdt command in a string to be sent to the modem
	//
	char dialCommand[50];
	strcpy(dialCommand,MODEM_DIAL_TONE__AT_COMMAND);
	strcat(dialCommand," ");
	strcat(dialCommand,T2A(szNum));
	strcat(dialCommand,"\r\n");

	//
	//send the dial command
	//we don't wait for a connect response in this function
	//
	ClearCommInputBuffer();
	SendData(dialCommand);

}//CTapiDevice::SendFaxCallAtCommands



//*********************************************************************************
//* Name:	FaxCreateAndConnectCall
//* Author: Guy Merin / 24-Sep-98
//*********************************************************************************
//* DESCRIPTION:
//*		make an outgoing fax call to a given address, using only AT command
//*		and not using TAPI commands.
//* PARAMETERS:
//*		[IN]  	LPCTSTR szNum
//*					destination address
//*	RETURN VALUE:
//*		NONE
//* REMARKS:
//*		the function uses a handle to the comm port and reads and writes AT commands
//*********************************************************************************
void CTapiDevice::FaxCreateAndConnectCall(LPCTSTR szNum)
{
	_ASSERT(NULL == m_modemCommPortHandle);

	MoveToPassThroughMode();
	//
	//transfer to passthrough mode sucessded
	//get the handle to the comm port
	//
	SetCommPortHandleFromCallHandle();
	
	//
	//start sending AT commands to the port
	//
	SendFaxCallAtCommands(szNum);
	
}//CTapiDevice::FaxCreateAndConnectCall()



//*********************************************************************************
//* Name:	CloseCommPortHandle
//* Author: Guy Merin / 24-Sep-98
//*********************************************************************************
//* DESCRIPTION:
//*		closes the file handle and resets m_modemCommPortHandle handle.
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapiDevice::CloseCommPortHandle()
{
	if(NULL == m_modemCommPortHandle)
	{
		return;
	}

	if (!CloseHandle(m_modemCommPortHandle))
	{
		throw CException(
			TEXT("%s(%d): CTapiDevice::CloseCommPortHandle(): closeHandle failed with error %d \n"), 
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
	}
	m_modemCommPortHandle = NULL;
}//CTapiDevice::CloseCommPortHandle()


//*********************************************************************************
//* Name:	GetTickDiff
//* Author: Guy Merin / 25-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		calculates the differnce in miliseconds between now and dwStartTickTime
//* PARAMETERS:
//*		[IN]	const DWORD dwStartTickCount
//*					the start time to calculate the differnce from
//*	RETURN VALUE:
//*		differnce in miliseconds
//*	REMARKS:
//*		This function uses ::GetTickCount() and deals with possible wrap-around
//*********************************************************************************
DWORD CTapiDevice::GetTickDiff(const DWORD dwStartTickCount) 
{
	DWORD dwNowTickCount = ::GetTickCount();
	if (dwNowTickCount >= dwStartTickCount)
	{
		return (dwNowTickCount - dwStartTickCount);
	}
	else
	{
		return ( (0xffffffff - dwStartTickCount) + dwNowTickCount + 1);

	}

}//DWORD CTapiDevice::GetTickDiff()


//*********************************************************************************
//* Name:	Call
//* Author: Guy Merin / 25-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		sync call to a given number with a given media mode
//* PARAMETERS:
//*		[IN]	LPCTSTR szNum
//*				desired number to call to
//*		[IN]	const DWORD dwMedia
//*					media mode of the outgoing call
//*					has to be exactly 1 media mode
//*		[IN]	bool bSyncData
//*					flag to indicate if to perform media streaming
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapiDevice::Call(LPCTSTR szNum, const DWORD dwMedia, bool bSyncData)
{
	try
	{
		DWORD dwDeviceSpecificMediaMode = GetDeviceSpecificMediaMode(dwMedia);

		VerifyValidMediaModeForOutgoingCall(dwDeviceSpecificMediaMode);

		TapiLogDetail(LOG_X, 5,TEXT("MediaMode=0x%x Action=Call"),dwDeviceSpecificMediaMode);

		OpenLineForOutgoingCall(dwDeviceSpecificMediaMode);

		CreateAndConnectCall(szNum,dwDeviceSpecificMediaMode);

		WaitForCallerConnectState();

		if (bSyncData)
		{
			TapiLogDetail(LOG_X, 5, TEXT("Starting Media Streaming"));
			SendCallerStream();
			TapiLogDetail(LOG_X, 5, TEXT("Media Streaming Succeeded, modems CONNECTED"));
		}
	}
	catch(CException thrownException)
	{
		CleanUp();
		throw thrownException;
	}
}//void CTapiDevice::Call()




//*********************************************************************************
//* Name:	Answer
//* Author: Guy Merin / 25-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		sync call to a given number with a given media mode
//* PARAMETERS:
//*		[IN]	const DWORD dwMedia
//*					media mode of the outgoing call
//*					has to be exactly 1 media mode
//*		[IN]	bool bSyncData
//*					flag to indicate if to perform media streaming
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapiDevice::Answer(const DWORD dwMedia,const DWORD dwTimeOut,const bool bSyncData)
{
	try
	{
		DWORD dwDeviceSpecificMediaMode = GetDeviceSpecificMediaMode(dwMedia);

		VerifyValidMediaModeForIncomingCall(dwDeviceSpecificMediaMode);

		TapiLogDetail(LOG_X, 5,TEXT("MediaMode=0x%x Action=Answer"),dwDeviceSpecificMediaMode);

		OpenLineForIncomingCall(dwDeviceSpecificMediaMode);

		SetNewCallHandleErrors callHandleStatus = SetNewCallHandle(dwTimeOut);
			
		switch (callHandleStatus )
		{
		
		case NO_CALL:
			throw CException(TEXT("CTapi3Device::Answer(), Timeout for new call"));

		case IDLE_CALL:
			throw CException(TEXT("CTapi3Device::Answer(), new call is IDLE call"));
			break;

		case OFFERING_CALL:
			TapiLogDetail(LOG_X, 5, TEXT("New offering call received"));
			::Sleep(4000);
			AnswerOfferingCall();
			WaitForAnswererConnectState();
			break;

		case ACTIVE_CALL:
		{
			TapiLogDetail(LOG_X, 5, TEXT("New call is a handoff call"));
			
			//
			//check the call's media mode
			//
			DWORD dwCallSupportedMediaModes = GetCallSupportedMediaModes();
			if (dwDeviceSpecificMediaMode & dwCallSupportedMediaModes)
			{
				//SetCallMediaMode(dwDeviceSpecificMediaMode);
			}
			else
			{
			
				//
				//reject the call
				//
				HangUp();
				throw CException(
					TEXT("CTapi3Device::Answer(), UnSupported mediamode(%x) on new handoff call"),
					dwCallSupportedMediaModes);
			}
			break;
		}
		default:
			throw CException(TEXT("CTapi3Device::Answer(), UnSupported SetNewCallHandleErrors(%d) status"),callHandleStatus);

		}

		if (bSyncData)
		{
			TapiLogDetail(LOG_X, 5, TEXT("Starting Media Streaming"));
			SendAnswerStream();
			TapiLogDetail(LOG_X, 5, TEXT("Media Streaming Succeeded, modems CONNECTED"));
		}
	}
	catch(CException thrownException)
	{
		CleanUp();
		throw thrownException;
	}

}//void CTapiDevice::Answer()


void CTapiDevice::FaxAnswerOfferingCall()
{
	_ASSERT(m_modemCommPortHandle);
	_ASSERT(m_isFaxCall);

	
	//
	//send echo off command and wait for response
	//echo is set to off so that every modem sent command wouldn't be queued at the
	// RX queue.
	//
	ClearCommInputBuffer();
	SendData(MODEM_ECHO_OFF__AT_COMMAND);
	WaitForModemResponse(MODEM_RESPONSE_TO_AT_COMMANDS,sizeof(MODEM_RESPONSE_TO_AT_COMMANDS),MODEM_RESPONSE_TIMEOUT);
	
	//
	//send fax class1 enabled and wait for response
	//
	ClearCommInputBuffer();
	SendData(MODEM_FAX_CLASS1_ENABLED__AT_COMMAND);
	WaitForModemResponse(MODEM_RESPONSE_TO_AT_COMMANDS,sizeof(MODEM_RESPONSE_TO_AT_COMMANDS),MODEM_RESPONSE_TIMEOUT);
	//
	//answer the offering call
	//we don't wait for a connect response here
	//
	ClearCommInputBuffer();
	SendData(MODEM_ANSWER__AT_COMMAND);
}//void CTapiDevice::FaxAnswerOfferingCall()


void CTapiDevice::FaxWaitForConnect()
{
	_ASSERT(m_modemCommPortHandle);
	_ASSERT(m_isFaxCall);


	WaitForModemResponse(MODEM_RESPONSE_TO_CONNECT,sizeof(MODEM_RESPONSE_TO_CONNECT),CONNECT_RESPONSE_TIMEOUT);
	TapiLogDetail(LOG_X, 5, TEXT("Fax Call Connected"));
}//void CTapiDevice::FaxWaitForConnect()




void CTapiDevice::SendFaxHangUpCommands() const
{
	_ASSERT(m_modemCommPortHandle);
	_ASSERT(m_isFaxCall);


	SendData(MODEM_ESCAPE_SEQUENCE_COMMAND);	//move to modem command mode
	Sleep(DELAY_BEFORE_SENDING_NEXT_MODEM_COMMAND);
	SendData(MODEM_HANGUP__AT_COMMAND);
	Sleep(DELAY_BEFORE_SENDING_NEXT_MODEM_COMMAND);
	SendData(MODEM_INIT_AT__COMMAND);
	Sleep(DELAY_BEFORE_SENDING_NEXT_MODEM_COMMAND);

}//void CTapiDevice::SendFaxHangUpCommands()




//*********************************************************************************
//* Name:	CTapiDevice::DisableVoiceCall()
//* Author:	Guy Merin
//* Date:	December 31, 1998
//*********************************************************************************
//* DESCRIPTION:
//*
//* PARAMETERS:
//*		NONE
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapiDevice::DisableVoiceCall(void)
{

	//
	//disable voice call
	//
	ClearCommInputBuffer();
	SendData(VOICE_CALL_DISABLE);
	WaitForModemResponse(MODEM_RESPONSE_TO_AT_COMMANDS,sizeof(MODEM_RESPONSE_TO_AT_COMMANDS),MODEM_RESPONSE_TIMEOUT);

}//void CTapiDevice::DisableVoiceCall()



//*********************************************************************************
//* Name:	CTapiDevice::ChangeToFaxCall()
//* Author:	Guy Merin
//* Date:	December 31, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		Switch the current call to a fax call and simulate the caller or answerer
//*		of the fax call
//* PARAMETERS:
//*		[IN]	const FaxDirection eFaxDirection
//*			one of the following:
//*				FAX_CALLER
//*					simulate the caller side of the fax call
//*				FAX_ANSWERER
//*					simulate the answerer side of the fax call
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapiDevice::ChangeToFaxCall(const FaxDirection eFaxDirection)
{

	//
	//sleep for 5 sec to be sure the caller is already connected
	//
	::Sleep(5000);

	//
	//Get the current MediaMode
	//
	DWORD dwFriendlyMediaMode = GetFriendlyMediaMode();
	
	//
	//extract UnKnown media mode
	//
	dwFriendlyMediaMode = dwFriendlyMediaMode & ~MEDIAMODE_UNKNOWN;

	//
	//switch to fax call according to current media mode
	//
	switch (dwFriendlyMediaMode)
	{
	case MEDIAMODE_FAX:
		TapiLogDetail(
			LOG_X,
			8, 
			TEXT("CTapiDevice::ChangeToFaxCall(), call is already a fax call")
			);
		return;

	case MEDIAMODE_VOICE:
	case MEDIAMODE_AUTOMATED_VOICE:
	case MEDIAMODE_INTERACTIVE_VOICE:
		PrepareForStreaming(DATA_STREAMING,CALLER_STREAMING);
		DisableVoiceCall();
		break;
		
	case MEDIAMODE_DATA:
		PrepareForStreaming(DATA_STREAMING,CALLER_STREAMING);
		break;

	default:
		throw CException(
			TEXT("%s(%d): CTapiDevice::ChangeToFaxCall(), CTapiDevice::GetFriendlyMediaMode() returned unsupported media mode(%d)"), 
			TEXT(__FILE__),
			__LINE__,
			dwFriendlyMediaMode 
			);
	}
	m_isFaxCall = true;

	//
	//change to fax call
	//
	ClearCommInputBuffer();
	SendData(MODEM_FAX_CLASS1_ENABLED__AT_COMMAND);
	WaitForModemResponse(MODEM_RESPONSE_TO_AT_COMMANDS,sizeof(MODEM_RESPONSE_TO_AT_COMMANDS),MODEM_RESPONSE_TIMEOUT);

	//
	//connect the fax call
	//
	ClearCommInputBuffer();
	if (FAX_CALLER == eFaxDirection)
	{
		SendData(MODEM_DIAL_TONE__AT_COMMAND"\r\n");
		//
		//no response from modem after ATDT
		//
	}
	else if (FAX_ANSWERER == eFaxDirection)
	{
		SendData(MODEM_ANSWER__AT_COMMAND);

		//
		//The response should be CONNECT
		//
		WaitForModemResponse(MODEM_RESPONSE_TO_CONNECT,sizeof(MODEM_RESPONSE_TO_CONNECT),CONNECT_RESPONSE_TIMEOUT);
	}
	else
	{
		throw CException(
			TEXT("CTapiDevice::ChangeToFaxCall(), unsupported fax direction(%d)"),
			eFaxDirection
			);
	}
	

	
}//CTapiDevice::ChangeToFaxCall()





//*********************************************************************************
//* Name:	CTapiDevice::SetHighestPriorityApplication()
//* Author:	Guy Merin
//* Date:	January 11, 1999
//*********************************************************************************
//* DESCRIPTION:
//*		Set the current application as the highest priority application for
//*		a specific media mode
//* PARAMETERS:
//*		[IN]	const DWORD dwMedia
//*			a combination of abstract media mode types to set priority for
//*			possible values are:
//*				MEDIAMODE_UNKNOWN
//*				MEDIAMODE_VOICE
//*				MEDIAMODE_AUTOMATED_VOICE
//*				MEDIAMODE_INTERACTIVE_VOICE
//*				MEDIAMODE_DATA
//*				MEDIAMODE_FAX	
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapiDevice::SetHighestPriorityApplication(const DWORD dwMedia)
{
	SetApplicationPriorityForSpecificTapiDevice(
		GetDeviceSpecificMediaMode(dwMedia),
		1
		);
}//void CTapiDevice::SetHighestPriorityApplication(const DWORD dwMedia)



//*********************************************************************************
//* Name:	CTapiDevice::SetLowestPriorityApplication()
//* Author:	Guy Merin
//* Date:	January 11, 1999
//*********************************************************************************
//* DESCRIPTION:
//*		Set the current application as the lowest priority application for
//*		a specific media mode
//* PARAMETERS:
//*		[IN]	const DWORD dwMedia
//*			a combination of abstract media mode types to set priority for
//*			possible values are:
//*				MEDIAMODE_UNKNOWN
//*				MEDIAMODE_VOICE
//*				MEDIAMODE_AUTOMATED_VOICE
//*				MEDIAMODE_INTERACTIVE_VOICE
//*				MEDIAMODE_DATA
//*				MEDIAMODE_FAX	
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapiDevice::SetLowestPriorityApplication(const DWORD dwMedia)
{
	SetApplicationPriorityForSpecificTapiDevice(
		GetDeviceSpecificMediaMode(dwMedia),
		0
		);
}//void CTapiDevice::SetLowestPriorityApplication(const DWORD dwMedia)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\tapitools\tapidevice\tapidevice.h ===
//TapiDevice.h

#ifndef _TAPIDEVICE_H
#define _TAPIDEVICE_H

#include <windows.h>

#define APPLICATION_NAME_T			TEXT(APPLICATION_NAME_A)
#define APPLICATION_NAME_A			"TapiDevice.exe"

enum {MaxLogSize =		1024};

enum SetNewCallHandleErrors	{
								NO_CALL=0,
								ACTIVE_CALL,
								IDLE_CALL,
								OFFERING_CALL
							};


enum ReadResponseErros	{
						READRESPONSE_SUCCESS=0,
						READRESPONSE_FAIL,
						READRESPONSE_BUFFERFULL,
						READRESPONSE_TIMEOUT
						};


enum StreamingType	{
						VOICE_STREAMING =0,
						DATA_STREAMING,
						FAX_STREAMING
					};

enum StreamingDirection	{
							CALLER_STREAMING =0,
							ANSWERER_STREAMING
						};


#define	MEDIAMODE_UNKNOWN				0x00000002
#define	MEDIAMODE_VOICE					0x00000004
#define	MEDIAMODE_AUTOMATED_VOICE		0x00000008
#define	MEDIAMODE_INTERACTIVE_VOICE		0x00000010
#define	MEDIAMODE_DATA					0x00000020
#define	MEDIAMODE_FAX					0x00000040
//#define	MEDIAMODE_UNSUPPORTED		0x00000080


enum FaxDirection	{
						FAX_CALLER =0,
						FAX_ANSWERER
					};


class CTapiDevice
{
	
public:
	CTapiDevice(const DWORD dwId);
	virtual ~CTapiDevice(void);
	virtual void Call(
		LPCTSTR szNum, 
		const DWORD dwMedia,
		bool bSyncData = true
		);
	virtual void Answer(
		const DWORD dwMedia, 
		const DWORD dwTimeOut,
		const bool bSyncData = true
		);
	virtual void HangUp(void)=0;
	virtual void DirectHandoffCall(LPCTSTR szAppName)=0;
	virtual bool MediaHandoffCall(void)=0;

	void ChangeToFaxCall(const FaxDirection eFaxDirection);
	void SetHighestPriorityApplication(const DWORD dwMedia);
	void SetLowestPriorityApplication(const DWORD dwMedia);

	virtual HCALL GetTapi2CallHandle() {return NULL;};



//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////data members////////////////////////////////////////////////////////////
protected:
	DWORD m_dwId;
	HANDLE m_modemCommPortHandle;	//handle to the comm port (used in Pass Through mode)
	bool m_isFaxCall;

	

//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////Methods////////////////////////////////////////////////////////////

private:

/////////////////////////////////////////////////////////////////////////////////////
//COMM PORT functions

	//data
	void ReadData(char * szResponse,int nResponseMaxSize, const DWORD dwTimeout) const;
	void SendData(const char *szCommand) const;

	//
	// general COMM port functions:
	//
	static void SetOverlappedStruct(OVERLAPPED * const ol);
	void ClearCommInputBuffer(void) const;

	//read
	bool SynchReadFile(
		LPVOID lpBuffer,
		DWORD nNumberOfBytesToRead,
		LPDWORD lpNumberOfBytesRead
		) const;
	ReadResponseErros ReadResponse(
		char * szResponse,
		int nResponseMaxSize,
		DWORD *pdwActualRead,
		DWORD dwTimeOut
		) const;
	void WaitForModemResponse(
		LPCSTR szWantedResponse, 
		DWORD dwWantedResponseSize,
		const DWORD dwTimeout
		) const;


protected:

/////////////////////////////////////////////////////////////////////////////////////
//helper functions

	virtual void TapiLogDetail(
		DWORD dwLevel,
		DWORD dwSeverity,
		const TCHAR * const szLogDescription,
		...
		) const =0;
	virtual void TapiLogError(
		DWORD dwSeverity,
		const TCHAR * const szLogDescription,
		...
		) const =0;

	static DWORD GetTickDiff(const DWORD dwStartTickCount);

	virtual void CleanUp()=0;

/////////////////////////////////////////////////////////////////////////////////////
//streaming
	
	virtual void PrepareForStreaming(
		const StreamingType streamingType,
		const StreamingDirection streaminDirection
		) = 0;
	virtual void SendCallerStream(void)=0;
	virtual void SendAnswerStream(void)=0;

	//caller
	void SendCallerDataStream(void);
	void SendCallerVoiceStream(void);
	void SendCallerFaxStream(void);

	//answer
	void SendAnswerDataStream(void);
	void SendAnswerVoiceStream(void);
	void SendAnswerFaxStream(void); 
	
	//DTMF
	virtual void sendDTMF(LPCTSTR digitsToSend) const = 0;
	virtual void receiveDTMF(
		LPTSTR DTMFresponse,
		DWORD dwNumberOfDigitsToCollect,
		const DWORD dwTimeout
		) const = 0;
	

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//PASSTHROUGH 
	
	virtual void MoveToPassThroughMode(void)=0;
	virtual void SetBearerModeToPASSTHROUGH(void)=0;
	virtual void SetCommPortHandleFromCallHandle(void)=0;
	void CloseCommPortHandle(void);
	
	


/////////////////////////////////////////////
//CALL object functions

	virtual SetNewCallHandleErrors SetNewCallHandle(const DWORD dwTimeOut)=0;
	
	//call's media mode functions:
	virtual void VerifyValidMediaModeForOutgoingCall(const DWORD dwMediaMode) const=0;
	virtual void VerifyValidMediaModeForIncomingCall(const DWORD dwMediaMode) const=0;
	virtual void SetCallMediaMode(const DWORD dwMedia)=0;
	virtual DWORD GetCallSupportedMediaModes(void) const=0;

	//call control functions:
	virtual void CreateAndConnectCall(LPCTSTR szNum, const DWORD dwMedia)=0;
	virtual void AnswerOfferingCall(void)=0;
	virtual void WaitForCallerConnectState(void)=0;
	virtual void WaitForAnswererConnectState(void)=0;
	virtual DWORD GetFriendlyMediaMode(void) const=0;
	virtual DWORD GetDeviceSpecificMediaMode(const DWORD dwMedia)=0;
	
	

/////////////////////////////////////////////
//LINE object functions
	
	virtual void OpenLineForOutgoingCall(const DWORD dwMedia)=0;
	virtual void OpenLineForIncomingCall(const DWORD dwMedia)=0;

	

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//FAX

	//
	//FAX AT commands wrapper functions:
	//
	void SendFaxCallAtCommands(LPCTSTR szNum) const;
	void SendFaxHangUpCommands(void) const;
	

	//
	// Fax call control functions:
	//
	void FaxCreateAndConnectCall(LPCTSTR szNum);
	void FaxAnswerOfferingCall(void);
	void FaxWaitForConnect(void);

	void DisableVoiceCall(void);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Application priority
	void virtual SetApplicationPriorityForSpecificTapiDevice(const DWORD dwMedia,const DWORD dwPriority)=0;
	void virtual SetApplicationPriorityForOneMediaMode(const DWORD dwMediaMode,const DWORD dwPriority)=0;


};


#endif //#ifndef _TAPIDEVICE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\tifftools\testit\main.c ===
#include "..\TiffTools\TiffTools.h"

int __cdecl main(int argc, char* argvA[])
{
    LPTSTR *argv;
    int cbDifferentPixels;

#ifdef UNICODE
    argv = CommandLineToArgvW( GetCommandLine(), &argc );
#else
    argv = argvA;
#endif

    if (4 != argc)
    {
        _tprintf(TEXT("Usage: %s <1st tiff> <2nd tiff> <bool: fSkipFirstLineOfSecondFile>\n"), argv[0]);
        _tprintf(TEXT("Example: %s c:\\sent.tif c:\\recv.tif 1\n"), argv[0]);
        _tprintf(TEXT("Example: %s c:\\sent.tif c:\\recv.tif 0\n"), argv[0]);
        _tprintf(TEXT("Example: %s c:\\sent1.tif c:\\sent2.tif 0\n"), argv[0]);
        return -1;
    }

    cbDifferentPixels = TiffCompare(argv[1], argv[2], _ttoi(argv[3]));
    return cbDifferentPixels;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\tapitools\virtualmodem\main.cpp ===
//
// syntax:
// Medetect.exe com<number>
// example: Medetect.exe com169
//
// a simple test of usage for the CMedetectStub class
//

#include <windows.h>
#include <crtdbg.h>
#include "medetectstub.h"
#include "log.h"


int __cdecl main(int argc, char *argv[])
{
	int nRetval = -1;

	//
	// argv[1] must be "COM<number>"
	//
	if (2 != argc)
	{
		goto out;
	}

	::lgInitializeLogger();

	::lgBeginSuite(TEXT("suite1"));


	try
	{
		CMedetectStub stub(argv[1]);
		MessageBox(NULL, "Start Ringing", "MedetectStub", MB_OK);
		stub.StartRinging();
		
		//MessageBox(NULL, "Stop Ringing", "MedetectStub", MB_OK);
		//stub.StopRinging();

		MessageBox(NULL, "END", "MedetectStub", MB_OK);
	}
	catch(CException e)
	{
		lgLogError(LOG_SEV_1,e);
		_ASSERTE(FALSE);
	}
	catch(...)
	{
		::lgLogError(LOG_SEV_1,"UNKNOWN EXCEPTION");
		_ASSERTE(FALSE);
	}

	::lgEndSuite();

	::lgCloseLogger();

	nRetval = 0;

out:
	return nRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\tapitools\tapidevice\tapieventnotification.h ===
//TAPIEventNotification.h
#ifndef TAPI_EVENT_NOTIFICATION_H
#define TAPI_EVENT_NOTIFICATION_H

#include <tapi3if.h>


class CTapi3Device;

class CTAPIEventNotification : public ITTAPIEventNotification
{

public:
    //
    // Constructor.
    //
    
	CTAPIEventNotification(CTapi3Device *tapi3Device);

    //
    // Destructor.
    //
    virtual ~CTAPIEventNotification(void);


	//
    // IUnknown implementation.
    //

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject);
    
    ULONG STDMETHODCALLTYPE AddRef(void)
    {
        m_dwRefCount++;
        return m_dwRefCount;
    }
    
    ULONG STDMETHODCALLTYPE Release(void)
    {
        if (0 == --m_dwRefCount)
        {
            delete this;
            return 0;
        }
        
        return m_dwRefCount;
    }


	//
    // This is the only method in the ITTAPIEventNotification interface.
    //
    HRESULT STDMETHODCALLTYPE Event(
		TAPI_EVENT  tapiEvent,
		IDispatch  *pEvent
		);



private:
    DWORD           m_dwRefCount;
	CTapi3Device	*m_tapi3Object;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\tapitools\virtualmodem\medetectstub.cpp ===
#include <time.h>
#include <crtdbg.h>
#include <stdlib.h>
#include "MedetectStub.h"
#include "log.h"

#define MAX_RESPONSE_STRING_LENGTH	100
#define MAX_RECEIVE_STRING_LENGTH	100
#define MAX_KEY_SIZE				30

#define INI_FILE_NAME				".\\MedetectStub.ini"

#define DEFAULT_RESPONSE_STRING			""
#define DEFAULT_ACTION_STRING			""
#define DEFAULT_CONDITION_STRING		""
#define DEFAULT_REPEAT_STRING			"1"
#define DEFAULT_SLEEP_STRING			"0"

#define INI_WAIT_TILL_NEXT_RESPONSE_KEY		"Wait Till Next Response"					


#define RESPONSE_KEY_NAME			"Response"
#define CONDITION_KEY_NAME			"Condition"
#define ACTION_KEY_NAME				"Action"
#define REPEAT_KEY_NAME				"Repeat"
#define SLEEP_KEY_NAME				"Sleep"

#define INVALID_VALUE_CHAR			"~"


#define NO_CARRIER_MESSAGE			"NO CARRIER\r\n"



#define READ_INTERVAL_COMM_TIMOOUT				1000
#define READ_TOTAL_MULTIPLIER_COMM_TIMOOUT		1000
#define READ_TOTAL_CONSTANT_COMM_TIMOOUT		1000
#define WRITE_TOTAL_MULTIPLIER_COMM_TIMOOUT		1000
#define WRITE_TOTAL_CONSTANT_COMM_TIMOOUT		1000





//*********************************************************************************
//* Name:	CMedetectStub::CMedetectStub()
//* Author:	Guy Merin
//* Date:	December 30, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		CONSTRUCTOR
//* PARAMETERS:
//*		[IN]	const char *const szPort
//*			COM port to open
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
CMedetectStub::CMedetectStub(const char *const szPort):
	m_hPort(INVALID_HANDLE_VALUE),
	m_hWriteStringIteratorThread(NULL),
	m_fAbortWriteThread(false),
	m_fAbortReadThread(false),
	m_fFaxOn(false),
	m_fDetetctionOn(false)
{
	//
	// prepare the port name.
	// it should be in the format: \\.\COM<number>
	//
	if (4 > ::strlen(szPort))
	{
		throw CException("CMedetectStub::CMedetectStub() : (4 > strlen(szPort)");
	}

	if (6 < ::strlen(szPort))
	{
		throw CException("CMedetectStub::CMedetectStub() : (6 < strlen(szPort)");
	}

	if	( 
			('C' != ::toupper(szPort[0])) ||
			('O' != ::toupper(szPort[1])) ||
			('M' != ::toupper(szPort[2])) 
		)
	{
		throw CException("CMedetectStub::CMedetectStub() : szPort does not start with \"COM\"");
	}

	::strncpy(m_szPort, "\\\\.\\", 5);
	::strncat(m_szPort, szPort, sizeof(m_szPort) - 6);

	//
	// create the port
	//
	m_hPort = ::CreateFile(
		m_szPort,						// pointer to name of the file 
		GENERIC_READ | GENERIC_WRITE ,  // access (read-write) mode 
		0,								// share mode 
		NULL,							// pointer to security attributes 
		OPEN_EXISTING ,					// how to create 
		FILE_FLAG_OVERLAPPED ,			// file attributes 
		NULL 
		);
	if (INVALID_HANDLE_VALUE == m_hPort)
	{
		throw CException(
			"CMedetectStub::CMedetectStub(), ::CreateFile(%s) failed with %d.",
			m_szPort,
			::GetLastError()
			);
	}

	//
	// set port's properties
	//
	SetCommTimeouts(
        READ_INTERVAL_COMM_TIMOOUT,				// dwReadIntervalTimeout,
        READ_TOTAL_MULTIPLIER_COMM_TIMOOUT,		// dwReadTotalTimeoutMultiplier,
        READ_TOTAL_CONSTANT_COMM_TIMOOUT,		// dwReadTotalTimeoutConstant,
        WRITE_TOTAL_MULTIPLIER_COMM_TIMOOUT,	// dwWriteTotalTimeoutMultiplier,
        WRITE_TOTAL_CONSTANT_COMM_TIMOOUT		// dwWriteTotalTimeoutConstant
        );

	SetCommDCB();

	//
	// prepare read & write overlapped structure
	//
	SetOverlappedStruct(&m_olRead);

	SetOverlappedStruct(&m_olWrite);

	//
	// start the write thread
	//
	StartThread(&m_fAbortWriteThread, &m_hWriteThread, WriteThread);

	//
	// start the read thread
	//
	StartThread(&m_fAbortReadThread, &m_hReadThread, ReadThread);

	::srand((unsigned) ::time(NULL) );
}//CMedetectStub::CMedetectStub()





//*********************************************************************************
//* Name:	CMedetectStub::~CMedetectStub()
//* Author:	Guy Merin
//* Date:	December 30, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		Desructor
//* PARAMETERS:
//*		NONE
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
CMedetectStub::~CMedetectStub(void)
{
	::lgLogDetail(LOG_X, 9, "Entering CMedetectStub::~CMedetectStub()");
	AbortThread(&m_fAbortReadThread, &m_hReadThread);

	AbortThread(&m_fAbortWriteThread, &m_hWriteThread);

	if (INVALID_HANDLE_VALUE != m_hPort)
	{
		if (!::CloseHandle(m_hPort))
		{
			_ASSERTE(ERROR_SUCCESS == ::GetLastError());
		}
	}
	else
	{
		//
		// ctor should have thrown exception
		//
		_ASSERTE(INVALID_HANDLE_VALUE != m_hPort);
	}

	if (NULL != m_olRead.hEvent)
	{
		if (!::CloseHandle(m_olRead.hEvent))
		{
			_ASSERTE(!::GetLastError());
		}
	}
	else
	{
		//
		// ctor should have thrown exception
		//
		_ASSERTE(NULL != m_olRead.hEvent);
	}

	if (NULL != m_olWrite.hEvent)
	{
		if (!::CloseHandle(m_olWrite.hEvent))
		{
			_ASSERTE(!::GetLastError());
		}
	}
	else
	{
		//
		// ctor should have thrown exception
		//
		_ASSERTE(NULL != m_olWrite.hEvent);
	}

}//CMedetectStub::~CMedetectStub()



//*********************************************************************************
//* Name:	CMedetectStub::SetCommTimeouts()
//* Author:	Guy Merin
//* Date:	December 30, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		Set all the comm port timeouts using ::SetCommTimeouts()
//* PARAMETERS:
//*		[IN]	    const DWORD dwReadIntervalTimeout
//*		[IN]	    const DWORD dwReadTotalTimeoutMultiplier
//*		[IN]	    const DWORD dwReadTotalTimeoutConstant
//*		[IN]	    const DWORD dwWriteTotalTimeoutMultiplier
//*		[IN]	    const DWORD dwWriteTotalTimeoutConstant
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CMedetectStub::SetCommTimeouts(
    const DWORD dwReadIntervalTimeout,
    const DWORD dwReadTotalTimeoutMultiplier,
    const DWORD dwReadTotalTimeoutConstant,
    const DWORD dwWriteTotalTimeoutMultiplier,
    const DWORD dwWriteTotalTimeoutConstant
    ) const
{
    COMMTIMEOUTS ctmoSet;
    COMMTIMEOUTS ctmoGet;

    ctmoSet.ReadIntervalTimeout            = dwReadIntervalTimeout ;
    ctmoSet.ReadTotalTimeoutMultiplier     = dwReadTotalTimeoutMultiplier ;
    ctmoSet.ReadTotalTimeoutConstant       = dwReadTotalTimeoutConstant ;
    ctmoSet.WriteTotalTimeoutMultiplier    = dwWriteTotalTimeoutMultiplier ;
    ctmoSet.WriteTotalTimeoutConstant      = dwWriteTotalTimeoutConstant ;

    //
    //SetCommTimeouts 
    //
    if (!::SetCommTimeouts(m_hPort,&ctmoSet))
	{
        throw CException(
			"CMedetectStub::SetCommTimeouts(), ::SetCommTimeouts(m_hPort,&ctmoSet) failed with last error %d.",
            ::GetLastError()
            );
	}

    //
    //GetCommTimeouts
    //
    if (!::GetCommTimeouts(m_hPort,&ctmoGet))
	{
        throw CException(
            "CMedetectStub::SetCommTimeouts(): GetCommTimeouts(m_hPort,&ctmoGet) failed with last error %d.",
            ::GetLastError()
            );
	}

    //
    //compare the set TO to the get TO
    //
    if ((ctmoSet.ReadIntervalTimeout != ctmoGet.ReadIntervalTimeout) ||
        (ctmoSet.ReadTotalTimeoutMultiplier != ctmoGet.ReadTotalTimeoutMultiplier) ||
        (ctmoSet.ReadTotalTimeoutConstant != ctmoGet.ReadTotalTimeoutConstant) ||
        (ctmoSet.WriteTotalTimeoutMultiplier != ctmoGet.WriteTotalTimeoutMultiplier) ||
        (ctmoSet.WriteTotalTimeoutConstant != ctmoGet.WriteTotalTimeoutConstant)
        )
    {
        throw CException("CMedetectStub::SetCommTimeouts(): ctmoSet != ctmoGet.");
	}
}//CMedetectStub::SetCommTimeouts()





//*********************************************************************************
//* Name:	CMedetectStub::SetCommDCB()
//* Author:	Guy Merin
//* Date:	December 30, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		Set DCB parameters using ::SetCommState()
//* PARAMETERS:
//*		NONE
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CMedetectStub::SetCommDCB(void) 
{
	m_dcb.BaudRate         = CBR_19200;
	m_dcb.fBinary          = 1;
	m_dcb.fParity          = 0;
	m_dcb.fOutxCtsFlow     = 0;
	m_dcb.fOutxDsrFlow     = 0;
	m_dcb.fDtrControl      = DTR_CONTROL_ENABLE;
	m_dcb.fDsrSensitivity  = 0;
	m_dcb.fTXContinueOnXoff= 0;
	m_dcb.fOutX            = 0;
	m_dcb.fInX             = 0;
	m_dcb.fErrorChar       = 0;
	m_dcb.fNull            = 0;
	m_dcb.fRtsControl      = RTS_CONTROL_DISABLE;
	m_dcb.fAbortOnError    = 1;
	m_dcb.XonLim           = 10;
	m_dcb.XoffLim		   = 10;
	m_dcb.ByteSize         = 8;
	m_dcb.Parity           = NOPARITY;
	m_dcb.StopBits         = ONESTOPBIT;
	m_dcb.XonChar          = 0x1;
	m_dcb.XoffChar         = 0x2;
	m_dcb.ErrorChar        = 0x5;
	m_dcb.EofChar          = 0x3;
	m_dcb.EvtChar          = 0x4;

	
	if (!::SetCommState(m_hPort, &m_dcb))
    {
        throw CException(
			"CMedetectStub::SetCommDCB(): SetCommState() failed with %d.",
			::GetLastError()
			);
	}

	return;
}//CMedetectStub::SetCommDCB()






//*********************************************************************************
//* Name:	CMedetectStub::ChangeToCorrectBaudRate
//* Author:	Guy Merin
//* Date:	Thursday, December 24, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		Try to change the baud to the correct baud rate,
//* PARAMETERS:
//*		[IN]	const DWORD currentBaud
//*			the current baud rate to change
//* RETURN VALUE:
//*		NONE
//*	REMARK:
//*		If ClearCommError() returns CE_FRAME or CE_BREAK, the baud is changed again
//*********************************************************************************
void CMedetectStub::ChangeToCorrectBaudRate(const DWORD dwCurrentBaud)
{
	COMSTAT cmst;
	DWORD dwErrors;
	DWORD currentBaud = dwCurrentBaud;

	while(1)
	{
		switch (currentBaud)
		{
			case CBR_110:
				m_dcb.BaudRate = CBR_300;
				break;
			case CBR_300:
				m_dcb.BaudRate = CBR_600;
				break;
			case CBR_600:
				m_dcb.BaudRate = CBR_1200;
				break;
			case CBR_1200: 
				m_dcb.BaudRate = CBR_2400;
				break;
			case CBR_2400:
				m_dcb.BaudRate = CBR_4800;
				break;
			case CBR_4800:
				m_dcb.BaudRate = CBR_9600;
				break;
			case CBR_9600:
				m_dcb.BaudRate = CBR_14400;
				break;
			case CBR_14400:
				m_dcb.BaudRate = CBR_19200;
				break;
			case CBR_19200:
				m_dcb.BaudRate = CBR_38400;
				break;
			case CBR_38400:
				m_dcb.BaudRate = CBR_56000;
				break;
			case CBR_56000:
				m_dcb.BaudRate = CBR_57600;
				break;
			case CBR_57600:
				m_dcb.BaudRate = CBR_115200;
				break;
			case CBR_115200: 
				m_dcb.BaudRate = CBR_128000;
				break;
			case CBR_128000:
				m_dcb.BaudRate = CBR_256000;
				break;
			case CBR_256000:
				m_dcb.BaudRate = CBR_110;
				break;
		}
		
		currentBaud = m_dcb.BaudRate;
		if (!::SetCommState(m_hPort, &m_dcb))
		{
			if (!::ClearCommError(m_hPort, &dwErrors, &cmst))
			{
				::lgLogError(
					LOG_SEV_1,
					"CMedetectStub::ChangeToCorrectBaudRate(), ::ClearCommError() failed with %d",
					::GetLastError()
					);
				_ASSERTE(FALSE);
				::ExitProcess(::GetLastError());
			}
			if ( (CE_FRAME & dwErrors) || (CE_BREAK & dwErrors) )
			{
				continue;
			}
			else
			{
				::lgLogError(
					LOG_SEV_1,
					"CMedetectStub::ChangeToCorrectBaudRate(), ::ClearCommError() return error %x",
					dwErrors
					);
				_ASSERTE(FALSE);
				::ExitProcess(::GetLastError());
			}
		}

		if (!ClearCommError(m_hPort, &dwErrors, &cmst))
		{
			::lgLogError(
				LOG_SEV_1,
				"CMedetectStub::ChangeToCorrectBaudRate(), ::ClearCommError() failed with %d",
				::GetLastError()
				);
			_ASSERTE(FALSE);
			::ExitProcess(::GetLastError());
		}
		return;
	}
}//CMedetectStub::ChangeToCorrectBaudRate()





//*********************************************************************************
//* Name:	CMedetectStub::SetOverlappedStruct()
//* Author:	Guy Merin
//* Date:	Monday, December 28, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		Init the overlapped struct
//* PARAMETERS:
//*		[OUT]	OVERLAPPED * const ol
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CMedetectStub::SetOverlappedStruct(OVERLAPPED * const ol)
{
    ol->OffsetHigh = ol->Offset = 0;
    ol->hEvent = ::CreateEvent(NULL, TRUE,  FALSE, NULL);
    if (NULL == ol->hEvent)
    {
        throw CException(
            "CMedetectStub::SetOverlappedStruct() : CreateEvent() failed with %d.",
            ::GetLastError()
            );
    }
}//CMedetectStub::SetOverlappedStruct()




//*********************************************************************************
//* Name:	CMedetectStub::GetResponseFromINI()
//* Author:	Guy Merin
//* Date:	December 30, 1998
//*********************************************************************************
//* DESCRIPTION:
//*
//* PARAMETERS:
//*		[IN]		char *szSectionName
//*			Section to look for in INI
//*		[IN]		char *szKeyName
//*			Key to look for in INI
//*		[IN]		char *szDefaultResponseString
//*			Default value
//*		[OUT]		char *szResponseString
//*			the VALUE retrived from the INI	SECTION and KEY
//*		[IN]		DWORD dwResponseStringSize
//*			size of szResponseString buffer
//* RETURN VALUE:
//*		INI_SUCCESS
//*			Success in reading the INI
//*		INI_READ_ERROR
//*			read error from INI
//*		INI_ERROR_STRING_TO_SMALL
//*			szResponseString isn't big enough to contain the desired VALUE
//*		INI_OUT_OF_MEMORY
//*			new operating failed
//*********************************************************************************
iniStatus_t CMedetectStub::GetResponseFromINI(
	char *szSectionName,
	char *szKeyName,
	char *szDefaultResponseString,
	char *szResponseString,
	DWORD dwResponseStringSize
	)
{
	iniStatus_t eIniStatus = INI_SUCCESS;
	DWORD dwGetPrivateProfileStringStatus = 0;
	
	char * szIniString = new char[dwResponseStringSize];
	if (!szIniString)
	{
		eIniStatus = INI_OUT_OF_MEMORY;
		goto FUNC_OUT;
	}
	::ZeroMemory(szIniString,dwResponseStringSize);

	dwGetPrivateProfileStringStatus = ::GetPrivateProfileString(
		szSectionName,				// points to section name
		szKeyName,					// points to key name
		szDefaultResponseString,	// points to default string
		szIniString,				// points to destination buffer
		dwResponseStringSize,		// size of destination buffer
		INI_FILE_NAME				// points to initialization filename
		);
	
	if(dwGetPrivateProfileStringStatus == dwResponseStringSize - 1)
	{
		eIniStatus = INI_ERROR_STRING_TO_SMALL;
		goto FUNC_OUT;
	}

	::strcpy(szResponseString,szIniString);

FUNC_OUT:
	delete[] (szIniString);
	return(eIniStatus);		
}//CMedetectStub::GetResponseFromINI()





//*********************************************************************************
//* Name:	CMedetectStub::findReceivedStringInIniFile
//* Author:	Guy Merin
//* Date:	Monday, December 28, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		The function returns all the desired values from the INI,
//* PARAMETERS:
//*		[IN]	char *szSectionName
//*			Section to look for in INI
//*		[OUT]	char *szResponseString
//*			Response to sent
//*		[IN]	DWORD dwResponseStringSize
//*			Size of szResponseString buffer
//*		[OUT]	DWORD *cbWriteRepeat
//*			number of times to repeat the write opeartion
//*		[OUT]	DWORD *dwMaxTimeToSleepBetweenWrites
//*			Miliseconds to sleep between writes
//*		[IN]	DWORD keyNumber
//*			response number to look for
//*		[OUT]	DWORD *dwTimeToSleepBetweenResponses,
//*			miliseconds to sleep between differnt responses
//*		[OUT]	char *szResponseAction
//*			Action string
//*		[IN]	DWORD dwResponseActionSize
//*			size of szResponseAction buffer
//*		[OUT]	char *szResponseCondition
//*			Response string
//*		[IN]	DWORD dwResponseConditionSize
//*			size of szResponseCondition buffer
//* RETURN VALUE:
//*		INI_SUCCESS
//*			success
//*		INI_READ_ERROR
//*			error in reading INI
//*		INI_ERROR_STRING_TO_SMALL
//*			string size to small
//*		INI_MORE_DATA
//*			INI contains more data to be read, the function should be called again
//*		INI_OUT_OF_MEMORY
//*			out of memory
//*	REMARK:
//*		if the function returns INI_MORE_DATA, it should be called again to retrieve
//*		the rest of the parameters
//*********************************************************************************
iniStatus_t CMedetectStub::FindReceivedStringInIniFile(
	char *szSectionName,
	char *szResponseString,
	DWORD dwResponseStringSize,
	DWORD *cbWriteRepeat, 
	DWORD *dwMaxTimeToSleepBetweenWrites,
	DWORD dwKeyNumber,
	DWORD *dwTimeToSleepBetweenResponses,
	char *szResponseAction,
	DWORD dwResponseActionSize,
	char *szResponseCondition,
	DWORD dwResponseConditionSize
	)
{
	_ASSERT(NULL != szSectionName);
	_ASSERT(NULL != szResponseString);
	_ASSERT(NULL != szResponseAction);
	_ASSERT(NULL != szResponseString);
	_ASSERT(NULL != szResponseCondition);
	
	*cbWriteRepeat = 0;
	*dwMaxTimeToSleepBetweenWrites = 0;
	
	char szResponseKeyName[MAX_KEY_SIZE];
	char szActionKeyName[MAX_KEY_SIZE];
	char szConditionKeyName[MAX_KEY_SIZE];
	char szRepeatKeyName[MAX_KEY_SIZE];
	char szSleepKeyName[MAX_KEY_SIZE];
	char szNextKeyKeyName[MAX_KEY_SIZE];
	
	char szIniString[MAX_KEY_SIZE];
	
	InitKeyStringsForFindReceivedStringInIniFileFunction(
		dwKeyNumber,
		szResponseKeyName,
		szConditionKeyName,
		szActionKeyName,
		szRepeatKeyName,
		szSleepKeyName,
		szNextKeyKeyName
		);



	//
	//get the response string to be sent, default action string is DEFAULT_RESPONSE_STRING
	//
	iniStatus_t	eIniStatus = GetResponseFromINI(
		szSectionName,
		szResponseKeyName,
		DEFAULT_RESPONSE_STRING,
		szResponseString,
		dwResponseStringSize
		);
	
	if (INI_SUCCESS != eIniStatus)
	{
		return eIniStatus;
	}
	

	//
	//get the action string, default action string is "" (no action)
	//
	eIniStatus = GetResponseFromINI(
		szSectionName,
		szActionKeyName,
		DEFAULT_ACTION_STRING,
		szResponseAction,
		dwResponseActionSize
		);
	if (INI_SUCCESS != eIniStatus)
	{
		return eIniStatus;
	}

	//
	//get the condition string, default condition string is "" (no condition)
	//
	eIniStatus = GetResponseFromINI(
		szSectionName,
		szConditionKeyName,
		DEFAULT_CONDITION_STRING,
		szResponseCondition,
		dwResponseConditionSize
		);
	if (INI_SUCCESS != eIniStatus)
	{
		return eIniStatus;
	}
	
	//
	//get the number if times to repeat this response string, default is 1
	//
	eIniStatus = GetResponseFromINI(
		szSectionName,
		szRepeatKeyName,
		DEFAULT_REPEAT_STRING,
		szIniString,
		sizeof(szIniString)
		);
	if (INI_SUCCESS != eIniStatus)
	{
		return eIniStatus;
	}
	*cbWriteRepeat = atoi(szIniString);

	//
	//get the sleep between writes string, default is 0
	//
	eIniStatus = GetResponseFromINI(
		szSectionName,
		szSleepKeyName,
		DEFAULT_SLEEP_STRING,
		szIniString,
		sizeof(szIniString)
		);
	if (INI_SUCCESS != eIniStatus)
	{
		return eIniStatus;
	}
	*dwMaxTimeToSleepBetweenWrites = atoi(szIniString);

	//
	//get the number of milliseconds to sleep between different responses
	//
	eIniStatus = GetResponseFromINI(
		szSectionName,
		INI_WAIT_TILL_NEXT_RESPONSE_KEY,
		NULL,
		szIniString,
		sizeof(szIniString)
		);
	if (INI_SUCCESS != eIniStatus)
	{
		return eIniStatus;
	}
	*dwTimeToSleepBetweenResponses = atoi(szIniString);
	
	
	//
	//check if the INI contains another response string,
	//Note that the INI can't contain a string INVALID_VALUE_CHAR
	//
	eIniStatus = GetResponseFromINI(
		szSectionName,
		szNextKeyKeyName,
		INVALID_VALUE_CHAR,
		szIniString,
		sizeof(szIniString)
		);
	if (INI_SUCCESS != eIniStatus)
	{
		return eIniStatus;
	}
	if ( ::strcmp(szIniString,INVALID_VALUE_CHAR) != 0 )
	{
		return (INI_MORE_DATA);		// another response string is unread.
	}
	return(INI_SUCCESS);		
}//iniStatus_t CMedetectStub::findReceivedStringInIniFile()



//*********************************************************************************
//* Name:	CMedetectStub::initKeyStringsForFindReceivedStringInIniFileFunction()
//* Author:	Guy Merin
//* Date:	Monday, December 28, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		A helper function, that initializes all the 
//*		strings for FindReceivedStringInIniFile() function.
//* PARAMETERS:
//*		[IN]		DWORD keyNumber
//*			key number to append to each of the following strings
//*		[OUT]	char *szResponseKeyName,
//*		[OUT]	char *szConditionKeyName,
//*		[OUT]	char *szActionKeyName,
//*		[OUT]	char *szRepeatKeyName,
//*		[OUT]	char *szSleepKeyName,
//*		[OUT]	char *szNextKeyKeyName
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CMedetectStub::InitKeyStringsForFindReceivedStringInIniFileFunction(
	DWORD keyNumber,
	char *szResponseKeyName,
	char *szConditionKeyName,
	char *szActionKeyName,
	char *szRepeatKeyName,
	char *szSleepKeyName,
	char *szNextKeyKeyName
	)
{

	char szBuffer[10];
	::itoa(keyNumber,szBuffer,10);

	//
	//build the desired 'Response' INI key
	//
	::strcpy(szResponseKeyName,RESPONSE_KEY_NAME);
	::strcat(szResponseKeyName,szBuffer);

	//
	//build the desired 'Condition' INI key
	//
	::strcpy(szConditionKeyName,CONDITION_KEY_NAME);
	::strcat(szConditionKeyName,szBuffer);
	
	//
	//build the desired 'Action' INI key
	//
	::strcpy(szActionKeyName,ACTION_KEY_NAME);
	::strcat(szActionKeyName,szBuffer);
	
	//
	//build the desired 'Repeat' INI key
	//
	::strcpy(szRepeatKeyName,REPEAT_KEY_NAME);
	::strcat(szRepeatKeyName,szBuffer);
	
	//
	//build the desired 'Sleep' INI key
	//
	::strcpy(szSleepKeyName,SLEEP_KEY_NAME);
	::strcat(szSleepKeyName,szBuffer);

	::itoa(keyNumber+1,szBuffer,10);
	::strcpy(szNextKeyKeyName,RESPONSE_KEY_NAME);
	::strcat(szNextKeyKeyName,szBuffer);		//szNextKeyKeyName is now the next response string key number.

}//CMedetectStub::initKeyStringsForFindReceivedStringInIniFileFunction()



//*********************************************************************************
//* Name:	CMedetectStub::writeResponseString()
//* Author:	Guy Merin
//* Date:	Monday, December 28, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		This function gets as a parameter the received string and writes the response string
//*		according to speceific INI conditions and actions.
//* PARAMETERS:
//*		[IN]	char *szSectionName
//*			Recieved string from comm port
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CMedetectStub::WriteResponseString(char *szSectionName)
{
	DWORD dwTimeToSleepBetweenResponses = 0;
	DWORD cbWriteRepeat = 1;
	DWORD dwMaxTimeToSleepBetweenWrites = 0;
	DWORD keyNumberIndex = 1;
	char szResponseString[MAX_RESPONSE_STRING_LENGTH + 2];
	char szResponseAction[MAX_RESPONSE_STRING_LENGTH];
	char szResponseCondition[MAX_RESPONSE_STRING_LENGTH];
	iniStatus_t eFindReceivedStringInIniFileStatus = INI_MORE_DATA;

	::ZeroMemory(szResponseString,MAX_RESPONSE_STRING_LENGTH + 2);
	
	//
	//echo the response strings
	//
	::lgLogDetail(LOG_X, 2, "Received string:\t <%s>",szSectionName);

	//
	//loop till all the response string are retrieved from the INI file
	//
	while (INI_MORE_DATA == eFindReceivedStringInIniFileStatus)
	{
		::Sleep(dwTimeToSleepBetweenResponses);
	
		//
		//get the response string according to the received string (from the INI)
		//
		eFindReceivedStringInIniFileStatus = FindReceivedStringInIniFile(
			szSectionName,					//INI section name is the received string.
			szResponseString,				//buffer for the response string.
			MAX_RESPONSE_STRING_LENGTH,		//buffer size.
			&cbWriteRepeat,					//the number of times to repeat the szResponseString.
			&dwMaxTimeToSleepBetweenWrites,	//mili seconds to sleep between repeats.
			keyNumberIndex,					//response number.
			&dwTimeToSleepBetweenResponses,	//sleep between responses.
			szResponseAction,				//desired action buffer
			30,								//desired action buffer size.
			szResponseCondition,			//condition for response and action buffer
			30								//condition buffer size.
			);
		if (INI_READ_ERROR == eFindReceivedStringInIniFileStatus)
		{
			//
			//read from INI failed, szResponseString will be the default response string
			//
			::strcpy(szResponseString,DEFAULT_RESPONSE_STRING);
		}

		if (INI_ERROR_STRING_TO_SMALL == eFindReceivedStringInIniFileStatus)
		{
			throw CException("CMedetectStub::writeResponseString(), CMedetectStub::findReceivedStringInIniFile() return INI_ERROR_STRING_TO_SMALL");
		}
		if (INI_OUT_OF_MEMORY == eFindReceivedStringInIniFileStatus)
		{
			throw CException("CMedetectStub::writeResponseString(), CMedetectStub::findReceivedStringInIniFile() return INI_OUT_OF_MEMORY");
		}

		//
		//Check if the response condition is met.
		//
		if	(
				!IsConditionExist(szResponseCondition) || 
				(TRUE == CheckCondition(szResponseCondition))
			)
		{
		
			//
			//write response string to port
			//
			char szLineFeedResponseString[MAX_RESPONSE_STRING_LENGTH+20];
			::sprintf(szLineFeedResponseString, "\r\n%s\r\n", szResponseString);
			WriteString(szLineFeedResponseString,cbWriteRepeat,dwMaxTimeToSleepBetweenWrites);
			
			//
			//Check if a desired action is required
			//
			if (IsActionExist(szResponseAction))
			{
				ExecuteResponseAction(szResponseAction);
			}
		}

		//
		//increase this index and continue the while loop for getting the next response string
		//
		keyNumberIndex++;
	}
}//CMedetectStub::writeResponseString()




//*********************************************************************************
//* Name:	CMedetectStub::IsActionExist()
//* Author:	Guy Merin
//* Date:	December 30, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		Checks that the given action isn't empty
//* PARAMETERS:
//*		[IN]	const char * const szResponseAction
//*			The action to check
//* RETURN VALUE:
//*		true
//*			non empty action
//*		false
//*			empty action
//*********************************************************************************
bool CMedetectStub::IsActionExist(const char * const szResponseAction)
{
	if (NULL == szResponseAction)
	{
		return false;
	}
	return (::strcmp(szResponseAction,"") != 0);
}//CMedetectStub::IsActionExist()




//*********************************************************************************
//* Name:	CMedetectStub::IsConditionExist()
//* Author:	Guy Merin
//* Date:	December 30, 1998
//*********************************************************************************
//* DESCRIPTION:
//*			Checks that the given condition isn't empty
//* PARAMETERS:
//*		[IN]	const char * const szResponseCondition
//*			condition to check
//* RETURN VALUE:
//*		true
//*			non empty condition
//*		false
//*			empty condition
//*********************************************************************************
bool CMedetectStub::IsConditionExist(const char * const szResponseCondition)
{
	if (NULL == szResponseCondition)
	{
		return false;
	}
	return (::strcmp(szResponseCondition,"") != 0);
}//bool CMedetectStub::IsConditionExist()





//*********************************************************************************
//* Name:	CMedetectStub::CheckCondition()
//* Author:	Guy Merin
//* Date:	December 30, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		Check if a certain condition is met
//* PARAMETERS:
//*		[IN]	char *szResponseCondition
//*			condition string to check
//* RETURN VALUE:
//*		true
//*			condition met	
//*		false
//*			condition isn't met
//*********************************************************************************
bool CMedetectStub::CheckCondition(char *szResponseCondition)
{
	if(!IsConditionExist(szResponseCondition))
	{
		return (TRUE);
	}

	//
	//Fax and Media detection on
	//
	if (::strcmp(szResponseCondition,"FAX_ON*DETECTION_ON") == 0)
	{
		::lgLogDetail(LOG_X,5,"CONDITION:\t\t FAX_ON and DETECTION_ON");
		return ( (TRUE == m_fFaxOn) && (TRUE == m_fDetetctionOn) );
	}

	//
	//Fax or Media detection on
	//
	if (::strcmp(szResponseCondition,"FAX_ON+DETECTION_ON") == 0)
	{
		::lgLogDetail(LOG_X,5,"CONDITION:\t\t FAX_ON or DETECTION_ON");
		return ( (TRUE == m_fFaxOn) || (TRUE == m_fDetetctionOn) );
	}

	//
	//Fax On / Off
	//
	if (::strcmp(szResponseCondition,"FAX_ON") == 0)
	{
		::lgLogDetail(LOG_X,5,"CONDITION:\t\t FAX_ON");
		return (TRUE == m_fFaxOn);
	}

	if (::strcmp(szResponseCondition,"FAX_OFF") == 0)
	{
		::lgLogDetail(LOG_X,5,"CONDITION:\t\t FAX_OFF");
		return (FALSE == m_fFaxOn);
	}

	//
	//Media detection On / Off
	//
	if (::strcmp(szResponseCondition,"DETECTION_ON") == 0)
	{
		::lgLogDetail(LOG_X,5,"CONDITION:\t\t DETECTION_ON");
		return (TRUE == m_fDetetctionOn);
	}

	if (::strcmp(szResponseCondition,"DETECTION_OFF") == 0)
	{
		::lgLogDetail(LOG_X,5,"CONDITION:\t\t DETECTION_OFF");
		return (FALSE == m_fDetetctionOn);
	}

	::lgLogError(LOG_SEV_1,"CheckCondition() unknown Condition");
	return (FALSE);
}//CMedetectStub::CheckCondition()



//*********************************************************************************
//* Name:	CMedetectStub::ExecuteResponseAction()
//* Author:	Guy Merin
//* Date:	December 30, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		Execute an action (HANGUP, STOP RINGING etc)
//* PARAMETERS:
//*		[IN]	char *szResponseAction
//*			Action to Execute, one of the following values:
//*				HANGUP
//*				STOP RINGING
//*				START RINGING
//*				FAX_ON
//*				FAX_OFF
//*				DETECTION_ON
//*				DETECTION_OFF
//* RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		To add new actions to the INI, we need to implement the action in this function
//*********************************************************************************
void CMedetectStub::ExecuteResponseAction(char *szResponseAction)
{

	if (::strcmp(szResponseAction,"") == 0)
	{
		return;
	}

	//
	//HANGUP
	//
	if (::strcmp(szResponseAction,"HANGUP") == 0)
	{
		DropDtr();
		WriteOneString(NO_CARRIER_MESSAGE);
		::lgLogDetail(LOG_X,5,"ACTION:\t\t Hangup");
		return;
	}

	//
	//START / STOP RINGING
	//
	if (::strcmp(szResponseAction,"STOP RINGING") == 0)
	{
		::lgLogDetail(LOG_X,5,"ACTION:\t\t Stop Ringing");
		StopRinging();
		return;
	}

	if (::strcmp(szResponseAction,"START RINGING") == 0)
	{
		::lgLogDetail(LOG_X,5,"ACTION:\t\t Start Ringing");
		StartRinging();
		return;
	}

	//
	//Fax On / Off
	//
	if (::strcmp(szResponseAction,"FAX_ON") == 0)
	{
		::lgLogDetail(LOG_X,5,"ACTION:\t\t Fax Enabled");
		m_fFaxOn = true;
		return;
	}

	if (::strcmp(szResponseAction,"FAX_OFF") == 0)
	{
		::lgLogDetail(LOG_X,5,"ACTION:\t\t Fax Disabled");
		m_fFaxOn = false;
		return;
	}

	//
	//Media detection On / Off
	//
	if (::strcmp(szResponseAction,"DETECTION_ON") == 0)
	{
		::lgLogDetail(LOG_X,5,"ACTION:\t\t Media Detection Enabled");
		m_fDetetctionOn = true;
		return;
	}

	if (::strcmp(szResponseAction,"DETECTION_OFF") == 0)
	{
		::lgLogDetail(LOG_X,5,"ACTION:\t\t Media Detection Disabled");
		m_fDetetctionOn = false;
		return;
	}
	::lgLogError(LOG_SEV_1,"Unknown Action");
}//CMedetectStub::ExecuteResponseAction()



//*********************************************************************************
//* Name:	ReadThread()
//* Author:	Guy Merin
//* Date:	December 30, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		The Read thread.
//*		This thread reads a character at a time and pushes them in the Q
//* PARAMETERS:
//*		[IN]	void *pVoid
//*			pointer to CMedetectStub object as a void*
//* RETURN VALUE:
//*		thread exit code
//*********************************************************************************
DWORD WINAPI ReadThread(void *pVoid)
{
	::lgLogDetail(LOG_X, 9, "::ReadThread() entering");
	_ASSERTE(pVoid);
	
	CMedetectStub *pThis = (CMedetectStub*)pVoid;
	char acRead[MAX_RECEIVE_STRING_LENGTH];
	char szSectionName[MAX_RECEIVE_STRING_LENGTH];
	int nextSectionNameIndex = 0;

	for (int iChar = 0; iChar < MAX_RECEIVE_STRING_LENGTH; iChar++)
	{
		acRead[iChar] = 'x';
		szSectionName[iChar] = '\0';
	}

	char cRead;
	char cPrevRead = 'x'; //not \r
	char cPrevPrevRead = 'x'; //not \r

	DWORD dwCaseNumber = 1;
	char szCaseName[2*MAX_KEY_SIZE];


	while(!pThis->m_fAbortReadThread)
	{
		if (!::ReadFile(
				pThis->m_hPort,
				&cRead,
				1,
				&pThis->m_cbRead,
				&pThis->m_olRead
				)
			)
		{
			//
			//::ReadFile() failed because of read error or aysnc read(ERROR_IO_PENDING)
			//
			DWORD dwLastError = ::GetLastError();
			if (ERROR_IO_PENDING != dwLastError)
			{
				::lgLogError(
					LOG_SEV_1,
					"::ReadThread(), ::ReadFile() failed with %d, ASSERTING",
					::GetLastError()
					);
				_ASSERTE(FALSE);
				::ExitProcess(dwLastError);
			}

			//
			//check if async read succeed
			//
            if (!::GetOverlappedResult (
					pThis->m_hPort, 
					&pThis->m_olRead, 
					&pThis->m_cbRead, 
					TRUE)
				) 
			{
				DWORD dwLastError = ::GetLastError();
				::lgLogError(
					LOG_SEV_1,
					"::ReadThread(), ::GetOverlappedResult() failed with %d",
					::GetLastError()
					);
				
				//
				// since the fAbortOnError DCB member is TRUE, then if baud is changed, errors
				// will occur, and the operation will be aborted.
				// this is heuristic.
				//
				if (ERROR_OPERATION_ABORTED != dwLastError)
				{
					::lgLogError(
						LOG_SEV_1,
						"ReadThread(): GetOverlappedResult() failed with %d",
						::GetLastError()
						);
					_ASSERTE(FALSE);
					::ExitProcess(::GetLastError());
				}

				
				//
				//Operation was aborted, maybe baud is wrong?
				//
				COMSTAT cmst;
				DWORD dwErrors;
				if (!::ClearCommError(pThis->m_hPort, &dwErrors, &cmst))
				{
					::lgLogError(
						LOG_SEV_1,
						"::ReadThread(), ::ClearCommError() failed with %d",
						::GetLastError()
						);
					_ASSERTE(FALSE);
					::ExitProcess(::GetLastError());
				}
				::lgLogDetail(LOG_X, 5, "::ReadThread(), dwErrors=0x%08X", dwErrors);
				
				//
				//try setting another baud rate
				//
				pThis->ChangeToCorrectBaudRate(pThis->m_dcb.BaudRate);
				
				continue;
			}
		}//if (!::ReadFile(

		//
		// Read was sync, or overlapped succeeded
		//
		if (1 > pThis->m_cbRead)
		{
			//
			// nothing was read, so read was time-out
			//
			continue;
		}

		//
		// 1 char was read
		//
		
		for (iChar = 0; iChar < MAX_RECEIVE_STRING_LENGTH - 1; iChar++)
		{
			acRead[iChar] = acRead[iChar+1];
		}
		acRead[MAX_RECEIVE_STRING_LENGTH-1] = cRead;
		
		if ( ('\r' == cRead) || ('\n' == cRead) )
		{
			//
			//Write back the response according to the received string
			//

			//
			//prepare the string for the viewport
			//
			szSectionName[nextSectionNameIndex++] = '\0';
			::strcpy(szCaseName,"Case command: ");
			::strcat(szCaseName,szSectionName);
			::strcat(szCaseName,"\0");
			::lgBeginCase(dwCaseNumber++, szCaseName);
			
			//
			//Write the response string
			//
			pThis->WriteResponseString(szSectionName);

			::lgEndCase();
			nextSectionNameIndex = 0;		//reset the buffer for the next string
		}
		else
		{
			szSectionName[nextSectionNameIndex++] = cRead;
		}
		if (MAX_RECEIVE_STRING_LENGTH - 1 == nextSectionNameIndex)
		{
			::lgLogError(LOG_SEV_1,"::ReadThread(), Received string exceed MAX buffer size");
 			_ASSERTE(FALSE);
			::ExitProcess(::GetLastError());
		}
		

		cPrevPrevRead = cPrevRead;
		cPrevRead = cRead;

		
		
		//
		//echo the recieved string in char format and in hex format
		//
		::lgLogDetail(LOG_X, 9, "char = %c \t hex = 0x%08x",cRead,(UCHAR)cRead);

		//
		// make sure we print \r\n for newline
		//
		if ( ('\r' == cPrevRead) && ('\n' != cRead) )
		{
			pThis->m_readQ.Queue('\n');
		}
		else if ( ('\n' == cPrevRead) && ('\r' != cRead) )
		{
			pThis->m_readQ.Queue('\r');
		}
		else
		{
			;
		}

		pThis->m_readQ.Queue(cRead);
	}//while(!pThis->m_fAbortReadThread)

	::lgLogDetail(LOG_X, 9, "::ReadThread() exiting");
	return ERROR_SUCCESS;
}//ReadThread




//*********************************************************************************
//* Name:	WriteThread()
//* Author:	Guy Merin
//* Date:	December 30, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		The Write thread.
//*		This thread reads a character from the queue and sends it to the COMM port
//*		using ::WriteFile()
//* PARAMETERS:
//*		[IN]	void *pVoid
//*			pointer to CMedetectStub object as a void*
//* RETURN VALUE:
//*		thread exit code
//*********************************************************************************
DWORD WINAPI WriteThread(void *pVoid)
{
	::lgLogDetail(LOG_X, 9, "::WriteThread() entering");
	_ASSERTE(pVoid);
	
	CMedetectStub *pThis = (CMedetectStub*)pVoid;
	char cToWrite;

	while(!pThis->m_fAbortWriteThread)
	{
		if (!pThis->m_WriteQ.SyncDeQueue(cToWrite,100)) 
		{
			continue;
		}

		if (!::WriteFile(
				pThis->m_hPort,
				&cToWrite,
				1,
				&pThis->m_cbWritten,
				&pThis->m_olWrite
				)
			)
		{
			DWORD dwLastError = ::GetLastError();
			if (ERROR_IO_PENDING != dwLastError)
			{
				::lgLogError(
					LOG_SEV_1,
					"::WriteThread(), ::WriteFile() failed with %d",
					dwLastError
					);
				_ASSERTE(FALSE);
				::ExitProcess(::GetLastError());
			}

            if (!::GetOverlappedResult (
					pThis->m_hPort, 
					&pThis->m_olWrite, 
					&pThis->m_cbWritten, 
					TRUE)
				) 
			{
				DWORD dwLastError = ::GetLastError();
				
				//
				// since the fAbortOnError DCB member is TRUE, then if baud is changed, errors
				// will occur, and the operation will be aborted.
				// this is heuristic.
				//
				if (ERROR_OPERATION_ABORTED != dwLastError)
				{
					::lgLogError(
						LOG_SEV_1,
						"::WriteThread(), ::GetOverlappedResult() failed with %d",
						dwLastError
						);
					_ASSERTE(FALSE);
					::ExitProcess(dwLastError);
				}


				//
				// baud is wrong?
				//
				COMSTAT cmst;
				DWORD dwErrors;
				if (!::ClearCommError(pThis->m_hPort, &dwErrors, &cmst))
				{
					::lgLogError(
						LOG_SEV_1,
						"::ReadThread(), ::ClearCommError() failed with %d",
						::GetLastError()
						);
					_ASSERTE(FALSE);
					::ExitProcess(::GetLastError());
				}
				::lgLogDetail(LOG_X, 5, "::WriteThread(): dwErrors=0x%08X", dwErrors);
				
				//
				//try setting another baud rate
				//
				pThis->ChangeToCorrectBaudRate(pThis->m_dcb.BaudRate);
			
				continue;
			}
		}//if (!WriteFile(

		//
		// write was sync, or overlapped succeeded
		//
		if (1 != pThis->m_cbWritten)
		{
			::lgLogError(LOG_SEV_1,"1 != pThis->m_cbWritten(%d).", pThis->m_cbWritten);
			_ASSERTE(pThis->m_cbWriteBuff == pThis->m_cbWritten);
			::ExitProcess(-2);
		}

	}//while(!pThis->m_fAbortWriteThread)

	::lgLogDetail(LOG_X, 9, "WriteThread() exiting");
	return ERROR_SUCCESS;
}//WriteThread






//*********************************************************************************
//* Name:	CMedetectStub::StartThread()
//* Author:	Guy Merin
//* Date:	December 30, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		This function creates a new thread and initilazes it's a flag which can be
//*		used for aborting the thread
//* PARAMETERS:
//*		[OUT]	long *pfAbortThread
//*			Initialazed flag which will be used for aborting the thread
//*		[OUT]	HANDLE *phThreah
//*			thread handle
//*		[IN]	LPTHREAD_START_ROUTINE ThreadFunc
//*			Thread start routine
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CMedetectStub::StartThread(
	long *pfAbortThread,
	HANDLE *phThreah, 
	LPTHREAD_START_ROUTINE ThreadFunc
	)
{
	_ASSERTE(pfAbortThread);
	_ASSERTE(phThreah);
	_ASSERTE(ThreadFunc);
	DWORD dwThreadId;

	::InterlockedExchange(pfAbortThread, 0);

	*phThreah = ::CreateThread(
		NULL,			// pointer to thread security attributes 
		0,				// initial thread stack size, in bytes 
		ThreadFunc,		// pointer to thread function 
		this,			// argument for new thread 
		0,				// creation flags 
		&dwThreadId		// pointer to returned thread identifier  
		); 
	if (NULL == *phThreah)
    {
        throw CException(
            "CMedetectStub::StartThread() : CreateThread() failed with %d.",
            ::GetLastError()
            );
    }
}//CMedetectStub::StartThread()  





//*********************************************************************************
//* Name:	CMedetectStub::AbortThread()
//* Author:	Guy Merin
//* Date:	December 30, 1998
//*********************************************************************************
//* DESCRIPTION:
//*
//* PARAMETERS:
//*		[OUT]	long *pfAbortThread
//*			
//*		[IN/OUT]	HANDLE *phThread
//*			Handle to the thread to be aborted, after the thread is aborted this
//*			handle is reset(zeroed)
//* RETURN VALUE:
//*		true
//*			Success in aborting
//*		false
//*			Fail in aborting
//*********************************************************************************
bool CMedetectStub::AbortThread(long *pfAbortThread, HANDLE *phThread)
{
	_ASSERTE(pfAbortThread);
	_ASSERTE(phThread);

	if (!(*pfAbortThread))
	{
		::InterlockedExchange(pfAbortThread, 1);
		DWORD dwWaitForWriteThread = ::WaitForSingleObject(*phThread, 60*1000);
		if (WAIT_OBJECT_0 != dwWaitForWriteThread)
		{
			_ASSERTE(dwWaitForWriteThread);
			return false;
		}

		DWORD dwExitCodeThread;
		if (!::GetExitCodeThread(*phThread, &dwExitCodeThread))
		{
			_ASSERTE(!::GetLastError());
			return false;
		}
		else
		{
			if (ERROR_SUCCESS != dwExitCodeThread)
			{
				::lgLogError(
					LOG_SEV_1,
					"(ERROR_SUCCESS != dwExitCodeThread(%d))",
					dwExitCodeThread
					);
				::lgLogError(LOG_SEV_1,"(ERROR_SUCCESS != dwExitCodeThread(%d))\n", dwExitCodeThread);
				_ASSERTE(!dwExitCodeThread);
				return false;
			}
		}

		if (!::CloseHandle(*phThread))
		{
			_ASSERTE(!::GetLastError());
			return false;
		}
		*phThread = NULL;
	}
	else
	{
		//
		// do not assert, because dtor calls us anyway
		//
	}

	return true;
}//CMedetectStub::AbortThread()



//*********************************************************************************
//* Name:	CMedetectStub::Ring()
//* Author:	Guy Merin
//* Date:	December 30, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		Simulate ringing of a modem, this is done by sending a 
//*		"RING" "RING" string(default) or another ring string
//* PARAMETERS:
//*		[IN]	const char * const szRing
//*			the string corresponding a ring, default = "RING"
//*		[IN]	const DWORD cbRingRepeat
//*			Number of timers to repeat the ring action
//*		[IN]	const DWORD dwMaxTimeToSleepBetweenRings
//*			Miliseconds to sleep between rings
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CMedetectStub::Ring(
	const char * const szRing, 
	const DWORD cbRingRepeat, 
	const DWORD dwMaxTimeToSleepBetweenRings
	)
{
	WriteString(szRing, cbRingRepeat, dwMaxTimeToSleepBetweenRings);
}//CMedetectStub::Ring()






//*********************************************************************************
//* Name:	CMedetectStub::WriteOneString()
//* Author:	Guy Merin
//* Date:	December 30, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		sync write 1 string and wait till it's queued
//* PARAMETERS:
//*		[IN]	const char * const szToWrite
//*			string to write
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CMedetectStub::WriteOneString(
	const char * const szToWrite
	)
{
	char szLogString[MAX_RESPONSE_STRING_LENGTH];
	
	int i = 0;
	const char * szToCopy = szToWrite;
	while (*szToCopy) 
	{
		if ( ('\r' != *szToCopy) && ('\n' != *szToCopy) )
		{
			szLogString[i] = *szToCopy;
			i++;
		}
		szToCopy++;
	}
	szLogString[i] = '\0';
	
	::lgLogDetail(LOG_X, 2, "Write string:\t\t <%s>",szLogString);

	const char * pcIter = szToWrite;
	while('\0' != *pcIter)
	{
		m_WriteQ.Queue(*pcIter);
		pcIter++;
	}
}//CMedetectStub::WriteOneString()






//*********************************************************************************
//* Name:	CMedetectStub::WaitForWrite()
//* Author:	Guy Merin
//* Date:	December 30, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		Wait till the write operation finshed (the queue is empty)
//* PARAMETERS:
//*		NONE
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CMedetectStub::WaitForWrite()
{
	while(!m_WriteQ.IsEmpty())
	{
		::Sleep(1);
	}
}//CMedetectStub::WaitForWrite()






//*********************************************************************************
//* Name:	CMedetectStub::WriteString()
//* Author:	Guy Merin
//* Date:	December 30, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		This function writes a desired string to the COMM port
//* PARAMETERS:
//*		[IN]		const char * const szToWrite
//*			String to write to COMM port	
//*		[IN]		const DWORD cbWriteRepeat
//*			Number of times to repeat the string writing
//*		[IN]		const DWORD dwMaxTimeToSleepBetweenWrites
//*			Miliseconds to sleep between string finshing and starting
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CMedetectStub::WriteString( 
	const char * const szToWrite, 
	const DWORD cbWriteRepeat, 
	const DWORD dwMaxTimeToSleepBetweenWrites
	)	
{
	_ASSERTE(INFINITE != cbWriteRepeat);

	for(DWORD dwIter = 0; dwIter < cbWriteRepeat; dwIter++)
	{
		WriteOneString(szToWrite);
		WaitForWrite();
		if (0 != dwMaxTimeToSleepBetweenWrites)
		{
			::Sleep( ::rand() % dwMaxTimeToSleepBetweenWrites);
		}
	}
}//CMedetectStub::WriteString()





//*********************************************************************************
//* Name:	WriteStringIteratorThread()
//* Author:	Guy Merin
//* Date:	December 30, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		A write thread iterator
//*		This function is the thread function that writes a desired string to
//*		the comm port.
//* PARAMETERS:
//*		[IN]	void *pVoid
//*			Pointer to CMedetectStub
//* RETURN VALUE:
//*		thread exit code
//*	REMARK:
//*		If we need to async write a string (without waiting) then a new thread should
//*		be created, and this will be it's thread func
//*********************************************************************************
DWORD WINAPI WriteStringIteratorThread(void *pVoid)
{
	_ASSERTE(pVoid);
	CMedetectStub *pThis = (CMedetectStub*)pVoid;

	for(DWORD dwIter = 0; dwIter < pThis->m_cbWriteRepeat; dwIter++)
	{
		if (pThis->m_fAbortWriteStringIteratorThread) break;

		pThis->m_fWriteStringIteratorThreadStarted = 1;

		pThis->WriteString(pThis->m_acWriteBuff, 1, 0);

		if (0 != pThis->m_dwMaxTimeToSleepBetweenWrites)
		{
			::Sleep(pThis->m_dwMaxTimeToSleepBetweenWrites);
		}
	}
	
	return 0;
}//WriteStringIteratorThread





//*********************************************************************************
//* Name:	CMedetectStub::StartWritingString()
//* Author:	Guy Merin
//* Date:	December 30, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		async write a string
//* PARAMETERS:
//*		[IN]		const char * const szToWrite
//*			String to write
//*		[IN]		const DWORD cbWriteRepeat
//*			Number of times to write the string
//*		[IN]		const DWORD dwMaxTimeToSleepBetweenWrites
//*			Miliseconds to sleep between writes
//* RETURN VALUE:
//*		NONE
//*	REMARK:
//*		This function, uses StartThread() with WriteStringIteratorThread() as it's
//*		Thread function
//*********************************************************************************
void CMedetectStub::StartWritingString(
	const char * const szToWrite, 
	const DWORD cbWriteRepeat, 
	const DWORD dwMaxTimeToSleepBetweenWrites
	)
{
	::strcpy(m_acWriteBuff, szToWrite);
	m_cbWriteBuff = strlen(m_acWriteBuff);
	m_cbWriteRepeat = cbWriteRepeat;
	m_dwMaxTimeToSleepBetweenWrites = dwMaxTimeToSleepBetweenWrites;

	m_fWriteStringIteratorThreadStarted = 0;

	StartThread(&m_fAbortWriteStringIteratorThread, &m_hWriteStringIteratorThread, WriteStringIteratorThread);
}//CMedetectStub::StartWritingString()






//*********************************************************************************
//* Name:	CMedetectStub::StopWritingString()
//* Author:	Guy Merin
//* Date:	December 30, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		Abort the WriteStringIteratorThread
//* PARAMETERS:
//*		NONE
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CMedetectStub::StopWritingString()
{
	if (!AbortThread(&m_fAbortWriteStringIteratorThread, &m_hWriteStringIteratorThread))
    {
		throw CException(
            "CMedetectStub::StopWritingString() : AbortThread() failed with %d.",
            ::GetLastError()
            );
	}

	WaitForWrite();
}//CMedetectStub::StopWritingString()





//*********************************************************************************
//* Name:	CMedetectStub::StartRinging()
//* Author:	Guy Merin
//* Date:	December 30, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		async ringing ,using StartWritingString()
//* PARAMETERS:
//*		[IN]		const char * const szRing
//*			the string corresponding a ring, default = "RING"
//*		[IN]		const DWORD cbRingRepeat
//*			Number of timers to repeat the ring action
//*		[IN]		const DWORD dwMaxTimeToSleepBetweenRings
//*			Miliseconds to sleep between rings
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CMedetectStub::StartRinging(
	const char * const szRing, 
	const DWORD cbRingRepeat, 
	const DWORD dwMaxTimeToSleepBetweenRings
	)
{
	StartWritingString(szRing, cbRingRepeat, dwMaxTimeToSleepBetweenRings);
}//CMedetectStub::StartRinging()





//*********************************************************************************
//* Name:	CMedetectStub::StopRinging()
//* Author:	Guy Merin
//* Date:	December 30, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		Stop ringing, using StopWritingString()
//* PARAMETERS:
//*		NONE
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CMedetectStub::StopRinging()
{
	StopWritingString();
}//CMedetectStub::StopRinging()




//*********************************************************************************
//* Name:	CMedetectStub::DropDtr()
//* Author:	Guy Merin
//* Date:	December 30, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		Clear the DTR
//* PARAMETERS:
//*		NONE
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CMedetectStub::DropDtr()
{
	if (!::EscapeCommFunction(m_hPort, CLRDTR) )
	{
		throw CException(
			"CMedetectStub::DropDtr() : EscapeCommFunction() failed with %d.",
			::GetLastError()
			);
	}
}//CMedetectStub::DropDtr()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\tapitools\virtualmodem\medetectstub.h ===
#ifndef __MEDETECT_STUB_H
#define __MEDETECT_STUB_H

#include <windows.h>
#include "Exception.h"
#include "MtQueue.h"


typedef enum
{
	INI_SUCCESS=0,
	INI_READ_ERROR,
	INI_ERROR_STRING_TO_SMALL,
	INI_MORE_DATA,
	INI_OUT_OF_MEMORY
} iniStatus_t;



class CMedetectStub
{
public:
	//
	// szPort is for example: "COM23"
	//
	CMedetectStub(const char * const szPort);
	~CMedetectStub(void);



	///////////////////////////////////////////////////////////////////////////////////
	//ring functions
	//

	//
	//aSync function
	// start the process of writing the szRing string cbRingRepeat times, 
	// each-at-most dwMaxTimeToSleepBetweenRings milli.
	//
	void StartRinging(
		const char * const szRing = "\r\nRING\r\n", 
		const DWORD cbRingRepeat = INFINITE, 
		const DWORD dwMaxTimeToSleepBetweenRings = 5000
	);
	
	void StopRinging(void);

	//
	//Sync function
	// write szRing string cbRingRepeat times, 
	// each-at-most dwMaxTimeToSleepBetweenRings milli.
	//
	void Ring(
		const char *const szRing = "\r\nRING\r\n", 
		const DWORD cbRingRepeat = 5, 
		const DWORD dwMaxTimeToSleepBetweenRings = 5000
	);

	
	

	////////////////////////////////////////////////////////////////////////
	//Sync write functions:
	//

	//
	//Sync function
	// start the process of writing the szToWrite string cbWriteRepeat times, 
	// sleep dwMaxTimeToSleepBetweenWrites milli seconds between repeats.
	//
	void WriteString(
		const char *const szToWrite, 
		const DWORD cbWriteRepeat = 1, 
		const DWORD dwMaxTimeToSleepBetweenWrites = 0
		);

	//
	//Sync function
	//Write One string, no repeats no sleeps.
	//
	void WriteOneString(const char *const szToWrite);

	
	////////////////////////////////////////////////////////////////////////
	//aSync write functions:
	//

	//
	//aSync function
	// start the process of writing the szToWrite string cbWriteRepeat times, 
	// sleep dwMaxTimeToSleepBetweenWrites milli seconds between repeats.
	//
	void StartWritingString(
		const char *const szToWrite, 
		const DWORD cbWriteRepeat = 1, 
		const DWORD dwMaxTimeToSleepBetweenWrites = 0
		);

	//
	//Sync function
	//Used for stopping the async StartWritingString()
	//
	void StopWritingString(void);
	
	//////////////////////////////////////////////////////////////////////////////////////////
	
	void WaitForWrite(void);
	
	void DropDtr(void);

	bool GetNextReadChar(char& c){ return m_readQ.DeQueue(c);}
	bool SyncGetNextReadChar(char& c, const DWORD dwTimeout){ return m_readQ.SyncDeQueue(c, dwTimeout);}

	
private:
	HANDLE m_hPort;
	HANDLE m_hReadThread;
	HANDLE m_hWriteThread;
	HANDLE m_hWriteStringIteratorThread;
	char m_szPort[16];						//port name
	DCB m_dcb;
	OVERLAPPED m_olRead;
	OVERLAPPED m_olWrite;
	DWORD m_cbRead;							
	DWORD m_cbWritten;
	long m_fAbortReadThread;					//flag used for stoping the Read Thread
	long m_fAbortWriteThread;					//flag used for stoping the Write Thread
	long m_fAbortWriteStringIteratorThread;		//flag used for stoping the WriteStringIterator Thread
	long m_fWriteStringIteratorThreadStarted;
	char m_acWriteBuff[1024];
	DWORD m_cbWriteBuff;
	DWORD m_cbWriteRepeat;						
	DWORD m_dwMaxTimeToSleepBetweenWrites;		
	bool m_fDetetctionOn;						//indicates if modem is in media detection state
	bool m_fFaxOn;								//indicates if modem is in fax state

	//
	// used as a read pipe, to read all received bytes.
	//
	CMtQueue<char, 64*1024> m_readQ;
	CMtQueue<char, 64*1024> m_WriteQ;

	void SetCommTimeouts(
        const DWORD dwReadIntervalTimeout,
        const DWORD dwReadTotalTimeoutMultiplier,
        const DWORD dwReadTotalTimeoutConstant,
        const DWORD dwWriteTotalTimeoutMultiplier,
        const DWORD dwWriteTotalTimeoutConstant
        ) const;

	void SetCommDCB();

	void ChangeToCorrectBaudRate(DWORD currentBaud);

	void StartThread(
		long *pfAbortThread,
		HANDLE *phThreah, 
		LPTHREAD_START_ROUTINE ThreadFunc
		);
	
	iniStatus_t FindReceivedStringInIniFile(
		char *szSectionName,
		char *szResponseString,
		DWORD dwResponseStringSize,
		DWORD *cbWriteRepeat, 
		DWORD *dwMaxTimeToSleepBetweenWrites,
		DWORD keyNumber,
		DWORD *dwTimeToSleepBetweenResponses,
		char *szResponseAction,
		DWORD dwResponseActionSize,
		char *szResponseCondition,
		DWORD dwResponseConditionSize
		);

	iniStatus_t GetResponseFromINI(
	char *szSectionName,
	char *szKeyName,
	char *szDefaultResponseString,
	char *szIniString,
	DWORD dwResponseStringSize
	);


	
	bool CheckCondition(char *szResponseCondition);
	void WriteResponseString(char *szSectionName);
	void ExecuteResponseAction(char *szResponseAction);
	
	static void SetOverlappedStruct(OVERLAPPED * const ol);
	static bool AbortThread(long *pfAbortThread, HANDLE *phThread);

	static void InitKeyStringsForFindReceivedStringInIniFileFunction(
		DWORD keyNumber,
		char *szKeyNumberString,
		char *szConditionNumberString,
		char *szActionNumberString,
		char *szRepeatNumberString,
		char *szSleepNumberString,
		char *szNextKeyNumberString
		);

	bool IsActionExist(const char * const szResponseAction);
	bool IsConditionExist(const char * const szResponseCondition);



	friend DWORD WINAPI ReadThread(void *pVoid);
	friend DWORD WINAPI WriteThread(void *pVoid);
	friend DWORD WINAPI WriteStringIteratorThread(void *pVoid);


};


#endif //__MEDETECT_STUB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxclasses\ceventredirectionthread.h ===
#ifndef _EVENT_REDIRECTION_THREAD_H
#define _EVENT_REDIRECTION_THREAD_H

//utilities
#include <cthread.h>

//project specific
#include <Defs.h>
#include <AutoPtrs.h>


class CEventRedirectionThread: public ThreadBase_t
{
public:
		
	// CEventSource class cant validate this member in the constructor
	CEventRedirectionThread(); 
	CEventRedirectionThread(const tstring strServerName, 
					        const HANDLE hCompletionPort,
							const DWORD  dwEventPollingTime);
	~CEventRedirectionThread();
	unsigned int ThreadMain();
	void StopThreadMain();
	DWORD SetThreadParameters(const tstring strServerName, 
						      const HANDLE hCompletionPort,
						      const DWORD  dwEventPollingTime);
	HANDLE GetEvThreadCompleted()const {return  m_EventEndThread.get();};

private:
	DWORD m_dwEventPollingTime;
	BOOL m_fStopFlag;
	tstring m_tstrServerName;
	HANDLE m_hCompletionPort; // completion port handle received
	// event signifying thread has terminated 
	Event_t  m_EventEndThread;
};


#endif //_EVENT_REDIRECTION_THREAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxclasses\ceventredirectionthread.cpp ===
#include <windows.h>
#include <CFaxNotifySystem.h>
#include <CEventRedirectionThread.h>

//
// CEventRedirectionThread
// constructors
//
CEventRedirectionThread::CEventRedirectionThread():
	m_EventEndThread(NULL, TRUE, FALSE, TEXT("EventEndTHread")),
	m_hCompletionPort(INVALID_HANDLE_VALUE),
	m_fStopFlag(FALSE)

{;}

CEventRedirectionThread::CEventRedirectionThread(const tstring tstrServerName, 
												 const HANDLE hCompletionPort,
												 const DWORD  dwEventPollingTime):
	m_EventEndThread(NULL, TRUE, FALSE, TEXT("EventEndTHread")),
	m_tstrServerName(tstrServerName),
	m_fStopFlag(FALSE),
	m_dwEventPollingTime(dwEventPollingTime)
{
	assert(hCompletionPort && (hCompletionPort != INVALID_HANDLE_VALUE));
	m_hCompletionPort = hCompletionPort;
}

//
// destructor
//
CEventRedirectionThread::~CEventRedirectionThread()
{
	if( WaitForSingleObjectEx( GetEvThreadCompleted() , 0, FALSE) != WAIT_OBJECT_0)
	{
		StopThreadMain();
		// time out is set to (thread's polling for IOCP package time out) * 3
		if(WaitForSingleObjectEx(GetEvThreadCompleted(), 3 * m_dwEventPollingTime, FALSE) != WAIT_OBJECT_0)
		{
			Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("~CEventJobThread, WaitForSingleObjectEx"));
			::lgLogError(LOG_SEV_2, TEXT("Exception:%s."), err.description());
		}
	}

}


DWORD CEventRedirectionThread::SetThreadParameters(const tstring tstrServerName, 
												   const HANDLE hCompletionPort,
												   const DWORD  dwEventPollingTime)
{
	verify(ResetEvent(m_EventEndThread.get()));
	m_tstrServerName = tstrServerName;
	m_fStopFlag = FALSE;
	m_dwEventPollingTime = dwEventPollingTime;

	assert(hCompletionPort && (hCompletionPort != INVALID_HANDLE_VALUE));
	m_hCompletionPort = hCompletionPort;
	return 0;
}

//
// ThreadMain
//
unsigned int CEventRedirectionThread::ThreadMain()
{

	CFaxNotifySys* FaxNotifyEvent = NULL;
	CFaxEvent* pObjFaxEvent = NULL;
	DWORD dwThreadMainRetVal = 0;
	try
	{
			
		// create fax notifications pipe
		switch(ImplementationType)
		{
		case CType:
			FaxNotifyEvent = new CIOCompletionPortSystem(m_tstrServerName);
			if(!FaxNotifyEvent)
			{
						
				THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("CEventRedirectionThread::ThreadMain, new"));
			}
			break;
		case ComType:
			assert(false);
			break;
		default:
			assert(false);

		}
		
		while(!m_fStopFlag)
		{
		
			DWORD dwRetVal;
			// wait for event
			dwRetVal = FaxNotifyEvent->WaitFaxEvent(m_dwEventPollingTime, pObjFaxEvent);
			if(dwRetVal)
			{
				if(dwRetVal == WAIT_TIMEOUT)
				{
					#ifdef _DEBUG
					::lgLogDetail(LOG_X, 3, TEXT("WAIT_TIMEOUT in CEventRedirectionThread"));
					#endif
					continue;
				}
			
				THROW_TEST_RUN_TIME_WIN32(dwRetVal, TEXT("CEventRedirectionThread::ThreadMain, WaitFaxEvent"));
			}
			
			// post message
			BOOL bVal = PostQueuedCompletionStatus( m_hCompletionPort,
													sizeof(CFaxEvent),
													0,
													(LPOVERLAPPED)pObjFaxEvent);
			if(!bVal)
			{
				DWORD dwErr = GetLastError();
				THROW_TEST_RUN_TIME_WIN32(dwErr, TEXT("CEventRedirectionThread::ThreadMain, PostQueuedCompletionStatus"));
			}
			pObjFaxEvent = NULL;
		}

		
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
		dwThreadMainRetVal = err.error();
	}

	// cleanup
	delete FaxNotifyEvent;
	delete pObjFaxEvent;
	
	// signal thread has terminated.
	verify(SetEvent(m_EventEndThread.get()));
	::lgLogDetail(LOG_X, 3, TEXT("Terminated CEventRedirectionThread"));
	return dwThreadMainRetVal; 
}

//
// set stop condition
//
void CEventRedirectionThread::StopThreadMain()
{
	m_fStopFlag = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxclasses\ceventthread.cpp ===
#include "CEventThread.h"
#include "CFaxNotifySystem.h"
#include "Defs.h"

//
// CEventThread
// constructor
//
CEventThread::CEventThread():
	m_EventEndThread(NULL, TRUE, FALSE, TEXT("EventEndTHread")),
	m_fStopFlag(FALSE),
	m_pMsgRoutine(NULL)
{;}


//
// destructor
//
CEventThread::~CEventThread()
{
	if( WaitForSingleObjectEx( GetEvThreadCompleted() , 0, FALSE) != WAIT_OBJECT_0)
	{
		StopThreadMain();
		// time out is set to (thread's polling for IOCP package time out) * 3
		if(WaitForSingleObjectEx(GetEvThreadCompleted(), 3 * m_dwEventPollingTime, FALSE) != WAIT_OBJECT_0)
		{
			Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("~CEventThread, WaitForSingleObjectEx"));
			::lgLogError(LOG_SEV_2, TEXT("Exception:%s."), err.description());
		}
	}

}

//
// Initialize
//
// initialize parameters and start thread
//
DWORD CEventThread::Initialize(const tstring strServerName, 
	 						   const MsgHandleRoutine pMsgRoutine,
							   const DWORD  dwEventPollingTime)
{
	m_strServerName = strServerName;
	assert(pMsgRoutine);
	m_pMsgRoutine = pMsgRoutine;
	m_dwEventPollingTime = dwEventPollingTime;
	return StartThread();
}


//
// ThreadMain
//
unsigned int CEventThread::ThreadMain()
{

	CFaxNotifySys* FaxNotifyEvent = NULL;
	CFaxEvent* pObjFaxEvent = NULL;
	DWORD dwThreadMainRetVal = 0;
	try
	{
			
		// create fax notifications pipe
		switch(ImplementationType)
		{
		case CType:
			FaxNotifyEvent = new CIOCompletionPortSystem(m_strServerName);
			if(!FaxNotifyEvent)
			{
						
				THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("CEventThread::ThreadMain, new"));
			}
			break;
		case ComType:
			assert(false);
			break;
		default:
			assert(false);

		}
		

		while(!m_fStopFlag)
		{
		
			DWORD dwRetVal;
			// wait for event
			dwRetVal = FaxNotifyEvent->WaitFaxEvent(m_dwEventPollingTime, pObjFaxEvent);
			if(dwRetVal)
			{
				if(dwRetVal == WAIT_TIMEOUT)
				{
					#ifdef _DEBUG
					::lgLogDetail(LOG_X, 3, TEXT("WAIT_TIMEOUT in CEventThread"));
					#endif
				
				}
				else
				{
					Win32Err err(dwRetVal,__LINE__,TEXT(__FILE__),TEXT("CEventThread::ThreadMain, m_pMsgRoutine"));
					::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
				}

				continue;
			}
			
			// hand event to JobContainer
			if(DWORD dwHndleMsgRet = m_pMsgRoutine(*pObjFaxEvent))
			{
				//TODO:  error, report but continue
				Win32Err err(dwHndleMsgRet,__LINE__,TEXT(__FILE__),TEXT("CEventThread::ThreadMain, m_pMsgRoutine"));
				::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
			}
			
			delete pObjFaxEvent;
			pObjFaxEvent = NULL;
		}

		
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.what());
		dwThreadMainRetVal = err.error();
	}

	// cleanup
	delete FaxNotifyEvent;
	delete pObjFaxEvent;
	
	// signal thread terminated.
	verify(SetEvent(m_EventEndThread.get()));
	::lgLogDetail(LOG_X, 3, TEXT("Terminated CEventThread"));
	return dwThreadMainRetVal; 
}

//
// set stop condition
//
void CEventThread::StopThreadMain()
{
	m_fStopFlag = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxtestutils.cpp ===
#include <FaxTestUtils.h>

/*++
    Modifies access rights to Fax service for the specified user.
    The function adds new information to existing DACL.
    Access rights that are not included in dwAllow or dwDeny are not affected.

    [IN]    lpctstrServer   Server name (NULL for local server)
    [IN]    lptstrTrustee   User or group name. If it's NULL, access is set for currently logged on user.
    [IN]    dwAllow         Specifies access rights to be allowed
    [IN]    dwDeny          Specifies access rights to be denied
    [IN]    bReset          Specifies whether old access rights should be completeley discarded or
                            merged with new

    "Deny" is stronger than "Allow". Meaning, if the same right is specified in both dwAllow and dwDeny,
    the right will be denied.
  
    Calling the function with both dwAllow = 0 and dwDeny = 0 and bReset = TRUE has an affect of removing
    all ACEs for the specified user or group.

    Return value:           If the function succeeds, the return value is nonzero.
                            If the function fails, the return value is zero.
                            To get extended error information, call GetLastError. 
--*/

BOOL FaxModifyAccess(
                     LPCTSTR        lpctstrServer,
                     LPTSTR         lptstrTrustee,
                     const DWORD    dwAllow,
                     const DWORD    dwDeny,
                     const BOOL     bReset
                     )
{
    HANDLE                  hFaxServer          =   NULL;
    PSECURITY_DESCRIPTOR    pCurrSecDesc        =   NULL;
    PSECURITY_DESCRIPTOR    pNewSecDesc         =   NULL;
    DWORD                   dwEC                =   ERROR_SUCCESS;

    try
    {
        if (!FaxConnectFaxServer(lpctstrServer, &hFaxServer))
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("FaxModifyAccess - FaxConnectFaxServer"));
        }

        // Get current security descriptor from the service
        if (!FaxGetSecurity(hFaxServer, &pCurrSecDesc))
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("FaxModifyAccess - FaxGetSecurity"));
        }
        
        if (!CreateSecDescWithModifiedDacl(pCurrSecDesc, lptstrTrustee, dwAllow, dwDeny, bReset, TRUE, &pNewSecDesc))
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("FaxModifyAccess - CreateSecDescWithModifiedDacl"));
        }

        // Apply new security descriptor to the service
        if (!FaxSetSecurity(hFaxServer, DACL_SECURITY_INFORMATION, pNewSecDesc))
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("FaxModifyAccess - FaxSetSecurity"));
        }
    }

    catch(Win32Err& e)
    {
        dwEC = e.error();
    }

    // CleanUp
    if (pCurrSecDesc)
    {
        FaxFreeBuffer(pCurrSecDesc);
    }
    if (pNewSecDesc && FreeSecDesc(pNewSecDesc) != NULL)
    {
        // Report clean up error
    }
    if (hFaxServer && !FaxClose(hFaxServer))
    {
        // Report clean up error
    }

    if (dwEC != ERROR_SUCCESS)
    {
        SetLastError(dwEC);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxclasses\cfaxnotifysystem.h ===
#ifndef FAX_NOTIFY_H
#define FAX_NOTIFY_H

#include "CFaxEvent.h"
//
//
//
class CFaxNotifySys
{

public:
	virtual ~CFaxNotifySys(){};
	virtual DWORD WaitFaxEvent(const DWORD dwWaitTimeout, CFaxEvent*& pObjFaxEvent) = 0;
private:
};

#include "CIOCompletionPortSystem.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxclasses\ceventthread.h ===
#ifndef _EVENT_THREAD_H
#define _EVENT_THREAD_H

#include <cthread.h>
#include <autoptrs.h>
#include "CFaxEvent.h"

typedef DWORD (WINAPI* MsgHandleRoutine)(CFaxEvent& pFaxEvent);

class CEventThread: public ThreadBase_t
{
public:
		
	CEventThread(); 
	DWORD Initialize(const tstring strServerName, 
					 const MsgHandleRoutine pMsgRoutine,
					 const DWORD  dwEventPollingTime = 3*60*1000);
	~CEventThread();
	unsigned int ThreadMain();
	void StopThreadMain();
	HANDLE GetEvThreadCompleted()const {return  m_EventEndThread.get();};

private:
	BOOL m_fStopFlag;
	// event signifying thread termination 
	Event_t  m_EventEndThread;
	MsgHandleRoutine m_pMsgRoutine;

	DWORD m_dwEventPollingTime;
	tstring m_strServerName;

};

#endif //_EVENT_THREAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxclasses\ciocompletionportsystem.h ===
#ifndef IOC_NOTIFY_H
#define IOC_NOTIFY_H


#include "Defs.h"
#include "CFaxEvent.h"
#include "CFaxNotifySystem.h"


//
//
//
class CIOCompletionPortSystem : public virtual CFaxNotifySys
{
public:
	CIOCompletionPortSystem(const tstring strServerName);
	~CIOCompletionPortSystem();
	DWORD WaitFaxEvent(const DWORD dwWaitTimeout, CFaxEvent*& pObjFaxEvent);
private:
	void _Cleanup();
	tstring m_strServerName;
	HANDLE m_hCompletionPort;
	HANDLE m_hFax;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxclasses\ciocompletionportsystem.cpp ===
#include <winfax.h>
#include <testruntimeerr.h>

#include "CIOCompletionPortSystem.h"

// Constructor
// Initialize fax service notification system
// [in] ServerName - Srever name.

CIOCompletionPortSystem::CIOCompletionPortSystem(const tstring strServerName):m_strServerName(strServerName),
																			  m_hFax(NULL),		
																			  m_hCompletionPort(INVALID_HANDLE_VALUE)
{
	
	// Connect service
	BOOL bVal = FaxConnectFaxServer( m_strServerName.c_str(), &m_hFax);
	if(!bVal)
	{
		DWORD dwErr = GetLastError();
		if(!dwErr)
		{
			::lgLogError(LOG_SEV_2, TEXT("FaxConnectFaxServer-GetLastError returned 0 on fail, module CIOCompletionPortSystem."));
		}

		THROW_TEST_RUN_TIME_WIN32(dwErr, TEXT(" CIOCompletionPortSystem, FaxConnectFaxServer"));
	}

	// Create IO completion port
	m_hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE,NULL,0,0);
	if (!m_hCompletionPort) 
	{
		_Cleanup();
		THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" CIOCompletionPortSystem, CreateIoCompletionPort"));
	}

	// Initialize fax event queue
	bVal = FaxInitializeEventQueue(m_hFax,m_hCompletionPort,NULL,NULL,0);
	if(!bVal)
	{
		_Cleanup();
		DWORD dwErr = GetLastError();
		if(!dwErr)
		{
			::lgLogError(LOG_SEV_2, TEXT("FaxInitializeEventQueue-GetLastError returned 0 on fail,module CIOCompletionPortSystem."));
		}
		THROW_TEST_RUN_TIME_WIN32(dwErr, TEXT(" CIOCompletionPortSystem, FaxInitializeEventQueue"));
	}
	
}


// WaitFaxEvent
// Get Fax event
// [in] dwWaitTimeout - time out to wait on events.
// [out] pObjFaxEvent - fax event object.
// return value - 0 for success any other value is a system error
//				  returned by the GetLastError call.

DWORD CIOCompletionPortSystem::WaitFaxEvent(const DWORD dwWaitTimeout, 
											CFaxEvent*& pObjFaxEvent)
{

	DWORD dwRetVal = 0;
	pObjFaxEvent = NULL;
	DWORD dwBytes, dwCompletionKey;
	PFAX_EVENT pFaxEvent = NULL; // TODO: Update type PFAX_EVENT_EX

	// Wait for event
	BOOL bVal = GetQueuedCompletionStatus(m_hCompletionPort, 
										  &dwBytes,
										  &dwCompletionKey,
										  (LPOVERLAPPED *)&pFaxEvent,
										  dwWaitTimeout);
	if(!bVal)
	{
		dwRetVal = GetLastError();
	}
	else
	{
		pObjFaxEvent  = new CFaxEvent( pFaxEvent->TimeStamp,
									   pFaxEvent->EventId,
									   0,	// TODO: Update type PFAX_EVENT_EX
									   pFaxEvent->JobId,
									   pFaxEvent->DeviceId,
									   TEXT(""));// TODO: Update type PFAX_EVENT_EX
		if(!pObjFaxEvent)
		{
			dwRetVal = ERROR_OUTOFMEMORY;
		}

		if( LocalFree(pFaxEvent))
		{
			delete pObjFaxEvent;
			pObjFaxEvent = NULL;
			dwRetVal = GetLastError();
		}
	}

	return dwRetVal;
}



CIOCompletionPortSystem::~CIOCompletionPortSystem()
{
	_Cleanup();
}

// Cleanup
//
void CIOCompletionPortSystem::_Cleanup()
{
	if (NULL != m_hFax)
	{
		if (!FaxClose( m_hFax ))
		{
			Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("~CIOCompletionPortSystem, FaxClose"));
			::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
		}
	}
	
	if (INVALID_HANDLE_VALUE != m_hCompletionPort)
	{
		if (!CloseHandle( m_hCompletionPort ))
		{
			Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("~CIOCompletionPortSystem, CloseHandle"));
			::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxclasses\cfaxevent.h ===
#ifndef FAX_EVENT_H
#define FAX_EVENT_H

#include <string>
#include "Defs.h"

//
// Class holding FAX_EVENT_EX fields.
//
class CFaxEvent
{

public:
	CFaxEvent( const FILETIME TimeStamp,
			   const DWORD dwEventId,
			   const DWORD dwEventParam,
			   const DWORD dwJobId,
			   const DWORD dwDeviceId,
			   const tstring strEventDesc);
	~CFaxEvent(){};
	CFaxEvent( const CFaxEvent& FEvent);
	CFaxEvent& CFaxEvent::operator=(const CFaxEvent& FEvent);
	
	DWORD GetEventId(){return m_dwEventId;}; 
	DWORD GetEventParam(){return m_dwEventParam;};
	DWORD GetJobId(){return m_dwJobId;};
	DWORD GetDeviceId(){return m_dwDeviceId;};
	FILETIME GetTimeStamp(){return m_TimeStamp;};
	TCHAR* GetEventDesc(){return const_cast<TCHAR*>(m_strEventDesc.c_str());};

private:
	FILETIME m_TimeStamp;
	DWORD m_dwEventId;
	DWORD m_dwEventParam;
	DWORD m_dwJobId;
	DWORD m_dwDeviceId;
	tstring m_strEventDesc;
};


// Constructor
inline CFaxEvent::CFaxEvent( const FILETIME TimeStamp,
							 const DWORD dwEventId,
							 const DWORD dwEventParam,
							 const DWORD dwJobId,
							 const DWORD dwDeviceId,
							 const tstring strEventDesc):m_TimeStamp(TimeStamp),
														 m_dwEventId(dwEventId),
														 m_dwEventParam(dwEventParam),
														 m_dwJobId(dwJobId),
														 m_dwDeviceId(dwDeviceId),
														 m_strEventDesc(strEventDesc)
{
	;
}




// Copy constructor
inline CFaxEvent :: CFaxEvent( const CFaxEvent& FEvent)
{ 

		m_TimeStamp = FEvent.m_TimeStamp;
		m_dwEventId = FEvent.m_dwEventId;
		m_dwEventParam = FEvent.m_dwEventParam;
		m_dwJobId = FEvent.m_dwJobId;
		m_dwDeviceId = FEvent.m_dwDeviceId;
		m_strEventDesc = FEvent.m_strEventDesc;
}


// Operator =
inline CFaxEvent& CFaxEvent::operator=(const CFaxEvent& FEvent)
{

	if(this != &FEvent)
	{
		m_TimeStamp = FEvent.m_TimeStamp;
		m_dwEventId = FEvent.m_dwEventId;
		m_dwEventParam = FEvent.m_dwEventParam;
		m_dwJobId = FEvent.m_dwJobId;
		m_dwDeviceId = FEvent.m_dwDeviceId;
		m_strEventDesc = FEvent.m_strEventDesc;
	}
	return *this;
}



#endif //FAX_EVENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxsender\faxcompport.cpp ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Filename:	FaxCompPort.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		16-Aug-98
//


//
//	Description:
//		This file contains the implementation of class CFaxCompletionPort.
//


#include "FaxCompPort.h"


CFaxCompletionPort::CFaxCompletionPort():
	m_hCompletionPort(NULL),
	m_hServerEvents(NULL)
{
}


CFaxCompletionPort::~CFaxCompletionPort(void)
{
	if (NULL != m_hCompletionPort)
	{
		if(!::CloseHandle(m_hCompletionPort))
		{
			::_tprintf(TEXT("FILE:%s LINE:%d\nCloseHandle failed with GetLastError()=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError()
				);
		}
	}
	if (NULL != m_hServerEvents)
	{
		if (FALSE == FaxUnregisterForServerEvents(m_hServerEvents))
		{
			::_tprintf(TEXT("FILE:%s LINE:%d\nFaxUnregisterForServerEvents(m_hEventHandle=0x%08X) failed with GetLastError()=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				m_hServerEvents,
				::GetLastError()
				);
		}
	}
}


//
// GetCompletionPortHandle:
//	Creates an I\O completion port and "connects" it
//	to the local NT5.0 Fax Server.
//
// Return Value:
//	The Completion port if successful.
//	Otherwise NULL.
//
// Note:
//	Only one I\O completion port can be "connected" to
//	the Fax Server Queue (due to a limitation of the
//	API FaxInitializeEventQueue), so the first time this
//	function is called, a completion port is created and
//	FaxInitializedEventQueue is called. The created port 
//	is stored in the private member m_hCompletionPort.
//	Subsequent calls to this function return m_hCompletionPort.
//
BOOL CFaxCompletionPort::GetCompletionPortHandle(
	LPCTSTR szMachineName,
	HANDLE& hComPortHandle, 
	DWORD& dwLastError)
{
	BOOL fReturnValue = TRUE;

	// set OUT param dwLAstError
	dwLastError = ERROR_SUCCESS;

	//
	// Check if we already created and "connected" a completion port.
	// If we did then m_hCompletionPort would not be NULL.
	//
	if (NULL == m_hCompletionPort) 	
	{
		// No Completion Port exists, so create one.
		fReturnValue = ::InitFaxQueue(
			szMachineName,
			m_hCompletionPort,
			dwLastError,
			m_hServerEvents
			);// create and "connect" port.

			// reminder:
			// if completion port creation failed (InitFaxQueue failed)=>
			// dwLastError was set to last error
			// and m_hCompletionPort was set to NULL.
			// if completion port creation succeeded (InitFaxQueue succeeded)=>
			// dwLastError was set to ERROR_SUCCESS (0)
			// and m_hCompletionPort was set comp port handle.

		
		// OUT param dwLastError was set by InitFaxQueue()
					
	}

	// set OUT param to new m_hCompletionPort
	hComPortHandle = m_hCompletionPort;

	return(fReturnValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxsender\faxevent.cpp ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Filename:	FaxEvent.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		23-Jul-98
//


//
// Description:
//		This file contains the implementation of module "FaxEvent.h".
//


#include "FaxEvent.h"

//
// AppendEventIdStrToOs:
//	Inserts a string describing the event's numeric id (EventId) into the given stream.
//
CostrstreamEx& AppendEventIdStrToOs(CostrstreamEx& /* IN OUT */ os, const DWORD /* IN */ EventId)
{
	switch(EventId)
	{
	case FEI_DIALING:
		os<<TEXT("FEI_DIALING (");
		break;

	case FEI_SENDING:
		os<<TEXT("FEI_SENDING (");
		break;

	case FEI_RECEIVING:
		os<<TEXT("FEI_RECEIVING (");
		break;

	case FEI_COMPLETED:
		os<<TEXT("FEI_COMPLETED (");
		break;

	case FEI_BUSY:
		os<<TEXT("FEI_BUSY (");
		break;

	case FEI_NO_ANSWER:
		os<<TEXT("FEI_NO_ANSWER (");
		break;

	case FEI_BAD_ADDRESS:
		os<<TEXT("FEI_BAD_ADDRESS (");
		break;

	case FEI_NO_DIAL_TONE:
		os<<TEXT("FEI_NO_DIAL_TONE (");
		break;

	case FEI_DISCONNECTED:
		os<<TEXT("FEI_DISCONNECTED (");
		break;

	case FEI_FATAL_ERROR:
		os<<TEXT("FEI_FATAL_ERROR (");
		break;

	case FEI_NOT_FAX_CALL:
		os<<TEXT("FEI_NOT_FAX_CALL (");
		break;

	case FEI_CALL_DELAYED:
		os<<TEXT("FEI_CALL_DELAYED (");
		break;

	case FEI_CALL_BLACKLISTED:
		os<<TEXT("FEI_CALL_BLACKLISTED (");
		break;

	case FEI_RINGING:
		os<<TEXT("FEI_RINGING (");
		break;

	case FEI_ABORTING:
		os<<TEXT("FEI_ABORTING (");
		break;

	case FEI_ROUTING:
		os<<TEXT("FEI_ROUTING (");
		break;

	case FEI_MODEM_POWERED_ON:
		os<<TEXT("FEI_MODEM_POWERED_ON (");
		break;

	case FEI_MODEM_POWERED_OFF:
		os<<TEXT("FEI_MODEM_POWERED_OFF (");
		break;

	case FEI_IDLE :
		os<<TEXT("FEI_IDLE  (");
		break;

	case FEI_FAXSVC_ENDED :
		os<<TEXT("FEI_FAXSVC_ENDED  (");
		break;

	case FEI_ANSWERED :
		os<<TEXT("FEI_ANSWERED  (");
		break;

	case FEI_JOB_QUEUED :
		os<<TEXT("FEI_JOB_QUEUED  (");
		break;

	case FEI_DELETED:
		os<<TEXT("FEI_DELETED (");
		break;

	case FEI_FAXSVC_STARTED :
		os<<TEXT("FEI_FAXSVC_STARTED  (");
		break;

	case FEI_INITIALIZING :
		os<<TEXT("FEI_FAXSVC_INITIALIZING  (");
		break;

	case FEI_LINE_UNAVAILABLE :
		os<<TEXT("FEI_LINE_UNAVAILABLE  (");
		break;

	case FEI_HANDLED :
		os<<TEXT("FEI_HANDLED  (");
		break;

	default:
		_ASSERTE(FALSE);
		break;
	}
	os<<EventId<<TEXT(")");
	return(os);
}

//
// AppendEventIdStrToOs:
//	Inserts a string describing the event's numeric id (EventId) into the given stream.
//
CotstrstreamEx& AppendEventIdStrToOs(CotstrstreamEx& /* IN OUT */ os, const DWORD /* IN */ EventId)
{
	switch(EventId)
	{
	case FEI_DIALING:
		os << TEXT("FEI_DIALING (");
		break;

	case FEI_SENDING:
		os << TEXT("FEI_SENDING (");
		break;

	case FEI_RECEIVING:
		os << TEXT("FEI_RECEIVING (");
		break;

	case FEI_COMPLETED:
		os << TEXT("FEI_COMPLETED (");
		break;

	case FEI_BUSY:
		os << TEXT("FEI_BUSY (");
		break;

	case FEI_NO_ANSWER:
		os << TEXT("FEI_NO_ANSWER (");
		break;

	case FEI_BAD_ADDRESS:
		os << TEXT("FEI_BAD_ADDRESS (");
		break;

	case FEI_NO_DIAL_TONE:
		os << TEXT("FEI_NO_DIAL_TONE (");
		break;

	case FEI_DISCONNECTED:
		os << TEXT("FEI_DISCONNECTED (");
		break;

	case FEI_FATAL_ERROR:
		os<<TEXT("FEI_FATAL_ERROR (");
		break;

	case FEI_NOT_FAX_CALL:
		os << TEXT("FEI_NOT_FAX_CALL (");
		break;

	case FEI_CALL_DELAYED:
		os << TEXT("FEI_CALL_DELAYED (");
		break;

	case FEI_CALL_BLACKLISTED:
		os << TEXT("FEI_CALL_BLACKLISTED (");
		break;

	case FEI_RINGING:
		os << TEXT("FEI_RINGING (");
		break;

	case FEI_ABORTING:
		os << TEXT("FEI_ABORTING (");
		break;

	case FEI_ROUTING:
		os << TEXT("FEI_ROUTING (");
		break;

	case FEI_MODEM_POWERED_ON:
		os << TEXT("FEI_MODEM_POWERED_ON (");
		break;

	case FEI_MODEM_POWERED_OFF:
		os << TEXT("FEI_MODEM_POWERED_OFF (");
		break;

	case FEI_IDLE :
		os << TEXT("FEI_IDLE  (");
		break;

	case FEI_FAXSVC_ENDED :
		os << TEXT("FEI_FAXSVC_ENDED  (");
		break;

	case FEI_ANSWERED :
		os << TEXT("FEI_ANSWERED  (");
		break;

	case FEI_JOB_QUEUED :
		os << TEXT("FEI_JOB_QUEUED  (");
		break;

	case FEI_DELETED:
		os << TEXT("FEI_DELETED (");
		break;

	case FEI_FAXSVC_STARTED :
		os << TEXT("FEI_FAXSVC_STARTED  (");
		break;

	case FEI_INITIALIZING :
		os << TEXT("FEI_FAXSVC_INITIALIZING  (");
		break;

	case FEI_LINE_UNAVAILABLE :
		os << TEXT("FEI_LINE_UNAVAILABLE  (");
		break;

	case FEI_HANDLED :
		os << TEXT("FEI_HANDLED  (");
		break;

	default:
		_ASSERTE(FALSE);
		break;
	}
	os << EventId << TEXT(")");
	return(os);
}

//
// operator<<:
//	Appends a string representation of all the fields of a given FAX_EVENT.
//
CostrstreamEx& operator<<(CostrstreamEx& /* IN OUT */ os, const FAX_EVENT& /* IN */ aFaxEvent)
{
	os<<TEXT("SizeOfStruct:\t")<<aFaxEvent.SizeOfStruct<<endl;

	// convert the FAX_EVENT's time field to representable form
	os<<TEXT("TimeStamp:\t");
	FILETIME localFileTime;
	if (FALSE == ::FileTimeToLocalFileTime(&(aFaxEvent.TimeStamp),&localFileTime))
	{
		os<<TEXT("Time Conversion (FileTimeToLocalFileTime) Failed with Error=)")<<GetLastError();
		return(os);
	}

	SYSTEMTIME lpSystemTime;
	if(FALSE == ::FileTimeToSystemTime(&localFileTime,&lpSystemTime))
	{
		os<<TEXT("Time Conversion (FileTimeToSystemTime) Failed with Error=")<<GetLastError();
		return(os);
	}
	os<<lpSystemTime.wDay<<TEXT("/")<<lpSystemTime.wMonth<<TEXT("/")<<lpSystemTime.wYear<<TEXT("  ");
	os<<lpSystemTime.wHour<<TEXT(":");
	if (lpSystemTime.wMinute < 10) 
	{
		os<<TEXT("0");
	}
	os<<lpSystemTime.wMinute<<TEXT(":");
	if (lpSystemTime.wSecond < 10)
	{
		os<<TEXT("0");
	}
	os<<lpSystemTime.wSecond;
	os<<TEXT("  (d/m/yy  h:mm:ss)")<<endl;

	os<<TEXT("DeviceId:\t")<<aFaxEvent.DeviceId<<endl;

	// convert EventId to a descriptive string
	os<<TEXT("EventId:\t");
	::AppendEventIdStrToOs(os, aFaxEvent.EventId);
	os<<endl;

	os<<TEXT("JobId:\t\t")<<aFaxEvent.JobId;

	return(os);
}

//
// operator<<:
//	Appends a string representation of all the fields of a given FAX_EVENT.
//
CotstrstreamEx& operator<<(CotstrstreamEx& /* IN OUT */ os, const FAX_EVENT& /* IN */ aFaxEvent)
{
	os<<TEXT("SizeOfStruct:\t")<<aFaxEvent.SizeOfStruct<<endl;

	// convert the FAX_EVENT's time field to representable form
	os<<TEXT("TimeStamp:\t");
	FILETIME localFileTime;
	if (FALSE == ::FileTimeToLocalFileTime(&(aFaxEvent.TimeStamp),&localFileTime))
	{
		os<<TEXT("Time Conversion (FileTimeToLocalFileTime) Failed with Error=")<<GetLastError();
		return(os);
	}

	SYSTEMTIME lpSystemTime;
	if(FALSE == ::FileTimeToSystemTime(&localFileTime,&lpSystemTime))
	{
		os<<TEXT("Time Conversion (FileTimeToSystemTime) Failed with Error=")<<GetLastError();
		return(os);
	}
	os<<lpSystemTime.wDay<<TEXT("/")<<lpSystemTime.wMonth<<TEXT("/")<<lpSystemTime.wYear<<TEXT("  ");
	os<<lpSystemTime.wHour<<TEXT(":");
	if (lpSystemTime.wMinute < 10) 
	{
		os<<TEXT("0");
	}
	os<<lpSystemTime.wMinute<<TEXT(":");
	if (lpSystemTime.wSecond < 10)
	{
		os<<TEXT("0");
	}
	os<<lpSystemTime.wSecond;
	os<<TEXT("  (d/m/yy  h:m:ss)")<<endl;

	os<<TEXT("DeviceId:\t")<<aFaxEvent.DeviceId<<endl;

	// convert EventId to a descriptive string
	os<<TEXT("EventId:\t");
	::AppendEventIdStrToOs(os, aFaxEvent.EventId);
	os<<endl;

	os<<TEXT("JobId:\t\t")<<aFaxEvent.JobId;

	return(os);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxsender\faxevent.h ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Filename:	FaxEvent.h
// Author:	Sigalit Bar (sigalitb)
// Date:		23-Jul-98
//

//
// Description:
//	This file contains FAX_EVENT (winfax.h) related functions.
//	These methods allow for easier printing of FAX_EVENTs.
//


#ifndef _FAX_EVENT_H_
#define _FAX_EVENT_H_

#include <crtdbg.h>
#include <WinFax.h>
#include "streamEx.h"


//
// AppendEventIdStrToOs:
//	Inserts a string describing the event's numeric id (EventId) into the given stream.
//
// Parameters:
//	EventId		The numeric id of a fax event (FAX_EVENT.EventId), to generate the
//				corresponding descriptive string by.
//	os			The output stream to which the string will be appended.
//
// Return Value:
//	The updated stream.
//
CostrstreamEx& AppendEventIdStrToOs(CostrstreamEx& /* IN OUT */ os, const DWORD /* IN */ EventId);


//
// operator<<:
//	Appends a string representation of all the fields of a given FAX_EVENT.
//
// Parameters:
//	aFaxEvent	The FAX_EVENT which the generated string will represent.
//	os			The output stream to which the string will be appended.
//
// Return Value:
//	The updated stream.
//
CostrstreamEx& operator<<(CostrstreamEx& /* IN OUT */ os, const FAX_EVENT& /* IN */ aFaxEvent);
CotstrstreamEx& operator<<(CotstrstreamEx& /* IN OUT */ os, const FAX_EVENT& /* IN */ aFaxEvent);
CotstrstreamEx& AppendEventIdStrToOs(CotstrstreamEx& /* IN OUT */ os, const DWORD /* IN */ EventId);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxclasses\defs.h ===
#ifndef _TEST_MNG_DEFS_H
#define _TEST_MNG_DEFS_H

#include <assert.h>
#include <log\log.h>
#include <tstring.h>

	
#define verify(f) \
	do \
	{ \
	if (!(f)) \
		assert(FALSE); \
	} while (0) \

#define CType   0
#define ComType 1
#define ImplementationType CType

#endif //_TEST_MNG_DEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxclasses\preparejobparams.cpp ===
#ifndef _PREPARE_JOB_PARAMS_H
#define _PREPARE_JOB_PARAMS_H

#include <winfax.h>
#include <ptrs.h>
#include <assert.h>
#include <tstring.h>
#include <testruntimeerr.h>


////////////////////////////////////
// FAX_JOB_PARAM_EX Classes
//
////////////////////////////////////

// 
// BasicJobParamsEx
//
//
class BasicJobParamsEx
{
public:
	BasicJobParamsEx(const TCHAR* tstrDocumentName);
	BasicJobParamsEx(): // for the copy constructor
		m_pdata(NULL),
		m_pCounter(NULL){}; 
	virtual ~BasicJobParamsEx(){};
	void DeleteData();
	FAX_JOB_PARAM_EX* GetData(){ return m_pdata;};
protected:
	FAX_JOB_PARAM_EX* m_pdata;
	Counter* m_pCounter;
};

inline BasicJobParamsEx::BasicJobParamsEx(const TCHAR* tstrDocumentName) :
	m_pdata(NULL),
	m_pCounter(NULL)
{
	m_pCounter = new Counter(1);
	if(!m_pCounter)
	{
		THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("BasicJobParamsEx, new"));
	}

	m_pdata = new FAX_JOB_PARAM_EX;
	if(!m_pdata)
	{
		THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("BasicJobParamsEx, new"));
	}
	memset(m_pdata, 0, sizeof(FAX_JOB_PARAM_EX));
	m_pdata->dwSizeOfStruct = sizeof(FAX_JOB_PARAM_EX);

	m_pdata->lptstrDocumentName = _tcsdup(tstrDocumentName);
	assert(m_pdata->lptstrDocumentName);
}

inline void BasicJobParamsEx::DeleteData()
{
	if(m_pdata)
	{
		if(m_pdata->lptstrDocumentName)
			free( m_pdata->lptstrDocumentName);
	}
	delete m_pdata; 
	delete m_pCounter;
}

//
// JobParamExPrio
//
// JSA_NOW
//

class JobParamExPrio: public  BasicJobParamsEx
{
public:
	JobParamExPrio(const TCHAR* tstrDocumentName = TEXT(""), const DWORD dwPageCount = 0);
	~JobParamExPrio();
	JobParamExPrio( const JobParamExPrio& pJobParamExPrio);
	JobParamExPrio& operator=(const JobParamExPrio& pJobParamExPrio);
};

inline JobParamExPrio::JobParamExPrio(const TCHAR* tstrDocumentName, const DWORD dwPageCount):
	BasicJobParamsEx(tstrDocumentName)
{
	m_pdata->dwScheduleAction = JSA_NOW;
	m_pdata->dwPageCount = dwPageCount;
}

inline JobParamExPrio::JobParamExPrio( const JobParamExPrio& pJobParamExPrio)
{
	m_pCounter = pJobParamExPrio.m_pCounter;
	m_pdata = pJobParamExPrio.m_pdata;
	++(*m_pCounter);
}

inline 	JobParamExPrio& JobParamExPrio::operator=(const JobParamExPrio& pJobParamExPrio)
{
	if(this != &pJobParamExPrio)
	{
		if(!--(*m_pCounter))
		{
			DeleteData();
		}
		m_pCounter = pJobParamExPrio.m_pCounter;
		m_pdata = pJobParamExPrio.m_pdata;
		++(*m_pCounter);
	}
	return *this;
}

inline JobParamExPrio::~JobParamExPrio()
{
	if(!--(*m_pCounter))
	{
		DeleteData();
	}
}

//
// JobParamExNow
// 
// JSA_SPECIFIC_TIME, current system time
//
class JobParamExNow: public  BasicJobParamsEx
{
public:
	JobParamExNow(const TCHAR* strDocumentName = TEXT(""), const DWORD dwPageCount = 0);
	~JobParamExNow();
	JobParamExNow( const JobParamExNow& pJobParamExNow);
	JobParamExNow& operator=(const JobParamExNow& pJobParamExNow);
};

inline JobParamExNow::JobParamExNow(const TCHAR* tstrDocumentName, const DWORD dwPageCount):
	BasicJobParamsEx(tstrDocumentName)
{
	m_pdata->dwScheduleAction = JSA_SPECIFIC_TIME;
	GetLocalTime(&m_pdata->tmSchedule);
	m_pdata->dwPageCount = dwPageCount;
}

inline JobParamExNow::JobParamExNow( const JobParamExNow& pJobParamExNow)
{
	m_pCounter = pJobParamExNow.m_pCounter;
	m_pdata = pJobParamExNow.m_pdata;
	++(*m_pCounter);
}

inline 	JobParamExNow& JobParamExNow::operator=(const JobParamExNow& pJobParamExNow)
{
	if(this != &pJobParamExNow)
	{
		if(!--(*m_pCounter))
		{
			DeleteData();
		}
		m_pCounter = pJobParamExNow.m_pCounter;
		m_pdata = pJobParamExNow.m_pdata;
		++(*m_pCounter);
	}
	return *this;
}

inline JobParamExNow::~JobParamExNow()
{
	if(!--(*m_pCounter))
	{
		DeleteData();
	}
}

//
// JobParamSchedule
//
// JSA_SPECIFIC_TIME
//

class JobParamSchedule: public virtual BasicJobParamsEx
{
public:
	JobParamSchedule(const TCHAR* strDocumentName = TEXT(""),
					 const DWORD dwHour = 0,
					 const DWORD dwMinutes = 0,
					 const DWORD dwPageCount = 0);
	~JobParamSchedule();
	JobParamSchedule( const JobParamSchedule& pJobParamSchedule);
	JobParamSchedule& operator=(const JobParamSchedule& pJobParamSchedule);
};

inline JobParamSchedule::JobParamSchedule(const TCHAR* tstrDocumentName,
										  const DWORD dwHour,
										  const DWORD dwMinutes,
										  const DWORD dwPageCount):
	BasicJobParamsEx(tstrDocumentName)
{
	m_pdata->dwScheduleAction = JSA_SPECIFIC_TIME;
	m_pdata->dwPageCount = dwPageCount;

	SYSTEMTIME tmSys;
	GetLocalTime(&tmSys);
	if((dwHour > 0) && (dwHour < 24))
	{
		tmSys.wHour = dwHour;

	}
	if((dwMinutes >= 0) && (dwMinutes < 60))
	{
		tmSys.wMinute = dwMinutes;
	}

	m_pdata->tmSchedule = tmSys;

}

inline JobParamSchedule::JobParamSchedule( const JobParamSchedule& pJobParamSchedule)
{
	m_pCounter = pJobParamSchedule.m_pCounter;
	m_pdata = pJobParamSchedule.m_pdata;
	++(*m_pCounter);
}

inline 	JobParamSchedule& JobParamSchedule::operator=(const JobParamSchedule& pJobParamSchedule)
{
	if(this != &pJobParamSchedule)
	{
		if(!--(*m_pCounter))
		{
			DeleteData();
		}
		m_pCounter = pJobParamSchedule.m_pCounter;
		m_pdata = pJobParamSchedule.m_pdata;
		++(*m_pCounter);
		
	}
	return *this;
}

inline JobParamSchedule::~JobParamSchedule()
{
	if(!--(*m_pCounter))
	{
		DeleteData();
	}
}


////////////////////////////////////
// FAX_COVERPAGE_INFO_EX Classes
//
////////////////////////////////////

class CoverPageInfo
{
public:
	CoverPageInfo();
	CoverPageInfo(const TCHAR* tstrCoverPageFileName,
				  const TCHAR* tstrNote = NULL,
				  const TCHAR* tstrSubject = NULL,
				  BOOL bServerBased = FALSE);
	~CoverPageInfo();
	CoverPageInfo( const CoverPageInfo& pCoverPageInfo);
	CoverPageInfo& operator=(const CoverPageInfo& pCoverPageInfo);
	FAX_COVERPAGE_INFO_EX* GetData(){ return m_pdata;};
private:
	FAX_COVERPAGE_INFO_EX* m_pdata;
	Counter* m_pCounter;
	void _FreeData();
};

inline CoverPageInfo::CoverPageInfo():
	m_pdata(NULL),
	m_pCounter(NULL)
{
	m_pCounter = new Counter(1);
	if(!m_pCounter)
	{
		THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("CoverPageInfo, new"));
	}
}

inline CoverPageInfo::CoverPageInfo(const TCHAR* tstrCoverPageFileName,
								    const TCHAR* tstrNote,
								    const TCHAR* tstrSubject,
									BOOL bServerBased):
	m_pdata(NULL),
	m_pCounter(NULL)
{
	m_pCounter = new Counter(1);
	if(!m_pCounter)
	{
		THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("CoverPageInfo, new"));
	}
	
	m_pdata = new FAX_COVERPAGE_INFO_EX;
	if(!m_pdata)
	{
		THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("CoverPageInfo, new"));
	}
	memset(m_pdata, 0, sizeof(FAX_COVERPAGE_INFO_EX));
	m_pdata->dwSizeOfStruct = sizeof(FAX_COVERPAGE_INFO_EX);
	
	m_pdata->lptstrCoverPageFileName = _tcsdup(tstrCoverPageFileName);
	if(tstrCoverPageFileName)
		assert(m_pdata->lptstrCoverPageFileName);
	m_pdata->dwCoverPageFormat = FAX_COVERPAGE_FMT_COV;
	m_pdata->bServerBased = bServerBased;
	m_pdata->lptstrNote = _tcsdup(tstrNote);
	if(tstrNote)
		assert(m_pdata->lptstrNote);
	m_pdata->lptstrSubject = _tcsdup(tstrSubject);
	if(tstrSubject)
		assert(m_pdata->lptstrSubject);
	
}

inline CoverPageInfo::CoverPageInfo( const CoverPageInfo& pCoverPageInfo)
{
	m_pCounter = pCoverPageInfo.m_pCounter;
	m_pdata = pCoverPageInfo.m_pdata;
	++(*m_pCounter);
}

inline 	CoverPageInfo& CoverPageInfo::operator=(const CoverPageInfo& pCoverPageInfo)
{
	if(this != &pCoverPageInfo)
	{
		if(!--(*m_pCounter))
		{
			_FreeData();
		}
		m_pCounter = pCoverPageInfo.m_pCounter;
		m_pdata = pCoverPageInfo.m_pdata;
		++*m_pCounter;
		
	}
	return *this;
}

inline CoverPageInfo::~CoverPageInfo()
{
	if(!--(*m_pCounter))
	{
		_FreeData();
	}
}

inline void CoverPageInfo::_FreeData()
{
	if(m_pdata)
	{
		if(m_pdata->lptstrCoverPageFileName)
			free (m_pdata->lptstrCoverPageFileName);
		if(m_pdata->lptstrCoverPageFileName)
			free(m_pdata->lptstrNote);
		if(m_pdata->lptstrSubject)
			free(m_pdata->lptstrSubject);
	}
	delete m_pdata;
	delete m_pCounter;
}

////////////////////////////////////
// FAX_PERSONAL_PROFILE Classes
//
////////////////////////////////////

//
// PersonalProfile
//
class PersonalProfile
{
public:
	PersonalProfile(); // element in array
	PersonalProfile(const TCHAR* tstrFaxNumber);
	PersonalProfile(const FAX_PERSONAL_PROFILE& FaxPersonalProfile);
	PersonalProfile( const PersonalProfile& PProfile);
	PersonalProfile& operator=(const PersonalProfile& PProfile);
	~PersonalProfile();
	FAX_PERSONAL_PROFILE* GetData(){ return m_pdata;};
private:
	 FAX_PERSONAL_PROFILE* m_pdata;
	 Counter* m_pCounter;
	 void _FreeData();
};

inline PersonalProfile::PersonalProfile():
	m_pCounter(NULL),
	m_pdata(NULL)
{
	m_pCounter = new Counter(1);
	if(!m_pCounter)
	{
		THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("PersonalProfile, new"));
	}
}

inline PersonalProfile::PersonalProfile(const TCHAR* tstrFaxNumber):
	m_pCounter(NULL),
	m_pdata(NULL)
{
	m_pCounter = new Counter(1);
	if(!m_pCounter)
	{
		THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("PersonalProfile, new"));
	}

	m_pdata = new FAX_PERSONAL_PROFILE;
	if(!m_pdata)
	{
		THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("PersonalProfile, new"));
	}
	memset(m_pdata, 0, sizeof(FAX_PERSONAL_PROFILE));
	m_pdata->dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);
	
	m_pdata->lptstrFaxNumber = _tcsdup(tstrFaxNumber);
	if(tstrFaxNumber)
		assert(m_pdata->lptstrFaxNumber);
}

inline PersonalProfile::PersonalProfile(const FAX_PERSONAL_PROFILE& FaxPersonalProfile):
	m_pCounter(NULL),
	m_pdata(NULL)
{	  
	m_pCounter = new Counter(1);
	if(!m_pCounter)
	{
		THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("PersonalProfile, new"));
	}

	m_pdata = new FAX_PERSONAL_PROFILE;
	if(!m_pdata)
	{
		THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("PersonalProfile, new"));
	}
	memset(m_pdata, 0, sizeof(FAX_PERSONAL_PROFILE));
	m_pdata->dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);
	
	m_pdata->lptstrFaxNumber = _tcsdup(FaxPersonalProfile.lptstrFaxNumber);
	if(FaxPersonalProfile.lptstrFaxNumber)
		assert(m_pdata->lptstrFaxNumber);
	m_pdata->lptstrFaxNumber = _tcsdup(FaxPersonalProfile.lptstrFaxNumber);
		if(FaxPersonalProfile.lptstrFaxNumber)
		assert(m_pdata->lptstrFaxNumber);
	m_pdata->lptstrCompany = _tcsdup(FaxPersonalProfile.lptstrCompany);
	if(FaxPersonalProfile.lptstrCompany)
		assert(m_pdata->lptstrCompany);
    m_pdata->lptstrStreetAddress =  _tcsdup(FaxPersonalProfile.lptstrStreetAddress);
	if(FaxPersonalProfile.lptstrStreetAddress)
		assert(m_pdata->lptstrStreetAddress);
    m_pdata->lptstrCity = _tcsdup(FaxPersonalProfile.lptstrCity);
	if(FaxPersonalProfile.lptstrCity)
		assert(m_pdata->lptstrCity);
    m_pdata->lptstrState = _tcsdup(FaxPersonalProfile.lptstrState);
	if(FaxPersonalProfile.lptstrState)
		assert(m_pdata->lptstrState);
    m_pdata->lptstrZip = _tcsdup(FaxPersonalProfile.lptstrZip);
	if(FaxPersonalProfile.lptstrZip)
		assert(m_pdata->lptstrZip);
    m_pdata->lptstrCountry = _tcsdup(FaxPersonalProfile.lptstrCountry);
	if(FaxPersonalProfile.lptstrCountry)
		assert(m_pdata->lptstrCountry);
    m_pdata->lptstrTitle = _tcsdup(FaxPersonalProfile.lptstrTitle);
	if(FaxPersonalProfile.lptstrTitle)
		assert(m_pdata->lptstrTitle);
    m_pdata->lptstrDepartment = _tcsdup(FaxPersonalProfile.lptstrDepartment);
	if(FaxPersonalProfile.lptstrDepartment)
		assert(m_pdata->lptstrDepartment);
    m_pdata->lptstrOfficeLocation = _tcsdup(FaxPersonalProfile.lptstrOfficeLocation);
	if(FaxPersonalProfile.lptstrOfficeLocation)
		assert(m_pdata->lptstrOfficeLocation);
    m_pdata->lptstrHomePhone = _tcsdup(FaxPersonalProfile.lptstrHomePhone);
	if(FaxPersonalProfile.lptstrHomePhone)
		assert(m_pdata->lptstrHomePhone);
    m_pdata->lptstrOfficePhone = _tcsdup(FaxPersonalProfile.lptstrOfficePhone);
	if(FaxPersonalProfile.lptstrOfficePhone)
		assert(m_pdata->lptstrOfficePhone);
    m_pdata->lptstrOrganizationalMail = _tcsdup(FaxPersonalProfile.lptstrOrganizationalMail);
	if(FaxPersonalProfile.lptstrOrganizationalMail)
		assert(m_pdata->lptstrOrganizationalMail);
    m_pdata->lptstrInternetMail = _tcsdup(FaxPersonalProfile.lptstrInternetMail);
	if(FaxPersonalProfile.lptstrInternetMail)
		assert(m_pdata->lptstrInternetMail);
    m_pdata->lptstrBillingCode = _tcsdup(FaxPersonalProfile.lptstrBillingCode);
	if(FaxPersonalProfile.lptstrBillingCode)
		assert(m_pdata->lptstrBillingCode);
    m_pdata->lptstrTSID = _tcsdup(FaxPersonalProfile.lptstrTSID);
	if(FaxPersonalProfile.lptstrTSID)
		assert(m_pdata->lptstrTSID);

}

//copy constructor
inline PersonalProfile::PersonalProfile( const PersonalProfile& PProfile)
{
	m_pCounter = PProfile.m_pCounter;

	m_pdata = PProfile.m_pdata;
	++*m_pCounter;
}

//operator =
inline 	PersonalProfile& PersonalProfile::operator=(const PersonalProfile& PProfile)
{
	if(this != &PProfile)
	{
		if(!--(*m_pCounter))
		{
			_FreeData();
		}
		m_pCounter = PProfile.m_pCounter;
		m_pdata = PProfile.m_pdata;
		++*m_pCounter;
	}
	return *this;
}


inline PersonalProfile::~PersonalProfile()
{
	if(!--(*m_pCounter))
	{
		_FreeData();
	}
}

inline void PersonalProfile::_FreeData()
{
	if(m_pdata)
	{
		if(m_pdata->lptstrFaxNumber)
			free(m_pdata->lptstrFaxNumber);
	}
	delete m_pdata;
	delete m_pCounter;
}


//
// ListPersonalProfile
//
class ListPersonalProfile
{
public:
	ListPersonalProfile();
	ListPersonalProfile(const DWORD dwElementsNum, const PersonalProfile* pListProfile);
	~ListPersonalProfile();
	ListPersonalProfile( ListPersonalProfile& pListPersonalProfile);
	ListPersonalProfile& operator=(ListPersonalProfile& pListPersonalProfile);
	FAX_PERSONAL_PROFILE* GetData();
	PersonalProfile* GetClassData(){return m_classdata.get();};

private:
	aaptr<PersonalProfile> m_classdata;
	FAX_PERSONAL_PROFILE* m_pdata;
	DWORD m_dwElementsNum;
	Counter* m_pCounter;
	void _FreeData(){ delete m_pCounter;
					  if(m_pdata)
						delete m_pdata;};
};

inline ListPersonalProfile::ListPersonalProfile():
	m_pCounter(NULL),
	m_pdata(NULL)
{
	m_pCounter = new Counter(1);
	if(!m_pCounter)
	{
		THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("ListPersonalProfile, new"));
	}
}


inline ListPersonalProfile::ListPersonalProfile(const DWORD dwElementsNum, const PersonalProfile* pListProfile):
	m_pCounter(NULL),
	m_pdata(NULL)
{
	m_pCounter = new Counter(1);
	if(!m_pCounter)
	{
		THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("ListPersonalProfile, new"));
	}

	m_classdata = new PersonalProfile[dwElementsNum];
	if(!m_classdata.get())
	{
		THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("ListPersonalProfile, new"));
	}

	for(int index = 0; index < dwElementsNum; index++)
	{
		(m_classdata.get())[index] = pListProfile[index];
	}
	
	m_dwElementsNum = dwElementsNum;
}

inline ListPersonalProfile::ListPersonalProfile( ListPersonalProfile& pListPersonalProfile)
{
	m_pCounter = pListPersonalProfile.m_pCounter;
	m_dwElementsNum = pListPersonalProfile.m_dwElementsNum;

	m_classdata = new PersonalProfile[m_dwElementsNum];
	if(!m_classdata.get())
	{
		THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("ListPersonalProfile, new"));
	}

	for(int index = 0; index < m_dwElementsNum; index++)
	{
		(m_classdata.get())[index] = pListPersonalProfile.GetClassData()[index];
	}
	++*m_pCounter;
}

inline 	ListPersonalProfile& ListPersonalProfile::operator=(ListPersonalProfile& pListPersonalProfile)
{
	if(this != &pListPersonalProfile)
	{
		if(!--(*m_pCounter))
		{
			_FreeData();
		}
		m_pCounter = pListPersonalProfile.m_pCounter;
		m_dwElementsNum = pListPersonalProfile.m_dwElementsNum;

		m_classdata = new PersonalProfile[m_dwElementsNum];
		if(!m_classdata.get())
		{
			THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("ListPersonalProfile, new"));
		}

		for(int index = 0; index < m_dwElementsNum; index++)
		{
			(m_classdata.get())[index] = (const_cast<PersonalProfile*>(pListPersonalProfile.m_classdata.get()))[index];
		}
	
		++*m_pCounter;
		
	}
	return *this;
}
inline ListPersonalProfile::~ListPersonalProfile()
{
	if(!--(*m_pCounter))
	{
		_FreeData();
	}
		
}

inline FAX_PERSONAL_PROFILE* ListPersonalProfile::GetData()
{
	if(m_pdata)
		delete m_pdata;
	
	m_pdata = new FAX_PERSONAL_PROFILE[m_dwElementsNum];
	if(!m_pdata)
	{
		THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("ListPersonalProfile, new"));
	}

	for(int index = 0; index < m_dwElementsNum; index++)
	{
		m_pdata[index] = *((m_classdata.get())[index].GetData());
	}
	
	return m_pdata;

}


#endif // _PREPARE_JOB_PARAMS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxsender\cometfax.cpp ===
// Copyright (c) 1996-1998 Microsoft Corporation

// Module name:		fax.cpp
// Author:			Sigalit Bar (sigalitb)
// Date:			28-Jul-98


//
// Description:
//		This file contains the implementation of module "fax.h".
//



#include "CometFax.h"



// g_hHeap is a global handle to the process heap
HANDLE  g_hHeap = NULL;


//
// fnFaxPrint
//	Sends a fax containing szDocumentName to number szFaxNumber,
//	using hFaxSvcHandle as the HANDLE to the Fax Server, and 
//	returns the JobId via pdwFaxId and the last error encountered 
//	via pdwLastError.
//	Returns TRUE on success (job queued to Fax Server Queue successfully)
//	and FALSE on failure.
//
BOOL
fnFaxPrint(
    HANDLE    /* IN */	hFaxSvcHandle,	//handle to the fax service
    LPCTSTR   /* IN */	szFaxNumber,	//fax number to call
    LPCTSTR   /* IN */	szDocumentName,	//name of document to fax
    LPCTSTR   /* IN */	szCPName,		//name of cover page to fax
    LPDWORD  /* OUT */	pdwFaxId,		//pointer to set to the fax job id of the fax
	LPDWORD	 /* OUT */	pdwLastError,	//pointer to set to last error encountered during send
    DWORDLONG*  /* OUT */	pdwlMessageId		//pointer to set to the fax msg id of the fax
)
{
	DWORD				dwRecipientJobs = 0;
	DWORD				dwLoopIndex = 0;
	DWORD				dwJobId = 0;
	DWORDLONG			dwlMessageId = 0;
	BOOL				fRetVal = FALSE;

	_ASSERTE(NULL != pdwLastError);

    // FaxJobParams is the FAX_JOB_PARAM struct
    FAX_JOB_PARAM       FaxJobParams;

    // Initialize the FAX_JOB_PARAM struct
    ZeroMemory(&FaxJobParams, sizeof(FAX_JOB_PARAM));

    // Set the FAX_JOB_PARAM struct
    FaxJobParams.SizeOfStruct = sizeof(FAX_JOB_PARAM);
    FaxJobParams.RecipientNumber = szFaxNumber;
    FaxJobParams.RecipientName = szFaxNumber;
    FaxJobParams.ScheduleAction = JSA_NOW;	//send fax immediately

	// pCPInfo is the pointer to the FAX_COVERPAGE_INFO struct
	PFAX_COVERPAGE_INFO pCPInfo = NULL;
	// CPInfo is the FAX_COVERPAGE_INFO struct
	FAX_COVERPAGE_INFO CPInfo;
	// Initialize the FAX_COVERPAGE_INFO struct
	ZeroMemory(&CPInfo, sizeof(FAX_COVERPAGE_INFO));
	if (NULL != szCPName)
	{
		// Set the FAX_COVERPAGE_INFO struct
		CPInfo.SizeOfStruct = sizeof(FAX_COVERPAGE_INFO);
		CPInfo.CoverPageName = _tcsdup(szCPName);
		if (NULL == CPInfo.CoverPageName)
		{
			(*pdwLastError) = ::GetLastError();
			::lgLogError(
				LOG_SEV_1, 
				TEXT("_tcsdup returned NULL with GetLastError=%d\n"),
				(*pdwLastError));
			goto ExitFunc;
		}
		CPInfo.Note = TEXT("NOTE1\nNOTE2\nNOTE3\nNOTE4");
		CPInfo.Subject = TEXT("SUBJECT");	

		pCPInfo = &CPInfo;
	}

    if (!FaxSendDocument(hFaxSvcHandle, szDocumentName, &FaxJobParams, pCPInfo, &dwJobId))
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxSendDocument returned FALSE with GetLastError=%d\n"),
			(*pdwLastError));
		goto ExitFunc;
    }

#ifndef _NT5FAXTEST
//
// Extended private API - MessageId available
//
	if (pdwlMessageId)
	{
		PFAX_JOB_ENTRY_EX		pFaxRecipientJobs = NULL;

		//
		// get the job's dwlMessageId
		//
		if (!FaxEnumJobsEx(hFaxSvcHandle, JT_SEND, &pFaxRecipientJobs, &dwRecipientJobs))
		{
			(*pdwLastError) = ::GetLastError();
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FaxEnumJobsEx returned FALSE with GetLastError=%d\n"),
				(*pdwLastError));
			goto ExitFunc;
		}
		_ASSERTE(pFaxRecipientJobs);
		_ASSERTE(dwRecipientJobs);

		for (dwLoopIndex = 0; dwLoopIndex < dwRecipientJobs; dwLoopIndex++)
		{
			if (pFaxRecipientJobs[dwLoopIndex].pStatus->dwJobID == dwJobId)
			{
				// this is our job => get the msg id
				dwlMessageId = pFaxRecipientJobs[dwLoopIndex].dwlMessageId;
			}
		}
		_ASSERTE(dwlMessageId);

		(*pdwlMessageId) = dwlMessageId;
	}
#endif // #ifndef _NT5FAXTEST

	(*pdwFaxId) = dwJobId;
	fRetVal = TRUE;

ExitFunc:
    return fRetVal;
}


#ifdef _NT5FAXTEST
//
// fnFaxPrintBroadcast_OLD
//	Sends a fax containing szDocumentName to number szFaxNumber,
//	using hFaxSvcHandle as the HANDLE to the Fax Server, and 
//	returns the JobId via pdwFaxId and the last error encountered 
//	via pdwLastError.
//	Returns TRUE on success (job queued to Fax Server Queue successfully)
//	and FALSE on failure.
//
BOOL
fnFaxPrintBroadcast_OLD(
    IN	HANDLE    	hFaxSvcHandle,	//handle to the fax service
    IN	LPCTSTR   	szDocumentName,	//name of document to fax
    IN	LPVOID    	pContext,		//pointer to a CFaxBroadcastObj 
    OUT	LPDWORD  	pdwFaxId,		//pointer to set to the fax job id of the fax
	OUT	LPDWORD	 	pdwLastError	//pointer to set to last error encountered during send
)
{
	BOOL fRetVal = FALSE;

	if (NULL == pContext)
	{
		(*pdwLastError) = E_INVALIDARG;
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\nfnFaxPrintBroadcast got a NULL pContext\n"),
			TEXT(__FILE__),
			__LINE__
			);
        goto ExitFunc;
	}

/*
	// FaxSendDocumentForBroadcast not defined in new winfax.h
	// TO DO: release from comment once we re-implement FaxSendDocumentForBroadcast

    if (!FaxSendDocumentForBroadcast(
				hFaxSvcHandle, 
				szDocumentName, 
				pdwFaxId, 
				DefaultFaxRecipientCallback, 
				pContext
				)
		) 
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxSendDocumentForBroadcast returned FALSE with GetLastError=%d\n"),
			(*pdwLastError));
        goto ExitFunc;
    }

  	fRetVal = TRUE;
*/
	//
	// Start HACK - FaxSendDocumentForBroadcast not defined in new winfax.h (so fail)
	//
	_ASSERTE(FALSE);
  	fRetVal = FALSE;
	*pdwLastError = ERROR_CALL_NOT_IMPLEMENTED;
	::lgLogError(
		LOG_SEV_1, 
		TEXT("FILE:%s LINE:%d\nReturning *pdwLastError=ERROR_CALL_NOT_IMPLEMENTED since FaxSendDocumentForBroadcast not defined in new winfax.h\n"),
		TEXT(__FILE__),
		__LINE__
		);
	//
	// End HACK - FaxSendDocumentForBroadcast not defined in new winfax.h
	//

ExitFunc:
    return(fRetVal);
}

#else // ! _NT5FAXTEST
//
// fnFaxPrintBroadcast_NEW
//	Sends a fax containing szDocumentName to number szFaxNumber,
//	using hFaxSvcHandle as the HANDLE to the Fax Server, and 
//	returns the JobId via pdwFaxId and the last error encountered 
//	via pdwLastError.
//	Returns TRUE on success (job queued to Fax Server Queue successfully)
//	and FALSE on failure.
//
BOOL
fnFaxPrintBroadcast_NEW(
    HANDLE		/* IN */	hFaxSvcHandle,	//handle to the fax service
    LPCTSTR		/* IN */	szDocumentName,	//name of document to fax
    LPVOID		/* IN */	pContext,		//pointer to a CFaxBroadcastObj 
    LPDWORD		/* OUT */	pdwFaxId,		//pointer to set to the fax job id of the fax
	LPDWORD		/* OUT */	pdwLastError,	//pointer to set to last error encountered during send
    DWORDLONG*  /* OUT */	pdwlParentMessageId,//pointer to set to the fax msg id of the fax
	DWORDLONG**	/* OUT */	ppdwlRecipientIds,	// array of recipient ids
	DWORD*		/* OUT */	pdwNumOfRecipients	//number of recipient ids in pdwlRecipientIds	
)
{
	BOOL fRetVal = FALSE;
    CFaxBroadcast*          pFaxBroadcast  = NULL;
    PFAX_COVERPAGE_INFO_EX  pCoverPageInfo = NULL;
    PFAX_PERSONAL_PROFILE   pRecipientList = NULL;
    DWORD                   dwNumRecipients = 0;
    FAX_JOB_PARAM_EX        JobParams;
    DWORDLONG               dwlParentJobId  = 0;
    PDWORDLONG              pdwlTmpRecipientIds = NULL;
    FAX_PERSONAL_PROFILE    Sender;
    DWORD                   dwLoopIndex = 0;

    //START declerations
    //////////////////////////////////////////////////////
    // HACK to support legacy notifications mechanism	//
    //////////////////////////////////////////////////////
    PFAX_JOB_ENTRY_EX pJobEntry = NULL;
	PFAX_JOB_ENTRY_EX pBroadcastJobEntry = NULL;
    DWORD             dwRecipient0SessionJobId = 0;
    DWORD             dwParentSessionJobId = 0;
    //////////////////////////////////////////////////////
    // HACK to support legacy notifications mechanism	//
    //////////////////////////////////////////////////////
    //END declerations

	// caller must have both ppdwlRecipientIds and pdwNumOfRecipients
	// NULL, or both not NULL
	if (NULL != ppdwlRecipientIds)
	{
		_ASSERTE(NULL != pdwNumOfRecipients);
	}
	else
	{
		_ASSERTE(NULL == pdwNumOfRecipients);
	}

	if (NULL == pContext)
	{
		(*pdwLastError) = E_INVALIDARG;
		::lgLogError(
			LOG_SEV_1, 
			TEXT("fnFaxPrintBroadcast got a NULL pContext\n")
			);
        goto ExitFunc;
	}
    pFaxBroadcast = (CFaxBroadcast*) pContext;
    if (FALSE == pFaxBroadcast->GetBroadcastParams(
                                    &pCoverPageInfo,
                                    &dwNumRecipients,
                                    &pRecipientList
                                    )
       )
    {
		(*pdwLastError) = E_INVALIDARG;
        goto ExitFunc;
    }
    // NOTE: GetBroadcastParams may return dwNumRecipients=0 and pRecipientList=NULL 

    // alloc recipient id array pdwTmpRecipientIds 
    if (0 != dwNumRecipients)
    {
        pdwlTmpRecipientIds = (PDWORDLONG) malloc (dwNumRecipients*sizeof(DWORDLONG));
        if (NULL == pdwlTmpRecipientIds)
        {
            (*pdwLastError) = ::GetLastError();
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("File=%s Line=%d\nmalloc failed with err=0x%08X\n"),
                TEXT(__FILE__),
                __LINE__,
                (*pdwLastError)
			    );
            goto ExitFunc;
        }
        ZeroMemory(pdwlTmpRecipientIds, dwNumRecipients*sizeof(DWORDLONG));
    }

    // Set JobParams
    ZeroMemory(&JobParams, sizeof(FAX_JOB_PARAM_EX));
    JobParams.dwSizeOfStruct = sizeof(FAX_JOB_PARAM_EX);
    JobParams.dwScheduleAction = JSA_NOW;	//send fax immediately
	JobParams.lptstrDocumentName = TEXT("Doc Display Name");

    // Set Sender profile
    ZeroMemory(&Sender, sizeof(FAX_PERSONAL_PROFILE));
    Sender.dwSizeOfStruct =sizeof(FAX_PERSONAL_PROFILE);

    // Send
    if (FALSE == ::FaxSendDocumentEx(
                        hFaxSvcHandle, 
                        szDocumentName,
                        pCoverPageInfo,
                        &Sender,
                        dwNumRecipients,
                        pRecipientList,
                        &JobParams,
                        &dwlParentJobId,
                        pdwlTmpRecipientIds
                        )
       )
    {
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxSendDocumentEx returned FALSE with GetLastError=%d\n"),
			(*pdwLastError));
        goto ExitFunc;
    }

	// removing the hack below
	// now causes FaxBVT.exe to not work with 
	// g_fUseExtendedEvents=FALSE and _NT5FAXTEST not defined
	dwParentSessionJobId = 0xcdcdcdcd; //HACK to avoid an assert
//
//	The hack below is currently removed because there is
//	no way of getting the session id of a parent job
//	(FaxGetParentJobId was removed and
//	FaxGetJobEx fails with invalid param for parent job id)
//
/*
    //START
    //////////////////////////////////////////////////////
    // HACK to support legacy notifications mechanism	//
    //////////////////////////////////////////////////////
    // we need to get a DWORD session id for the parent job 
    // so we can see its notifications

    // first get a session id for a recipient
    if (!FaxGetJobEx(hFaxSvcHandle, pdwlTmpRecipientIds[0], &pJobEntry))
    {
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE: %s LINE: %d\nFaxGetJobEx returned FALSE with GetLastError=%d\n"),
            TEXT(__FILE__),
            __LINE__,
			(*pdwLastError));
        goto ExitFunc;
    }
    _ASSERTE(pJobEntry);
    dwRecipient0SessionJobId = pJobEntry->pStatus->dwJobID;
	::lgLogDetail(
		LOG_X,
        1, 
		TEXT("FILE: %s LINE: %d\ndwlRecipientJobId = %i64u\ndwlBroadcastId = %i64u"),
        TEXT(__FILE__),
        __LINE__,
		pdwlTmpRecipientIds[0],
		dwlParentJobId
        );

    // now, get the parent session id to support legacy notification mechanism

//
//	FaxGetParentJobId was removed from fxsapi.dll (but we may put it back)
//
//    if (!FaxGetParentJobId(hFaxSvcHandle, dwRecipient0SessionJobId, &dwParentSessionJobId))
//    {
//		(*pdwLastError) = ::GetLastError();
//		::lgLogError(
//			LOG_SEV_1, 
//			TEXT("FILE: %s LINE: %d\nFaxGetParentJobId returned FALSE with GetLastError=%d\n"),
//            TEXT(__FILE__),
//            __LINE__,
//			(*pdwLastError));
//        goto ExitFunc;
//    }
//

//
//	Currently, FaxGetJobEx fails with invalid param for parent job id 
//	(we may change this for testing)
//
	if (!FaxGetJobEx(hFaxSvcHandle, dwlParentJobId, &pBroadcastJobEntry))
    {
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE: %s LINE: %d\nFaxGetJobEx returned FALSE with GetLastError=%d\n"),
            TEXT(__FILE__),
            __LINE__,
			(*pdwLastError));
        goto ExitFunc;
    }
    _ASSERTE(pBroadcastJobEntry);
    _ASSERTE(pBroadcastJobEntry->pStatus);
    dwParentSessionJobId = pBroadcastJobEntry->pStatus->dwJobID;

  ::lgLogDetail(
		LOG_X,
        1, 
		TEXT("FILE: %s LINE: %d\ndwParentSessionJobId = %d\n"),
        TEXT(__FILE__),
        __LINE__,
		dwParentSessionJobId
        );
    //////////////////////////////////////////////////////
    // HACK to support legacy notifications mechanism	//
    //////////////////////////////////////////////////////
    //END
*/

    // log all ids
	::lgLogDetail(
		LOG_X,
        3, 
		TEXT("\nParentJobId = %I64x with %d Recipients\n"),
		dwlParentJobId,
        dwNumRecipients
        );
    for (dwLoopIndex = 0; dwLoopIndex < dwNumRecipients; dwLoopIndex++)
    {
		::lgLogDetail(
			LOG_X,
            3, 
			TEXT("\nJobId of Recipient(%d) = %I64x\n"),
            dwLoopIndex,
			pdwlTmpRecipientIds[dwLoopIndex]
            );
    }

    // set OUT params
    (*pdwFaxId) = dwParentSessionJobId;
	(*pdwLastError) = ERROR_SUCCESS;

	if (pdwlParentMessageId)
	{
		(*pdwlParentMessageId) = dwlParentJobId;
	}
	if (ppdwlRecipientIds)
	{
		(*ppdwlRecipientIds) = pdwlTmpRecipientIds;
		_ASSERTE(pdwNumOfRecipients);
		(*pdwNumOfRecipients) = dwNumRecipients;
	}
	fRetVal = TRUE;

ExitFunc:
    // free all tmp allocs
	if (pCoverPageInfo)
    {
        free(pCoverPageInfo->lptstrCoverPageFileName);
        free(pCoverPageInfo);
    }
    if (pRecipientList)
    {
        for (dwLoopIndex = 0; dwLoopIndex < dwNumRecipients; dwLoopIndex++)
        {
            free(pRecipientList[dwLoopIndex].lptstrFaxNumber);
        }
        free(pRecipientList);
    }
   	if (NULL == ppdwlRecipientIds)
	{
		// we don't have any use for the allocated pdwlTmpRecipientIds =>
		// free it
		free(pdwlTmpRecipientIds);
	}
    FaxFreeBuffer(pJobEntry);
    return(fRetVal);
}

#endif // #ifdef _NT5FAXTEST


//
// PortIsSendEnabled
//	Checks if device with id dwDeviceId is configured as "send enabled"
//	according to the configuration described by pFaxPortsConfig, with
//	dwNumFaxPorts representing the number of ports that pFaxPortsConfig
//	contains.
//
BOOL
PortIsSendEnabled(
    PFAX_PORT_INFO  /* IN */ pFaxPortsConfig,	//array of FAX_PORT_INFO structs
    DWORD           /* IN */ dwNumFaxPorts,		//number of FAX_PORT_INFO structs in above array
    DWORD           /* IN */ dwDeviceId			//id of device in question
)
{
	DWORD dwIndex;
    for (dwIndex = 0; dwIndex < dwNumFaxPorts; dwIndex++) 
	{
        if (pFaxPortsConfig[dwIndex].DeviceId != dwDeviceId) continue;
		if (pFaxPortsConfig[dwIndex].Flags & FPF_SEND)
		{
            return TRUE;
        }
    }
	return FALSE;
}


//
// SendFax:
//	Sends a fax containing the document szDocumentName to fax number
//	szFaxNumber and collects all the FAX_EVENT@s from hCompletionPort
//	into SendInfo. The fax job id is returned via pdwFaxId and the
//	last error encountered is returned via pdwLastError.
//
// IMPORTANT:
//	This is a SYNCHRONOUS send.
//	The function waits until the fax session has completed, accumulating
//	all the FAX_EVENT@s generated by the send job into the OUT parameter
//	SendInfo.
//
BOOL
SendFax(
    LPCTSTR		/* IN */	szFaxNumber,
    LPCTSTR		/* IN */	szDocumentName,
	LPCTSTR		/* IN */	szCPName,
	LPCTSTR		/* IN */	szMachineName,
	HANDLE		/* IN */	hCompletionPort,
	LPVOID		/* IN */	pContext,
    LPDWORD		/* OUT */	pdwFaxId,
    DWORDLONG*	/* OUT */	pdwlMessageId,
	CSendInfo&	/* OUT */	SendInfo,
	LPDWORD		/* OUT */	pdwLastError
)
{
	// hFaxSvcHandle is the handle to the local fax service
    HANDLE				hFaxSvcHandle	= NULL;
    // pFaxSvcConfig is a pointer to the fax service configuration
    PFAX_CONFIGURATION  pFaxSvcConfig	= NULL;
    // pFaxPortsConfig is a pointer to the fax ports configuration
    PFAX_PORT_INFO      pFaxPortsConfig	= NULL;
    // dwNumFaxPorts is the number of fax ports
    DWORD               dwNumFaxPorts;
    // dwNumAvailFaxPorts is the number of send enabled fax ports
    DWORD               dwNumAvailFaxPorts;
    // pFaxEvent is a pointer to the fax port event
    PFAX_EVENT          pFaxEvent = NULL;
    // pFaxInfo is a pointer to the FAX_INFO structs
    PFAX_INFO           pFaxInfo = NULL;
	// broadcast obj 
	CFaxBroadcast* thisBroadcastObj = NULL;
	// function's return value
	BOOL fReturnValue = FALSE;

	// fxsapi.dll function pointers
	LPVOID pVoidFunc = NULL;
	DWORDLONG*	pdwlTmpMessageId = NULL;
	DWORDLONG**	ppdwlRecipientIds = NULL;
	DWORD*		pdwNumOfRecipients = NULL;

	//Check that we can set *pdwLastError
	if (NULL == pdwLastError)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SendFax Called with pdwLastError parameter equal to NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != pdwLastError);
        goto ExitFunc;
	}
	(*pdwLastError) = ERROR_SUCCESS; //if all will be well *pdwLastError will remain so.

	//Check that we can set *pdwFaxId
	if (NULL == pdwFaxId)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SendFax Called with pdwFaxId parameter equal to NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != pdwFaxId);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
	}

	//Check that we can set *pdwlMessageId
	if (NULL == pdwlMessageId)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SendFax Called with pdwlMessageId parameter equal to NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != pdwlMessageId);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
	}

	//
	//If Completion port is not initialized return ERROR_INVALID_PARAM in *pdwLastError
	//
	if (!hCompletionPort) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SendFax Called with hCompletionPort parameter equal to NULL (ERROR_INVALID_PARAM returned)\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != hCompletionPort);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
    }

	//
    // Get the handle to the process heap
	//
    g_hHeap = GetProcessHeap();
	if (NULL == g_hHeap)
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d GetProcessHeap returned NULL pointer with GetLastError=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
			(*pdwLastError));
        goto ExitFunc;
	}

	//
    // Connect to the fax service
	//
	hFaxSvcHandle = NULL;
    if (!FaxConnectFaxServer(szMachineName, &hFaxSvcHandle)) 
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxConnectFaxServer returned FALSE with GetLastError=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
			(*pdwLastError));
        goto ExitFunc;
    }
	//WHITE BOX tells us that a Fax Service HANDLE
	//is in actuality a pointer to a node in a linked list =>
	//for maximum verification, we check the API didn't return NULL
	_ASSERTE(hFaxSvcHandle);

	//
	// Retrieve the fax service configuration
	//
    if (!FaxGetConfiguration(hFaxSvcHandle, &pFaxSvcConfig)) 
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxGetConfiguration returned FALSE with GetLastError=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
			(*pdwLastError));
        goto ExitFunc;
    }
	//This API returns a pointer, so for max verification
	//we check it is not NULL
	_ASSERTE(pFaxSvcConfig);

	//
	//We set the Retries parameter to 0 
	//since we want a single try (no retry).       
	//
	pFaxSvcConfig->Retries = 0;
	//Q:
	//check that not paused
	//pFaxSvcConfig->PauseServerQueue = 0;

/*
	//BUG - getting 0xC0000005 (AV) error
    if (!FaxSetConfiguration(hFaxSvcHandle, pFaxSvcConfig)) 
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxSetConfiguration returned FALSE with GetLastError=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
			(*pdwLastError));
        goto ExitFunc;
    }
*/

	//
    // Retrieve the fax ports configuration
	//
    if (!FaxEnumPorts(hFaxSvcHandle, &pFaxPortsConfig, &dwNumFaxPorts)) 
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxEnumPorts returned FALSE with GetLastError=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
			(*pdwLastError));
        goto ExitFunc;
    }
	//API returns pointer to port config, for max
	//verification we check it isn't NULL
	_ASSERTE(pFaxPortsConfig);
	//API returns number of ports, for max verification
	//we check it isn't 0.
	_ASSERTE(dwNumFaxPorts);
	//Note: We ASSERT because...
	//There must be at least one port, otherwise the
	//Fax Service would not start 
	//(FaxConnectFaxService would have failed).
	//In any way if this is the situation (pFaxPortsConfig==NULL)
	//or (dwNumFaxPorts == 0) we cannot continue
	//since faxes cannot be sent.


	//
    // Retrieve the number of send enabled fax ports
	//
	DWORD dwIndex;
    for (dwIndex = 0, dwNumAvailFaxPorts = 0; dwIndex < dwNumFaxPorts; dwIndex++) 
	{
        if (pFaxPortsConfig[dwIndex].Flags & FPF_SEND) 
		{
            dwNumAvailFaxPorts++;
        }
    }
	//If there are no send enabled ports, then return with FALSE and ERROR_INVALID_DATA
    if (0 == dwNumAvailFaxPorts) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("There are no Send enabled ports. Fax will not be sent\n"));
		(*pdwLastError) = ERROR_INVALID_DATA;
        goto ExitFunc;
    }

	//
    // Initialize the FAX_INFO struct 
	// pFaxInfo is used to indicate completion and pass or fail
	// inside the following while on GetQueuedCompletionStatus loop.
	//
    pFaxInfo = (PFAX_INFO)HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, sizeof(FAX_INFO));
	if (NULL == pFaxInfo)
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d HeapAlloc returned NULL pointer with GetLastError=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
			(*pdwLastError));
        goto ExitFunc;
	}


#ifndef _NT5FAXTEST
	// Testing Bos Fax (with new fxsapi.dll)
	pdwlTmpMessageId = &(pFaxInfo->dwlMessageId);
	ppdwlRecipientIds = &(pFaxInfo->pdwlRecipientMessageIds);
	pdwNumOfRecipients = &(pFaxInfo->dwNumOfRecipients);
	// Note: when testing NT5Fax 
	//		 pdwlMessageId  and ppdwlRecipientIds remain NULL
	//		 and pdwNumOfRecipients remains 0
#endif

	//
	// Log the doc name and fax number of fax.
	//
	if (NULL == pContext) //this is a regular fax
	{
		::lgLogDetail(
			LOG_X, 
			3, 
			TEXT("Printing a fax:\n  Document Name: %s\n  Fax Number: %s.\n"), 
			szDocumentName, 
			szFaxNumber);

		//
		// "Print" the fax (no cover page)
		// Actually fnFaxPrint just adds the job to the Fax Service queue.
		//
		if (!fnFaxPrint(
				hFaxSvcHandle, 
				szFaxNumber, 
				szDocumentName, 
				szCPName, 
				&(pFaxInfo->dwFaxId), 
				pdwLastError,
				pdwlTmpMessageId
				)
			) 
		{
			goto ExitFunc;
		}

		pFaxInfo->dwNumOfRecipients = 1; // this is a non-broadcast fax
	}
	else	//this is a broadcast
	{
		::lgLogDetail(
			LOG_X, 
			3, 
			TEXT("Printing a broadcast:\n  Document Name: %s\n"), 
			szDocumentName
			);
		thisBroadcastObj = (CFaxBroadcast*)pContext;
		thisBroadcastObj->outputAllToLog(LOG_X,1);

#ifndef _NT5FAXTEST
		// Testing Bos Fax (with new fxsapi.dll)

		//
		// Broadcast the fax 
		//
		if (!fnFaxPrintBroadcast(
				hFaxSvcHandle,
				szDocumentName, 
				pContext,
				&(pFaxInfo->dwFaxId), 
				pdwLastError,
				pdwlTmpMessageId, 
				ppdwlRecipientIds,
				pdwNumOfRecipients
				)
			) 
		{
			goto ExitFunc;
		}
#else
		// Testing NT5 Fax (with old winfax.dll)

		//
		// Broadcast the fax 
		//
		if (!fnFaxPrintBroadcast(
				hFaxSvcHandle,
				szDocumentName, 
				pContext,
				&(pFaxInfo->dwFaxId), 
				pdwLastError
				)
			) 
		{
			goto ExitFunc;
		}
#endif

	}


	//if succeeded log that fax was queued
	::lgLogDetail(
		LOG_X,
		4, 
		TEXT("Fax queuing SUCCESS. JobId=%u dwlMessageId=%I64u\n"),
		pFaxInfo->dwFaxId,
		pFaxInfo->dwlMessageId
		);
	(*pdwFaxId) = pFaxInfo->dwFaxId;
	(*pdwlMessageId) = pFaxInfo->dwlMessageId;


	fReturnValue = WatchFaxEvents(
						hCompletionPort,
						pFaxPortsConfig,
						dwNumFaxPorts,
						dwNumAvailFaxPorts,
						pFaxInfo, 
						SendInfo, 
						pdwLastError
						);
	if (FALSE == fReturnValue)
	{
		goto ExitFunc;
	}

	//fReturnValue is defaultly FALSE and 
	//is should be true only if WatchFax@Events succeeded.

ExitFunc:

    // Free the FAX_INFO struct
	if (NULL != pFaxInfo)
	{
		free(pFaxInfo->pdwlRecipientMessageIds);

		if (FALSE == ::HeapFree(g_hHeap, 0, pFaxInfo))
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%d HeapFree returned FALSE with GetLastError=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError());
		}
	}

    // Free the fax ports configuration
	if (NULL != pFaxPortsConfig) FaxFreeBuffer(pFaxPortsConfig);
	if (NULL != pFaxSvcConfig) FaxFreeBuffer(pFaxSvcConfig);

    // Disconnect from the fax service
	if (NULL != hFaxSvcHandle)
	{
		if (!FaxClose(hFaxSvcHandle))
		{
			(*pdwLastError) = ::GetLastError();
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%d FaxClose returned FALSE with GetLastError=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				(*pdwLastError)
				);
			fReturnValue = FALSE;
		}
	}

    return fReturnValue;
}


//
// AbortFax
//	Aborts the fax job with dwJobId on the local Fax Server,
//	and returns the last error encountered via pdwLastError.
//
// IMPORTANT:
//	This is an ASYNCHRONOUS abort.
//	It delivers the abort request to the local Fax Server 
//	and returns.
//
BOOL AbortFax(
	LPCTSTR		/* IN */	szMachineName,
	const DWORD	/* IN */	dwJobId,
	LPDWORD		/* OUT */	pdwLastError)
{
	BOOL fReturnValue = FALSE;
	HANDLE hFaxSvcHandle = NULL;
	PMY_FAX_JOB_ENTRY JobsArray = NULL;

	//Check that we can set *pdwLastError
	if (NULL == pdwLastError)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d pdwLastError parameter is equal to NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}
	(*pdwLastError) = ERROR_SUCCESS;

    // Connect to the local fax service
    if (!FaxConnectFaxServer(szMachineName, &hFaxSvcHandle)) 
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxConnectFaxServer returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			(*pdwLastError));
		goto ExitFunc;
    }

	//
	// Get an array of jobs on queue
	//
	DWORD dwJobsNum;
	if (!MyFaxEnumJobs(hFaxSvcHandle,&JobsArray,&dwJobsNum))
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxEnumJobs returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			(*pdwLastError));
		goto ExitFunc;
	}


	//
	// Log whether this job is on queue
	//
	DWORD index;
	BOOL fJobExists; // do NOT put =FALSE on this line, it causes compile error
					 // because of "goto ExitLevel1" above.
	fJobExists = FALSE;
	for (index=0;index<dwJobsNum;index++)
	{
		if (MyGetJobId(JobsArray[index]) == dwJobId)
		{
			fJobExists = TRUE;
		}
	}
	if (fJobExists)
	{
		::lgLogDetail(LOG_X, 7, TEXT("Job#%d EXISTS on queue."),dwJobId);
	}
	else
	{
		::lgLogDetail(LOG_X, 7, TEXT("Job#%d does NOT EXIST on queue."),dwJobId);
	}

	//
	// Abort the job
	//
	//Note: Even if job not on queue we call this API
	if (!FaxAbort(hFaxSvcHandle,dwJobId)) 
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxAbort returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			(*pdwLastError));
		goto ExitFunc;
    }

	::lgLogDetail(LOG_PASS, 1, TEXT("Abort job#%d PASS\n"),dwJobId);
	fReturnValue = TRUE;

ExitFunc:
	//Free JobsArray
	if (NULL != JobsArray) FaxFreeBuffer(JobsArray);

	//Free hFaxSvcHandle
	if (NULL != hFaxSvcHandle)
	{
		if (!FaxClose(hFaxSvcHandle)) 
		{
			(*pdwLastError) = ::GetLastError();
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%d FaxClose returned FALSE with GetLastError=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				(*pdwLastError));
		}
	}

    return(fReturnValue);
}



//
// InitFaxQueue:
//	Initializes the Fax Service queue so that it will post
//	all FAX_EVENTs to an I\O completion port.
//
BOOL InitFaxQueue(
	LPCTSTR		/* IN */	szMachineName,
	HANDLE&		/* OUT */	hComPortHandle,
	DWORD&		/* OUT */	dwLastError,
	HANDLE&		/* OUT */	hServerEvents
	)
{
	dwLastError = ERROR_SUCCESS;	//if func succeeds - OUT DWORD is ERROR_SUCCESS
	hComPortHandle = NULL;			//if func fails - OUT HANDLE is NULL'ed

	HANDLE hCompletionPort = NULL;
	HANDLE hFaxSvcHandle = NULL;
	BOOL fReturnValue = FALSE;

#ifndef _NT5FAXTEST
//
// Use extended notifications mechanism
//
	DWORD	dwEventTypes = 0;
	hServerEvents = NULL;
#endif

    // Connect to the fax service
    if (!FaxConnectFaxServer(szMachineName, &hFaxSvcHandle)) 
	{
		dwLastError = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxConnectFaxServer returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			dwLastError);
        goto ExitFunc;
    }

    // Create the completion port
    hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1);
    if (NULL == hCompletionPort) 
	{
		dwLastError = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d CreateIoCompletionPort returned FALSE with GetLastError=%d\n"), 
			TEXT(__FILE__),
			__LINE__,
			dwLastError);
        goto ExitFunc;
    }

#ifdef _NT5FAXTEST
//
// Use legacy notifications mechanism
//
	// Initialize the fax event queue
	if (!FaxInitializeEventQueue(hFaxSvcHandle, hCompletionPort, 0, NULL, 0)) 
	{
		dwLastError = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxInitializeEventQueue returned FALSE with GetLastError=0x%08x\n"), 
			TEXT(__FILE__),
			__LINE__,
			dwLastError);
		goto ExitFunc;
	}
#else // ! _NT5FAXTEST
//
// Use extended notifications mechanism
//
	dwEventTypes = (	FAX_EVENT_TYPE_IN_QUEUE	|
						FAX_EVENT_TYPE_OUT_QUEUE |
						FAX_EVENT_TYPE_CONFIG |
						FAX_EVENT_TYPE_ACTIVITY	|
						FAX_EVENT_TYPE_QUEUE_STATE |
						FAX_EVENT_TYPE_IN_ARCHIVE |
						FAX_EVENT_TYPE_OUT_ARCHIVE |
						FAX_EVENT_TYPE_FXSSVC_ENDED
					); // all server events

	if (!FaxRegisterForServerEvents(
								hFaxSvcHandle,
								dwEventTypes,
								hCompletionPort,
								0,
								NULL,
								0,
								&hServerEvents
								)
		)
	{
		dwLastError = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\nFaxRegisterForServerEvents returned FALSE with GetLastError=0x%08x\n"), 
			TEXT(__FILE__),
			__LINE__,
			dwLastError);
		goto ExitFunc;
	}
#endif // #ifdef _NT5FAXTEST

	hComPortHandle = hCompletionPort;
	fReturnValue = TRUE;

ExitFunc:
	//
    // Disconnect from the fax service
	//
	if (NULL != hFaxSvcHandle)
	{
		if(!FaxClose(hFaxSvcHandle))
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%d FaxClose returned FALSE with GetLastError=%d\n"), 
				TEXT(__FILE__),
				__LINE__,
				::GetLastError());
		}
	}
	if (FALSE == fReturnValue)
	{
		if (hCompletionPort)
		{
			// Close the completion port
			if(!CloseHandle(hCompletionPort))
			{
				::lgLogError(
					LOG_SEV_1, 
					TEXT("FILE:%s LINE:%d\nCloseHandle returned FALSE with GetLastError=%d\n"), 
					TEXT(__FILE__),
					__LINE__,
					::GetLastError());
			}
			hCompletionPort = NULL;
		}
	}

    return fReturnValue;
}


#ifdef _NT5FAXTEST
//
// WatchFaxLegacyEvents:
//	collects all the FAX_EVENTs of the job with pFaxInfo->dwFaxId 
//  from hCompletionPort.
//	last error encountered is returned via pdwLastError.
//
BOOL
WatchFaxLegacyEvents(
	HANDLE			/* IN */	hCompletionPort,
    PFAX_PORT_INFO	/* IN */	pFaxPortsConfig,
    DWORD			/* IN */	dwNumFaxPorts,
    DWORD			/* IN */	dwNumAvailFaxPorts,
	PFAX_INFO	/* IN OUT */	pFaxInfo,
	CSendInfo&	/* OUT */		SendInfo,
	LPDWORD		/* OUT */		pdwLastError
)
{
    // pFaxEvent is a pointer to the fax port event
    PFAX_EVENT          pFaxEvent = NULL;
    DWORD               dwBytes = 0;
    ULONG_PTR           pulCompletionKey = 0;
	// function's return value
	BOOL fReturnValue = FALSE;

	::lgLogDetail(
		LOG_X,
		7,
		TEXT("FILE: %s LINE:%d\n[WatchFaxLegacyEvents] Entry"),
		TEXT(__FILE__),
		__LINE__
		);

	//Check that we can set *pdwLastError
	if (NULL == pdwLastError)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SendFax Called with pdwLastError parameter equal to NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != pdwLastError);
        goto ExitFunc;
	}
	(*pdwLastError) = ERROR_SUCCESS; //if all will be well *pdwLastError will remain so.

	//Check pFaxInfo is valid
	if (NULL == pFaxInfo)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SendFax Called with pFaxInfo parameter equal to NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != pFaxInfo);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
	}

	//Check dwFaxId is valid
	if (0 == pFaxInfo->dwFaxId)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SendFax Called with pFaxInfo->dwFaxId parameter equal to 0\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(0 != pFaxInfo->dwFaxId);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
	}

	//
	//If Completion port is not initialized return ERROR_INVALID_PARAM in *pdwLastError
	//
	if (!hCompletionPort) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SendFax Called with hCompletionPort parameter equal to NULL (ERROR_INVALID_PARAM returned)\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != hCompletionPort);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
    }

	//
	//If pFaxPortsConfig is NULL return ERROR_INVALID_PARAM in *pdwLastError
	//
	if (!pFaxPortsConfig) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SendFax Called with pFaxPortsConfig parameter equal to NULL (ERROR_INVALID_PARAM returned)\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != pFaxPortsConfig);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
    }

	//
	//If dwNumFaxPorts is 0 return ERROR_INVALID_PARAM in *pdwLastError
	//
	if (0 == dwNumFaxPorts) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SendFax Called with dwNumFaxPorts parameter equal to 0 (ERROR_INVALID_PARAM returned)\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(0 != dwNumFaxPorts);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
    }

	//
	//If dwNumAvailFaxPorts is NULL return ERROR_INVALID_PARAM in *pdwLastError
	//
	if (0 == dwNumAvailFaxPorts) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SendFax Called with dwNumAvailFaxPorts parameter equal to 0 (ERROR_INVALID_PARAM returned)\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(0 != dwNumAvailFaxPorts);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
    }

	//
	// Handle fax events on the completion port
	//
	BOOL fReturnValueOfGetQueuedCompletionStatus;
    while ( fReturnValueOfGetQueuedCompletionStatus =
			::GetQueuedCompletionStatus(
				hCompletionPort, 
				&dwBytes, 
				&pulCompletionKey, 
				(LPOVERLAPPED *) &pFaxEvent, 
				MAX_COMP_PORT_WAIT_TIME) 
			) 
	{
		//check that pFaxEvent is legitimate
		//if not log and return FALSE and ERROR_INVALID_DATA
		if (FALSE == _CrtIsValidPointer((const void*) pFaxEvent, sizeof(FAX_EVENT), TRUE) )
		{
			(*pdwLastError) = ERROR_INVALID_DATA;
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%d _CrtIsValidPointer returned FALSE\n"),
				TEXT(__FILE__),
				__LINE__
				);
			goto ExitFunc;
		}

		//We are only interested in events with a specific JobId
		//and the general (non-job related) events with JobId -1
		if ((pFaxEvent->JobId != pFaxInfo->dwFaxId) && (-1 != pFaxEvent->JobId)) 
		{
			goto ContinueWhile; 
		}

		//
		// Handle the different types of events
		//
		switch (pFaxEvent->EventId)
		{

		//
		// General events with JobId=-1
		//

		case FEI_FAXSVC_ENDED:				
			//This is a JobId=-1 event.
			_ASSERTE(pFaxEvent->JobId == -1);
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
            break;

		case FEI_FAXSVC_STARTED:
			//This is a JobId=-1 event.
			_ASSERTE(pFaxEvent->JobId == -1);
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
            break;

		case FEI_INITIALIZING:
			//This is a JobId=-1 event.
			_ASSERTE(pFaxEvent->JobId == -1);
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
            break;

		case FEI_MODEM_POWERED_OFF:
			//This is a JobId=-1 event.
			_ASSERTE(pFaxEvent->JobId == -1);
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			//If a send enabled port was powered off
			//we update the number of ports "available"
			//for sending.
            if (
				::PortIsSendEnabled(
					pFaxPortsConfig,
					dwNumFaxPorts,
					pFaxEvent->DeviceId
					)
				) 
			{
				dwNumAvailFaxPorts--;
			}
			//If there are no more send enabled ports
			//then fax cannot be sent, so we return FALSE
			//and ERROR_INVALID_DATA
            if (0 == dwNumAvailFaxPorts) 
			{
				::lgLogError(LOG_SEV_1, TEXT("There are no send enablede Fax ports.\n"));
				(*pdwLastError) = ERROR_INVALID_DATA;
                goto ExitFunc;
            }
			else
			{
				//At any case we want to log how many ports remain
				//Even if there was actually no change
				::lgLogDetail(
					LOG_X,
					4, 
					TEXT("There are %d available Fax ports.\n"),
					dwNumAvailFaxPorts);
			}
            break;

		case FEI_MODEM_POWERED_ON:
			//This is a JobId=-1 event.
			_ASSERTE(pFaxEvent->JobId == -1);
			//We suspect this event is never generated, so "hack"
			_ASSERTE(FALSE); 
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			//If this port is send enabled, then increment
			//the number of "available" send ports
            if (
				::PortIsSendEnabled(
					pFaxPortsConfig,
					dwNumFaxPorts,
					pFaxEvent->DeviceId
					)
				) 
			{
				dwNumAvailFaxPorts++;
			}
			::lgLogDetail(LOG_X,4, TEXT("There are %d send enabled Fax ports.\n"),dwNumAvailFaxPorts);
            break;

        case FEI_RINGING:
			//This is a JobId=-1 event.
			_ASSERTE(pFaxEvent->JobId == -1);
			//The Fax Service detected that
			//one of its devices is ringing
			//Not interesting => dismiss.
			break;

        case FEI_IDLE:
			//This is a JobId=-1 event.
			_ASSERTE(pFaxEvent->JobId == -1);
            // If job is complete then we return TRUE
            if ((pFaxInfo->bComplete) && (pFaxEvent->DeviceId == pFaxInfo->dwDeviceId))
			{
				// Add Event to OUT parameter 
				SendInfo.AddItem(*pFaxEvent);
				// We return TRUE, since we exit earlier if the send failed
				fReturnValue = TRUE;
				goto ExitFunc;
            }
            break;

		//
		// Send job events
		//

        case FEI_DIALING:
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			//Set the device used to perform the send job
			pFaxInfo->dwDeviceId = pFaxEvent->DeviceId;
			//Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
            break;

        case FEI_NO_DIAL_TONE:
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// This event should have the DeviceId that was used to dial
			_ASSERTE(pFaxEvent->DeviceId == pFaxInfo->dwDeviceId);
			//This event indicates that send failed.
			//Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_NO_DAIL_TONE for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			(*pdwLastError) = ERROR_INVALID_DATA;
            goto ExitFunc;

        case FEI_JOB_QUEUED:
        case FEI_HANDLED: //TO DO: make sure what we want here Esp. pFaxEvent->DeviceId == ???
        case FEI_SENDING:		
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// This event should have the DeviceId that was used to dial
			_ASSERTE(pFaxEvent->DeviceId == pFaxInfo->dwDeviceId);
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
            break;

        case FEI_LINE_UNAVAILABLE:
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// This event should have the DeviceId that was used to dial
			_ASSERTE(pFaxEvent->DeviceId == pFaxInfo->dwDeviceId);
			//This event indicates that send failed.
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_LINE_UNAVAILABLE for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			(*pdwLastError) = ERROR_INVALID_DATA;
            goto ExitFunc;

        case FEI_BUSY:
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// This event should have the DeviceId that was used to dial
			_ASSERTE(pFaxEvent->DeviceId == pFaxInfo->dwDeviceId);
			//This event indicates that send failed.
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_BUSY for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			(*pdwLastError) = ERROR_INVALID_DATA;
            goto ExitFunc;

        case FEI_NO_ANSWER:
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// This event should have the DeviceId that was used to dial
			_ASSERTE(pFaxEvent->DeviceId == pFaxInfo->dwDeviceId);
			//This event indicates that send failed.
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_NO_ANSWER for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			(*pdwLastError) = ERROR_INVALID_DATA;
            goto ExitFunc;

        case FEI_FATAL_ERROR:
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// a FATAL_ERROR can happen before dialing so 
			// pFaxInfo->dwDeviceId might still 0 =>
			// This event should have the DeviceId that was used to dial or 0
			_ASSERTE((pFaxEvent->DeviceId == pFaxInfo->dwDeviceId) || (0 == pFaxInfo->dwDeviceId));
			//This event indicates that send failed.
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_FATAL_ERROR for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			(*pdwLastError) = ERROR_INVALID_DATA;
            goto ExitFunc;

        case FEI_COMPLETED:
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// This event should have the DeviceId that was used to dial
			_ASSERTE(pFaxEvent->DeviceId == pFaxInfo->dwDeviceId);
			//This event indicates that send succeeded.
			//But we stil wait for the idle event of this device.
			//set the complete flag
			pFaxInfo->bComplete = TRUE;
			// Set the pass flag
			pFaxInfo->bPass = TRUE;
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
            break;

        case FEI_ABORTING:
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// a FATAL_ERROR can happen before dialing so 
			// pFaxInfo->dwDeviceId might still 0 =>
			// This event should have the DeviceId that was used to dial or 0
			_ASSERTE((pFaxEvent->DeviceId == pFaxInfo->dwDeviceId) || (0 == pFaxInfo->dwDeviceId));
			// Set the complete flag
			pFaxInfo->bComplete = TRUE;
			// Set the pass flag
			pFaxInfo->bPass = FALSE;
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_ABORTING for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			(*pdwLastError) = ERROR_INVALID_DATA;
            goto ExitFunc;

        case FEI_DELETED:
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// This event should have the DeviceId that was used to dial
			_ASSERTE(pFaxEvent->DeviceId == pFaxInfo->dwDeviceId);
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			// Set the complete flag
			pFaxInfo->bComplete = TRUE;
			// Set the pass flag
			if (0 == pFaxEvent->DeviceId)
			{
				//this is a broadcast job => ok
				pFaxInfo->bPass = TRUE;
				fReturnValue = TRUE;
			}
			else 
			{
				//this is a regular job => failure
				pFaxInfo->bPass = FALSE;
				::lgLogError(
					LOG_SEV_1, 
					TEXT("FEI_DELETED for job %d on port %d"),
					pFaxEvent->JobId,
					pFaxEvent->DeviceId
					);
				(*pdwLastError) = ERROR_INVALID_DATA;
			}
			goto ExitFunc;

        case FEI_DISCONNECTED:		//CAN ??
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// This event should have the DeviceId that was used to dial
			_ASSERTE(pFaxEvent->DeviceId == pFaxInfo->dwDeviceId);
			// Set the complete flag
			pFaxInfo->bComplete = TRUE;
			// Set the pass flag
			pFaxInfo->bPass = FALSE;
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_DISCONNECTED for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			(*pdwLastError) = ERROR_INVALID_DATA;
            goto ExitFunc;

        case FEI_BAD_ADDRESS:		
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// This event should have the DeviceId that was used to dial
			_ASSERTE(pFaxEvent->DeviceId == pFaxInfo->dwDeviceId);
			// Set the complete flag
			pFaxInfo->bComplete = TRUE;
			// Set the pass flag
			pFaxInfo->bPass = FALSE;
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_BAD_ADDRESS for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			(*pdwLastError) = ERROR_INVALID_DATA;
            goto ExitFunc;

        case FEI_CALL_DELAYED:		
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// This event should have the DeviceId that was used to dial
			_ASSERTE(pFaxEvent->DeviceId == pFaxInfo->dwDeviceId);
			// Set the complete flag
			pFaxInfo->bComplete = TRUE;
			// Set the pass flag
			pFaxInfo->bPass = FALSE;
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_CALL_DELAYED for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			(*pdwLastError) = ERROR_INVALID_DATA;
            goto ExitFunc;

        case FEI_CALL_BLACKLISTED:	
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// This event should have the DeviceId that was used to dial
			_ASSERTE(pFaxEvent->DeviceId == pFaxInfo->dwDeviceId);
			// Set the complete flag
			pFaxInfo->bComplete = TRUE;
			// Set the pass flag
			pFaxInfo->bPass = FALSE;
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_CALL_BLACKLISTED for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			(*pdwLastError) = ERROR_INVALID_DATA;
            goto ExitFunc;

		//
		// Receive job events
		//

        case FEI_RECEIVING:			
		//We should never get this event
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_RECEIVING for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			_ASSERTE(FALSE);			
			break;

        case FEI_NOT_FAX_CALL:		
		//We should never get this event
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_NOT_FAX_CALL for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			_ASSERTE(FALSE);			
			break;

        case FEI_ANSWERED:			
		//We should never get this event
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_ANSWERED for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			_ASSERTE(FALSE);			
			break;

		//
		// Routing job events
		//

        case FEI_ROUTING:
		//We should never get this event
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_ROUTING for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			_ASSERTE(FALSE);			
			break;

        default:
			::lgLogError(
				LOG_SEV_4, 
				TEXT("FILE:%s LINE:%d SEND FAX FATAL ERROR - State out of enumaration scope 0x%x.\n"),
				TEXT(__FILE__),
				__LINE__,
                pFaxEvent->EventId
                );
			_ASSERTE(FALSE);
            break;
		}

ContinueWhile:
        // Free the pFaxEvent packet
        if (NULL != ::LocalFree(pFaxEvent))
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%d LocalFree did not return NULL with GetLastError=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError()
				);
			//we do NOT exit the function upon such an error and do not return FALSE.
		}
		pFaxEvent = NULL;
    }

	//
	//Check if we left while because GetQueuedCompletionStatus failed
	//
	if (FALSE == fReturnValueOfGetQueuedCompletionStatus)
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d GetQueuedCompletionStatus returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			(*pdwLastError)
			);
		goto ExitFunc;
	}

	//fReturnValue is defaultly FALSE and 
	//is set to TRUE at relevent cases inside switch.

ExitFunc:
	//Free any "left over" pFaxEvent
	if (NULL != pFaxEvent)
	{
        if (NULL != ::LocalFree(pFaxEvent))
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%d LocalFree did not return NULL with GetLastError=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError());
		}
	}

    return fReturnValue;
}

#else // ! _NT5FAXTEST

///
//
// HandleOutQueueEvent:
//
BOOL
HandleOutQueueExtendedEvent(
	PFAX_EVENT_EX	/* IN */	pFaxEventEx,
	PFAX_INFO	/* IN OUT */	pFaxInfo,
	CSendInfo&	/* OUT */		SendInfo,
	LPDWORD		/* OUT */		pdwLastError
)
{
	BOOL			fRetVal = FALSE;
	FAX_EVENT_JOB	JobInfo = {0};
	PFAX_JOB_STATUS	pJobData = NULL;
    DWORD           dwQueueStatus = 0;
    DWORD           dwExtendedStatus = 0;
    LPCTSTR         lpctstrExtendedStatus = NULL;
	DWORDLONG		dwlMessageId = 0;
	LPCTSTR			strQueueStatus = NULL;
	LPCTSTR			strExtendedStatus = NULL;


	::lgLogDetail(
		LOG_X,
		7,
		TEXT("FILE:%s LINE:%d [HandleOutQueueExtendedEvent] Entry"),
		TEXT(__FILE__),
		__LINE__
		);

	_ASSERTE(pFaxEventEx);
	_ASSERTE(pFaxInfo);
	_ASSERTE(pdwLastError);
	_ASSERTE(FAX_EVENT_TYPE_OUT_QUEUE == pFaxEventEx->EventType);

	//
	// get field values from pFaxEventEx
	// 
	JobInfo = (pFaxEventEx->EventInfo).JobInfo;
	pJobData = JobInfo.pJobData;
	dwlMessageId = JobInfo.dwlMessageId;

	switch(JobInfo.Type)
	{
		case FAX_JOB_EVENT_TYPE_ADDED:
		case FAX_JOB_EVENT_TYPE_REMOVED:
			//_ASSERTE(dwlMessageId == pFaxInfo->dwlMessageId);
			SendInfo.AddItem(*pFaxEventEx);
			break;

		case FAX_JOB_EVENT_TYPE_STATUS:
		dwQueueStatus = pJobData->dwQueueStatus;
		dwExtendedStatus = pJobData->dwExtendedStatus;
		strQueueStatus = GetQueueStatusTStr(dwQueueStatus);
		strExtendedStatus = GetExtendedStatusTStr(dwExtendedStatus);
		if (pJobData->lpctstrExtendedStatus)
		{
			lpctstrExtendedStatus = pJobData->lpctstrExtendedStatus;
		}
		else
		{
			lpctstrExtendedStatus = TEXT("(null)");
		}
		switch (dwQueueStatus)
		{
			case JS_INPROGRESS:
				if (JS_EX_PROPRIETARY <= dwExtendedStatus)
				{
					// this is a proprietary extended status so 
					// do nothing
					SendInfo.AddItem(*pFaxEventEx);
					break;
				}
				switch (dwExtendedStatus)
				{
					case JS_EX_INITIALIZING:
						//_ASSERTE(dwlMessageId == pFaxInfo->dwlMessageId);
						//Set the device used to perform the send job
						_ASSERTE(pFaxInfo->dwDeviceId == pJobData->dwDeviceID);
						//pFaxInfo->dwDeviceId = pJobData->dwDeviceID;
						SendInfo.AddItem(*pFaxEventEx);
						break;

					case JS_EX_DIALING:
						//_ASSERTE(dwlMessageId == pFaxInfo->dwlMessageId);
						//Set the device used to perform the send job
						pFaxInfo->dwDeviceId = pJobData->dwDeviceID;
						SendInfo.AddItem(*pFaxEventEx);
						break;

					case JS_EX_TRANSMITTING:
					case JS_EX_HANDLED:
                    case JS_EX_CALL_COMPLETED:
						//_ASSERTE(dwlMessageId == pFaxInfo->dwlMessageId);
						_ASSERTE(pFaxInfo->dwDeviceId == pJobData->dwDeviceID);
						SendInfo.AddItem(*pFaxEventEx);
						break;

					default:
						::lgLogError(
							LOG_SEV_1, 
							TEXT("FILE:%s LINE:%d [HandleOutQueueExtendedEvent]\nGot QueueStatus=%s ExtendedStatus=%s lpctstrExtendedStatus=%s for messageId=%I64u on port %d"),
							TEXT(__FILE__),
							__LINE__,
							strQueueStatus,
							strExtendedStatus,
							lpctstrExtendedStatus,
							dwlMessageId,
							pJobData->dwDeviceID
							);
						_ASSERTE(FALSE);
						goto ExitFunc;
						break;
				} //switch (dwExtendedStatus)
				break;

	        case JS_COMPLETED:
				//_ASSERTE(dwlMessageId == pFaxInfo->dwlMessageId);
				_ASSERTE(pFaxInfo->dwDeviceId == pJobData->dwDeviceID);
				if (1 == pFaxInfo->dwNumOfRecipients)
				{
					// this is a regular (non-broadcast) fax
					pFaxInfo->bComplete = TRUE;
					pFaxInfo->bPass = TRUE;
				}
				else
				{
					// this is a broadcast fax
					_ASSERTE(pFaxInfo->dwNumOfCompletedRecipients < pFaxInfo->dwNumOfRecipients);
					pFaxInfo->dwNumOfCompletedRecipients++; // mark that a recipient completed
					if (pFaxInfo->dwNumOfCompletedRecipients == pFaxInfo->dwNumOfRecipients)
					{
						// all the recipients completed =>
						// broadcast is completed
						pFaxInfo->bComplete = TRUE;
						pFaxInfo->bPass = TRUE;
					}
				}
				SendInfo.AddItem(*pFaxEventEx);
				break;

			case JS_RETRIES_EXCEEDED:
			case JS_FAILED:
			case JS_RETRYING:
				switch (dwExtendedStatus)
				{
					case JS_EX_LINE_UNAVAILABLE:
					case JS_EX_BUSY:
					case JS_EX_NO_ANSWER:
					case JS_EX_BAD_ADDRESS:
					case JS_EX_FATAL_ERROR:
					case JS_EX_NO_DIAL_TONE:
					case JS_EX_DISCONNECTED:
					case JS_EX_CALL_DELAYED:
					case JS_EX_CALL_BLACKLISTED:
						//_ASSERTE(dwlMessageId == pFaxInfo->dwlMessageId);
						_ASSERTE(pFaxInfo->dwDeviceId == pJobData->dwDeviceID);
						//This event indicates that send failed.
						SendInfo.AddItem(*pFaxEventEx);
						::lgLogError(
							LOG_SEV_1, 
							TEXT("FILE:%s LINE:%d [HandleOutQueueExtendedEvent]\nGot QueueStatus=%s ExtendedStatus=%s lpctstrExtendedStatus=%s for messageId=%I64u on port %d"),
							TEXT(__FILE__),
							__LINE__,
							strQueueStatus,
							strExtendedStatus,
							lpctstrExtendedStatus,
							dwlMessageId,
							pJobData->dwDeviceID
							);
						(*pdwLastError) = ERROR_INVALID_DATA;
						goto ExitFunc;
						break;

					default:
						//_ASSERTE(dwlMessageId == pFaxInfo->dwlMessageId);
						_ASSERTE(pFaxInfo->dwDeviceId == pJobData->dwDeviceID);
						//This event indicates that send failed.
						SendInfo.AddItem(*pFaxEventEx);
						::lgLogError(
							LOG_SEV_1, 
							TEXT("FILE:%s LINE:%d [HandleOutQueueExtendedEvent]\nExtendedStatus Out of Scope - QueueStatus=%s ExtendedStatus=%s lpctstrExtendedStatus=%s for messageId=%I64u on port %d"),
							TEXT(__FILE__),
							__LINE__,
							strQueueStatus,
							strExtendedStatus,
							lpctstrExtendedStatus,
							dwlMessageId,
							pJobData->dwDeviceID
							);
						_ASSERTE(FALSE);
						goto ExitFunc;
						break;

				} //switch (dwExtendedStatus)
				break;

			case JS_DELETING:
			case JS_CANCELED:
				//_ASSERTE(dwlMessageId == pFaxInfo->dwlMessageId);
				_ASSERTE(pFaxInfo->dwDeviceId == pJobData->dwDeviceID);
				//This event indicates that send failed.
				SendInfo.AddItem(*pFaxEventEx);
				::lgLogError(
					LOG_SEV_1, 
					TEXT("FILE:%s LINE:%d [HandleOutQueueExtendedEvent]\nGot QueueStatus=%s ExtendedStatus=%s lpctstrExtendedStatus=%s for messageId=%I64u on port %d"),
					TEXT(__FILE__),
					__LINE__,
					strQueueStatus,
					strExtendedStatus,
					lpctstrExtendedStatus,
					dwlMessageId,
					pJobData->dwDeviceID
					);
				(*pdwLastError) = ERROR_INVALID_DATA;
				goto ExitFunc;
				break;

			default:
				::lgLogError(
					LOG_SEV_1, 
					TEXT("FILE:%s LINE:%d [HandleOutQueueExtendedEvent]\nQueueStatus Out of Scope - QueueStatus=%s ExtendedStatus=%s lpctstrExtendedStatus=%s for messageId=%I64u on port %d"),
					TEXT(__FILE__),
					__LINE__,
					strQueueStatus,
					strExtendedStatus,
					lpctstrExtendedStatus,
					dwlMessageId,
					pJobData->dwDeviceID
					);
				_ASSERTE(FALSE);
				(*pdwLastError) = ERROR_INVALID_DATA;
				goto ExitFunc;
				break;

		} //switch (dwQueueStatus)
		break;

		default:
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%d [HandleOutQueueExtendedEvent]\n- JobInfo.Type=0x%08X is out of enumaration scope\n"),
				TEXT(__FILE__),
				__LINE__,
				JobInfo.Type
				);
			_ASSERTE(FALSE);
			break;
	} //switch(JobInfo.Type)

	fRetVal = TRUE;

ExitFunc:
	return(fRetVal);
}


///
//
// WatchFaxExtendedEvents:
//	collects all the FAX_EVENT_EXs of the job with pFaxInfo->dwFaxId 
//  from hCompletionPort.
//	last error encountered is returned via pdwLastError.
//
BOOL
WatchFaxExtendedEvents(
	HANDLE			/* IN */	hCompletionPort,
    PFAX_PORT_INFO	/* IN */	pFaxPortsConfig,
    DWORD			/* IN */	dwNumFaxPorts,
    DWORD			/* IN */	dwNumAvailFaxPorts,
	PFAX_INFO	/* IN OUT */	pFaxInfo,
	CSendInfo&	/* OUT */		SendInfo,
	LPDWORD		/* OUT */		pdwLastError
)
{
	BOOL				fReturnValue = FALSE;
    // pFaxEvent is a pointer to the fax port event
    PFAX_EVENT_EX       pFaxEventEx = NULL;
    DWORD               dwBytes = 0;
    ULONG_PTR           pulCompletionKey = 0;
	FAX_EVENT_JOB		EventJobInfo = {0};
	DWORD				dwLoopIndex = 0;
	BOOL				fOneOfMyRecipientMsgIds = FALSE;

	::lgLogDetail(
		LOG_X,
		7,
		TEXT("FILE: %s LINE:%d\n[WatchFaxExtendedEvents] Entry"),
		TEXT(__FILE__),
		__LINE__
		);

	//Check that we can set *pdwLastError
	if (NULL == pdwLastError)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d [WatchFaxExtendedEvents]\nGot pdwLastError == NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != pdwLastError);
        goto ExitFunc;
	}
	(*pdwLastError) = ERROR_SUCCESS; //if all will be well *pdwLastError will remain so.

	//Check pFaxInfo is valid
	if (NULL == pFaxInfo)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d [WatchFaxExtendedEvents]\nGot pFaxInfo parameter == NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != pFaxInfo);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
	}

	//Check dwFaxId is valid
	if (0 == pFaxInfo->dwFaxId)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d [WatchFaxExtendedEvents]\nGot pFaxInfo->dwFaxId == 0\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(0 != pFaxInfo->dwFaxId);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
	}

	//
	//If Completion port is not initialized return ERROR_INVALID_PARAM in *pdwLastError
	//
	if (!hCompletionPort) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d [WatchFaxExtendedEvents]\nGot hCompletionPort == NULL (ERROR_INVALID_PARAM returned)\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != hCompletionPort);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
    }

	//
	//If pFaxPortsConfig is NULL return ERROR_INVALID_PARAM in *pdwLastError
	//
	if (!pFaxPortsConfig) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d [WatchFaxExtendedEvents]\nGot pFaxPortsConfig == NULL (ERROR_INVALID_PARAM returned)\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != pFaxPortsConfig);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
    }

	//
	//If dwNumFaxPorts is 0 return ERROR_INVALID_PARAM in *pdwLastError
	//
	if (0 == dwNumFaxPorts) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d [WatchFaxExtendedEvents]\nGot dwNumFaxPorts == 0 (ERROR_INVALID_PARAM returned)\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(0 != dwNumFaxPorts);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
    }

	//
	//If dwNumAvailFaxPorts is NULL return ERROR_INVALID_PARAM in *pdwLastError
	//
	if (0 == dwNumAvailFaxPorts) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d [WatchFaxExtendedEvents]\nGot dwNumAvailFaxPorts == 0 (ERROR_INVALID_PARAM returned)\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(0 != dwNumAvailFaxPorts);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
    }

	//
	// Handle fax events on the completion port
	//
	BOOL fReturnValueOfGetQueuedCompletionStatus;
    while ( fReturnValueOfGetQueuedCompletionStatus =
			::GetQueuedCompletionStatus(
				hCompletionPort, 
				&dwBytes, 
				&pulCompletionKey, 
				(LPOVERLAPPED *) &pFaxEventEx, 
				MAX_COMP_PORT_WAIT_TIME) 
			) 
	{
		//check that pFaxEvent is legitimate
		//if not log and return FALSE and ERROR_INVALID_DATA
		if (FALSE == _CrtIsValidPointer((const void*) pFaxEventEx, sizeof(FAX_EVENT_EX), TRUE) )
		{
			(*pdwLastError) = ERROR_INVALID_DATA;
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%d [WatchFaxExtendedEvents]\n_CrtIsValidPointer returned FALSE\n"),
				TEXT(__FILE__),
				__LINE__
				);
			goto ExitFunc;
		}

		//We are only interested in OUT_QUEUE events with a specific JobId.
		//Other events we simply log.
		switch (pFaxEventEx->EventType)
		{
			case FAX_EVENT_TYPE_IN_QUEUE:
			case FAX_EVENT_TYPE_CONFIG:
			case FAX_EVENT_TYPE_ACTIVITY:
			case FAX_EVENT_TYPE_QUEUE_STATE:
			case FAX_EVENT_TYPE_IN_ARCHIVE:
			case FAX_EVENT_TYPE_OUT_ARCHIVE:
				// this is not an event regarding our send job (so just log it)
				LogExtendedEvent(pFaxEventEx);
				goto ContinueWhile; 
				break;

			case FAX_EVENT_TYPE_OUT_QUEUE:
				EventJobInfo = (pFaxEventEx->EventInfo).JobInfo;
				if ( NULL == pFaxInfo->pdwlRecipientMessageIds )
				{
					// this is a regular (non-broadcast) fax
					if (EventJobInfo.dwlMessageId != pFaxInfo->dwlMessageId)
					{
						// this is not an event regarding our send job
						LogExtendedEvent(pFaxEventEx);
						goto ContinueWhile; 
					}
				}
				else
				{
					// this is a broadcast fax
					_ASSERTE(pFaxInfo->dwNumOfRecipients);
					fOneOfMyRecipientMsgIds = FALSE;
					for (dwLoopIndex = 0; dwLoopIndex < pFaxInfo->dwNumOfRecipients; dwLoopIndex++)
					{
						if (EventJobInfo.dwlMessageId == pFaxInfo->pdwlRecipientMessageIds[dwLoopIndex])
						{
							fOneOfMyRecipientMsgIds = TRUE;
						}
					}
					if (FALSE == fOneOfMyRecipientMsgIds)
					{
						// this is not an event regarding our send job
						LogExtendedEvent(pFaxEventEx);
						goto ContinueWhile; 
					}
				}
				// this is an event regarding our send job
				if (!HandleOutQueueExtendedEvent(
											pFaxEventEx,
											pFaxInfo,
											SendInfo,
											pdwLastError
											)
				   )
				{
					// failure
					goto ExitFunc;
				}
				if (TRUE == pFaxInfo->bComplete)
				{
					// completed successfully
					_ASSERTE(TRUE == pFaxInfo->bPass);
					goto ExitWhile;
				}
				break;

			default:
				::lgLogError(
					LOG_SEV_1, 
					TEXT("FILE:%s LINE:%d [WatchFaxExtendedEvents]\n- pFaxEventEx->EventType=0x%08X is out of enumaration scope\n"),
					TEXT(__FILE__),
					__LINE__,
					pFaxEventEx->EventType
					);
				_ASSERTE(FALSE);
				break;
		}

ContinueWhile:
        // Free the pFaxEvent packet
        FaxFreeBuffer(pFaxEventEx);
		pFaxEventEx = NULL;
    }

ExitWhile:
	//
	//Check if we left while because GetQueuedCompletionStatus failed
	//
	if (FALSE == fReturnValueOfGetQueuedCompletionStatus)
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d GetQueuedCompletionStatus returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			(*pdwLastError)
			);
		goto ExitFunc;
	}

	// we only get here if all is ok
	_ASSERTE(TRUE == pFaxInfo->bPass);
	_ASSERTE(TRUE == pFaxInfo->bComplete);
	fReturnValue = TRUE; 

ExitFunc:
	//Free any "left over" pFaxEvent
	if (NULL != pFaxEventEx)
	{
        FaxFreeBuffer(pFaxEventEx);
		pFaxEventEx = NULL;
	}

    return fReturnValue;
}

#endif // #ifdef _NT5FAXTEST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxsender\personalprofile.h ===
#ifndef __PERSONAL_PROFILE_H__
#define __PERSONAL_PROFILE_H__

typedef struct _FAX_PERSONAL_PROFILEA
{
    DWORD      dwSizeOfStruct;              // Size of this structure
    LPSTR      lptstrName;                  // Name of person
    LPSTR      lptstrFaxNumber;             // Fax number
    LPSTR      lptstrCompany;               // Company name
    LPSTR      lptstrStreetAddress;         // Street address
    LPSTR      lptstrCity;                  // City
    LPSTR      lptstrState;                 // State
    LPSTR      lptstrZip;                   // Zip code
    LPSTR      lptstrCountry;               // Country
    LPSTR      lptstrTitle;                 // Title
    LPSTR      lptstrDepartment;            // Department
    LPSTR      lptstrOfficeLocation;        // Office location
    LPSTR      lptstrHomePhone;             // Phone number at home
    LPSTR      lptstrOfficePhone;           // Phone number at office
    LPSTR      lptstrEmail;                 // Personal e-mail address
    LPSTR      lptstrBillingCode;           // Billing code
    LPSTR      lptstrTSID;                  // Tsid
} FAX_PERSONAL_PROFILEA, *PFAX_PERSONAL_PROFILEA;
typedef struct _FAX_PERSONAL_PROFILEW
{
    DWORD      dwSizeOfStruct;              // Size of this structure
    LPWSTR     lptstrName;                  // Name of person
    LPWSTR     lptstrFaxNumber;             // Fax number
    LPWSTR     lptstrCompany;               // Company name
    LPWSTR     lptstrStreetAddress;         // Street address
    LPWSTR     lptstrCity;                  // City
    LPWSTR     lptstrState;                 // State
    LPWSTR     lptstrZip;                   // Zip code
    LPWSTR     lptstrCountry;               // Country
    LPWSTR     lptstrTitle;                 // Title
    LPWSTR     lptstrDepartment;            // Department
    LPWSTR     lptstrOfficeLocation;        // Office location
    LPWSTR     lptstrHomePhone;             // Phone number at home
    LPWSTR     lptstrOfficePhone;           // Phone number at office
    LPWSTR     lptstrEmail;                 // Personal e-mail address
    LPWSTR     lptstrBillingCode;           // Billing code
    LPWSTR     lptstrTSID;                  // Tsid
} FAX_PERSONAL_PROFILEW, *PFAX_PERSONAL_PROFILEW;
#ifdef UNICODE
typedef FAX_PERSONAL_PROFILEW FAX_PERSONAL_PROFILE;
typedef PFAX_PERSONAL_PROFILEW PFAX_PERSONAL_PROFILE;
#else
typedef FAX_PERSONAL_PROFILEA FAX_PERSONAL_PROFILE;
typedef PFAX_PERSONAL_PROFILEA PFAX_PERSONAL_PROFILE;
#endif // UNICODE

typedef const FAX_PERSONAL_PROFILEW * LPCFAX_PERSONAL_PROFILEW;
typedef const FAX_PERSONAL_PROFILEA * LPCFAX_PERSONAL_PROFILEA;

#ifdef UNICODE
        typedef LPCFAX_PERSONAL_PROFILEW LPCFAX_PERSONAL_PROFILE;
#else
        typedef LPCFAX_PERSONAL_PROFILEA LPCFAX_PERSONAL_PROFILE;
#endif

#endif // #ifndef __PERSONAL_PROFILE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxsender\streamex.cpp ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Filename: streamEx.cpp
// Author:   Sigalit Bar
// Date:     22-Jul-98
//

//
//	Description:
//	This file contains the implementation of class CostrstreamEx.
//  
//  Modified on 19-Dec-99 by Miris: 
//	Added class CotstrstreamEx implementation.
// 
//


#include "streamEx.h"



//
// cstr:
//	Returns a const string representation of the stream
//	and resets the stream's insertion point to the start
//	of the stream's buffer.
//
LPCTSTR CostrstreamEx::cstr(void)
{
	//make sure there is an "end string"
	(*this)<<ends;
	
	//ostrstream::str() returns the pointer to the stream's buffer,
	//and freezes the buffer. We are responsible to either unfreeze
	//the array or free it ourselves. 
	//we choose to unfreeze (before we return), using reset().
	char* szStr = str();	
							
	//ostrstream::str() returns NULL on error, so do we.
	if (NULL == szStr) return(NULL);	

	//
	//Handle both UNICODE and MBCS
	//

	int len = lstrlenA(szStr);
	len = len + 1;

#ifdef _UNICODE

	//we need to allocate a wchar string 
	wchar_t* wscStr = new wchar_t[len];
	if (NULL == wscStr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d malloc returned NULL\n"),
			TEXT(__FILE__),
			__LINE__);
		return(NULL);
	}

	//we need to convert the string to mb
	if ((size_t)(-1) == mbstowcs(wscStr, szStr, len))
	{
		//mbstowcs returns (size_t)(-1) on error
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d wcstombs returned -1 (cannot convert)\n"),
			TEXT(__FILE__),
			__LINE__
			);

		return(NULL);
	}

	//we reset the stream buffer
	reset();

	return((LPCWSTR) wscStr);

#else //MBCS

	//we create our own copy of the stream's buffer and return it.
	char* szStr2;
	szStr2 = _tcsdup(szStr);
	if (NULL == szStr2)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d _tcsdup returned NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return(NULL);
	}

	//we reset the stream buffer
	reset();

	return((LPCSTR) szStr2);
#endif

}


//
// reset:
//	Unfreezes the stream's buffer (if it is frozen) and
//	resets the stream's buffer.
//	That is, the insertion point of the stream is reset
//	to the start of the stream's buffer (overwriting 
//	the buffer's contents), and the stream
//	is made submissive to changes.
//
void CostrstreamEx::reset(void)
{
	rdbuf()->freeze( 0 );
	seekp(0);
}




//
// cstr:
//	Returns a copy of const tstring representation of the stream.
//
LPCTSTR CotstrstreamEx::cstr(void)
{
	//ostrstream::str() returns the pointer to the stream's buffer,
	//and freezes the buffer. 
	tstring tszStr = str();	
							
	//ostrstream::str() returns NULL on error, so do we.
	if (NULL == tszStr.c_str()) return(NULL);	

	//we create our own copy of the stream's buffer and return it.
	TCHAR* tszStr2;
	tszStr2 = _tcsdup(tszStr.c_str());
	if (NULL == tszStr2)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d _tcsdup returned NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return(NULL);
	}

	return((LPCTSTR) tszStr2);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxsender\faxbroadcast.cpp ===
//
//
// Filename:	FaxBroadcast.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		31-Dec-98
//
//


#include "FaxBroadcast.h"

//
// frees all string fields of pRecipientProfile 
//
static
VOID
FreeRecipientProfile(
    IN OUT PFAX_PERSONAL_PROFILE   pRecipientProfile 
)
{
    if (NULL == pRecipientProfile)
    {
        return;
    }
    free(pRecipientProfile->lptstrName);
    free(pRecipientProfile->lptstrFaxNumber);
    free(pRecipientProfile->lptstrCompany);
    free(pRecipientProfile->lptstrStreetAddress);
    free(pRecipientProfile->lptstrCity);
    free(pRecipientProfile->lptstrState);
    free(pRecipientProfile->lptstrZip);
    free(pRecipientProfile->lptstrCountry);
    free(pRecipientProfile->lptstrTitle);
    free(pRecipientProfile->lptstrDepartment);
    free(pRecipientProfile->lptstrOfficeLocation);
    free(pRecipientProfile->lptstrHomePhone);
    free(pRecipientProfile->lptstrOfficePhone);
    free(pRecipientProfile->lptstrEmail);
    free(pRecipientProfile->lptstrBillingCode);
    free(pRecipientProfile->lptstrTSID);
    // NULL pDstRecipientProfile
    ZeroMemory(pRecipientProfile, sizeof(FAX_PERSONAL_PROFILE));
    // but set dwSizeOfStruct
    pRecipientProfile->dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

}

//
//
// Note: if one of the string allocations fails then
//       all previous allocations are freed
//       and pDstRecipientProfile is nulled.
//       
static
BOOL
CopyRecipientProfile(
    OUT PFAX_PERSONAL_PROFILE   pDstRecipientProfile, 
    IN  LPCFAX_PERSONAL_PROFILE pSrcRecipientProfile
)
{
    BOOL fRetVal = FALSE;

    _ASSERTE(pDstRecipientProfile);
    _ASSERTE(pSrcRecipientProfile);
    _ASSERTE(sizeof(FAX_PERSONAL_PROFILE) == pSrcRecipientProfile->dwSizeOfStruct);

    // dwSizeOfStruct
    pDstRecipientProfile->dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

    // lptstrName
	if (NULL != pSrcRecipientProfile->lptstrName)
    {
	    pDstRecipientProfile->lptstrName = ::_tcsdup(pSrcRecipientProfile->lptstrName);
	    if (NULL == pDstRecipientProfile->lptstrName)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrFaxNumber
	if (NULL != pSrcRecipientProfile->lptstrFaxNumber)
    {
	    pDstRecipientProfile->lptstrFaxNumber = ::_tcsdup(pSrcRecipientProfile->lptstrFaxNumber);
	    if (NULL == pDstRecipientProfile->lptstrFaxNumber)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrCompany
	if (NULL != pSrcRecipientProfile->lptstrCompany)
    {
	    pDstRecipientProfile->lptstrCompany = ::_tcsdup(pSrcRecipientProfile->lptstrCompany);
	    if (NULL == pDstRecipientProfile->lptstrCompany)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrStreetAddress
	if (NULL != pSrcRecipientProfile->lptstrStreetAddress)
    {
	    pDstRecipientProfile->lptstrStreetAddress = ::_tcsdup(pSrcRecipientProfile->lptstrStreetAddress);
	    if (NULL == pDstRecipientProfile->lptstrStreetAddress)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrCity
	if (NULL != pSrcRecipientProfile->lptstrCity)
    {
	    pDstRecipientProfile->lptstrCity = ::_tcsdup(pSrcRecipientProfile->lptstrCity);
	    if (NULL == pDstRecipientProfile->lptstrCity)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrState
	if (NULL != pSrcRecipientProfile->lptstrState)
    {
	    pDstRecipientProfile->lptstrState = ::_tcsdup(pSrcRecipientProfile->lptstrState);
	    if (NULL == pDstRecipientProfile->lptstrState)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrZip
	if (NULL != pSrcRecipientProfile->lptstrZip)
    {
	    pDstRecipientProfile->lptstrZip = ::_tcsdup(pSrcRecipientProfile->lptstrZip);
	    if (NULL == pDstRecipientProfile->lptstrZip)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrCountry
	if (NULL != pSrcRecipientProfile->lptstrCountry)
    {
	    pDstRecipientProfile->lptstrCountry = ::_tcsdup(pSrcRecipientProfile->lptstrCountry);
	    if (NULL == pDstRecipientProfile->lptstrCountry)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrTitle
	if (NULL != pSrcRecipientProfile->lptstrTitle)
    {
	    pDstRecipientProfile->lptstrTitle = ::_tcsdup(pSrcRecipientProfile->lptstrTitle);
	    if (NULL == pDstRecipientProfile->lptstrTitle)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrDepartment
	if (NULL != pSrcRecipientProfile->lptstrDepartment)
    {
	    pDstRecipientProfile->lptstrDepartment = ::_tcsdup(pSrcRecipientProfile->lptstrDepartment);
	    if (NULL == pDstRecipientProfile->lptstrDepartment)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrOfficeLocation
	if (NULL != pSrcRecipientProfile->lptstrOfficeLocation)
    {
	    pDstRecipientProfile->lptstrOfficeLocation = ::_tcsdup(pSrcRecipientProfile->lptstrOfficeLocation);
	    if (NULL == pDstRecipientProfile->lptstrOfficeLocation)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrHomePhone
	if (NULL != pSrcRecipientProfile->lptstrHomePhone)
    {
	    pDstRecipientProfile->lptstrHomePhone = ::_tcsdup(pSrcRecipientProfile->lptstrHomePhone);
	    if (NULL == pDstRecipientProfile->lptstrHomePhone)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrOfficePhone
	if (NULL != pSrcRecipientProfile->lptstrOfficePhone)
    {
	    pDstRecipientProfile->lptstrOfficePhone = ::_tcsdup(pSrcRecipientProfile->lptstrOfficePhone);
	    if (NULL == pDstRecipientProfile->lptstrOfficePhone)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrEmail
	if (NULL != pSrcRecipientProfile->lptstrEmail)
    {
	    pDstRecipientProfile->lptstrEmail = ::_tcsdup(pSrcRecipientProfile->lptstrEmail);
	    if (NULL == pDstRecipientProfile->lptstrEmail)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrBillingCode
	if (NULL != pSrcRecipientProfile->lptstrBillingCode)
    {
	    pDstRecipientProfile->lptstrBillingCode = ::_tcsdup(pSrcRecipientProfile->lptstrBillingCode);
	    if (NULL == pDstRecipientProfile->lptstrBillingCode)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrTSID
	if (NULL != pSrcRecipientProfile->lptstrTSID)
    {
	    pDstRecipientProfile->lptstrTSID = ::_tcsdup(pSrcRecipientProfile->lptstrTSID);
	    if (NULL == pDstRecipientProfile->lptstrTSID)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    fRetVal = TRUE;

ExitFunc:
    if (FALSE == fRetVal)
    {
        FreeRecipientProfile(pDstRecipientProfile);
    }
    return(fRetVal);
}

//
// CFaxBroadcast:
//
CFaxBroadcast::CFaxBroadcast(void):
	m_szCPFileName(NULL)
{
}

//
// ~CFaxBroadcast:
//
CFaxBroadcast::~CFaxBroadcast(void)
{

	//
	// remove (and free) all items from vector
	//
	FreeAllRecipients();
}


//
// AddRecipient:
//	Adds a recipient's profile to the broadcast.
//
// Note:
//	pRecipientProfile and all its fields are duplicated by AddRecipient.
//
BOOL CFaxBroadcast::AddRecipient(LPCFAX_PERSONAL_PROFILE /* IN */ pRecipientProfile)
{
    BOOL                    fRetVal = FALSE;
    PFAX_PERSONAL_PROFILE   pNewRecipientProfile = NULL;

    _ASSERTE(pRecipientProfile);
    _ASSERTE(sizeof(FAX_PERSONAL_PROFILE) == pRecipientProfile->dwSizeOfStruct);

    //
    // allocate the new profile
    //
    pNewRecipientProfile = (PFAX_PERSONAL_PROFILE)malloc(sizeof(FAX_PERSONAL_PROFILE));
    if (NULL == pNewRecipientProfile)
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d malloc returned NULL with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
        goto ExitFunc;
    }
    ZeroMemory(pNewRecipientProfile, sizeof(FAX_PERSONAL_PROFILE));
    pNewRecipientProfile->dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

    //
    // duplicate all string fields
    //
    if (!CopyRecipientProfile(pNewRecipientProfile, pRecipientProfile))
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d CopyRecipientProfile failed\n"),
			TEXT(__FILE__),
			__LINE__
			);
        goto ExitFunc;
    }

    //
    // Log if lptstrFaxNumber is NULL
    //
	if (NULL == pNewRecipientProfile->lptstrFaxNumber)
	{
		// we allow to add a NULL recipient number (for testing fax service)
		::lgLogDetail(
			LOG_X, 
			2,
			TEXT("FILE:%s LINE:%d pSrcRecipientProfile->lptstrFaxNumber is NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
	}

	//
	// add the new profile pointer at end of recipient list
	//
	m_FaxRecipientVector.push_back(pNewRecipientProfile);
    fRetVal = TRUE;

ExitFunc:
    if (FALSE == fRetVal)
    {
        free(pNewRecipientProfile);
    }
    return(fRetVal);
}
	
//
// ClearAllRecipients:
//	Removes all the recipient number strings from instance.
//	=> empties vector.
//
void CFaxBroadcast::ClearAllRecipients(void)
{
	m_FaxRecipientVector.clear();
}

//
// FreeAllRecipients:
//
void CFaxBroadcast::FreeAllRecipients(void)
{
	PFAX_PERSONAL_PROFILE pRecipientProfile = NULL;
	UINT uSize = m_FaxRecipientVector.size();
	UINT uIndex = 0;

	//
	//free strings in vector
	//
	for (uIndex = 0; uIndex < uSize; uIndex++)
	{
		pRecipientProfile = (PFAX_PERSONAL_PROFILE)m_FaxRecipientVector[uIndex];
        if(pRecipientProfile)
        {
            free(pRecipientProfile->lptstrName);
            free(pRecipientProfile->lptstrFaxNumber);
            free(pRecipientProfile->lptstrCompany);
            free(pRecipientProfile->lptstrStreetAddress);
            free(pRecipientProfile->lptstrCity);
            free(pRecipientProfile->lptstrState);
            free(pRecipientProfile->lptstrZip);
            free(pRecipientProfile->lptstrCountry);
            free(pRecipientProfile->lptstrTitle);
            free(pRecipientProfile->lptstrDepartment);
            free(pRecipientProfile->lptstrOfficeLocation);
            free(pRecipientProfile->lptstrHomePhone);
            free(pRecipientProfile->lptstrOfficePhone);
            free(pRecipientProfile->lptstrEmail);
            free(pRecipientProfile->lptstrBillingCode);
            free(pRecipientProfile->lptstrTSID);
            free(pRecipientProfile);
        }
		m_FaxRecipientVector[uIndex] = NULL;
	}

	//
	//empty vector
	//
	ClearAllRecipients();
}

//
// GetNumberOfRecipients:
//	Returns the number of recipients in the broadcast.
//
DWORD CFaxBroadcast::GetNumberOfRecipients(void) const
{
	return(m_FaxRecipientVector.size());
}

//
// SetCPFileName:
//	Sets the Cover Page file that will be used for the broadcast.
//
// NOTE: function has its own copy of szCPFileName,
//		 that is, it duplicates the IN param string.
BOOL CFaxBroadcast::SetCPFileName(
	LPCTSTR	/* IN */	szCPFileName
)
{
	LPTSTR szTmpCPFilename = NULL;

	if (NULL == szCPFileName)
	{
		goto ExitFunc;
	}

	//duplicate the IN param
	szTmpCPFilename = ::_tcsdup(szCPFileName);
	if (NULL == szTmpCPFilename)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
		return(FALSE);
	}

ExitFunc:
	// free previous CP filename string
	delete(m_szCPFileName);
	// set new CP filename
	m_szCPFileName = szTmpCPFilename;

	return(TRUE);
}

//
// GetCPFileName:
//	Retreives the Cover Page filename.
//
// NOTE: pszCPFileName points to a copy of m_szCPFileName
//		 Function allocates memory for OUT param, caller must free.
//
BOOL CFaxBroadcast::GetCPFileName(
	LPTSTR*	/* OUT */	pszCPFileName
) const
{
	LPTSTR szTmpCPFilename = NULL;

	//
	// check OUT param
	//
	if (NULL == pszCPFileName)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d OUT param pszCPFileName is NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

	if(NULL == m_szCPFileName)
	{
		goto ExitFunc;
	}

	//
	// copy m_szCPFileName
	//
	szTmpCPFilename = ::_tcsdup(m_szCPFileName);
	if (NULL == szTmpCPFilename)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d _tcsdup returned NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

ExitFunc:

	// set OUT param
	(*pszCPFileName) = szTmpCPFilename;

	return(TRUE);
}

//
// GetRecipient:
//	Retreives the number (as string) of a recipient in the broadcast.
//	
// NOTE: dwRecipientIndex is 1 based and the vector is 0 based.
//		 pszRecipientNumber is a copy of the requested recipient's number string.
//		 Function allocates memory for OUT param, caller must free.
//
BOOL CFaxBroadcast::GetRecipient(
	DWORD	                /* IN */	dwRecipientIndex,
	PFAX_PERSONAL_PROFILE*	/* OUT */	ppRecipientProfile
) const
{
    BOOL fRetVal = FALSE;
	PFAX_PERSONAL_PROFILE pTmpRecipientProfile = NULL;
	LPCFAX_PERSONAL_PROFILE pRecipientProfile = NULL;

	//
	// check OUT param
	//
	if (NULL == ppRecipientProfile)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d OUT param pszRecipientNumber is NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
        _ASSERTE(ppRecipientProfile);
		return(FALSE);
	}

	UINT uSize = m_FaxRecipientVector.size();
	//NOTE: dwRecipientIndex is 1 based.
	if (dwRecipientIndex > uSize)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d dwRecipientIndex (%d) > uSize (%d)\n"),
			TEXT(__FILE__),
			__LINE__,
			dwRecipientIndex,
			uSize
			);
		return(FALSE);
	}

	//NOTE: dwIndex and vector are 0 based.
	DWORD dwIndex = (dwRecipientIndex - 1);

	pRecipientProfile = m_FaxRecipientVector.at(dwIndex); // at returns the pointer
	if (NULL == pRecipientProfile)
	{
		::lgLogDetail(
			LOG_X, 
			2,
			TEXT("FILE:%s LINE:%d m_FaxRecipientVector.at(%d) returned NULL\n"),
			TEXT(__FILE__),
			__LINE__,
			dwRecipientIndex
			);
        (*ppRecipientProfile) = NULL;
		return(TRUE);
	}

    //
    // allocate the new profile
    //
    pTmpRecipientProfile = (PFAX_PERSONAL_PROFILE)malloc(sizeof(FAX_PERSONAL_PROFILE));
    if (NULL == pTmpRecipientProfile)
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d malloc returned NULL with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
        goto ExitFunc;
    }
    ZeroMemory(pTmpRecipientProfile, sizeof(FAX_PERSONAL_PROFILE));
    pTmpRecipientProfile->dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

    //
    // duplicate all string fields
    //
    if (!CopyRecipientProfile(pTmpRecipientProfile, pRecipientProfile))
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d CopyRecipientProfile failed\n"),
			TEXT(__FILE__),
			__LINE__
			);
        goto ExitFunc;
    }

    (*ppRecipientProfile) = pTmpRecipientProfile;
    fRetVal = TRUE;

ExitFunc:
    if (FALSE == fRetVal)
    {
        free(pTmpRecipientProfile);
    }
	return(fRetVal);
}

/*
//
// operator<<:
//	Appends a string representation of all the fields of a given CFaxBroadcast
//	instance.
//
CostrstreamEx& operator<<(
	IN OUT CostrstreamEx&		os, 
	IN const CFaxBroadcast&	    FaxBroadcastObj
)
{
	LPCFAX_PERSONAL_PROFILE pRecipientProfile = NULL;

    if (0 == FaxBroadcastObj.m_FaxRecipientVector.size())
	{
		os<<"No Recipients"<<endl;
		return(os);
	}

	os<<endl;
	LPCSTR str = NULL;
	UINT uSize = FaxBroadcastObj.m_FaxRecipientVector.size();
	int index = 0;
	for (index = 0; index < uSize; index++) 
	{
		str = NULL;
		os << "Recipient#"<<(index+1)<<": "<<endl; //append recipient index number
        pRecipientProfile = FaxBroadcastObj.m_FaxRecipientVector.at(index);
		if (NULL == pRecipientProfile)
		{
			os<<"pRecipientProfile = <NULL>"<<endl;
            continue;
		}

        //
        // add all profile strings to stream
        //

        //lptstrName
		str = ::DupTStrAsStr(pRecipientProfile->lptstrName);
        os<<"lptstrName = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrFaxNumber
		str = ::DupTStrAsStr(pRecipientProfile->lptstrFaxNumber);
        os<<"lptstrFaxNumber = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);

        //lptstrCompany
		str = ::DupTStrAsStr(pRecipientProfile->lptstrCompany);
        os<<"lptstrCompany = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrStreetAddress
		str = ::DupTStrAsStr(pRecipientProfile->lptstrStreetAddress);
        os<<"lptstrStreetAddress = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrCity
		str = ::DupTStrAsStr(pRecipientProfile->lptstrCity);
        os<<"lptstrCity = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrState
		str = ::DupTStrAsStr(pRecipientProfile->lptstrState);
        os<<"lptstrState = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrZip
		str = ::DupTStrAsStr(pRecipientProfile->lptstrZip);
        os<<"lptstrZip = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrCountry
		str = ::DupTStrAsStr(pRecipientProfile->lptstrCountry);
        os<<"lptstrCountry = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrTitle
		str = ::DupTStrAsStr(pRecipientProfile->lptstrTitle);
        os<<"lptstrTitle = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrDepartment
		str = ::DupTStrAsStr(pRecipientProfile->lptstrDepartment);
        os<<"lptstrDepartment = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrOfficeLocation
		str = ::DupTStrAsStr(pRecipientProfile->lptstrOfficeLocation);
        os<<"lptstrOfficeLocation = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrHomePhone
		str = ::DupTStrAsStr(pRecipientProfile->lptstrHomePhone);
        os<<"lptstrHomePhone = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrOfficePhone
		str = ::DupTStrAsStr(pRecipientProfile->lptstrOfficePhone);
        os<<"lptstrOfficePhone = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrOrganizationalMail
		str = ::DupTStrAsStr(pRecipientProfile->lptstrOrganizationalMail);
        os<<"lptstrOrganizationalMail = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrInternetMail
		str = ::DupTStrAsStr(pRecipientProfile->lptstrInternetMail);
        os<<"lptstrInternetMail = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrBillingCode
		str = ::DupTStrAsStr(pRecipientProfile->lptstrBillingCode);
        os<<"lptstrBillingCode = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrTSID
		str = ::DupTStrAsStr(pRecipientProfile->lptstrTSID);
        os<<"lptstrTSID = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);

	}

	return(os);
}
*/

//
// operator<<:
//	Appends a string representation of all the fields of a given CFaxBroadcast
//	instance.
//
CostrstreamEx& operator<<(
	CostrstreamEx&			        /* IN OUT */	os, 
	const FAX_PERSONAL_PROFILE&	    /* IN */		RecipientProfile
)
{

    os<<endl;
	LPCSTR str = NULL;

    //
    // add all profile strings to stream
    //

    //lptstrName
	str = ::DupTStrAsStr(RecipientProfile.lptstrName);
    os<<TEXT("\tlptstrName = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrFaxNumber
	str = ::DupTStrAsStr(RecipientProfile.lptstrFaxNumber);
    os<<TEXT("\tlptstrFaxNumber = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);

    //lptstrCompany
	str = ::DupTStrAsStr(RecipientProfile.lptstrCompany);
    os<<TEXT("\tlptstrCompany = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrStreetAddress
	str = ::DupTStrAsStr(RecipientProfile.lptstrStreetAddress);
    os<<TEXT("\tlptstrStreetAddress = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrCity
	str = ::DupTStrAsStr(RecipientProfile.lptstrCity);
    os<<TEXT("\tlptstrCity = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrState
	str = ::DupTStrAsStr(RecipientProfile.lptstrState);
    os<<TEXT("\tlptstrState = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrZip
	str = ::DupTStrAsStr(RecipientProfile.lptstrZip);
    os<<TEXT("\tlptstrZip = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrCountry
	str = ::DupTStrAsStr(RecipientProfile.lptstrCountry);
    os<<TEXT("\tlptstrCountry = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrTitle
	str = ::DupTStrAsStr(RecipientProfile.lptstrTitle);
    os<<TEXT("\tlptstrTitle = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrDepartment
	str = ::DupTStrAsStr(RecipientProfile.lptstrDepartment);
    os<<TEXT("\tlptstrDepartment = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrOfficeLocation
	str = ::DupTStrAsStr(RecipientProfile.lptstrOfficeLocation);
    os<<TEXT("\tlptstrOfficeLocation = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrHomePhone
	str = ::DupTStrAsStr(RecipientProfile.lptstrHomePhone);
    os<<TEXT("\tlptstrHomePhone = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrOfficePhone
	str = ::DupTStrAsStr(RecipientProfile.lptstrOfficePhone);
    os<<TEXT("\tlptstrOfficePhone = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrEmail
	str = ::DupTStrAsStr(RecipientProfile.lptstrEmail);
    os<<TEXT("\tlptstrEmail = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrBillingCode
	str = ::DupTStrAsStr(RecipientProfile.lptstrBillingCode);
    os<<TEXT("\tlptstrBillingCode = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrTSID
	str = ::DupTStrAsStr(RecipientProfile.lptstrTSID);
    os<<TEXT("\tlptstrTSID = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);

	return(os);
}

//
// operator<<:
//	Appends a string representation of all the fields of a given FAX_PERSONAL_PROFILE
//	instance.
//
CotstrstreamEx& operator<<(
	CotstrstreamEx&			        /* IN OUT */	os, 
	const FAX_PERSONAL_PROFILE&	    /* IN */		RecipientProfile
)
{

    os << endl;

    //
    // add all profile strings to stream
    //

    //lptstrName
    os << TEXT("\tlptstrName = ");
	if (NULL == RecipientProfile.lptstrName)
	{
		os<< TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrName << endl; //append string to stream
	}

    //lptstrFaxNumber
    os << TEXT("\tlptstrFaxNumber = ");
	if (NULL == RecipientProfile.lptstrFaxNumber)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrFaxNumber <<endl; //append string to stream
	}

    //lptstrCompany
    os << TEXT("\tlptstrCompany = ");
	if (NULL == RecipientProfile.lptstrCompany)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrCompany <<endl; //append string to stream
	}

    //lptstrStreetAddress
    os << TEXT("\tlptstrStreetAddress = ");
	if (NULL == RecipientProfile.lptstrStreetAddress)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrStreetAddress << endl; //append string to stream
	}

    //lptstrCity
    os << TEXT("\tlptstrCity = ");
	if (NULL == RecipientProfile.lptstrCity)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrCity << endl; //append string to stream
	}

    //lptstrState
    os << TEXT("\tlptstrState = ");
	if (NULL == RecipientProfile.lptstrState)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrState << endl; //append string to stream
	}

    //lptstrZip
    os << TEXT("\tlptstrZip = ");
	if (NULL == RecipientProfile.lptstrZip)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrZip << endl; //append string to stream
	}

    //lptstrCountry
    os << TEXT("\tlptstrCountry = ");
	if (NULL == RecipientProfile.lptstrCountry)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrCountry << endl; //append string to stream
	}

    //lptstrTitle
    os << TEXT("\tlptstrTitle = ");
	if (NULL == RecipientProfile.lptstrTitle)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrTitle << endl; //append string to stream
	}

    //lptstrDepartment
    os << TEXT("\tlptstrDepartment = ");
	if (NULL == RecipientProfile.lptstrDepartment)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrDepartment << endl; //append string to stream
	}

    //lptstrOfficeLocation
    os << TEXT("\tlptstrOfficeLocation = ");
	if (NULL == RecipientProfile.lptstrOfficeLocation)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrOfficeLocation << endl; //append string to stream
	}

    //lptstrHomePhone
    os << TEXT("\tlptstrHomePhone = ");
	if (NULL == RecipientProfile.lptstrHomePhone)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrHomePhone << endl; //append string to stream
	}

    //lptstrOfficePhone
    os << TEXT("\tlptstrOfficePhone = ");
	if (NULL == RecipientProfile.lptstrOfficePhone)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrOfficePhone << endl; //append string to stream
	}

    //lptstrEmail
    os << TEXT("\tlptstrEmail = ");
	if (NULL == RecipientProfile.lptstrEmail)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrEmail << endl; //append string to stream
	}

    //lptstrBillingCode
    os << TEXT("\tlptstrBillingCode = ");
	if (NULL == RecipientProfile.lptstrBillingCode)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrBillingCode << endl; //append string to stream
	}

    //lptstrTSID
    os << TEXT("\tlptstrTSID = ");
	if (NULL == RecipientProfile.lptstrTSID)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrTSID << endl; //append string to stream
	}

	return(os);
}



CostrstreamEx& operator<<(
	IN OUT CostrstreamEx&		os, 
	IN const CFaxBroadcast&	    FaxBroadcastObj
)
{
	LPCFAX_PERSONAL_PROFILE pRecipientProfile = NULL;

    if (0 == FaxBroadcastObj.m_FaxRecipientVector.size())
	{
		os<<TEXT("No Recipients")<<endl;
		return(os);
	}

	os<<endl;
	LPCSTR str = NULL;
	UINT uSize = FaxBroadcastObj.m_FaxRecipientVector.size();
	int index = 0;
	for (index = 0; index < uSize; index++) 
	{
		str = NULL;
		os << TEXT("Recipient#")<<(index+1)<<TEXT(": ")<<endl; //append recipient index number
        pRecipientProfile = FaxBroadcastObj.m_FaxRecipientVector.at(index);
	    if (NULL == pRecipientProfile)
	    {
		    os<<TEXT("pRecipientProfile = <NULL>")<<endl;
            continue;
	    }

        os << pRecipientProfile << endl;
    }
    return(os);
}

CotstrstreamEx& operator<<(
	IN OUT CotstrstreamEx&		os, 
	IN const CFaxBroadcast&	    FaxBroadcastObj
)
{
	LPCFAX_PERSONAL_PROFILE pRecipientProfile = NULL;

    if (0 == FaxBroadcastObj.m_FaxRecipientVector.size())
	{
		os << TEXT("No Recipients") << endl;
		return(os);
	}

	os<<endl;
	UINT uSize = FaxBroadcastObj.m_FaxRecipientVector.size();
	int index = 0;
	for (index = 0; index < uSize; index++) 
	{
		os << TEXT("Recipient#") << (index+1) << TEXT(": ") <<  endl; //append recipient index number
        pRecipientProfile = FaxBroadcastObj.m_FaxRecipientVector.at(index);
	    if (NULL == pRecipientProfile)
	    {
		    os << TEXT("pRecipientProfile = <NULL>") << endl;
            continue;
	    }

        os << pRecipientProfile << endl;
    }
    return(os);
}


//
// outputAllToLog:
//	Outputs a description of all the recipients in the instance's
//	recipient list to the logger in use.
//
void CFaxBroadcast::outputAllToLog(
	const DWORD /* IN */ dwSeverity, 
	const DWORD /* IN */ dwLevel
) const
{
	LPCTSTR szLogStr = NULL;	
	LPCFAX_PERSONAL_PROFILE pRecipientProfile = NULL;

    if (0 == m_FaxRecipientVector.size())
	{
	    ::lgLogDetail(dwSeverity,dwLevel,TEXT("No Recipients\n"));
        return;
	}

	LPCSTR str = NULL;
	UINT uSize = m_FaxRecipientVector.size();
	int index = 0;
	for (index = 0; index < uSize; index++) 
	{
    	CotstrstreamEx os;
		str = NULL;
		os <<endl<<TEXT("Recipient#")<<(index+1)<<TEXT(": ")<<endl; //append recipient index number
        pRecipientProfile = m_FaxRecipientVector.at(index);
	    if (NULL == pRecipientProfile)
	    {
		    os<<TEXT("pRecipientProfile = <NULL>")<<endl;
	    }
        else
        {
            os << (*pRecipientProfile);
        }
	    //CotstrstreamEx::cstr() returns copy of stream buffer
	    //it allocates string, caller should free.		
	    szLogStr = os.cstr();
        _ASSERTE(szLogStr);
							    
	    ::lgLogDetail(dwSeverity,dwLevel,szLogStr); //log recipient list string
	    delete[]((LPTSTR)szLogStr); //free string (allocated by CotstrstreamEx::cstr())
    }

}


#ifndef _NT5FAXTEST
// For Ronen's FaxSendDocumetEx changes:
//    "replace" DefaultFaxRecipientCallback with
//    CFaxBroadcast::GetBroadcastParams(
//                          OUT	LPFAX_COVERPAGE_INFO_EXW* lpcCoverPageInfo,
//	                        OUT	LPFAX_PERSONAL_PROFILEW*  lpcSenderProfile,
//	                        OUT	LPDWORD dwNumRecipients,
//   	                    OUT	LPFAX_PERSONAL_PROFILEW*	lpcRecipientList
//                          )
//    It will alloc and set OUT params, since caller doesn't know num of recipients

BOOL CFaxBroadcast::GetBroadcastParams(
    PFAX_COVERPAGE_INFO_EX*     /* OUT */	ppCoverPageInfo,
    PDWORD                      /* OUT */	pdwNumRecipients,
    PFAX_PERSONAL_PROFILE*	    /* OUT */	ppRecipientList
    ) const
{
    BOOL fRetVal = FALSE;

    PFAX_COVERPAGE_INFO_EX    pTmpCoverPageInfo = NULL;
    DWORD                     dwTmpNumRecipients = 0;
    PFAX_PERSONAL_PROFILE     pTmpRecipientList = NULL;
    LPCFAX_PERSONAL_PROFILE   pRecipientProfile = NULL;
    DWORD                     dwLoopIndex = 0;

    //
    // check OUT params are valid
    //
    if (NULL == ppCoverPageInfo)
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\nGetBroadcastParams got NULL == ppCoverPageInfo\n"),
			TEXT(__FILE__),
			__LINE__
			);
        goto ExitFunc;
    }
    if (NULL == pdwNumRecipients)
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\nGetBroadcastParams got NULL == pdwNumRecipients\n"),
			TEXT(__FILE__),
			__LINE__
			);
        goto ExitFunc;
    }
    if (NULL == ppRecipientList)
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\nGetBroadcastParams got NULL == ppRecipientList\n"),
			TEXT(__FILE__),
			__LINE__
			);
        goto ExitFunc;
    }


    //
    // Cover Page 
    //

    // if m_szCPFileName != NULL we alloc and set pTmpCoverPageInfo,
    // else we leave pTmpCoverPageInfo = NULL
    if (NULL != m_szCPFileName)
    {
        // alloc pTmpCoverPageInfo
        pTmpCoverPageInfo = (PFAX_COVERPAGE_INFO_EX) malloc (sizeof(FAX_COVERPAGE_INFO_EX));
	    if (NULL == pTmpCoverPageInfo)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d\nmalloc failed with err=0x%08X\n"),
			    TEXT(__FILE__),
			    __LINE__,
                ::GetLastError()
			    );
		    goto ExitFunc;
	    }
        ZeroMemory(pTmpCoverPageInfo, sizeof(FAX_COVERPAGE_INFO_EX));

        // set pTmpCoverPageInfo
        pTmpCoverPageInfo->dwSizeOfStruct = sizeof(FAX_COVERPAGE_INFO_EX);
	    pTmpCoverPageInfo->bServerBased = FALSE; 
	    pTmpCoverPageInfo->dwCoverPageFormat = FAX_COVERPAGE_FMT_COV; 
	    pTmpCoverPageInfo->lptstrCoverPageFileName = ::_tcsdup(m_szCPFileName);
	    if (NULL == pTmpCoverPageInfo->lptstrCoverPageFileName)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d\n_tcsdup returned NULL\n"),
			    TEXT(__FILE__),
			    __LINE__
			    );
		    goto ExitFunc;
	    }
	    pTmpCoverPageInfo->lptstrNote = TEXT("NOTE1\nNOTE2\nNOTE3\nNOTE4");
	    pTmpCoverPageInfo->lptstrSubject = TEXT("SUBJECT");
    } // of if (NULL != m_szCPFileName)


    //
    // Number Of Recipients
    //

    dwTmpNumRecipients = m_FaxRecipientVector.size();


    //
    // Recipient Profile List
    //

    if (0 == dwTmpNumRecipients)
    {
        // we allow this so that we could test FaxSendDocumentEx's response
        // but there is no need to alloc pTmpRecipientList
		::lgLogDetail(
			LOG_X,
            1, 
			TEXT("FILE:%s LINE:%d\ncalled GetBroadcastParams() on a CFaxBroadcast object with ZERO recipients\n"),
			TEXT(__FILE__),
			__LINE__
			);
    }
    else
    {
        // alloc pTmpRecipientList
        pTmpRecipientList = (PFAX_PERSONAL_PROFILE) malloc (dwTmpNumRecipients*sizeof(FAX_PERSONAL_PROFILE));
	    if (NULL == pTmpRecipientList)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d\nmalloc failed with err=0x%08X\n"),
			    TEXT(__FILE__),
			    __LINE__,
                ::GetLastError()
			    );
		    goto ExitFunc;
	    }
        ZeroMemory(pTmpRecipientList, dwTmpNumRecipients*sizeof(FAX_PERSONAL_PROFILE));
    }

    //
    // set pTmpRecipientList members
    //
    // NOTE: if (0 == dwTmpNumRecipients) then we don't go into loop
    for (dwLoopIndex = 0; dwLoopIndex < dwTmpNumRecipients; dwLoopIndex++)
    {
    	pRecipientProfile = m_FaxRecipientVector.at(dwLoopIndex); // at returns the pointer
	    if (NULL == pRecipientProfile)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d\nInternal Error - m_FaxRecipientVector.at(%d) returned NULL\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    dwLoopIndex
			    );
            _ASSERTE(pRecipientProfile);
		    goto ExitFunc;
	    }

        // set the recipient's profile
        if (!CopyRecipientProfile(&pTmpRecipientList[dwLoopIndex], pRecipientProfile))
        {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d\nCopyRecipientProfile failed\n"),
			    TEXT(__FILE__),
			    __LINE__
			    );
            goto ExitFunc;
        }
    } // of for (dwLoopIndex = 0; dwLoopIndex < dwTmpNumRecipients; iLoopIndex++)


    //
    // set OUT params
    //
    (*ppCoverPageInfo) = pTmpCoverPageInfo;
    (*pdwNumRecipients) = dwTmpNumRecipients;
    (*ppRecipientList) = pTmpRecipientList;
        
    fRetVal = TRUE;

ExitFunc:
    if (FALSE == fRetVal)
    {
        // free all Tmp allocs
	    if (pTmpCoverPageInfo)
        {
            free(pTmpCoverPageInfo->lptstrCoverPageFileName);
            free(pTmpCoverPageInfo);
        }
        if (pTmpRecipientList)
        {
            for (dwLoopIndex = 0; dwLoopIndex < dwTmpNumRecipients; dwLoopIndex++)
            {
                FreeRecipientProfile(&pTmpRecipientList[dwLoopIndex]);
            }
            free(pTmpRecipientList);
        }
    }
    return(fRetVal);
}
#endif // #ifndef _NT5FAXTEST

#ifdef _NT5FAXTEST
// Testing NT5 Fax (with old winfax.dll)

//
// DefaultFaxRecipientCallback:
//	A default implementation of the required FAX_RECIPIENT_CALLBACK.
//  This function is used by CFaxSender::send_broadcast(), to send a broadcast
//  fax. 
//  That is, CFaxSender::send_broadcast() will invoke FaxSendDocumentForBroadcast
//	giving it a CFaxBroadcast instance as its Context parameter and the
//	exported DefaultFaxRecipientCallback function as its final parameter.
//  The FaxSendDocumentForBroadcast function calls this callback function to 
//  retrieve user-specific information for the transmission. 
//  FaxSendDocumentForBroadcast calls FAX_RECIPIENT_CALLBACK multiple times, 
//  once for each designated fax recipient, passing it the Context parameter.
//
// NOTE: dwRecipientNumber is 1 based.
//
// Return Value:
//	The function returns TRUE to indicate that the FaxSendDocumentForBroadcast function 
//	should queue an outbound fax transmission, using the data pointed to by the 
//	JobParams and CoverpageInfo parameters. 
//	The function returns FALSE to indicate that there are no more fax transmission jobs 
//	to queue, and calls to FAX_RECIPIENT_CALLBACK should be terminated. 
//
BOOL CALLBACK DefaultFaxRecipientCallback(
	HANDLE					/* IN */	hFaxHandle,
	DWORD					/* IN */	dwRecipientNumber,
	LPVOID					/* IN */	pContext,
	PFAX_JOB_PARAM			/* IN OUT */	JobParams,
	PFAX_COVERPAGE_INFO		/* IN OUT */	CoverpageInfo 
)
{
	BOOL fRetVal = FALSE;
	LPTSTR szCPFileName = NULL;
	LPTSTR szCPNote = NULL;
	LPTSTR szCPSubject = NULL;
	LPTSTR szRecipientNumber = NULL;
	PFAX_PERSONAL_PROFILE pRecipientProfile = NULL;

	_ASSERTE(NULL != pContext);
	// cast the pContext param to CFaxBroadcast
	CFaxBroadcast* thisFaxBroadcastObj = (CFaxBroadcast*)pContext;

	// return FALSE to indicate no more recipients
	if (dwRecipientNumber > thisFaxBroadcastObj->GetNumberOfRecipients())
	{
		goto ExitFunc;
	}

	// get a copy of the RecipientProfile from list
	if (FALSE == thisFaxBroadcastObj->GetRecipient(dwRecipientNumber,&pRecipientProfile))
	{
		goto ExitFunc;
	}
	_ASSERTE(pRecipientProfile);
	_ASSERTE(pRecipientProfile->lptstrFaxNumber);

	// copy number string of recipient dwRecipientNumber from profile
	szRecipientNumber = ::_tcsdup(pRecipientProfile->lptstrFaxNumber);
	if (NULL == szRecipientNumber)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\n_tcsdup failed with ec=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
	}

	// get a copy of the Cover Page filename
	if (FALSE == thisFaxBroadcastObj->GetCPFileName(&szCPFileName))
	{
		goto ExitFunc;
	}

	// set the Note field of the Cover Page
	szCPNote = ::_tcsdup(TEXT("NOTE1\nNOTE2\nNOTE3\nNOTE4"));
	if (NULL == szCPNote)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\n_tcsdup failed with ec=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
	}

	// set the Subject field of the Cover Page
	szCPSubject = ::_tcsdup(TEXT("SUBJECT"));
	if (NULL == szCPSubject)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\n_tcsdup failed with ec=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
	}

	// set OUT params
    JobParams->RecipientNumber = szRecipientNumber;
	CoverpageInfo->CoverPageName = szCPFileName;
	CoverpageInfo->Note = szCPNote;
	CoverpageInfo->Subject = szCPSubject;
	fRetVal = TRUE;

ExitFunc:
	FreeRecipientProfile(pRecipientProfile);
	if (FALSE == fRetVal)
	{
		// function failed so free all allocations
		::free(szRecipientNumber);
		::free(szCPFileName);
		::free(szCPNote);
		::free(szCPSubject);
	}

	return(fRetVal);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxclasses\stringtable.h ===
#ifndef STRING_TABLE_H
#define STRING_TABLE_H

#include <winfax.h>
#include "Defs.h"
#include <vector>

typedef std::pair<DWORD, tstring> FAX_EVENT_STR;

const FAX_EVENT_STR FaxEventTable[]  = { 
	std::make_pair( DWORD(FEI_FAXSVC_STARTED), tstring(TEXT("FEI_FAXSVC_STARTED"))),
	std::make_pair( DWORD(FEI_MODEM_POWERED_ON), tstring(TEXT("FEI_MODEM_POWERED_ON"))),
	std::make_pair( DWORD(FEI_MODEM_POWERED_OFF), tstring(TEXT("FEI_MODEM_POWERED_OFF"))),
	std::make_pair( DWORD(FEI_FAXSVC_ENDED), tstring(TEXT("FEI_FAXSVC_ENDED"))),
	std::make_pair( DWORD(FEI_FATAL_ERROR), tstring(TEXT("FEI_FATAL_ERROR"))),
	std::make_pair( DWORD(FEI_IDLE), tstring(TEXT("FEI_IDLE"))),
	std::make_pair( DWORD(FEI_RINGING), tstring(TEXT("FEI_RINGING"))),
	std::make_pair( DWORD(FEI_RECEIVING), tstring(TEXT("FEI_RECEIVING"))),
	std::make_pair( DWORD(FEI_NOT_FAX_CALL), tstring(TEXT("FEI_NOT_FAX_CALL"))),
	std::make_pair( DWORD(FEI_INITIALIZING), tstring(TEXT("FEI_INITIALIZING"))),
	std::make_pair( DWORD(FEI_LINE_UNAVAILABLE), tstring(TEXT("FEI_LINE_UNAVAILABLE"))),
	std::make_pair( DWORD(FEI_HANDLED), tstring(TEXT("FEI_HANDLED"))),


	std::make_pair( DWORD(FEI_CALL_BLACKLISTED), tstring(TEXT("FEI_CALL_BLACKLISTED"))),
	std::make_pair( DWORD(FEI_CALL_DELAYED), tstring(TEXT("FEI_CALL_DELAYED"))),
	std::make_pair( DWORD(FEI_ROUTING), tstring(TEXT("FEI_ROUTING"))),
	std::make_pair( DWORD(FEI_ANSWERED), tstring(TEXT("FEI_ANSWERED"))),
	std::make_pair( DWORD(FEI_DISCONNECTED), tstring(TEXT("FEI_DISCONNECTED"))),
	std::make_pair( DWORD(FEI_NO_DIAL_TONE), tstring(TEXT("FEI_NO_DIAL_TONE"))),
	std::make_pair( DWORD(FEI_BAD_ADDRESS), tstring(TEXT("FEI_BAD_ADDRESS"))),
	std::make_pair( DWORD(FEI_NO_ANSWER), tstring(TEXT("FEI_NO_ANSWER"))),
	std::make_pair( DWORD(FEI_BUSY), tstring(TEXT("FEI_BUSY"))),
	std::make_pair( DWORD(FEI_DIALING), tstring(TEXT("FEI_DIALING"))),
	std::make_pair( DWORD(FEI_ABORTING), tstring(TEXT("FEI_ABORTING"))),
	std::make_pair( DWORD(FEI_DELETED), tstring(TEXT("FEI_DELETED"))),
	std::make_pair( DWORD(FEI_RECEIVING), tstring(TEXT("FEI_RECEIVING"))),
	std::make_pair( DWORD(FEI_SENDING), tstring(TEXT("FEI_SENDING"))),
	std::make_pair( DWORD(FEI_COMPLETED), tstring(TEXT("FEI_COMPLETED"))),
	std::make_pair( DWORD(FEI_JOB_QUEUED), tstring(TEXT("FEI_JOB_QUEUED")))

};

#define FaxTableSize ( sizeof(FaxEventTable) / sizeof(FAX_EVENT_STR))

typedef std::pair<DWORD, tstring> JOB_STATE_STR;

const JOB_STATE_STR JobStatetTable[]  = { 
	std::make_pair( DWORD(JS_PENDING), tstring(TEXT("JS_PENDING"))),
	std::make_pair( DWORD(JS_INPROGRESS), tstring(TEXT("JS_INPROGRESS"))),
	std::make_pair( DWORD(JS_DELETING), tstring(TEXT("JS_DELETING"))),
	std::make_pair( DWORD(JS_FAILED), tstring(TEXT("JS_FAILED"))),
	std::make_pair( DWORD(JS_PAUSED), tstring(TEXT("JS_PAUSED"))),
	std::make_pair( DWORD(JS_NOLINE), tstring(TEXT("JS_NOLINE"))),
	std::make_pair( DWORD(JS_RETRYING), tstring(TEXT("JS_RETRYING"))),
	std::make_pair( DWORD(JS_RETRIES_EXCEEDED), tstring(TEXT("JS_RETRIES_EXCEEDED"))),
	std::make_pair( DWORD(JS_COMPLETED), tstring(TEXT("JS_COMPLETED"))),
	std::make_pair( DWORD(JS_CANCELED), tstring(TEXT("JS_CANCELED"))),
	std::make_pair( DWORD(JS_CANCELING), tstring(TEXT("JS_CANCELING"))),
	std::make_pair( DWORD(JS_PAUSING), tstring(TEXT("JS_PAUSING")))
};

#define JobStateTableSize ( sizeof(JobStatetTable) / sizeof(JOB_STATE_STR))

#endif // STRING_TABLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxsender\wcsutil.cpp ===
//
//
// Filename:	wcsutil.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		6-Jan-99
//
//

#include "wcsutil.h"


//
// DupTStrAsStr:
//	Duplicates a CTSTR (CWSTR or CSTR) as a CSTR.
//	The needed memory is allocated and the needed convertion is made.
//	The caller is responsible to free the returned string.
//
LPCSTR DupTStrAsStr(LPCTSTR /* IN */ str)
{

	if (NULL == str) return(NULL);
	char* szStr = NULL;

#ifdef UNICODE
	int len = ::wcslen(str) + 1;
	szStr = new char[len];
	if (NULL == szStr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d new returned NULL with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
		return(NULL);
	}
	szStr[len-1] = NULL;
	if ((size_t)(-1) == ::wcstombs(szStr, str, len))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d wcstombs returned -1 (cannot convert)\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return(NULL);
	}
#else
	szStr = ::_tcsdup(str);
	if (NULL == szStr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d _tcsdupreturned NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return(NULL);
	}
#endif

	//caller must free this allocation
	return(szStr);
}

//
// DupTStrAsWStr:
//	Duplicates a CTSTR (CWSTR or CSTR) as a CWSTR.
//	The needed memory is allocated and the needed convertion is made.
//	The caller is responsible to free the returned string.
//
LPCWSTR DupTStrAsWStr(LPCTSTR /* IN */ str)
{

	if (NULL == str) return(NULL);
	wchar_t* szStr = NULL;

#ifdef UNICODE
	szStr = ::_tcsdup(str);
	if (NULL == szStr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d _tcsdup returned NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return(NULL);
	}
#else
	int len = ::strlen(str) + 1;
	szStr = new wchar_t[len];
	if (NULL == szStr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d new returned NULL with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
		return(NULL);
	}
	szStr[len-1] = NULL;
	if ((size_t)(-1) == ::mbstowcs(szStr, str, len))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d mbstowcs returned -1 (cannot convert)\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return(NULL);
	}

#endif

	//caller must free this allocation
	return(szStr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxsender\sendinfo.cpp ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Module name:		SendInfo.cpp
// Module author:	Sigalit Bar (sigalitb)
// Date:			23-Jul-98
//


//
//	Description:
//		This file contains the implementation of class CSendInfo.
//


#include "SendInfo.h"

CSendInfo::CSendInfo(void)
{
}

CSendInfo::~CSendInfo(void)
{
	RemoveAll();
}


//
// AddItem:
//	Creates a copy of NewFaxEvent and places it at the end of the
//	instance's private list of FAX_EVENT@s.
//
//	The description of the added item is logged with logging level 9.
//
BOOL CSendInfo::AddItem(const MY_FAX_EVENT /* IN */ NewFaxEvent)
{
	BOOL			fRetVal = FALSE;
	MY_FAX_EVENT*	pFaxEvent = NULL;
	LPCTSTR pszLogStr;	// string to be given to logging function
	CotstrstreamEx os;	// stream to append list description to

#ifdef _NT5FAXTEST
// MY_FAX_EVENT is FAX_EVENT
	pFaxEvent = &NewFaxEvent;
#else
// MY_FAX_EVENT is FAX_EVENT_EX
	if (FALSE == CopyFaxExtendedEvent(&pFaxEvent, NewFaxEvent))
	{
		goto ExitFunc;
	}
#endif

	_ASSERTE(pFaxEvent);

	//
	// Add to list (copy and add at end of list)
	//
	m_EventList.push_back(*pFaxEvent);

#ifndef _NT5FAXTEST
// MY_FAX_EVENT is FAX_EVENT_EX
	// we can now free the FAX_EVENT_EX that CopyFaxExtendedEvent allocated
	// since push_back copied it
	// note - we don't free what the FAX_EVENT_EX pointer members are pointing at
	//		  just the Fax_EVENT_EX struct itself
	free(pFaxEvent);
#endif

	//
	// Log a description of the event (logging level 9)
	//
	os<<endl;
	os<<TEXT("FaxEvent#")<<m_EventList.size()<<TEXT(":")<<endl;	//append list size to stream
	os<<TEXT("***********************************************")<<endl;
	os<<NewFaxEvent<<endl;	//append list description

	pszLogStr = os.cstr(); //convert stream to a string (cstr() allocates and caller frees)
	::lgLogDetail(LOG_SEVERITY_DONT_CARE, 9, pszLogStr); //log
	delete[]((LPTSTR)pszLogStr); //free string that cstr() allocated

	fRetVal = TRUE;

ExitFunc:
	return(fRetVal);
}


//
// RemoveAll:
//	Removes all items from the instance's private list of
//	FAX_EVENTs and deallocates them.
//
void CSendInfo::RemoveAll(void)
{
#ifndef _NT5FAXTEST
// MY_FAX_EVENT is FAX_EVENT_EX
	CFaxEventList::iterator eventIterator;
	int index;
	for (index = 1, eventIterator = m_EventList.begin(); 
		 eventIterator != m_EventList.end(); 
		 index++, eventIterator++
		) 
	{
		MY_FAX_EVENT* pFaxEvent = &(*eventIterator);
		FreeFaxExtendedEvent(pFaxEvent);
	}
#endif

	m_EventList.clear();
}
	

//
// GetLastJobEvent:
//	Returns the last event in the instance's private list of
//	FAX_EVENT@s, that is associated with Fax Service job ID,
//	and its event ID.
//
// Parameters:
//	MsgId		IN parameter.
//				the Fax Service job ID to look for in the instance's
//				FAX_EVENT@s list.
//	LastEvent	OUT parameter.
//				the last event in the instance's FAX_EVENT@ list with
//				desired MsgId.
// Return Value:
//  For FAX_EVENT    - EventId
//  For FAX_EVENT_EX - EventType
//	If there are no FAX_EVENT@s with desired MsgId,
//	then the function returns NO_FAX_EVENTS.
//
DWORD CSendInfo::GetLastJobEvent(MY_FAX_EVENT** /* OUT */ ppLastEvent, MY_MSG_ID /* IN  */ MsgId) const
{
	_ASSERTE(ppLastEvent);

	if (0 == m_EventList.size())
	{
		return(NO_FAX_EVENTS);
	}

	_ASSERTE(MsgId != 0);

	//goes over list from finish to start,
	//returning first event with matching MsgId
	//in OUT param LastEvent
	CFaxEventList::const_iterator eventIterator;
	for (eventIterator = m_EventList.end(); 
		 eventIterator != m_EventList.begin(); 
		 eventIterator--) 
	{

#ifndef _NT5FAXTEST
// MY_FAX_EVENT is FAX_EVENT_EX
		if (! ((FAX_EVENT_TYPE_OUT_QUEUE == eventIterator->EventType) ||
			   (FAX_EVENT_TYPE_IN_QUEUE == eventIterator->EventType) ||
			   (FAX_EVENT_TYPE_OUT_ARCHIVE == eventIterator->EventType) ||
			   (FAX_EVENT_TYPE_IN_ARCHIVE == eventIterator->EventType)
			  )
		   )
		{
			// this (extended) event does not have a msg id
			continue;
		}
#endif
		// this event has a MsgId
		if (MyGetEventMsgId(*eventIterator) != MsgId) 
		{
			// this is not our MsgId
			continue;
		}

		// found first event with MsgId
		(*ppLastEvent) = const_cast<MY_FAX_EVENT*>(&(*eventIterator));
		return(MyGetEventType(*eventIterator));
	}

	return(NO_FAX_EVENTS);
}


//
// cstr:
//	Returns a string which contains all the instance's information.
//
//  String is allocated by function and should be freed by caller.
//	
LPCTSTR CSendInfo::cstr(void) const
{
	CostrstreamEx myOs;	//stream to append description of list to

	myOs << endl;
	myOs << (*this);	//append list description to stream

	return(myOs.cstr());//CostrstreamEx::cstr() returns copy of stream buffer
						//it allocates string, caller should free.
}


//
// operator<<:
//	Outputs a description of all the FAX_EVENT@s in the instance's
//	list to (the stream) os.
//
CostrstreamEx& operator<<(CostrstreamEx& /* IN OUT */ os, const CSendInfo& /* IN */ SendInfo)
{
	if (0 == SendInfo.m_EventList.size())
	{
		os<<TEXT("No Fax Events")<<endl;
	}

	CFaxEventList::const_iterator eventIterator;
	int index;
	for (index = 1, eventIterator = SendInfo.m_EventList.begin(); 
		 eventIterator != SendInfo.m_EventList.end(); 
		 index++, eventIterator++
		) 
	{
		os << TEXT("FaxEvent#")<<index<<TEXT(":")<<endl; //append event number
		os << (*eventIterator) <<endl; //append event to stream
	}

	return(os);
}


//
// operator<<:
//	Outputs a description of all the FAX_EVENT@s in the instance's
//	list to (the stream) os.
//
CotstrstreamEx& operator<<(CotstrstreamEx& /* IN OUT */ os, const CSendInfo& /* IN */ SendInfo)
{
	if (0 == SendInfo.m_EventList.size())
	{
		os<<TEXT("No Fax Events")<<endl;
	}

	CFaxEventList::const_iterator eventIterator;
	int index;
	for (index = 1, eventIterator = SendInfo.m_EventList.begin(); 
		 eventIterator != SendInfo.m_EventList.end(); 
		 index++, eventIterator++
		) 
	{
		os << TEXT("FaxEvent#")<<index<<TEXT(":")<<endl; //append event number
		os << (*eventIterator) <<endl; //append event to stream
	}

	return(os);
}


//
// outputAllToLog:
//	Outputs a description of all the FAX_EVENT@s in the instance's
//	list to the logger in use.
//
void CSendInfo::outputAllToLog(const DWORD /* IN */ dwSeverity, const DWORD /* IN */ dwLevel) const
{
	CostrstreamEx os;

	if (0 == m_EventList.size())
	{
		::lgLogDetail(dwSeverity,dwLevel,TEXT("No Fax Events"));
	}

	LPCTSTR szLogStr;	//string to be sent to logger

	CFaxEventList::const_iterator eventIterator;
	int index;

	for (index = 1, eventIterator = m_EventList.begin();
		 eventIterator != m_EventList.end(); 
		 index++, eventIterator++
		) 
	{
		os << TEXT("FaxEvent#")<<index<<TEXT(":")<<endl; //appending event number to stream
		os << (*eventIterator) <<endl;	//appending event description to stream

		//CostrstreamEx::cstr() returns copy of stream buffer
		//it allocates string, caller should free.		
		szLogStr = os.cstr();	
								
		::lgLogDetail(dwSeverity,dwLevel,szLogStr); //log event string
		delete[]((LPTSTR)szLogStr); //free string (allocated by CostrstreamEx::cstr())
	}
}


//
// outputJobToLog:
//	Outputs a description of those FAX_EVENT_EXs in the instance's
//	list that have MsgId field equal to dwlMsgId, to the logger in use.
//
void CSendInfo::outputJobToLog(
	const MY_MSG_ID	/* IN */ MsgId, 
	const DWORD		/* IN */ dwSeverity, 
	const DWORD		/* IN */ dwLevel
	) const
{
	CostrstreamEx os;
	LPCTSTR szLogStr = NULL; //string to be sent to logger
	int index = 0;

	if (0==m_EventList.size())
	{
		::lgLogDetail(dwSeverity,dwLevel,TEXT("No Fax Events"));
		return;
	}

	CFaxEventList::const_iterator eventIterator;
	for (index = 1, eventIterator = m_EventList.begin(); 
		 eventIterator != m_EventList.end(); 
		 index++, eventIterator++
		) 
	{
#ifndef _NT5FAXTEST
// MY_FAX_EVENT is FAX_EVENT_EX
		if (! ((FAX_EVENT_TYPE_OUT_QUEUE == eventIterator->EventType) ||
			   (FAX_EVENT_TYPE_IN_QUEUE == eventIterator->EventType) ||
			   (FAX_EVENT_TYPE_OUT_ARCHIVE == eventIterator->EventType) ||
			   (FAX_EVENT_TYPE_IN_ARCHIVE == eventIterator->EventType)
			  )
		   )
		{
			// this (extended) event does not have a msg id
			continue;
		}
#endif
		// this event has a MsgId
		if (MyGetEventMsgId(*eventIterator) != MsgId) 
		{
			// this is not our MsgId
			continue;
		}
		// found event with MsgId
		os << TEXT("FaxEvent#")<<index<<TEXT(":")<<endl; //appending event number to stream
		os << (*eventIterator) <<endl;	//appending event description to stream

		szLogStr = os.cstr();	//CostrstreamEx::cstr() returns copy of stream buffer
								//it allocates string, caller should free.
		::lgLogDetail(dwSeverity,dwLevel,szLogStr); //log event string
		delete[]((LPTSTR)szLogStr); //free string (allocated by CostrstreamEx::cstr())
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxsender\faxeventex.cpp ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Filename:    FaxEvent.cpp
// Author:      Sigalit Bar (sigalitb)
// Date:        23-Jul-98
//


//
// Description:
//      This file contains the implementation of module "FaxEvent.h".
//


#include "FaxEventEx.h"
#include "wcsutil.h"


//
// TSTR string arrays for enum types
//

LPCTSTR g_tstrFaxJobEventTypes[] =
{
    TEXT("FAX_JOB_EVENT_TYPE_ADDED"),
    TEXT("FAX_JOB_EVENT_TYPE_REMOVED"),
    TEXT("FAX_JOB_EVENT_TYPE_STATUS")
};

LPCTSTR g_tstrFaxConfigEventTypes[] =
{
    TEXT("FAX_CONFIG_TYPE_SMTP"),
    TEXT("FAX_CONFIG_TYPE_ACTIVITY_LOGGING"),
    TEXT("FAX_CONFIG_TYPE_OUTBOX"),
    TEXT("FAX_CONFIG_TYPE_SENTITEMS"),
    TEXT("FAX_CONFIG_TYPE_INBOX"),
    TEXT("FAX_CONFIG_TYPE_SECURITY"),
    TEXT("FAX_CONFIG_TYPE_EVENTLOGS"),
    TEXT("FAX_CONFIG_TYPE_DEVICES"),
    TEXT("FAX_CONFIG_TYPE_OUT_GROUPS"),
    TEXT("FAX_CONFIG_TYPE_OUT_RULES")
};

LPCTSTR g_tstrFaxEventTypes[] =
{
    TEXT("FAX_EVENT_TYPE_IN_QUEUE"),    //= 0x0001
    TEXT("FAX_EVENT_TYPE_OUT_QUEUE"),   //= 0x0002
    TEXT("FAX_EVENT_TYPE_CONFIG"),      //= 0x0004
    TEXT("FAX_EVENT_TYPE_ACTIVITY"),    //= 0x0008
    TEXT("FAX_EVENT_TYPE_QUEUE_STATE"), //= 0x0010
    TEXT("FAX_EVENT_TYPE_IN_ARCHIVE"),  //= 0x0020
    TEXT("FAX_EVENT_TYPE_OUT_ARCHIVE"), //= 0x0040
    TEXT("FAX_EVENT_TYPE_FXSSVC_ENDED") //= 0x0080
};

LPCTSTR g_tstrFaxQueueStatus[] =
{
    TEXT("JS_PENDING"),             //= 0x00000001
    TEXT("JS_INPROGRESS"),          //= 0x00000002
    TEXT("JS_DELETING"),            //= 0x00000004
    TEXT("JS_FAILED"),              //= 0x00000008
    TEXT("JS_PAUSED"),              //= 0x00000010
    TEXT("JS_NOLINE"),              //= 0x00000020
    TEXT("JS_RETRYING"),            //= 0x00000040
    TEXT("JS_RETRIES_EXCEEDED"),    //= 0x00000080
    TEXT("JS_COMPLETED"),           //= 0x00000100
    TEXT("JS_CANCELED"),            //= 0x00000200
    TEXT("JS_CANCELING"),           //= 0x00000400
    TEXT("JS_ROUTING")              //= 0x00000800
};


LPCTSTR g_tstrFaxExtendedStatus[] =
{
    TEXT("JS_EX_DISCONNECTED"),
    TEXT("JS_EX_INITIALIZING"),
    TEXT("JS_EX_DIALING"),
    TEXT("JS_EX_TRANSMITTING"),
    TEXT("JS_EX_ANSWERED"),
    TEXT("JS_EX_RECEIVING"),
    TEXT("JS_EX_LINE_UNAVAILABLE"),
    TEXT("JS_EX_BUSY"),
    TEXT("JS_EX_NO_ANSWER"),
    TEXT("JS_EX_BAD_ADDRESS"),
    TEXT("JS_EX_NO_DIAL_TONE"),
    TEXT("JS_EX_FATAL_ERROR"),
    TEXT("JS_EX_CALL_DELAYED"),
    TEXT("JS_EX_CALL_BLACKLISTED"),
    TEXT("JS_EX_NOT_FAX_CALL"),
    TEXT("JS_EX_PARTIALLY_RECEIVED"),
    TEXT("JS_EX_HANDLED"),
    TEXT("JS_EX_CALL_COMPLETED"),
    TEXT("JS_EX_CALL_ABORTED")
};


LPCTSTR g_tstrFaxQueueStates[] =
{
    TEXT("FAX_INCOMING_BLOCKED"),   // = 0x0001,
    TEXT("FAX_OUTBOX_BLOCKED"),     // = 0x0002,
    TEXT("FAX_OUTBOX_PAUSED")       // = 0x0004
};

//
// ANSI string arrays for enum types
//

LPCSTR g_strFaxJobEventTypes[] =
{
    "FAX_JOB_EVENT_TYPE_ADDED",
    "FAX_JOB_EVENT_TYPE_REMOVED",
    "FAX_JOB_EVENT_TYPE_STATUS"
};

LPCSTR g_strFaxConfigEventTypes[] =
{
    "FAX_CONFIG_TYPE_SMTP",
    "FAX_CONFIG_TYPE_ACTIVITY_LOGGING",
    "FAX_CONFIG_TYPE_OUTBOX",
    "FAX_CONFIG_TYPE_SENTITEMS",
    "FAX_CONFIG_TYPE_INBOX",
    "FAX_CONFIG_TYPE_SECURITY",
    "FAX_CONFIG_TYPE_EVENTLOGS",
    "FAX_CONFIG_TYPE_DEVICES",
    "FAX_CONFIG_TYPE_OUT_GROUPS",
    "FAX_CONFIG_TYPE_OUT_RULES"
};

LPCSTR g_strFaxEventTypes[] =
{
    "FAX_EVENT_TYPE_IN_QUEUE",    //= 0x0001
    "FAX_EVENT_TYPE_OUT_QUEUE",   //= 0x0002
    "FAX_EVENT_TYPE_CONFIG",        //= 0x0004
    "FAX_EVENT_TYPE_ACTIVITY",    //= 0x0008
    "FAX_EVENT_TYPE_QUEUE_STATE", //= 0x0010
    "FAX_EVENT_TYPE_IN_ARCHIVE",  //= 0x0020
    "FAX_EVENT_TYPE_OUT_ARCHIVE", //= 0x0040
    "FAX_EVENT_TYPE_FXSSVC_ENDED" //= 0x0080
};

LPCSTR g_strFaxQueueStatus[] =
{
    "JS_PENDING",             //= 0x00000001
    "JS_INPROGRESS",          //= 0x00000002
    "JS_DELETING",            //= 0x00000004
    "JS_FAILED",              //= 0x00000008
    "JS_PAUSED",              //= 0x00000010
    "JS_NOLINE",              //= 0x00000020
    "JS_RETRYING",            //= 0x00000040
    "JS_RETRIES_EXCEEDED",    //= 0x00000080
    "JS_COMPLETED",           //= 0x00000100
    "JS_CANCELED",            //= 0x00000200
    "JS_CANCELING",           //= 0x00000400
};                                              

LPCSTR g_strFaxExtendedStatus[] =
{
    "JS_EX_DISCONNECTED",
    "JS_EX_INITIALIZING",
    "JS_EX_DIALING",
    "JS_EX_TRANSMITTING",
    "JS_EX_ANSWERED",
    "JS_EX_RECEIVING",
    "JS_EX_LINE_UNAVAILABLE",
    "JS_EX_BUSY",
    "JS_EX_NO_ANSWER",
    "JS_EX_BAD_ADDRESS",
    "JS_EX_NO_DIAL_TONE",
    "JS_EX_FATAL_ERROR",
    "JS_EX_CALL_DELAYED",
    "JS_EX_CALL_BLACKLISTED",
    "JS_EX_NOT_FAX_CALL",
    "JS_EX_PARTIALLY_RECEIVED",
    "JS_EX_HANDLED"
};


LPCSTR g_strFaxQueueStates[] =
{
    "FAX_INCOMING_BLOCKED",     // = 0x0001,
    "FAX_OUTBOX_BLOCKED",       // = 0x0002,
    "FAX_OUTBOX_PAUSED"         // = 0x0004
};

///
//
// GetQueueStatusStr:
//
LPCSTR
GetQueueStatusStr(
    IN  const DWORD dwQueueStatus
)
{
    DWORD   dwQueueStatusIndex = 0;

    _ASSERTE(dwQueueStatus >= JS_PENDING);
    _ASSERTE(dwQueueStatus <= JS_ROUTING);
    _ASSERTE(dwQueueStatusIndex < (sizeof(g_strFaxQueueStatus)/sizeof(g_strFaxQueueStatus[0])));
    if(0 != dwQueueStatus)
    {
        dwQueueStatusIndex = (log(dwQueueStatus)/log(2));
    }
    // else dwQueueStatusIndex remains 0.

    return(g_strFaxQueueStatus[dwQueueStatusIndex]);
}

///
//
// GetQueueStatusTStr:
//
LPCTSTR
GetQueueStatusTStr(
    IN  const DWORD dwQueueStatus
)
{
    DWORD   dwQueueStatusIndex = 0;

    _ASSERTE(dwQueueStatus >= JS_PENDING);
    _ASSERTE(dwQueueStatus <= JS_ROUTING);
    _ASSERTE(dwQueueStatusIndex < (sizeof(g_tstrFaxQueueStatus)/sizeof(g_tstrFaxQueueStatus[0])));
    if(0 != dwQueueStatus)
    {
        dwQueueStatusIndex = (log(dwQueueStatus)/log(2));
    }
    // else dwQueueStatusIndex remains 0.

    return(g_tstrFaxQueueStatus[dwQueueStatusIndex]);
}

///
//
// GetExtendedStatusStr:
//
LPCSTR
GetExtendedStatusStr(
    IN  const DWORD dwExtendedStatus
)
{
    DWORD dwExtendedStatusIndex = 0;
    if (0 == dwExtendedStatus)
    {
        return("0x00000000");
    }
    if (dwExtendedStatus >= JS_EX_PROPRIETARY)
    {
        return("JS_EX_PROPRIETARY");
    }

    _ASSERTE(dwExtendedStatus <= JS_EX_HANDLED);
    dwExtendedStatusIndex = dwExtendedStatus - 1;
    _ASSERTE(dwExtendedStatusIndex < (sizeof(g_strFaxExtendedStatus)/sizeof(g_strFaxExtendedStatus[0])));
    return(g_strFaxExtendedStatus[dwExtendedStatusIndex]);
}

///
//
// GetExtendedStatusTStr:
//
LPCTSTR
GetExtendedStatusTStr(
    IN  const DWORD dwExtendedStatus
)
{
    DWORD dwExtendedStatusIndex = 0;
    if (0 == dwExtendedStatus)
    {
        return(TEXT("0x00000000"));
    }

    if (dwExtendedStatus >= JS_EX_PROPRIETARY)
    {
        return(TEXT("JS_EX_PROPRIETARY"));
    }

    _ASSERTE(dwExtendedStatus <= JS_EX_HANDLED);
    dwExtendedStatusIndex = dwExtendedStatus - 1;
    _ASSERTE(dwExtendedStatusIndex < (sizeof(g_tstrFaxExtendedStatus)/sizeof(g_tstrFaxExtendedStatus[0])));
    return(g_tstrFaxExtendedStatus[dwExtendedStatusIndex]);
}

///
//
// LogExtendedEvent:
//
void
LogExtendedEvent(
    PFAX_EVENT_EX   /* IN */ pFaxEventEx,
    const DWORD     /* IN */ dwSeverity,
    const DWORD     /* IN */ dwLevel
)
{
    CotstrstreamEx os;
    LPCTSTR szLogStr;   //string to be sent to logger

    os << TEXT("FaxExtendedEvent -")<<endl;
    os << (*pFaxEventEx);
    szLogStr = os.cstr();   
                            
    ::lgLogDetail(dwSeverity,dwLevel,szLogStr); //log event string
    delete[]((LPTSTR)szLogStr); //free string (allocated by CostrstreamEx::cstr())

}

//
// operator<<:
//  Appends a string representation of all the fields of a given FAX_EVENT_EX.
//
CostrstreamEx& operator<<(
    CostrstreamEx& /* IN OUT */ os,
    const FAX_EVENT_EX& /* IN */ FaxEventEx
    )
{
    FAX_EVENT_JOB   EventJobInfo = {0};
    DWORD           dwEventTypeIndex = 0;
    LPCSTR          strEventType = NULL;
    LPCSTR          strJobEventType = NULL;
    LPCSTR          strConfigEventType = NULL;
    LPCSTR          strQueueStatus = NULL;
    LPCSTR          strExtendedStatus = NULL;
    LPCSTR          strProprietaryExtendedStatus = NULL;
    LPCSTR          strDeviceName = NULL;
    LPCSTR          strConfigType = NULL;
    DWORD           dwQueueStatus = 0;
    DWORD           dwExtendedStatus = 0;
    LPCTSTR         lpctstrExtendedStatus = NULL;
    DWORD           dwDeviceId = 0;
    LPCTSTR         lpctstrDeviceName = NULL;
    CHAR            strMessageId[20] = {0};

    os<<TEXT("SizeOfStruct:\t")<<FaxEventEx.dwSizeOfStruct<<endl;

    // convert the FAX_EVENT's time field to representable form
    os<<TEXT("TimeStamp:\t");
    FILETIME localFileTime;
    if (FALSE == ::FileTimeToLocalFileTime(&(FaxEventEx.TimeStamp),&localFileTime))
    {
        os<<TEXT("Time Conversion (FileTimeToLocalFileTime) Failed with Error=")<<GetLastError();
        return(os);
    }

    SYSTEMTIME lpSystemTime;
    if(FALSE == ::FileTimeToSystemTime(&localFileTime,&lpSystemTime))
    {
        os<<TEXT("Time Conversion (FileTimeToSystemTime) Failed with Error=")<<GetLastError();
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d [CostrstreamEx& operator<<]\n- FileTimeToSystemTime failed with ec=0x%08X\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        _ASSERTE(FALSE);
        return(os);
    }
    os<<lpSystemTime.wDay<<TEXT("/")<<lpSystemTime.wMonth<<TEXT("/")<<lpSystemTime.wYear<<TEXT("  ");
    os<<lpSystemTime.wHour<<TEXT(":");
    if (lpSystemTime.wMinute < 10)
    {
        os<<TEXT("0");
    }
    os<<lpSystemTime.wMinute<<TEXT(":");
    if (lpSystemTime.wSecond < 10)
    {
        os<<TEXT("0");
    }
    os<<lpSystemTime.wSecond;
    os<<TEXT("  (d/m/yy  h:mm:ss)")<<endl;

    dwEventTypeIndex = log(FaxEventEx.EventType)/log(2);
    _ASSERTE(dwEventTypeIndex < (sizeof(g_strFaxEventTypes)/sizeof(g_strFaxEventTypes[0])));

    strEventType = g_strFaxEventTypes[dwEventTypeIndex];
    os<<TEXT("EventType:\t")<<strEventType<<endl;

    switch (FaxEventEx.EventType)
    {
        case FAX_EVENT_TYPE_IN_QUEUE:
        case FAX_EVENT_TYPE_OUT_QUEUE:
        case FAX_EVENT_TYPE_IN_ARCHIVE:
        case FAX_EVENT_TYPE_OUT_ARCHIVE:
            EventJobInfo = (FaxEventEx.EventInfo).JobInfo;
            strJobEventType = g_strFaxJobEventTypes[EventJobInfo.Type];
            ::_ui64toa(EventJobInfo.dwlMessageId, strMessageId, 16);
            os<<TEXT("dwlMessageId:\t")<<strMessageId<<endl;
            os<<TEXT("JobEventType:\t")<<strJobEventType<<endl;
            if (FAX_JOB_EVENT_TYPE_STATUS == EventJobInfo.Type)
            {
                _ASSERTE(EventJobInfo.pJobData);
                dwDeviceId = EventJobInfo.pJobData->dwDeviceID;
                _ASSERTE(dwDeviceId);
                lpctstrDeviceName = EventJobInfo.pJobData->lpctstrDeviceName;
                _ASSERTE(lpctstrDeviceName);
                dwQueueStatus = EventJobInfo.pJobData->dwQueueStatus;
                dwExtendedStatus = EventJobInfo.pJobData->dwExtendedStatus;
                lpctstrExtendedStatus = EventJobInfo.pJobData->lpctstrExtendedStatus;
                strQueueStatus = GetQueueStatusStr(dwQueueStatus);
                strExtendedStatus = GetExtendedStatusStr(dwExtendedStatus);
                os<<TEXT("Extended Event JobData-")<<endl;
                if (lpctstrDeviceName)
                {
                    strDeviceName = ::DupTStrAsStr(lpctstrDeviceName);
                    if (NULL == strDeviceName)
                    {
                        os<<TEXT("lpctstrDeviceName:\t ERROR - DupTStrAsStr() failed")<<endl;
                    }
                    else
                    {
                        os<<TEXT("lpctstrDeviceName:\t")<<strDeviceName<<endl;
                    }
                }
                else
                {
                    os<<TEXT("lpctstrDeviceName:\t (null)")<<endl;
                }
                os<<TEXT("dwDeviceId:\t")<<dwDeviceId<<endl;
                os<<TEXT("QueueStatus:\t")<<strQueueStatus<<endl;
                os<<TEXT("ExtendedStatus:\t")<<strExtendedStatus<<endl;
                if (lpctstrExtendedStatus)
                {
                    strProprietaryExtendedStatus = ::DupTStrAsStr(lpctstrExtendedStatus);
                    if (NULL == strProprietaryExtendedStatus)
                    {
                        os<<TEXT("lpctstrExtendedStatus:\t ERROR - DupTStrAsStr() failed")<<endl;
                    }
                    else
                    {
                        os<<TEXT("lpctstrExtendedStatus:\t")<<strProprietaryExtendedStatus<<endl;
                    }
                }
                else
                {
                    os<<TEXT("lpctstrExtendedStatus:\t (null)")<<endl;
                }
            }
            break;

        case FAX_EVENT_TYPE_CONFIG:
            _ASSERTE((FaxEventEx.EventInfo).ConfigType < (sizeof(g_strFaxQueueStatus)/sizeof(g_strFaxQueueStatus[0])));
            strConfigType = g_strFaxConfigEventTypes[(FaxEventEx.EventInfo).ConfigType];
            os<<TEXT("ConfigType:\t")<<strConfigType<<endl;
            break;

        case FAX_EVENT_TYPE_ACTIVITY:
            os<<TEXT("dwIncomingMessages:\t")<<(FaxEventEx.EventInfo).ActivityInfo.dwIncomingMessages<<endl;
            os<<TEXT("dwRoutingMessages:\t")<<(FaxEventEx.EventInfo).ActivityInfo.dwRoutingMessages<<endl;
            os<<TEXT("dwOutgoingMessages:\t")<<(FaxEventEx.EventInfo).ActivityInfo.dwOutgoingMessages<<endl;
            os<<TEXT("dwDelegatedOutgoingMessages:\t")<<(FaxEventEx.EventInfo).ActivityInfo.dwDelegatedOutgoingMessages<<endl;
            os<<TEXT("dwQueuedMessages:\t")<<(FaxEventEx.EventInfo).ActivityInfo.dwQueuedMessages<<endl;
            break;

        case FAX_EVENT_TYPE_QUEUE_STATE:
            os<<TEXT("dwQueueStates:\t")<<(FaxEventEx.EventInfo).dwQueueStates<<endl;
            break;

        default:
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d [CostrstreamEx& operator<<]\n- FaxEventEx.EventType=0x%08X is out of enumaration scope\n"),
                TEXT(__FILE__),
                __LINE__,
                FaxEventEx.EventType
                );
            _ASSERTE(FALSE);
            break;
    }

    delete[]((LPSTR)strDeviceName);
    delete[]((LPSTR)strProprietaryExtendedStatus);
    return(os);
}

//
// operator<<:
//  Appends a string representation of all the fields of a given FAX_EVENT_EX.
//
CotstrstreamEx& operator<<(
    CotstrstreamEx& /* IN OUT */ os,
    const FAX_EVENT_EX& /* IN */ FaxEventEx
    )
{
    FAX_EVENT_JOB   EventJobInfo = {0};
    DWORD           dwEventTypeIndex = 0;
    LPCTSTR         strEventType = NULL;
    LPCTSTR         strJobEventType = NULL;
    LPCTSTR         strConfigEventType = NULL;
    LPCTSTR         strQueueStatus = NULL;
    LPCTSTR         strExtendedStatus = NULL;
    LPCTSTR         strProprietaryExtendedStatus = NULL;
    LPCTSTR         strConfigType = NULL;
    DWORD           dwQueueStatus = 0;
    DWORD           dwExtendedStatus = 0;
    LPCTSTR         lpctstrExtendedStatus = NULL;
    DWORD           dwDeviceId = 0;
    LPCTSTR         lpctstrDeviceName = NULL;
    TCHAR           strMessageId[20] = {0};

    os<<TEXT("SizeOfStruct:\t")<<FaxEventEx.dwSizeOfStruct<<endl;

    // convert the FAX_EVENT's time field to representable form
    os<<TEXT("TimeStamp:\t");
    FILETIME localFileTime;
    if (FALSE == ::FileTimeToLocalFileTime(&(FaxEventEx.TimeStamp),&localFileTime))
    {
        os<<TEXT("Time Conversion (FileTimeToLocalFileTime) Failed with Error=")<<GetLastError();
        return(os);
    }

    SYSTEMTIME lpSystemTime;
    if(FALSE == ::FileTimeToSystemTime(&localFileTime,&lpSystemTime))
    {
        os<<TEXT("Time Conversion (FileTimeToSystemTime) Failed with Error=")<<GetLastError();
        return(os);
    }
    DWORD   dwDay = lpSystemTime.wDay;
    DWORD   dwMonth = lpSystemTime.wMonth;
    DWORD   dwYear = lpSystemTime.wYear;
    DWORD   dwHour = lpSystemTime.wHour;
    DWORD   dwMinute = lpSystemTime.wMinute;
    DWORD   dwSecond = lpSystemTime.wSecond;
    os<<dwDay<<TEXT("/")<<dwMonth<<TEXT("/")<<dwYear<<TEXT("  ");
    os<<dwHour<<TEXT(":");
    if (dwMinute < 10)
    {
        os<<TEXT("0");
    }
    os<<dwMinute<<TEXT(":");
    if (dwSecond < 10)
    {
        os<<TEXT("0");
    }
    os<<dwSecond;
    os<<TEXT("  (d/m/yy  h:m:ss)")<<endl;

    dwEventTypeIndex = log(FaxEventEx.EventType)/log(2);
    _ASSERTE(dwEventTypeIndex < (sizeof(g_tstrFaxEventTypes)/sizeof(g_tstrFaxEventTypes[0])));

    strEventType = g_tstrFaxEventTypes[dwEventTypeIndex];
    os<<TEXT("EventType:\t")<<strEventType<<endl;

    switch (FaxEventEx.EventType)
    {
        case FAX_EVENT_TYPE_IN_QUEUE:
        case FAX_EVENT_TYPE_OUT_QUEUE:
        case FAX_EVENT_TYPE_IN_ARCHIVE:
        case FAX_EVENT_TYPE_OUT_ARCHIVE:
            EventJobInfo = (FaxEventEx.EventInfo).JobInfo;
            strJobEventType = g_tstrFaxJobEventTypes[EventJobInfo.Type];
            ::_ui64tot(EventJobInfo.dwlMessageId, strMessageId, 16);
            os<<TEXT("dwlMessageId:\t")<<strMessageId<<endl;
            os<<TEXT("JobEventType:\t")<<strJobEventType<<endl;
            os<<TEXT("EventType:\t")<<strEventType<<endl;
            if (FAX_JOB_EVENT_TYPE_STATUS == EventJobInfo.Type)
            {
                _ASSERTE(EventJobInfo.pJobData);
                dwDeviceId = EventJobInfo.pJobData->dwDeviceID;
                _ASSERTE(dwDeviceId);
                lpctstrDeviceName = EventJobInfo.pJobData->lpctstrDeviceName;
                _ASSERTE(lpctstrDeviceName);
                dwQueueStatus = EventJobInfo.pJobData->dwQueueStatus;
                dwExtendedStatus = EventJobInfo.pJobData->dwExtendedStatus;
                lpctstrExtendedStatus = EventJobInfo.pJobData->lpctstrExtendedStatus;
                strQueueStatus = GetQueueStatusTStr(dwQueueStatus);
                strExtendedStatus = GetExtendedStatusTStr(dwExtendedStatus);
                strProprietaryExtendedStatus = lpctstrExtendedStatus;
                os<<TEXT("Extended Event JobData-")<<endl;
                os<<TEXT("lpctstrDeviceName:\t")<<lpctstrDeviceName<<endl;
                os<<TEXT("dwDeviceId:\t")<<dwDeviceId<<endl;
                os<<TEXT("QueueStatus:\t")<<strQueueStatus<<endl;
                os<<TEXT("ExtendedStatus:\t")<<strExtendedStatus<<endl;
                if (NULL != strProprietaryExtendedStatus)
                {
                    os<<TEXT("ProprietaryExtendedStatus:\t")<<strProprietaryExtendedStatus<<endl;
                }
                else
                {
                    os<<TEXT("ProprietaryExtendedStatus:\t(null)")<<endl;
                }
            }
            break;

        case FAX_EVENT_TYPE_CONFIG:
            _ASSERTE((FaxEventEx.EventInfo).ConfigType < (sizeof(g_tstrFaxQueueStatus)/sizeof(g_tstrFaxQueueStatus[0])));
            strConfigType = g_tstrFaxConfigEventTypes[(FaxEventEx.EventInfo).ConfigType];
            os<<TEXT("ConfigType:\t")<<strConfigType<<endl;
            break;

        case FAX_EVENT_TYPE_ACTIVITY:
            os<<TEXT("dwIncomingMessages:\t")<<(FaxEventEx.EventInfo).ActivityInfo.dwIncomingMessages<<endl;
            os<<TEXT("dwRoutingMessages:\t")<<(FaxEventEx.EventInfo).ActivityInfo.dwRoutingMessages<<endl;
            os<<TEXT("dwOutgoingMessages:\t")<<(FaxEventEx.EventInfo).ActivityInfo.dwOutgoingMessages<<endl;
            os<<TEXT("dwDelegatedOutgoingMessages:\t")<<(FaxEventEx.EventInfo).ActivityInfo.dwDelegatedOutgoingMessages<<endl;
            os<<TEXT("dwQueuedMessages:\t")<<(FaxEventEx.EventInfo).ActivityInfo.dwQueuedMessages<<endl;
            break;

        case FAX_EVENT_TYPE_QUEUE_STATE:
            os<<TEXT("dwQueueStates:\t")<<(FaxEventEx.EventInfo).dwQueueStates<<endl;
            break;

        default:
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d [CostrstreamEx& operator<<]\n- FaxEventEx.EventType=0x%08X is out of enumaration scope\n"),
                TEXT(__FILE__),
                __LINE__,
                FaxEventEx.EventType
                );
            _ASSERTE(FALSE);
            break;
    }

    return(os);
}


//
//
//
BOOL CopyFaxExtendedEvent(
    OUT FAX_EVENT_EX**  ppDstFaxEventEx,
    IN  FAX_EVENT_EX    SrcFaxEventEx
)
{
    BOOL fRetVal = FALSE;
    FAX_EVENT_EX*   pDstFaxEventEx = NULL;
    DWORD           dwEventTypeIndex = 0;
    LPCTSTR         strEventType = NULL;
    LPCTSTR         strJobEventType = NULL;
    LPCTSTR         strConfigEventType = NULL;
    LPCTSTR         strQueueStatus = NULL;
    LPCTSTR         strExtendedStatus = NULL;
    LPCTSTR         strProprietaryExtendedStatus = NULL;
    LPCTSTR         strConfigType = NULL;
    DWORD           dwQueueStatus = 0;
    DWORD           dwExtendedStatus = 0;
    LPCTSTR         lpctstrExtendedStatus = NULL;
    DWORD           dwQueueStatusIndex = 0;
    FAX_EVENT_JOB*  pSrcEventJobInfo = NULL;
    FAX_EVENT_JOB*  pDstEventJobInfo = NULL;

    pDstFaxEventEx = (FAX_EVENT_EX*) malloc (sizeof(FAX_EVENT_EX));
    if (NULL == pDstFaxEventEx)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\n[CSendInfo::AddItem] new failed with ec=0x%08X"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    ZeroMemory(pDstFaxEventEx, sizeof(FAX_EVENT_EX));

    pDstFaxEventEx->dwSizeOfStruct = SrcFaxEventEx.dwSizeOfStruct;
    pDstFaxEventEx->TimeStamp = SrcFaxEventEx.TimeStamp;
    pDstFaxEventEx->EventType = SrcFaxEventEx.EventType;

    switch (SrcFaxEventEx.EventType)
    {
        case FAX_EVENT_TYPE_IN_QUEUE:
        case FAX_EVENT_TYPE_OUT_QUEUE:
        case FAX_EVENT_TYPE_IN_ARCHIVE:
        case FAX_EVENT_TYPE_OUT_ARCHIVE:
            pSrcEventJobInfo = &((SrcFaxEventEx.EventInfo).JobInfo);
            pDstEventJobInfo = &((pDstFaxEventEx->EventInfo).JobInfo);
            pDstEventJobInfo->dwlMessageId = pSrcEventJobInfo->dwlMessageId;
            pDstEventJobInfo->Type = pSrcEventJobInfo->Type;
            pDstEventJobInfo->pJobData = NULL;
            if (FAX_JOB_EVENT_TYPE_STATUS == pSrcEventJobInfo->Type)
            {
                _ASSERTE(pSrcEventJobInfo->pJobData);
                pDstEventJobInfo->pJobData = (PFAX_JOB_STATUS) malloc (sizeof(FAX_JOB_STATUS));
                if(NULL == pDstEventJobInfo->pJobData)
                {
                    ::lgLogError(
                        LOG_SEV_1,
                        TEXT("FILE:%s LINE:%d [CopyFaxExtendedEvent]\n malloc failed with ec=0x%08X\n"),
                        TEXT(__FILE__),
                        __LINE__,
                        ::GetLastError()
                        );
                    goto ExitFunc;
                }
                ZeroMemory(pDstEventJobInfo->pJobData, sizeof(FAX_JOB_STATUS));
                pDstEventJobInfo->pJobData->dwSizeOfStruct = pSrcEventJobInfo->pJobData->dwSizeOfStruct;
                pDstEventJobInfo->pJobData->dwValidityMask = pSrcEventJobInfo->pJobData->dwValidityMask;
                pDstEventJobInfo->pJobData->dwJobID = pSrcEventJobInfo->pJobData->dwJobID;
                pDstEventJobInfo->pJobData->dwJobType = pSrcEventJobInfo->pJobData->dwJobType;
                pDstEventJobInfo->pJobData->dwSize = pSrcEventJobInfo->pJobData->dwSize;
                pDstEventJobInfo->pJobData->dwPageCount = pSrcEventJobInfo->pJobData->dwPageCount;
                pDstEventJobInfo->pJobData->dwCurrentPage = pSrcEventJobInfo->pJobData->dwCurrentPage;
                pDstEventJobInfo->pJobData->tmScheduleTime = pSrcEventJobInfo->pJobData->tmScheduleTime;
                // TODO: the field was removed. New field was added: EndTime
                //pDstEventJobInfo->pJobData->tmTransmissionTime = pSrcEventJobInfo->pJobData->tmTransmissionTime;
                pDstEventJobInfo->pJobData->dwDeviceID = pSrcEventJobInfo->pJobData->dwDeviceID;
                pDstEventJobInfo->pJobData->dwRetries = pSrcEventJobInfo->pJobData->dwRetries;
                pDstEventJobInfo->pJobData->dwQueueStatus = pSrcEventJobInfo->pJobData->dwQueueStatus;
                pDstEventJobInfo->pJobData->dwExtendedStatus = pSrcEventJobInfo->pJobData->dwExtendedStatus;

                if (pSrcEventJobInfo->pJobData->lpctstrExtendedStatus)
                {
                    pDstEventJobInfo->pJobData->lpctstrExtendedStatus = ::_tcsdup(pSrcEventJobInfo->pJobData->lpctstrExtendedStatus);
                    if (NULL == pDstEventJobInfo->pJobData->lpctstrExtendedStatus)
                    {
                        ::lgLogError(
                            LOG_SEV_1,
                            TEXT("FILE:%s LINE:%d [CopyFaxExtendedEvent]\n _tcsdup failed with ec=0x%08X\n"),
                            TEXT(__FILE__),
                            __LINE__,
                            ::GetLastError()
                            );
                        goto ExitFunc;
                    }
                }
                if (pSrcEventJobInfo->pJobData->lpctstrTsid)
                {
                    pDstEventJobInfo->pJobData->lpctstrTsid = ::_tcsdup(pSrcEventJobInfo->pJobData->lpctstrTsid);
                    if (NULL == pDstEventJobInfo->pJobData->lpctstrTsid)
                    {
                        ::lgLogError(
                            LOG_SEV_1,
                            TEXT("FILE:%s LINE:%d [CopyFaxExtendedEvent]\n _tcsdup failed with ec=0x%08X\n"),
                            TEXT(__FILE__),
                            __LINE__,
                            ::GetLastError()
                            );
                        goto ExitFunc;
                    }
                }
                if (pSrcEventJobInfo->pJobData->lpctstrCsid)
                {
                    pDstEventJobInfo->pJobData->lpctstrCsid = ::_tcsdup(pSrcEventJobInfo->pJobData->lpctstrCsid);
                    if (NULL == pDstEventJobInfo->pJobData->lpctstrCsid)
                    {
                        ::lgLogError(
                            LOG_SEV_1,
                            TEXT("FILE:%s LINE:%d [CopyFaxExtendedEvent]\n _tcsdup failed with ec=0x%08X\n"),
                            TEXT(__FILE__),
                            __LINE__,
                            ::GetLastError()
                            );
                        goto ExitFunc;
                    }
                }
                if (pSrcEventJobInfo->pJobData->lpctstrDeviceName)
                {
                    pDstEventJobInfo->pJobData->lpctstrDeviceName = ::_tcsdup(pSrcEventJobInfo->pJobData->lpctstrDeviceName);
                    if (NULL == pDstEventJobInfo->pJobData->lpctstrDeviceName)
                    {
                        ::lgLogError(
                            LOG_SEV_1,
                            TEXT("FILE:%s LINE:%d [CopyFaxExtendedEvent]\n _tcsdup failed with ec=0x%08X\n"),
                            TEXT(__FILE__),
                            __LINE__,
                            ::GetLastError()
                            );
                        goto ExitFunc;
                    }
                }
                if (pSrcEventJobInfo->pJobData->lpctstrCallerID)
                {
                    pDstEventJobInfo->pJobData->lpctstrCallerID = ::_tcsdup(pSrcEventJobInfo->pJobData->lpctstrCallerID);
                    if (NULL == pDstEventJobInfo->pJobData->lpctstrCallerID)
                    {
                        ::lgLogError(
                            LOG_SEV_1,
                            TEXT("FILE:%s LINE:%d [CopyFaxExtendedEvent]\n _tcsdup failed with ec=0x%08X\n"),
                            TEXT(__FILE__),
                            __LINE__,
                            ::GetLastError()
                            );
                        goto ExitFunc;
                    }
                }
                if (pSrcEventJobInfo->pJobData->lpctstrRoutingInfo)
                {
                    pDstEventJobInfo->pJobData->lpctstrRoutingInfo = ::_tcsdup(pSrcEventJobInfo->pJobData->lpctstrRoutingInfo);
                    if (NULL == pDstEventJobInfo->pJobData->lpctstrRoutingInfo)
                    {
                        ::lgLogError(
                            LOG_SEV_1,
                            TEXT("FILE:%s LINE:%d [CopyFaxExtendedEvent]\n _tcsdup failed with ec=0x%08X\n"),
                            TEXT(__FILE__),
                            __LINE__,
                            ::GetLastError()
                            );
                        goto ExitFunc;
                    }
                }
            }
            break;

        case FAX_EVENT_TYPE_CONFIG:
            (pDstFaxEventEx->EventInfo).ConfigType = SrcFaxEventEx.EventInfo.ConfigType;
            break;

        case FAX_EVENT_TYPE_ACTIVITY:
            (pDstFaxEventEx->EventInfo).ActivityInfo.dwIncomingMessages = SrcFaxEventEx.EventInfo.ActivityInfo.dwIncomingMessages;
            (pDstFaxEventEx->EventInfo).ActivityInfo.dwRoutingMessages = SrcFaxEventEx.EventInfo.ActivityInfo.dwRoutingMessages;
            (pDstFaxEventEx->EventInfo).ActivityInfo.dwOutgoingMessages = SrcFaxEventEx.EventInfo.ActivityInfo.dwOutgoingMessages;
            (pDstFaxEventEx->EventInfo).ActivityInfo.dwDelegatedOutgoingMessages = SrcFaxEventEx.EventInfo.ActivityInfo.dwDelegatedOutgoingMessages;
            (pDstFaxEventEx->EventInfo).ActivityInfo.dwQueuedMessages = SrcFaxEventEx.EventInfo.ActivityInfo.dwQueuedMessages;
            break;

        case FAX_EVENT_TYPE_QUEUE_STATE:
            (pDstFaxEventEx->EventInfo).dwQueueStates = SrcFaxEventEx.EventInfo.dwQueueStates;
            break;

        default:
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d [CopyFaxExtendedEvent]\n- FaxEventEx.EventType=0x%08X is out of enumaration scope\n"),
                TEXT(__FILE__),
                __LINE__,
                SrcFaxEventEx.EventType
                );
            _ASSERTE(FALSE);
            break;
    }

    (*ppDstFaxEventEx) = pDstFaxEventEx;
    fRetVal = TRUE;

ExitFunc:
    if (FALSE == fRetVal)
    {
        switch (SrcFaxEventEx.EventType)
        {
            case FAX_EVENT_TYPE_IN_QUEUE:
            case FAX_EVENT_TYPE_OUT_QUEUE:
            case FAX_EVENT_TYPE_IN_ARCHIVE:
            case FAX_EVENT_TYPE_OUT_ARCHIVE:
                if ((pDstFaxEventEx->EventInfo).JobInfo.pJobData)
                {
                    free((LPTSTR)(pDstFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrExtendedStatus);
                    free((LPTSTR)(pDstFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrTsid);
                    free((LPTSTR)(pDstFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrCsid);
                    free((LPTSTR)(pDstFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrDeviceName);
                    free((LPTSTR)(pDstFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrCallerID);
                    free((LPTSTR)(pDstFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrRoutingInfo);
                    free((LPTSTR)(pDstFaxEventEx->EventInfo).JobInfo.pJobData);
                    ZeroMemory((pDstFaxEventEx->EventInfo).JobInfo.pJobData, sizeof(FAX_JOB_STATUS));
                }
                break;

            default:
                // no strings to free
                break;
        }
    }
    return(fRetVal);
}

//
// FreeFaxExtendedEvent:
//  Frees all memory associated with pFaxEventEx
//
void FreeFaxExtendedEvent(
    IN  FAX_EVENT_EX*   pFaxEventEx
)
{
    _ASSERTE(pFaxEventEx);
    switch (pFaxEventEx->EventType)
    {
        case FAX_EVENT_TYPE_IN_QUEUE:
        case FAX_EVENT_TYPE_OUT_QUEUE:
        case FAX_EVENT_TYPE_IN_ARCHIVE:
        case FAX_EVENT_TYPE_OUT_ARCHIVE:
            if ((pFaxEventEx->EventInfo).JobInfo.pJobData)
            {
                free((LPTSTR)(pFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrExtendedStatus);
                free((LPTSTR)(pFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrTsid);
                free((LPTSTR)(pFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrCsid);
                free((LPTSTR)(pFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrDeviceName);
                free((LPTSTR)(pFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrCallerID);
                free((LPTSTR)(pFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrRoutingInfo);
                ZeroMemory((pFaxEventEx->EventInfo).JobInfo.pJobData, sizeof(FAX_JOB_STATUS));
                free((LPTSTR)(pFaxEventEx->EventInfo).JobInfo.pJobData);
            }
            break;

        default:
            // no strings to free
            break;
    }
    ZeroMemory(pFaxEventEx, sizeof(FAX_EVENT_EX));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxsender\faxsender.cpp ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Module name:		FaxSender.cpp
// Author:			Sigalit Bar (sigalitb)
// Date:			23-Jul-98
//


//
//	Description:
//		This file contains the implementation of class CFaxSender.
//


#include <FaxSender.h>



///////////////////////
// FAX_SENDER_STATUS //
///////////////////////

//
//	operator<< (for struct FAX_SENDER_STATUS)
//
CostrstreamEx& operator<<(
	IN OUT	CostrstreamEx&				os, 
	IN		const FAX_SENDER_STATUS&	SenderStatus)
{
	os<<endl;
	os<<"\tLastErrorFromFaxService:\t";
	
	if (ERROR_SUCCESS == SenderStatus.LastErrorFromFaxService)
	{
		os<<"ERROR_SUCCESS (0)";
	}
	else
	{
		CHAR strLastErr[20] = {0};
		::_ultoa(SenderStatus.LastErrorFromFaxService, strLastErr, 16);
		_ASSERTE(strLastErr[0]);
		os << strLastErr;
	}

	os<<endl;
	os<<"\tLastEventFromFaxQueue:\t\t";
	if (NULL == SenderStatus.pLastEventFromFaxQueue)
	{
		os<<"NO_FAX_EVENTS";
	}
	else
	{
		os<<(*SenderStatus.pLastEventFromFaxQueue);
	}

	return(os);
}

//
//	operator<< (for struct FAX_SENDER_STATUS)
//
CotstrstreamEx& operator<<(
	CotstrstreamEx&				/* IN OUT */	os, 
	const FAX_SENDER_STATUS&	/* IN */		SenderStatus)
{
	os << endl;
	os << TEXT("\tLastErrorFromFaxService:\t");
	if (ERROR_SUCCESS == SenderStatus.LastErrorFromFaxService)
	{
		os << TEXT("ERROR_SUCCESS (0)");
	}
	else
	{
		TCHAR tstrLastErr[20] = {0};
		::_ultot(SenderStatus.LastErrorFromFaxService, tstrLastErr, 16);
		_ASSERTE(tstrLastErr[0]);
		os << tstrLastErr;
	}

	os<<endl;
	os<<TEXT("\tLastEventExFromFaxQueue:\t\t");
	if (NULL == SenderStatus.pLastEventFromFaxQueue)
	{
		os<<TEXT("NO_FAX_EVENTS");
	}
	else
	{
		os<<(*SenderStatus.pLastEventFromFaxQueue);
	}

	return(os);
}


////////////////
// CFaxSender //
////////////////

#ifdef _NT5FAXTEST
	// Testing NT5 Fax (with old winfax.dll)
//
// private static member of CFaxSender
//
CFaxCompletionPort CFaxSender::m_TheFaxCompletionPort;
#endif

CFaxSender::CFaxSender(LPCTSTR szMachineName ):
	m_dwSendJobId(0),
	m_dwlSendJobMessageId(0),
	m_fSendSuccess(FALSE),
	m_szSendFileName(NULL),
	m_szCPFileName(NULL),
	m_szSendRecipientNumber(NULL)
{
	m_szMachineName = NULL; // do NOT remove this line or SetMachineName() assertion will fail
	if ( FALSE == SetMachineName(szMachineName))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SetMachineName(%s) returned FALSE\n"),
			TEXT(__FILE__),
			__LINE__,
			szMachineName
			);
		_ASSERTE(FALSE);
	}
	m_SendStatus.pLastEventFromFaxQueue = NULL;
	m_SendStatus.LastErrorFromFaxService = ERROR_SUCCESS;
}	


CFaxSender::~CFaxSender( void )
{
	delete(m_szMachineName);
	delete(m_szSendFileName);
	delete(m_szCPFileName);
	delete(m_szSendRecipientNumber);
}


//
// GetSendInfo:
//	Returns a const reference to instance member m_SendInfo.
//
const CSendInfo& CFaxSender::GetSendInfo( void ) const
{
	return(m_SendInfo);
}


//
// GetLastStatus:
//	Returns a const reference to instance member m_SendStatus.
//
const FAX_SENDER_STATUS& CFaxSender::GetLastStatus( void ) const
{
	return(m_SendStatus);	
}


//
// GetJobId:
//	Returns a const copy of instance member m_dwSendJobId.
//
const DWORD CFaxSender::GetJobId(void) const
{
	return(m_dwSendJobId);
}


//
// send:
//	Sends a fax synchronouslly and accumulates
//	every FAX_EVENT relevant to it. 
//	This implies that an I\O Completion Port 
//  is created and the Fax Service Queue is set
//	to post all FAX_EVENTs to it (see class
//	CFaxCompletionPort for details).
//
BOOL CFaxSender::send(
	LPCTSTR /* IN */ szFileName, 
	LPCTSTR /* IN */ szCPFileName, 
	LPCTSTR /* IN */ szRecipientNumber
	)
{
	DWORD dwLastError = ERROR_SUCCESS; 	// Used for Last error returned from call to ::SendFax

	//
	// Reset instance members
	//
	m_dwSendJobId = 0;
	m_fSendSuccess = FALSE;
	m_SendInfo.RemoveAll();
	m_SendStatus.LastErrorFromFaxService = ERROR_SUCCESS;
	m_SendStatus.pLastEventFromFaxQueue = NULL;

	//
	// Set filename and recipient number members to new values
	//
	BOOL fReturnValueOfSetSendFileName;
	BOOL fReturnValueOfSetCPFileName;
	BOOL fReturnValueOfSetSendRecipientNumber;
	fReturnValueOfSetSendFileName = SetSendFileName(szFileName);
	fReturnValueOfSetCPFileName = SetCPFileName(szCPFileName);
	fReturnValueOfSetSendRecipientNumber = SetSendRecipientNumber(szRecipientNumber);
	// If either of members could not be set return FALSE
	if ((FALSE == fReturnValueOfSetSendFileName) ||
		(FALSE == fReturnValueOfSetCPFileName) ||
		(FALSE == fReturnValueOfSetSendRecipientNumber))
	{
		return(FALSE);
	}

	// Get the completion port used with the Fax Service Queue
	HANDLE hCompletionPort = NULL;
	if (!m_TheFaxCompletionPort.GetCompletionPortHandle(
			m_szMachineName,
			hCompletionPort,
			m_SendStatus.LastErrorFromFaxService))
	{
		return(FALSE);
	}
	_ASSERTE(NULL != hCompletionPort);

	//
	// Send the fax
	//
	m_fSendSuccess = ::SendFax(
		m_szSendRecipientNumber,
		m_szSendFileName,
		m_szCPFileName,
		m_szMachineName,
		hCompletionPort,
		NULL,
		&m_dwSendJobId,
		&m_dwlSendJobMessageId,
		m_SendInfo,
		&dwLastError
		);

	//
	// Set m_SendStatus to new values
	//
	m_SendStatus.LastErrorFromFaxService = dwLastError;
#ifdef _NT5FAXTEST
// Legacy API
	m_SendInfo.GetLastJobEvent(&m_SendStatus.pLastEventFromFaxQueue, m_dwSendJobId);
#else
// Extended private API - MessageId is available
	m_SendInfo.GetLastJobEvent(&m_SendStatus.pLastEventFromFaxQueue, m_dwlSendJobMessageId);
#endif

	return(m_fSendSuccess);
}

//
// send_broadcast:
//	Sends a broadcast fax synchronouslly and accumulates
//	every FAX_EVENT relevant to it. 
//	This implies that an I\O Completion Port 
//  is created and the Fax Service Queue is set
//	to post all FAX_EVENTs to it (see class
//	CFaxCompletionPort for details).
//
BOOL CFaxSender::send_broadcast(
	LPCTSTR				/* IN */ szFileName, 
	CFaxBroadcast*		/* IN */ pmyFaxBroadcastObj
	)
{
	DWORD dwLastError = ERROR_SUCCESS; 	// Used for Last error returned from call to ::SendFax

	//
	// Reset instance members
	//
	m_dwSendJobId = 0;
	m_fSendSuccess = FALSE;
	m_SendInfo.RemoveAll();
	m_SendStatus.LastErrorFromFaxService = ERROR_SUCCESS;
	m_SendStatus.pLastEventFromFaxQueue = NULL;

	//
	// Set filename and recipient number members to new values
	//
	BOOL fReturnValueOfSetSendFileName;
	BOOL fReturnValueOfSetCPFileName;
	BOOL fReturnValueOfSetSendRecipientNumber;
	fReturnValueOfSetSendFileName = SetSendFileName(szFileName);
	fReturnValueOfSetCPFileName = SetCPFileName(NULL);
	fReturnValueOfSetSendRecipientNumber = SetSendRecipientNumber(NULL);
	// If either of members could not be set return FALSE
	if ((FALSE == fReturnValueOfSetSendFileName) ||
		(FALSE == fReturnValueOfSetCPFileName) ||
		(FALSE == fReturnValueOfSetSendRecipientNumber))
	{
		return(FALSE);
	}

	// Get the completion port used with the Fax Service Queue
	HANDLE hCompletionPort = NULL;
	if (!m_TheFaxCompletionPort.GetCompletionPortHandle(
			m_szMachineName,
			hCompletionPort,
			m_SendStatus.LastErrorFromFaxService))
	{
		return(FALSE);
	}
	_ASSERTE(NULL != hCompletionPort);

	//
	// Send the fax
	//
	m_fSendSuccess = ::SendFax(
		m_szSendRecipientNumber,
		m_szSendFileName,
		m_szCPFileName,
		m_szMachineName,
		hCompletionPort,
		(LPVOID)(pmyFaxBroadcastObj),
		&m_dwSendJobId,
		&m_dwlSendJobMessageId,
		m_SendInfo,
		&dwLastError
		);

	//
	// Set m_SendStatus to new values
	//
	m_SendStatus.LastErrorFromFaxService = dwLastError;

#ifdef _NT5FAXTEST
// Legacy API
	m_SendInfo.GetLastJobEvent(&m_SendStatus.pLastEventFromFaxQueue, m_dwSendJobId);
#else
// Extended private API - MessageId is available
	m_SendInfo.GetLastJobEvent(&m_SendStatus.pLastEventFromFaxQueue, m_dwlSendJobMessageId);
#endif

	return(m_fSendSuccess);
}

//
// abort:
//	Asynchronouslly aborts the send fax job with JobId equal to m_dwSendJobId.
//
// Note:
//	Since send() is synchronous, any synchronous abort() will fail.
//	Thus it only makes sense to call this method from a separate
//	thread (which has a reference to the instance).
//
// IMPORTANT:
//	Since the implementation of class CFaxSender is NOT thread safe
//	we choose that abort() will not change any of the instance's
//	members.
//	Thus the only way to tell whether the abort succeeded or failed 
//	is via the function's return value.
//
// Return Value:
//	TRUE if the request to abort succeeded.
//	Otherwise FALSE.
//
BOOL CFaxSender::abort(void)
{
	DWORD dwLastError;
	//We do not use dwLastError, since we just want
	//to log it, and ::AbortFax already does that for us.
	return(::AbortFax(m_szMachineName,m_dwSendJobId,&dwLastError));
}


//
// operator<<
//	Outputs a description of every one of the instance's 
//	members to the given stream.
//
CostrstreamEx& operator<<(CostrstreamEx& /* IN OUT */ os, const CFaxSender& /* IN */ Sender) 
{
	Sender.InsertAllButEventsIntoOs(os);
	os<<"Events:"<<endl;
	os<<Sender.m_SendInfo;
	return(os);
}

//
// operator<<
//	Outputs a description of every one of the instance's 
//	members to the given stream.
//
CotstrstreamEx& operator<<(CotstrstreamEx& /* IN OUT */ os, const CFaxSender& /* IN */ Sender) 
{
	Sender.InsertAllButEventsIntoOs(os);
	os<<TEXT("Events:")<<endl;
	os<<Sender.m_SendInfo;
	return(os);
}


//
// cstr:
//	Returns a string which contains all the instance's information.
//	
LPCTSTR CFaxSender::cstr(void) const
{
	CostrstreamEx myOs;

	myOs<<endl;
	myOs<<(*this); //use operator << of class to "print" to stream
	return(myOs.cstr());
	//above is OK since cstr() allocates string
}


//
// outputAllToLog:
//	Outputs a description of every one of the instance's 
//	members to the logger. Including ALL the events 
//	accumulated in the instance's m_SendInfo member.
//
void CFaxSender::outputAllToLog(
	const DWORD /* IN */ dwSeverity, 
	const DWORD /* IN */ dwLevel
	) const
{
	CostrstreamEx os;

	::lgLogDetail(dwSeverity,dwLevel,TEXT("Logging CFaxSender instance information"));

	os<<endl;
	InsertAllButEventsIntoOs(os);
	
	LPCTSTR myStr = os.cstr();
	::lgLogDetail(dwSeverity,dwLevel,myStr);
	delete[]((LPTSTR)myStr);

	::lgLogDetail(dwSeverity,dwLevel,TEXT("Logging CFaxSender instance fax events"));
	m_SendInfo.outputAllToLog(dwSeverity,dwLevel);

}


//
// outputJobToLog:
//	Outputs a description of every one of the instance's 
//	members to the logger.
//	ONLY the fax events with JobId equal to the instance's
//	m_dwSendJobId member are outputed to the logger (NOT ALL 
//	events).
//
void CFaxSender::outputJobToLog(
	const DWORD /* IN */ dwSeverity, 
	const DWORD /* IN */ dwLevel
	) const
{
	CostrstreamEx os;

	::lgLogDetail(dwSeverity,dwLevel,TEXT("Logging CFaxSender instance information"));

	os<<endl;
	InsertAllButEventsIntoOs(os);
	
	LPCTSTR myStr = os.cstr();
	::lgLogDetail(dwSeverity,dwLevel,myStr);
	delete[]((LPTSTR)myStr);

	::lgLogDetail(
		dwSeverity,
		dwLevel,
		TEXT("Logging CFaxSender instance fax events for job#%d"),
		m_dwSendJobId);

#ifdef _NT5FAXTEST
// Legacy API
	// log event info (FAX_EVENT)
	m_SendInfo.outputJobToLog(m_dwSendJobId,dwSeverity,dwLevel);
#else
// Extended private API - MessageId is available
	// log extended event info (FAX_EVENT_EX)
	m_SendInfo.outputJobToLog(m_dwlSendJobMessageId,dwSeverity,dwLevel);
#endif

}


//
// SetSendFileName:
//	Sets the instance's m_szSendFileName to szStr.
//	A copy of szStr is created and m_szSendFileName
//	is set to point to it.
//
BOOL CFaxSender::SetSendFileName(LPCTSTR szStr)
{
	delete(m_szSendFileName);
	m_szSendFileName = NULL;

	if (NULL == szStr) return(TRUE);

	//dup
	m_szSendFileName = ::_tcsdup(szStr);
	if (NULL == m_szSendFileName)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
		return(FALSE);
	}

	return(TRUE);
}
//
// SetCPFileName:
//	Sets the instance's m_szCPFileName to szStr.
//	A copy of szStr is created and m_szCPFileName
//	is set to point to it.
//
BOOL CFaxSender::SetCPFileName(LPCTSTR szStr)
{
	delete(m_szCPFileName);
	m_szCPFileName = NULL;

	if (NULL == szStr) return(TRUE);

	//dup
	m_szCPFileName = ::_tcsdup(szStr);
	
	if (NULL == m_szCPFileName)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
		return(FALSE);
	}

	return(TRUE);
}
//
// SetMachineName:
//	Sets the instance's m_szMachineName to szStr.
//	A copy of szStr is created and m_szMachineName
//	is set to point to it.
//  This function is only called once from the
//	constructor.
//
BOOL CFaxSender::SetMachineName(LPCTSTR szStr)
{
	_ASSERTE(NULL == m_szMachineName);
	//m_szMachineName = NULL;

	if (NULL == szStr) return(TRUE);

	//dup
	m_szMachineName = ::_tcsdup(szStr);
	if (NULL == m_szMachineName)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
		return(FALSE);
	}

	return(TRUE);
}


//
// SetSendRecipientNumber:
//	Sets the instance's m_szSendRecipientNumber to szStr.
//	A copy of szStr is created and m_szSendRecipientNumber
//	is set to point to it.
//
BOOL CFaxSender::SetSendRecipientNumber(LPCTSTR szStr)
{
	delete(m_szSendRecipientNumber);
	m_szSendRecipientNumber = NULL;

	if (NULL == szStr) return(TRUE);

	//dup
	m_szSendRecipientNumber = ::_tcsdup(szStr);
	if (NULL == m_szSendRecipientNumber)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
		return(FALSE);
	}

	return(TRUE);
}

//
// InsertAllButEventsIntoOs:
//	Appends a string description of all the instance's members
//	except for m_SendInfo.
//
CostrstreamEx& CFaxSender::InsertAllButEventsIntoOs(IN OUT	CostrstreamEx&	os) const
{
	LPCSTR szConvertedStr;


	os<<"m_szMachineName:\t";
	//stream takes MBCS only, so convert if necessary
	szConvertedStr = ::DupTStrAsStr(m_szMachineName);
	if (NULL == szConvertedStr)
	{
		os<<"NULL"<<endl;
	}
	else
	{
		os<<szConvertedStr<<endl;
	}
	delete[] ((LPSTR)szConvertedStr);

	os<<"m_dwSendJobId:\t\t"<<m_dwSendJobId<<endl;

	os<<"m_szSendFileName:\t";
	//stream takes MBCS only, so convert if necessary
	szConvertedStr = ::DupTStrAsStr(m_szSendFileName);
	if (NULL == szConvertedStr)
	{
		os<<"NULL"<<endl;
	}
	else
	{
		os<<szConvertedStr<<endl;
	}
	delete[] ((LPSTR)szConvertedStr);

	os<<"m_szCPFileName:\t";
	//stream takes MBCS only, so convert if necessary
	szConvertedStr = ::DupTStrAsStr(m_szCPFileName);
	if (NULL == szConvertedStr)
	{
		os<<"NULL"<<endl;
	}
	else
	{
		os<<szConvertedStr<<endl;
	}
	delete[] ((LPSTR)szConvertedStr);

	os<<"m_szSendRecipientNumber:\t";
	//stream takes MBCS only, so convert if necessary
	szConvertedStr = ::DupTStrAsStr(m_szSendRecipientNumber);
	if (NULL == szConvertedStr)
	{
		os<<"NULL"<<endl;
	}
	else
	{
		os<<szConvertedStr<<endl;
	}
	delete[] ((LPSTR)szConvertedStr);

	os<<"m_fSendSuccess:\t\t";
	if (TRUE == m_fSendSuccess)
	{
		os<<"TRUE"<<endl;
	}
	else
	{
		os<<"FALSE"<<endl;
	}

	os<<"m_SendStatus:\t\t";
	os<<m_SendStatus<<endl;

	return(os);
}

//
// InsertAllButEventsIntoOs:
//	Appends a string description of all the instance's members
//	except for m_SendInfo.
//
CotstrstreamEx& CFaxSender::InsertAllButEventsIntoOs(CotstrstreamEx& /* IN OUT */ os) const
{

	os << TEXT("m_szMachineName:\t");
	//stream takes MBCS only, so convert if necessary
	if (NULL == m_szMachineName)
	{
		os << TEXT("NULL") << endl;
	}
	else
	{
		os << m_szMachineName << endl;
	}

	os << TEXT("m_dwSendJobId:\t\t") << m_dwSendJobId << endl;

	os << TEXT("m_szSendFileName:\t");
	//stream takes MBCS only, so convert if necessary
	if (NULL == m_szSendFileName)
	{
		os << TEXT("NULL") << endl;
	}
	else
	{
		os << m_szSendFileName << endl;
	}

	os << TEXT("m_szCPFileName:\t");
	//stream takes MBCS only, so convert if necessary
	if (NULL == m_szCPFileName)
	{
		os << TEXT("NULL") << endl;
	}
	else
	{
		os << m_szCPFileName << endl;
	}

	os << TEXT("m_szSendRecipientNumber:\t");
	//stream takes MBCS only, so convert if necessary
	if (NULL == m_szSendRecipientNumber)
	{
		os << TEXT("NULL") << endl;
	}
	else
	{
		os << m_szSendRecipientNumber << endl;
	}

	os << TEXT("m_fSendSuccess:\t\t");
	if (TRUE == m_fSendSuccess)
	{
		os << TEXT("TRUE") << endl;
	}
	else
	{
		os<< TEXT("FALSE") << endl;
	}

	os << TEXT("m_SendStatus:\t\t");
	os << m_SendStatus << endl;

	return(os);
}

#ifndef _NT5FAXTEST
// Availlable in extended private API only
const DWORDLONG CFaxSender::GetMessageId(void) const
{
	return(m_dwlSendJobMessageId);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\tiffutils\bmp2tiff.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    bmp2tiff.c

Abstract:

    This file contains support for converting a
    Windows BMP file to a TIFF file.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/



#include "TiffUtilsP.h"
#pragma hdrstop



#define Align(p, x)  (((x) & ((p)-1)) ? (((x) & ~((p)-1)) + p) : (x))



DWORD
WINAPI
ConvertBmpToTiff(
    LPTSTR BmpFile,
    LPTSTR TiffFile,
    DWORD CompressionType
    )

/*++

Routine Description:

    Converts a BMP file to a TIFF file.

Arguments:

    BmpFile             - BMP file name
    TiffFile            - TIFF file name
    CompressionType     - Compression method, see tifflib.h

Return Value:

    None.

--*/

{
    HANDLE hFileIn;
    HANDLE hMapIn;
    LPVOID FilePtrIn;
    HANDLE hTiff;
    PBMPINFO BmpInfo;
    DWORD LineWidth;
    DWORD FileSize;
    LPBYTE Bits;
    DWORD i,j;
    LPBYTE SrcPtr;
    DWORD RealWidth;
    BYTE BitBuffer[(1728/8)*2];


    hFileIn = CreateFile(
        BmpFile,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );
    if (hFileIn != INVALID_HANDLE_VALUE) {
        return GetLastError();
    }

    hMapIn = CreateFileMapping(
        hFileIn,
        NULL,
        PAGE_READONLY | SEC_COMMIT,
        0,
        0,
        NULL
        );
    if (!hMapIn) {
        return GetLastError();
    }

    FilePtrIn = MapViewOfFile(
        hMapIn,
        FILE_MAP_READ,
        0,
        0,
        0
        );
    if (!FilePtrIn) {
        return GetLastError();
    }

    FileSize = GetFileSize( hFileIn, NULL );

    BmpInfo = (PBMPINFO) FilePtrIn;

    LineWidth = BmpInfo->SizeImage / BmpInfo->Height;
    Bits = (LPBYTE) ( (LPBYTE)FilePtrIn + BmpInfo->Offset );
    SrcPtr = ((LPBYTE)FilePtrIn + BmpInfo->Offset) + (LineWidth * (BmpInfo->Height - 1));
    RealWidth = Align( 8, BmpInfo->Width ) / 8;

    hTiff = TiffCreate( TiffFile, CompressionType, LineWidth*8, 1, 1 );
    if (!hTiff) {
        return GetLastError();
    }

    TiffStartPage( hTiff );

    for (i=0; i<BmpInfo->Height; i++) {
        FillMemory( BitBuffer, sizeof(BitBuffer), 0xff );
        CopyMemory( BitBuffer, SrcPtr, RealWidth );
        if (BmpInfo->Width % 8) {
            BitBuffer[BmpInfo->Width/8] |= 0xf;
        }
        for (j=0; j<sizeof(BitBuffer); j++) {
            BitBuffer[j] ^= 0xff;
        }
        SrcPtr -= LineWidth;
        TiffWrite( hTiff, BitBuffer );
    }

    TiffEndPage( hTiff );

    UnmapViewOfFile( FilePtrIn );
    CloseHandle( hMapIn );
    CloseHandle( hFileIn );

    TiffClose( hTiff );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxsender\test.h ===
//
//
// Filename:	test.h
// Author:		Sigalit Bar (sigalitb)
// Date:		30-Dec-98
//
//

#ifndef _TEST_H_
#define _TEST_H_

#include <windows.h>
#include <fxsapip.h>

#include <TCHAR.H>
#include "crtdbg.h"

#include <log.h>
#include <FaxSender.h>


#ifdef __cplusplus
extern "C" {
#endif

#define TEST_ARCHIVE_DIR	TEXT("C:\\CometBVT\\FaxBVT\\Faxes\\SentFaxes")
#define TEST_MIN_PORTS		1

#define MY_FPF_NONE			0

#define DEV1_TSID			TEXT("CometFax dev1")
#define DEV1_CSID			TEXT("CometFax dev1")
#define DEV2_TSID			TEXT("CometFax dev2")
#define DEV2_CSID			TEXT("CometFax dev2")
#define DEV_TSID			TEXT("CometFax dev>2")
#define DEV_CSID			TEXT("CometFax dev>2")

//
// TestSuiteSetup:
//	Initializes logger and changes the Fax server configuration
//	for the tests.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber		IN parameter
//					Phone number of first device installed on server.
//					Will be set up as sending device.
//
//	szDocument		IN parameter
//					Filename of document to be used in tests.
//					The function only prints this string to logger (for debugging).
//
//	szCoverPage		IN parameter
//					Filename of cover page to be used in tests.
//					The function only prints this string to logger (for debugging).
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestSuiteSetup(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
);

//
// TestCase1:
//	Send a fax + CP.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber		IN parameter
//					Phone number to send fax to.
//
//	szDocument		IN parameter
//					Filename of document to send.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase1(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
);

//
// TestCase2:
//	Send a broadcast (3 times the same recipient) with cover pages.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber 	IN parameter
//					Phone number to send faxes to.
//
//	szDocument		IN parameter
//					Filename of document to send.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase2(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
);

//
// TestSuiteShutdown:
//	Perform test suite cleanup (close logger).
//
// Return Value:
//	TRUE if successful, FALSE otherwise.
//
BOOL WINAPIV TestSuiteShutdown(void);



#ifdef __cplusplus
}
#endif 

#endif //_TEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxsender\test.cpp ===
//
//
// Filename:	bvt.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		30-Dec-98
//
//

#include "test.h"

//forward declerations:

//
// SetupPort:
//	Private module function used to set port configuration
// 
static BOOL SetupPort(
	IN  HANDLE				hFaxSvc,
	IN  PFAX_PORT_INFO		pPortInfo,
	IN  DWORD				dwFlags,
	IN  LPCTSTR				szTsid,
	IN  LPCTSTR				szCsid
	);

//
// SendRegularFax: 
//	Private module function used to send a fax
//
static BOOL SendRegularFax(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
);




//
// TestSuiteSetup:
//	Initializes logger and changes the Fax server configuration
//	for the tests.
//
BOOL WINAPIV TestSuiteSetup(
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber,
	LPCTSTR		szDocument,
	LPCTSTR		szCoverPage)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber);
	_ASSERTE(NULL != szDocument);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;
	HANDLE hFaxSvc = NULL;
	DWORD dwNumFaxPorts = 0;
	int nPortIndex = 0;
	PFAX_CONFIGURATION pFaxSvcConfig = NULL;
	PFAX_PORT_INFO	pFaxPortsConfig = NULL;

	//
	// Init logger
	//
	if (!::lgInitializeLogger())
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgInitializeLogger failed with GetLastError()=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	//
	// Begin test suite (logger)
	//
	if(!::lgBeginSuite(TEXT("BVT suite")))
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgBeginSuite failed with GetLastError()=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	// log CometFaxSender.exe params using elle logger
	::lgLogDetail(
		LOG_X,
		1,
		TEXT("CometFaxSender params:\n\tszServerName=%s\n\tszFaxNumber1=%s\n\tszDocument=%s\n\tszCoverPage=%s\n\t"),
		szServerName,
		szFaxNumber,
		szDocument,
		szCoverPage
		);

	//
	// Setup fax service
	//
	if (!FaxConnectFaxServer(szServerName,&hFaxSvc))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\nFaxConnectFaxServer(%s) failed with GetLastError()=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			szServerName,
			::GetLastError()
			);
        goto ExitFunc;
	}

	//
	// Setup Service configuration
	//

	// Retrieve the fax service configuration
    if (!FaxGetConfiguration(hFaxSvc, &pFaxSvcConfig)) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxGetConfiguration returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }
	//check that FaxGetConfiguration allocated
	_ASSERTE(pFaxSvcConfig);

	pFaxSvcConfig->Retries = 0;
	pFaxSvcConfig->PauseServerQueue = FALSE;
	pFaxSvcConfig->ArchiveOutgoingFaxes = TRUE;
	pFaxSvcConfig->ArchiveDirectory = TEST_ARCHIVE_DIR;
	pFaxSvcConfig->Branding = TRUE;

	// Set the fax service configuration
    if (!FaxSetConfiguration(hFaxSvc, pFaxSvcConfig)) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxSetConfiguration returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }

	//
	// Setup the two ports
	//

    // Retrieve the fax ports configuration
    if (!FaxEnumPorts(hFaxSvc, &pFaxPortsConfig, &dwNumFaxPorts)) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxEnumPorts returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }
	_ASSERTE(pFaxPortsConfig);

	if (TEST_MIN_PORTS > dwNumFaxPorts)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\n dwNumFaxPorts(=%d) < TEST_MIN_PORTS(=%d)\n"),
			TEXT(__FILE__),
			__LINE__,
			dwNumFaxPorts,
			TEST_MIN_PORTS
			);
        goto ExitFunc;
	}
	else
	{
		::lgLogDetail(
			LOG_X, 
			1,
			TEXT("FILE:%s LINE:%d\ndwNumFaxPorts=%d\nTEST_MIN_PORTS=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			dwNumFaxPorts,
			TEST_MIN_PORTS
			);
	}


    // Set 1st device as Send only (note pFaxPortsConfig array is 0 based)
	if (FALSE == SetupPort(
					hFaxSvc, 
					&pFaxPortsConfig[0], 
					FPF_SEND, 
					DEV1_TSID, 
					DEV1_CSID
					)
		)
	{
		goto ExitFunc;
	}

	if (2 <= dwNumFaxPorts)
	{
		// Set 2nd device as Receive only (note pFaxPortsConfig array is 0 based)
		if (FALSE == SetupPort(
						hFaxSvc, 
						&pFaxPortsConfig[1], 
						FPF_RECEIVE, 
						DEV2_TSID, 
						DEV2_CSID
						)
			)
		{
			goto ExitFunc;
		}

		// set all other devices as Receive=No and Send=No
		// NOTE: nPortIndex is 0 based
		for (nPortIndex = 2; nPortIndex < dwNumFaxPorts; nPortIndex++)
		{
			if (FALSE == SetupPort(
							hFaxSvc, 
							&pFaxPortsConfig[nPortIndex], 
							MY_FPF_NONE, 
							DEV_TSID, 
							DEV_CSID
							)
				)
			{
				goto ExitFunc;
			}
		}
	}

	fRetVal = TRUE;

ExitFunc:
	::FaxFreeBuffer(pFaxPortsConfig);
	if (FALSE == ::FaxClose(hFaxSvc))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxClose returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
	}
	return(fRetVal);
}


//
// TestCase1:
//	Send a fax + CP.
//
BOOL TestCase1(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber);
	_ASSERTE(NULL != szDocument);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;

	::lgBeginCase(
		1,
		TEXT("TC#1: Send a fax + CP")
		);

	fRetVal = SendRegularFax(szServerName, szFaxNumber, szDocument, szCoverPage);

	::lgEndCase();
	return(fRetVal);
}


//
// TestCase2:
//	Send a broadcast (3 times the same recipient) with cover pages.
//
BOOL TestCase2(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber);
	_ASSERTE(NULL != szDocument);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;
	FAX_SENDER_STATUS myFaxSenderStatus;
	CostrstreamEx os;
	LPCTSTR myStr = NULL;
    FAX_PERSONAL_PROFILE RecipientProfile = {0};

	::lgBeginCase(
		1,
		TEXT("TC#2: Send a broadcast with CP (3 * same recipient)")
		);
	::lgLogDetail(
		LOG_X,
		1,
		TEXT("Server=%s\nFaxNumber=%s\nDocument=%s\nCoverPage=%s\n"),
		szServerName,
		szFaxNumber,
		szDocument,
		szCoverPage
		);

	// create the fax sending object
	CFaxSender myFaxSender(TRUE, szServerName);  //if constructor fails an assertion is raised

	// create a broadcast object with 3 recipients
	CFaxBroadcast myFaxBroadcastObj;
	if (FALSE == myFaxBroadcastObj.SetCPFileName(szCoverPage))
	{
		::lgLogError(LOG_SEV_1,TEXT("myFaxBroadcastObj.SetCPFileName() failed"));
		goto ExitFunc;
	}
	// add 1st recipient to broadcast
    RecipientProfile.dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);
    RecipientProfile.lptstrName = TEXT("Recipient Number1");
    RecipientProfile.lptstrFaxNumber = (LPTSTR)szFaxNumber;
	if (FALSE == myFaxBroadcastObj.AddRecipient(&RecipientProfile))
	{
		::lgLogError(LOG_SEV_1,TEXT("1st myFaxBroadcastObj.AddRecipient() failed"));
		goto ExitFunc;
	}
	// add 2nd recipient to broadcast
    RecipientProfile.lptstrName = TEXT("Recipient Number2");
    RecipientProfile.lptstrFaxNumber = (LPTSTR)szFaxNumber;
	if (FALSE == myFaxBroadcastObj.AddRecipient(&RecipientProfile))
	{
		::lgLogError(LOG_SEV_1,TEXT("2nd myFaxBroadcastObj.AddRecipient() failed"));
		goto ExitFunc;
	}
	// add 3rd recipient to broadcast
    RecipientProfile.lptstrName = TEXT("Recipient Number3");
    RecipientProfile.lptstrFaxNumber = (LPTSTR)szFaxNumber;
	if (FALSE == myFaxBroadcastObj.AddRecipient(&RecipientProfile))
	{
		::lgLogError(LOG_SEV_1,TEXT("3rd myFaxBroadcastObj.AddRecipient() failed"));
		goto ExitFunc;
	}

	myFaxBroadcastObj.outputAllToLog(LOG_X,1);

	fRetVal = myFaxSender.send_broadcast( szDocument, &myFaxBroadcastObj,TRUE);
	myFaxSenderStatus = myFaxSender.GetLastStatus();
	if (FALSE == fRetVal)
	{
		// test case failed
		::lgLogError(LOG_SEV_1,TEXT("myFaxSender.send_broadcast returned FALSE"));
	}
	else
	{
		// test case succeeded
		::lgLogDetail(LOG_X,1,TEXT("myFaxSender.send_broadcast returned TRUE"));
	}

	// log the last status returned from the fax sending object
	os<<myFaxSenderStatus;
	myStr = os.cstr();
	::lgLogDetail(LOG_X,1,myStr);
	delete[]((LPTSTR)myStr);

ExitFunc:
	::lgEndCase();
	return(fRetVal);
}


//
// TestSuiteShutdown:
//	Perform test suite cleanup (close logger).
//
BOOL TestSuiteShutdown(void)
{
	BOOL fRetVal = TRUE;

	//
	// End test suite (logger)
	//
	if (!::lgEndSuite())
	{
		//
		//this is not possible since API always returns TRUE
		//but to be on the safe side
		//
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgEndSuite returned FALSE\n"),
			TEXT(__FILE__),
			__LINE__
			);
		fRetVal = FALSE;
	}

	//
	// Close the Logger
	//
	if (!::lgCloseLogger())
	{
		//this is not possible since API always returns TRUE
		//but to be on the safe side
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgCloseLogger returned FALSE\n"),
			TEXT(__FILE__),
			__LINE__
			);
		fRetVal = FALSE;
	}

	return(fRetVal);
}


//
// SetupPort:
//	Private module function, used to set port configuration.
// 
// Parameters:
//	hFaxSvc			IN parameter.
//					A handle to the Fax service.
//
//	pPortInfo		IN parameter.
//					A pointer to the original port configuration, as returned 
//					from a call to FaxGetPort or FaxEnumPorts.
//
//	dwFlags			IN parameter.
//					Bit flags that specify the new capabilities of the fax port.
//					See FAX_PORT_INFO for more information.
//
//	szTsid			IN parameter.
//					A string that specifies the new transmitting station identifier.
//
//	szCsid			IN parameter.
//					A string that specifies the new called station identifier.
//
// Return Value:
//	TRUE if successful, FALSE otherwise.
//
static BOOL SetupPort(
	IN  HANDLE				hFaxSvc,
	IN  PFAX_PORT_INFO		pPortInfo,
	IN  DWORD				dwFlags,
	IN  LPCTSTR				szTsid,
	IN  LPCTSTR				szCsid
	)
{
	BOOL fRetVal = FALSE;
	HANDLE hPort = NULL;

	// check in params
	_ASSERTE(NULL != hFaxSvc);
	_ASSERTE(NULL != pPortInfo);
	_ASSERTE(NULL != szTsid);
	_ASSERTE(NULL != szCsid);

	// Set pPortInfo as required
	pPortInfo->Flags = dwFlags;
	pPortInfo->Tsid	 = szTsid;
	pPortInfo->Csid  = szCsid;

	// get the device Id
	DWORD dwDeviceId = pPortInfo->DeviceId;

	// open the port for configuration
	if(!FaxOpenPort(hFaxSvc, dwDeviceId, PORT_OPEN_MODIFY, &hPort))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxOpenPort returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	// set the device configuration
	if(!FaxSetPort(hPort, pPortInfo))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxSetPort returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	fRetVal = TRUE;

ExitFunc:
	if (FALSE == ::FaxClose(hPort))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxClose returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
	}
	return(fRetVal);
}

//
// SendRegularFax:
//	Sends a fax.
//
// NOTE: This function is private to this module, it is not exported.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to use.
//  
//	szFaxNumber2	IN parameter
//					Phone number to send fax to.
//
//	szDocument		IN parameter
//					Filename of document to send.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
static BOOL SendRegularFax(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber);
	_ASSERTE(NULL != szDocument);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;
	FAX_SENDER_STATUS myFaxSenderStatus;

	::lgLogDetail(
		LOG_X,
		1,
		TEXT("Server=%s\nFaxNumber=%s\nDocument=%s\nCoverPage=%s\n"),
		szServerName,
		szFaxNumber,
		szDocument,
		szCoverPage
		);

	CFaxSender myFaxSender(TRUE, szServerName);  //if constructor fails an assertion is raised
	fRetVal = myFaxSender.send( szDocument, szCoverPage, szFaxNumber,TRUE);
	myFaxSenderStatus = myFaxSender.GetLastStatus();
	if (FALSE == fRetVal)
	{
		// test case failed
		::lgLogError(LOG_SEV_1,TEXT("myFaxSender.send returned FALSE"));
	}
	else
	{
		// test case succeeded
		::lgLogDetail(LOG_X,1,TEXT("myFaxSender.send returned TRUE"));
	}

	CostrstreamEx os;
	os<<myFaxSenderStatus;
	LPCTSTR myStr = os.cstr();
	::lgLogDetail(LOG_X,1,myStr);
	delete[]((LPTSTR)myStr);


	return(fRetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\faxsender\main.cpp ===
//
//
// Filename:	main.cpp
// Author:		Sigalit Bar
// Date:		30-dec-98
//
//


#include "test.h"

#define HELP_SWITCH_1        TEXT("/?")
#define HELP_SWITCH_2        TEXT("/H")
#define HELP_SWITCH_3        TEXT("-?")
#define HELP_SWITCH_4        TEXT("-H")

#define MAX_ARGS	6 //including exe name

#define ARGUMENT_IS_SERVER_NAME		1
#define ARGUMENT_IS_FAX_NUMBER		2
#define ARGUMENT_IS_DOC				3
#define ARGUMENT_IS_CP				4
#define ARGUMENT_IS_BROADCAST		5

//
// global pointer to process heap
//
HANDLE g_hMainHeap = NULL;


//
// UsageInfo:
//	Outputs application's proper usage and exits process.
//
void
UsageInfo(void)
{
	::_tprintf(TEXT("WindowsXPFaxSender\n\n"));
	::_tprintf(TEXT("WindowsXPFaxSender server_name fax_number document cover_page broadcast\n"));
	::_tprintf(TEXT("    server_name	The name of the fax server (without the \\\\)\n"));
	::_tprintf(TEXT("    fax_number		The fax number of the 1st device on server\n"));
	::_tprintf(TEXT("    document		The full path of the document to send\n"));
	::_tprintf(TEXT("    cover_page		The full path to the cover page to send\n"));
	::_tprintf(TEXT("    Broadcast		TRUE or FALSE to indicate if to send to a single recipient or a broadcast\n"));
	::_tprintf(TEXT("\n"));
	exit(0);
}


//
// ParseCmdLineParams:
//	Parses the command line parameters, saves a copy of them,
//	and converts from MBCS to UNICODE if necessary.
//
// Parameters:
//	argc				IN parameter.
//						command line number of arguments.
//	argvA[]				IN parameter.
//						command line args (in MBCS).
//	pszServerName		OUT parameter.
//						Pointer to string to copy 1st argument to.
//						Represents the name of fax server to use.
//	pszFaxNumber		OUT parameter.
//						Pointer to string to copy 2nd argument to.
//						Represents the fax number of 1st device on the
//						above fax server.
//	pszDocument			OUT parameter.
//						Pointer to string to copy 3rd argument to.
//						Represents the name of document to use with tests.
//	pszCoverPage		OUT parameter.
//						Pointer to string to copy 4th argument to.
//						Represents the name of the cover page to use
//						with tests.
//
//	pszBroadcast		OUT parameter.
//						Pointer to string to copy 5th argument to.
//						Represents a flag to indicate if to send a single 
//						or a broadcast job.
//
// Return Value:
//	TRUE on success and FALSE on failure.
//
//
BOOL 
ParseCmdLineParams(
	const INT	/* IN */	argc,
	CHAR *		/* IN */	argvA[],
	LPTSTR*		/* OUT */	pszServerName,
	LPTSTR*		/* OUT */	pszFaxNumber,
	LPTSTR*		/* OUT */	pszDocument,
	LPTSTR*		/* OUT */	pszCoverPage,
	LPTSTR*		/* OUT */	pszBroadcast
	)
{
	_ASSERTE(pszServerName);
	_ASSERTE(pszDocument);
	_ASSERTE(pszFaxNumber);
	_ASSERTE(pszCoverPage);
	_ASSERTE(pszBroadcast);

	DWORD	dwArgLoopIndex;
	DWORD	dwArgSize;
	LPTSTR	aszParam[MAX_ARGS];

	//
	// Check number of parameters
	//
	if ( ( argc != MAX_ARGS ) && ( argc != 2 ) )  
	{
		::_tprintf(TEXT("\nInvalid invokation of WindowsXPFaxSender.exe\n\n"));
		::_tprintf(TEXT("WindowsXPFaxSender.exe Help:\n"));
		::UsageInfo(); //UsageInfo() exits process.
	}

	//
	// Initialize awcsParam[]
	//
	for (dwArgLoopIndex = 0; dwArgLoopIndex < MAX_ARGS; dwArgLoopIndex++)
	{
		aszParam[dwArgLoopIndex] = NULL;
	}

	//
	// Loop on arguments in argvA[]
	//
    for (dwArgLoopIndex = 1; dwArgLoopIndex < (DWORD) argc; dwArgLoopIndex++) 
	{
		//
        // Determine the memory required for the parameter
		//
        dwArgSize = (::lstrlenA(argvA[dwArgLoopIndex]) + 1) * sizeof(TCHAR);

		//
        // Allocate the memory for the parameter
		//
		_ASSERTE(g_hMainHeap);
        aszParam[dwArgLoopIndex] = (TCHAR*)::HeapAlloc(
			g_hMainHeap, 
			HEAP_ZERO_MEMORY, 
			dwArgSize
			);
		if(NULL == aszParam[dwArgLoopIndex])
		{
			::_tprintf(TEXT("FILE:%s LINE:%d\n HeapAlloc returned NULL\n"),
				TEXT(__FILE__),
				__LINE__
				);
			goto ExitFuncFail;
		}

		//
		// Copy content of argument from argvA[index] to new allocation
		//
#ifdef _UNICODE
		// argvA[] is a CHAR*, so it needs to be converted to a WCHAR* ifdef UNICODE
        // Convert awcsParam
		if (!::MultiByteToWideChar(
			CP_ACP, 
			0, 
			argvA[dwArgLoopIndex], 
			-1, 
			aszParam[dwArgLoopIndex], 
			(::lstrlenA(argvA[dwArgLoopIndex]) + 1) * sizeof(WCHAR))
			)
		{
			::_tprintf(
				TEXT("FILE:%s LINE:%d\n MultiByteToWideChar failed With GetLastError()=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError()
				);
			goto ExitFuncFail;
		}
#else //_MBCS
		::strcpy(aszParam[dwArgLoopIndex],argvA[dwArgLoopIndex]);
		if (strcmp(aszParam[dwArgLoopIndex],argvA[dwArgLoopIndex]))
		{
			::_tprintf(
				TEXT("FILE:%s LINE:%d\n string copy or compare failed\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError()
				);
			goto ExitFuncFail;
		}
#endif
		//
		// Check for help switch
		//
		// If this is the second argument, it may be one of several help switches defined.
		// A help switch can appear only as the second argument.
        if (2 == argc)
		{
			if (! (!::lstrcmpi(HELP_SWITCH_1, aszParam[dwArgLoopIndex])) || 
				  (!::lstrcmpi(HELP_SWITCH_2, aszParam[dwArgLoopIndex])) || 
				  (!::lstrcmpi(HELP_SWITCH_3, aszParam[dwArgLoopIndex])) || 
				  (!::lstrcmpi(HELP_SWITCH_4, aszParam[dwArgLoopIndex]))
				) 
			{
				::_tprintf(TEXT("Invalid invokation of CometFaxSender.exe\n\n"));
			}
			::UsageInfo(); //UsageInfo() exits the process.
		}

		//
		// Treat each argument accordingly
		//
		switch (dwArgLoopIndex)
		{
		case ARGUMENT_IS_SERVER_NAME:
			//server_name param
			(*pszServerName) = aszParam[dwArgLoopIndex];
			break;

		case ARGUMENT_IS_FAX_NUMBER:
			//fax_number1 param
			(*pszFaxNumber) = aszParam[dwArgLoopIndex];
			break;

		case ARGUMENT_IS_DOC:
			//document param
			(*pszDocument) = aszParam[dwArgLoopIndex];
			break;

		case ARGUMENT_IS_CP:
			//cover_page param
			(*pszCoverPage) = aszParam[dwArgLoopIndex];
			break;
		
		case ARGUMENT_IS_BROADCAST:
			//broadcast param
			(*pszBroadcast) = aszParam[dwArgLoopIndex];
			break;

		default:
			::_tprintf(TEXT("FILE:%s LINE:%d\n default reached dwArgLoopIndex=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				dwArgLoopIndex
				);
			_ASSERTE(FALSE);
			return FALSE;
		}// switch (dwIndex)

	}//for (dwIndex = 1; dwIndex < (DWORD) argc; dwIndex++)


	//If all is well then we do NOT free 
	//pszServerName, pszFaxNumber1, pszFaxNumber2, pszDocument and pszCoverPage,
	//since these allocations were the purpose of the function.
	return(TRUE);

ExitFuncFail:

	//
	// Free allocations
	//
	DWORD i;
	//0 to MAX_ARGS is ok, since that is aszParam array size and we NULLed all of it first
	for (i=0; i<MAX_ARGS; i++) 
	{
		if (NULL == aszParam[i]) continue;
		if (FALSE == ::HeapFree(g_hMainHeap, 0, aszParam[i]))
		{
			::_tprintf(TEXT("FILE:%s LINE:%d loop#%d\nHeapFree returned FALSE with GetLastError()=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				i,
				::GetLastError()
				);
			return(FALSE);
		}
	}

	//
	//reset OUT parameters
	//
	(*pszServerName) = NULL;
	(*pszFaxNumber) = NULL;
	(*pszDocument) = NULL;
	(*pszCoverPage) = NULL;
	(*pszBroadcast) = NULL;

	return(FALSE);
}




//
// main body of application.
//
int __cdecl
main(
	INT   argc,
    CHAR  *argvA[]
)
{
	BOOL bRet = FALSE;
	int nReturnValue = 1; //"default" return value is to indicate error

	LPTSTR szServerName = NULL;
	LPTSTR szFaxNumber = NULL;
	LPTSTR szDocument = NULL;
	LPTSTR szCoverPage = NULL;
	LPTSTR szBroadcast = NULL;

	HINSTANCE hModWinfax = NULL;
	LPVOID pVoidTempFunc = NULL;

	//
	// Set g_hMainHeap to process heap
	//
	g_hMainHeap = NULL;
	g_hMainHeap = ::GetProcessHeap();
	if(NULL == g_hMainHeap)
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nGetProcessHeap returned NULL with GetLastError()=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	//
	// Parse the command line
	//
	bRet = ::ParseCmdLineParams(
		argc,
		argvA,
		&szServerName,
		&szFaxNumber,
		&szDocument,
		&szCoverPage,
		&szBroadcast
		);

	if (FALSE == bRet)
	{
		goto ExitFunc;
	}


	//
	// "Debug" printing of the command line parameters after parsing
	//
#ifdef _DEBUG
	::_tprintf(
		TEXT("DEBUG DEBUG DEBUG\nServer=%s\nFaxNumber=%s\nDocument=%s\nCoverPage=%s\nBroadcast=%s\n"),
		szServerName,
		szFaxNumber,
		szDocument,
		szCoverPage,
		szBroadcast
		);
#endif

	bRet = TestSuiteSetup(
		szServerName,
		szFaxNumber,
		szDocument,
		szCoverPage
		);
	
	if (FALSE == bRet)
	{
		goto ExitFunc;
	}

	if (0 == _tcsicmp(szBroadcast,TEXT("TRUE")))
	{
		//
		//Send a broadcast with CP (3 * same recipient)
		//
		bRet = TestCase2(			
			szServerName,
			szFaxNumber,
			szDocument,
			szCoverPage
			);
	}
	else
	{

		//
		//Send a single recp fax + CP
		//
		bRet = TestCase1(			
			szServerName,
			szFaxNumber,
			szDocument,
			szCoverPage
			);
	}


ExitFunc:
	
	//
	//We don't check the return code of TestSuiteShutdown() since we don't want to fail
	// the whole test case due to a problem with the logger.
	//
	TestSuiteShutdown();
	
	if (TRUE == bRet)
	{
		return(0);
	}
	else
	{
		return(1);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\tiffutils\dirtiffcmp.cpp ===
//
//
// Filename:	DirTiffCmp.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		3-Feb-99
//
//



#include <windows.h>
#include <TCHAR.H>
#include <log.h>
#include "VecTiffCmp.h"



extern "C" BOOL WINAPI DirToDirTiffCompare(
	LPTSTR	/* IN */	szDir1,
	LPTSTR	/* IN */	szDir2,
    BOOL    /* IN */    fSkipFirstLine,
	DWORD	/* IN */    dwExpectedNumberOfFiles
	)
{
	BOOL fRetVal = FALSE;
	CFilenameVector* pMyDir1FileVec = NULL;
	CFilenameVector* pMyDir2FileVec = NULL;


	if (NULL == szDir1)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n NULL==szDir1\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	if (NULL == szDir2)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n NULL==szDir2\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	if ( FALSE == GetTiffFilesOfDir(szDir1, &pMyDir1FileVec))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n DirToDirTiffCompare: GetTiffFilesOfDir(%s) failed\n"),
			TEXT(__FILE__),
			__LINE__,
            szDir1
			);
		goto ExitFunc;
	}

	PrintVector(pMyDir1FileVec);

	if (dwExpectedNumberOfFiles < 0xFFFFFFFF && dwExpectedNumberOfFiles != pMyDir1FileVec->size())
	{
		// The caller passed expected number of files and it differs from actual number of files
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n DirToDirTiffCompare: Actual number of files (%ld) in %s differs from the expected (%ld)\n"),
			TEXT(__FILE__),
			__LINE__,
			pMyDir1FileVec->size(),
            szDir1,
			dwExpectedNumberOfFiles
			);
		goto ExitFunc;
	}

	if ( FALSE == GetTiffFilesOfDir(szDir2, &pMyDir2FileVec))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n DirToDirTiffCompare: GetTiffFilesOfDir(%s) failed\n"),
			TEXT(__FILE__),
			__LINE__,
            szDir2
			);
		goto ExitFunc;
	}

	PrintVector(pMyDir2FileVec);

	if (dwExpectedNumberOfFiles < 0xFFFFFFFF && dwExpectedNumberOfFiles != pMyDir2FileVec->size())
	{
		// The caller passed expected number of files and it differs from actual number of files
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n DirToDirTiffCompare: Actual number of files (%ld) in %s differs from the expected (%ld)\n"),
			TEXT(__FILE__),
			__LINE__,
			pMyDir2FileVec->size(),
            szDir2,
			dwExpectedNumberOfFiles
			);
		goto ExitFunc;
	}

	::lgLogDetail(
		LOG_X,
        1,
		TEXT("FILE(%s) LINE(%d):\n DirToDirTiffCompare: comparing %s and %s with fSkipFirstLine=%d\n"),
		TEXT(__FILE__),
		__LINE__,
        szDir1,
        szDir2,
        fSkipFirstLine
		);

    fRetVal = VecToVecTiffCompare(pMyDir1FileVec, pMyDir2FileVec, fSkipFirstLine);

ExitFunc:
	FreeVector(pMyDir1FileVec);
	FreeVector(pMyDir2FileVec);
	return(fRetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\tiffutils\filenamevec.cpp ===
//
//
// Filename:	FilenameVec.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		3-Feb-99
//
//



#include "FilenameVec.h"
#include <crtdbg.h>
#include <log.h>



//
// func creats the CFilenameVector and adds all TIF files in szDir to it
//
BOOL GetTiffFilesOfDir(
	LPCTSTR				/* IN */	szDir,
	CFilenameVector**	/* OUT */	ppMyDirFileVec
	)
{
	BOOL fRetVal = FALSE;

    fRetVal = GetFilesOfDir(szDir, TEXT("TIF"), ppMyDirFileVec);

	return(fRetVal);
}

//
// creates new vector and adds all files with extension szFileExtension in szDir to it
//
// Note: szDir must be without last '\' char (e.g. "C:\Dir1\Dir2", NOT "C:\Dir1\Dir2\")
//       szFileExtension must be the actual extension (e.g. "tif" or "*", NOT "*.tif" or "*.*")
BOOL GetFilesOfDir(
	LPCTSTR				/* IN */	szDir,
	LPCTSTR				/* IN */	szFileExtension,
	CFilenameVector**	/* OUT */	ppMyDirFileVec
	)
{
	BOOL fRetVal = FALSE;
	DWORD dwErr = 0;
	HANDLE hFindFile = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA FindFileData;
	LPTSTR szCurrentFullFilename = NULL;
	CFilenameVector* pTmpDirFileVec = NULL;
	DWORD dwLen = 0;

	_ASSERTE(NULL != ppMyDirFileVec);
	_ASSERTE(NULL != szFileExtension);
	_ASSERTE(NULL != szDir);


	//
	// compose string of filenames to look for
	//
	TCHAR szLookFor[MAX_PATH];

    if (0 >= ::_sntprintf(szLookFor, MAX_PATH, TEXT("%s\\*.%s"), szDir, szFileExtension))
    {
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n _sntprintf failed\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
    }

	::lgLogDetail(
		LOG_X,
		9,
		TEXT("\n szLookFor=%s\n"),
		szLookFor
		);

	//
	// create an empty vector
	//
	pTmpDirFileVec = new(CFilenameVector);
	if (NULL == pTmpDirFileVec)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n new(CFilenameVector) failed\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	//
	// find first file
	//
	hFindFile =  ::FindFirstFile(szLookFor, &FindFileData);
	dwErr = ::GetLastError();

	if ((INVALID_HANDLE_VALUE == hFindFile) && (ERROR_FILE_NOT_FOUND == dwErr))
	{
		//this is ok, we will return an empty vector
		::lgLogDetail(
			LOG_X,
			9,
			TEXT("no files found, returning empty vector\n")
			);
		(*ppMyDirFileVec) = pTmpDirFileVec;
		fRetVal = TRUE;
		goto ExitFunc;
	}

	if (INVALID_HANDLE_VALUE == hFindFile)
	{
		// INVALID_HANDLE_VALUE and last err != ERROR_FILE_NOT_FOUND
		// => error
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n FindFirstFile returned INVALID_HANDLE_VALUE with err=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			dwErr
			);
		goto ExitFunc;
	}


	//
	// add found file name to vector
	//
	if(NULL == FindFileData.cFileName)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n NULL==FindFileData.cFileName\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	dwLen = ::_tcslen(szDir) + ::_tcslen(FindFileData.cFileName) + 2;// backslash+null
	szCurrentFullFilename = new TCHAR[dwLen];
	if (NULL == szCurrentFullFilename)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n new failed with err=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}
	szCurrentFullFilename[dwLen-1] = TEXT('\0');

    if (0 >= ::_sntprintf(szCurrentFullFilename, MAX_PATH, TEXT("%s\\%s"), szDir, FindFileData.cFileName))
    {
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n _sntprintf failed\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
    }

	pTmpDirFileVec->push_back(szCurrentFullFilename);
	szCurrentFullFilename = NULL;


	//
	// look for any other such files in dir
	//
	while (TRUE == FindNextFile(hFindFile, &FindFileData))
	{
		// found another file with extension szFileExtension in dir
		// so add it to vector
		if(NULL == FindFileData.cFileName)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("FILE(%s) LINE(%d):\n NULL==FindFileData.cFileName\n"),
				TEXT(__FILE__),
				__LINE__
				);
			goto ExitFunc;
		}
		dwLen = ::_tcslen(szDir) + ::_tcslen(FindFileData.cFileName) + 2;//backslash+null
		szCurrentFullFilename = new TCHAR[dwLen];
		if (NULL == szCurrentFullFilename)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("FILE(%s) LINE(%d):\n new failed with err=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError()
				);
			goto ExitFunc;
		}
		szCurrentFullFilename[dwLen-1] = TEXT('\0');
        if (0 >= ::_sntprintf(szCurrentFullFilename, MAX_PATH, TEXT("%s\\%s"), szDir, FindFileData.cFileName))
        {
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE(%s) LINE(%d):\n _sntprintf failed\n"),
			    TEXT(__FILE__),
			    __LINE__
			    );
		    goto ExitFunc;
        }
		pTmpDirFileVec->push_back(szCurrentFullFilename);
		szCurrentFullFilename = NULL;
	} // 	while (TRUE == FindNextFile(hFindFile, &FindFileData))


	//no more files with extension szFileExtension in dir

	//
	// set out param
	//
	(*ppMyDirFileVec) = pTmpDirFileVec;
	fRetVal = TRUE;

ExitFunc:
	if (FALSE == fRetVal)
	{
		// free vec
		FreeVector(pTmpDirFileVec);
        delete(pTmpDirFileVec); 
	}
    if (INVALID_HANDLE_VALUE != hFindFile) 
    {
        if(!FindClose(hFindFile))
        {
			::lgLogError(
				LOG_SEV_1,
				TEXT("FILE(%s) LINE(%d):\n FindClose(hFindFile) failed with err=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError()
				);
        }
    }
 

	return(fRetVal);
}


//
// func copies pSrcFileVec vector to (*ppDstFileVec) vector
// copy is 1st level, that is, ptrs to strings are copied but
// strings themselves are not duplicated.
//
BOOL FirstLevelDup(
	CFilenameVector**	/* OUT */	ppDstFileVec,
	CFilenameVector*	/* IN */	pSrcFileVec
	)
{
	BOOL fRetVal = FALSE;
	UINT uSrcVecSize = 0;
	CFilenameVector* pTmpFileVec = NULL;
	UINT i = 0;
	LPTSTR szCurrentFullFilename = NULL;

	_ASSERTE(NULL != ppDstFileVec);
	_ASSERTE(NULL != pSrcFileVec);

	// create empty Dst vec
	pTmpFileVec = new(CFilenameVector);
	if (NULL == pTmpFileVec)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n new failed with err=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
	}

	uSrcVecSize = pSrcFileVec->size();
	if (0 == uSrcVecSize)
	{
		(*ppDstFileVec) = pTmpFileVec;
		fRetVal = TRUE;
		goto ExitFunc;
	}

	for (i = 0; i < uSrcVecSize; i++)
	{
		szCurrentFullFilename = (LPTSTR)pSrcFileVec->at(i);
		pTmpFileVec->push_back(szCurrentFullFilename);
		szCurrentFullFilename = NULL;
	}

	(*ppDstFileVec) = pTmpFileVec;
	fRetVal = TRUE;

ExitFunc:
	return(fRetVal);
}

// returns TRUE if pFileVec is empty (size=0), FALSE otherwise
BOOL IsEmpty(CFilenameVector* /* IN */ pFileVec)
{
	if (NULL == pFileVec)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n IsEmpty called with pFileVec==NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

	if (0 == pFileVec->size())
	{
		return(TRUE);
	}

    return(FALSE);
}

// removes all string pointers from vector (==clears vector)
// does NOT free the pointers.
void ClearVector(CFilenameVector* /* IN OUT */ pFileVec)
{
	if (NULL == pFileVec)
	{
		return;
	}
	pFileVec->clear();
}

// frees all strings in vector and clears vector
void FreeVector(CFilenameVector* /* IN OUT */ pFileVec)
{
	if (NULL == pFileVec)
	{
		return;
	}

	UINT uSize = pFileVec->size();
	UINT i = 0;
	for (i = 0; i < uSize; i++)
	{
		delete[](LPTSTR)pFileVec->at(i);
        (LPTSTR)pFileVec->at(i) = NULL;
	}
}

void PrintVector(CFilenameVector* /* IN */ pFileVec)
{
	if (NULL == pFileVec)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n pFileVec==NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return;
	}

	UINT uSize = pFileVec->size();
	if (0 == uSize)
	{
		::lgLogDetail(
			LOG_X,
			1,
			TEXT("\n Vector is Empty\n")
			);
		return;
	}

	TCHAR szBuf[MAX_PRINT_BUF];
	szBuf[0] = NULL;
	szBuf[MAX_PRINT_BUF-1] = NULL;

	::_stprintf(szBuf,TEXT("\n Vector size = %d\n"),uSize);
	_ASSERTE(MAX_PRINT_BUF > ::_tcslen(szBuf));

	UINT i = 0;
	for (i = 0; i < uSize; i++)
	{
		::_stprintf(szBuf,TEXT("%s\t filename(%d)=%s\n"),szBuf,i,pFileVec->at(i));
		_ASSERTE(MAX_PRINT_BUF > ::_tcslen(szBuf));
	}
    if (MAX_LOG_BUF > ::_tcslen(szBuf))
    {
	    ::lgLogDetail(
		    LOG_X,
		    1,
		    TEXT("%s"),
		    szBuf
		    );
    }
    else
    {
        ::_tprintf(TEXT("%s"),szBuf);
	    ::lgLogDetail(
		    LOG_X,
		    1,
		    TEXT("Vector too long, logged to console\n"),
		    szBuf
		    );
    }
}


BOOL DeleteVectorFiles(CFilenameVector* /* IN */ pFileVec)
{
    BOOL fRetVal = TRUE;
	UINT uSize = pFileVec->size();
	UINT i = 0;

    if (NULL == pFileVec)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n pFileVec==NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
        fRetVal = FALSE;
		goto ExitFunc;
	}

	if (0 == uSize)
	{
		::lgLogDetail(
			LOG_X,
			1,
			TEXT("FILE(%s) LINE(%d):\nVector is Empty - no files to delete\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	for (i = 0; i < uSize; i++)
	{
        if (FALSE == ::DeleteFile(pFileVec->at(i)))
        {
            //TO DO: what about when the delete fails because the file does not exist
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE(%s) LINE(%d):\nDeleteFile(%s) failed with err=0x%8X\n"),
			    TEXT(__FILE__),
			    __LINE__,
                pFileVec->at(i),
                ::GetLastError()
			    );
            fRetVal = FALSE;
        }
        else
        {
		    ::lgLogDetail(
			    LOG_X,
			    4,
			    TEXT("FILE(%s) LINE(%d):\ndeleted file %s\n"),
			    TEXT(__FILE__),
			    __LINE__,
                pFileVec->at(i)
			    );
        }
	}

ExitFunc:
    return(fRetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\tiffutils\filenamevec.h ===
#ifndef _FILENAME_VEC_H__
#define _FILENAME_VEC_H__



//
//
// Filename:	FilenameVec.h
// Author:		Sigalit Bar (sigalitb)
// Date:		3-Feb-99
//
//



#include <windows.h>
#include <TCHAR.H>
#include <vector>



#ifdef __cplusplus
extern "C"
{
#endif



#define MAX_LOG_BUF 1024
#define MAX_PRINT_BUF (1024*16)
#define FILE_TYPE_TO_LOOK_FOR	TEXT("\\*.tif")



// CMsgHandlerClientVector
// an STL vector of pointers to CMsgHandlerClients
#ifdef _C_FILENAME_VECTOR_
#error "redefinition of _C_FILENAME_VECTOR_"
#else
#define _C_FILENAME_VECTOR_
typedef std::vector< LPTSTR > CFilenameVector;
#endif



//
// func creats the CFilenameVector and adds all TIF files in szDir to it
//
BOOL GetTiffFilesOfDir(
	LPCTSTR				/* IN */	szDir,
	CFilenameVector**	/* OUT */	ppMyDirFileVec
	);

//
// creates new vector and adds all files with extension szFileExtension in szDir to it
//
// Note: szDir must be without last '\' char (e.g. "C:\Dir1\Dir2", NOT "C:\Dir1\Dir2\")
//       szFileExtension must be the actual extension (e.g. "tif" or "*", NOT "*.tif" or "*.*")
BOOL GetFilesOfDir(
	LPCTSTR				/* IN */	szDir,
	LPCTSTR				/* IN */	szFileExtension,
	CFilenameVector**	/* OUT */	ppMyDirFileVec
	);

//
// func copies pSrcFileVec vector to (*ppDstFileVec) vector
// copy is 1st level, that is, ptrs to strings are copied but
// strings themselves are not duplicated.
//
BOOL FirstLevelDup(
	CFilenameVector**	/* OUT */	ppDstFileVec,
	CFilenameVector*	/* IN */	pSrcFileVec
	);

// returns TRUE if pFileVec is empty, FALSE otherwise
BOOL IsEmpty(CFilenameVector* /* IN */ pFileVec);

// removes all string pointers from vector (==clears vector)
// does NOT free the pointers.
void ClearVector(CFilenameVector* /* IN OUT */ pFileVec);

// frees all strings in vector and clears vector
void FreeVector(CFilenameVector* /* IN OUT */ pFileVec);

// prints all strings in vector
void PrintVector(CFilenameVector* /* IN */ pFileVec);

// delete all files that vector holds names for
BOOL DeleteVectorFiles(CFilenameVector* /* IN */ pFileVec);

#ifdef __cplusplus
}
#endif



#endif //_FILENAME_VEC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\verifytifffiles\dirtiffcmp.cpp ===
//
//
// Filename:	DirTiffCmp.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		3-Feb-99
//
//


#include "DirTiffCmp.h"

BOOL DirToDirTiffCompare(
	LPTSTR	/* IN */	szDir1,
	LPTSTR	/* IN */	szDir2,
    BOOL    /* IN */    fSkipFirstLine,
	DWORD	/* IN */    dwExpectedNumberOfFiles // optional
	)
{
	BOOL fRetVal = FALSE;
	CFilenameVector* pMyDir1FileVec = NULL;
	CFilenameVector* pMyDir2FileVec = NULL;


	if (NULL == szDir1)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n NULL==szDir1\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	if (NULL == szDir2)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n NULL==szDir2\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	if ( FALSE == GetTiffFilesOfDir(szDir1, &pMyDir1FileVec))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n DirToDirTiffCompare: GetTiffFilesOfDir(%s) failed\n"),
			TEXT(__FILE__),
			__LINE__,
            szDir1
			);
		goto ExitFunc;
	}

	PrintVector(pMyDir1FileVec);

	if (dwExpectedNumberOfFiles < 0xFFFFFFFF && dwExpectedNumberOfFiles != pMyDir1FileVec->size())
	{
		// The caller passed expected number of files and it differs from actual number of files
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n DirToDirTiffCompare: Actual number of files (%ld) in %s differs from the expected (%ld)\n"),
			TEXT(__FILE__),
			__LINE__,
			pMyDir1FileVec->size(),
            szDir1,
			dwExpectedNumberOfFiles
			);
		goto ExitFunc;
	}

	if ( FALSE == GetTiffFilesOfDir(szDir2, &pMyDir2FileVec))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n DirToDirTiffCompare: GetTiffFilesOfDir(%s) failed\n"),
			TEXT(__FILE__),
			__LINE__,
            szDir2
			);
		goto ExitFunc;
	}

	PrintVector(pMyDir2FileVec);

	if (dwExpectedNumberOfFiles < 0xFFFFFFFF && dwExpectedNumberOfFiles != pMyDir2FileVec->size())
	{
		// The caller passed expected number of files and it differs from actual number of files
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n DirToDirTiffCompare: Actual number of files (%ld) in %s differs from the expected (%ld)\n"),
			TEXT(__FILE__),
			__LINE__,
			pMyDir2FileVec->size(),
            szDir2,
			dwExpectedNumberOfFiles
			);
		goto ExitFunc;
	}

	::lgLogDetail(
		LOG_X,
        1,
		TEXT("FILE(%s) LINE(%d):\n DirToDirTiffCompare: comparing %s and %s with fSkipFirstLine=%d\n"),
		TEXT(__FILE__),
		__LINE__,
        szDir1,
        szDir2,
        fSkipFirstLine
		);

    fRetVal = VecToVecTiffCompare(pMyDir1FileVec, pMyDir2FileVec, fSkipFirstLine);

ExitFunc:
	FreeVector(pMyDir1FileVec);
	FreeVector(pMyDir2FileVec);
	return(fRetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\verifytifffiles\dirtiffcmp.h ===
//
//
// Filename:	DirTiffCmp.h
// Author:		Sigalit Bar (sigalitb)
// Date:		3-Feb-99
//
//


#ifndef _DIR_TIFF_COMPARE_H__
#define _DIR_TIFF_COMPARE_H__


#include <windows.h>
#include <TCHAR.H>
#include <crtdbg.h>

#include "VecTiffCmp.h"
#include <log.h>


#ifdef __cplusplus
extern "C"
{
#endif

//
// func compares *.tif files in directory szDir1 to *.tif files in directory szDir2
// returns true iff for every *.tif file in szDir1 there exists a *.tif 
// file in szDir2 whose image is identical, and vice versa.
//
BOOL DirToDirTiffCompare(
	LPTSTR	/* IN */	szDir1,
	LPTSTR	/* IN */	szDir2,
    BOOL    /* IN */    fSkipFirstLine,
	DWORD	/* IN */    dwExpectedNumberOfFiles = 0xFFFFFFFF // optional
	);


#ifdef __cplusplus
}
#endif


#endif //_DIR_TIFF_COMPARE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\tiffutils\dllmain.c ===
#include <windows.h>


BOOL WINAPI 
DllMain(
    HINSTANCE hDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )

/*++

    FUNCTION:    DllMain
    
    INPUTS:      hDLL       - handle of DLL
                 dwReason   - indicates why DLL called
                 lpReserved - reserved
                 Note that the return value is used only when
                 dwReason = DLL_PROCESS_ATTACH.
                 Normally the function would return TRUE if DLL initial-
                 ization succeeded, or FALSE it it failed.

--*/

{
	UNREFERENCED_PARAMETER(hDLL);
	UNREFERENCED_PARAMETER(lpReserved);

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // DLL is attaching to the address space of the current process.
        //

      break;

    case DLL_THREAD_ATTACH:
        //
        // A new thread is being created in the current process.
        //

        break;

    case DLL_THREAD_DETACH:
        //
        // A thread is exiting cleanly.
        //

        break;

    case DLL_PROCESS_DETACH:
        //
        // The calling process is detaching the DLL from its address space.
        //

		break;

    default:
        MessageBox(
			NULL,
			TEXT("Reached default in DLLmain"),
			TEXT("TiffUtils.dll: DllMain failure:"),
			MB_OK
			);
        return FALSE;
    }//switch (dwReason)

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\verifytifffiles\filenamevec.h ===
//
//
// Filename:	FilenameVec.h
// Author:		Sigalit Bar (sigalitb)
// Date:		3-Feb-99
//
//


#ifndef _FILENAME_VEC_H__
#define _FILENAME_VEC_H__


#include <windows.h>
#include <TCHAR.H>
#include <crtdbg.h>

#include <vector>

#include <log.h>

using namespace std ;

#ifdef __cplusplus
extern "C"
{
#endif


#define MAX_LOG_BUF 1024
#define MAX_PRINT_BUF (1024*16)
#define FILE_TYPE_TO_LOOK_FOR	TEXT("\\*.tif")

// CMsgHandlerClientVector
// an STL vector of pointers to CMsgHandlerClients
#ifdef _C_FILENAME_VECTOR_
#error "redefinition of _C_FILENAME_VECTOR_"
#else
#define _C_FILENAME_VECTOR_
typedef vector< LPTSTR > CFilenameVector;
#endif

//
// func creats the CFilenameVector and adds all TIF files in szDir to it
//
BOOL GetTiffFilesOfDir(
	LPCTSTR				/* IN */	szDir,
	CFilenameVector**	/* OUT */	ppMyDirFileVec
	);

//
// creates new vector and adds all files with extension szFileExtension in szDir to it
//
// Note: szDir must be without last '\' char (e.g. "C:\Dir1\Dir2", NOT "C:\Dir1\Dir2\")
//       szFileExtension must be the actual extension (e.g. "tif" or "*", NOT "*.tif" or "*.*")
BOOL GetFilesOfDir(
	LPCTSTR				/* IN */	szDir,
	LPCTSTR				/* IN */	szFileExtension,
	CFilenameVector**	/* OUT */	ppMyDirFileVec
	);

//
// func copies pSrcFileVec vector to (*ppDstFileVec) vector
// copy is 1st level, that is, ptrs to strings are copied but
// strings themselves are not duplicated.
//
BOOL FirstLevelDup(
	CFilenameVector**	/* OUT */	ppDstFileVec,
	CFilenameVector*	/* IN */	pSrcFileVec
	);

// returns TRUE if pFileVec is empty, FALSE otherwise
BOOL IsEmpty(CFilenameVector* /* IN */ pFileVec);

// removes all string pointers from vector (==clears vector)
// does NOT free the pointers.
void ClearVector(CFilenameVector* /* IN OUT */ pFileVec);

// frees all strings in vector and clears vector
void FreeVector(CFilenameVector* /* IN OUT */ pFileVec);

// prints all strings in vector
void PrintVector(CFilenameVector* /* IN */ pFileVec);

// delete all files that vector holds names for
BOOL DeleteVectorFiles(CFilenameVector* /* IN */ pFileVec);

#ifdef __cplusplus
}
#endif


#endif //_FILENAME_VEC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\tiffutils\tiffcomp.c ===
#include "TiffUtilsP.h"


//
// this array will hold in each entry the number of bits that the entry has in its hex notation.
// e.g. s_nNumOfBitsInChar[0xf0] == 4
//
static int s_nNumOfBitsInChar[256];



//
// fills s_nNumOfBitsInChar[]
// algorithm:
// for each byte value, shift left and check if LS bit is 1.
//
static void PrepareBitcountLookup()
{
    static BOOL s_fLookupReady = FALSE;
    int iChar;

    if (s_fLookupReady) return;
    else s_fLookupReady = TRUE;

    for (iChar = 0; iChar < 256 ; iChar++)
    {
        int nChar = iChar;
        int nCount = 0;
        int iBit;

        for (iBit = 0; iBit < 8; iBit++)
        {
            if (0x1 == (nChar & 0x1))
            {
                nCount++;
            }

            nChar = nChar >> 1;
        }

        s_nNumOfBitsInChar[iChar] = nCount;
    }

    return;
}



static void PrintTiffInfo(LPCTSTR lpctstrFileName, TIFF_INFO *pti)
{
    _tprintf( TEXT("%s: TIFF_INFO:\n"), lpctstrFileName);
    _tprintf( TEXT("  ImageWidth:\t%d\n"), pti->ImageWidth);
    _tprintf( TEXT("  ImageHeight:\t%d\n"), pti->ImageHeight);
    _tprintf( TEXT("  PageCount:\t%d\n"), pti->PageCount);
    _tprintf( TEXT("  Photometric:\t%d\n"), pti->PhotometricInterpretation);
    _tprintf( TEXT("  ImageSize:\t%d\n"),pti->ImageSize);
    _tprintf( TEXT("  Compression:\t%d\n"), pti->CompressionType);
    _tprintf( TEXT("  FillOrder:\t%d\n"), pti->FillOrder);
    _tprintf( TEXT("  YResolution:\t%d\n"), pti->YResolution);
}



BOOL
WINAPI
TiffCompare(
    LPTSTR  lpctstrFirstTiffFile,
    LPTSTR  lpctstrSecondTiffFile,
    BOOL    fSkipFirstLineOfSecondFile,
    int     *piDifferentBits
    )

/*++

Routine Description:

    comparees 2 tiff files.

Arguments:

    lpctstrFirstTiffFile        First file to compare.
    lpctstrSecondTiffFile       Second file to compare.
    fSkipFirstLineOfSecondFile  Indicates whether the first line should be skipped.
    piDifferentBits             Pointer to a DWORD variable, that receives the number of diferent bits.
                                If the number is zero - the files are identical.
                                If the number is negative - the files are different in some significant parameter:
                                page count, image width, image height.
                                The variable contents is valid only if the function succeeds.

Return Value:

    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero. To get extended error information, call GetLastError. 


Author:
    Micky Snir (MickyS) August 3, 98

--*/

{
    HANDLE hFirstTiff = NULL;
    HANDLE hSecondTiff = NULL;
    DWORD   dwFirstTiffImageWidth = 0;
    DWORD   dwFirstTiffImageHeight = 0;
    DWORD   dwSecondTiffImageWidth = 0;
    DWORD   dwSecondTiffImageHeight = 0;
    DWORD   dwFirstTiffLines = 0;
    DWORD   dwFirstTiffStripDataSize = 0;
    DWORD   dwSecondTiffLines = 0;
    DWORD   dwSecondTiffStripDataSize = 0;
/*
    HANDLE hFirstBmp = NULL;
    HANDLE hSecondBmp = NULL;
    HANDLE hFirstMap = NULL;
    HANDLE hSecondMap = NULL;
    LPVOID fFirstPtr = NULL;
    LPVOID fSecondPtr = NULL;
    PBMPINFO BmpFirstInfo = NULL;
    PBMPINFO BmpSecondInfo = NULL;
    PWINRGBQUAD Palette = NULL;
    LPBYTE dPtr = NULL;
    LPBYTE sPtr = NULL;
*/
    LPBYTE pbFirstBmpData = NULL;
    LPBYTE pbSecondBmpData = NULL;
    TIFF_INFO tiFirst;
    TIFF_INFO tiSecond;
    DWORD iPage;
    BOOL fHeightCmpFail = FALSE;
    BOOL fHeightCmpWithOffByOneFail = FALSE;

    DWORD dwEC = ERROR_FUNCTION_FAILED;

    if (!lpctstrFirstTiffFile || !lpctstrSecondTiffFile || !piDifferentBits)
    {
        dwEC = ERROR_INVALID_PARAMETER;
        goto out;
    }

    *piDifferentBits = 0;

    //
    // open the 2 tiff files.
    //
    hFirstTiff = TiffOpen( lpctstrFirstTiffFile, &tiFirst, TRUE, FILLORDER_MSB2LSB );
    if (!hFirstTiff) 
    {
        _tprintf( TEXT("could not open tiff file %s\n") ,lpctstrFirstTiffFile);
        dwEC = GetLastError();
        goto out;
    }
    PrintTiffInfo(lpctstrFirstTiffFile, &tiFirst);

    hSecondTiff = TiffOpen( lpctstrSecondTiffFile, &tiSecond, TRUE, FILLORDER_MSB2LSB );
    if (!hSecondTiff) 
    {
        _tprintf( TEXT("could not open tiff file %s\n") ,lpctstrSecondTiffFile);
        dwEC = GetLastError();
        goto out;
    }
    PrintTiffInfo(lpctstrSecondTiffFile, &tiSecond);

    //
    // if PageCount, ImageWidth or ImageHeight are different: fail.
    //
    if (tiFirst.PageCount != tiSecond.PageCount)
    {
        _tprintf( 
            TEXT("tiFirst.PageCount(%d) != tiSecond.PageCount(%d)\n"),
            tiFirst.PageCount,
            tiSecond.PageCount
            );
        *piDifferentBits = -1;
        goto out;
    }

    //
    // compare each page
    //
    _tprintf(
        TEXT("\nComparing pages: 1-%d"),
        tiFirst.PageCount
        );
    
    for (iPage = 1; iPage <= tiFirst.PageCount; iPage++)
    {
        //
        // initialize image height Comparison flags (to indicate comparisons have *not* failed)
        // 
        fHeightCmpFail = FALSE;
        fHeightCmpWithOffByOneFail = FALSE;

        //
        // seek to iPage on both files
        //
        if (!TiffSeekToPage(
                hFirstTiff,
                iPage,
                FILLORDER_MSB2LSB
                )
            )
        {
            dwEC = GetLastError();
            _tprintf( 
                TEXT("TiffSeekToPage(hFirstTiff, %d, FILLORDER_MSB2LSB) failed with %d\n"),
                iPage,
                dwEC
                );
            goto out;
        }

        if (!TiffSeekToPage(
                hSecondTiff,
                iPage,
                FILLORDER_MSB2LSB
                )
            )
        {
            dwEC = GetLastError();
            _tprintf( 
                TEXT("TiffSeekToPage(hSecondTiff, %d, FILLORDER_MSB2LSB) failed with %d\n"),
                iPage,
                dwEC
                );
            goto out;
        }

        //
        // get Width and Height of current page for 2 tiffs
        //
        if (!TiffGetCurrentPageData(
                                hFirstTiff, 
                                &dwFirstTiffLines, 
                                &dwFirstTiffStripDataSize, 
                                &dwFirstTiffImageWidth,
                                &dwFirstTiffImageHeight
                                )
            )
        {
            dwEC = GetLastError();
            _tprintf( TEXT("could not get page data\n") );
            goto out;
        }

        _ASSERTE(dwFirstTiffImageWidth);
        _ASSERTE(dwFirstTiffImageHeight);

        if (!TiffGetCurrentPageData(
                                hSecondTiff, 
                                &dwSecondTiffLines, 
                                &dwSecondTiffStripDataSize, 
                                &dwSecondTiffImageWidth,
                                &dwSecondTiffImageHeight
                                )
            )
        {
            dwEC = GetLastError();
            _tprintf( TEXT("could not get page data\n") );
            goto out;
        }
        
        _ASSERTE(dwSecondTiffImageWidth);
        _ASSERTE(dwSecondTiffImageHeight);
        
        //
        //Dump this new info to the console
        //
        _tprintf(
            TEXT("Comparing page:%d/%d\n"),
            iPage,
            tiFirst.PageCount
            );
        _tprintf(
            TEXT("   Tiff#1 (%s):\n\tLines=%d, StripDataSize=%d, ImageWidth=%d, ImageHeight=%d\n"),
            lpctstrFirstTiffFile,
            dwFirstTiffLines,
            dwFirstTiffStripDataSize,
            dwFirstTiffImageWidth,
            dwFirstTiffImageHeight
            );
        _tprintf(
            TEXT("   Tiff#2 (%s):\n\tLines=%d, StripDataSize=%d, ImageWidth=%d, ImageHeight=%d\n"),
            lpctstrSecondTiffFile,
            dwSecondTiffLines,
            dwSecondTiffStripDataSize,
            dwSecondTiffImageWidth,
            dwSecondTiffImageHeight
            );

        //
        // verify that both pages have same Width and Height
        //
        if (dwFirstTiffImageWidth != dwSecondTiffImageWidth)
        {
            _tprintf( 
                TEXT("dwFirstTiffImageWidth(%d) != dwSecondTiffImageWidth(%d)\n"),
                dwFirstTiffImageWidth,
                dwSecondTiffImageWidth
                );
            *piDifferentBits = -1;
            goto out;
        }

        //
        // Image Height Compare
        // 
        if (dwFirstTiffImageHeight != dwSecondTiffImageHeight)
        {
            fHeightCmpFail = TRUE;
        }
        //
        // Image Height Compare (height is off by 1?) //workaround for bug
        //
        if (dwFirstTiffImageHeight != (dwSecondTiffImageHeight - 1))
        {
            fHeightCmpWithOffByOneFail = TRUE;
        }

        //
        // due to known bug we only fail if both height comparisons fail
        //
        // details on bug: when a cp is rendered the SentItems copy of the cp and the 
        // Inbox copy (the received file) differ in the first line of the data,
        // *but* the image heights are identical.
        // when a document (not a cp) is rendered the SentItems copy of the cp and the 
        // Inbox copy (the received file) differ in the first line of the data,
        // *and* the image heights differ by one.
        //
        // => we don't know if we want to compare height or height-1,
        //    so we only fail if both fail.
        //
        if ((TRUE == fHeightCmpWithOffByOneFail) && (TRUE == fHeightCmpFail))
        {
            _tprintf( 
                TEXT("ERR: both height comparisons have failed.\n")
                );
            *piDifferentBits = -1;
            goto out;
        }


        //
        // de-allocate memory of previous 2 bmp datas
        //
        if (NULL != pbFirstBmpData)
        {
            if (!VirtualFree( pbFirstBmpData, 0, MEM_RELEASE ))
            {
                _ASSERTE(FALSE);
            }
        }
        if (NULL != pbSecondBmpData)
        {
            if (!VirtualFree( pbSecondBmpData, 0, MEM_RELEASE ))
            {
                _ASSERTE(FALSE);
            }
        }

        //
        // allocate memory for 2 bmp datas
        //
        pbFirstBmpData = VirtualAlloc(
            NULL,
            dwFirstTiffImageHeight * (dwFirstTiffImageWidth / 8),
            MEM_COMMIT,
            PAGE_READWRITE
            );
        if (!pbFirstBmpData) 
        {
            _tprintf( TEXT("could not allocate memory for bmp data\n") );
            dwEC = GetLastError();
            goto out;
        }

        pbSecondBmpData = VirtualAlloc(
            NULL,
            dwSecondTiffImageHeight * (dwSecondTiffImageWidth / 8),
            MEM_COMMIT,
            PAGE_READWRITE
            );
        if (!pbSecondBmpData) 
        {
            _tprintf( TEXT("could not allocate memory for bmp data\n") );
            dwEC = GetLastError();
            goto out;
        }
        
        //
        // read the iPage in each file
        //
        if (!TiffRead( hFirstTiff, pbFirstBmpData,0 )) 
        {
            _tprintf( TEXT("could not read tiff data\n") );
            dwEC = GetLastError();
            goto out;
        }

        if (!TiffRead( hSecondTiff, pbSecondBmpData,0 )) 
        {
            _tprintf( TEXT("could not read tiff data\n") );
            dwEC = GetLastError();
            goto out;
        }

        //
        // compare the bitmaps, while counting the non-matching pixels
        //
        PrepareBitcountLookup();

        if (fSkipFirstLineOfSecondFile)
        {
            if (0 != memcmp(
                    pbFirstBmpData, 
                    pbSecondBmpData+(dwFirstTiffImageWidth/8), 
                    (dwFirstTiffImageHeight-1) * (dwFirstTiffImageWidth / 8)
                    )
                )
            {
                PBYTE pNextByteInFirstFile;
                PBYTE pNextByteInSecondFile;
                int cbBitErrors = 0;

                for (   pNextByteInFirstFile = pbFirstBmpData, pNextByteInSecondFile = pbSecondBmpData+(dwFirstTiffImageWidth/8); 
                        pNextByteInFirstFile < pbFirstBmpData+(dwFirstTiffImageHeight-1) * (dwFirstTiffImageWidth / 8); 
                        pNextByteInFirstFile++, pNextByteInSecondFile++
                    )
                {
                    *pNextByteInFirstFile = 
                        ((*pNextByteInFirstFile) ^ (*(pNextByteInSecondFile+1)));

                    cbBitErrors += s_nNumOfBitsInChar[*pNextByteInFirstFile];
                }
                _tprintf(TEXT("Page is NOT identical, %d bits different\n"), cbBitErrors);
                *piDifferentBits += cbBitErrors;
            }
            else
            {
                _tprintf(TEXT("Page is identical in both files\n"));
            }
        }
        else
        {
            if (0 != memcmp(
                    pbFirstBmpData, 
                    pbSecondBmpData, 
                    dwFirstTiffImageHeight * (dwFirstTiffImageWidth / 8)
                    )
                )
            {
                PBYTE pNextByteInFirstFile;
                PBYTE pNextByteInSecondFile;
                int cbBitErrors = 0;

                for (   pNextByteInFirstFile = pbFirstBmpData, pNextByteInSecondFile = pbSecondBmpData; 
                        pNextByteInFirstFile < pbFirstBmpData+(dwFirstTiffImageHeight) * (dwFirstTiffImageWidth / 8); 
                        pNextByteInFirstFile++, pNextByteInSecondFile++
                    )
                {
                    *pNextByteInFirstFile = 
                        ((*pNextByteInFirstFile) ^ (*pNextByteInSecondFile));

                    cbBitErrors += s_nNumOfBitsInChar[*pNextByteInFirstFile];
                }
                _tprintf(TEXT("Page is NOT identical, %d bits different\n"), cbBitErrors);
                *piDifferentBits += cbBitErrors;
            }
            else
            {
                _tprintf(TEXT("Page is identical in both files\n"));
            }
        }
    }

    if (0 == *piDifferentBits)
    {
        _tprintf( TEXT("Tiff files are identical\n") );
    }
    else
    {
        _tprintf(
            TEXT("Tiff files are DIFFERENT in %d bits\n"),
            *piDifferentBits
            );
    }

    dwEC = ERROR_SUCCESS;

out:
    if (NULL != hFirstTiff)
    {
        if (!TiffClose( hFirstTiff ))
        {
            _ASSERTE(FALSE);
        }
    }
    if (NULL != hSecondTiff)
    {
        if (!TiffClose( hSecondTiff ))
        {
            _ASSERTE(FALSE);
        }
    }
    if (NULL != pbFirstBmpData)
    {
        if (!VirtualFree( pbFirstBmpData, 0, MEM_RELEASE ))
        {
            _ASSERTE(FALSE);
        }
    }
    if (NULL != pbSecondBmpData)
    {
        if (!VirtualFree( pbSecondBmpData, 0, MEM_RELEASE ))
        {
            _ASSERTE(FALSE);
        }
    }

    SetLastError(dwEC);

    return ERROR_SUCCESS == dwEC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\verifytifffiles\tiff.h ===
// Copyright (c) 1996-1998 Microsoft Corporation

// Module name:		LogElle.c
// Author:			Micky Snir (mickys)
// Date:			

#ifndef __TIFF_TOOLS_WRAPPER_H__
#define __TIFF_TOOLS_WRAPPER_H__

#ifdef __cplusplus
extern "C"
{
#endif
        
#include "..\tiff\tifftools\TiffTools.h"

#ifdef __cplusplus
}
#endif


#endif //__TIFF_TOOLS_WRAPPER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\tiffutils\tiffutilsp.h ===
#ifndef __TIFF_UTILS_P_H__
#define __TIFF_UTILS_P_H__



#include <TiffUtils.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>



//
// Private Fax includes.
//
#include <tifflib.h>
#include <faxutil.h>



#pragma pack(1)

typedef struct _WINRGBQUAD {
    BYTE   rgbBlue;                 // Blue Intensity Value
    BYTE   rgbGreen;                // Green Intensity Value
    BYTE   rgbRed;                  // Red Intensity Value
    BYTE   rgbReserved;             // Reserved (should be 0)
} WINRGBQUAD, *PWINRGBQUAD;

typedef struct _BMPINFO {
    WORD   Type;                    //  File Type Identifier
    DWORD  FileSize;                //  Size of File
    WORD   Reserved1;               //  Reserved (should be 0)
    WORD   Reserved2;               //  Reserved (should be 0)
    DWORD  Offset;                  //  Offset to bitmap data
    DWORD  Size;                    //  Size of Remianing Header
    DWORD  Width;                   //  Width of Bitmap in Pixels
    DWORD  Height;                  //  Height of Bitmap in Pixels
    WORD   Planes;                  //  Number of Planes
    WORD   BitCount;                //  Bits Per Pixel
    DWORD  Compression;             //  Compression Scheme (0=none)
    DWORD  SizeImage;               //  Size of bitmap in bytes
    DWORD  XPelsPerMeter;           //  Horz. Resolution in Pixels/Meter
    DWORD  YPelsPerMeter;           //  Vert. Resolution in Pixels/Meter
    DWORD  ClrUsed;                 //  Number of Colors in Color Table
    DWORD  ClrImportant;            //  Number of Important Colors
} BMPINFO, *UNALIGNED PBMPINFO;

#pragma pack()



#endif // #ifndef __TIFF_UTILS_P_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\tiffutils\tiff2bmp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tiff2bmp.c

Abstract:

    This file contains support for converting a
    TIFF file to a Windows BMP file.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "TiffUtilsP.h"
#include <tiff.h>
#include <crtdbg.h>
#pragma hdrstop



static void PrintTheTiff(
    LPTSTR TiffFile
    ) 
{
    FAX_PRINT_INFO PrintInfo;
    FAX_CONTEXT_INFOW ContextInfo;
    LPTSTR FullPath = TEXT("c:\\temp\\thetiff.tif");
    DWORD TmpFaxJobId;
    BOOL Rslt;

    ZeroMemory( &PrintInfo, sizeof(FAX_PRINT_INFOW) );

    PrintInfo.SizeOfStruct = sizeof(FAX_PRINT_INFOW);
    PrintInfo.OutputFileName = FullPath;

    ZeroMemory( &ContextInfo, sizeof(FAX_CONTEXT_INFOW) );
    ContextInfo.SizeOfStruct = sizeof(FAX_CONTEXT_INFOW);

    if (!FaxStartPrintJobW( NULL, &PrintInfo, &TmpFaxJobId, &ContextInfo )) {
        DeleteFile( FullPath );
        SetLastError( ERROR_INVALID_FUNCTION );
        return;
    }

    Rslt = PrintTiffFile( ContextInfo.hDC, TiffFile );

    EndDoc( ContextInfo.hDC );
    DeleteDC( ContextInfo.hDC );

}



DWORD
WINAPI
ConvertTiffToBmp(
    LPTSTR TiffFile,
    LPTSTR BmpFile
    )

/*++

Routine Description:

    Converts a TIFF file to a BMP file.

Arguments:

    TiffFile            - TIFF file name
    BmpFile             - BMP file name

Return Value:

    None.

--*/

{
    HANDLE hTiff = NULL;
    HANDLE hBmp = INVALID_HANDLE_VALUE;
    HANDLE hMap = NULL;
    LPVOID fPtr = NULL;
    PBMPINFO BmpInfo = NULL;
    PWINRGBQUAD Palette = NULL;
    LPBYTE dPtr;
    LPBYTE sPtr;
    DWORD i,j;
    LPBYTE BmpData = NULL;
    TIFF_INFO TiffInfo;

	BOOL fSuccess = FALSE;

	DWORD dwRetval = ERROR_SUCCESS;//success

	SetLastError(ERROR_SUCCESS);

    hTiff = TiffOpen( TiffFile, &TiffInfo, TRUE, FILLORDER_MSB2LSB );
    if (!hTiff) {
        _tprintf( TEXT("could not open tiff file\n") );
        goto out;
    }

    _tprintf( TEXT("ImageWidth:\t%d\n"),TiffInfo.ImageWidth);
    _tprintf( TEXT("ImageHeight:\t%d\n"),TiffInfo.ImageHeight);
    _tprintf( TEXT("PageCount:\t%d\n"),TiffInfo.PageCount);
    _tprintf( TEXT("Photometric:\t%d\n"),TiffInfo.PhotometricInterpretation);
    _tprintf( TEXT("ImageSize:\t%d\n"),TiffInfo.ImageSize);
    _tprintf( TEXT("Compression:\t%d\n"),TiffInfo.CompressionType);
    _tprintf( TEXT("FillOrder:\t%d\n"),TiffInfo.FillOrder);
    _tprintf( TEXT("YResolution:\t%d\n"),TiffInfo.YResolution);


    BmpData = VirtualAlloc(
        NULL,
        TiffInfo.ImageHeight * (TiffInfo.ImageWidth / 8),
        MEM_COMMIT,
        PAGE_READWRITE
        );
    if (!BmpData) {
        _tprintf( TEXT("could not allocate memory for bmp data\n") );
        goto out;
    }

    if (!TiffRead( hTiff, BmpData,0 )) {
        _tprintf( TEXT("could not read tiff data\n") );
        TiffClose( hTiff );
        goto out;
    }

    hBmp = CreateFile(
        BmpFile,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        0,
        NULL
        );
    if (hBmp == INVALID_HANDLE_VALUE) {
        _tprintf( TEXT("CreateFile(%s) failed with %d\n"), BmpFile, GetLastError() );
        return 0;
    }


    hMap = CreateFileMapping(
        hBmp,
        NULL,
        PAGE_READWRITE | SEC_COMMIT,
        0,
        1024*1024*10,  // 10 meg
        NULL
        );
    if (!hMap) {
        return GetLastError();
    }

    fPtr = MapViewOfFile(
        hMap,
        FILE_MAP_WRITE,
        0,
        0,
        0
        );
    if (!fPtr) {
        return GetLastError();
    }

    BmpInfo = (PBMPINFO) fPtr;
    Palette = (PWINRGBQUAD) (BmpInfo + 1);

    BmpInfo->Type           =  0x4d42;
    BmpInfo->FileSize       =  sizeof(BMPINFO) + ((TiffInfo.ImageWidth / 8) * TiffInfo.ImageHeight);
    BmpInfo->Reserved1      =  0;
    BmpInfo->Reserved2      =  0;
    BmpInfo->Offset         =  sizeof(BMPINFO) + (sizeof(WINRGBQUAD) * 2);
    BmpInfo->Size           =  sizeof(BMPINFO) - FIELD_OFFSET(BMPINFO,Size);
    BmpInfo->Width          =  TiffInfo.ImageWidth;
    BmpInfo->Height         =  TiffInfo.ImageHeight;
    BmpInfo->Planes         =  1;
    BmpInfo->BitCount       =  1;
    BmpInfo->Compression    =  0;
    BmpInfo->SizeImage      =  (TiffInfo.ImageWidth / 8) * TiffInfo.ImageHeight;
    BmpInfo->XPelsPerMeter  =  0;
    BmpInfo->YPelsPerMeter  =  0;
    BmpInfo->ClrUsed        =  0;
    BmpInfo->ClrImportant   =  0;

	if (TiffInfo.PhotometricInterpretation) {
		//
		// minimum is black.
		//
		Palette[1].rgbBlue      = 0;
		Palette[1].rgbGreen     = 0;
		Palette[1].rgbRed       = 0;
		Palette[1].rgbReserved  = 0;

		Palette[0].rgbBlue      = 0xff;
		Palette[0].rgbGreen     = 0xff;
		Palette[0].rgbRed       = 0xff;
		Palette[0].rgbReserved  = 0;
	} else {
		//
		// minimum is white
		//
		Palette[0].rgbBlue      = 0;
		Palette[0].rgbGreen     = 0;
		Palette[0].rgbRed       = 0;
		Palette[0].rgbReserved  = 0;

		Palette[1].rgbBlue      = 0xff;
		Palette[1].rgbGreen     = 0xff;
		Palette[1].rgbRed       = 0xff;
		Palette[1].rgbReserved  = 0;
	}

    sPtr = (LPBYTE) (BmpData + ((TiffInfo.ImageHeight-1)*(TiffInfo.ImageWidth/8)));
    dPtr = (LPBYTE) ((LPBYTE)(Palette + 2));

    //
    // capture the data
    //
    for (i=0; i<TiffInfo.ImageHeight; i++) {

        CopyMemory( dPtr, sPtr, TiffInfo.ImageWidth/8 );

        for (j=0; j<(TiffInfo.ImageWidth/8); j++) {
            dPtr[j] ^= 0xff;
        }

        sPtr -= (TiffInfo.ImageWidth/8);
        dPtr += (TiffInfo.ImageWidth/8);

    }

	fSuccess = TRUE;

out:
    if (NULL != hTiff) TiffClose( hTiff );

    if (NULL != BmpData) 
	{
		if (!VirtualFree( BmpData, 0, MEM_RELEASE ))
		{
			_tprintf(TEXT("Internal error: ConvertTiffToBmp(): VirtualFree() failed with %d\n"), GetLastError());
			_ASSERTE(FALSE);
			fSuccess = FALSE;
		}
	}
	else _ASSERTE(NULL == hTiff);

    if (INVALID_HANDLE_VALUE != hBmp) CloseHandle( hBmp );
	else _ASSERTE(NULL == BmpData);

    if (NULL != hMap) CloseHandle( hMap );
	else _ASSERTE(INVALID_HANDLE_VALUE == hBmp);

    if (NULL != fPtr) UnmapViewOfFile( fPtr );
	else _ASSERTE(NULL == hMap);

    PrintTheTiff(TiffFile);

	//
	// function starts with SetLastError(ERROR_SUCCESS)
	//
	dwRetval = GetLastError();

	if (fSuccess && (ERROR_SUCCESS != dwRetval))
	{
		_tprintf(TEXT("Internal error: ConvertTiffToBmp(): (fSuccess && (ERROR_SUCCESS != dwRetval))\n"));
		_ASSERTE(FALSE);
		return ERROR_INVALID_PARAMETER;
	}

	//
	// BUGBUG: I return ERROR_INVALID_PARAMETER if I do not know the exact error
	//
	if (ERROR_SUCCESS == dwRetval) ERROR_INVALID_PARAMETER;

	return dwRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\verifytifffiles\vectiffcmp.cpp ===
//
//
// Filename:	VecTiffCmp.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		3-Feb-99
//
//


#include "VecTiffCmp.h"


//
// func compares *.tif files in pFileVec1 to *.tif files in pFileVec2
// returns true iff for every *.tif file in pFileVec1 there exists a *.tif 
// file in pFileVec2 whose image is identical, and vice versa.
//
BOOL VecToVecTiffCompare(
	CFilenameVector*	/* IN */	pFileVec1,
	CFilenameVector*	/* IN */	pFileVec2,
    BOOL                /* IN */    fSkipFirstLine
	)
{
	BOOL fRetVal = FALSE;
	UINT uVec1Size = 0;
	UINT uVec2Size = 0;
	int i = 0;
	LPTSTR szCurFile = NULL;
	DWORD dwIndex = -1;
	CFilenameVector* pTmpFileVec = NULL;

	//
	// check in params
	//
	_ASSERTE(NULL != pFileVec1);
	_ASSERTE(NULL != pFileVec2);

	// check sizes
	uVec1Size = pFileVec1->size();
	uVec2Size = pFileVec2->size();
	::lgLogDetail(
		LOG_X,
		9,
		TEXT("FILE(%s) LINE(%d):\n FileToVecTiffCompare: uVec1Size=%d uVec2Size=%d\n"),
		TEXT(__FILE__),
		__LINE__,
		uVec1Size,
		uVec2Size
		);

	if ((0 == uVec1Size)&&(0 == uVec2Size))
	{
		// 2 empty vecs do not qualify as having identical images
        ::lgLogDetail(
            LOG_X,
            1,
		    TEXT("FILE(%s) LINE(%d):\n FileToVecTiffCompare: uVec1Size==uVec2Size==0\n"),
		    TEXT(__FILE__),
		    __LINE__
		    );
		goto ExitFunc;
	}

	if (uVec1Size != uVec2Size)
	{
		// if sizes are different than return false.
        ::lgLogDetail(
            LOG_X,
            1,
		    TEXT("FILE(%s) LINE(%d):\n FileToVecTiffCompare: uVec1Size(%d)!=uVec2Size(%d)\n"),
		    TEXT(__FILE__),
		    __LINE__,
		    uVec1Size,
		    uVec2Size
		    );
		fRetVal = FALSE;
		goto ExitFunc;
	}

	//
	// make a copy of pFileVec2
	//
	// one level copy => create a vector (pTmpFileVec) with ptrs pointing at
	// pFileVec2 strings.
	//
	if (FALSE == FirstLevelDup(&pTmpFileVec,pFileVec2))
	{
        ::lgLogError(
            LOG_SEV_1,
		    TEXT("FILE(%s) LINE(%d):\n FileToVecTiffCompare: FirstLevelDup failed\n"),
		    TEXT(__FILE__),
		    __LINE__
            );
		goto ExitFunc;
	}

	//
	// compare every file in pFileVec1 to any file in pTmpFileVec (==pFileVec2)
	//
	for (i = 0; i < uVec1Size; i++)
	{
		szCurFile = (LPTSTR)(*pFileVec1)[i];
		_ASSERTE(NULL != szCurFile);
		// compare a specific file from pFileVec1 (szCurFile) to any file
		// in pTmpFileVec (==pFileVec2)
		if (FALSE == FileToVecTiffCompare(szCurFile, pTmpFileVec, fSkipFirstLine, &dwIndex))
		{
			// we could not find a file with the same image as szCurFile
			// in pTmpFileVec, so return FALSE
            ::lgLogDetail(
                LOG_X,
                4,
		        TEXT("FILE(%s) LINE(%d):\n FileToVecTiffCompare: no match for file %s (fSkipFirstLine=%d)\n"),
		        TEXT(__FILE__),
		        __LINE__,
                szCurFile,
                fSkipFirstLine
                );
			goto ExitFunc;
		}
		//
		// file with index dwIndex in pTmpFileVec has same image as szCurFile
		// => "remove" (actually NULL) pTmpFileVec->at(dwIndex)
		// this way, next time compare to (*pTmpFileVec)[dwIndex] will return FALSE
		//
		(*pTmpFileVec)[dwIndex] = NULL;
	}

	//
	//If we reach here then we finished the for loop and all went well
	//we should return TRUE
	//
	fRetVal = TRUE;

ExitFunc:
	return(fRetVal);
}

//
// func compares *.tif file szFile to *.tif files in pFileVec
// returns true iff there exists a *.tif file in pFileVec whose image is 
// identical to szFile image.
// sets pdwIndex to the index of the identical file in pFileVec.
//
BOOL FileToVecTiffCompare(
	LPTSTR				/* IN */	szFile,
	CFilenameVector*	/* IN */	pFileVec,
    BOOL                /* IN */    fSkipFirstLine,
	LPDWORD				/* OUT */	pdwIndex
	)
{
	BOOL fRetVal = FALSE;
	UINT uVecSize = 0;
	int i = 0;
	BOOL fFoundIdenticalImage = FALSE;

	//
	// check in params
	//
	_ASSERTE(NULL != pFileVec);
	_ASSERTE(NULL != szFile);
	_ASSERTE(NULL != pdwIndex);


	//
	uVecSize = pFileVec->size();
	if (0 == uVecSize)
	{
        ::lgLogDetail(
            LOG_X,
            4,
		    TEXT("FILE(%s) LINE(%d):\n FileToVecTiffCompare: pFileVec->size==0\n"),
		    TEXT(__FILE__),
		    __LINE__
            );
		goto ExitFunc;
	}

	for (i = 0; i < uVecSize; i++)
	{
		if (TRUE == FileToFileTiffCompare(szFile, (*pFileVec)[i], fSkipFirstLine))
		{
			(*pdwIndex) = i;
			fRetVal = TRUE;
			goto ExitFunc;
		}
	}

ExitFunc:
	return(fRetVal);
}

//
// func compares *.tif file szFile to *.tif file szFile2
// returns true iff szFile1 and szFile2 images are identical.
// NOTE: we do not consider 2 NULL filenames as 2 files with same NULL image
//       => if szFile1==szFile2==NULL we return FALSE.
//
BOOL FileToFileTiffCompare(
	LPTSTR				/* IN */	szFile1,
	LPTSTR				/* IN */	szFile2,
    BOOL                /* IN */    fSkipFirstLine
	)
{
	BOOL fRetVal = FALSE;
	LPTSTR szRetVal = TEXT("NOT identical");
    DWORD dwLogLevel = 9;

	if (NULL == szFile1)
	{
		goto ExitFunc;
	}

	if (NULL == szFile2)
	{
		goto ExitFunc;
	}

	if (0 == TiffCompare(szFile1, szFile2, fSkipFirstLine))
	{
		fRetVal = TRUE;
		szRetVal = TEXT("identical");
        dwLogLevel = 1;
	}

ExitFunc:
	::lgLogDetail(
		LOG_X,
		dwLogLevel,
		TEXT("FileToFileTiffCompare:\n File#1:%s\n File#1:%s\n With (fSkipFirstLine=%d)\n Are %s.\n"),
		szFile1, 
		szFile2, 
        fSkipFirstLine,
		szRetVal
		);
	return(fRetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\verifytifffiles\vectiffcmp.h ===
//
//
// Filename:	VecTiffCmp.h
// Author:		Sigalit Bar (sigalitb)
// Date:		3-Feb-99
//
//


#ifndef _VECTOR_TIFF_COMPARE_H__
#define _VECTOR_TIFF_COMPARE_H__


#include <windows.h>
#include <TCHAR.H>
#include <crtdbg.h>

#include <log.h>
//NOTE: order of includes matters!!
#include "FilenameVec.h"
#include "Tiff.h"


#ifdef __cplusplus
extern "C"
{
#endif

//
// func compares *.tif files in pFileVec1 to *.tif files in pFileVec2
// returns true iff for every *.tif file in pFileVec1 there exists a *.tif 
// file in pFileVec2 whose image is identical, and vice versa.
//
BOOL VecToVecTiffCompare(
	CFilenameVector*	/* IN */	pFileVec1,
	CFilenameVector*	/* IN */	pFileVec2,
    BOOL                /* IN */    fSkipFirstLine
	);

//
// func compares *.tif file szFile to *.tif files in pFileVec
// returns true iff there exists a *.tif file in pFileVec whose image is 
// identical to szFile image.
// sets pdwIndex to the index of the identical file in pFileVec.
//
BOOL FileToVecTiffCompare(
	LPTSTR				/* IN */	szFile,
	CFilenameVector*	/* IN */	pFileVec,
    BOOL                /* IN */    fSkipFirstLine,
	LPDWORD				/* OUT */	pdwIndex
	);

//
// func compares *.tif file szFile to *.tif file szFile2
// returns true iff szFile1 and szFile2 images are identical.
//
BOOL FileToFileTiffCompare(
	LPTSTR				/* IN */	szFile1,
	LPTSTR				/* IN */	szFile2,
    BOOL                /* IN */    fSkipFirstLine
	);


#ifdef __cplusplus
}
#endif


#endif //_VECTOR_TIFF_COMPARE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\tiffutils\vectiffcmp.h ===
#ifndef _VECTOR_TIFF_COMPARE_H__
#define _VECTOR_TIFF_COMPARE_H__



//
//
// Filename:	VecTiffCmp.h
// Author:		Sigalit Bar (sigalitb)
// Date:		3-Feb-99
//
//



#include <windows.h>
#include <TCHAR.H>
#include "FilenameVec.h"



#ifdef __cplusplus
extern "C"
{
#endif

//
// func compares *.tif files in pFileVec1 to *.tif files in pFileVec2
// returns true iff for every *.tif file in pFileVec1 there exists a *.tif 
// file in pFileVec2 whose image is identical, and vice versa.
//
BOOL VecToVecTiffCompare(
	CFilenameVector*	/* IN */	pFileVec1,
	CFilenameVector*	/* IN */	pFileVec2,
    BOOL                /* IN */    fSkipFirstLine
	);

//
// func compares *.tif file szFile to *.tif files in pFileVec
// returns true iff there exists a *.tif file in pFileVec whose image is 
// identical to szFile image.
// sets pdwIndex to the index of the identical file in pFileVec.
//
BOOL FileToVecTiffCompare(
	LPTSTR				/* IN */	szFile,
	CFilenameVector*	/* IN */	pFileVec,
    BOOL                /* IN */    fSkipFirstLine,
	LPDWORD				/* OUT */	pdwIndex
	);

//
// func compares *.tif file szFile to *.tif file szFile2
// returns true iff szFile1 and szFile2 images are identical.
//
BOOL FileToFileTiffCompare(
	LPTSTR				/* IN */	szFile1,
	LPTSTR				/* IN */	szFile2,
    BOOL                /* IN */    fSkipFirstLine
	);


#ifdef __cplusplus
}
#endif


#endif //_VECTOR_TIFF_COMPARE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\verifytifffiles\main.cpp ===
//
//
// Filename:	main.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		3-Feb-99
//
//


#include "DirTiffCmp.h"
#include <log.h>


#define PARAM_NUM 5
#define FALSE_TSTR TEXT("false")
#define TRUE_TSTR TEXT("true")


static BOOL GetBoolFromStr(LPCTSTR /* IN */ szVal, BOOL* /* OUT */ pfVal);
static void PrintUsageInfo(void);


int __cdecl main(int argc, char* argvA[])
{
    LPTSTR *argv;

#ifdef UNICODE
    argv = CommandLineToArgvW( GetCommandLine(), &argc );
#else
    argv = argvA;
#endif

	// arguments are dir names
	// we check that every file in dir1 has an identical file in dir2
	// and that both dirs have same number of files.

	int nRetVal = -1; //to indicate failure

	LPTSTR szDir1 = NULL;
	LPTSTR szDir2 = NULL;
	LPTSTR szExpectedResult = NULL;
    BOOL fExpectedResult = TRUE;
	LPTSTR szSkipFirstLine = NULL;
    BOOL fSkipFirstLine = FALSE;
    BOOL fCmpRetVal = FALSE;

	//
	// Init logger
	//
	if (!::lgInitializeLogger())
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgInitializeLogger failed with GetLastError()=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto Exit;
	}

	//
	// Begin test suite (logger)
	//
	if(!::lgBeginSuite(TEXT("Verify Tiff Files Suite")))
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgBeginSuite failed with GetLastError()=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto Exit;
	}

	::lgBeginCase(
		1,
		TEXT("Tiff Compare the Files in two directories\n")
		);

	//
	// check num of command line args
	//
	if (PARAM_NUM != argc)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n got argc=%d (should be %d)\n"),
			TEXT(__FILE__),
			__LINE__,
			argc,
			PARAM_NUM
			);
        PrintUsageInfo();
		goto Exit;
	}
	

	//
	// duplicate args
	//
	szDir1 = _tcsdup(argv[1]);
	if (NULL == szDir1)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n _tcsdup failed\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto Exit;
	}
	szDir2 = _tcsdup(argv[2]);
	if (NULL == szDir2)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n _tcsdup failed\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto Exit;
	}
    szSkipFirstLine = _tcsdup(argv[3]);
	if (NULL == szSkipFirstLine)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n _tcsdup failed\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto Exit;
	}
    szExpectedResult = _tcsdup(argv[4]);
	if (NULL == szExpectedResult)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n _tcsdup failed\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto Exit;
	}

	// log command line params using elle logger
	::lgLogDetail(
		LOG_X,
		1,
		TEXT("FILE(%s) LINE(%d):\n Command line params:\n\tszDir1=%s\n\tszDir2=%s\n\tszSkipFirstLine=%s\n\tszExpectedResult=%s\n"),
		TEXT(__FILE__),
		__LINE__,
		szDir1,
		szDir2,
        szSkipFirstLine,
        szExpectedResult
		);

    if (FALSE == GetBoolFromStr(szExpectedResult, &fExpectedResult))
    {
        goto Exit;
    }

    if (FALSE == GetBoolFromStr(szSkipFirstLine, &fSkipFirstLine))
    {
        goto Exit;
    }


    fCmpRetVal = DirToDirTiffCompare(szDir1, szDir2, fSkipFirstLine);
	if (fExpectedResult == fCmpRetVal)
	{
		::lgLogDetail(
            LOG_X,
            1,
            TEXT("*** DirToDirTiffCompare returned as expected (%d) ***\n"),
            fExpectedResult
            );
	}
	else
	{
		::lgLogError(
            LOG_SEV_1,
            TEXT("*** DirToDirTiffCompare returned %d NOT as expected (%d) ***\n"),
            fCmpRetVal,
            fExpectedResult
            );
	}

    nRetVal = 0;

Exit:

	::lgEndCase();

    //
	// End test suite (logger)
	//
	if (!::lgEndSuite())
	{
		//
		//this is not possible since API always returns TRUE
		//but to be on the safe side
		//
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgEndSuite returned FALSE\n"),
			TEXT(__FILE__),
			__LINE__
			);
		//fRetVal = FALSE;
	}

	//
	// Close the Logger
	//
	if (!::lgCloseLogger())
	{
		//this is not possible since API always returns TRUE
		//but to be on the safe side
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgCloseLogger returned FALSE\n"),
			TEXT(__FILE__),
			__LINE__
			);
		//fRetVal = FALSE;
	}

	return(nRetVal);
}

static BOOL GetBoolFromStr(LPCTSTR /* IN */ szVal, BOOL* /* OUT */ pfVal)
{
    BOOL fRetVal = FALSE;
    BOOL fTmpVal = FALSE;

    _ASSERTE(NULL != szVal);
    _ASSERTE(NULL != pfVal);

    if ( 0 == _tcscmp(szVal, FALSE_TSTR) )
    {
        fTmpVal = FALSE;
    }
    else
    {
        if ( 0 == _tcscmp(szVal, TRUE_TSTR) )
        {
            fTmpVal = TRUE;
        }
        else
        {
		    ::lgLogError(
                LOG_SEV_1,
                TEXT("\n3rd param is invalid (%s)\nShould be '%s' or '%s'\n"),
                szVal,
                TRUE_TSTR,
                FALSE_TSTR
                );
            goto ExitFunc;
        }
    }

    (*pfVal) = fTmpVal;
    fRetVal = TRUE;

ExitFunc:
    return(fRetVal);
}


static void PrintUsageInfo(void)
{
    lgLogError(
        LOG_SEV_1,
        TEXT("VerifyTiffFiles Usage:\n\tVerifyTiffFiles.exe dir1 dir2 skip_first_line expected_result\n\tdir1 & dir2 are dirs to compare\n\tskip_first_line is true | false\n\texpected result is true | false\n")
        );
    _tprintf(TEXT("VerifyTiffFiles - compares tiff files of 2 directories\n"));
    _tprintf(TEXT("Usage:\n"));
    _tprintf(TEXT("\tVerifyTiffFiles.exe dir1 dir2 skip_first_line expected_result\n"));
    _tprintf(TEXT("\tdir1 & dir2      - directories to compare\n"));
    _tprintf(TEXT("\tskip_first_line  - 'true' | 'false'\n"));
    _tprintf(TEXT("\t                   whether or not to skip the 1st line of files in dir1\n"));
    _tprintf(TEXT("\texpected_result  - 'true' | 'false'\n"));
    _tprintf(TEXT("\t                   are we expecting the files to be identical ('true') or not ('false')\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\tiffutils\vectiffcmp.cpp ===
//
//
// Filename:    VecTiffCmp.cpp
// Author:      Sigalit Bar (sigalitb)
// Date:        3-Feb-99
//
//


#include "TiffUtilsP.h"
#include <crtdbg.h>
#include <log.h>
#include "VecTiffCmp.h"



//
// func compares *.tif files in pFileVec1 to *.tif files in pFileVec2
// returns true iff for every *.tif file in pFileVec1 there exists a *.tif 
// file in pFileVec2 whose image is identical, and vice versa.
//
BOOL VecToVecTiffCompare(
    CFilenameVector*    /* IN */    pFileVec1,
    CFilenameVector*    /* IN */    pFileVec2,
    BOOL                /* IN */    fSkipFirstLine
    )
{
    BOOL fRetVal = FALSE;
    UINT uVec1Size = 0;
    UINT uVec2Size = 0;
    int i = 0;
    LPTSTR szCurFile = NULL;
    DWORD dwIndex = -1;
    CFilenameVector* pTmpFileVec = NULL;

    //
    // check in params
    //
    _ASSERTE(NULL != pFileVec1);
    _ASSERTE(NULL != pFileVec2);

    // check sizes
    uVec1Size = pFileVec1->size();
    uVec2Size = pFileVec2->size();
    ::lgLogDetail(
        LOG_X,
        9,
        TEXT("FILE(%s) LINE(%d):\n FileToVecTiffCompare: uVec1Size=%d uVec2Size=%d\n"),
        TEXT(__FILE__),
        __LINE__,
        uVec1Size,
        uVec2Size
        );

    if ((0 == uVec1Size)&&(0 == uVec2Size))
    {
        // 2 empty vecs do not qualify as having identical images
        ::lgLogDetail(
            LOG_X,
            1,
            TEXT("FILE(%s) LINE(%d):\n FileToVecTiffCompare: uVec1Size==uVec2Size==0\n"),
            TEXT(__FILE__),
            __LINE__
            );
        goto ExitFunc;
    }

    if (uVec1Size != uVec2Size)
    {
        // if sizes are different than return false.
        ::lgLogDetail(
            LOG_X,
            1,
            TEXT("FILE(%s) LINE(%d):\n FileToVecTiffCompare: uVec1Size(%d)!=uVec2Size(%d)\n"),
            TEXT(__FILE__),
            __LINE__,
            uVec1Size,
            uVec2Size
            );
        fRetVal = FALSE;
        goto ExitFunc;
    }

    //
    // make a copy of pFileVec2
    //
    // one level copy => create a vector (pTmpFileVec) with ptrs pointing at
    // pFileVec2 strings.
    //
    if (FALSE == FirstLevelDup(&pTmpFileVec,pFileVec2))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE(%s) LINE(%d):\n FileToVecTiffCompare: FirstLevelDup failed\n"),
            TEXT(__FILE__),
            __LINE__
            );
        goto ExitFunc;
    }

    //
    // compare every file in pFileVec1 to any file in pTmpFileVec (==pFileVec2)
    //
    for (i = 0; i < uVec1Size; i++)
    {
        szCurFile = (LPTSTR)(*pFileVec1)[i];
        _ASSERTE(NULL != szCurFile);
        // compare a specific file from pFileVec1 (szCurFile) to any file
        // in pTmpFileVec (==pFileVec2)
        if (FALSE == FileToVecTiffCompare(szCurFile, pTmpFileVec, fSkipFirstLine, &dwIndex))
        {
            // we could not find a file with the same image as szCurFile
            // in pTmpFileVec, so return FALSE
            ::lgLogDetail(
                LOG_X,
                4,
                TEXT("FILE(%s) LINE(%d):\n FileToVecTiffCompare: no match for file %s (fSkipFirstLine=%d)\n"),
                TEXT(__FILE__),
                __LINE__,
                szCurFile,
                fSkipFirstLine
                );
            goto ExitFunc;
        }
        //
        // file with index dwIndex in pTmpFileVec has same image as szCurFile
        // => "remove" (actually NULL) pTmpFileVec->at(dwIndex)
        // this way, next time compare to (*pTmpFileVec)[dwIndex] will return FALSE
        //
        (*pTmpFileVec)[dwIndex] = NULL;
    }

    //
    //If we reach here then we finished the for loop and all went well
    //we should return TRUE
    //
    fRetVal = TRUE;

ExitFunc:
    return(fRetVal);
}

//
// func compares *.tif file szFile to *.tif files in pFileVec
// returns true iff there exists a *.tif file in pFileVec whose image is 
// identical to szFile image.
// sets pdwIndex to the index of the identical file in pFileVec.
//
BOOL FileToVecTiffCompare(
    LPTSTR              /* IN */    szFile,
    CFilenameVector*    /* IN */    pFileVec,
    BOOL                /* IN */    fSkipFirstLine,
    LPDWORD             /* OUT */   pdwIndex
    )
{
    BOOL fRetVal = FALSE;
    UINT uVecSize = 0;
    int i = 0;
    BOOL fFoundIdenticalImage = FALSE;

    //
    // check in params
    //
    _ASSERTE(NULL != pFileVec);
    _ASSERTE(NULL != szFile);
    _ASSERTE(NULL != pdwIndex);


    //
    uVecSize = pFileVec->size();
    if (0 == uVecSize)
    {
        ::lgLogDetail(
            LOG_X,
            4,
            TEXT("FILE(%s) LINE(%d):\n FileToVecTiffCompare: pFileVec->size==0\n"),
            TEXT(__FILE__),
            __LINE__
            );
        goto ExitFunc;
    }

    for (i = 0; i < uVecSize; i++)
    {
        if (TRUE == FileToFileTiffCompare(szFile, (*pFileVec)[i], fSkipFirstLine))
        {
            (*pdwIndex) = i;
            fRetVal = TRUE;
            goto ExitFunc;
        }
    }

ExitFunc:
    return(fRetVal);
}

//
// func compares *.tif file szFile to *.tif file szFile2
// returns true iff szFile1 and szFile2 images are identical.
// NOTE: we do not consider 2 NULL filenames as 2 files with same NULL image
//       => if szFile1==szFile2==NULL we return FALSE.
//
BOOL FileToFileTiffCompare(
    LPTSTR              /* IN */    szFile1,
    LPTSTR              /* IN */    szFile2,
    BOOL                /* IN */    fSkipFirstLine
    )
{
    BOOL fRetVal = FALSE;
    LPTSTR szRetVal = TEXT("NOT identical");
    DWORD dwLogLevel = 9;
    int iDifferentBits = 0;

    if (NULL == szFile1)
    {
        goto ExitFunc;
    }

    if (NULL == szFile2)
    {
        goto ExitFunc;
    }

    if (TiffCompare(szFile1, szFile2, fSkipFirstLine, &iDifferentBits) && 0 == iDifferentBits)
    {
        fRetVal = TRUE;
        szRetVal = TEXT("identical");
        dwLogLevel = 1;
    }

ExitFunc:
    ::lgLogDetail(
        LOG_X,
        dwLogLevel,
        TEXT("FileToFileTiffCompare:\n File#1:%s\n File#1:%s\n With (fSkipFirstLine=%d)\n Are %s.\n"),
        szFile1, 
        szFile2, 
        fSkipFirstLine,
        szRetVal
        );
    return(fRetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\fax\verifytifffiles\filenamevec.cpp ===
//
//
// Filename:	FilenameVec.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		3-Feb-99
//
//



#include "FilenameVec.h"

//
// func creats the CFilenameVector and adds all TIF files in szDir to it
//
BOOL GetTiffFilesOfDir(
	LPCTSTR				/* IN */	szDir,
	CFilenameVector**	/* OUT */	ppMyDirFileVec
	)
{
	BOOL fRetVal = FALSE;

    fRetVal = GetFilesOfDir(szDir, TEXT("TIF"), ppMyDirFileVec);

	return(fRetVal);
}

//
// creates new vector and adds all files with extension szFileExtension in szDir to it
//
// Note: szDir must be without last '\' char (e.g. "C:\Dir1\Dir2", NOT "C:\Dir1\Dir2\")
//       szFileExtension must be the actual extension (e.g. "tif" or "*", NOT "*.tif" or "*.*")
BOOL GetFilesOfDir(
	LPCTSTR				/* IN */	szDir,
	LPCTSTR				/* IN */	szFileExtension,
	CFilenameVector**	/* OUT */	ppMyDirFileVec
	)
{
	BOOL fRetVal = FALSE;
	DWORD dwErr = 0;
	HANDLE hFindFile = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA FindFileData;
	LPTSTR szCurrentFullFilename = NULL;
	CFilenameVector* pTmpDirFileVec = NULL;
	DWORD dwLen = 0;

	_ASSERTE(NULL != ppMyDirFileVec);
	_ASSERTE(NULL != szFileExtension);
	_ASSERTE(NULL != szDir);


	//
	// compose string of filenames to look for
	//
	TCHAR szLookFor[MAX_PATH];

    if (0 >= ::_sntprintf(szLookFor, MAX_PATH, TEXT("%s\\*.%s"), szDir, szFileExtension))
    {
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n _sntprintf failed\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
    }

	::lgLogDetail(
		LOG_X,
		9,
		TEXT("\n szLookFor=%s\n"),
		szLookFor
		);

	//
	// create an empty vector
	//
	pTmpDirFileVec = new(CFilenameVector);
	if (NULL == pTmpDirFileVec)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n new(CFilenameVector) failed\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	//
	// find first file
	//
	hFindFile =  ::FindFirstFile(szLookFor, &FindFileData);
	dwErr = ::GetLastError();

	if ((INVALID_HANDLE_VALUE == hFindFile) && (ERROR_FILE_NOT_FOUND == dwErr))
	{
		//this is ok, we will return an empty vector
		::lgLogDetail(
			LOG_X,
			9,
			TEXT("no files found, returning empty vector\n")
			);
		(*ppMyDirFileVec) = pTmpDirFileVec;
		fRetVal = TRUE;
		goto ExitFunc;
	}

	if (INVALID_HANDLE_VALUE == hFindFile)
	{
		// INVALID_HANDLE_VALUE and last err != ERROR_FILE_NOT_FOUND
		// => error
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n FindFirstFile returned INVALID_HANDLE_VALUE with err=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			dwErr
			);
		goto ExitFunc;
	}


	//
	// add found file name to vector
	//
	if(NULL == FindFileData.cFileName)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n NULL==FindFileData.cFileName\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	dwLen = ::_tcslen(szDir) + ::_tcslen(FindFileData.cFileName) + 2;// backslash+null
	szCurrentFullFilename = new TCHAR[dwLen];
	if (NULL == szCurrentFullFilename)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n new failed with err=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}
	szCurrentFullFilename[dwLen-1] = TEXT('\0');

    if (0 >= ::_sntprintf(szCurrentFullFilename, MAX_PATH, TEXT("%s\\%s"), szDir, FindFileData.cFileName))
    {
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n _sntprintf failed\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
    }

	pTmpDirFileVec->push_back(szCurrentFullFilename);
	szCurrentFullFilename = NULL;


	//
	// look for any other such files in dir
	//
	while (TRUE == FindNextFile(hFindFile, &FindFileData))
	{
		// found another file with extension szFileExtension in dir
		// so add it to vector
		if(NULL == FindFileData.cFileName)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("FILE(%s) LINE(%d):\n NULL==FindFileData.cFileName\n"),
				TEXT(__FILE__),
				__LINE__
				);
			goto ExitFunc;
		}
		dwLen = ::_tcslen(szDir) + ::_tcslen(FindFileData.cFileName) + 2;//backslash+null
		szCurrentFullFilename = new TCHAR[dwLen];
		if (NULL == szCurrentFullFilename)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("FILE(%s) LINE(%d):\n new failed with err=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError()
				);
			goto ExitFunc;
		}
		szCurrentFullFilename[dwLen-1] = TEXT('\0');
        if (0 >= ::_sntprintf(szCurrentFullFilename, MAX_PATH, TEXT("%s\\%s"), szDir, FindFileData.cFileName))
        {
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE(%s) LINE(%d):\n _sntprintf failed\n"),
			    TEXT(__FILE__),
			    __LINE__
			    );
		    goto ExitFunc;
        }
		pTmpDirFileVec->push_back(szCurrentFullFilename);
		szCurrentFullFilename = NULL;
	} // 	while (TRUE == FindNextFile(hFindFile, &FindFileData))


	//no more files with extension szFileExtension in dir

	//
	// set out param
	//
	(*ppMyDirFileVec) = pTmpDirFileVec;
	fRetVal = TRUE;

ExitFunc:
	if (FALSE == fRetVal)
	{
		// free vec
		FreeVector(pTmpDirFileVec);
        delete(pTmpDirFileVec); 
	}
    if (INVALID_HANDLE_VALUE != hFindFile) 
    {
        if(!FindClose(hFindFile))
        {
			::lgLogError(
				LOG_SEV_1,
				TEXT("FILE(%s) LINE(%d):\n FindClose(hFindFile) failed with err=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError()
				);
        }
    }
 

	return(fRetVal);
}


//
// func copies pSrcFileVec vector to (*ppDstFileVec) vector
// copy is 1st level, that is, ptrs to strings are copied but
// strings themselves are not duplicated.
//
BOOL FirstLevelDup(
	CFilenameVector**	/* OUT */	ppDstFileVec,
	CFilenameVector*	/* IN */	pSrcFileVec
	)
{
	BOOL fRetVal = FALSE;
	UINT uSrcVecSize = 0;
	CFilenameVector* pTmpFileVec = NULL;
	UINT i = 0;
	LPTSTR szCurrentFullFilename = NULL;

	_ASSERTE(NULL != ppDstFileVec);
	_ASSERTE(NULL != pSrcFileVec);

	// create empty Dst vec
	pTmpFileVec = new(CFilenameVector);
	if (NULL == pTmpFileVec)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n new failed with err=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
	}

	uSrcVecSize = pSrcFileVec->size();
	if (0 == uSrcVecSize)
	{
		(*ppDstFileVec) = pTmpFileVec;
		fRetVal = TRUE;
		goto ExitFunc;
	}

	for (i = 0; i < uSrcVecSize; i++)
	{
		szCurrentFullFilename = (LPTSTR)pSrcFileVec->at(i);
		pTmpFileVec->push_back(szCurrentFullFilename);
		szCurrentFullFilename = NULL;
	}

	(*ppDstFileVec) = pTmpFileVec;
	fRetVal = TRUE;

ExitFunc:
	return(fRetVal);
}

// returns TRUE if pFileVec is empty (size=0), FALSE otherwise
BOOL IsEmpty(CFilenameVector* /* IN */ pFileVec)
{
	if (NULL == pFileVec)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n IsEmpty called with pFileVec==NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

	if (0 == pFileVec->size())
	{
		return(TRUE);
	}

    return(FALSE);
}

// removes all string pointers from vector (==clears vector)
// does NOT free the pointers.
void ClearVector(CFilenameVector* /* IN OUT */ pFileVec)
{
	if (NULL == pFileVec)
	{
		return;
	}
	pFileVec->clear();
}

// frees all strings in vector and clears vector
void FreeVector(CFilenameVector* /* IN OUT */ pFileVec)
{
	if (NULL == pFileVec)
	{
		return;
	}

	UINT uSize = pFileVec->size();
	UINT i = 0;
	for (i = 0; i < uSize; i++)
	{
		delete[](LPTSTR)pFileVec->at(i);
        (LPTSTR)pFileVec->at(i) = NULL;
	}
}

void PrintVector(CFilenameVector* /* IN */ pFileVec)
{
	if (NULL == pFileVec)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n pFileVec==NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return;
	}

	UINT uSize = pFileVec->size();
	if (0 == uSize)
	{
		::lgLogDetail(
			LOG_X,
			1,
			TEXT("\n Vector is Empty\n")
			);
		return;
	}

	TCHAR szBuf[MAX_PRINT_BUF];
	szBuf[0] = NULL;
	szBuf[MAX_PRINT_BUF-1] = NULL;

	::_stprintf(szBuf,TEXT("\n Vector size = %d\n"),uSize);
	_ASSERTE(MAX_PRINT_BUF > ::_tcslen(szBuf));

	UINT i = 0;
	for (i = 0; i < uSize; i++)
	{
		::_stprintf(szBuf,TEXT("%s\t filename(%d)=%s\n"),szBuf,i,pFileVec->at(i));
		_ASSERTE(MAX_PRINT_BUF > ::_tcslen(szBuf));
	}
    if (MAX_LOG_BUF > ::_tcslen(szBuf))
    {
	    ::lgLogDetail(
		    LOG_X,
		    1,
		    TEXT("%s"),
		    szBuf
		    );
    }
    else
    {
        ::_tprintf(TEXT("%s"),szBuf);
	    ::lgLogDetail(
		    LOG_X,
		    1,
		    TEXT("Vector too long, logged to console\n"),
		    szBuf
		    );
    }
}


BOOL DeleteVectorFiles(CFilenameVector* /* IN */ pFileVec)
{
    BOOL fRetVal = TRUE;
	UINT uSize = pFileVec->size();
	UINT i = 0;

    if (NULL == pFileVec)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n pFileVec==NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
        fRetVal = FALSE;
		goto ExitFunc;
	}

	if (0 == uSize)
	{
		::lgLogDetail(
			LOG_X,
			1,
			TEXT("FILE(%s) LINE(%d):\nVector is Empty - no files to delete\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	for (i = 0; i < uSize; i++)
	{
        if (FALSE == ::DeleteFile(pFileVec->at(i)))
        {
            //TO DO: what about when the delete fails because the file does not exist
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE(%s) LINE(%d):\nDeleteFile(%s) failed with err=0x%8X\n"),
			    TEXT(__FILE__),
			    __LINE__,
                pFileVec->at(i),
                ::GetLastError()
			    );
            fRetVal = FALSE;
        }
        else
        {
		    ::lgLogDetail(
			    LOG_X,
			    4,
			    TEXT("FILE(%s) LINE(%d):\ndeleted file %s\n"),
			    TEXT(__FILE__),
			    __LINE__,
                pFileVec->at(i)
			    );
        }
	}

ExitFunc:
    return(fRetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\general\log\lgelle\logelle.c ===
//
// this is an implementation of the log.h interface to support ELLE logging.
// you must implicitly link you project to your logger's lib.
// you may use this implementation as a reference for impementing other loggers
//


#pragma warning( disable:4201)
#include <windows.h>
#include <crtdbg.h>
#include <stdio.h>
#include <tchar.h>
#include <log.h>


#ifdef UNICODE 
	#ifndef NT
		#define NT // for elle 
	#endif //NT
#endif// UNICODE  

//
// include your logger header file here
//
#include "elle.h"


//***************************************************
//
// static function declarations
//
//***************************************************
static WORD _SevToElle(DWORD dwSeverity);



//***************************************************
//
// static variables to hold the state of the logger
//
//***************************************************

//
// ELLE's internals
//
//static LOGSYS s_LogSys;

//
// logging is disabled by default, and turned on by lgInitializeLogger()
//
static long s_lDisableLogging = TRUE;


//
// initialize your logger, or if it is an object, create an instance of it.
//
BOOL __cdecl lgInitializeLogger()
{
	s_lDisableLogging = FALSE;
	return EcInitElle();

}



//
// close your logger, or if it is an object, delete it.
//
BOOL __cdecl lgCloseLogger()
{
	s_lDisableLogging = TRUE;
	return EcDeInitElle();

}


BOOL __cdecl lgBeginSuite(LPCTSTR szSuite)
{
#ifdef UNICODE
	char MultiByteStr[1024];
	int nSizeOfMultiByteStr = sizeof(MultiByteStr);
	BOOL fDefaultCharUsed;
	int nRet;

	memset(MultiByteStr, 0, nSizeOfMultiByteStr);

	nRet = WideCharToMultiByte(  
		CP_ACP,         // ANSI code page
		0,         // performance and mapping flags
		szSuite, // address of wide-character string
		lstrlen(szSuite),       // number of characters in string
		MultiByteStr,  // address of buffer for new string
		nSizeOfMultiByteStr,      // size of buffer
		"*",  // address of default for unmappable characters
		&fDefaultCharUsed   // address of flag set when default char. used
		);
	//
	//BUGBUG: check return values
	//
	_ASSERTE(!fDefaultCharUsed);

	BeginSuite(MultiByteStr);
#else
	BeginSuite((LPSTR)szSuite);
#endif//UNICODE

	return TRUE;
							 
}

BOOL __cdecl lgEndSuite()
{
	EndSuite();
	return TRUE;
}

BOOL __cdecl lgBeginCase(const DWORD dwCase, LPCTSTR szCase)
{
#ifdef UNICODE
	BeginCaseW(dwCase, (LPTSTR)szCase);
#else
	BeginCase(dwCase, (LPTSTR)szCase);
#endif
	return TRUE;
}



BOOL __cdecl lgEndCase()
{
	EndCase();
	return TRUE;
}


//
// set the log level.
// 9 is most details, 0 is least.
// return value is not supported.
//
int __cdecl lgSetLogLevel(const int nLogLevel)
{
	SetFileLevel((WORD)nLogLevel);
	SetCommLevel((WORD)nLogLevel);
	SetViewportLevel((WORD)nLogLevel);
	SetDbgOutLevel((WORD)nLogLevel);

	return 0;
}


BOOL __cdecl lgDisableLogging()
{
	return InterlockedExchange(&s_lDisableLogging, 1L);
}

BOOL __cdecl lgEnableLogging()
{
	return InterlockedExchange(&s_lDisableLogging, 0L);
}

void __cdecl lgLogDetail(const DWORD dwSeverity, const DWORD dwLevel, LPCTSTR szFormat, ...)
{
	if (s_lDisableLogging) return;
	else
	{
		TCHAR msg[1024];
        va_list args;
	
        va_start(args, szFormat);
        _vstprintf(msg,szFormat,args);
#ifdef UNICODE
        LogDetailW(_SevToElle(dwSeverity) ,(WORD)dwLevel,(LPTSTR)msg);
#else
        LogDetailA(_SevToElle(dwSeverity) ,(WORD)dwLevel,(LPTSTR)msg);
#endif
		va_end(args);
    }
}

void __cdecl lgLogError(const DWORD dwSeverity, LPCTSTR szFormat, ...)
{
	UNREFERENCED_PARAMETER(dwSeverity);

	if (s_lDisableLogging) return;
	else
	{
		TCHAR msg[1024];
        va_list args;
	
        va_start(args, szFormat);
        _vstprintf(msg,szFormat,args);
#ifdef UNICODE
        LogDetailW(L_FAIL,0,(LPTSTR)msg);
#else
        LogDetailA(L_FAIL,0,(LPTSTR)msg);
#endif
		va_end(args);
    }

}

//
// if you can log to a remote machine, set it here.
// it is irrelevant for ELLE.
//
BOOL __cdecl lgSetLogServer(LPCTSTR szLogServer)
{
	UNREFERENCED_PARAMETER(szLogServer);
	return FALSE;
}



static WORD _SevToElle(DWORD dwSeverity)
{
	switch(dwSeverity)
	{
	case LOG_PASS: return (WORD)L_PASS;
	case LOG_X: return (WORD)L_X;
	case LOG_SEV_1:
	case LOG_SEV_2:
	case LOG_SEV_3:
	case LOG_SEV_4:
		return (WORD)L_FAIL;

	default:
		_ASSERTE(FALSE);

	}

	//
	// to remove the warning
	//
	return (WORD)L_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\general\log\lgconsole\logconsole.c ===
//
//  This is a Console implementation of the log.h logger interface.
//  The logging is done to console.
//
//  Written 27 Aug 1998 by Nathan Lavy (v-nlavy)
//

#include <windows.h>
#include <TCHAR.H>
#include <stdio.h>
#include <conio.h>
#include <crtdbg.h>
#include <time.h>
#include <log.h>

//  Maximum length of header for suite and case
#define MAX_HEADER_LENGTH 256
//  Maximum length of error message
#define MAX_ERROR_MESSAGE 1023
//  Size of buffer for the function PrintCurrentTime
#define TIME_BUFFER_SIZE   50
//  Format for PrintCurrentTime
#define TIME_FORMAT TEXT("%y/%m/%d %H:%M:%S ")
//  DEFAULT value for logging level
// TODO - is this the right default ?
#define MAX_LOG_LEVEL 9
#define MIN_LOG_LEVEL 0

//*************************************************************
//   static variables
//*************************************************************

static CRITICAL_SECTION s_CriticalSection;
//
//  Flag whether logging has been initialized or not.
static long s_lLoggerInitialized = FALSE;
//  Logging enable/disable state.  Default is disabled state.
static long s_lLoggingIsEnabled = FALSE;
//  Current logging level
static DWORD s_dwLogLevel = MAX_LOG_LEVEL;
//
//  Current suite info
//
//  State of being inside logging of a suite.
static long s_lSuiteIsDefined = FALSE;
//  Sequential number of current suite.
static s_dwSuiteNumber = 0;
//  Title of current suite
static TCHAR s_szHeader[MAX_HEADER_LENGTH + 1] = TEXT("");
//  Number of cases in current suite.
static int  s_nCases    = 0;
//  Number of passed cases in current suite.
static int  s_nPassed   = 0;
// Number of failed cases in current suite.
static int  s_nFailed   = 0;

//
//  Current case info
//
//  State of being inside logging of a case.
static int s_lCaseIsDefined = FALSE;
//  Save here the number associated with this case.
static DWORD s_dwCaseNumData = 0;
//  First failure message for curent case
static TCHAR s_szFirstError[MAX_ERROR_MESSAGE + 1] = TEXT("");

//*************************************************************
//   static functions
//*************************************************************

//
// The function PrintCurrentTime prints the current time
// Asuming that we are holding g_CriticalSection.
//
static void PrintCurrentTime(void) {
	TCHAR szTimeBuffer[TIME_BUFFER_SIZE] = TEXT("");
	time_t TimeVal;
	struct tm *ptmStruct;
	int nSize = 0;

	// Get the system time
	time(&TimeVal);
	// Convert time to local time structure
	ptmStruct = localtime(&TimeVal);
	// Edit it to specified format
	nSize = _tcsftime (szTimeBuffer, TIME_BUFFER_SIZE, TIME_FORMAT, ptmStruct);
	_tprintf ((0 != nSize) ? szTimeBuffer : TEXT("????? "));
}



//*************************************************************
//   logger functions
//*************************************************************

//
//  Initialize the logger.  By default this also enables the logger.
//
BOOL __cdecl lgInitializeLogger()
{
	BOOL  bRetCode = FALSE;

	//
	//  If logger is initialized a second time, it will popup assert window,
	//  and if returned - will crash because LeaveCriticalSection is invoked without EnterCriticalSection.
	//  This is checked BEFORE initializing critical section a SECOND time.
	//
	if (s_lLoggerInitialized) goto out;

	//
	//   Initialize the logger and its parameters
	//
	InitializeCriticalSection (&s_CriticalSection);
	EnterCriticalSection (&s_CriticalSection);

	s_lLoggerInitialized = TRUE;
	s_lLoggingIsEnabled = TRUE;
	s_dwLogLevel = MAX_LOG_LEVEL;
	//
	//  Initialize suite parameters
	//
	s_lSuiteIsDefined = FALSE;
	_tcscpy (s_szHeader,TEXT(""));
	s_dwSuiteNumber = 0;
	s_nCases    = 0;
	s_nPassed   = 0;
	s_nFailed   = 0;

	//
	//  Initialize case parameters
	//
	s_lCaseIsDefined = FALSE;
	s_dwCaseNumData = 0;
	_tcscpy (s_szFirstError, TEXT(""));

	PrintCurrentTime();
	_tprintf (TEXT("Beginning of Console Logger\n\n"));

	LeaveCriticalSection (&s_CriticalSection);

	bRetCode = TRUE;

out:
	_ASSERTE(bRetCode);
	return bRetCode;
}

//
//  Close the logger
//
BOOL __cdecl lgCloseLogger()
{
	BOOL bRetCode = FALSE;

	if (!s_lLoggerInitialized) return bRetCode;//return so you do not delete the CS

	if (!s_lLoggingIsEnabled) goto out;

	InterlockedExchange(&s_lLoggerInitialized, FALSE);
	InterlockedExchange(&s_lLoggingIsEnabled, FALSE);

	EnterCriticalSection (&s_CriticalSection);

	//
	//  The logger is initialized.
	//  Cleanup possibly non-closed suite.
	//
	if (s_lSuiteIsDefined) lgEndSuite();

	PrintCurrentTime();
	_tprintf (TEXT("End of Console Logger\n"));
	bRetCode = TRUE;

out:
	_ASSERTE(bRetCode);

	DeleteCriticalSection (&s_CriticalSection);

	return bRetCode;
}

//
//  Begin a test suite
//
BOOL __cdecl lgBeginSuite(LPCTSTR szSuite)
{
	BOOL bRetCode = FALSE;

	if (!s_lLoggerInitialized) goto out;

	if (!s_lLoggingIsEnabled)
	{
		bRetCode = TRUE;
		goto out;
	}

	if (s_lSuiteIsDefined) goto out;

	EnterCriticalSection (&s_CriticalSection);

	//  Initialize suite parameters
	//
	_tcsncpy (s_szHeader, szSuite, MAX_HEADER_LENGTH) ;  // Save header of suite
	_tcscpy  (s_szHeader + MAX_HEADER_LENGTH, TEXT(""));
	s_dwSuiteNumber++;
	s_nCases    = 0;
	s_nPassed   = 0;
	s_nFailed   = 0;

	//
	//  Initialize case parameters
	//
	s_lCaseIsDefined = FALSE;
	s_dwCaseNumData = 0;
	_tcscpy (s_szFirstError, TEXT(""));

	s_lSuiteIsDefined = TRUE;

	PrintCurrentTime();
	_tprintf (TEXT("SUITE BEGIN (%d): %s\n"), s_dwSuiteNumber, s_szHeader);

	LeaveCriticalSection (&s_CriticalSection);

	bRetCode = TRUE;

out:
	_ASSERTE(bRetCode);
	return bRetCode;
}  // end of lgBeginSuite

//
//  End of Suite
//
BOOL __cdecl lgEndSuite()
{
	BOOL bRetCode = FALSE;

	if (!s_lLoggerInitialized) goto out;

	if (!s_lLoggingIsEnabled)
	{
		bRetCode = TRUE;
		goto out;
	}

	if (!s_lSuiteIsDefined)    goto out;

	EnterCriticalSection (&s_CriticalSection);

	//
	//  Clean up posibly non closed test case
	//
	if (s_lCaseIsDefined)
	{
		lgEndCase();
	}

	//
	//  Print summary data for the suite.
	//
	PrintCurrentTime();
	_tprintf (TEXT("SUITE END (%d): %s\n"), s_dwSuiteNumber, s_szHeader);
	PrintCurrentTime();
	_tprintf (TEXT("Number of cases in suite %d\n"), s_nCases);
	PrintCurrentTime();
	_tprintf (TEXT("Number of passed cases   %d\n"), s_nPassed);
	PrintCurrentTime();
	_tprintf (TEXT("Number of failed cases   %d\n"), s_nFailed);

	s_lSuiteIsDefined = FALSE;

	LeaveCriticalSection (&s_CriticalSection);

	bRetCode = TRUE;

out:
	_ASSERTE(bRetCode);
	return bRetCode;
}

//
//  Begin a case
//
BOOL __cdecl lgBeginCase(const DWORD dwCase, LPCTSTR szCase)
{
	BOOL bRetCode = FALSE;

	if (!s_lLoggerInitialized) goto out;

	if (!s_lLoggingIsEnabled)
	{
		bRetCode = TRUE;
		goto out;
	}

	if (s_lCaseIsDefined)      goto out;

	EnterCriticalSection (&s_CriticalSection);

	//
	//  Save case info in static area for the termination message.
	//
	s_dwCaseNumData = dwCase;
	//
	//  Initialize case parameters
	//
	_tcscpy (s_szFirstError, TEXT(""));

	s_lCaseIsDefined = TRUE;

	PrintCurrentTime();
	_tprintf (TEXT("CASE BEGIN (%d): %s\n"), dwCase, szCase);

	LeaveCriticalSection (&s_CriticalSection);

	bRetCode = TRUE;

out:
	_ASSERTE(bRetCode);
	return bRetCode;
}

//
//  End of a case
//
BOOL __cdecl lgEndCase()
{
	BOOL bRetCode = FALSE;

	if (!s_lLoggerInitialized) goto out;

	if (!s_lLoggingIsEnabled)
	{
		bRetCode = TRUE;
		goto out;
	}

	if (!s_lCaseIsDefined)     goto out;

	EnterCriticalSection (&s_CriticalSection);

	//
	// Case is really ending. Check if it has failed then print saved error detail.
	//
	PrintCurrentTime();
	if (_tcscmp (s_szFirstError, TEXT("")) != 0)
	{
		s_nFailed++;
		_tprintf (TEXT("CASE:FAILED: (%d): %s\n"), s_dwCaseNumData, s_szFirstError);
	}
	else
	{
		s_nPassed++;
		_tprintf (TEXT("CASE:PASSED: (%d)\n"), s_dwCaseNumData);
	}
	s_nCases++;
	s_lCaseIsDefined = FALSE;
	_tcscpy (s_szFirstError, TEXT(""));

	LeaveCriticalSection (&s_CriticalSection);

	bRetCode = TRUE;
out:
	_ASSERTE(bRetCode);
	return bRetCode;
}  // end of lgEndCase

//
//  Set logging level
//
int __cdecl lgSetLogLevel(const int nLogLevel)
{
	if (!s_lLoggerInitialized) goto out;

	EnterCriticalSection(&s_CriticalSection);
	//
	//  If level is not within range - default to highest number allowed.
	//  This is taken from logElle.
	//
	if (nLogLevel < 0 || nLogLevel > MAX_LOG_LEVEL)
	{
		s_dwLogLevel = MAX_LOG_LEVEL;
	}
	else
	{
		s_dwLogLevel = nLogLevel;
	}

	LeaveCriticalSection (&s_CriticalSection);

out:
	return 0;
}

//
// Disable the logger (Must be initialized when invoked).
//
BOOL __cdecl lgDisableLogging()
{
	BOOL bRetCode = FALSE;

	if (!s_lLoggerInitialized) goto out;

	if (!s_lLoggingIsEnabled)
	{
		bRetCode = TRUE;
		goto out;
	}

	InterlockedExchange(&s_lLoggingIsEnabled, FALSE);

	bRetCode = TRUE;

out:
	_ASSERTE(bRetCode);
	return bRetCode;
}

//
// Enable the logger.
// The logger is enabled automatically when it is initialized.
//
BOOL __cdecl lgEnableLogging()
{
	BOOL bRetCode = FALSE;

	if (!s_lLoggerInitialized) goto out;

	if (s_lLoggingIsEnabled)
	{
		bRetCode = TRUE;
		goto out;
	}

	InterlockedExchange(&s_lLoggingIsEnabled, TRUE);

	bRetCode = TRUE;

out:
	_ASSERTE(bRetCode);
	return bRetCode;
}
//
//   lgLogDetail - Process a detail in a test case
//
void __cdecl lgLogDetail(const DWORD dwSeverity, const DWORD dwLevel, LPCTSTR szFormat, ...)
{
	TCHAR msg[MAX_ERROR_MESSAGE];
    va_list args;
	TCHAR *pszSeverity;
	DWORD dwActualLogLevel;

	if (!s_lLoggerInitialized)  goto out;

	if (!s_lLoggingIsEnabled)	goto out;

	EnterCriticalSection (&s_CriticalSection);

	if (dwLevel > MAX_LOG_LEVEL)
	{
		dwActualLogLevel = MAX_LOG_LEVEL;
	}
	else
	{
		dwActualLogLevel = dwLevel;
	}

	//
	//  If level is not within range - default to highest number allowed.
	//  This is taken from logElle.
	//
	if (dwActualLogLevel > s_dwLogLevel) goto leave_CS;

    va_start(args, szFormat);
	//  Edit the message from the caller.
    _vstprintf(msg, szFormat, args);
	va_end(args);

	switch (dwSeverity)
	{
	case LOG_PASS:
		pszSeverity = TEXT("PASS");
		break;

	case LOG_X:
	//case LOG_SEVERITY_DONT_CARE:
		pszSeverity = TEXT("X");
		break;

	case LOG_SEV_1:
		pszSeverity = TEXT("FAILED SEV1");
		//
		//  A failure message. If first in this test case - memorize it.
		//
		if (s_szFirstError[0] == TEXT('\0')) {
			_tcsncpy (s_szFirstError, msg, MAX_ERROR_MESSAGE) ;  // Save formatted message
			_tcscpy  (s_szFirstError + MAX_ERROR_MESSAGE, TEXT(""));
		}
		break;
	case LOG_SEV_2:
		pszSeverity = TEXT("FAILED SEV2");
		//
		//  A failure message. If first in this test case - memorize it.
		//
		if (s_szFirstError[0] == TEXT('\0')) {
			_tcsncpy (s_szFirstError, msg, MAX_ERROR_MESSAGE) ;  // Save formatted message
			s_szFirstError[MAX_ERROR_MESSAGE-1] = TEXT('\0');
		}
		break;
	case LOG_SEV_3:
		pszSeverity = TEXT("FAILED SEV3");
		//
		//  A failure message. If first in this test case - memorize it.
		//
		if (s_szFirstError[0] == TEXT('\0')) {
			_tcsncpy (s_szFirstError, msg, MAX_ERROR_MESSAGE) ;  // Save formatted message
			s_szFirstError[MAX_ERROR_MESSAGE-1] = TEXT('\0');
		}
		break;
	case LOG_SEV_4:
		pszSeverity = TEXT("FAILED SEV4");
		//
		//  A failure message. If first in this test case - memorize it.
		//
		if (s_szFirstError[0] == TEXT('\0')) {
			_tcsncpy (s_szFirstError, msg, MAX_ERROR_MESSAGE) ;  // Save formatted message
			s_szFirstError[MAX_ERROR_MESSAGE-1] = TEXT('\0');
		}
		break;

	default:
		pszSeverity = TEXT("FAILED INTERNAL ERROR: illegal severity");
		//
		//  A failure message. If first in this test case - memorize it.
		//
		if (s_szFirstError[0] == TEXT('\0')) {
			_tcsncpy (s_szFirstError, msg, MAX_ERROR_MESSAGE) ;  // Save formatted message
			s_szFirstError[MAX_ERROR_MESSAGE-1] = TEXT('\0');
		}

		_ASSERTE (FALSE);
	}

	//
	// If we go out from here the failure may be recorded, but the detail will not be displayed.
	// This is also done the same way as in logElle.
	//
	//  Print the first part of the line.
	PrintCurrentTime();
	_tprintf (TEXT("	DETAIL(%d):%s: %s\n"), dwActualLogLevel, pszSeverity, msg);

leave_CS:
	LeaveCriticalSection (&s_CriticalSection);

out:
	return;
}  //  end of lgLogDetail

//
//  lgLogError  -  log an error
//  This is similar to lgLogDetail, only it enforces FAIL for the message, and
//  the level defaults to 0 (shows always).
//
void __cdecl lgLogError(const DWORD dwSeverity, LPCTSTR szFormat, ...)
{
	// TODO Like LogElle - dwSeverity is ignored. Is it OK ??
	TCHAR msg[MAX_ERROR_MESSAGE];
    va_list args;

	if (!s_lLoggerInitialized) goto out;

	EnterCriticalSection (&s_CriticalSection);

    va_start(args, szFormat);
	//  Edit the message from the caller.
    _vstprintf(msg, szFormat, args);
	va_end(args);

	lgLogDetail (LOG_SEV_4, 0, TEXT("%s"), msg);

out:
	LeaveCriticalSection (&s_CriticalSection);

	return;
}

//NIY  TODO ???
BOOL __cdecl lgSetLogServer(LPCTSTR szLogServer)
{
	SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	_ASSERTE(FALSE);
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\general\service.cpp ===
#include <service.h>
#include <assert.h>
#include <testruntimeerr.h>
#include <tstring.h>


/*++
    Queries the service for its state until desired state is achieved or until timeout.
  
    [IN]            hService        The service handle.
    [IN]            dwState         The desired state.
    [IN]            dwTimeout       Timeout in milliseconds
    [IN] (optional) dwSleep         Number of milliseconds to sleep between calls to QueryServiceStatus().
                                    If not specified, the default value is used.

    Return value:                   If the function succeeds, the return value is nonzero.
                                    If the function fails, the return value is zero.
                                    To get extended error information, call GetLastError. 
--*/
BOOL WaitForServiceState(
                         const SC_HANDLE    hService,
                         const DWORD        dwState,
                         const DWORD        dwTimeout,
                         const DWORD        dwSleep
                         )
{
    SERVICE_STATUS ServiceStatus;
    DWORD dwStartTickCount = GetTickCount();

    if (!hService)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    for(;;)
    {
        // Get the last reported service status
        if (!QueryServiceStatus(hService, &ServiceStatus))  
        {
            return FALSE;
        } 
    
        if (ServiceStatus.dwCurrentState == dwState)
        {
            SetLastError(ERROR_SUCCESS);
            return TRUE;
        }

        if (GetTickCount() > dwStartTickCount + dwTimeout)
        {
            SetLastError(ERROR_SERVICE_REQUEST_TIMEOUT);
            return FALSE;
        }

        Sleep(dwSleep);        
    }
}



/*++
    Sends a request to a service. The function is synchronous: it returns after required
    operation completes or afer a timeout.
  
    [IN]                lpctstrMachineName  The machine name (NULL for local machine)
    [IN]                lpctstrServiceName  The service name
    [IN]                RequiredAction      Requered action. Supported actions are defined in SERVICE_REQUEST enumeration.
    [OUT] (optional)    pdwDisposition      Pointer to a variable that receives additional information (win32 error code)
                                            about the action request result.
                                            For example, if the request is SERVICE_REQUEST_START and the specified
                                            service is already running, the function will return TRUE and *pdwDisposition
                                            will be set to ERROR_SERVICE_ALREADY_RUNNING.
                                            If pdwDisposition argument is not passed or it is NULL, no additional
                                            information will be supplied.

    Return value:                           If the function succeeds, the return value is nonzero.
                                            If the function fails, the return value is zero.
                                            To get extended error information, call GetLastError. 
--*/
BOOL ServiceRequest(
                    LPCTSTR                 lpctstrMachineName,
                    LPCTSTR                 lpctstrServiceName,
                    const SERVICE_REQUEST   RequiredAction,
                    DWORD                   *pdwDisposition
                    )
{
    SC_HANDLE   hSCManager  = NULL;
    SC_HANDLE   hService    = NULL;
    DWORD       dwEC        = ERROR_SUCCESS;
    
    if (!lpctstrServiceName)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    try
    {
        hSCManager = OpenSCManager(lpctstrMachineName, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT);
        if (!hSCManager)
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("ControlFaxService - OpenSCManager"));
        }

        hService = OpenService(hSCManager, lpctstrServiceName, SERVICE_START | SERVICE_STOP | SERVICE_QUERY_STATUS);
        if (!hService)
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("ControlFaxService - OpenService"));
        }

        if (pdwDisposition)
        {
            // No additional info by default

            *pdwDisposition = ERROR_SUCCESS;
        }

        switch(RequiredAction)
        {
        case SERVICE_REQUEST_START:
            if (!StartService(hService, 0, NULL))
            {
                dwEC = GetLastError();
                if (dwEC == ERROR_SERVICE_ALREADY_RUNNING && pdwDisposition)
                {
                    *pdwDisposition = dwEC;
                    dwEC = ERROR_SUCCESS;
                }
                else
                {
                    THROW_TEST_RUN_TIME_WIN32(dwEC, TEXT("ControlFaxService - StartService"));
                }
            }
            if (!WaitForServiceState(hService, SERVICE_RUNNING, SERVICE_REQUEST_TIMEOUT))
            {
                THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("ControlFaxService - WaitForServiceState"));
            }
            break;

        case SERVICE_REQUEST_STOP:
            {
                SERVICE_STATUS LastServiceStatus;

                if (!ControlService(hService, SERVICE_CONTROL_STOP, &LastServiceStatus))
                {
                    dwEC = GetLastError();
                    if (dwEC == ERROR_SERVICE_NOT_ACTIVE && pdwDisposition)
                    {
                        *pdwDisposition = dwEC;
                        dwEC = ERROR_SUCCESS;
                    }
                    else
                    {
                        THROW_TEST_RUN_TIME_WIN32(dwEC, TEXT("ControlFaxService - ControlService"));
                    }
                }
            }
            if (!WaitForServiceState(hService, SERVICE_STOPPED, SERVICE_REQUEST_TIMEOUT))
            {
                THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("ControlFaxService - WaitForServiceState"));
            }
            break;

        default:
            assert(FALSE);
            THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, TEXT("ControlFaxService"));
        }
    }

    catch(Win32Err& e)
    {
        dwEC = e.error();
    }

    // CleanUp
    if (hService && !CloseServiceHandle(hService))
    {
        // Report clean up error
    }

    if (hSCManager && !CloseServiceHandle(hSCManager))
    {
        // Report clean up error
    }

    if (dwEC != ERROR_SUCCESS)
    {
        SetLastError(dwEC);
        return FALSE;
    }

    return TRUE;
}



/*++
    Returns the account name under which the specified service runs.
  
    [IN]    lpctstrMachineName      The machine name (NULL for local machine)
    [IN]    lpctstrServiceName      Service name
    [OUT]   lplpctstrAccountName    Pointer to pointer to a buffer, that receives the account name.
                                    The buffer is allocated by the function and caller's responsibility
                                    is to free it with delete operator.

    Return value:                   If the function succeeds, the return value is nonzero.
                                    If the function fails, the return value is zero.
                                    To get extended error information, call GetLastError. 
--*/
BOOL ServiceAccout(
                   LPCTSTR lpctstrMachineName,
                   LPCTSTR lpctstrServiceName,
                   LPTSTR *lplptstrAccountName
                   )
{
    SC_HANDLE               hSCManager              = NULL;
    SC_HANDLE               hService                = NULL;
    LPQUERY_SERVICE_CONFIG  pServiceConfig          = NULL;
    DWORD                   dwBufSize               = 0;
    DWORD                   dwEC                    = ERROR_SUCCESS;
    
    if (!(lpctstrServiceName && lplptstrAccountName))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    try
    {
        hSCManager = OpenSCManager(lpctstrMachineName, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT);
        if (!hSCManager)
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("DoesRunUnderAccount - OpenSCManager"));
        }

        hService = OpenService(hSCManager, lpctstrServiceName, SERVICE_QUERY_CONFIG);
        if (!hService)
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("DoesRunUnderAccount - OpenService"));
        }
        
        // Get service info
        if (QueryServiceConfig(hService, pServiceConfig, 0, &dwBufSize))
        {
            assert(FALSE);
        }
        else if ((dwEC = GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
        {
            THROW_TEST_RUN_TIME_WIN32(dwEC, TEXT("DoesRunUnderAccount - QueryServiceConfig"));
        }
        dwEC = ERROR_SUCCESS;

        if (!(pServiceConfig = reinterpret_cast<LPQUERY_SERVICE_CONFIG>(new BYTE[dwBufSize])))
        {
            THROW_TEST_RUN_TIME_WIN32(ERROR_NOT_ENOUGH_MEMORY, TEXT("DoesRunUnderAccount"));
        }
        if (!QueryServiceConfig(hService, pServiceConfig, dwBufSize, &dwBufSize))
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("DoesRunUnderAccount - QueryServiceConfig"));
        }

        // Get account name
        if (pServiceConfig->lpServiceStartName)
        {
            if (!(*lplptstrAccountName = new TCHAR[_tcslen(pServiceConfig->lpServiceStartName)]))
            {
                THROW_TEST_RUN_TIME_WIN32(ERROR_NOT_ENOUGH_MEMORY, TEXT("DoesRunUnderAccount"));
            }

            _tcscpy(*lplptstrAccountName, pServiceConfig->lpServiceStartName);
        }
    }

    catch(Win32Err& e)
    {
        dwEC = e.error();
    }

    // CleanUp
    if (pServiceConfig)
    {
        delete pServiceConfig;
    }
    if (hService && !CloseServiceHandle(hService))
    {
        // Report clean up error
    }
    if (hSCManager && !CloseServiceHandle(hSCManager))
    {
        // Report clean up error
    }

    if (dwEC != ERROR_SUCCESS)
    {
        SetLastError(dwEC);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\general\securityutils.cpp ===
#include <securityutils.h>

#include <assert.h>
#include <Accctrl.h>
#include <Aclapi.h>
#include <testruntimeerr.h>
#include <tstring.h>



/*++
    Retrieves an ACL size in bytes.

    [IN]    pAcl                            Pointer to an ACL.
    [OUT]   pdwSize                         Pointer to a DWORD variable that receives the size.
    [IN]    bActuallyAllocated (optional)   Specifies whether the return value will be the number of bytes,
                                            actually allocated for the ACL or only number of bytes used
                                            to store information (which may be less).

    Return value:                           If the function succeeds, the return value is nonzero.
                                            If the function fails, the return value is zero.
                                            To get extended error information, call GetLastError.
--*/

BOOL GetAclSize(
                PACL    pAcl,
                DWORD   *pdwSize,
                BOOL    bActuallyAllocated
                )
{

    ACL_SIZE_INFORMATION    AclInfo;

    if (!(pAcl && pdwSize))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    if (!GetAclInformation(pAcl, &AclInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
    {
        return FALSE;
    }
    
    *pdwSize = AclInfo.AclBytesInUse + (bActuallyAllocated ? AclInfo.AclBytesInUse : 0);

    return TRUE;
}



/*++
    Retrieves a SID size in bytes.

    [IN]    pSid        Pointer to a SID.
    [OUT]   pdwSize     Pointer to a DWORD variable that receives the size.

    Return value:       If the function succeeds, the return value is nonzero.
                        If the function fails, the return value is zero.
                        To get extended error information, call GetLastError.
--*/

BOOL GetSidSize(
                PSID    pSid,
                DWORD   *pdwSize
                )
{
    if (!(pSid && IsValidSid(pSid) && pdwSize))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    *pdwSize = GetLengthSid(pSid);

    return TRUE;
}



/*++
    Creates a copy of a security descriptor.
    
    [IN]    pOriginalSecDesc    Pointer to original security descriptor (in either absolute or self-relative form).
    [IN]    bSelfRelative       Specifies whether a copy of the  security descriptor should be in self-relative form
                                (absolute otherwise).
    [OUT]   ppNewSecDesc        Pointer to a variable that receives pointer to a copy of security descriptor.
                                Memory is allocated by the function. The memory is always allocated as contiguous block.
                                The caller's responsibility is to free it by a call to LocalFree().

    Return value:               If the function succeeds, the return value is nonzero.
                                If the function fails, the return value is zero.
                                To get extended error information, call GetLastError.
--*/

BOOL CopySecDesc(
                 PSECURITY_DESCRIPTOR pOriginalSecDesc,
                 BOOL bSelfRelative,
                 PSECURITY_DESCRIPTOR *ppNewSecDesc
                 )
{
    SECURITY_DESCRIPTOR_CONTROL SecDescControl      = 0;
    DWORD                       SecDescRevision     = 0;
    PSECURITY_DESCRIPTOR        pSecDescCopy        = NULL;
    PSECURITY_DESCRIPTOR        pTmpRelSecDesc      = NULL;
    PACL                        pDacl               = NULL;
    PACL                        pSacl               = NULL;
    PSID                        pOwner              = NULL;
    PSID                        pPrimaryGroup       = NULL;
    DWORD                       dwEC                = ERROR_SUCCESS;

    try
    {
        // Check arguments validity
        if (!(pOriginalSecDesc && IsValidSecurityDescriptor(pOriginalSecDesc) && ppNewSecDesc))
        {
            THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, TEXT("CopySecDesc"));
        }
        
        // Get security desriptor control to check its form
        if (!GetSecurityDescriptorControl(pOriginalSecDesc, &SecDescControl, &SecDescRevision))
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("CopySecDesc - GetSecurityDescriptorControl"));
        }

        if ((SecDescControl & SE_SELF_RELATIVE) == SE_SELF_RELATIVE)
        {
            // The original SD is in self-relative form.

            if (bSelfRelative)
            {
                // New SD should be in self-relative form. Just copy.

                DWORD dwBufferSize = GetSecurityDescriptorLength(pOriginalSecDesc);

                // Allocate the buffer
                if (!(pSecDescCopy = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, dwBufferSize)))
                {
                    THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("CopySecDesc - LocalAlloc"));
                }

                // Copy
                memcpy(pSecDescCopy, pOriginalSecDesc, dwBufferSize);
            }
            else
            {
                // New SD should be in absolute form. Convert.
            
                DWORD dwSecDescSize       = 0;
                DWORD dwDaclSize          = 0;
                DWORD dwSaclSize          = 0;
                DWORD dwOwnerSize         = 0;
                DWORD dwPrimaryGroupSize  = 0;

                // Get the required buffers sizes
                if(MakeAbsoluteSD(
                                  pOriginalSecDesc,
                                  NULL,
                                  &dwSecDescSize,
                                  NULL,
                                  &dwDaclSize,
                                  NULL,
                                  &dwSaclSize,
                                  NULL,
                                  &dwOwnerSize,
                                  NULL,
                                  &dwPrimaryGroupSize
                                  ))
                {
                    assert(FALSE);
                }
                else if ((dwEC = GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
                {
                    THROW_TEST_RUN_TIME_WIN32(dwEC, TEXT("CopySecDesc - MakeAbsoluteSD"));
                }
                dwEC = ERROR_SUCCESS;
                
                // Allocate memory
                pSecDescCopy    = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, dwSecDescSize);
                pDacl           = (PACL)LocalAlloc(LMEM_FIXED, dwDaclSize);
                pSacl           = (PACL)LocalAlloc(LMEM_FIXED, dwSaclSize);
                pOwner          = (PSID)LocalAlloc(LMEM_FIXED, dwOwnerSize);
                pPrimaryGroup   = (PSID)LocalAlloc(LMEM_FIXED, dwPrimaryGroupSize);

                if(!(pSecDescCopy && pDacl && pSacl && pOwner && pPrimaryGroup))
                {
                    THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("CopySecDesc - LocalAlloc"));
                }

                // Convert.
                if(!MakeAbsoluteSD(
                                   pOriginalSecDesc,
                                   pSecDescCopy,
                                   &dwSecDescSize,
                                   pDacl,
                                   &dwDaclSize,
                                   pSacl,
                                   &dwSaclSize,
                                   pOwner,
                                   &dwOwnerSize,
                                   pPrimaryGroup,
                                   &dwPrimaryGroupSize
                                   ))
                {
                    THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("CopySecDesc - MakeAbsoluteSD"));
                }
            }
        }
        else
        {
            // The original SD is in absolute form.

            if (bSelfRelative)
            {
                // New SD should be in self-relative form. Convert.

                DWORD dwBufferSize = 0;

                // Get the required buffer size.
                if (MakeSelfRelativeSD(pOriginalSecDesc, NULL, &dwBufferSize))
                {
                    assert(FALSE);
                }
                else if ((dwEC = GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
                {
                    THROW_TEST_RUN_TIME_WIN32(dwEC, TEXT("CopySecDesc - MakeSelfRelativeSD"));
                }
                dwEC = ERROR_SUCCESS;

                // Allocate the buffer.
                if (!(pSecDescCopy = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, dwBufferSize)))
                {
                    THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("CopySecDesc - LocalAlloc"));
                }
                
                // Convert.
                if (!MakeSelfRelativeSD(pOriginalSecDesc, pSecDescCopy, &dwBufferSize))
                {
                    THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("CopySecDesc - MakeSelfRelativeSD"));
                }
            }
            else
            {
                // New SD should be in absolute form. Copy.

                // Recursive call to create a temporary self-relative copy.
                if (!CopySecDesc(pOriginalSecDesc, TRUE, &pTmpRelSecDesc))
                {
                    THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("CopySecDesc - CopySecDesc recursive call"));
                }

                // Recursive call to convert the temporary self-relative to absolute.
                if (!CopySecDesc(pTmpRelSecDesc, FALSE, &pSecDescCopy))
                {
                    THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("CopySecDesc - CopySecDesc recursive call"));
                }
            }
        }

        if (!IsValidSecurityDescriptor(pSecDescCopy))
        {
            assert(FALSE);
            THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_SECURITY_DESCR, TEXT("CopySecDesc"));
        }

        *ppNewSecDesc = pSecDescCopy;
    }

    catch(Win32Err& e)
    {
        dwEC = e.error();
    }

    // CleanUp

    // pTmpRelSecDesc is internal copy and should be freed always
    if (pTmpRelSecDesc && !FreeSecDesc(pTmpRelSecDesc))
    {
        // Report clean up error
    }

    if (dwEC != ERROR_SUCCESS)
    {
        // The function failed - free all allocated resources
        
        // Cannot use FreeSecDesc() here, because of the following case:
        //    memory for DACL, SACL, Owner and Group is allocated, but SD pointers are not assigned.
        // Therefore should free manually.

        if (pSecDescCopy && LocalFree(pSecDescCopy) != NULL)
        {
            // Report clean up error
        }
        
        if (pDacl && LocalFree(pDacl) != NULL)
        {
            // Report clean up error
        }
        
        if (pSacl && LocalFree(pSacl) != NULL)
        {
            // Report clean up error
        }
        
        if (pOwner && LocalFree(pOwner) != NULL)
        {
            // Report clean up error
        }
        
        if (pPrimaryGroup && LocalFree(pPrimaryGroup) != NULL)
        {
            // Report clean up error
        }
        
        SetLastError(dwEC);
        return FALSE;
    }

    return TRUE;
}



/*++
    Frees a security descriptor.

    [IN]    pSecDesc    Pointer to a security descriptor (in either absolute or self-relative form).
                        Assumed that the memory pointed to by pSecDesc (and all related ACL and SID structures
                        in case of absolute form) was allocated by LocalAlloc.

    Return value:       If the function succeeds, the return value is nonzero.
                        If the function fails, the return value is zero.
                        To get extended error information, call GetLastError.

                        The function fails if pSecDesc is NULL or points to invalid SD, or if it cannot retrieve
                        the SD form.
--*/

BOOL FreeSecDesc(
                 PSECURITY_DESCRIPTOR pSecDesc
                 )
{
    SECURITY_DESCRIPTOR_CONTROL SecDescControl  = 0;
    DWORD                       SecDescRevision = 0;
    DWORD                       dwEC            = ERROR_SUCCESS;

    try
    {
        // Check arguments validity
        if (!(pSecDesc && IsValidSecurityDescriptor(pSecDesc)))
        {
            THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, TEXT("FreeSecDesc"));
        }
        
        // Get security desriptor control to check its form
        if (!GetSecurityDescriptorControl(pSecDesc, &SecDescControl, &SecDescRevision))
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("FreeSecDesc - GetSecurityDescriptorControl"));
        }

        if ((SecDescControl & SE_SELF_RELATIVE) != SE_SELF_RELATIVE)
        {
            // The SD is in absolute form. Should free all associated ACL and SID structures.

            BOOL    bPresent        = FALSE;
            BOOL    bDefaulted      = FALSE;
            PACL    pACL            = NULL;
            PSID    pSID            = NULL;

            // Free DACL
            if (
                !GetSecurityDescriptorDacl(pSecDesc, &bPresent, &pACL, &bDefaulted)    ||
                (bPresent && pACL && LocalFree(pACL) != NULL)
                )
            {
                // Report memory leak; 
            }

            // Free SACL
            if (
                !GetSecurityDescriptorSacl(pSecDesc, &bPresent, &pACL, &bDefaulted)    ||
                (bPresent && pACL && LocalFree(pACL) != NULL)
                )
            {
                // Report memory leak; 
            }

            // Free Owner
            if (
                !GetSecurityDescriptorOwner(pSecDesc, &pSID, &bDefaulted)              ||
                (pSID && LocalFree(pSID) != NULL)
                )
            {
                // Report memory leak; 
            }

            // Free Group
            if (
                !GetSecurityDescriptorGroup(pSecDesc, &pSID, &bDefaulted)              ||
                (pSID && LocalFree(pSID) != NULL)
                )
            {
                // Report memory leak; 
            }
        }

        // Free SD
        if (LocalFree(pSecDesc) != NULL)
        {
            // Report memory leak; 
        }
    }

    catch(Win32Err& e)
    {
        dwEC = e.error();
    }

    if (dwEC != ERROR_SUCCESS)
    {
        SetLastError(dwEC);
        return FALSE;
    }

    return TRUE;
}



/*++
    Creates new security descriptor with modified DACL.

    [IN]    pCurrSecDesc    Pointer to current security descriptor (in either absolute or self-relative form).
    [IN]    lptstrTrustee   User or group name. If it's NULL, access is set for currently logged on user.
    [IN]    dwAllow         Specifies access rights to be allowed.
    [IN]    dwDeny          Specifies access rights to be denied.
    [IN]    bReset          Specifies whether old ACL information should be completeley discarded or
                            merged with new informaton.
    [IN]    bSelfRelative   Specifies whether new security descriptor should be in self-relative form
                            (absolute otherwise).
    [OUT]   ppNewSecDesc    Pointer to a variable that receives pointer to modified security descriptor.
                            Memory is allocated by the function. The caller's responsibility is to free it
                            by a call to LocalFree().

    "Deny" is stronger than "Allow". Meaning, if the same right is specified in both dwAllow and dwDeny,
    the right will be denied.

    Calling the function with both dwAllow = 0 and dwDeny = 0 and bReset = TRUE has an affect of removing
    all ACEs for the specified user or group.

    Return value:           If the function succeeds, the return value is nonzero.
                            If the function fails, the return value is zero.
                            To get extended error information, call GetLastError. 
--*/

BOOL CreateSecDescWithModifiedDacl(
                                   PSECURITY_DESCRIPTOR pCurrSecDesc,
                                   LPTSTR lptstrTrustee,
                                   DWORD dwAllow,
                                   DWORD dwDeny,
                                   BOOL bReset,
                                   BOOL bSelfRelative,
                                   PSECURITY_DESCRIPTOR *ppNewSecDesc
                                   )
{
    PSECURITY_DESCRIPTOR    pNewSecDescAbs      =   NULL;
    PSECURITY_DESCRIPTOR    pNewSecDescRel      =   NULL;
    PACL                    pOriginalDacl       =   NULL;
    PACL                    pDaclTmp            =   NULL;
    PACL                    pDaclAfterReset     =   NULL;
    PACL                    pDaclWithNewInfo    =   NULL;
    PACL                    pNewDacl            =   NULL;
    BOOL                    bDaclPresent        =   FALSE;
    BOOL                    bDaclDefaulted      =   FALSE;
    DWORD                   dwEC                =   ERROR_SUCCESS;

    try
    {
        // Check arguments validity
        if (!(pCurrSecDesc && IsValidSecurityDescriptor(pCurrSecDesc) && ppNewSecDesc))
        {
            THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, TEXT("CreateSecDescWithModifiedDacl"));
        }
        
        // Get current DACL of the original SD        
        if (!GetSecurityDescriptorDacl(pCurrSecDesc, &bDaclPresent, &pOriginalDacl, &bDaclDefaulted))
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("CreateSecDescWithModifiedDacl - GetSecurityDescriptorDacl"));
        }
        if (!bDaclPresent)
        {
            assert(!pOriginalDacl);
        }

        if (bReset)
        {
            EXPLICIT_ACCESS AccessReset[2] =    {
                                                    {
                                                        GENERIC_EXECUTE,
                                                        SET_ACCESS,
                                                        NO_INHERITANCE,
                                                        {
                                                            NULL,
                                                            NO_MULTIPLE_TRUSTEE,
                                                            TRUSTEE_IS_NAME,
                                                            TRUSTEE_IS_UNKNOWN,
                                                            lptstrTrustee ? lptstrTrustee : TEXT("CURRENT_USER")
                                                        }
                                                    },
                                                    {
                                                        0,
                                                        REVOKE_ACCESS,
                                                        NO_INHERITANCE,
                                                        {
                                                            NULL,
                                                            NO_MULTIPLE_TRUSTEE,
                                                            TRUSTEE_IS_NAME,
                                                            TRUSTEE_IS_UNKNOWN,
                                                            lptstrTrustee ? lptstrTrustee : TEXT("CURRENT_USER")
                                                        }
                                                    }
                                                };

            // This call causes removal of all ACEs (including "access-denied") and creation of new "GENERIC_EXECUTE allowed" ACE
            // for the specified trustee.
            dwEC = SetEntriesInAcl(1, &(AccessReset[0]), pOriginalDacl, &pDaclTmp);
            if (dwEC != ERROR_SUCCESS)
            {
                THROW_TEST_RUN_TIME_WIN32(dwEC, TEXT("CreateSecDescWithModifiedDacl - SetEntriesInAcl"));
            }

            // This call removes the "access-allowed" ACE, added by previous call.
            dwEC = SetEntriesInAcl(1, &(AccessReset[1]), pDaclTmp, &pDaclAfterReset);
            if (dwEC != ERROR_SUCCESS)
            {
                THROW_TEST_RUN_TIME_WIN32(dwEC, TEXT("CreateSecDescWithModifiedDacl - SetEntriesInAcl"));
            }

            assert(IsValidAcl(pDaclAfterReset));
        }

        if (dwAllow | dwDeny)
        {
            EXPLICIT_ACCESS AccessModifiers[2]  =   {
                                                        {
                                                            dwAllow & ~dwDeny,
                                                            GRANT_ACCESS,
                                                            NO_INHERITANCE,
                                                            {
                                                                NULL,
                                                                NO_MULTIPLE_TRUSTEE,
                                                                TRUSTEE_IS_NAME,
                                                                TRUSTEE_IS_UNKNOWN,
                                                                lptstrTrustee ? lptstrTrustee : TEXT("CURRENT_USER")
                                                            }
                                                        },
                                                        {
                                                            dwDeny,
                                                            DENY_ACCESS,
                                                            NO_INHERITANCE,
                                                            {
                                                                NULL,
                                                                NO_MULTIPLE_TRUSTEE,
                                                                TRUSTEE_IS_NAME,
                                                                TRUSTEE_IS_UNKNOWN,
                                                                lptstrTrustee ? lptstrTrustee : TEXT("CURRENT_USER")
                                                            }
                                                        }
                                                    };

            // Create new ACL as combination of current DACL, dwAllow and dwDeny
            dwEC = SetEntriesInAcl(2, AccessModifiers, pDaclAfterReset ? pDaclAfterReset : pOriginalDacl, &pDaclWithNewInfo);
            if (dwEC != ERROR_SUCCESS)
            {
                THROW_TEST_RUN_TIME_WIN32(dwEC, TEXT("CreateSecDescWithModifiedDacl - SetEntriesInAcl"));
            }

            assert(IsValidAcl(pDaclWithNewInfo));
        }

        if (pDaclWithNewInfo)
        {
            // At least new information (dwAllow and/or dwDeny) specified

            pNewDacl = pDaclWithNewInfo;
        }
        else if(pDaclAfterReset)
        {
            // bReset is TRUE

            pNewDacl = pDaclAfterReset;
        }
        else
        {
            // There is nothing to do

            THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, TEXT("CreateSecDescWithModifiedDacl"));
        }

        // Create a copy of the original security descriptor in absolute form
        if (!CopySecDesc(pCurrSecDesc, FALSE, &pNewSecDescAbs))
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("CreateSecDescWithModifiedDacl - CopySecDesc"));
        }

        // Get current DACL of the copy and free it.
        if (!GetSecurityDescriptorDacl(pNewSecDescAbs, &bDaclPresent, &pOriginalDacl, &bDaclDefaulted))
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("CreateSecDescWithModifiedDacl - GetSecurityDescriptorDacl"));
        }
        if (bDaclPresent)
        {
            if (pOriginalDacl && LocalFree(pOriginalDacl) != NULL)
            {
                // Report memory leak; 
            }
        }
        else
        {
            assert(!pOriginalDacl);
        }

        // Replace the DACL of the copy.
        // Note that SetSecurityDescriptorDacl() doesn't copy the DACL. It just assigns a pointer.
        if (!SetSecurityDescriptorDacl(pNewSecDescAbs, TRUE, pNewDacl, FALSE))
        {
            THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("CreateSecDescWithModifiedDacl - SetSecurityDescriptorDacl"));
        }

        if (bSelfRelative)
        {
            // Convert newly created security descriptor into self-relative form
            if (!CopySecDesc(pNewSecDescAbs, TRUE, &pNewSecDescRel))
            {
                THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("CreateSecDescWithModifiedDacl - CopySecDesc"));
            }

            if (!IsValidSecurityDescriptor(pNewSecDescRel))
            {
                assert(FALSE);
                THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_SECURITY_DESCR, TEXT("CreateSecDescWithModifiedDacl"));
            }

            *ppNewSecDesc = pNewSecDescRel;
        }
        else
        {
            if (!IsValidSecurityDescriptor(pNewSecDescAbs))
            {
                assert(FALSE);
                THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_SECURITY_DESCR, TEXT("CreateSecDescWithModifiedDacl"));
            }

            *ppNewSecDesc = pNewSecDescAbs;
        }
    }

    catch(Win32Err& e)
    {
        dwEC = e.error();
    }

    // CleanUp

    if (pDaclTmp && LocalFree(pDaclTmp) != NULL)
    {
        // Report clean up error
    }
    
    if (
        (dwEC != ERROR_SUCCESS || pNewDacl != pDaclAfterReset)      &&
        (pDaclAfterReset && LocalFree(pDaclAfterReset) != NULL)
        )
    {
        // Report clean up error
    }

    if (
        (dwEC != ERROR_SUCCESS || pNewDacl != pDaclWithNewInfo)      &&
        (pDaclWithNewInfo && LocalFree(pDaclWithNewInfo) != NULL)
        )
    {
        // Report clean up error
    }

    if (
        (dwEC != ERROR_SUCCESS || bSelfRelative)                     &&
        (pNewSecDescAbs && !FreeSecDesc(pNewSecDescAbs))
        )
    {
        // Report clean up error
    }

    if (
        (dwEC != ERROR_SUCCESS)                                      && 
        (pNewSecDescRel && !FreeSecDesc(pNewSecDescRel))
        )
    {
        // Report clean up error
    }

    if (dwEC != ERROR_SUCCESS)
    {
        SetLastError(dwEC);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\general\log\loggerclasses\cscopetracer.cpp ===
#include <LoggerClasses.h>



//-----------------------------------------------------------------------------------------------------------------------------------------
CScopeTracer::CScopeTracer(CLogger &Logger, DWORD dwLevel, const tstring &tstrScope)
: m_Logger(Logger), m_dwLevel(dwLevel), m_tstrScope(tstrScope)
{
    m_Logger.Detail(SEV_MSG, m_dwLevel, _T("Enter %s."), m_tstrScope.c_str());
}



//-----------------------------------------------------------------------------------------------------------------------------------------
CScopeTracer::~CScopeTracer()
{
    m_Logger.Detail(SEV_MSG, m_dwLevel, _T("Exit %s."), m_tstrScope.c_str());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\general\log\lgnull\lognull.c ===
//
// this is an implementation of the log.h interface to support ELLE logging.
// you must implicitly link you project to your logger's lib.
// you may use this implementation as a reference for impementing other loggers
//
//named type definition in parentheses
#pragma warning (disable:4115)
//nonstandard extension used : nameless struct/union 
#pragma warning (disable:4201) 
//nonstandard extension used : bit field types other than int
#pragma warning (disable:4214) 
//unreferenced inline function has been removed
#pragma warning (disable:4514) 
//conditional expression is constant
#pragma warning (disable:4127) 

#pragma warning(disable:4786)

#include <windows.h>
#include <log.h>




//
// initialize your logger, or if it is an object, create an instance of it.
//
BOOL __cdecl lgInitializeLogger()
{
	return TRUE;

}



//
// close your logger, or if it is an object, delete it.
//
BOOL __cdecl lgCloseLogger()
{
	return TRUE;
}


BOOL __cdecl lgBeginSuite(LPCTSTR szSuite)
{
    UNREFERENCED_PARAMETER(szSuite);
	return TRUE;
}

BOOL __cdecl lgEndSuite()
{
	return TRUE;
}

BOOL __cdecl lgBeginCase(const DWORD dwCase, LPCTSTR szCase)
{
    UNREFERENCED_PARAMETER(dwCase);
    UNREFERENCED_PARAMETER(szCase);
	return TRUE;
}



BOOL __cdecl lgEndCase()
{
	return TRUE;
}


//
// set the log level.
// 9 is most details, 0 is least.
// return value is not supported.
//
int __cdecl lgSetLogLevel(const int nLogLevel)
{
    UNREFERENCED_PARAMETER(nLogLevel);
	return 0;
}


BOOL __cdecl lgDisableLogging()
{
	return TRUE;
}

BOOL __cdecl lgEnableLogging()
{
	return TRUE;
}

void __cdecl lgLogDetail(const DWORD dwSeverity, const DWORD dwLevel, LPCTSTR szFormat, ...)
{
    UNREFERENCED_PARAMETER(dwSeverity);
    UNREFERENCED_PARAMETER(dwLevel);
    UNREFERENCED_PARAMETER(szFormat);
	return;
}

void __cdecl lgLogError(const DWORD dwSeverity, LPCTSTR szFormat, ...)
{
    UNREFERENCED_PARAMETER(dwSeverity);
    UNREFERENCED_PARAMETER(szFormat);
	return;
}

BOOL __cdecl lgSetLogServer(LPCTSTR szLogServer)
{
    UNREFERENCED_PARAMETER(szLogServer);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\general\log\loggerclasses\clogger.cpp ===
#include <LoggerClasses.h>
#include <testruntimeerr.h>



#define DETAIL_BUFFER_SIZE 1024



//-----------------------------------------------------------------------------------------------------------------------------------------
CLogger::CLogger()
: m_bLoggerInitialized(false)
{
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CLogger::OpenLogger()
{
    CS CriticalSectionLock(m_CriticalSection);
    OpenLogger_Internal();
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CLogger::CloseLogger()
{
    CS CriticalSectionLock(m_CriticalSection);
    CloseLogger_Internal();
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CLogger::BeginSuite(const tstring &tstrSuiteName)
{
    CS CriticalSectionLock(m_CriticalSection);
    OpenLogger();
    BeginSuite_Internal(tstrSuiteName);
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CLogger::EndSuite()
{
    CS CriticalSectionLock(m_CriticalSection);
    ValidateInitialization();
    EndSuite_Internal();
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CLogger::BeginCase(int iCaseCounter, const tstring &tstrCaseName)
{
    CS CriticalSectionLock(m_CriticalSection);
    ValidateInitialization();
    BeginCase_Internal(iCaseCounter, tstrCaseName);
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CLogger::EndCase()
{
    CS CriticalSectionLock(m_CriticalSection);

    ValidateInitialization();
    EndCase_Internal();
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CLogger::Detail(ENUM_SEV Severity, DWORD dwLevel, LPCTSTR lpctstrFormat, ...)
{
    CS CriticalSectionLock(m_CriticalSection);

    OpenLogger();

    TCHAR tszBuffer[DETAIL_BUFFER_SIZE];

    // Insert thread ID.
    int iThreadIDStringLength = _stprintf(tszBuffer, _T("[0x%04x] "), GetCurrentThreadId());

    va_list args;
	va_start(args, lpctstrFormat);

    int iFreeBufferSpace = DETAIL_BUFFER_SIZE - iThreadIDStringLength;

    int iCharactersWritten = _vsntprintf(
                                         tszBuffer + iThreadIDStringLength,
                                         iFreeBufferSpace,
                                         lpctstrFormat,
                                         args);

    if (iCharactersWritten < 0 || iCharactersWritten == iFreeBufferSpace)
    {
        // Should append terminating null character.

        tszBuffer[DETAIL_BUFFER_SIZE - 1] = _T('\0');
    }

    Detail_Internal(Severity, dwLevel, tszBuffer);

    va_end(args);
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CLogger::IsInitialized() const
{
    return m_bLoggerInitialized;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CLogger::SetInitialized(bool bInitialized)
{
    m_bLoggerInitialized = bInitialized;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CLogger::ValidateInitialization() const
{
    if (!IsInitialized())
    {
        THROW_TEST_RUN_TIME_WIN32(ERROR_CAN_NOT_COMPLETE, _T("Logger must be initialized."));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\general\log\loggerclasses\cellelogger.cpp ===
#include <LoggerClasses.h>
#include <testruntimeerr.h>
#include <crtdbg.h>



#ifdef UNICODE 
	#define NT // for elle 
#endif
#include <elle.h>



//-----------------------------------------------------------------------------------------------------------------------------------------
CElleLogger::CElleLogger(TCHAR tchDetailsSeparator)
: m_tchDetailsSeparator(tchDetailsSeparator)
{
}
        
        

//-----------------------------------------------------------------------------------------------------------------------------------------
void CElleLogger::OpenLogger_Internal()
{
    if (!IsInitialized() && !::EcInitElle())
    {
        THROW_TEST_RUN_TIME_WIN32(ERROR_CAN_NOT_COMPLETE, _T("EcInitElle."));
    }
    SetInitialized(true);
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CElleLogger::CloseLogger_Internal()
{
    if (IsInitialized() && !::EcDeInitElle())
	{
        THROW_TEST_RUN_TIME_WIN32(ERROR_CAN_NOT_COMPLETE, _T("EcDeInitElle."));
	}
    SetInitialized(false);
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CElleLogger::BeginSuite_Internal(const tstring &tstrSuiteName)
{
    ::UBeginSuite(const_cast<LPTSTR>(tstrSuiteName.c_str()));
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CElleLogger::EndSuite_Internal()
{
    ::EndSuite();
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CElleLogger::BeginCase_Internal(int iCaseCounter, const tstring &tstrCaseName)
{
    ::UBeginCase(iCaseCounter, const_cast<LPTSTR>(tstrCaseName.c_str()));
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CElleLogger::EndCase_Internal()
{
    ::EndCase();
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CElleLogger::Detail_Internal(ENUM_SEV Severity, DWORD dwLevel, LPTSTR lptstrText)
{
    if (m_tchDetailsSeparator)
    {
        //
        // Append details separator.
        //
        ::ULogDetailF(ConvertSeverity(Severity), min(dwLevel, 9), _T("%s%c"), lptstrText, m_tchDetailsSeparator);
    }
    else
    {
        ::ULogDetail(ConvertSeverity(Severity), min(dwLevel, 9), lptstrText);
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
DWORD CElleLogger::ConvertSeverity(ENUM_SEV Severity)
{
    switch (Severity)
    {
    case SEV_MSG:
    case SEV_WRN:
        return L_PASS;

    case SEV_ERR:
        return L_FAIL;

    default:
        _ASSERT(false);
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("Invalid Severity."));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\general\testsuite\testsuite.cpp ===
#include <TestSuite.h>
#include <crtdbg.h>
#include <shellapi.h>
#include <testruntimeerr.h>
#include <stringutils.h>
#include <iniutils.h>
#include <STLAuxiliaryFunctions.h>
#include "CBooleanExpression.h"



//
// Maximal number of nested levels in the tests hierarchy.
//
#define MAX_SUITE_DEEPNESS 64



//
// Inifile string constants - for internal use.
//
#define INI_SECTION_SUITE               _T("Suite")
#define INI_ENTRY_TEST_SUITE            _T("TestSuite")
#define INI_ENTRY_MACROS                _T("Macros")
#define INI_ENTRY_CONTINUE_ON_FAILURE   _T("ContinueOnFailure")
#define INI_ENTRY_CLSID                 _T("CLSID")
#define INI_ENTRY_DESCRIPTION           _T("Description")
#define CLSID_STANDARD_SHELL_EXECUTE    _T("StandardShellExecute")
#define CLSID_STANDARD_DELAY            _T("StandardDelay")
#define CLSID_STANDARD_PAUSE            _T("StandardPause")
#define CLSID_STANDARD_DEBUG_BREAK      _T("StandardDebugBreak")
#define CLSID_STANDARD_TEST_CONTAINER   _T("StandardTestContainer")



//
// "Visual" log strings.
//
#define LOG_MSG_PASSED \
_T("\
\n\
\t***   ***  ***  *** **** ***\n\
\t*  * *  * *    *    *    *  *\n\
\t***  ****  **   **  ***  *  *\n\
\t*    *  *    *    * *    *  *\n\
\t*    *  * ***  ***  **** ***\
")

#define LOG_MSG_FAILED \
_T("\
\n\
\t****  *** *** *    **** ***\n\
\t*    *  *  *  *    *    *  *\n\
\t***  ****  *  *    ***  *  *\n\
\t*    *  *  *  *    *    *  *\n\
\t*    *  * *** **** **** ***\
")



//-----------------------------------------------------------------------------------------------------------------------------------------
CTest::CTest(
                    const tstring &tstrName,
                    const tstring &tstrDescription,
                    CLogger       &Logger,
                    int           iRunsCount,
                    int           iDeepness
                    )
: m_tstrName(tstrName),
  m_tstrDescription(tstrDescription),
  m_Logger(Logger),
  m_iRunsCount(iRunsCount),
  m_iDeepness(iDeepness),
  m_bInitialized(false),
  m_pContainer(NULL)
{
}



//-----------------------------------------------------------------------------------------------------------------------------------------
CTest::~CTest()
{
}


    
//-----------------------------------------------------------------------------------------------------------------------------------------
CLogger &CTest::GetLogger() const
{
    return m_Logger;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
const tstring &CTest::GetName() const
{
    return m_tstrName;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
const tstring &CTest::GetDescription() const
{
    return m_tstrDescription;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
int CTest::GetRunsCount() const
{
    return m_iRunsCount;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
int CTest::GetDeepness() const
{
    return m_iDeepness;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CTest::IsInitialized() const
{
    return m_bInitialized;
}
    


//-----------------------------------------------------------------------------------------------------------------------------------------
const CTestContainer &CTest::GetContainer() const
{
    _ASSERT(m_pContainer);
    return *m_pContainer;
}
    


//-----------------------------------------------------------------------------------------------------------------------------------------
void CTest::BeginLog(int iRun, int iCasesCounter)
{
    UNREFERENCED_PARAMETER(iRun);
    UNREFERENCED_PARAMETER(iCasesCounter);
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CTest::EndLog(bool bPassed, int iRun)
{
    UNREFERENCED_PARAMETER(bPassed);
    UNREFERENCED_PARAMETER(iRun);
}


    
//-----------------------------------------------------------------------------------------------------------------------------------------
void CTest::SetInitialized(bool bInitialized)
{
    m_bInitialized = bInitialized;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CTest::SetContainer(const CTestContainer *pContainer)
{
    m_pContainer = pContainer;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CTest::IsCommonEntry(const tstring &tstrEntry)
{
    return (
            INI_ENTRY_CLSID               == tstrEntry ||
            INI_ENTRY_DESCRIPTION         == tstrEntry ||
            INI_ENTRY_CONTINUE_ON_FAILURE == tstrEntry
            );
}



//-----------------------------------------------------------------------------------------------------------------------------------------
CTestCase::CTestCase(
                     const tstring &tstrName,
                     const tstring &tstrDescription,
                     CLogger       &Logger,
                     int           iRunsCount,
                     int           iDeepness
                     )
: CTest(tstrName, tstrDescription, Logger, iRunsCount, iDeepness)
{
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CTestCase::Init(const CTestContainer *pContainer)
{
    if (IsInitialized())
    {
        //
        // The case is already initialized.
        //
        THROW_TEST_RUN_TIME_WIN32(ERROR_ALREADY_INITIALIZED, _T("Case already initialized"));
    }

    if (!pContainer)
    {
        //
        // The test case must be a part of a container.
        //
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("Invalid pContainer."));
    }

    //
    // Store the pointer to the container.
    //
    SetContainer(pContainer);
    
    //
    // Get params from a container and parse them.
    //
    ParseParams(pContainer->GetParams(GetName()));

    SetInitialized(true);
}
    


//-----------------------------------------------------------------------------------------------------------------------------------------
int CTestCase::GetReportedCasesCountPerRun() const
{
    return 1;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CTestCase::BeginLog(int iRun, int iCasesCounter)
{
    GetLogger().BeginCase(iCasesCounter, GetName());

    //
    // Log description.
    //
    if (GetDescription() != _T(""))
    {
        GetLogger().Detail(SEV_MSG, 0, GetDescription().c_str());
    }

    //
    // Log run number.
    //
    GetLogger().Detail(SEV_MSG, 0, _T("Run %ld of %ld."), iRun, GetRunsCount());
}
    


//-----------------------------------------------------------------------------------------------------------------------------------------
void CTestCase::EndLog(bool bPassed, int iRun)
{
    GetLogger().Detail(
                       bPassed ? SEV_MSG : SEV_ERR,
                       0,
                       _T("Test case %s (run %ld of %ld) %s."),
                       GetName().c_str(),
                       iRun,
                       GetRunsCount(),
                       bPassed ? _T("PASSED") : _T("FAILED")
                       );

    GetLogger().EndCase();
}



//-----------------------------------------------------------------------------------------------------------------------------------------
CNotReportedTestCase::CNotReportedTestCase(
                                                  const tstring &tstrName,
                                                  const tstring &tstrDescription,
                                                  CLogger       &Logger,
                                                  int           iRunsCount,
                                                  int           iDeepness
                                                  )
: CTestCase(tstrName, tstrDescription, Logger, iRunsCount, iDeepness)
{
}



//-----------------------------------------------------------------------------------------------------------------------------------------
int CNotReportedTestCase::GetReportedCasesCountPerRun() const
{
    //
    // We don't want this test case to be reported and counted.
    //
    return 0;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CNotReportedTestCase::BeginLog(int iRun, int iCasesCounter)
{
    UNREFERENCED_PARAMETER(iRun);
    UNREFERENCED_PARAMETER(iCasesCounter);
}
    


//-----------------------------------------------------------------------------------------------------------------------------------------
void CNotReportedTestCase::EndLog(bool bPassed, int iRun)
{
    UNREFERENCED_PARAMETER(bPassed);
    UNREFERENCED_PARAMETER(iRun);
}



//-----------------------------------------------------------------------------------------------------------------------------------------
CShellExecute::CShellExecute(
                             const tstring &tstrName,
                             const tstring &tstrDescription,
                             CLogger       &Logger,
                             int           iRunsCount,
                             int           iDeepness
                             )
: CTestCase(tstrName, tstrDescription, Logger, iRunsCount, iDeepness)
{
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CShellExecute::Run()
{
    SHELLEXECUTEINFO ShellExecInfo = {0};

    ShellExecInfo.cbSize       = sizeof(ShellExecInfo);
    ShellExecInfo.fMask        = SEE_MASK_FLAG_DDEWAIT | SEE_MASK_DOENVSUBST;
    ShellExecInfo.lpVerb       = m_tstrVerb.c_str();
    ShellExecInfo.lpFile       = m_tstrFile.c_str();
    ShellExecInfo.lpParameters = m_tstrParameters.c_str();

    if (!ShellExecuteEx(&ShellExecInfo))
    {
        GetLogger().Detail(
                           m_bResultMatters ? SEV_ERR : SEV_MSG,
                           1,
                           _T("ShellExecuteEx failed with ec=%ld."),
                           GetLastError()
                           );
        //
        // Report failure of the test case only if the user cares.
        //
        return !m_bResultMatters;
    }
    else
    {
        GetLogger().Detail(SEV_MSG, 1, _T("ShellExecuteEx succeded."));
        return true;
    }
}

                             
                             
//-----------------------------------------------------------------------------------------------------------------------------------------
void CShellExecute::ParseParams(const TSTRINGMap &mapParams)
{
    //
    // Read SHELLEXECUTEINFO members - all optional.
    //

    try
    {
        m_tstrVerb = GetValueFromMap(mapParams, _T("Verb"));
    }
    catch (...)
    {
    }

    try
    {
        m_tstrFile = GetValueFromMap(mapParams, _T("File"));
    }
    catch (...)
    {
    }

    try
    {
        m_tstrParameters = GetValueFromMap(mapParams, _T("Parameters"));
    }
    catch (...)
    {
    }

    //
    // Read whether the command result matters. Optional, false if not specified.
    //
    try
    {
        m_bResultMatters = FromString<bool>(GetValueFromMap(mapParams, _T("ResultMatters")));
    }
    catch (...)
    {
        m_bResultMatters = false;
    }
}


//-----------------------------------------------------------------------------------------------------------------------------------------
CDelay::CDelay(
               const tstring &tstrName,
               const tstring &tstrDescription,
               CLogger       &Logger,
               int           iRunsCount,
               int           iDeepness
               )
: CNotReportedTestCase(tstrName, tstrDescription, Logger, iRunsCount, iDeepness)
{
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CDelay::Run()
{
    if (m_dwWaitDuration > 0)
    {
        GetLogger().Detail(SEV_MSG, 0, GetDescription().c_str());
        GetLogger().Detail(SEV_MSG, 0, _T("Sleeping for %ld msec..."), m_dwWaitDuration);
        Sleep(m_dwWaitDuration);
        GetLogger().Detail(SEV_MSG, 0, _T("Waked up."));
    }

    return true;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CDelay::ParseParams(const TSTRINGMap &mapParams)
{
    m_dwWaitDuration = FromString<DWORD>(GetValueFromMap(mapParams, _T("Duration")));
}



//-----------------------------------------------------------------------------------------------------------------------------------------
CPause::CPause(
                      const tstring &tstrName,
                      const tstring &tstrDescription,
                      CLogger       &Logger,
                      int           iRunsCount,
                      int           iDeepness
                      )
: CNotReportedTestCase(tstrName, tstrDescription, Logger, iRunsCount, iDeepness)
{
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CPause::Run()
{
    MessageBox(
               NULL,
               _T("The test is paused. Press Ok to continue."),
               GetContainer().GetName().c_str(),
               MB_OK | MB_TASKMODAL | MB_SETFOREGROUND
               );

    return true;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CPause::ParseParams(const TSTRINGMap &mapParams)
{
    UNREFERENCED_PARAMETER(mapParams);
}



//-----------------------------------------------------------------------------------------------------------------------------------------
CDebugBreak::CDebugBreak(
                                const tstring &tstrName,
                                const tstring &tstrDescription,
                                CLogger       &Logger,
                                int           iRunsCount,
                                int           iDeepness
                                )
: CNotReportedTestCase(tstrName, tstrDescription, Logger, iRunsCount, iDeepness)
{
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CDebugBreak::Run()
{
    DebugBreak();
    return true;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CDebugBreak::ParseParams(const TSTRINGMap &mapParams)
{
    UNREFERENCED_PARAMETER(mapParams);
}



//-----------------------------------------------------------------------------------------------------------------------------------------
CTestContainer::CTestContainer(
                                      const tstring &tstrName,
                                      const tstring &tstrDescription,
                                      CLogger       &Logger,
                                      int           iRunsCount,
                                      int           iDeepness
                                      )
: CTest(tstrName, tstrDescription, Logger, iRunsCount, iDeepness)
{
    //
    // All members are initialized in Init() method.
    //
}



//-----------------------------------------------------------------------------------------------------------------------------------------
CTestContainer::~CTestContainer()
{
    for (std::vector<CTest *>::iterator itTestsIterator = m_vecTests.begin();
         itTestsIterator != m_vecTests.end();
         ++itTestsIterator
         )
    {
        delete *itTestsIterator;
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
const tstring &CTestContainer::GetIniFile() const
{
    return m_tstrIniFile;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CTestContainer::Init(const CTestContainer *pContainer)
{
    if (!pContainer)
    {
        //
        // Container must be specified.
        //
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_PARAMETER, _T("Invalid pContainer."));
    }

    //
    // Store the pointer to the container.
    //
    SetContainer(pContainer);
    
    Init(
         pContainer->GetOrderedParams(GetName()), 
         pContainer->GetIniFile(),
         pContainer->GetFactoryMap(),
         pContainer->GetMacrosMap(),
         pContainer->GetContinueOnFailure()
         );
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CTestContainer::Init(
                          const std::vector<TSTRINGPair> &vecParams,
                          const tstring                  &tstrIniFile,
                          const TEST_FACTORY_MAP         &mapFactoryMap,
                          const TSTRINGMap               &mapMacrosMap,
                          bool                           bContinueOnFailure
                          )
{
    if (IsInitialized())
    {
        //
        // The container is already initialized.
        //
        THROW_TEST_RUN_TIME_WIN32(ERROR_ALREADY_INITIALIZED, _T("Container already initialized"));
    }

    _ASSERT(m_vecTests.empty());
    
    //
    // Set the container data.
    //
    m_tstrIniFile        = tstrIniFile;
    m_pFactoryMap        = &mapFactoryMap;
    m_pMacrosMap         = &mapMacrosMap;
    m_bContinueOnFailure = bContinueOnFailure;

    //
    // Initialize the contained test cases count.
    //
    m_iReportedCasesCountPerRun = 0;
    
    //
    // Create the indentation string - one tab character for each level of deepness.
    // The deepness of a test suite is supposed never to exceed MAX_SUITE_DEEPNESS.
    //
    TCHAR tszIndentation[MAX_SUITE_DEEPNESS + 1];
    _ASSERT(GetDeepness() <= MAX_SUITE_DEEPNESS);
    for (int i = 0; i < GetDeepness(); ++i)
    {
        tszIndentation[i] = _T('\t');
    }
    tszIndentation[i] = _T('\0');

    //
    // Create, initialize and add all contained tests.
    //
    for (std::vector<TSTRINGPair>::const_iterator citParamsIterator = vecParams.begin();
         citParamsIterator != vecParams.end();
         ++citParamsIterator
         )
    {
        _ASSERT(!CTest::IsCommonEntry(citParamsIterator->first));

        //
        // Read number of test runs.
        //
        int iRunsCount = 1;
        if (citParamsIterator->second != _T(""))
        {
            try
            {
                iRunsCount = FromString<int>(citParamsIterator->second);
            }
            catch (...)
            {
                //
                // The value cannot be interpreted as an integer. Let's see whether it is a flag.
                //

                CBooleanExpression BooleanExpression(citParamsIterator->second);

                iRunsCount = BooleanExpression.Value(mapMacrosMap) ? 1 : 0;
            }
        }

        //
        // Skip tests with 0 runs.
        //
        if (iRunsCount == 0)
        {
            continue;
        }

        //
        // Create contained test.
        //

        CTest *pNewTest = NULL;
        try
        {
            GetLogger().Detail(
                               SEV_MSG,
                               5,
                               _T("%sCreate, initialize and add test %s..."),
                               tszIndentation,
                               citParamsIterator->first.c_str()
                               );

            //
            // Read class ID.
            //
            tstring tstrCLSID = GetValueFromMap(GetCommonEntries(citParamsIterator->first), INI_ENTRY_CLSID);

            //
            // Read description - optional.
            //
            tstring tstrDescription;
            try
            {
                tstrDescription = GetValueFromMap(GetCommonEntries(citParamsIterator->first), INI_ENTRY_DESCRIPTION);
            }
            catch (...)
            {
            }

            //
            // Create an instance.
            //

            //
            // Look for the class factory.
            //
            TEST_FACTORY_MAP_CONST_ITERATOR citFactoryMapIterator = mapFactoryMap.find(tstrCLSID);
            if (citFactoryMapIterator == mapFactoryMap.end())
            {
                GetLogger().Detail(SEV_ERR, 0, _T("%sUnknown CLSID: %s."), tszIndentation, tstrCLSID.c_str());
                THROW_TEST_RUN_TIME_WIN32(ERROR_NOT_FOUND, _T("Unknown CLSID"));
            }

            //
            // Create instance of the class with specified class ID.
            //
            pNewTest = citFactoryMapIterator->second->CreateTest(
                                                                 citParamsIterator->first,
                                                                 tstrDescription,
                                                                 GetLogger(),
                                                                 iRunsCount,
                                                                 GetDeepness() + 1
                                                                 );
            _ASSERT(pNewTest);

            //
            // Read whether the new test should continue on failure.
            // This parameter is inhereted from the container and may be overridden.
            //
            try
            {
                m_bCurrentTestContinueOnFailure = FromString<bool>(GetValueFromMap(
                                                                                   GetCommonEntries(citParamsIterator->first),
                                                                                   INI_ENTRY_CONTINUE_ON_FAILURE
                                                                                   ));
            }
            catch (...)
            {
                m_bCurrentTestContinueOnFailure = bContinueOnFailure;
            }

            //
            // Initialize the instance.
            //
            pNewTest->Init(this);
            
            //
            // Add the initialized test to the container.
            //
            m_vecTests.push_back(pNewTest);
            
            GetLogger().Detail(
                               SEV_MSG,
                               5,
                               _T("%sTest %s created, initialized and added to container %s."),
                               tszIndentation,
                               citParamsIterator->first.c_str(),
                               GetName().c_str()
                               );

            //
            // Update number of contained test cases.
            //
            m_iReportedCasesCountPerRun += pNewTest->GetReportedCasesCountPerRun() * pNewTest->GetRunsCount();
        }
        catch(Win32Err &e)
        {
            //
            // Failed to read needed information, to create, to initialize or to add an instance of the class.
            //
            GetLogger().Detail(
                               SEV_ERR,
                               0,
                               _T("%sFailed to create test %s - %s."),
                               tszIndentation,
                               citParamsIterator->first.c_str(),
                               e.description()
                               );

            delete pNewTest;
            throw;
        }
    }

    //
    // The factories map and the flags map will not be used after leaving this function.
    // Thus, the pointers are not required to be valid.
    //
    m_pFactoryMap = NULL;
    m_pMacrosMap  = NULL;
    
    SetInitialized(true);
}



//-----------------------------------------------------------------------------------------------------------------------------------------
int CTestContainer::GetReportedCasesCountPerRun() const
{
    return m_iReportedCasesCountPerRun;
}


    
//-----------------------------------------------------------------------------------------------------------------------------------------
bool CTestContainer::Run()
{

    if (!IsInitialized())
    {
        GetLogger().Detail(
                           SEV_ERR,
                           0,
                           _T("Attempt to run uninitialized container %s"),
                           GetName().c_str()
                           );

        THROW_TEST_RUN_TIME_WIN32(ERROR_CAN_NOT_COMPLETE, _T("Container uninitialized"));
    }
    
    bool bAllTestsInContainerPassed = true;

    //
    // Run all tests in the container.
    //
    for (std::vector<CTest *>::const_iterator citTestsIterator = m_vecTests.begin();
         citTestsIterator != m_vecTests.end();
         ++citTestsIterator
         )
    {
        int iRunsCount = (*citTestsIterator)->GetRunsCount();

        for (int iRunInd = 1; iRunInd <= iRunsCount; ++iRunInd)
        {
            bool bTestPassed = false;

            //
            // Begin the current contained test log.
            //
            (*citTestsIterator)->BeginLog(iRunInd, m_iBaseCasesCounter);

            //
            // Update the container base cases counter.
            //
            m_iBaseCasesCounter += (*citTestsIterator)->GetReportedCasesCountPerRun();

            try
            {
                bTestPassed = (*citTestsIterator)->Run();
            }
            catch(Win32Err &e)
            {
                GetLogger().Detail(
                                   SEV_ERR,
                                   0,
                                   _T("Internal error in test %s, run %ld: ec=%ld"),
                                   (*citTestsIterator)->GetName().c_str(),
                                   iRunInd,
                                   e.error()
                                   );

                //
                // Don't propagate the internal error to the caller.
                //
            }

            bAllTestsInContainerPassed = bAllTestsInContainerPassed && bTestPassed;
            (*citTestsIterator)->EndLog(bTestPassed, iRunInd);

            if (!bTestPassed)
            {
                if (iRunInd < iRunsCount || citTestsIterator + 1 != m_vecTests.end())
                {
                    //
                    // The test failed and there are more tests in the container.
                    // Proceed or terminate the rest of the container, according to m_bContinueOnFailure.
                    //
                    if (m_bContinueOnFailure)
                    {
                        GetLogger().Detail(SEV_MSG, 0, _T("Proceed with execution of the container %s."), GetName().c_str());
                    }
                    else
                    {
                        GetLogger().Detail(SEV_ERR, 0, _T("Terminate execution of the container %s."), GetName().c_str());
                        THROW_TEST_RUN_TIME_WIN32(ERROR_CAN_NOT_COMPLETE, _T("Container termination forced"));
                    }
                }
            }
        }
    }

    return bAllTestsInContainerPassed;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
const TSTRINGMap &CTestContainer::GetParams(const tstring &tstrTestName) const
{
    if (m_tstrCurrentTestSection != tstrTestName)
    {
        m_tstrCurrentTestSection = tstrTestName;
        ReadCurrentTestSection();
    }
    return m_mapCurrentTestParamsMap;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
const std::vector<TSTRINGPair> &CTestContainer::GetOrderedParams(const tstring &tstrTestName) const
{
    if (m_tstrCurrentTestSection != tstrTestName)
    {
        m_tstrCurrentTestSection = tstrTestName;
        ReadCurrentTestSection();
    }
    return m_vecCurrentTestParamsVector;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
const TSTRINGMap &CTestContainer::GetCommonEntries(const tstring &tstrTestName) const
{
    if (m_tstrCurrentTestSection != tstrTestName)
    {
        m_tstrCurrentTestSection = tstrTestName;
        ReadCurrentTestSection();
    }
    return m_mapCurrentTestCommonEntriesMap;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CTestContainer::ReadCurrentTestSection() const
{
    m_mapCurrentTestParamsMap.clear();
    m_vecCurrentTestParamsVector.clear();
    m_mapCurrentTestCommonEntriesMap.clear();

    //
    // Read the section from inifile into vector.
    //
    m_vecCurrentTestParamsVector = INI_GetOrderedSectionEntries(m_tstrIniFile, m_tstrCurrentTestSection, FALSE, FALSE);

    //
    // Do macros substitution and move common entries to a separate map.
    //
    std::vector<TSTRINGPair>::iterator itParamsIterator = m_vecCurrentTestParamsVector.begin();
    while(itParamsIterator != m_vecCurrentTestParamsVector.end())
    {
        //
        // Try macro replacement for the value.
        //
        try
        {
            itParamsIterator->second = GetValueFromMap(GetMacrosMap(), itParamsIterator->second);
        }
        catch (...)
        {
        }

        if (CTest::IsCommonEntry(itParamsIterator->first))
        {
            //
            // Move the entry to the common entries map.
            //
            m_mapCurrentTestCommonEntriesMap.insert(*itParamsIterator);
            itParamsIterator = m_vecCurrentTestParamsVector.erase(itParamsIterator);
        }
        else
        {
            //
            // Try macro replacement for the key.
            //
            try
            {
                itParamsIterator->first = GetValueFromMap(GetMacrosMap(), itParamsIterator->first);
            }
            catch (...)
            {
            }
            ++itParamsIterator;
        }
    }

    //
    // Copy entries from the vector to the map.
    //
    for (std::vector<TSTRINGPair>::const_iterator citParamsIterator = m_vecCurrentTestParamsVector.begin();
         citParamsIterator != m_vecCurrentTestParamsVector.end();
         ++citParamsIterator
         )
    {
        m_mapCurrentTestParamsMap.insert(*citParamsIterator);
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
const TEST_FACTORY_MAP &CTestContainer::GetFactoryMap() const
{
    _ASSERT(m_pFactoryMap);
    return *m_pFactoryMap;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
const TSTRINGMap &CTestContainer::GetMacrosMap() const
{
    _ASSERT(m_pMacrosMap);
    return *m_pMacrosMap;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CTestContainer::GetContinueOnFailure() const
{
    return m_bCurrentTestContinueOnFailure;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CTestContainer::BeginLog(int iRun, int iCasesCounter)
{
    UNREFERENCED_PARAMETER(iRun);
    m_iBaseCasesCounter = iCasesCounter;
}
    


//-----------------------------------------------------------------------------------------------------------------------------------------
CTestSuite::CTestSuite(
                              const tstring &tstrName,
                              const tstring &tstrDescription,
                              CLogger       &Logger
                              )
: CTestContainer(tstrName, tstrDescription, Logger, 1, 0)
{
    //
    // Cause operator new to throw exceptions.
    //
    m_OldNewHandler = _set_new_handler(CTestSuite::OperatorNewFailureHandler);
}



//-----------------------------------------------------------------------------------------------------------------------------------------
CTestSuite::~CTestSuite()
{
    //
    // Restore the operator failures handler.
    //
    _set_new_handler(m_OldNewHandler);
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CTestSuite::Do(const tstring &tstrIniFile, const TEST_FACTORY_MAP &mapFactoryMap)
{
    // Begin the suite log.
    BeginLog(1, 1);
    
    bool bPassed = false;

    try
    {
        //
        // Read suite definition section from inifile.
        //
        TSTRINGMap mapSuiteDefinition = INI_GetSectionEntries(tstrIniFile, INI_SECTION_SUITE, FALSE, FALSE);

        if (mapSuiteDefinition.empty())
        {
            GetLogger().Detail(
                               SEV_ERR,
                               0,
                               _T("Either the file %s doesn't exist or doesn't have [%s] section."),
                               tstrIniFile,
                               INI_SECTION_SUITE
                               );

            THROW_TEST_RUN_TIME_WIN32(ERROR_NOT_FOUND, _T("File or section no found."));
        }

        //
        // Read the mandatory sections names.
        //
        tstring tstrSuite          = GetValueFromMap(mapSuiteDefinition, INI_ENTRY_TEST_SUITE);
        bool    bContinueOnFailure = FromString<bool>(GetValueFromMap(mapSuiteDefinition, INI_ENTRY_CONTINUE_ON_FAILURE));


        //
        // Read macros section - optional.
        //
        TSTRINGMap mapMacros;
        try
        {
            tstring tstrMacros = GetValueFromMap(mapSuiteDefinition, INI_ENTRY_MACROS);
            mapMacros = INI_GetSectionEntries(tstrIniFile, tstrMacros, FALSE, FALSE);
        }
        catch(...)
        {
        }

        //
        // Create a copy of the user test factories map and add standard factories.
        //
        
        TEST_FACTORY_MAP mapModifiedFactoryMap(mapFactoryMap);

        CShellExecuteFactory  ShellExecuteFactory;
        CDelayFactory         DelayFactory;
        CPauseFactory         PauseFactory;
        CDebugBreakFactory    DebugBreakFactory;
        CTestContainerFactory TestContainerFactory;

        mapModifiedFactoryMap.insert(TEST_FACTORY_MAP_ENTRY(CLSID_STANDARD_SHELL_EXECUTE,  &ShellExecuteFactory));
        mapModifiedFactoryMap.insert(TEST_FACTORY_MAP_ENTRY(CLSID_STANDARD_DELAY,          &DelayFactory));
        mapModifiedFactoryMap.insert(TEST_FACTORY_MAP_ENTRY(CLSID_STANDARD_PAUSE,          &PauseFactory));
        mapModifiedFactoryMap.insert(TEST_FACTORY_MAP_ENTRY(CLSID_STANDARD_DEBUG_BREAK,    &DebugBreakFactory));
        mapModifiedFactoryMap.insert(TEST_FACTORY_MAP_ENTRY(CLSID_STANDARD_TEST_CONTAINER, &TestContainerFactory));

        //
        // Create all contained tests.
        //
        Init(
             INI_GetOrderedSectionEntries(tstrIniFile, tstrSuite, FALSE, FALSE),
             tstrIniFile,
             mapModifiedFactoryMap,
             mapMacros,
             bContinueOnFailure
             );

        //
        // Log test cases count.
        //
        GetLogger().Detail(SEV_MSG, 0, _T("The suite contains %ld test cases (including repetitions)."), GetReportedCasesCountPerRun());

        bPassed = Run();
    }
    catch(Win32Err &e)
	{
        GetLogger().Detail(SEV_MSG, 0, _T("%s\n"), e.description());
	}

    GetLogger().Detail(SEV_MSG, 0, bPassed ? LOG_MSG_PASSED : LOG_MSG_FAILED);

    //
    // End the suite log.
    //
    EndLog(bPassed, 1);

    return bPassed;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CTestSuite::BeginLog(int iRun, int iCasesCounter)
{
    CTestContainer::BeginLog(iRun, iCasesCounter);
    
    GetLogger().BeginSuite(GetName());

    //
    // Log description.
    //
    if (GetDescription() != _T(""))
    {
        GetLogger().Detail(SEV_MSG, 0, GetDescription().c_str());
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CTestSuite::EndLog(bool bPassed, int iRun)
{
    GetLogger().EndSuite();
}



//-----------------------------------------------------------------------------------------------------------------------------------------
int __cdecl CTestSuite::OperatorNewFailureHandler(size_t size)
{
    THROW_TEST_RUN_TIME_WIN32(ERROR_NOT_ENOUGH_MEMORY, _T("new"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\corruptimage\corruptdll.h ===
// CorruptDLL.h: interface for the CCorruptDLL class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CORRUPTDLL_H__C470EDEB_7C79_4B3C_B1F5_190F57609DBE__INCLUDED_)
#define AFX_CORRUPTDLL_H__C470EDEB_7C79_4B3C_B1F5_190F57609DBE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "CorruptImageBase.h"


class CCorruptDLL : public CCorruptImageBase  
{
public:
	CCorruptDLL();
	virtual ~CCorruptDLL();

protected:
	virtual bool CorruptOriginalImageBuffer(PVOID pCorruptionData);
	virtual HANDLE LoadImage(TCHAR *szImageName, TCHAR *szParams);

	void CleanupCorrupedImages();

};

#endif // !defined(AFX_CORRUPTDLL_H__C470EDEB_7C79_4B3C_B1F5_190F57609DBE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\cnulldbg\main.cpp ===
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
#include <time.h>

void IgnoreQueuedDebugEventsForAllProcesses(DWORD dwTimeout);
bool SimpleCreateProcess(TCHAR *szExeAndParams, HANDLE *phProcess);

long g_fTerminateDebuggedProcessAndExit = FALSE;
long g_fExitWithoutTerminatingDebuggedProcess = FALSE;

BOOL WINAPI Handler_Routine(DWORD dwCtrlType)
{
	switch(dwCtrlType)
	{
	case CTRL_C_EVENT:
		g_fTerminateDebuggedProcessAndExit = TRUE;
		break;

	case CTRL_BREAK_EVENT:
		g_fExitWithoutTerminatingDebuggedProcess = TRUE;
		break;

	default:
		g_fTerminateDebuggedProcessAndExit = TRUE;
	}
	_tprintf(TEXT(">>>Handler_Routine() Entered\n"));

	_tprintf(TEXT(">>>Handler_Routine(): before TerminateProcess().\n"));
	fflush(stdout);
	::TerminateProcess(::GetCurrentProcess(), -1);
	_ASSERTE(FALSE);
	return true;
}


int main(int argc, char *szArgvA[])
{
	TCHAR **szArgv = NULL;

#ifdef UNICODE
	szArgv = CommandLineToArgvW( GetCommandLine(), &argc );
	if (NULL == szArgv)
	{
		_tprintf(TEXT("CommandLineToArgvW() failed with %d\n"), ::GetLastError());
		return -1;
	}
#else
	szArgv = szArgvA;
#endif

	if (argc < 2)
	{
		_tprintf(TEXT("Usage: %s <command line>\n"), szArgv[0]);
		_tprintf(TEXT("Example: %s where.exe /r c:\\ *.dll\n"), szArgv[0]);
		return -1;
	}

	TCHAR *szCommandLine = ::GetCommandLine();
	_tprintf(TEXT("1 - szCommandLine=%s\n"), szCommandLine);
	szCommandLine = _tcstok(szCommandLine, TEXT(" \t"));
	szCommandLine += lstrlen(szCommandLine)+1;
	_tprintf(TEXT("2 - szCommandLine=%s\n"), szCommandLine);
	_ASSERTE(szCommandLine);
	_ASSERTE(szCommandLine[0]);

    if (! ::SetConsoleCtrlHandler(
			  Handler_Routine,  // address of handler function
			  true                          // handler to add or remove
			  ))
	{
		_tprintf(TEXT("SetConsoleCtrlHandler() failed with %d.\n"),GetLastError());
		exit(1);
	}

	::SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    srand(time( NULL ));

	HANDLE hProcess = NULL;
	if (!SimpleCreateProcess(szCommandLine, &hProcess))
	{
		exit(1);
	}
	_ASSERTE(hProcess);

	DWORD dwWaitOnProcessResult = WAIT_OBJECT_0;
	for (;;)
	{
		IgnoreQueuedDebugEventsForAllProcesses(1000);
		dwWaitOnProcessResult = ::WaitForSingleObject(hProcess, 1000);
		if (WAIT_OBJECT_0 == dwWaitOnProcessResult)
		{
			//
			// the process terminated, we're done
			//
			break;
		}

		if (g_fTerminateDebuggedProcessAndExit)
		{
			_tprintf(TEXT("Before TerminateProcess(%s).\n"), szCommandLine);
			fflush(stdout);
			::TerminateProcess(hProcess, -1);
			break;
		}

		if (g_fExitWithoutTerminatingDebuggedProcess)
		{
			_tprintf(TEXT("Exiting without Terminating Process (%s).\n"), szCommandLine);
			fflush(stdout);
			break;
		}
	}//for (;;)


	return 0;
}



void IgnoreQueuedDebugEventsForAllProcesses(DWORD dwTimeout)
{
	DEBUG_EVENT debugEvent;
	DWORD dwContinueStatus;
	for(;;)
	{
		if ( ::WaitForDebugEvent(
				&debugEvent,  // pointer to debug event structure
				dwTimeout         // milliseconds to wait for event
				))
		{
			///*
			_tprintf(TEXT("WaitForDebugEvent():\n"));
			_tprintf(TEXT("    dwProcessId  = %d = 0x%08X, "),debugEvent.dwProcessId , debugEvent.dwProcessId );
			_tprintf(TEXT("dwThreadId   = %d = 0x%08X, "),debugEvent.dwThreadId  , debugEvent.dwThreadId  );
			dwContinueStatus = DBG_CONTINUE;
			switch(debugEvent.dwDebugEventCode )
			{
			case EXCEPTION_DEBUG_EVENT:
				_tprintf(TEXT("EXCEPTION_DEBUG_EVENT"));
				//
				// i want to ignore break points, and 1st chance exceptions
				//
				if (!debugEvent.u.Exception.dwFirstChance)
				{
					_tprintf(TEXT("2nd chance !!!"));
					dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED;
				}
				/*
				if (STATUS_BREAKPOINT != debugEvent.Exception.ExceptionRecord.ExceptionCode)
				{

				}
				*/
				break;

			case CREATE_THREAD_DEBUG_EVENT:
				_tprintf(TEXT("CREATE_THREAD_DEBUG_EVENT"));
				break;

			case CREATE_PROCESS_DEBUG_EVENT:
				_tprintf(TEXT("CREATE_PROCESS_DEBUG_EVENT"));
				break;

			case EXIT_THREAD_DEBUG_EVENT:
				_tprintf(TEXT("EXIT_THREAD_DEBUG_EVENT"));
				break;

			case EXIT_PROCESS_DEBUG_EVENT:
				_tprintf(TEXT("EXIT_PROCESS_DEBUG_EVENT"));
				break;

			case LOAD_DLL_DEBUG_EVENT:
				_tprintf(TEXT("LOAD_DLL_DEBUG_EVENT"));
				break;

			case UNLOAD_DLL_DEBUG_EVENT:
				_tprintf(TEXT("UNLOAD_DLL_DEBUG_EVENT"));
				break;

			case OUTPUT_DEBUG_STRING_EVENT:
				_tprintf(TEXT("OUTPUT_DEBUG_STRING_EVENT"));
				break;

			case RIP_EVENT:
				_tprintf(TEXT("RIP_EVENT"));
				break;

			default:
				_ASSERTE(FALSE);
			}
			_tprintf(TEXT("\n"));
			//*/
			if (! ::ContinueDebugEvent(
					debugEvent.dwProcessId,       // process to continue
					debugEvent.dwThreadId,        // thread to continue
					dwContinueStatus     // continuation status
					))
			{
				_tprintf(TEXT("ContinueDebugEvent() failed with %d:\n"), ::GetLastError());
			}
		}
		else
		{
			DWORD dwError = ::GetLastError();
			if (ERROR_SEM_TIMEOUT != dwError)
			{
				_tprintf(TEXT("WaitForDebugEvent() failed with %d:\n"), dwError);
			}

			//
			// there are no more debug events, return
			//
			return;
		}
	}
}


bool SimpleCreateProcess(TCHAR *szExeAndParams, HANDLE *phProcess)
{
	_ASSERTE(szExeAndParams);
	_ASSERTE(phProcess);
	_ASSERTE(NULL == *phProcess);

    STARTUPINFO si;
    PROCESS_INFORMATION pi;

	//
	// fill STARTUPINFO
	//
    si.cb = sizeof(STARTUPINFO); 
    si.lpReserved = NULL; 
    si.lpDesktop = NULL;//TEXT(""); 
    si.lpTitle = TEXT("TITLE"); 
    //si.dwX; 
    //si.dwY; 
    //si.dwXSize; 
    //si.dwYSize; 
    //si.dwXCountChars; 
    //si.dwYCountChars; 
    //si.dwFillAttribute; 
    si.dwFlags = 0; 
    //si.wShowWindow; 
    si.cbReserved2 = 0; 
    si.lpReserved2 = NULL; 
    //si.hStdInput; 
    //si.hStdOutput; 
    //si.hStdError; 

	//
	// create the process
	//
    if (! ::CreateProcess(
        NULL,
        szExeAndParams,	// pointer to command line string
        NULL,	// pointer to process security attributes 
        NULL,	// pointer to thread security attributes 
        FALSE,	// handle inheritance flag 
        DEBUG_PROCESS /* | CREATE_NEW_CONSOLE | CREATE_SHARED_WOW_VDM */,	// creation flags 
        NULL,	// pointer to new environment block 
        NULL,	// pointer to current directory name 
        &si,	// pointer to STARTUPINFO 
        &pi 	// pointer to PROCESS_INFORMATION  
       ))
    {
        _tprintf(  
            TEXT("CreateProcess(%s) failed with %d.\n"), 
            szExeAndParams, GetLastError()
            );
        return false;
    }

	//
	// if the process is a corrupted image, then it will not have a main thread!
	//
	if (NULL == pi.hThread)
	{
		//
		// seems like a bug, but it happens that the main thread is NULL, probably related
		// to the fact that the image is bad.
		// in this case, we close the Process handle, and fail
		//
		::SetLastError(ERROR_BAD_FORMAT);
		_tprintf(  
			TEXT("CreateProcess(%s): (NULL == pi.hThread) probably corrupted image.\n"), szExeAndParams
			);
		if (!CloseHandle(pi.hProcess))
		{
			_tprintf(  
				TEXT("(NULL == pi.hThread), CloseHandle(pi.hProcess) failed with %d.\n"), 
				szExeAndParams, 
				GetLastError()
				);
		}
		return false;
	}

	if(!CloseHandle(pi.hThread))
	{
		_tprintf(  
			TEXT("CloseHandle(pi.hThread) failed with %d.\n"), 
			szExeAndParams, GetLastError()
			);
	}
	
	_ASSERTE(NULL != pi.hProcess);
	*phProcess = pi.hProcess;
	/*
    _tprintf(  
        TEXT("SimpleCreateProcess(%s): succeeded.\n"),
		szExeAndParams
        );
	*/
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\general\testsuite\cbooleanexpression.h ===
#ifndef __C_BOOLEAN_EXPRESSION_H__
#define __C_BOOLEAN_EXPRESSION_H__



/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    This file contains definition of CBooleanExpression class, which allows to evaluate boolean expressions.

    Author: Yury Berezansky (YuryB)

    18-June-2001

    The class is implemented using the predictive parsing method with the following grammar:

    expr -> term moreterms

    moreterms -> || term moreterms
               | empty

    term -> factor morefactors

    morefactors -> && factor morefactors
                 | empty

    factor -> !expr
            | (expr)
            | identifier


    The identifier token is defined by the following regular expression: <[a-b|A-B|_][a-b|A-B|_|0-9]*>

-----------------------------------------------------------------------------------------------------------------------------------------*/



#pragma warning(disable :4786)
#include <map>
#include <tstring.h>
#include <iniutils.h>



typedef enum {
    TOKEN_LEFT_PARENTHESIS,
    TOKEN_RIGHT_PARENTHESIS,
    TOKEN_NOT,
    TOKEN_AND,
    TOKEN_OR,
    TOKEN_IDENTIFIER,
    TOKEN_NONE,
    TOKENS_ENUM_SIZE
} TOKENS_ENUM;



typedef enum {
    STATE_START,
    STATE_LEFT_PARENTHESIS,
    STATE_RIGHT_PARENTHESIS,
    STATE_NOT,
    STATE_WAITING_FOR_AND,
    STATE_AND,
    STATE_WAITING_FOR_OR,
    STATE_OR,
    STATE_WAITING_FOR_IDENTIFIER,
    STATE_IDENTIFIER,
    STATE_ERROR,
    STATES_ENUM_SIZE
} STATES_ENUM;



typedef enum {
    CHARACTER_CLASS_WHITE_SPACE,
    CHARACTER_CLASS_LEFT_PARENTHESIS,
    CHARACTER_CLASS_RIGHT_PARENTHESIS,
    CHARACTER_CLASS_EXCLAMATION,
    CHARACTER_CLASS_AMPERSAND,
    CHARACTER_CLASS_VERTICAL_BAR,
    CHARACTER_CLASS_LETTER,
    CHARACTER_CLASS_UNDERSCORE,
    CHARACTER_CLASS_DIGIT,
    CHARACTER_CLASS_OTHER,
    CHARACTER_CLASSES_ENUM_SIZE
} CHARACTER_CLASSES_ENUM;



struct StateDescription {
    TOKENS_ENUM AcceptToken;
    bool        bRetract;
};



class CBooleanExpression {
    
public:

    CBooleanExpression(const tstring &tstrParam);
    
    bool Value(const TSTRINGMap &mapFlags);

    bool Value(const tstring &IniFileName, const tstring &SectionName);

private:

    CHARACTER_CLASSES_ENUM GetCharacterClass(TCHAR tch) const;

    bool expr();

    bool term();

    bool factor();

    void match(TOKENS_ENUM Token);

    void NextToken();

    tstring          m_tstrExpression;
    const TSTRINGMap *m_pFlags;
    int              m_iCurrentLexemeStartPosition;
    int              m_iForward;
    TOKENS_ENUM      m_CurrentToken;
    tstring          m_tstrCurrentLexeme;

    static const STATES_ENUM       m_TransitionDiagram[STATES_ENUM_SIZE][CHARACTER_CLASSES_ENUM_SIZE];
    static const StateDescription  m_States[STATES_ENUM_SIZE];
};



#endif // #ifndef __C_BOOLEAN_EXPRESSION_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\util\general\testsuite\cbooleanexpression.cpp ===
#include "CBooleanExpression.h"
#include <crtdbg.h>
#include <testruntimeerr.h>
#include <stringutils.h>



//-----------------------------------------------------------------------------------------------------------------------------------------
const STATES_ENUM CBooleanExpression::m_TransitionDiagram[STATES_ENUM_SIZE][CHARACTER_CLASSES_ENUM_SIZE] =
{
                                         /* CHARACTER_CLASS_WHITE_SPACE | CHARACTER_CLASS_LEFT_PARENTHESIS | CHARACTER_CLASS_RIGHT_PARENTHESIS | CHARACTER_CLASS_EXCLAMATION | CHARACTER_CLASS_AMPERSAND | CHARACTER_CLASS_VERTICAL_BAR |       CHARACTER_CLASS_LETTER |   CHARACTER_CLASS_UNDERSCORE |       CHARACTER_CLASS_DIGIT | CHARACTER_CLASS_OTHER */
    /* STATE_START                  */ {                    STATE_START,            STATE_LEFT_PARENTHESIS,            STATE_RIGHT_PARENTHESIS,                    STATE_NOT,      STATE_WAITING_FOR_AND,          STATE_WAITING_FOR_OR,  STATE_WAITING_FOR_IDENTIFIER,  STATE_WAITING_FOR_IDENTIFIER,                  STATE_ERROR,            STATE_ERROR   },
    /* STATE_LEFT_PARENTHESIS       */ {                    STATE_ERROR,                       STATE_ERROR,                        STATE_ERROR,                  STATE_ERROR,                STATE_ERROR,                   STATE_ERROR,                   STATE_ERROR,                   STATE_ERROR,                  STATE_ERROR,            STATE_ERROR   },
    /* STATE_RIGHT_PARENTHESIS      */ {                    STATE_ERROR,                       STATE_ERROR,                        STATE_ERROR,                  STATE_ERROR,                STATE_ERROR,                   STATE_ERROR,                   STATE_ERROR,                   STATE_ERROR,                  STATE_ERROR,            STATE_ERROR   },
    /* STATE_NOT                    */ {                    STATE_ERROR,                       STATE_ERROR,                        STATE_ERROR,                  STATE_ERROR,                STATE_ERROR,                   STATE_ERROR,                   STATE_ERROR,                   STATE_ERROR,                  STATE_ERROR,            STATE_ERROR   },
    /* STATE_WAITING_FOR_AND        */ {                    STATE_ERROR,                       STATE_ERROR,                        STATE_ERROR,                  STATE_ERROR,                  STATE_AND,                   STATE_ERROR,                   STATE_ERROR,                   STATE_ERROR,                  STATE_ERROR,            STATE_ERROR   },
    /* STATE_AND                    */ {                    STATE_ERROR,                       STATE_ERROR,                        STATE_ERROR,                  STATE_ERROR,                STATE_ERROR,                   STATE_ERROR,                   STATE_ERROR,                   STATE_ERROR,                  STATE_ERROR,            STATE_ERROR   },
    /* STATE_WAITING_FOR_OR         */ {                    STATE_ERROR,                       STATE_ERROR,                        STATE_ERROR,                  STATE_ERROR,                STATE_ERROR,                      STATE_OR,                   STATE_ERROR,                   STATE_ERROR,                  STATE_ERROR,            STATE_ERROR   },
    /* STATE_OR                     */ {                    STATE_ERROR,                       STATE_ERROR,                        STATE_ERROR,                  STATE_ERROR,                STATE_ERROR,                   STATE_ERROR,                   STATE_ERROR,                   STATE_ERROR,                  STATE_ERROR,            STATE_ERROR   },
    /* STATE_WAITING_FOR_IDENTIFIER */ {               STATE_IDENTIFIER,                  STATE_IDENTIFIER,                   STATE_IDENTIFIER,             STATE_IDENTIFIER,           STATE_IDENTIFIER,              STATE_IDENTIFIER,  STATE_WAITING_FOR_IDENTIFIER,  STATE_WAITING_FOR_IDENTIFIER, STATE_WAITING_FOR_IDENTIFIER,       STATE_IDENTIFIER   },
    /* STATE_IDENTIFIER             */ {                    STATE_ERROR,                       STATE_ERROR,                        STATE_ERROR,                  STATE_ERROR,                STATE_ERROR,                   STATE_ERROR,                   STATE_ERROR,                   STATE_ERROR,                  STATE_ERROR,            STATE_ERROR   },
};

const StateDescription CBooleanExpression::m_States[STATES_ENUM_SIZE] = 
{
    /* STATE_START                  */ {TOKEN_NONE,              false},
    /* STATE_LEFT_PARENTHESIS       */ {TOKEN_LEFT_PARENTHESIS,  false},
    /* STATE_RIGHT_PARENTHESIS      */ {TOKEN_RIGHT_PARENTHESIS, false},
    /* STATE_NOT                    */ {TOKEN_NOT,               false},
    /* STATE_WAITING_FOR_AND        */ {TOKEN_NONE,              false},
    /* STATE_AND                    */ {TOKEN_AND,               false},
    /* STATE_WAITING_FOR_OR         */ {TOKEN_NONE,              false},
    /* STATE_OR                     */ {TOKEN_OR,                false},
    /* STATE_WAITING_FOR_IDENTIFIER */ {TOKEN_NONE,              false},
    /* STATE_IDENTIFIER             */ {TOKEN_IDENTIFIER,        true }
};



//-----------------------------------------------------------------------------------------------------------------------------------------
CBooleanExpression::CBooleanExpression(const tstring &tstrParam)
: m_tstrExpression(tstrParam), m_pFlags(NULL), m_iCurrentLexemeStartPosition(0), m_iForward(0), m_CurrentToken(TOKEN_NONE)
{
}
    


//-----------------------------------------------------------------------------------------------------------------------------------------
bool CBooleanExpression::Value(const TSTRINGMap &mapFlags)
{
    m_pFlags = &mapFlags;
    NextToken();
    return expr();
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CBooleanExpression::Value(const tstring &IniFileName, const tstring &SectionName)
{
    return Value(INI_GetSectionEntries(IniFileName, SectionName));
}



//-----------------------------------------------------------------------------------------------------------------------------------------
CHARACTER_CLASSES_ENUM CBooleanExpression::GetCharacterClass(TCHAR tch) const
{
    if (_T(' ') == tch || _T('\t') == tch)
    {
        return CHARACTER_CLASS_WHITE_SPACE;
    }
    if (_T('(') == tch)
    {
        return CHARACTER_CLASS_LEFT_PARENTHESIS;
    }
    else if (_T(')') == tch)
    {
        return CHARACTER_CLASS_RIGHT_PARENTHESIS;
    }
    else if (_T('!') == tch)
    {
        return CHARACTER_CLASS_EXCLAMATION;
    }
    else if (_T('&') == tch)
    {
        return CHARACTER_CLASS_AMPERSAND;
    }
    else if (_T('|') == tch)
    {
        return CHARACTER_CLASS_VERTICAL_BAR;
    }
    else if ((_T('a') <= tch && _T('z') >= tch) || (_T('A') <= tch && _T('Z') >= tch))
    {
        return CHARACTER_CLASS_LETTER;
    }
    else if (_T('_') == tch)
    {
        return CHARACTER_CLASS_UNDERSCORE;
    }
    else if (_T('0') <= tch && _T('9') >= tch)
    {
        return CHARACTER_CLASS_DIGIT;
    }
    else
    {
        return CHARACTER_CLASS_OTHER;
    }
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CBooleanExpression::expr()
{
    bool bValue = term();

    for (;;)
    {
        switch(m_CurrentToken)
        {
        case TOKEN_OR:
            match(TOKEN_OR);
            bValue = term() || bValue;
            break;

        default:
            return bValue;
        }
    }

    _ASSERT(false);
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CBooleanExpression::term()
{
    bool bValue = factor();

    for (;;)
    {
        switch(m_CurrentToken)
        {
        case TOKEN_AND:
            match(TOKEN_AND);
            bValue = factor() && bValue;
            break;

        default:
            return bValue;
        }
    }

    _ASSERT(false);
}



//-----------------------------------------------------------------------------------------------------------------------------------------
bool CBooleanExpression::factor()
{
    bool bValue;

    switch(m_CurrentToken)
    {
    case TOKEN_LEFT_PARENTHESIS:
        match(TOKEN_LEFT_PARENTHESIS);
        bValue = expr();
        match(TOKEN_RIGHT_PARENTHESIS);
        break;

    case TOKEN_NOT:
        match(TOKEN_NOT);
        bValue = !expr();
        break;

    case TOKEN_IDENTIFIER:
        {
            _ASSERT(m_pFlags);
            
            TSTRINGMap::const_iterator citFlag = m_pFlags->find(m_tstrCurrentLexeme);
            
            if (citFlag == m_pFlags->end())
            {
                tstring tstrErrMsg = _T("Flag not found in map - ") + m_tstrCurrentLexeme;
                THROW_TEST_RUN_TIME_WIN32(ERROR_NOT_FOUND, tstrErrMsg.c_str());
            }

            bValue = FromString<bool>(citFlag->second);
            match(TOKEN_IDENTIFIER);
            break;
        }

    case TOKEN_NONE:
        break;

    default:
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_DATA, _T("Invalid token."));
    }

    return bValue;
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CBooleanExpression::match(TOKENS_ENUM Token)
{
    if (m_CurrentToken != Token)
    {
        THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_DATA, _T("Invalid token."));
    }

    NextToken();
}



//-----------------------------------------------------------------------------------------------------------------------------------------
void CBooleanExpression::NextToken()
{
    STATES_ENUM CurrentState = STATE_START;

    m_iForward = m_iCurrentLexemeStartPosition;

    if (m_iForward >= m_tstrExpression.size())
    {
        m_tstrCurrentLexeme = _T("");
        m_CurrentToken = TOKEN_NONE;
        return;
    }

    for(;;)
    {
        CurrentState = m_TransitionDiagram[CurrentState][GetCharacterClass(m_tstrExpression[m_iForward])];

        if (STATE_ERROR == CurrentState)
        {
            THROW_TEST_RUN_TIME_WIN32(ERROR_INVALID_DATA, _T("Invalid token."));
        }

        if (STATE_START == CurrentState)
        {
            ++m_iCurrentLexemeStartPosition;
            ++m_iForward;
            continue;
        }

        if (TOKEN_NONE == m_States[CurrentState].AcceptToken)
        {
            ++m_iForward;
            continue;
        }

        m_CurrentToken = m_States[CurrentState].AcceptToken;

        if (m_States[CurrentState].bRetract)
        {
            --m_iForward;
        }

        m_tstrCurrentLexeme = m_tstrExpression.substr(m_iCurrentLexemeStartPosition, m_iForward - m_iCurrentLexemeStartPosition + 1);
        m_iCurrentLexemeStartPosition = m_iForward + 1;
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\corruptimage\corruptdll.cpp ===
// CorruptDLL.cpp: implementation of the CCorruptDLL class.
//
//////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <crtdbg.h>
#include "CorruptDLL.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCorruptDLL::CCorruptDLL()
{
}

CCorruptDLL::~CCorruptDLL()
{
}

bool CCorruptDLL::CorruptOriginalImageBuffer(PVOID pCorruptionData)
{
	return CCorruptImageBase::CorruptOriginalImageBuffer((PVOID)rand());
}

HANDLE CCorruptDLL::LoadImage(TCHAR *szImageName, TCHAR *szParams)
{
	_ASSERTE(szImageName);
	UNREFERENCED_PARAMETER(szParams);

	HMODULE hModule;

	if (NULL == (hModule == ::LoadLibrary(szImageName)))
	{
        _tprintf(  
            TEXT("LoadLibrary(%s): failed with %d.\n"), 
            szImageName, GetLastError()
            );
        return NULL;
	}
	else
	{
        _tprintf(  
            TEXT("LoadLibrary(%s): succeeded.\n"));
        return (HANDLE)hModule;
	}
}

void CCorruptDLL::CleanupCorrupedImages()
{
	_tprintf(TEXT(">>>Entered CleanupCorrupedImages\n"));
	bool afDeleteCorruptedImage[MAX_NUM_OF_CONCURRENT_CORRUPTED_IMAGES];
	//
	// time to verify that all processes are dead, and clean them up
	//
	for (DWORD dwProcessToCleanup = 0; dwProcessToCleanup < MAX_NUM_OF_CONCURRENT_CORRUPTED_IMAGES; dwProcessToCleanup++)
	{
		afDeleteCorruptedImage[dwProcessToCleanup] = true;
		//
		// check the process state
		//
		if(NULL == m_ahCorruptedProcesses[dwProcessToCleanup])
		{
			continue;
		}

		if (!::FreeLibrary((HMODULE)m_ahCorruptedProcesses[dwProcessToCleanup]))
		{
			_tprintf(
				TEXT("CleanupCorrupedImages(): FreeLibrary(%s) failed with %d\n"),
				m_aszCorruptedImage[dwProcessToCleanup],
				::GetLastError()
				);
		}
		m_ahCorruptedProcesses[dwProcessToCleanup] = NULL;
	}

	//
	// delete the images.
	// i do this here, and not inside the loop above, because i want to be sure that 'enough' time
	// passes after terminating the process, so i do not get  sharing violation / access denied error
	//
	for (dwProcessToCleanup = 0; dwProcessToCleanup < MAX_NUM_OF_CONCURRENT_CORRUPTED_IMAGES; dwProcessToCleanup++)
	{
		if (!::DeleteFile(m_aszCorruptedImage[dwProcessToCleanup]))
		{
			/*
			_tprintf(
				TEXT("CleanupCorrupedImages(): DeleteFile(%s) failed with %d\n"),
				m_aszCorruptedImage[dwProcessToCleanup],
				::GetLastError()
				);
				*/
		}
		lstrcpy(m_aszCorruptedImage[dwProcessToCleanup], TEXT(""));
	}

	_tprintf(TEXT("<<<Exited CleanupCorrupedImages\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\corruptimage\corruptimagebase.cpp ===
// ImageBase.cpp: implementation of the ImageBase class.
//
//////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
#include "CorruptImageBase.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
//
// 2 phase construction, so Init() must always be called
//
CCorruptImageBase::CCorruptImageBase():
	m_szImageName(NULL),
	m_abOriginalFileContents(NULL),
	m_abOriginalFileContentsCopy(NULL),
	m_fValidObject(false),
	m_dwNextFreeCorruptedImageIndex(0)
{
	ZeroMemory(m_ahCorruptedProcesses, sizeof(m_ahCorruptedProcesses));
	ZeroMemory(m_aszCorruptedImage, sizeof(m_aszCorruptedImage));
}

CCorruptImageBase::~CCorruptImageBase()
{
	Cleanup();
}

void CCorruptImageBase::Cleanup()
{
	CleanupCorrupedImages();

	delete[] m_szImageName;
	m_szImageName = NULL;
	delete[] m_abOriginalFileContents;
	m_abOriginalFileContents = NULL;
	delete[] m_abOriginalFileContentsCopy;
	m_abOriginalFileContentsCopy = NULL;

	m_dwOriginalFileSize = 0;

	ZeroMemory(m_ahCorruptedProcesses, sizeof(m_ahCorruptedProcesses));
	ZeroMemory(m_aszCorruptedImage, sizeof(m_aszCorruptedImage));

	m_fValidObject = false;
}

//
// 2 phase construction, so Init() must always be called
// actions: cleanup, and read the file to a buffer in memory.
// i do not use memory mapped files. because most executables
// are not that big.
// upon any failure: cleanup.
//
bool CCorruptImageBase::Init(TCHAR * szImageName)
{
	HANDLE hOriginalFile = INVALID_HANDLE_VALUE;
	DWORD dwNumberOfBytesRead = 0;
	//
	// this may be a not 1st call to Init(), so lets cleanup 1st
	//
	Cleanup();


	if (NULL == szImageName)
	{
		DPF((TEXT("CCorruptImageBase::Init():szImageName is NULL\n"),
			m_szImageName,
			::GetLastError()
			));
		goto ErrorExit;
	}

	m_szImageName = new TCHAR[1+lstrlen(szImageName)];
	if(NULL == m_szImageName)
	{
		DPF((TEXT("CCorruptImageBase::Init(%s): new TCHAR[%d] failed\n"),
			szImageName,
			1+lstrlen(szImageName)
			));
		goto ErrorExit;
	}

	if (NULL == ::lstrcpy(m_szImageName, szImageName))
	{
		DPF((TEXT("CCorruptImageBase::Init(%s): lstrcpy failed\n"),
			szImageName
			));
		goto ErrorExit;
	}

	hOriginalFile = ::CreateFile(
		m_szImageName, //LPCTSTR lpFileName, // pointer to name of the file 
		GENERIC_READ, //DWORD dwDesiredAccess, // access (read-write) mode 
		FILE_SHARE_READ, // share mode 
		NULL, // pointer to security attributes 
		OPEN_EXISTING , // how to create  
		FILE_ATTRIBUTE_NORMAL, //FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING ,  // file attributes 
		NULL // handle to file with attributes to copy
		);
	if (INVALID_HANDLE_VALUE == hOriginalFile) 
	{
		DPF((TEXT("CCorruptImageBase::Init():CreateFile(%s) failed with %d\n"),
			m_szImageName,
			::GetLastError()
			));
		goto ErrorExit;
	}
	
	m_dwOriginalFileSize = ::GetFileSize(hOriginalFile, NULL);
	if (0xFFFFFFFF == m_dwOriginalFileSize)
	{
		DPF((TEXT("CCorruptImageBase::Init():GetFileSize(%s) failed with %d\n"),
			m_szImageName,
			::GetLastError()
			));
		goto ErrorExit;
	}

	m_abOriginalFileContents = new BYTE[m_dwOriginalFileSize];		
	if (NULL == m_abOriginalFileContents)
	{
		DPF((TEXT("CCorruptImageBase::Init(%s):new BYTE[%d] failed with %d\n"),
			m_szImageName,
			m_dwOriginalFileSize,
			::GetLastError()
			));
		goto ErrorExit;
	}
	m_abOriginalFileContentsCopy = new BYTE[m_dwOriginalFileSize];		
	if (NULL == m_abOriginalFileContentsCopy)
	{
		DPF((TEXT("CCorruptImageBase::Init(%s):new BYTE[%d] failed with %d\n"),
			m_szImageName,
			m_dwOriginalFileSize,
			::GetLastError()
			));
		goto ErrorExit;
	}

	if (!::ReadFile(
			hOriginalFile, // handle of file to read 
			m_abOriginalFileContents, // address of buffer that receives data 
			m_dwOriginalFileSize, // number of bytes to read 
			&dwNumberOfBytesRead, // address of number of bytes read 
			NULL // OL
		))
	{
		DPF((TEXT("CCorruptImageBase::Init():ReadFile(%s) failed with %d\n"),
			m_szImageName,
			::GetLastError()
			));
		goto ErrorExit;
	}
	if (m_dwOriginalFileSize != dwNumberOfBytesRead)
	{
		DPF((TEXT("CCorruptImageBase::Init():ReadFile(%s) read %d bytes instead %d\n"),
			m_szImageName,
			dwNumberOfBytesRead,
			m_dwOriginalFileSize
			));
		goto ErrorExit;
	}

	::CloseHandle(hOriginalFile);

	m_fValidObject = true;

	return true;

ErrorExit:
	Cleanup();
	if (INVALID_HANDLE_VALUE != hOriginalFile) 
	{
		::CloseHandle(hOriginalFile);
	}

	return false;
}

//
// corrupts (DWORD)pCorruptionData bytes
//
bool CCorruptImageBase::CorruptOriginalImageBuffer(PVOID pCorruptionData)
{
	if (!m_fValidObject)
	{
		DPF((TEXT("CCorruptImageBase::CorruptOriginalImageBuffer(): object not initialized!\n")));
		return false;
	}

	DWORD dwBytesToCorrupt = (DWORD)pCorruptionData;
	BYTE bOriginalByte;

	CopyMemory(m_abOriginalFileContentsCopy, m_abOriginalFileContents, m_dwOriginalFileSize);

	//
	// corrupt the bytes
	// BUGBUG: we may corrupt the same byte twice, thus
	//   not corrupting the corrent num of byte, and i may even
	//   restore a corrupted byte to its original value
	//
	for (DWORD dwCorruptedBytes = 0; dwCorruptedBytes < dwBytesToCorrupt; dwCorruptedBytes++)
	{
		DWORD dwByteIndexToCorrupt = DWORD_RAND % m_dwOriginalFileSize;
		bOriginalByte = m_abOriginalFileContentsCopy[dwByteIndexToCorrupt];
		do
		{
			m_abOriginalFileContentsCopy[dwByteIndexToCorrupt] = rand()%0xff;
		}while(bOriginalByte == m_abOriginalFileContentsCopy[dwByteIndexToCorrupt]);
	}

	
	return true;
}

bool CCorruptImageBase::CreateCorruptedFileAccordingToImageBuffer(TCHAR *szNewCorruptedImageName)
{
	if (!m_fValidObject)
	{
		DPF((TEXT("CCorruptImageBase::CreateCorruptedFileAccordingToImageBuffer(): object not initialized!\n")));
		return false;
	}

	_ASSERTE(szNewCorruptedImageName);
	_stprintf(szNewCorruptedImageName, TEXT("%s-%d.exe"), m_szImageName, DWORD_RAND);

	//
	// make a file with corruped contents
	//
	HANDLE hCorruptedImage = INVALID_HANDLE_VALUE;
	DWORD dwNumberOfBytesWritten;
	//
	// the corrpted image name has the format:
	// <original name>-corrupted-bytes-<bytes corrupted>-<random number>
	// where <corrupt data> in this case is the byte index
	// example: c:\a.dll may become c:\a.dll-corrupted-bytes-1034-0x00000003
	//
	hCorruptedImage = ::CreateFile(
		szNewCorruptedImageName, //LPCTSTR lpFileName, // pointer to name of the file 
		GENERIC_WRITE, //DWORD dwDesiredAccess, // access (read-write) mode 
		0, // share mode 
		NULL, // pointer to security attributes 
		CREATE_NEW , // how to create  
		FILE_ATTRIBUTE_NORMAL, //FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING ,  // file attributes 
		NULL // handle to file with attributes to copy
		);
	if (INVALID_HANDLE_VALUE == hCorruptedImage) 
	{
		DPF((TEXT("CCorruptImageBase::CreateCorruptedFileAccordingToImageBuffer():CreateFile(%s) failed with %d\n"),
			szNewCorruptedImageName,
			::GetLastError()
			));
		//goto ErrorExit;
		//
		// do not goto exit, because the file may have beern existed, and i just do not want to 
		// overwrite it
		//
		return false;
	}

	if (!::WriteFile(
			hCorruptedImage, // handle of file to read 
			m_abOriginalFileContentsCopy, // address of buffer that receives data 
			m_dwOriginalFileSize, // number of bytes to read 
			&dwNumberOfBytesWritten, // address of number of bytes read 
			NULL // address of structure for data
		))
	{
		DPF((TEXT("CCorruptImageBase::CreateCorruptedFileAccordingToImageBuffer():WriteFile() failed with %d\n"),
			::GetLastError()
			));
		goto ErrorExit;
	}
	if (m_dwOriginalFileSize != dwNumberOfBytesWritten)
	{
		DPF((TEXT("CCorruptImageBase::CreateCorruptedFileAccordingToImageBuffer():WriteFile() wrote %d bytes instead of %d\n"),
			dwNumberOfBytesWritten,
			m_dwOriginalFileSize
			));
		goto ErrorExit;
	}

	::CloseHandle(hCorruptedImage);
	return true;

ErrorExit:
	if (INVALID_HANDLE_VALUE != hCorruptedImage) 
	{
		::CloseHandle(hCorruptedImage);
		::DeleteFile(szNewCorruptedImageName);
	}
	return false;
}

bool CCorruptImageBase::LoadCorruptedImage(TCHAR *szParams, PVOID pCorruptionData)
{
	if (!m_fValidObject)
	{
		DPF((TEXT("CCorruptImageBase::LoadCorruptedImage(): object not initialized!\n")));
		return false;
	}

	if (!CorruptOriginalImageBuffer(pCorruptionData))
	{
		return false;
	}

	TCHAR szNewCorruptedImageName[MAX_CORRUPTED_IMAGE_SIZE];
	if (!CreateCorruptedFileAccordingToImageBuffer(szNewCorruptedImageName))
	{
		return false;
	}

	//
	// if the internal list of corrupted processes is full, clean it up
	//
	if (MAX_NUM_OF_CONCURRENT_CORRUPTED_IMAGES == m_dwNextFreeCorruptedImageIndex)
	{
		CleanupCorrupedImages();

		//
		// wrap around
		//
		m_dwNextFreeCorruptedImageIndex = 0;
	}

	//
	// launch the image.
	// if successfull, it is added to the list
	//
	m_ahCorruptedProcesses[m_dwNextFreeCorruptedImageIndex] = LoadImage(szNewCorruptedImageName, szParams);
	if (NULL == m_ahCorruptedProcesses[m_dwNextFreeCorruptedImageIndex])
	{
		return false;
	}

	_stprintf(m_aszCorruptedImage[m_dwNextFreeCorruptedImageIndex], szNewCorruptedImageName);
	m_dwNextFreeCorruptedImageIndex++;
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\corruptimage\corruptimagebase.h ===
// ImageBase.h: interface for the ImageBase class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_IMAGEBASE_H__EED230C3_4BDF_11D3_B902_000000000000__INCLUDED_)
#define AFX_IMAGEBASE_H__EED230C3_4BDF_11D3_B902_000000000000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#define ARRSIZE(__arr) (sizeof(__arr) / (sizeof(__arr[0]))

#define DPF(__x) _tprintf __x

#define DWORD_RAND ((rand()<<16) | rand())

#define MAX_NUM_OF_CONCURRENT_CORRUPTED_IMAGES (12)
#define MAX_CORRUPTED_IMAGE_SIZE (MAX_PATH)

class CCorruptImageBase  
{
public:
	CCorruptImageBase();
	virtual ~CCorruptImageBase();

	//
	// i can think of processes (where params are relevant) and DLLs.
	// so each needs it's own implementation of loading/launching and
	// unloading/terminating
	//
	virtual bool LoadCorruptedImage(TCHAR *szParams, PVOID pCorruptionData);

	//
	// you may init with different filenames, as many times as you like.
	// each init clears the object, and reinitializes it.
	//
	virtual bool Init(TCHAR * szImageName);

protected:
	//
	// implement this to corrupt the image as you like.
	// the image is in the buffer m_abOriginalFileContents,
	// and it holds m_dwOriginalFileSize bytes.
	// copy it to m_abOriginalFileContentsCopy (alreadu allocated)
	// and corrupt m_abOriginalFileContentsCopy.
	// 
	virtual bool CorruptOriginalImageBuffer(PVOID pCorruptionData) = 0;

	//
	// CreateProcess(), LoadLibrary(), or whatever i could not think of
	//
	virtual HANDLE LoadImage(TCHAR *szImageName, TCHAR *szParams) = 0;

	//
	// this method creats the file szNewCorruptedImageName with
	// the contents of m_abOriginalFileContentsCopy
	//
	bool CreateCorruptedFileAccordingToImageBuffer(TCHAR *szNewCorruptedImageName);

	BYTE *m_abOriginalFileContents;
	BYTE *m_abOriginalFileContentsCopy;
	DWORD m_dwOriginalFileSize;
	bool m_fValidObject;
	void Cleanup();
	virtual void CleanupCorrupedImages() = 0;

	TCHAR * m_szImageName;
	DWORD m_dwNextFreeCorruptedImageIndex;
	HANDLE m_ahCorruptedProcesses[MAX_NUM_OF_CONCURRENT_CORRUPTED_IMAGES];
	TCHAR m_aszCorruptedImage[MAX_NUM_OF_CONCURRENT_CORRUPTED_IMAGES][MAX_CORRUPTED_IMAGE_SIZE];

private:

};

#endif // !defined(AFX_IMAGEBASE_H__EED230C3_4BDF_11D3_B902_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\corruptimage\corruptimagerandom.cpp ===
// CorruptImageRandom.cpp: implementation of the CCorruptImageRandom class.
//
//////////////////////////////////////////////////////////////////////

#include <windows.h>
#include "CorruptImageRandom.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCorruptImageRandom::CCorruptImageRandom()
{

}

CCorruptImageRandom::~CCorruptImageRandom()
{

}

bool CCorruptImageRandom::CorruptOriginalImageBuffer(PVOID pCorruptionData)
{
	return CCorruptImageBase::CorruptOriginalImageBuffer((PVOID)rand());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\corruptimage\corruptprocess.cpp ===
// CorruptProcess.cpp: implementation of the CCorruptProcess class.
//
//////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <crtdbg.h>
#include "CorruptProcess.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCorruptProcess::CCorruptProcess()
{
}

CCorruptProcess::~CCorruptProcess()
{
}

bool CCorruptProcess::CorruptOriginalImageBuffer(PVOID pCorruptionData)
{
	return CCorruptImageBase::CorruptOriginalImageBuffer((PVOID)rand());
}

HANDLE CCorruptProcess::CreateProcess(TCHAR *szImageName, TCHAR *szParams)
{
	_ASSERTE(szImageName);
	TCHAR szImageNameAndParams[1024];
	if (szParams)
	{
		_stprintf(szImageNameAndParams, TEXT("%s %s"), szImageName, szParams);
	}

    STARTUPINFO si;
    PROCESS_INFORMATION pi;

	//
	// fill STARTUPINFO
	//
    si.cb = sizeof(STARTUPINFO); 
    si.lpReserved = NULL; 
    si.lpDesktop = NULL;//TEXT(""); 
    si.lpTitle = TEXT("TITLE"); 
    //si.dwX; 
    //si.dwY; 
    //si.dwXSize; 
    //si.dwYSize; 
    //si.dwXCountChars; 
    //si.dwYCountChars; 
    //si.dwFillAttribute; 
    si.dwFlags = 0; 
    //si.wShowWindow; 
    si.cbReserved2 = 0; 
    si.lpReserved2 = NULL; 
    //si.hStdInput; 
    //si.hStdOutput; 
    //si.hStdError; 

	//
	// create the process
	//

	//
	// i want to always debug the process, because it may AV, and i do not want it 
	// to clutter the desktop.
	// i will just let the process die
	//
	DWORD dwCreationFlags = DEBUG_PROCESS;
	if (0 == rand()%20) dwCreationFlags != CREATE_NEW_CONSOLE;
	if (0 == rand()%20) dwCreationFlags != CREATE_SHARED_WOW_VDM;
	if (0 == rand()%20) dwCreationFlags != CREATE_DEFAULT_ERROR_MODE;
	if (0 == rand()%20) dwCreationFlags != CREATE_NEW_PROCESS_GROUP;
	if (0 == rand()%20) dwCreationFlags != CREATE_NO_WINDOW;
	if (0 == rand()%20) dwCreationFlags != CREATE_SEPARATE_WOW_VDM;
	if ( !(CREATE_NEW_CONSOLE & dwCreationFlags) && (0 == rand()%20) ) dwCreationFlags != DETACHED_PROCESS;

    if (! ::CreateProcess(
        NULL,
        szImageNameAndParams,	// pointer to command line string
        NULL,	// pointer to process security attributes 
        NULL,	// pointer to thread security attributes 
        rand()%2,	// handle inheritance flag 
        DEBUG_PROCESS  | CREATE_NEW_CONSOLE | CREATE_SHARED_WOW_VDM ,	// creation flags 
        NULL,	// pointer to new environment block 
        NULL,	// pointer to current directory name 
        &si,	// pointer to STARTUPINFO 
        &pi 	// pointer to PROCESS_INFORMATION  
       ))
    {
		///*
        _tprintf(  
            TEXT("SimpleCreateProcess(%s): CreateProcess() failed with %d.\n"), 
            szImageNameAndParams, GetLastError()
            );
		//*/
        return NULL;
    }

	//
	// if the process is a corrupted image, then it will not have a main thread!
	//
	if (NULL == pi.hThread)
	{
		//
		// seems like a bug, but it happens that the main thread is NULL, probably related
		// to the fact that the image is bad.
		// in this case, we close the Process handle, and fail
		//
		::SetLastError(ERROR_BAD_FORMAT);
		/*
		_tprintf(  
			TEXT("SimpleCreateProcess(%s): NULL == pi.hThread.\n"), szImageNameAndParams
			);
			*/
		if (!CloseHandle(pi.hProcess))
		{
			_tprintf(  
				TEXT("SimpleCreateProcess(%s): (NULL == pi.hThread), CloseHandle(pi.hProcess) failed with %d.\n"), 
				szImageNameAndParams, 
				GetLastError()
				);
		}
		return NULL;
	}

	if(!CloseHandle(pi.hThread))
	{
		_tprintf(  
			TEXT("SimpleCreateProcess(%s): CloseHandle(pi.hThread) failed with %d.\n"), 
			szImageNameAndParams, GetLastError()
			);
	}
	
	_ASSERTE(NULL != pi.hProcess);
	/*
	if (!CloseHandle(pi.hProcess))
	{
        _tprintf(  
            TEXT("SimpleCreateProcess(%s): CloseHandle(pi.hProcess) failed with %d.\n"), 
            szImageNameAndParams, 
			GetLastError()
            );
	}
	*/
	///*
    _tprintf(  
        TEXT("SimpleCreateProcess(%s): succeeded.\n"),
		szImageNameAndParams
        );
	//*/
	
	return pi.hProcess;
}

HANDLE CCorruptProcess::LoadImage(TCHAR *szImageName, TCHAR *szParams)
{
	return CreateProcess(szImageName, szParams);
}

void CCorruptProcess::CleanupCorrupedImages()
{
	_tprintf(TEXT(">>>Entered CleanupCorrupedImages\n"));
	bool afDeleteCorruptedImage[MAX_NUM_OF_CONCURRENT_CORRUPTED_IMAGES];
	//
	// time to verify that all processes are dead, and clean them up
	//
	for (DWORD dwProcessToCleanup = 0; dwProcessToCleanup < MAX_NUM_OF_CONCURRENT_CORRUPTED_IMAGES; dwProcessToCleanup++)
	{
		afDeleteCorruptedImage[dwProcessToCleanup] = true;
		//
		// check the process state
		//
		if(NULL == m_ahCorruptedProcesses[dwProcessToCleanup])
		{
			continue;
		}

		DWORD dwProcessWaitState = ::WaitForSingleObject(m_ahCorruptedProcesses[dwProcessToCleanup], 0);
		if (WAIT_TIMEOUT == dwProcessWaitState)
		{
			if (!::TerminateProcess(m_ahCorruptedProcesses[dwProcessToCleanup], -1))
			{
				_tprintf(
					TEXT("CleanupCorrupedImages(): TerminateProcess(%s) failed with %d\n"),
					m_aszCorruptedImage[dwProcessToCleanup],
					::GetLastError()
					);
				//
				// do not delete the file, because it may be initeresting to see why it did not
				// terminate
				//
				afDeleteCorruptedImage[dwProcessToCleanup] = false;
			}
		}
		else 
		{
			_tprintf(
				TEXT("CleanupCorrupedImages(): WaitForSingleObject(%s) returned %d with error %d\n"),
				m_aszCorruptedImage[dwProcessToCleanup],
				dwProcessWaitState,
				::GetLastError()
				);
			_ASSERTE(WAIT_OBJECT_0 == dwProcessWaitState);
		}

		if (!::CloseHandle(m_ahCorruptedProcesses[dwProcessToCleanup]))
		{
			_tprintf(
				TEXT("CleanupCorrupedImages(): CloseHandle(%s) failed with %d\n"),
				m_aszCorruptedImage[dwProcessToCleanup],
				::GetLastError()
				);
		}
		m_ahCorruptedProcesses[dwProcessToCleanup] = NULL;
	}

	//
	// delete the images.
	// i do this here, and not inside the loop above, because i want to be sure that 'enough' time
	// passes after terminating the process, so i do not get  sharing violation / access denied error
	//
	for (dwProcessToCleanup = 0; dwProcessToCleanup < MAX_NUM_OF_CONCURRENT_CORRUPTED_IMAGES; dwProcessToCleanup++)
	{
		if (!::DeleteFile(m_aszCorruptedImage[dwProcessToCleanup]))
		{
			/*
			_tprintf(
				TEXT("CleanupCorrupedImages(): DeleteFile(%s) failed with %d\n"),
				m_aszCorruptedImage[dwProcessToCleanup],
				::GetLastError()
				);
				*/
		}
		lstrcpy(m_aszCorruptedImage[dwProcessToCleanup], TEXT(""));
	}

	_tprintf(TEXT("<<<Exited CleanupCorrupedImages\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\corruptimage\corruptimagerandom.h ===
// CorruptImageRandom.h: interface for the CCorruptImageRandom class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CORRUPTIMAGERANDOM_H__74F2B566_6CF6_11D3_B92B_000000000000__INCLUDED_)
#define AFX_CORRUPTIMAGERANDOM_H__74F2B566_6CF6_11D3_B92B_000000000000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "CorruptImageBase.h"

class CCorruptImageRandom : public CCorruptImageBase  
{
public:
	CCorruptImageRandom();
	virtual ~CCorruptImageRandom();
	virtual bool CorruptOriginalImageBuffer(PVOID pCorruptionData);

};

#endif // !defined(AFX_CORRUPTIMAGERANDOM_H__74F2B566_6CF6_11D3_B92B_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\corruptimage\corruptprocess.h ===
// CorruptProcess.h: interface for the CCorruptProcess class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CORRUPTPROCESS_H__C470EDEB_7C79_4B3C_B1F5_190F57609DBE__INCLUDED_)
#define AFX_CORRUPTPROCESS_H__C470EDEB_7C79_4B3C_B1F5_190F57609DBE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "CorruptImageBase.h"


class CCorruptProcess : public CCorruptImageBase  
{
public:
	CCorruptProcess();
	virtual ~CCorruptProcess();
	static HANDLE CreateProcess(TCHAR *szImageName, TCHAR *szParams);

protected:
	virtual bool CorruptOriginalImageBuffer(PVOID pCorruptionData);
	virtual HANDLE LoadImage(TCHAR *szImageName, TCHAR *szParams);

	void CleanupCorrupedImages();

};

#endif // !defined(AFX_CORRUPTPROCESS_H__C470EDEB_7C79_4B3C_B1F5_190F57609DBE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\corruptimage\main.cpp ===
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
#include <time.h>

#include "CorruptImageRandom.h"
#include "CorruptProcess.h"



//bool SimpleCreateProcess(TCHAR *szExeAndParams, HANDLE *phProcess);
//void CleanupCorrupedProcesses();
void IgnoreQueuedDebugEventsForAllProcesses();
bool RecursiveLoadLibrary(TCHAR *szPath);

//static HANDLE s_ahCorruptedProcesses[MAX_NUM_OF_CONCURRENT_CORRUPTED_IMAGES];
//static TCHAR s_aszCorruptedImage[MAX_NUM_OF_CONCURRENT_CORRUPTED_IMAGES][MAX_CORRUPTED_IMAGE_SIZE];

static HANDLE s_hMainThread = NULL;

BOOL WINAPI Handler_Routine(DWORD dwCtrlType)
{
	_tprintf(TEXT(">>>Handler_Routine()\n"));

	//
	// BUG: as it happens on NT5, SuspendThread() never returns!
	// suspend main thread, so cleanup is pseudo-safe
	//
	/*
	if (0xFFFFFFFF == ::SuspendThread(s_hMainThread))
	{
		_tprintf(TEXT(">>>Handler_Routine(): SuspendThread() failed with %d.\n"), ::GetLastError());
	}
	*/
	_tprintf(TEXT(">>>Handler_Routine(), before CleanupCorrupedProcesses()\n"));

	//
	// BUGBUG: main thread is still running, so we may crash
	//
	//CleanupCorrupedProcesses();

	_tprintf(TEXT(">>>Handler_Routine(): before TerminateProcess().\n"));
	fflush(stdout);
	::TerminateProcess(::GetCurrentProcess(), -1);
	_ASSERTE(FALSE);
	return true;
}


int main(int argc, char *szArgvA[])
{
	TCHAR **szArgv = NULL;

#ifdef UNICODE
	szArgv = CommandLineToArgvW( GetCommandLine(), &argc );
#else
	szArgv = szArgvA;
#endif

	if (NULL == szArgv)
	{
		_tprintf(TEXT("CommandLineToArgvW() failed with %d\n"), ::GetLastError());
		return -1;
	}

	if (argc < 2)
	{
		_tprintf(TEXT("Usage: %s <imagename> [<params>]\n"), szArgv[0]);
		return -1;
	}

	s_hMainThread = GetCurrentThread();

    if (! ::SetConsoleCtrlHandler(
			  Handler_Routine,  // address of handler function
			  true                          // handler to add or remove
			  ))
	{
		_tprintf(TEXT("SetConsoleCtrlHandler() failed with %d.\n"),GetLastError());
		exit(1);
	}

	SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    srand(time( NULL ));

	if (0 == lstrcmp(TEXT("DLL"), szArgv[1]))
	{
		TCHAR szPath[1024];
		lstrcpy(szPath, szArgv[2]);
		return RecursiveLoadLibrary(szPath);
	}

	CCorruptProcess corruptingDLL;
	CCorruptProcess corruptingEXE;
	TCHAR *szOriginalImage = szArgv[1];
	TCHAR *szImageParams = TEXT("");
	if (argc > 2)
	{
		szImageParams = szArgv[2];
	}
	if (!corruptingEXE.Init(szOriginalImage))
	{
		return -1;
	}

	for (DWORD dwIter = 0; dwIter < 40000; dwIter++)
	{
		_tprintf(TEXT("%d, %d\n"), dwIter, dwIter);
		IgnoreQueuedDebugEventsForAllProcesses();

		if (!corruptingEXE.LoadCorruptedImage(szImageParams, 0))
		{
			continue;
		}

	}//for (DWORD dwIter = 0; dwIter < 40000; dwIter++)


	return 0;


}


void IgnoreQueuedDebugEventsForAllProcesses()
{
	DEBUG_EVENT debugEvent;
	for(;;)
	{
		if ( ::WaitForDebugEvent(
				&debugEvent,  // pointer to debug event structure
				0         // milliseconds to wait for event
				))
		{
			/*
			_tprintf(TEXT("WaitForDebugEvent():\n"));
			_tprintf(TEXT("    dwProcessId  = %d = 0x%08X, "),debugEvent.dwProcessId , debugEvent.dwProcessId );
			_tprintf(TEXT("dwThreadId   = %d = 0x%08X, "),debugEvent.dwThreadId  , debugEvent.dwThreadId  );
			switch(debugEvent.dwDebugEventCode )
			{
			case EXCEPTION_DEBUG_EVENT:
				_tprintf(TEXT("EXCEPTION_DEBUG_EVENT"));
				break;

			case CREATE_THREAD_DEBUG_EVENT:
				_tprintf(TEXT("CREATE_THREAD_DEBUG_EVENT"));
				break;

			case CREATE_PROCESS_DEBUG_EVENT:
				_tprintf(TEXT("CREATE_PROCESS_DEBUG_EVENT"));
				break;

			case EXIT_THREAD_DEBUG_EVENT:
				_tprintf(TEXT("EXIT_THREAD_DEBUG_EVENT"));
				break;

			case EXIT_PROCESS_DEBUG_EVENT:
				_tprintf(TEXT("EXIT_PROCESS_DEBUG_EVENT"));
				break;

			case LOAD_DLL_DEBUG_EVENT:
				_tprintf(TEXT("LOAD_DLL_DEBUG_EVENT"));
				break;

			case UNLOAD_DLL_DEBUG_EVENT:
				_tprintf(TEXT("UNLOAD_DLL_DEBUG_EVENT"));
				break;

			case OUTPUT_DEBUG_STRING_EVENT:
				_tprintf(TEXT("OUTPUT_DEBUG_STRING_EVENT"));
				break;

			case RIP_EVENT:
				_tprintf(TEXT("RIP_EVENT"));
				break;

			default:
				_ASSERTE(FALSE);
			}
			_tprintf(TEXT("\n"));
			*/
			if (! ::ContinueDebugEvent(
					debugEvent.dwProcessId,       // process to continue
					debugEvent.dwThreadId,        // thread to continue
					DBG_CONTINUE     // continuation status
					))
			{
				_tprintf(TEXT("ContinueDebugEvent() failed with %d:\n"), ::GetLastError());
			}
		}
		else
		{
			DWORD dwError = ::GetLastError();
			if (ERROR_SEM_TIMEOUT != dwError)
			{
				_tprintf(TEXT("WaitForDebugEvent() failed with %d:\n"), dwError);
			}

			//
			// there are no more debug events, return
			//
			return;
		}
	}
}


#if 0
bool SimpleCreateProcess(TCHAR *szExeAndParams, HANDLE *phProcess)
{
	_ASSERTE(szExeAndParams);
	_ASSERTE(phProcess);
	_ASSERTE(NULL == *phProcess);

    STARTUPINFO si;
    PROCESS_INFORMATION pi;

	//
	// fill STARTUPINFO
	//
    si.cb = sizeof(STARTUPINFO); 
    si.lpReserved = NULL; 
    si.lpDesktop = NULL;//TEXT(""); 
    si.lpTitle = TEXT("TITLE"); 
    //si.dwX; 
    //si.dwY; 
    //si.dwXSize; 
    //si.dwYSize; 
    //si.dwXCountChars; 
    //si.dwYCountChars; 
    //si.dwFillAttribute; 
    si.dwFlags = 0; 
    //si.wShowWindow; 
    si.cbReserved2 = 0; 
    si.lpReserved2 = NULL; 
    //si.hStdInput; 
    //si.hStdOutput; 
    //si.hStdError; 

	//
	// create the process
	//
    if (! ::CreateProcess(
        NULL,
        szExeAndParams,	// pointer to command line string
        NULL,	// pointer to process security attributes 
        NULL,	// pointer to thread security attributes 
        FALSE,	// handle inheritance flag 
        DEBUG_PROCESS /* | CREATE_NEW_CONSOLE | CREATE_SHARED_WOW_VDM */,	// creation flags 
        NULL,	// pointer to new environment block 
        NULL,	// pointer to current directory name 
        &si,	// pointer to STARTUPINFO 
        &pi 	// pointer to PROCESS_INFORMATION  
       ))
    {
		///*
        _tprintf(  
            TEXT("SimpleCreateProcess(%s): CreateProcess() failed with %d.\n"), 
            szExeAndParams, GetLastError()
            );
		//*/
        return false;
    }

	//
	// if the process is a corrupted image, then it will not have a main thread!
	//
	if (NULL == pi.hThread)
	{
		//
		// seems like a bug, but it happens that the main thread is NULL, probably related
		// to the fact that the image is bad.
		// in this case, we close the Process handle, and fail
		//
		::SetLastError(ERROR_BAD_FORMAT);
		/*
		_tprintf(  
			TEXT("SimpleCreateProcess(%s): NULL == pi.hThread.\n"), szExeAndParams
			);
			*/
		if (!CloseHandle(pi.hProcess))
		{
			_tprintf(  
				TEXT("SimpleCreateProcess(%s): (NULL == pi.hThread), CloseHandle(pi.hProcess) failed with %d.\n"), 
				szExeAndParams, 
				GetLastError()
				);
		}
		return false;
	}

	if(!CloseHandle(pi.hThread))
	{
		_tprintf(  
			TEXT("SimpleCreateProcess(%s): CloseHandle(pi.hThread) failed with %d.\n"), 
			szExeAndParams, GetLastError()
			);
	}
	
	_ASSERTE(NULL != pi.hProcess);
	*phProcess = pi.hProcess;
	/*
	if (!CloseHandle(pi.hProcess))
	{
        _tprintf(  
            TEXT("SimpleCreateProcess(%s): CloseHandle(pi.hProcess) failed with %d.\n"), 
            szExeAndParams, 
			GetLastError()
            );
	}
	*/
	///*
    _tprintf(  
        TEXT("SimpleCreateProcess(%s): succeeded.\n"),
		szExeAndParams
        );
	//*/
	
	return true;
}

void CleanupCorrupedProcesses()
{
	_tprintf(TEXT(">>>Entered CleanupCorrupedProcesses\n"));
	static bool s_afDeleteCorruptedImage[MAX_NUM_OF_CONCURRENT_CORRUPTED_IMAGES];
	//
	// time to verify that all processes are dead, and clean them up
	//
	for (DWORD dwProcessToCleanup = 0; dwProcessToCleanup < MAX_NUM_OF_CONCURRENT_CORRUPTED_IMAGES; dwProcessToCleanup++)
	{
		s_afDeleteCorruptedImage[dwProcessToCleanup] = true;
		//
		// check the process state
		//
		_ASSERTE(NULL != s_ahCorruptedProcesses[dwProcessToCleanup]);
		DWORD dwProcessWaitState = ::WaitForSingleObject(s_ahCorruptedProcesses[dwProcessToCleanup], 0);
		if (WAIT_TIMEOUT == dwProcessWaitState)
		{
			if (!::TerminateProcess(s_ahCorruptedProcesses[dwProcessToCleanup], -1))
			{
				_tprintf(
					TEXT("CleanupCorrupedProcesses(): TerminateProcess(%s) failed with %d\n"),
					s_aszCorruptedImage[dwProcessToCleanup],
					::GetLastError()
					);
				//
				// do not delete the file, because it may be initeresting to see why it did not
				// terminate
				//
				s_afDeleteCorruptedImage[dwProcessToCleanup] = false;
			}
		}
		else 
		{
			_tprintf(
				TEXT("CleanupCorrupedProcesses(): WaitForSingleObject(%s) returned %d with error %d\n"),
				s_aszCorruptedImage[dwProcessToCleanup],
				dwProcessWaitState,
				::GetLastError()
				);
			_ASSERTE(WAIT_OBJECT_0 == dwProcessWaitState);
		}

		if (!::CloseHandle(s_ahCorruptedProcesses[dwProcessToCleanup]))
		{
			_tprintf(
				TEXT("CleanupCorrupedProcesses(): CloseHandle(%s) failed with %d, will try to terminate\n"),
				s_aszCorruptedImage[dwProcessToCleanup],
				::GetLastError()
				);
		}
		s_ahCorruptedProcesses[dwProcessToCleanup] = NULL;
	}

	//
	// delete the images.
	// i do this here, and not inside the loop above, because i want to be sure that 'enough' time
	// passes after terminating the process, so i do not get  sharing violation / access denied error
	//
	for (dwProcessToCleanup = 0; dwProcessToCleanup < MAX_NUM_OF_CONCURRENT_CORRUPTED_IMAGES; dwProcessToCleanup++)
	{
		if (!::DeleteFile(s_aszCorruptedImage[dwProcessToCleanup]))
		{
			/*
			_tprintf(
				TEXT("CleanupCorrupedProcesses(): DeleteFile(%s) failed with %d\n"),
				s_aszCorruptedImage[dwProcessToCleanup],
				::GetLastError()
				);
				*/
		}
		lstrcpy(s_aszCorruptedImage[dwProcessToCleanup], TEXT(""));
	}

	_tprintf(TEXT("<<<Exited CleanupCorrupedProcesses\n"));
}

#endif //0

bool RecursiveLoadLibrary(TCHAR *szPath)
{
    WIN32_FIND_DATA findFileData;
    bool fMoreFiles = true;
	int nIndex = 0;
    HANDLE hFirstFile = INVALID_HANDLE_VALUE;
	bool fReturn = false;

    //
    // construct the full folder names, with the tailing \*
    //
	_tprintf(TEXT("RecursiveLoadLibrary(%s)\n"), szPath);

    lstrcat(szPath, TEXT("\\*"));

retry_FindFirstFile:
    hFirstFile = ::FindFirstFile(
        szPath,  // pointer to name of file to search for
        &findFileData  // pointer to returned information
        );
    if (INVALID_HANDLE_VALUE == hFirstFile)
    {
		DWORD dwLastErr = ::GetLastError();
		if (ERROR_NO_MORE_FILES == dwLastErr)
		{
			fMoreFiles = false;
		}
		else
		{
			_tprintf(TEXT("ERROR: FindFirstFile(%s) failed with %d.\n"), szPath, dwLastErr);
			//
			// LRS? retry forever!
			//
			::Sleep(100);
	        goto retry_FindFirstFile;
		}
    }

    //
    // Remove the \* at the end of the string
    //
    szPath[lstrlen(szPath)-2] = '\0';

	while(fMoreFiles)
    {
        //
        // construct the full file names
        //
        TCHAR szThisPath[MAX_PATH];
        lstrcpy(szThisPath, szPath);
        lstrcat(szThisPath, TEXT("\\"));
        lstrcat(szThisPath, findFileData.cFileName);

		HMODULE hModule;
		if (NULL == (hModule == ::LoadLibrary(szThisPath)))
		{
			_tprintf(  
				TEXT("LoadLibrary(%s): failed with %d.\n"), 
				szThisPath, GetLastError()
				);
		}
		else
		{
			_tprintf(  
				TEXT("LoadLibrary(%s): succeeded.\n"), szThisPath);
			::FreeLibrary(hModule);
		}

		HANDLE hProcess = CCorruptProcess::CreateProcess(szThisPath, NULL);
		if (hProcess)
		{
			::TerminateProcess(hProcess, -1);
		}

        if (FILE_ATTRIBUTE_DIRECTORY & findFileData.dwFileAttributes)
        {
			//
			// ignore the "." and ".." directories
			//
			if (0 == ::lstrcmp(TEXT("."), findFileData.cFileName))
			{
				goto NextFile;
			}
			if (0 == ::lstrcmp(TEXT(".."), findFileData.cFileName))
			{
				goto NextFile;
			}
			if (! RecursiveLoadLibrary(szThisPath))
			{
				_tprintf(TEXT("ERROR: RecursiveCompareTree(%s) failed.\n"), szThisPath);
				::FindClose(hFirstFile);
				goto out;
			}
		}

NextFile:
        //
        // continue with next file/folder
        //
		BOOL fFoundMoreFiles = TRUE;

retry_FindNextFile:
		fFoundMoreFiles = ::FindNextFile(
			hFirstFile,  // pointer to name of file to search for
			&findFileData  // pointer to returned information
			);
		if (!fFoundMoreFiles)
		{
			if (ERROR_NO_MORE_FILES == ::GetLastError())
			{
				fMoreFiles = false;
			}
			else
			{
				_tprintf(TEXT("ERROR: FindNextFile() failed with %d.\n"), ::GetLastError());
				//
				// LRS? retry forever!
				//
				::Sleep(100);
				goto retry_FindNextFile;
			}
		}
		else
		{
			;
		}
    }//while(fMoreFiles)

success:
	fReturn = true;
out:
    if (INVALID_HANDLE_VALUE != hFirstFile) ::FindClose(hFirstFile);
    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\acapi.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    acapi.h

Abstract:
    Falcon interface to the AC driver.

Author:
    Erez Haba (erezh) 25-Feb-96

--*/

#ifndef _ACAPI_H
#define _ACAPI_H

#include <portapi.h>

extern TCHAR g_wzDeviceName[];
#define MQAC_NAME g_wzDeviceName

//---------------------------------------------------------
//
// IMPLEMENTATION
//
//---------------------------------------------------------

//---------------------------------------------------------
//
// Falcon RT DLL interface to AC driver
//
//---------------------------------------------------------

inline
HRESULT
ACCreateHandle(
    PHANDLE phDevice
    )
{
    return MQpCreateFileW(
            MQAC_NAME,
            FILE_READ_ACCESS | FILE_WRITE_ACCESS,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            phDevice
            );
}

inline
HRESULT
ACCloseHandle(
    HANDLE hQueue
    )
{
    return MQpCloseHandle(hQueue);
}

//
//  Using this API, it is imposible to determine when the operation
//  is completed
//
inline
HRESULT
ACSendMessage(
    HANDLE hQueue,
    BOOL fCheckMachineQuota,
    CACTransferBuffer& tb
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_SEND_MESSAGE,
                0,
                fCheckMachineQuota,
                &tb,
                sizeof(tb)
                );
}

inline
HRESULT
ACSendMessage(
    HANDLE hQueue,
    CACTransferBuffer& tb,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_SEND_MESSAGE,
                0,
                TRUE,
                &tb,
                sizeof(tb),
                lpOverlapped
                );
}

inline
HRESULT
ACReceiveMessage(
    HANDLE hQueue,
    CACTransferBuffer& tb,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_RECEIVE_MESSAGE,
                &tb,
                sizeof(tb),
                0,
                0,
                lpOverlapped
                );
}

inline
HRESULT
ACCreateCursor(
    HANDLE hQueue,
    CACTransferBuffer& tb
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_CREATE_CURSOR,
                0,
                0,
                &tb,
                sizeof(tb)
                );
}

inline
HRESULT
ACCloseCursor(
    HANDLE hQueue,
    HANDLE hCursor
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_CLOSE_CURSOR,
                0,
                0,
                hCursor,
                0
                );
}

inline
HRESULT
ACSetCursorProperties(
    HANDLE hProxy,
    HANDLE hCursor,
    ULONG hRemoteCursor
    )
{
    return MQpDeviceIoControl(
                hProxy,
                IOCTL_AC_SET_CURSOR_PROPS,
                0,
                0,
                hCursor,
                hRemoteCursor
                );
}

inline
HRESULT
ACHandleToFormatName(
    HANDLE hQueue,
    LPWSTR lpwcsFormatName,
    LPDWORD lpdwFormatNameLength
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_HANDLE_TO_FORMAT_NAME,
                lpdwFormatNameLength,
                sizeof(DWORD),
                lpwcsFormatName,
                *lpdwFormatNameLength
                );
}

inline
HRESULT
ACPurgeQueue(
    HANDLE hQueue,
    BOOL fDelete
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_PURGE_QUEUE,
                0,
                fDelete,
                0,
                0
                );
}

//---------------------------------------------------------
//
// QM control APIs
//
//---------------------------------------------------------

inline
HRESULT
ACSetQueueProperties(
    HANDLE hQueue,
    BOOL fJournalQueue,
    BOOL fAuthenticate,
    ULONG ulPrivLevel,
    ULONG ulQuota,
    ULONG ulJournalQuota,
    LONG lBasePriority,
    BOOL fTransactionalQueue,
    const GUID* pgConnectorQM,
    BOOL fUnknownQueueType
    )
{
    CACSetQueueProperties qp = {
        fJournalQueue,
        fAuthenticate,
        ulPrivLevel,
        ulQuota,
        ulJournalQuota,
        lBasePriority,
        fTransactionalQueue,
        fUnknownQueueType,
        pgConnectorQM
    };

    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_SET_QUEUE_PROPS,
            0,
            0,
            &qp,
            sizeof(qp)
            );
}


inline
HRESULT
ACGetQueueProperties(
    HANDLE hQueue,
    CACGetQueueProperties& qp
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_GET_QUEUE_PROPS,
            0,
            0,
            &qp,
            sizeof(qp)
            );
}


inline
HRESULT
ACCreateQueue(
    BOOL fTargetQueue,
    const GUID* pDestGUID,
    const QUEUE_FORMAT* pQueueID,
    QueueCounters* pQueueCounters,
    LONGLONG liSeqID,
    ULONG ulSeqNo,
    PHANDLE phQueue
    )
{
    HRESULT rc;
    rc = ACCreateHandle(phQueue);

    if(FAILED(rc))
    {
        return rc;
    }

    CACCreateQueueParameters cqp = {
        fTargetQueue,
        pDestGUID,
        pQueueID,
        pQueueCounters,
        liSeqID,
        ulSeqNo,
    };

    rc = MQpDeviceIoControl(
            *phQueue,
            IOCTL_AC_CREATE_QUEUE,
            0,
            0,
            &cqp,
            sizeof(cqp)
            );

    if(FAILED(rc))
    {
        ACCloseHandle(*phQueue);
    }

    return rc;
}

inline
HRESULT
ACCreateRemoteProxy(
    const QUEUE_FORMAT* pQueueID,
    ULONG cli_pQMQueue,
    ULONG srv_pQMQueue,
    ULONG srv_hACQueue,
    ULONG hRPCContext,
    ULONG pCloseCS,
    PHANDLE phQueue
    )
{
    HRESULT rc;
    rc = ACCreateHandle(phQueue);

    if(FAILED(rc))
    {
        return rc;
    }

    CACCreateRemoteProxyParameters cpp = {
        pQueueID,
        cli_pQMQueue,
        (ULONG)*phQueue,
        srv_pQMQueue,
        srv_hACQueue,
        hRPCContext,
        pCloseCS
    };

    rc = MQpDeviceIoControl(
            *phQueue,
            IOCTL_AC_CREATE_REMOTE_PROXY,
            0,
            0,
            &cpp,
            sizeof(cpp)
            );

    if(FAILED(rc))
    {
        ACCloseHandle(*phQueue);
    }

    return rc;
}

inline
HRESULT
ACCreateTransaction(
    const XACTUOW* pXactUow,
    PHANDLE phQueue
    )
{
    HRESULT rc;
    rc = ACCreateHandle(phQueue);

    if(FAILED(rc))
    {
        return rc;
    }

    rc = MQpDeviceIoControl(
            *phQueue,
            IOCTL_AC_CREATE_TRANSACTION,
            0,
            0,
            const_cast<XACTUOW*>(pXactUow),
            sizeof(*pXactUow)
            );

    if(FAILED(rc))
    {
        ACCloseHandle(*phQueue);
    }

    return rc;
}

inline
HRESULT
ACGetServiceRequest(
    HANDLE hDevice,
    CACRequest* pRequest,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_GET_SERVICE_REQUEST,
            0,
            0,
            pRequest,
            sizeof(*pRequest),
            lpOverlapped
            );
}

inline
HRESULT
ACStorageCompleted(
    HANDLE hDevice,
    ULONG count,
    VOID* const* pCookieList,
    HRESULT result
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_STORE_COMPLETED,
            const_cast<VOID**>(pCookieList),
            count * sizeof(VOID*),
            (VOID*)result,
            0
            );
}

inline
HRESULT
ACAckingCompleted(
    HANDLE hDevice,
    const VOID* pCookie
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_ACKING_COMPLETED,
            0,
            0,
            const_cast<VOID*>(pCookie),
            0
            );
}

inline
HRESULT
ACXactGetInformation(
    HANDLE hXact,
    CACXactInformation *pInfo
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_GET_INFORMATION,
            0,
            0,
            pInfo,
            sizeof(*pInfo)
            );
}

inline
HRESULT
ACConnect(
    HANDLE hDevice,
    const GUID* pguidSourceQM,
    PWCHAR pStoragePath[AC_PATH_COUNT],
    ULONG ulMessageID,
    ULONG ulPoolSize,
    LONGLONG liSeqIDAtRestore,
    BOOL  fXactCompatibilityMode
    )
{
    
    CACConnectParameters cp;
    cp.pgSourceQM = pguidSourceQM;
    cp.ulMessageID = ulMessageID;
    cp.ulPoolSize = ulPoolSize;
    cp.liSeqIDAtRestore = liSeqIDAtRestore;
    cp.fXactCompatibilityMode = fXactCompatibilityMode;

    for(int i = 0; i < AC_PATH_COUNT; ++i)
    {
        cp.pStoragePath[i] = pStoragePath[i];
    }

    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_CONNECT,
            0,
            0,
            &cp,
            sizeof(cp)
            );
}

inline
HRESULT
ACSetMachineProperties(
    HANDLE hDevice,
    ULONG ulQuota
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_SET_MACHINE_PROPS,
            0,
            0,
            0,
            ulQuota
            );
}

inline
HRESULT
ACAssociateQueue(
    HANDLE hFromQueue,
    HANDLE hToQueue,
    ULONG DesiredAccess,
    ULONG ShareAccess
    )
{
    return MQpDeviceIoControl(
            hFromQueue,
            IOCTL_AC_ASSOCIATE_QUEUE,
            0,
            DesiredAccess,
            hToQueue,
            ShareAccess
            );
}

inline
HRESULT
ACAssociateJournal(
    HANDLE hFromQueue,
    HANDLE hToQueue,
    ULONG DesiredAccess,
    ULONG ShareAccess
    )
{
    return MQpDeviceIoControl(
            hFromQueue,
            IOCTL_AC_ASSOCIATE_JOURNAL,
            0,
            DesiredAccess,
            hToQueue,
            ShareAccess
            );
}

inline
HRESULT
ACAssociateDeadxact(
    HANDLE hFromQueue,
    HANDLE hToQueue,
    ULONG DesiredAccess,
    ULONG ShareAccess
    )
{
    return MQpDeviceIoControl(
            hFromQueue,
            IOCTL_AC_ASSOCIATE_DEADXACT,
            0,
            DesiredAccess,
            hToQueue,
            ShareAccess
            );
}

inline
HRESULT
ACPutRestoredPacket(
    HANDLE hQueue,
    PVOID lpPacket
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_PUT_RESTORED_PACKET,
            0,
            0,
            lpPacket,
            0
            );
}

inline
HRESULT
ACGetRestoredPacket(
    HANDLE hDriver,
    PVOID* lplpPacket
    )
{
    return MQpDeviceIoControl(
            hDriver,
            IOCTL_AC_GET_RESTORED_PACKET,
            0,
            0,
            lplpPacket,
            sizeof(*lplpPacket)
            );
}

inline
HRESULT
ACRestorePackets(
    HANDLE hDriver,
    PWSTR pLogPath,
    PWSTR pFilePath,
    ULONG ulFileID,
    ACPoolType pt
    )
{
    return MQpDeviceIoControl(
            hDriver,
            IOCTL_AC_RESTORE_PACKETS,
            pLogPath,
            pt,
            pFilePath,
            ulFileID
            );
}

inline
HRESULT
ACSetPerformanceBuffer(
    HANDLE hDriver,
    HANDLE hPerformanceSection,
    PVOID  pvPerformanceBuffer,
    QueueCounters *pMachineQueueCounters,
    QmCounters *pQmCounters
    )
{
    return MQpDeviceIoControl(
            hDriver,
            IOCTL_AC_SET_PERFORMANCE_BUFF,
            hPerformanceSection,
            reinterpret_cast<DWORD>(pQmCounters),
            pvPerformanceBuffer,
            reinterpret_cast<DWORD>(pMachineQueueCounters)
            );
}

inline
HRESULT
ACSendVerifiedMessage(
    HANDLE hQueue,
    CACTransferBuffer& tb,
    WORD wAck,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_SEND_VERIFIED_MESSAGE,
                0,
                (DWORD)wAck,
                &tb,
                sizeof(tb),
                lpOverlapped
                );
}

inline
HRESULT
ACReleaseResources(
    HANDLE hDevice
    )
{
    return MQpDeviceIoControl(
                hDevice,
                IOCTL_AC_RELEASE_RESOURCES,
                0,
                0,
                0,
                0
                );
}


inline
HRESULT
ACConvertPacket(
	HANDLE hDriver,
	LPVOID pPacket,
	LPOVERLAPPED lpOverlapped
	)
{
   return MQpDeviceIoControl(
				hDriver,
                IOCTL_AC_CONVERT_PACKET,
                0,
                0,
                pPacket,
                0,
                lpOverlapped
                );
}

//---------------------------------------------------------
//
// QM network interface APIs
//
//---------------------------------------------------------

inline
HRESULT
ACAllocatePacket(
    HANDLE hDevice,
    ACPoolType pt,
    DWORD dwSize,
    PVOID* ppPacket,
    BOOL fCheckMachineQuota = TRUE
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_ALLOCATE_PACKET,
            reinterpret_cast<PVOID>(fCheckMachineQuota),
            pt,
            ppPacket,
            dwSize
            );
}

inline
HRESULT
ACFreePacket(
    HANDLE hDevice,
    PVOID lpPacket,
    USHORT usClass = 0
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_FREE_PACKET,
            0,
            0,
            lpPacket,
            usClass
            );
}

inline
HRESULT
ACFreePacket1(
    HANDLE hDevice,
    const VOID* pCookie,
    USHORT usClass = 0
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_FREE_PACKET1,
            0,
            0,
            const_cast<VOID*>(pCookie),
            usClass
            );
}

inline
HRESULT
ACArmPacketTimer(
    HANDLE hDevice,
    const VOID* pCookie,
    BOOL fTimeToBeReceived,
    ULONG ulDelay
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_ARM_PACKET_TIMER,
            0,
            ulDelay,
            const_cast<VOID*>(pCookie),
            fTimeToBeReceived
            );
}

//
//  Using this API, it is imposible to determine when the operation
//  is completed
//
inline
HRESULT
ACPutPacket(
    HANDLE hQueue,
    PVOID lpPacket
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_PUT_PACKET,
            0,
            0,
            lpPacket,
            0
            );
}

//
//  Asynchronous, using an overlapped
//
inline
HRESULT
ACPutPacket(
    HANDLE hQueue,
    PVOID lpPacket,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_PUT_PACKET,
            0,
            0,
            lpPacket,
            0,
            lpOverlapped
            );
}

//
//  Asynchronous, using an overlapped;  with Receive setting
//
inline
HRESULT
ACPutPacket1(
    HANDLE hQueue,
    PVOID lpPacket,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_PUT_PACKET1,
            0,
            0,
            lpPacket,
            0,
            lpOverlapped
            );
}

inline
HRESULT
ACGetPacket(
    HANDLE hQueue,
    PVOID* lplpPacket,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_GET_PACKET,
            0,
            0,
            lplpPacket,
            sizeof(*lplpPacket),
            lpOverlapped
            );
}

inline
HRESULT
ACCreateGroup(
    PHANDLE phGroup
    )
{
    HRESULT rc;
    rc = MQpCreateFileW(
            MQAC_NAME,
            GENERIC_READ,
            FILE_SHARE_READ,
            0,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            phGroup
            );

    if(FAILED(rc))
    {
        return rc;
    }

    rc = MQpDeviceIoControl(
            *phGroup,
            IOCTL_AC_CREATE_GROUP,
            0,
            0,
            0,
            0
            );

    if(FAILED(rc))
    {
        ACCloseHandle(*phGroup);
    }

    return rc;
}

inline
HRESULT
ACCanCloseQueue(
    HANDLE hQueue
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_CAN_CLOSE_QUEUE,
            0,
            0,
            0,
            0
            );
}

inline
HRESULT
ACMoveQueueToGroup(
    HANDLE hQueue,
    HANDLE hGroup
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_MOVE_QUEUE_TO_GROUP,
            0,
            0,
            hGroup,
            0
            );
}

//----------------------------------------------------
//
//   APIs for remote reading.
//
//----------------------------------------------------

inline
HRESULT
ACBeginGetPacket2Remote(
    HANDLE hQueue,
    CACGet2Remote& g2r,
    PVOID* lplpPacket,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_BEGIN_GET_PACKET_2REMOTE,
            &g2r,
            sizeof(g2r),
            lplpPacket,
            sizeof(*lplpPacket),
            lpOverlapped
            );
}

inline
HRESULT
ACEndGetPacket2Remote(
    HANDLE hQueue,
    CACGet2Remote& g2r
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_END_GET_PACKET_2REMOTE,
            0,
            0,
            &g2r,
            sizeof(g2r)
            );
}

inline
HRESULT
ACCancelRequest(
    HANDLE hQueue,
    NTSTATUS status,
    ULONG ulTag
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_CANCEL_REQUEST,
            0,
            status,
            0,
            ulTag
            );
}

inline
HRESULT
ACPutRemotePacket(
    HANDLE hQueue,
    ULONG ulTag,
    PVOID lpPacket
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_PUT_REMOTE_PACKET,
            0,
            0,
            lpPacket,
            ulTag
            );
}

//----------------------------------------------------
//
//   APIs for transaction processing
//
//----------------------------------------------------


inline
HRESULT
ACXactCommit1(
    HANDLE hXact,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_COMMIT1,
            0,
            0,
            0,
            0,
            lpOverlapped
            );
}

inline
HRESULT
ACXactCommit2(
    HANDLE hXact,
	LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_COMMIT2,
            0,
            0,
            0,
			0,
            lpOverlapped
            );
}

inline
HRESULT
ACXactCommit3(
    HANDLE hXact
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_COMMIT3,
            0,
            0,
            0,
			0
            );
}

inline
HRESULT
ACXactAbort1(
    HANDLE hXact,
	LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_ABORT1,
            0,
            0,
            0,
			0,
            lpOverlapped
            );
}

inline
HRESULT
ACXactAbort2(
    HANDLE hXact
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_ABORT2,
            0,
            0,
            0,
			0
            );
}


inline
HRESULT
ACXactPrepare(
    HANDLE hXact,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_PREPARE,
            0,
            0,
            0,
            0,
            lpOverlapped
            );
}

inline
HRESULT
ACXactPrepareDefaultCommit(
    HANDLE hXact,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_PREPARE_DEFAULT_COMMIT,
            0,
            0,
            0,
            0,
            lpOverlapped
            );
}

inline
HRESULT
ACXactSetClass(
    HANDLE hDevice,
    OBJECTID* pMessageID,
    UCHAR bClass
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_XACT_SET_CLASS,
            0,
            bClass,
            pMessageID,
            sizeof(*pMessageID)
            );
}

#endif // _ACAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\acdef.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    acdef.h

Abstract:
    Falcon interface stractures used by the AC driver.

Author:
    Erez Haba (erezh) 25-Feb-96

Note:
    This file is compiled in Kernel Mode and User Mode.

--*/

#ifndef _ACDEF_H
#define _ACDEF_H

#include <mqperf.h>
#include <xactdefs.h>

//
//  Number of pools used for storage
//  Reliable, Persistant, Journal, Deadletter
//
enum ACPoolType {
    ptReliable,
    ptPersistent,
    ptJournal,
    ptLastPool
};

//
//  Path count is pool count plus one for the log path
//
#define AC_PATH_COUNT (ptLastPool + 1)

//---------------------------------------------------------
//
//  class CACTransferBuffer
//  Falcon RT DLL interface to AC driver
//
//---------------------------------------------------------

#include "trnsbufr.h"

//---------------------------------------------------------
//
//  class CACRequest
//  AC Request packet passed from AC to QM
//
//---------------------------------------------------------

#pragma pack(push,1)

//
//  Context used by remote reader, stored in CProxy
//
struct CRRContext {
    ULONG cli_pQMQueue;     // pointer to qm machine 'queue'
    ULONG cli_hACQueue;     // local qm handle to ac queue
    ULONG srv_pQMQueue;     // remote qm queue object
    ULONG srv_hACQueue;     // remote qm handle to ac queue
    ULONG hRPCContext;      // rpc context used
    ULONG pCloseCS;         // local qm critical seciton pointer
};

class CACRequest {
public:

    enum RequestFunction {
        rfAck,
        rfStorage,
        rfMessageID,
        rfRemoteRead,
        rfRemoteCancelRead,
        rfRemoteCloseQueue,
        rfRemoteCloseCursor,
        rfRemotePurgeQueue,
        rfTimeout,
        rfEventLog,
    };

    CACRequest(RequestFunction _rf);

public:
    LIST_ENTRY m_link;

    RequestFunction rf;

    union {

        //
        //
        //
        struct {
            ACPoolType pt;
            BOOL fSuccess;
            ULONG ulFileCount;
        } EventLog;

        //
        //  Save message ID request
        //
        struct {
            ULONG Value;
        } MessageID;

        //
        //  Storage request
        //
        struct {
            PVOID pPacket;
            PVOID pCookie;
            PVOID pAllocator;
			ULONG ulSize;
        } Storage;

             //
        //  Timeout request (xact)
        //
        struct {
            PVOID pPacket;
            PVOID pCookie;
            BOOL fTimeToBeReceived;
        } Timeout;

        //
        //  ACK/NACK request
        //
        struct {
            PVOID pPacket;
            PVOID pCookie;
            ULONG ulClass;
            BOOL fUser;
            BOOL fOrder;
        } Ack;

        //
        //  Remote requests
        //
        struct {

            //
            //  context needed for all requests
            //
            CRRContext Context;

            union {
                //
                //  Receive/Peek request
                //
                struct {
                    ULONG ulTag;            // request identifier
                    ULONG hRemoteCursor;
                    ULONG ulAction;
                    ULONG ulTimeout;
                } Read;

                //
                //  Cancel remote read request
                //
                struct {
                    ULONG ulTag;        // request identifier
                } CancelRead;

                //
                //  Close remote queue request
                //
                struct {
                } CloseQueue;

                //
                //  Close remote cursor request
                //
                struct {
                    ULONG hRemoteCursor;
                } CloseCursor;

                //
                //  Purge remote queue request
                //
                struct {
                } PurgeQueue;
            };
        } Remote;
    };
};

inline CACRequest::CACRequest(RequestFunction _rf)
{
    rf = _rf;
}

//---------------------------------------------------------
//
//  class CACCreateQueueParameters
//
//---------------------------------------------------------

class CACCreateQueueParameters {
public:
    BOOL fTargetQueue;
    const GUID* pDestGUID;
    const QUEUE_FORMAT* pQueueID;
    QueueCounters* pQueueCounters;
    LONGLONG liSeqID;               // Note: align on 8
    ULONG ulSeqN;
};

//---------------------------------------------------------
//
//  struct CACSetQueueProperties
//
//---------------------------------------------------------

struct CACSetQueueProperties {
    BOOL fJournalQueue;
    BOOL fAuthenticate;
    ULONG ulPrivLevel;
    ULONG ulQuota;
    ULONG ulJournalQuota;
    LONG lBasePriority;
    BOOL fTransactional;
    BOOL fUnknownType;
    const GUID* pgConnectorQM;
};


//---------------------------------------------------------
//
//  struct CACGetQueueProperties
//
//---------------------------------------------------------

struct CACGetQueueProperties {
    ULONG ulCount;
    ULONG ulQuotaUsed;
    ULONG ulJournalCount;
    ULONG ulJournalQuotaUsed;
    ULONG ulPrevNo;
    ULONG ulSeqNo;
    LONGLONG liSeqID;
};

//---------------------------------------------------------
//
//  class CACRemoteProxyProp
//
//---------------------------------------------------------

class CACCreateRemoteProxyParameters {
public:
    const QUEUE_FORMAT* pQueueID;
    CRRContext Context;
};

//---------------------------------------------------------
//
//  class CACGet2Remote
//
//---------------------------------------------------------

class CACGet2Remote {
public:
   ULONG  RequestTimeout;
   ULONG  Action;
   HANDLE Cursor;
   PVOID  lpPacket;
   ULONG* pTag;
};

//---------------------------------------------------------
//
//  class CACConnect
//
//---------------------------------------------------------

class CACConnectParameters {
public:
   const GUID* pgSourceQM;
   ULONG ulMessageID;
   ULONG ulPoolSize;
   PWCHAR pStoragePath[AC_PATH_COUNT];
   LONGLONG liSeqIDAtRestore;
   BOOL   fXactCompatibilityMode;
};

//---------------------------------------------------------
//
//  class CACXactInformation
//
//---------------------------------------------------------

class CACXactInformation {
public:
   	ULONG nReceives;
	ULONG nSends;
};

#pragma pack(pop)

#endif // _ACDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\batteryioctl.h ===
#ifndef __BATTERY_IOCTL_H
#define __BATTERY_IOCTL_H

//#include "IOCTL.h"


class CIoctlBattery : public CIoctl
{
public:
    CIoctlBattery(CDevice *pDevice): CIoctl(pDevice){;};
    virtual ~CIoctlBattery(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

private:
	ULONG m_aulTag[MAX_NUM_OF_REMEMBERED_ITEMS];
	void AddTag(ULONG ulTag);
	ULONG GetRandom_Tag();
	static int GetRandom_QueryInformationLevel();
	static int GetRandom_SetInformationLevel();

};




#endif //__BATTERY_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\afddeviceioctl.h ===
#ifndef __AFD_DEVICE_IOCTL_H
#define __AFD_DEVICE_IOCTL_H

//#include "IOCTL.h"
#include "SocketIOCTL.h"


class CIoctlAfdDevice : public CIoctlSocket
{
public:
    CIoctlAfdDevice(CDevice *pDevice);
    virtual ~CIoctlAfdDevice();

	HANDLE CreateDevice(CDevice *pDevice);
	BOOL CloseDevice(CDevice *pDevice);

	virtual BOOL DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		);
	virtual BOOL DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		);
	virtual BOOL DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		);
	virtual BOOL DeviceCancelIo(
		HANDLE hFile  // file handle for which to cancel I/O
		);

};




#endif //__AFD_DEVICE_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\batterioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*


#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
*/
#include <batclass.h>

#include "BatteryIOCTL.h"

static bool s_fVerbose = false;

void CIoctlBattery::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
	switch(dwIOCTL)
	{
	case IOCTL_BATTERY_QUERY_TAG:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);

		{
			AddTag(*((ULONG*)abOutBuffer));
		}
		break;
	}
}

void CIoctlBattery::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
    switch(dwIOCTL)
    {
    case IOCTL_BATTERY_QUERY_TAG:
		//
		// wait
		//
        *((ULONG*)abInBuffer) = rand()%2 ? rand() : rand()%2 ? 0 : rand()%2 ? DWORD_RAND : 0xffffffff;

        SetInParam(dwInBuff, sizeof(ULONG));

		SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG));

        break;

    case IOCTL_BATTERY_QUERY_INFORMATION:
        ((BATTERY_QUERY_INFORMATION*)abInBuffer)->BatteryTag = GetRandom_Tag();
        ((BATTERY_QUERY_INFORMATION*)abInBuffer)->InformationLevel = (BATTERY_QUERY_INFORMATION_LEVEL)GetRandom_QueryInformationLevel();
        //((BATTERY_QUERY_INFORMATION*)abInBuffer)->AtRate = GetRandom_AtRate();

        SetInParam(dwInBuff, sizeof(BATTERY_QUERY_INFORMATION));

        SetOutParam(abOutBuffer, dwOutBuff, rand()%1000);//variable size
		// do not think i need the output buffer

        break;

    case IOCTL_BATTERY_SET_INFORMATION:
        ((BATTERY_SET_INFORMATION*)abInBuffer)->BatteryTag = GetRandom_Tag();
        ((BATTERY_SET_INFORMATION*)abInBuffer)->InformationLevel = (BATTERY_SET_INFORMATION_LEVEL)GetRandom_SetInformationLevel();
        //SetRandom_Buffer(((BATTERY_SET_INFORMATION*)abInBuffer)->Buffer);

        SetInParam(dwInBuff, sizeof(BATTERY_SET_INFORMATION));

        SetOutParam(abOutBuffer, dwOutBuff, 0);//must be 0!

        break;

    case IOCTL_BATTERY_QUERY_STATUS:
        ((BATTERY_WAIT_STATUS*)abInBuffer)->BatteryTag = GetRandom_Tag();
        ((BATTERY_WAIT_STATUS*)abInBuffer)->Timeout = rand()%10 ? 0 : DWORD_RAND;
        ((BATTERY_WAIT_STATUS*)abInBuffer)->PowerState = rand()%10 ? 0 : DWORD_RAND;
        ((BATTERY_WAIT_STATUS*)abInBuffer)->LowCapacity = rand()%10 ? 0 : DWORD_RAND;
        ((BATTERY_WAIT_STATUS*)abInBuffer)->HighCapacity = rand()%10 ? 0 : DWORD_RAND;

        SetInParam(dwInBuff, sizeof(BATTERY_WAIT_STATUS));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(BATTERY_STATUS));
		// do not think i need the output buffer

        break;

    default:
		_ASSERTE(FALSE);
        SetInParam(dwInBuff, rand());
        SetOutParam(abOutBuffer, dwOutBuff, rand());
    }
}


BOOL CIoctlBattery::FindValidIOCTLs(CDevice *pDevice)
{
    AddIOCTL(pDevice, IOCTL_BATTERY_QUERY_TAG);
    AddIOCTL(pDevice, IOCTL_BATTERY_QUERY_INFORMATION);
    AddIOCTL(pDevice, IOCTL_BATTERY_SET_INFORMATION);
    AddIOCTL(pDevice, IOCTL_BATTERY_QUERY_STATUS);

    return TRUE;
}


void CIoctlBattery::CallRandomWin32API(LPOVERLAPPED pOL)
{
	return;
}


void CIoctlBattery::AddTag(ULONG ulTag)
{
	m_aulTag[rand()%MAX_NUM_OF_REMEMBERED_ITEMS] = ulTag;
}

ULONG CIoctlBattery::GetRandom_Tag()
{
	if (0 == rand()%40) return DWORD_RAND;
	return (m_aulTag[rand()%MAX_NUM_OF_REMEMBERED_ITEMS]);
}

int CIoctlBattery::GetRandom_QueryInformationLevel()
{
	switch(rand()%10)
	{
	case 0: return BatteryInformation;
	case 1: return BatteryGranularityInformation;
	case 2: return BatteryTemperature;
	case 3: return BatteryEstimatedTime;
	case 4: return BatteryDeviceName;
	case 5: return BatteryManufactureDate;
	case 6: return BatteryManufactureName;
	case 7: return BatteryUniqueID;
	case 8: return BatterySerialNumber;
	default: return (rand()%100 - 50);
	}
}

int CIoctlBattery::GetRandom_SetInformationLevel()
{
	switch(rand()%4)
	{
	case 0: return BatteryCriticalBias;
	case 1: return BatteryCharge;
	case 2: return BatteryDischarge;
	default: return (rand()%100 - 50);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\afddeviceioctl.cpp ===
#include "pch.h"
#pragma hdrstop
/*
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

#include <windows.h>

#include "NtNativeIOCTL.h"
*/
#include "AfdDeviceIOCTL.h"

static bool s_fVerbose = false;


CIoctlAfdDevice::CIoctlAfdDevice(CDevice *pDevice): 
	CIoctlSocket(pDevice)
{
	;
}

CIoctlAfdDevice::~CIoctlAfdDevice()
{
    ;
}


HANDLE CIoctlAfdDevice::CreateDevice(CDevice *pDevice)
{    
	return CIoctlNtNative::StaticCreateDevice(pDevice);
}


BOOL CIoctlAfdDevice::CloseDevice(CDevice *pDevice)
{
	return CIoctlNtNative::StaticCloseDevice(pDevice);
}

inline BOOL CIoctlAfdDevice::DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		)
{
	return CIoctlNtNative::StaticDeviceWriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
}
inline BOOL CIoctlAfdDevice::DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		)
{
	return CIoctlNtNative::StaticDeviceReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
}


inline BOOL CIoctlAfdDevice::DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		)
{
	return CIoctlNtNative::StaticDeviceInputOutputControl(
		hDevice,              // handle to a device, file, or directory 
		dwIoControlCode,       // control code of operation to perform
		lpInBuffer,           // pointer to buffer to supply input data
		nInBufferSize,         // size, in bytes, of input buffer
		lpOutBuffer,          // pointer to buffer to receive output data
		nOutBufferSize,        // size, in bytes, of output buffer
		lpBytesReturned,     // pointer to variable to receive byte count
		lpOverlapped    // pointer to structure for asynchronous operation
		);
}

inline BOOL CIoctlAfdDevice::DeviceCancelIo(
	HANDLE hFile  // file handle for which to cancel I/O
	)
{
	return CIoctlNtNative::StaticDeviceCancelIo(hFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\beepioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*


#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
*/
#include <ntddbeep.h>
#include "BeepIOCTL.h"

static bool s_fVerbose = false;

void CIoctlBeep::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    ;
}

void CIoctlBeep::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
    //
    // fill random data & len
    //
    if (rand()%20 == 0)
    {
        FillBufferWithRandomData(abInBuffer, dwInBuff);
        FillBufferWithRandomData(abOutBuffer, dwOutBuff);
        return;
    }

    //
    // NULL pointer variations
    //
    if (rand()%20 == 0)
    {
        abInBuffer = NULL;
        return;
    }
    if (rand()%20 == 0)
    {
        abOutBuffer = NULL;
        return;
    }
    if (rand()%20 == 0)
    {
        abInBuffer = NULL;
        abOutBuffer = NULL;
        return;
    }

    //
    // 0 size variations
    //
    if (rand()%20 == 0)
    {
        dwInBuff = NULL;
        return;
    }
    if (rand()%20 == 0)
    {
        dwOutBuff = NULL;
        return;
    }
    if (rand()%20 == 0)
    {
        dwInBuff = NULL;
        dwOutBuff = NULL;
        return;
    }

    switch(dwIOCTL)
    {
    case IOCTL_BEEP_SET:
/*
typedef struct _BEEP_SET_PARAMETERS {
    ULONG Frequency;
    ULONG Duration;
} BEEP_SET_PARAMETERS, *PBEEP_SET_PARAMETERS;
*/
        ((PBEEP_SET_PARAMETERS)abInBuffer)->Frequency = DWORD_RAND;
        ((PBEEP_SET_PARAMETERS)abInBuffer)->Duration = DWORD_RAND;

        SetInParam(dwInBuff, sizeof(BEEP_SET_PARAMETERS));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(BEEP_SET_PARAMETERS));

        break;

    default:
        ;
    }

}


BOOL CIoctlBeep::FindValidIOCTLs(
    CDevice *pDevice
    )
{
    AddIOCTL(pDevice, IOCTL_BEEP_SET);

    return TRUE;
}



void CIoctlBeep::CallRandomWin32API(LPOVERLAPPED pOL)
{
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\acioctl.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    acioctl.h

Abstract:

    Type definitions and data for Falcon AC driver

Author:

    Erez Haba (erezh) 1-Aug-95

Revision History:
--*/

#ifndef __ACIOCTL_H
#define __ACIOCTL_H

extern "C"
{
#include <devioctl.h>
}

//-- constants --------------------------------------------
//
//  Falcon Access Control unique identifier
//
//
#define FILE_DEVICE_MQAC 0x1965    //BUGBUG: find a number

//
//  Falcon IO control codes
//


//---------------------------------------------------------
//
//  RT INTERFACE TO AC DRIVER
//
//---------------------------------------------------------

//
//  Message apis
//
#define IOCTL_AC_SEND_MESSAGE               CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x011, \
                                                METHOD_NEITHER, \
                                                FILE_WRITE_ACCESS)

#define IOCTL_AC_RECEIVE_MESSAGE            CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x012, \
                                                METHOD_BUFFERED, \
                                                FILE_READ_ACCESS)

//
//  Queue apis
//
#define IOCTL_AC_HANDLE_TO_FORMAT_NAME      CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x013, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_PURGE_QUEUE                CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x014, \
                                                METHOD_NEITHER, \
                                                FILE_READ_ACCESS)

//
//  Cursor apis
//
#define IOCTL_AC_CREATE_CURSOR              CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x021, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_CLOSE_CURSOR               CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x022, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_SET_CURSOR_PROPS           CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x023, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

//---------------------------------------------------------
//
//  QM INTERFACE TO AC DRIVER
//
//---------------------------------------------------------

//
//  QM Control apis
//

//---------------------------------------------------------
//
//  NOTE: CONNECT must be first QM ioctl
//
#define IOCTL_AC_CONNECT                    CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x101, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)
//
//---------------------------------------------------------

#define IOCTL_AC_SET_PERFORMANCE_BUFF       CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x102, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_SET_MACHINE_PROPS          CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x103, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_GET_SERVICE_REQUEST        CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x104, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_STORE_COMPLETED            CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x106, \
                                                METHOD_BUFFERED, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_ACKING_COMPLETED           CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x107, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_CAN_CLOSE_QUEUE            CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x111, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_SET_QUEUE_PROPS            CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x112, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_ASSOCIATE_QUEUE            CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x113, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_ASSOCIATE_JOURNAL          CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x114, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_ASSOCIATE_DEADXACT         CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x115, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_PUT_RESTORED_PACKET        CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x116, \
                                                METHOD_NEITHER, \
                                                FILE_WRITE_ACCESS)

#define IOCTL_AC_GET_RESTORED_PACKET        CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x117, \
                                                METHOD_NEITHER, \
                                                FILE_READ_ACCESS)

#define IOCTL_AC_RESTORE_PACKETS            CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x118, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_CREATE_QUEUE               CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x120, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_CREATE_GROUP               CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x121, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_SEND_VERIFIED_MESSAGE      CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x122, \
                                                METHOD_NEITHER, \
                                                FILE_WRITE_ACCESS)

#define IOCTL_AC_RELEASE_RESOURCES          CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x123, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_GET_QUEUE_PROPS            CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x124, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_CONVERT_PACKET				CTL_CODE(FILE_DEVICE_MQAC, \
												0x125, \
												METHOD_NEITHER, \
												FILE_ANY_ACCESS)

//
//  QM Network interface apis
//
#define IOCTL_AC_ALLOCATE_PACKET            CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x201, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_FREE_PACKET                CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x202, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_PUT_PACKET                 CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x203, \
                                                METHOD_NEITHER, \
                                                FILE_WRITE_ACCESS)

#define IOCTL_AC_GET_PACKET                 CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x204, \
                                                METHOD_BUFFERED, \
                                                FILE_READ_ACCESS)

#define IOCTL_AC_MOVE_QUEUE_TO_GROUP        CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x213, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

//
//  QM remote read apis
//
#define IOCTL_AC_CREATE_REMOTE_PROXY        CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x221, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_BEGIN_GET_PACKET_2REMOTE   CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x222, \
                                                METHOD_BUFFERED, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_END_GET_PACKET_2REMOTE     CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x223, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_CANCEL_REQUEST             CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x224, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_PUT_REMOTE_PACKET          CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x225, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

//
//  QM transactions apis
//
#define IOCTL_AC_CREATE_TRANSACTION         CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x231, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_COMMIT1               CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x232, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_COMMIT2               CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x233, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_ABORT1                CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x234, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_PREPARE               CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x235, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_PREPARE_DEFAULT_COMMIT   CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x236, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)


#define IOCTL_AC_PUT_PACKET1                CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x237, \
                                                METHOD_NEITHER, \
                                                FILE_WRITE_ACCESS)

#define IOCTL_AC_XACT_SET_CLASS             CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x238, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_GET_INFORMATION       CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x239, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_FREE_PACKET1               CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x23a, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_ARM_PACKET_TIMER           CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x23b, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_COMMIT3               CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x23c, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_ABORT2                CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x23d, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)



//
//  Control panel apis
//
#define IOCTL_AC_FREE_HEAPS                 CTL_CODE(FILE_DEVICE_MQAC, \
                                                0x250, \
                                                METHOD_NEITHER, \
                                                FILE_ANY_ACCESS)

#endif // __ACIOCTL_H 3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\beepioctl.h ===
#ifndef __BEEP_IOCTL_H
#define __BEEP_IOCTL_H

//#include "IOCTL.h"


class CIoctlBeep : public CIoctl
{
public:
    CIoctlBeep(CDevice *pDevice): CIoctl(pDevice){;};
    virtual ~CIoctlBeep(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

};




#endif //__BEEP_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\browserioctl.h ===
#ifndef __BROWSER_IOCTL_H
#define __BROWSER_IOCTL_H

//#include "NtNativeIOCTL.h"

#include <ntddbrow.h>
#include <lmserver.h>

class CIoctlBrowser : public CIoctlNtNative
{
public:
    CIoctlBrowser(CDevice *pDevice);
    virtual ~CIoctlBrowser(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);
/*
	virtual HANDLE CreateDevice(CDevice *pDevice);

	virtual BOOL CloseDevice(CDevice *pDevice);

	virtual BOOL DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		);

	virtual BOOL DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		);
	virtual BOOL DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		);

	virtual BOOL DeviceCancelIo(
		HANDLE hFile  // file handle for which to cancel I/O
		);
*/

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

private:

#define NUM_OF_RESUME_HANDLES (16)
	ULONG m_aResumeHandle[NUM_OF_RESUME_HANDLES];
	ULONG m_LastResumeHandle;

	void FillCommonPartOf_LMDR_REQUEST_PACKET_WithRandomValues(LMDR_REQUEST_PACKET *pPacket);

	void Fill_LMDR_REQUEST_PACKET_WithRandom_Start(LMDR_REQUEST_PACKET *pPacket);

	void Fill_LMDR_REQUEST_PACKET_WithRandom_AddDelName(LMDR_REQUEST_PACKET *pPacket);

	void Fill_LMDR_REQUEST_PACKET_WithRandom_EnumerateNames(LMDR_REQUEST_PACKET *pPacket);

	void Fill_LMDR_REQUEST_PACKET_WithRandom_EnumerateServers(LMDR_REQUEST_PACKET *pPacket);

	void Fill_LMDR_REQUEST_PACKET_WithRandom_EnumerateTransports(LMDR_REQUEST_PACKET *pPacket);

	void Fill_LMDR_REQUEST_PACKET_WithRandom_Bind(LMDR_REQUEST_PACKET *pPacket);

	void Fill_LMDR_REQUEST_PACKET_WithRandom_GetBrowserServerList(LMDR_REQUEST_PACKET *pPacket);

	void Fill_LMDR_REQUEST_PACKET_WithRandom_WaitForMasterAnnouncement(LMDR_REQUEST_PACKET *pPacket);

	void Fill_LMDR_REQUEST_PACKET_WithRandom_GetMasterName(LMDR_REQUEST_PACKET *pPacket);

	void Fill_LMDR_REQUEST_PACKET_WithRandom_SendDatagram(LMDR_REQUEST_PACKET *pPacket);

	void Fill_LMDR_REQUEST_PACKET_WithRandom_UpdateStatus(LMDR_REQUEST_PACKET *pPacket);

	void Fill_LMDR_REQUEST_PACKET_WithRandom_ChangeRole(LMDR_REQUEST_PACKET *pPacket);

	void Fill_LMDR_REQUEST_PACKET_NetlogonMailslotEnable(LMDR_REQUEST_PACKET *pPacket);

	void Fill_LMDR_REQUEST_PACKET_EnableDisableTransport(LMDR_REQUEST_PACKET *pPacket);

	void Fill_LMDR_REQUEST_PACKET_DomainRename(LMDR_REQUEST_PACKET *pPacket);

	IOCTL_LMDR_STRUCTURES GetRandomStructureType();

	ULONG GetRandomStructureVersion();

	LUID GetRandomLogonId();

	UNICODE_STRING GetRandomEmulatedDomainName();

	ULONG GetRandomNumberOfMailslotBuffers();

	ULONG GetRandomNumberOfServerAnnounceBuffers();

	ULONG GetRandomIllegalDatagramThreshold();

	ULONG GetRandomEventLogResetFrequency();

	BOOLEAN GetRandomLogElectionPackets();

	BOOLEAN GetRandomIsLanManNt();

	DGRECEIVER_NAME_TYPE GetRandom_DGReceiverNameType();

	void SetRandomAddDelName_Name(WCHAR *wszName);
	WCHAR * GetRandomMachineName();

	ULONG GetRandomResumeHandle();

	ULONG GetRandomServerType();

	void SetRandomDomainName(WCHAR *wszName);

	void SetRandomTransportName(WCHAR *wszName);

	WCHAR* GetRandomTransportName_WCHAR();

	UNICODE_STRING GetRandomTransportName_UNICODE_STRING();

	void SetRandomTransport_SendDatagram_Name(WCHAR *wszName);

	ULONG GetRandomLevel();

};




#endif //__BROWSER_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\cdioctl.h ===
#ifndef __CD_IOCTL_H
#define __CD_IOCTL_H

//#include "IOCTL.h"


class CIoctlCD : public CIoctl
{
public:
    CIoctlCD(CDevice *pDevice): CIoctl(pDevice){;};
    virtual ~CIoctlCD(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

};




#endif //__CD_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\cioctlfactory.h ===
#ifndef __IOCTL_FACTORY_H
#define __IOCTL_FACTORY_H

//#include "IOCTL.h"

CIoctl* CreateIoctlObject(CDevice *pDevice);


#endif //__IOCTL_FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\cdioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*


#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
*/
#include <ntddcdrm.h>

#include "CDIOCTL.h"

static bool s_fVerbose = false;

void CIoctlCD::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    ;
}

void CIoctlCD::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
/*
    switch(dwIOCTL)
    {
    case IOCTL_CDROM_UNLOAD_DRIVER:
//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// This IOCTL is used to to create an interface in the filter driver. It    //
// takes in an index and an opaque context. It creates an interface,        //
// associates the index and context with it and returns a context for this  //
// created interface. All future IOCTLS require this context that is passed // 
// out                                                                      //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////
typedef struct _FILTER_DRIVER_CREATE_INTERFACE
{
    IN    DWORD   dwIfIndex;
    IN    DWORD   dwAdapterId;
    IN    PVOID   pvRtrMgrContext;
    OUT   PVOID   pvDriverContext;
}FILTER_DRIVER_CREATE_INTERFACE, *PFILTER_DRIVER_CREATE_INTERFACE;
        FillFilterDriverCreateInterface((PFILTER_DRIVER_CREATE_INTERFACE)abInBuffer);

        SetInParam(dwInBuff, sizeof(FILTER_DRIVER_CREATE_INTERFACE));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(PVOID));

        break;
*/
    CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
}


BOOL CIoctlCD::FindValidIOCTLs(CDevice *pDevice)
{
    AddIOCTL(pDevice, IOCTL_CDROM_UNLOAD_DRIVER);
    AddIOCTL(pDevice, IOCTL_CDROM_READ_TOC);
    AddIOCTL(pDevice, IOCTL_CDROM_GET_CONTROL);
    AddIOCTL(pDevice, IOCTL_CDROM_PLAY_AUDIO_MSF);
    AddIOCTL(pDevice, IOCTL_CDROM_SEEK_AUDIO_MSF);
    AddIOCTL(pDevice, IOCTL_CDROM_STOP_AUDIO);
    AddIOCTL(pDevice, IOCTL_CDROM_PAUSE_AUDIO);
    AddIOCTL(pDevice, IOCTL_CDROM_RESUME_AUDIO);
    AddIOCTL(pDevice, IOCTL_CDROM_GET_VOLUME);
    AddIOCTL(pDevice, IOCTL_CDROM_SET_VOLUME);
    AddIOCTL(pDevice, IOCTL_CDROM_READ_Q_CHANNEL);
    AddIOCTL(pDevice, IOCTL_CDROM_GET_LAST_SESSION);
    AddIOCTL(pDevice, IOCTL_CDROM_RAW_READ);
    AddIOCTL(pDevice, IOCTL_CDROM_DISK_TYPE);
    AddIOCTL(pDevice, IOCTL_CDROM_GET_DRIVE_GEOMETRY);
    AddIOCTL(pDevice, IOCTL_CDROM_CHECK_VERIFY);
    AddIOCTL(pDevice, IOCTL_CDROM_MEDIA_REMOVAL);
    AddIOCTL(pDevice, IOCTL_CDROM_EJECT_MEDIA);
    AddIOCTL(pDevice, IOCTL_CDROM_LOAD_MEDIA);
    AddIOCTL(pDevice, IOCTL_CDROM_RESERVE);
    AddIOCTL(pDevice, IOCTL_CDROM_RELEASE);
    AddIOCTL(pDevice, IOCTL_CDROM_FIND_NEW_DEVICES);
    AddIOCTL(pDevice, IOCTL_CDROM_SIMBAD);

    AddIOCTL(pDevice, IOCTL_STORAGE_CHECK_VERIFY);
    AddIOCTL(pDevice, IOCTL_STORAGE_CHECK_VERIFY2);
    AddIOCTL(pDevice, IOCTL_STORAGE_MEDIA_REMOVAL);
    AddIOCTL(pDevice, IOCTL_STORAGE_EJECT_MEDIA);
    AddIOCTL(pDevice, IOCTL_STORAGE_LOAD_MEDIA);
    AddIOCTL(pDevice, IOCTL_STORAGE_LOAD_MEDIA2);
    AddIOCTL(pDevice, IOCTL_STORAGE_RESERVE);
    AddIOCTL(pDevice, IOCTL_STORAGE_RELEASE);
    AddIOCTL(pDevice, IOCTL_STORAGE_FIND_NEW_DEVICES);
    AddIOCTL(pDevice, IOCTL_STORAGE_EJECTION_CONTROL);
    AddIOCTL(pDevice, IOCTL_STORAGE_MCN_CONTROL);
    AddIOCTL(pDevice, IOCTL_STORAGE_GET_MEDIA_TYPES);
    AddIOCTL(pDevice, IOCTL_STORAGE_GET_MEDIA_TYPES_EX);
    AddIOCTL(pDevice, IOCTL_STORAGE_RESET_BUS);
    AddIOCTL(pDevice, IOCTL_STORAGE_RESET_DEVICE);
    AddIOCTL(pDevice, IOCTL_STORAGE_GET_DEVICE_NUMBER);
    AddIOCTL(pDevice, IOCTL_STORAGE_PREDICT_FAILURE);
    AddIOCTL(pDevice, OBSOLETE_IOCTL_STORAGE_RESET_BUS);
    AddIOCTL(pDevice, OBSOLETE_IOCTL_STORAGE_RESET_DEVICE);

    AddIOCTL(pDevice, IOCTL_DISK_BASE);
    AddIOCTL(pDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY);
    AddIOCTL(pDevice, IOCTL_DISK_GET_PARTITION_INFO);
    AddIOCTL(pDevice, IOCTL_DISK_SET_PARTITION_INFO);
    AddIOCTL(pDevice, IOCTL_DISK_GET_DRIVE_LAYOUT);
    AddIOCTL(pDevice, IOCTL_DISK_SET_DRIVE_LAYOUT);
    AddIOCTL(pDevice, IOCTL_DISK_VERIFY);
    AddIOCTL(pDevice, IOCTL_DISK_FORMAT_TRACKS);
    AddIOCTL(pDevice, IOCTL_DISK_REASSIGN_BLOCKS);
    AddIOCTL(pDevice, IOCTL_DISK_PERFORMANCE);
    AddIOCTL(pDevice, IOCTL_DISK_IS_WRITABLE);
    AddIOCTL(pDevice, IOCTL_DISK_LOGGING);
    AddIOCTL(pDevice, IOCTL_DISK_FORMAT_TRACKS_EX);
    AddIOCTL(pDevice, IOCTL_DISK_HISTOGRAM_STRUCTURE);
    AddIOCTL(pDevice, IOCTL_DISK_HISTOGRAM_DATA);
    AddIOCTL(pDevice, IOCTL_DISK_HISTOGRAM_RESET);
    AddIOCTL(pDevice, IOCTL_DISK_REQUEST_STRUCTURE);
    AddIOCTL(pDevice, IOCTL_DISK_REQUEST_DATA);
    AddIOCTL(pDevice, IOCTL_DISK_CONTROLLER_NUMBER);

    AddIOCTL(pDevice, SMART_GET_VERSION);
    AddIOCTL(pDevice, SMART_SEND_DRIVE_COMMAND);
    AddIOCTL(pDevice, SMART_RCV_DRIVE_DATA);

    AddIOCTL(pDevice, IOCTL_DISK_UPDATE_DRIVE_SIZE);
    AddIOCTL(pDevice, IOCTL_DISK_GROW_PARTITION);
    AddIOCTL(pDevice, IOCTL_DISK_GET_CACHE_INFORMATION);
    AddIOCTL(pDevice, IOCTL_DISK_SET_CACHE_INFORMATION);
    AddIOCTL(pDevice, IOCTL_DISK_DELETE_DRIVE_LAYOUT);
    AddIOCTL(pDevice, IOCTL_DISK_FORMAT_DRIVE);
    AddIOCTL(pDevice, IOCTL_DISK_SENSE_DEVICE);
    AddIOCTL(pDevice, IOCTL_DISK_CHECK_VERIFY);
    AddIOCTL(pDevice, IOCTL_DISK_MEDIA_REMOVAL);
    AddIOCTL(pDevice, IOCTL_DISK_EJECT_MEDIA);
    AddIOCTL(pDevice, IOCTL_DISK_LOAD_MEDIA);
    AddIOCTL(pDevice, IOCTL_DISK_RESERVE);
    AddIOCTL(pDevice, IOCTL_DISK_RELEASE);
    AddIOCTL(pDevice, IOCTL_DISK_FIND_NEW_DEVICES);
    AddIOCTL(pDevice, IOCTL_DISK_GET_MEDIA_TYPES);

    return TRUE;
}



void CIoctlCD::CallRandomWin32API(LPOVERLAPPED pOL)
{
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\browserioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

#include <windows.h>
*/

#include <ntddbrow.h>
#include <lmserver.h>

#include <lmshare.h>
#include <lmapibuf.h>
#include <lmerr.h>

#include "BrowserIOCTL.h"

static bool s_fVerbose = true;

#define NUM_OF_REMEMBERED_TRANSPORTS (16)
#define MAX_TRANSPORT_NAME_LEN (1024)
static WCHAR s_awszTransportName[NUM_OF_REMEMBERED_TRANSPORTS][MAX_TRANSPORT_NAME_LEN] = {0};

enum {
	PLACE_HOLDER_NetSessionEnum = 0,
	PLACE_HOLDER_NetServerTransportEnum,
	PLACE_HOLDER_LAST
};


CIoctlBrowser::CIoctlBrowser(CDevice *pDevice): CIoctlNtNative(pDevice)
{
	for (int i = 0 ; i < NUM_OF_RESUME_HANDLES; i++)
	{
		m_aResumeHandle[i] = DWORD_RAND;
	}
	m_LastResumeHandle = 0;
/*
	HANDLE m_hLanmanDatagramReceiver;
	m_hLanmanDatagramReceiver = CIoctlNtNative::StaticCreateDevice(L"\\Device\\LanmanDatagramReceiver");
	_ASSERTE(INVALID_HANDLE_VALUE != m_hLanmanDatagramReceiver);
	m_hLanmanDatagramReceiver = CIoctlNtNative::StaticCreateDevice(L"\\FileSystem\\CDfsRecognizer");
	_ASSERTE(INVALID_HANDLE_VALUE != m_hLanmanDatagramReceiver);
	m_hLanmanDatagramReceiver = CIoctlNtNative::StaticCreateDevice(L"\\FileSystem\\FatRecognizer");
	_ASSERTE(INVALID_HANDLE_VALUE != m_hLanmanDatagramReceiver);
	m_hLanmanDatagramReceiver = CIoctlNtNative::StaticCreateDevice(L"\\FileSystem\\UdfsCdRomRecognizer");
	_ASSERTE(INVALID_HANDLE_VALUE != m_hLanmanDatagramReceiver);
	m_hLanmanDatagramReceiver = CIoctlNtNative::StaticCreateDevice(L"\\FileSystem\\UdfsDiskRecognizer");
	_ASSERTE(INVALID_HANDLE_VALUE != m_hLanmanDatagramReceiver);
*/
}










void CIoctlBrowser::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
	switch(dwIOCTL)
	{
	case IOCTL_LMDR_ENUMERATE_TRANSPORTS:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);

		{
			LMDR_TRANSPORT_LIST* pNextEntry = ((LMDR_TRANSPORT_LIST*)abOutBuffer);
			for (
					pNextEntry = ((LMDR_TRANSPORT_LIST*)abOutBuffer);
					pNextEntry->NextEntryOffset != 0;
					pNextEntry = (LMDR_TRANSPORT_LIST*)(((PBYTE)pNextEntry) + pNextEntry->NextEntryOffset)
				)
			{
				wcscpy(s_awszTransportName[rand()%NUM_OF_REMEMBERED_TRANSPORTS], pNextEntry->TransportName);
				DPF((TEXT("CIoctlBrowser::UseOutBuff(IOCTL_LMDR_ENUMERATE_TRANSPORTS): TransportName=%s\n"), pNextEntry->TransportName));
			}
		}
		break;

	}
}

/*
HANDLE CIoctlBrowser::CreateDevice(CDevice *pDevice)
{
	_ASSERTE(FALSE);
    ;
}

BOOL CIoctlBrowser::CloseDevice(CDevice *pDevice)
{
	_ASSERTE(FALSE);
    ;
}

BOOL CIoctlBrowser::DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		)
{
	_ASSERTE(FALSE);
	;
}

BOOL CIoctlBrowser::DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		)
{
	_ASSERTE(FALSE);
	;
}


BOOL CIoctlBrowser::DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		)
{
	_ASSERTE(FALSE);
	;
}

*/


void CIoctlBrowser::CallRandomWin32API(LPOVERLAPPED pOL)
{
	DWORD dwSwitch;
	if	(-1 != m_pDevice->m_dwOnlyThisIndexIOCTL) 
	{ 
		dwSwitch = m_pDevice->m_dwOnlyThisIndexIOCTL;
	}
	else
	{
		dwSwitch = rand()%PLACE_HOLDER_LAST;
	}

	switch(dwSwitch)
	{
	case PLACE_HOLDER_NetSessionEnum:
		{
			//
			// once in a while, start all over again
			//
			if (0 == rand()%50) m_LastResumeHandle = 0;

			LPBYTE bufptr = NULL;
			DWORD dwEntriesRead;
			DWORD dwTotalEntries;
			NET_API_STATUS status = ::NetSessionEnum(
				rand()%10 ? NULL : GetRandomMachineName(), //LPWSTR servername,     
				NULL, //LPWSTR UncClientName,  
				NULL, //LPWSTR username,       
				rand()%2 ? 0 : rand()%2 ? 1 : rand()%2 ? 2 : rand()%2 ? 10 : 502, //DWORD level,           
				&bufptr,        
				rand()%2 ? rand()%1000 : rand()%2 ? rand()%100 : MAX_PREFERRED_LENGTH,      
				&dwEntriesRead,   
				&dwTotalEntries,  
				&m_LastResumeHandle  
				);
			if (NERR_Success != status && ERROR_MORE_DATA != status)
			{
				DPF((TEXT("CIoctlBrowser::PLACE_HOLDER_NetSessionEnum(): failed with %d\n"), status));
				return;
			}
			else
			{
				//DPF((TEXT("CIoctlBrowser::PLACE_HOLDER_NetSessionEnum(): SUCCEEDED\n")));
			}

			m_aResumeHandle[rand()%NUM_OF_RESUME_HANDLES] = m_LastResumeHandle;

			::NetApiBufferFree(bufptr);
		}

		break;

	case PLACE_HOLDER_NetServerTransportEnum:
		{
			//
			// once in a while, start all over again
			//
			if (0 == rand()%50) m_LastResumeHandle = 0;

			LPBYTE bufptr = NULL;
			DWORD dwEntriesRead;
			DWORD dwTotalEntries;
			DWORD dwLevel = rand()%2;
			NET_API_STATUS status = ::NetServerTransportEnum(
				rand()%10 ? NULL : GetRandomMachineName(), //LPWSTR servername,     
				dwLevel, //DWORD level,           
				&bufptr,        
				rand()%2 ? rand()%1000 : rand()%2 ? rand()%100 : MAX_PREFERRED_LENGTH,      
				&dwEntriesRead,   
				&dwTotalEntries,  
				&m_LastResumeHandle  
				);
			if (NERR_Success != status && ERROR_MORE_DATA != status)
			{
				DPF((TEXT("CIoctlBrowser::PLACE_HOLDER_NetServerTransportEnum(): failed with %d\n"), status));
				return;
			}
			else
			{
				//DPF((TEXT("CIoctlBrowser::PLACE_HOLDER_NetServerTransportEnum(): SUCCEEDED\n")));
			}

			m_aResumeHandle[rand()%NUM_OF_RESUME_HANDLES] = m_LastResumeHandle;

			for (UINT i = 0; i < dwEntriesRead; i++)
			{
				if (i < NUM_OF_REMEMBERED_TRANSPORTS)
				{
					if (0 == dwLevel)
					{
						wcscpy(s_awszTransportName[rand()%NUM_OF_REMEMBERED_TRANSPORTS], (((SERVER_TRANSPORT_INFO_0*)bufptr)[i]).svti0_transportname);
					}
					else
					{
						wcscpy(s_awszTransportName[rand()%NUM_OF_REMEMBERED_TRANSPORTS], (((SERVER_TRANSPORT_INFO_1*)bufptr)[i]).svti1_transportname);
					}

				}
			}

			::NetApiBufferFree(bufptr);
		}

		break;

	}
	return;
}

void CIoctlBrowser::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
	switch(dwIOCTL)
	{
    case IOCTL_LMDR_START:
		/*
Function code:   IOCTL_LMDR_START
Input/Output Buffers:   none
This function initializes the Datagram Receiver.  This function only works if the Datagram Receiver FSD is loaded and one dormant Datagram Receiver FSP thread exists.
*/
		break;

    case IOCTL_LMDR_STOP:
		/*
Function code:   IOCTL_LMDR_STOP
Input/Output Buffers:   none
This function terminates the Datagram Receiver FSP, except for one thread.  All Datagram Receiver data is discarded, and the FSP thread remains dormant until it is restarted by a IOCTL_LMDR_START IOCtl call.
*/
		break;

    case IOCTL_LMDR_ADD_NAME:
    case IOCTL_LMDR_DELETE_NAME:
    case IOCTL_LMDR_ADD_NAME_DOM:
    case IOCTL_LMDR_DELETE_NAME_DOM:
		FillCommonPartOf_LMDR_REQUEST_PACKET_WithRandomValues((PLMDR_REQUEST_PACKET)abInBuffer);
        Fill_LMDR_REQUEST_PACKET_WithRandom_AddDelName((PLMDR_REQUEST_PACKET)abInBuffer);
		((PLMDR_REQUEST_PACKET)abInBuffer)->Version = rand()%100 ? LMDR_REQUEST_PACKET_VERSION_DOM : rand();
        SetInParam(dwInBuff, rand()%100+sizeof(LMDR_REQUEST_PACKET));//names may make the struct longer
        SetOutParam(abOutBuffer, dwOutBuff, 0);
		break;

    case IOCTL_LMDR_ENUMERATE_NAMES:
		FillCommonPartOf_LMDR_REQUEST_PACKET_WithRandomValues((PLMDR_REQUEST_PACKET)abInBuffer);
		((PLMDR_REQUEST_PACKET)abInBuffer)->Type = rand()%100 ? EnumerateNames : (IOCTL_LMDR_STRUCTURES)rand();
        Fill_LMDR_REQUEST_PACKET_WithRandom_EnumerateNames((PLMDR_REQUEST_PACKET)abInBuffer);
		((PLMDR_REQUEST_PACKET)abInBuffer)->Version = rand()%100 ? LMDR_REQUEST_PACKET_VERSION_DOM : rand();
        SetInParam(dwInBuff, rand()%100+sizeof(LMDR_REQUEST_PACKET));//names may make the struct longer
        SetOutParam(abOutBuffer, dwOutBuff, sizeof(DGRECEIVE_NAMES)+rand()%30);
		break;

    case IOCTL_LMDR_ENUMERATE_SERVERS:
		FillCommonPartOf_LMDR_REQUEST_PACKET_WithRandomValues((PLMDR_REQUEST_PACKET)abInBuffer);
		((PLMDR_REQUEST_PACKET)abInBuffer)->Type = rand()%100 ? EnumerateServers : (IOCTL_LMDR_STRUCTURES)rand();
        Fill_LMDR_REQUEST_PACKET_WithRandom_EnumerateServers((PLMDR_REQUEST_PACKET)abInBuffer);
		((PLMDR_REQUEST_PACKET)abInBuffer)->Version = rand()%100 ? LMDR_REQUEST_PACKET_VERSION_DOM : rand();
        SetInParam(dwInBuff, sizeof(LMDR_REQUEST_PACKET));
        SetOutParam(abOutBuffer, dwOutBuff, sizeof(SERVER_INFO_100)+rand()%30);
		break;

    case IOCTL_LMDR_BIND_TO_TRANSPORT:
    case IOCTL_LMDR_BIND_TO_TRANSPORT_DOM:
		FillCommonPartOf_LMDR_REQUEST_PACKET_WithRandomValues((PLMDR_REQUEST_PACKET)abInBuffer);
        Fill_LMDR_REQUEST_PACKET_WithRandom_Bind((PLMDR_REQUEST_PACKET)abInBuffer);
		((PLMDR_REQUEST_PACKET)abInBuffer)->Version = rand()%100 ? LMDR_REQUEST_PACKET_VERSION_DOM : rand();
		((PLMDR_REQUEST_PACKET)abInBuffer)->Type = (IOCTL_LMDR_STRUCTURES)rand();
        SetInParam(dwInBuff, rand()%30+(ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters.Bind.TransportName));
		break;

    case IOCTL_LMDR_ENUMERATE_TRANSPORTS:
		FillCommonPartOf_LMDR_REQUEST_PACKET_WithRandomValues((PLMDR_REQUEST_PACKET)abInBuffer);
		((PLMDR_REQUEST_PACKET)abInBuffer)->Type = rand()%100 ? EnumerateXports : (IOCTL_LMDR_STRUCTURES)rand();
        Fill_LMDR_REQUEST_PACKET_WithRandom_EnumerateTransports((PLMDR_REQUEST_PACKET)abInBuffer);
		((PLMDR_REQUEST_PACKET)abInBuffer)->Version = rand()%100 ? LMDR_REQUEST_PACKET_VERSION_DOM : rand();
        SetInParam(dwInBuff, sizeof(LMDR_REQUEST_PACKET));
        SetOutParam(abOutBuffer, dwOutBuff, sizeof(LMDR_TRANSPORT_LIST)+rand()%1000);
		break;

    case IOCTL_LMDR_UNBIND_FROM_TRANSPORT:
    case IOCTL_LMDR_UNBIND_FROM_TRANSPORT_DOM:
		FillCommonPartOf_LMDR_REQUEST_PACKET_WithRandomValues((PLMDR_REQUEST_PACKET)abInBuffer);
		((PLMDR_REQUEST_PACKET)abInBuffer)->Type = rand()%100 ? EnumerateXports : (IOCTL_LMDR_STRUCTURES)rand();
        Fill_LMDR_REQUEST_PACKET_WithRandom_EnumerateTransports((PLMDR_REQUEST_PACKET)abInBuffer);
		((PLMDR_REQUEST_PACKET)abInBuffer)->Version = rand()%100 ? LMDR_REQUEST_PACKET_VERSION_DOM : rand();
        SetInParam(dwInBuff, (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters.Unbind.TransportName));
        SetOutParam(abOutBuffer, dwOutBuff, sizeof(LMDR_TRANSPORT_LIST)+rand()%30);
		break;

    case IOCTL_LMDR_RENAME_DOMAIN:
		FillCommonPartOf_LMDR_REQUEST_PACKET_WithRandomValues((PLMDR_REQUEST_PACKET)abInBuffer);
		((PLMDR_REQUEST_PACKET)abInBuffer)->Version = rand()%100 ? LMDR_REQUEST_PACKET_VERSION_DOM : rand();
        SetInParam(dwInBuff, sizeof(LMDR_REQUEST_PACKET));
		break;

    case IOCTL_LMDR_GET_BROWSER_SERVER_LIST:
		FillCommonPartOf_LMDR_REQUEST_PACKET_WithRandomValues((PLMDR_REQUEST_PACKET)abInBuffer);
		((PLMDR_REQUEST_PACKET)abInBuffer)->Type = (IOCTL_LMDR_STRUCTURES)(rand()%4);
		Fill_LMDR_REQUEST_PACKET_WithRandom_GetBrowserServerList((PLMDR_REQUEST_PACKET)abInBuffer);
		((PLMDR_REQUEST_PACKET)abInBuffer)->Version = rand()%100 ? LMDR_REQUEST_PACKET_VERSION_DOM : rand();
        SetInParam(dwInBuff, sizeof(LMDR_REQUEST_PACKET));
        SetOutParam(abOutBuffer, dwOutBuff, rand()%200);
		break;

    case IOCTL_LMDR_GET_MASTER_NAME:
		FillCommonPartOf_LMDR_REQUEST_PACKET_WithRandomValues((PLMDR_REQUEST_PACKET)abInBuffer);
        SetInParam(dwInBuff, sizeof(LMDR_REQUEST_PACKET));
        SetOutParam(abOutBuffer, dwOutBuff, (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET, Parameters.GetMasterName.Name)+3*sizeof(WCHAR));
		break;

    case IOCTL_LMDR_BECOME_BACKUP:
		FillCommonPartOf_LMDR_REQUEST_PACKET_WithRandomValues((PLMDR_REQUEST_PACKET)abInBuffer);
        SetInParam(dwInBuff, sizeof(LMDR_REQUEST_PACKET));
		break;

    case IOCTL_LMDR_BECOME_MASTER:
		FillCommonPartOf_LMDR_REQUEST_PACKET_WithRandomValues((PLMDR_REQUEST_PACKET)abInBuffer);
        SetInParam(dwInBuff, sizeof(LMDR_REQUEST_PACKET));
		break;

    case IOCTL_LMDR_WAIT_FOR_MASTER_ANNOUNCE:
		FillCommonPartOf_LMDR_REQUEST_PACKET_WithRandomValues((PLMDR_REQUEST_PACKET)abInBuffer);
        SetInParam(dwInBuff, sizeof(LMDR_REQUEST_PACKET));
        SetOutParam(abOutBuffer, dwOutBuff, (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET, Parameters.WaitForMasterAnnouncement.Name));
		break;

    case IOCTL_LMDR_WRITE_MAILSLOT:
		FillCommonPartOf_LMDR_REQUEST_PACKET_WithRandomValues((PLMDR_REQUEST_PACKET)abInBuffer);
		((PLMDR_REQUEST_PACKET)abInBuffer)->Version = rand()%100 ? LMDR_REQUEST_PACKET_VERSION_DOM : rand();
        SetInParam(dwInBuff, (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters.SendDatagram.Name));
        SetOutParam(abOutBuffer, dwOutBuff, 1);
		break;

    case IOCTL_LMDR_UPDATE_STATUS:
		FillCommonPartOf_LMDR_REQUEST_PACKET_WithRandomValues((PLMDR_REQUEST_PACKET)abInBuffer);
		((PLMDR_REQUEST_PACKET)abInBuffer)->Version = rand()%100 ? LMDR_REQUEST_PACKET_VERSION_DOM : rand();
        SetInParam(dwInBuff, (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters)+sizeof(((PLMDR_REQUEST_PACKET)abInBuffer)->Parameters.UpdateStatus));
		break;

    case IOCTL_LMDR_CHANGE_ROLE:
		FillCommonPartOf_LMDR_REQUEST_PACKET_WithRandomValues((PLMDR_REQUEST_PACKET)abInBuffer);
        SetInParam(dwInBuff, sizeof(LMDR_REQUEST_PACKET));
		break;

    case IOCTL_LMDR_NEW_MASTER_NAME:
		FillCommonPartOf_LMDR_REQUEST_PACKET_WithRandomValues((PLMDR_REQUEST_PACKET)abInBuffer);
		Fill_LMDR_REQUEST_PACKET_WithRandom_GetMasterName((PLMDR_REQUEST_PACKET)abInBuffer);
        SetInParam(dwInBuff, sizeof(LMDR_REQUEST_PACKET));
		break;

    case IOCTL_LMDR_QUERY_STATISTICS:
		//
		// this IOCTL requires the exact size, so any other size will cause 
		// STATUS_BUFFER_TOO_SMALL, and the IOCTL thread will try bigger buffers
		// which will not help, and just waste time
		//
        dwOutBuff = sizeof(BOWSER_STATISTICS);
		break;

    case IOCTL_LMDR_RESET_STATISTICS:
		// no params
		break;

    case IOCTL_LMDR_DEBUG_CALL:
		// debug only code, let's leave that be
		break;

    case IOCTL_LMDR_NETLOGON_MAILSLOT_READ:	
        SetOutParam(abOutBuffer, dwOutBuff, sizeof(NETLOGON_MAILSLOT)+rand()%1000);
		break;

    case IOCTL_LMDR_NETLOGON_MAILSLOT_ENABLE:
		FillCommonPartOf_LMDR_REQUEST_PACKET_WithRandomValues((PLMDR_REQUEST_PACKET)abInBuffer);
		Fill_LMDR_REQUEST_PACKET_NetlogonMailslotEnable((PLMDR_REQUEST_PACKET)abInBuffer);
        SetInParam(dwInBuff, (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters)+sizeof(DWORD));
		break;

    case IOCTL_LMDR_IP_ADDRESS_CHANGED:
		// this is an empty method, with a logging bug
		break;

    case IOCTL_LMDR_ENABLE_DISABLE_TRANSPORT:
		FillCommonPartOf_LMDR_REQUEST_PACKET_WithRandomValues((PLMDR_REQUEST_PACKET)abInBuffer);
		((PLMDR_REQUEST_PACKET)abInBuffer)->Version = rand()%100 ? LMDR_REQUEST_PACKET_VERSION_DOM : rand();
        SetInParam(
			dwInBuff, 
			(ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters) + sizeof(((PLMDR_REQUEST_PACKET)abInBuffer)->Parameters.EnableDisableTransport)
			);
		break;

    case IOCTL_LMDR_BROWSER_PNP_READ:
        SetOutParam(abOutBuffer, dwOutBuff, sizeof(NETLOGON_MAILSLOT)+rand()%1000);
		break;

    case IOCTL_LMDR_BROWSER_PNP_ENABLE:
		FillCommonPartOf_LMDR_REQUEST_PACKET_WithRandomValues((PLMDR_REQUEST_PACKET)abInBuffer);
		Fill_LMDR_REQUEST_PACKET_NetlogonMailslotEnable((PLMDR_REQUEST_PACKET)abInBuffer);
        SetInParam(dwInBuff, (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters)+sizeof(DWORD));
		break;


	default:
		_ASSERTE(FALSE);
	}

    //CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
}


BOOL CIoctlBrowser::FindValidIOCTLs(CDevice *pDevice)
{
    AddIOCTL(pDevice, IOCTL_LMDR_START);
    AddIOCTL(pDevice, IOCTL_LMDR_STOP);
    AddIOCTL(pDevice, IOCTL_LMDR_ADD_NAME);
    AddIOCTL(pDevice, IOCTL_LMDR_DELETE_NAME);
    AddIOCTL(pDevice, IOCTL_LMDR_ADD_NAME_DOM);
    AddIOCTL(pDevice, IOCTL_LMDR_DELETE_NAME_DOM);
    AddIOCTL(pDevice, IOCTL_LMDR_ENUMERATE_NAMES);
    AddIOCTL(pDevice, IOCTL_LMDR_ENUMERATE_SERVERS);
    AddIOCTL(pDevice, IOCTL_LMDR_BIND_TO_TRANSPORT);
    AddIOCTL(pDevice, IOCTL_LMDR_BIND_TO_TRANSPORT_DOM);
    AddIOCTL(pDevice, IOCTL_LMDR_ENUMERATE_TRANSPORTS);
    AddIOCTL(pDevice, IOCTL_LMDR_UNBIND_FROM_TRANSPORT);
    AddIOCTL(pDevice, IOCTL_LMDR_UNBIND_FROM_TRANSPORT_DOM);
    AddIOCTL(pDevice, IOCTL_LMDR_RENAME_DOMAIN);
    AddIOCTL(pDevice, IOCTL_LMDR_GET_BROWSER_SERVER_LIST);
    AddIOCTL(pDevice, IOCTL_LMDR_GET_MASTER_NAME);
    AddIOCTL(pDevice, IOCTL_LMDR_BECOME_BACKUP);
    AddIOCTL(pDevice, IOCTL_LMDR_BECOME_MASTER);
    AddIOCTL(pDevice, IOCTL_LMDR_WAIT_FOR_MASTER_ANNOUNCE);
    AddIOCTL(pDevice, IOCTL_LMDR_WRITE_MAILSLOT);
    AddIOCTL(pDevice, IOCTL_LMDR_UPDATE_STATUS);
    AddIOCTL(pDevice, IOCTL_LMDR_CHANGE_ROLE);
    AddIOCTL(pDevice, IOCTL_LMDR_NEW_MASTER_NAME);
    AddIOCTL(pDevice, IOCTL_LMDR_QUERY_STATISTICS);
    AddIOCTL(pDevice, IOCTL_LMDR_RESET_STATISTICS);
    AddIOCTL(pDevice, IOCTL_LMDR_DEBUG_CALL);
    AddIOCTL(pDevice, IOCTL_LMDR_NETLOGON_MAILSLOT_READ);
    AddIOCTL(pDevice, IOCTL_LMDR_NETLOGON_MAILSLOT_ENABLE);
    AddIOCTL(pDevice, IOCTL_LMDR_IP_ADDRESS_CHANGED);
    AddIOCTL(pDevice, IOCTL_LMDR_ENABLE_DISABLE_TRANSPORT);
    AddIOCTL(pDevice, IOCTL_LMDR_BROWSER_PNP_READ);
    AddIOCTL(pDevice, IOCTL_LMDR_BROWSER_PNP_ENABLE);

    return TRUE;
}



void CIoctlBrowser::FillCommonPartOf_LMDR_REQUEST_PACKET_WithRandomValues(LMDR_REQUEST_PACKET *pPacket)
{
	pPacket->Type = GetRandomStructureType();
	pPacket->Version = GetRandomStructureVersion();
	pPacket->LogonId = GetRandomLogonId();
	pPacket->Level = GetRandomLevel();
	pPacket->TransportName = GetRandomTransportName_UNICODE_STRING();
	pPacket->EmulatedDomainName = GetRandomEmulatedDomainName();
}

void CIoctlBrowser::Fill_LMDR_REQUEST_PACKET_WithRandom_Start(LMDR_REQUEST_PACKET *pPacket)
{
	pPacket->Parameters.Start.NumberOfMailslotBuffers = GetRandomNumberOfMailslotBuffers();
	pPacket->Parameters.Start.NumberOfServerAnnounceBuffers = GetRandomNumberOfServerAnnounceBuffers();
	pPacket->Parameters.Start.IllegalDatagramThreshold = GetRandomIllegalDatagramThreshold();
	pPacket->Parameters.Start.EventLogResetFrequency = GetRandomEventLogResetFrequency();
	pPacket->Parameters.Start.LogElectionPackets = GetRandomLogElectionPackets();
	pPacket->Parameters.Start.IsLanManNt = GetRandomIsLanManNt();
}

void CIoctlBrowser::Fill_LMDR_REQUEST_PACKET_WithRandom_AddDelName(LMDR_REQUEST_PACKET *pPacket)
{
	pPacket->Parameters.AddDelName.Type = GetRandom_DGReceiverNameType();

	//
	// BUGBUG: do i need to fixup the struct's length due to copying a string into Name?
	//
	SetRandomAddDelName_Name(pPacket->Parameters.AddDelName.Name);
	pPacket->Parameters.AddDelName.DgReceiverNameLength = (rand()%3 == 0) ? rand()%1000 : wcslen(pPacket->Parameters.AddDelName.Name);
}

void CIoctlBrowser::Fill_LMDR_REQUEST_PACKET_WithRandom_EnumerateNames(LMDR_REQUEST_PACKET *pPacket)
{
	pPacket->Parameters.EnumerateNames.ResumeHandle = GetRandomResumeHandle();
}

void CIoctlBrowser::Fill_LMDR_REQUEST_PACKET_WithRandom_EnumerateServers(LMDR_REQUEST_PACKET *pPacket)
{
	pPacket->Parameters.EnumerateServers.ResumeHandle = GetRandomResumeHandle();
	pPacket->Parameters.EnumerateServers.ServerType = GetRandomServerType();
	SetRandomDomainName(pPacket->Parameters.EnumerateServers.DomainName);
	pPacket->Parameters.EnumerateServers.DomainNameLength = (rand()%3 == 0) ? rand()%1000 : wcslen(pPacket->Parameters.EnumerateServers.DomainName);
}

void CIoctlBrowser::Fill_LMDR_REQUEST_PACKET_WithRandom_EnumerateTransports(LMDR_REQUEST_PACKET *pPacket)
{
	pPacket->Parameters.EnumerateTransports.ResumeHandle = GetRandomResumeHandle();
}

void CIoctlBrowser::Fill_LMDR_REQUEST_PACKET_WithRandom_Bind(LMDR_REQUEST_PACKET *pPacket)
{
	SetRandomTransportName(pPacket->Parameters.Bind.TransportName);
	pPacket->Parameters.Bind.TransportNameLength = (rand()%20 == 0) ? rand()%1000 : wcslen(pPacket->Parameters.Bind.TransportName);
}

void CIoctlBrowser::Fill_LMDR_REQUEST_PACKET_WithRandom_GetBrowserServerList(LMDR_REQUEST_PACKET *pPacket)
{
	pPacket->Parameters.GetBrowserServerList.ResumeHandle = GetRandomResumeHandle();
	SetRandomDomainName(pPacket->Parameters.GetBrowserServerList.DomainName);
	pPacket->Parameters.GetBrowserServerList.DomainNameLength = (rand()%3 == 0) ? rand()%1000 : wcslen(pPacket->Parameters.GetBrowserServerList.DomainName);
	pPacket->Parameters.GetBrowserServerList.ResumeHandle = GetRandomResumeHandle();
	pPacket->Parameters.GetBrowserServerList.ForceRescan = rand()%2;
	pPacket->Parameters.GetBrowserServerList.UseBrowseList = rand()%2;
}

void CIoctlBrowser::Fill_LMDR_REQUEST_PACKET_WithRandom_WaitForMasterAnnouncement(LMDR_REQUEST_PACKET *pPacket)
{
	SetRandomTransportName(pPacket->Parameters.WaitForMasterAnnouncement.Name);
	pPacket->Parameters.WaitForMasterAnnouncement.MasterNameLength = (rand()%3 == 0) ? rand()%1000 : wcslen(pPacket->Parameters.WaitForMasterAnnouncement.Name);
}

void CIoctlBrowser::Fill_LMDR_REQUEST_PACKET_WithRandom_GetMasterName(LMDR_REQUEST_PACKET *pPacket)
{
	SetRandomTransportName(pPacket->Parameters.GetMasterName.Name);
	pPacket->Parameters.GetMasterName.MasterNameLength = (rand()%3 == 0) ? rand()%1000 : wcslen(pPacket->Parameters.GetMasterName.Name);
}

void CIoctlBrowser::Fill_LMDR_REQUEST_PACKET_WithRandom_SendDatagram(LMDR_REQUEST_PACKET *pPacket)
{
	pPacket->Parameters.SendDatagram.DestinationNameType = GetRandom_DGReceiverNameType();
	pPacket->Parameters.SendDatagram.MailslotNameLength = rand()%10 ? 0 : rand()%30;
	SetRandomTransport_SendDatagram_Name(pPacket->Parameters.SendDatagram.Name);
	pPacket->Parameters.SendDatagram.NameLength = (rand()%3 == 0) ? rand()%1000 : wcslen(pPacket->Parameters.SendDatagram.Name);
}

void CIoctlBrowser::Fill_LMDR_REQUEST_PACKET_WithRandom_UpdateStatus(LMDR_REQUEST_PACKET *pPacket)
{
	pPacket->Parameters.UpdateStatus.NewStatus = DWORD_RAND;
	pPacket->Parameters.UpdateStatus.NumberOfServersInTable = rand()%100;
	pPacket->Parameters.UpdateStatus.IsLanmanNt = rand()%10 ? TRUE : FALSE;
	pPacket->Parameters.UpdateStatus.MaintainServerList = rand()%2;
}

void CIoctlBrowser::Fill_LMDR_REQUEST_PACKET_WithRandom_ChangeRole(LMDR_REQUEST_PACKET *pPacket)
{
	pPacket->Parameters.ChangeRole.RoleModification = rand();
}

void CIoctlBrowser::Fill_LMDR_REQUEST_PACKET_NetlogonMailslotEnable(LMDR_REQUEST_PACKET *pPacket)
{
	pPacket->Parameters.NetlogonMailslotEnable.MaxMessageCount = rand();
}

void CIoctlBrowser::Fill_LMDR_REQUEST_PACKET_EnableDisableTransport(LMDR_REQUEST_PACKET *pPacket)
{
	pPacket->Parameters.EnableDisableTransport.EnableTransport = rand()%2;
}

void CIoctlBrowser::Fill_LMDR_REQUEST_PACKET_DomainRename(LMDR_REQUEST_PACKET *pPacket)
{
	pPacket->Parameters.DomainRename.ValidateOnly = rand()%2;
	SetRandomDomainName(pPacket->Parameters.DomainRename.DomainName);
	pPacket->Parameters.DomainRename.DomainNameLength = (rand()%3 == 0) ? rand()%1000 : wcslen(pPacket->Parameters.DomainRename.DomainName);
}

/*
typedef enum _IOCTL_LMDR_STRUCTURES {
    EnumerateNames,                   // IOCTL_LMDR_ENUMERATE_NAMES
    EnumerateServers,                 // IOCTL_LMDR_ENUMERATE_SERVERS
    EnumerateXports,                  // IOCTL_LMDR_ENUMERATE_TRANSPORTS
    Datagram
} IOCTL_LMDR_STRUCTURES;
*/
IOCTL_LMDR_STRUCTURES CIoctlBrowser::GetRandomStructureType()
{
	//
	// usually a datagram
	//
	if (rand()%20) return Datagram;

	if (0 == rand()%4) return EnumerateNames;

	if (0 == rand()%3) return EnumerateServers;

	if (0 == rand()%2) return EnumerateXports;
	
	return (IOCTL_LMDR_STRUCTURES)rand();
}

/*
#define LMDR_REQUEST_PACKET_VERSION_DOM  0x00000007L // Structure version.
#define LMDR_REQUEST_PACKET_VERSION  0x00000006L // Structure version.
*/
ULONG CIoctlBrowser::GetRandomStructureVersion()
{
	if (rand()%4) return LMDR_REQUEST_PACKET_VERSION_DOM;

	if (rand()%10) return LMDR_REQUEST_PACKET_VERSION;

	return rand();
}

ULONG CIoctlBrowser::GetRandomLevel()
{
	if (rand()%4) return 100;

	if (rand()%10) return 101;

	return rand();
}


LUID CIoctlBrowser::GetRandomLogonId()
{
	LUID luid;
	luid.LowPart = DWORD_RAND;
	luid.HighPart = DWORD_RAND;

	return luid;
}

//
// TODO: find out which names are relevant, and if i can use a static array, or
// do i need to programmatically get them
// put legal as well as illegal values here, including the empty string
//
static WCHAR *s_awszEmulatedDomainNames[] = 
{
	L"BUGBUG need real transport names",
	L"BUGBUG need real transport names",
	L"BUGBUG need real transport names",
	L"BUGBUG need real transport names",
	L"BUGBUG need real transport names"
};

UNICODE_STRING CIoctlBrowser::GetRandomEmulatedDomainName()
{
	UNICODE_STRING emulatedDomainName;
	emulatedDomainName.Buffer = s_awszEmulatedDomainNames[rand()%(sizeof(s_awszEmulatedDomainNames)/sizeof(*s_awszEmulatedDomainNames))];
	emulatedDomainName.Length = 1+(rand()%3 == 0) ? rand()%1000 : wcslen(emulatedDomainName.Buffer);
	if (rand()%2) emulatedDomainName.Buffer = (PWSTR)GetRandomIllegalPointer();
	emulatedDomainName.MaximumLength = emulatedDomainName.Length;

	return emulatedDomainName;
}

ULONG CIoctlBrowser::GetRandomNumberOfMailslotBuffers()
{
	return DWORD_RAND;
}

ULONG CIoctlBrowser::GetRandomNumberOfServerAnnounceBuffers()
{
	return DWORD_RAND;
}

ULONG CIoctlBrowser::GetRandomIllegalDatagramThreshold()
{
	return DWORD_RAND;
}

ULONG CIoctlBrowser::GetRandomEventLogResetFrequency()
{
	return DWORD_RAND;
}

BOOLEAN CIoctlBrowser::GetRandomLogElectionPackets()
{
	return (0 == rand()%2);
}

BOOLEAN CIoctlBrowser::GetRandomIsLanManNt()
{
	//
	// usually yes
	//
	return (0 != rand()%100);
}

/*
typedef enum _DGRECEIVER_NAME_TYPE {
    ComputerName = 1,           // 1: Computer name (signature 0), unique
    PrimaryDomain,              // 2: Primary domain (signature 0), group
    LogonDomain,                // 3: Logon domain (signature 0), group
    OtherDomain,                // 4: Other domain (signature 0), group
    DomainAnnouncement,         // 5: domain announce (__MSBROWSE__), group
    MasterBrowser,              // 6: Master browser (domain name, signature 1d), unique
    BrowserElection,            // 7: Election name (domain name, signature 1e), group
    BrowserServer,              // 8: Server name (signature 20)
    DomainName,                 // 9: DC Domain name (domain name, signature 1c)
    PrimaryDomainBrowser,       // a: PDC Browser name (domain name, signature 1b), unique
    AlternateComputerName,      // b: Computer name (signature 0), unique
} DGRECEIVER_NAME_TYPE, *PDGRECEIVER_NAME_TYPE;
*/
DGRECEIVER_NAME_TYPE CIoctlBrowser::GetRandom_DGReceiverNameType()
{
	switch(rand()%(AlternateComputerName+2))
	{
	case ComputerName:
		return ComputerName;

	case PrimaryDomain:
		return PrimaryDomain;

	case LogonDomain:
		return LogonDomain;

	case OtherDomain:
		return OtherDomain;

	case DomainAnnouncement:
		return DomainAnnouncement;

	case MasterBrowser:
		return MasterBrowser;

	case BrowserElection:
		return BrowserElection;

	case BrowserServer:
		return BrowserServer;

	case DomainName:
		return DomainName;

	case PrimaryDomainBrowser:
		return PrimaryDomainBrowser;

	case AlternateComputerName:
		return AlternateComputerName;

	default: return (DGRECEIVER_NAME_TYPE)rand();
	}
}

#define NUM_OF_REMEMBERED_COMPUTERS (100)
#define MAX_COMPUTER_NAME (100)

static WCHAR s_awszComputerName[NUM_OF_REMEMBERED_COMPUTERS][MAX_COMPUTER_NAME]={0};

WCHAR * CIoctlBrowser::GetRandomMachineName()
{
	return (s_awszComputerName[rand()%NUM_OF_REMEMBERED_COMPUTERS]);
}
void CIoctlBrowser::SetRandomAddDelName_Name(WCHAR *wszName)
{
	static long s_fFirstTime = true;
	if (::InterlockedExchange(&s_fFirstTime, FALSE))
	{
		LPBYTE bufptr = NULL;
		DWORD dwEntriesRead;
		DWORD dwTotalEntries;
		NET_API_STATUS status = ::NetServerEnum(
			NULL, //LPCWSTR servername,    
			100, //DWORD level,           
			&bufptr,        
			MAX_PREFERRED_LENGTH,      
			&dwEntriesRead,   
			&dwTotalEntries,  
			SV_TYPE_ALL,      
			NULL, //LPCWSTR domain,        
			NULL //LPDWORD resume_handle  
			);
		if (NERR_Success != status && ERROR_MORE_DATA != status)
		{
			DPF((TEXT("CIoctlBrowser::SetRandomAddDelName_Name(): NetServerEnum() failed with %d\n"), status));
			_ASSERTE(FALSE);
			return;
		}

		for(DWORD dwIndex = 0; dwIndex < NUM_OF_REMEMBERED_COMPUTERS && dwIndex < dwEntriesRead; dwIndex++)
		{
			wcscpy(s_awszComputerName[dwIndex], (((SERVER_INFO_100*)bufptr)[dwIndex]).sv100_name);
		}
		
		::NetApiBufferFree(bufptr);
	}
	
	wcscpy(wszName, s_awszComputerName[rand()%NUM_OF_REMEMBERED_COMPUTERS]);
}

ULONG CIoctlBrowser::GetRandomResumeHandle()
{
	//
	// usually return one of the returned ResumeHandles
	//
	if (rand()%2) return m_LastResumeHandle;

	if (rand()%10) return m_aResumeHandle[rand()%NUM_OF_RESUME_HANDLES];

	return DWORD_RAND;
}

ULONG CIoctlBrowser::GetRandomServerType()
{
	//
	// usually return 1 random bit
	//
	if (rand()%10) return (0x1 << (rand()%32));
	if (rand()%2) return 0;
	return DWORD_RAND;
}

void CIoctlBrowser::SetRandomDomainName(WCHAR *wszName)
{
	wcscpy(wszName, s_awszComputerName[rand()%(sizeof(s_awszComputerName)/sizeof(*s_awszComputerName))]);
}


void CIoctlBrowser::SetRandomTransportName(WCHAR *wszName)
{
	static long s_fFirstTime = true;
	if (::InterlockedExchange(&s_fFirstTime, FALSE))
	{
		//
		// to be on the safe side:
		//
		ZeroMemory(s_awszTransportName, NUM_OF_REMEMBERED_TRANSPORTS*MAX_TRANSPORT_NAME_LEN*sizeof(WCHAR));
		//
		// fill the s_awszTransportName array
		//
		HKEY hkTransports = NULL;

		TCHAR szRegistryPath[1024] = TEXT("SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}");
		TCHAR szFullRegistryPath[1024];
		LONG lRes = ::RegOpenKey(
			HKEY_LOCAL_MACHINE,        // handle to open key
			szRegistryPath, // name of subkey to open
			&hkTransports   // handle to open key
			);
		if (ERROR_SUCCESS != lRes)
		{
			DPF((TEXT("CIoctlBrowser::SetRandomInterfaceName(): RegOpenKey(%s) failed with %d\n"), szRegistryPath, lRes));
			_ASSERTE(FALSE);
			return;
		}

		TCHAR szSubKey[128];
		for(DWORD dwIndex = 0; dwIndex < NUM_OF_REMEMBERED_TRANSPORTS; dwIndex++)
		{
			lRes = ::RegEnumKey(
				hkTransports,     // handle to key to query
				dwIndex, // index of subkey to query
				szSubKey, // buffer for subkey name
				128-1   // size of subkey name buffer
				);
			if (ERROR_SUCCESS != lRes)
			{
				if (ERROR_NO_MORE_ITEMS == lRes)
				{
					//
					// no more items, break the loop
					//
					break;
				}
				DPF((TEXT("CIoctlBrowser::SetRandomInterfaceName(): RegEnumKey() failed with %d\n"), lRes));
				//
				// seems i should not enumerate no more
				//
				_ASSERTE(FALSE);
				break;
			}
			DPF((TEXT("CIoctlBrowser::SetRandomInterfaceName(): RegEnumKey() returned %s\n"), szSubKey));

			lstrcpy(szFullRegistryPath, szRegistryPath);
			lstrcat(szFullRegistryPath, TEXT("\\"));
			lstrcat(szFullRegistryPath, szSubKey);
			lstrcat(szFullRegistryPath, TEXT("\\Linkage"));
			HKEY hkUpToLinkage = NULL;
			lRes = ::RegOpenKey(
				HKEY_LOCAL_MACHINE,        // handle to open key
				szFullRegistryPath, // name of subkey to open
				&hkUpToLinkage   // handle to open key
				);
			if (ERROR_SUCCESS != lRes)
			{
				DPF((TEXT("CIoctlBrowser::SetRandomInterfaceName(): RegOpenKey(%s) failed with %d\n"), szFullRegistryPath, lRes));
				_ASSERTE(FALSE);
				goto out;
			}

			ULONG lRetLen = sizeof(TCHAR)*(MAX_TRANSPORT_NAME_LEN-1);
			DWORD dwType = REG_MULTI_SZ;
			lRes = ::RegQueryValueEx(
				hkUpToLinkage,        // handle to key to query
				TEXT("Export"), // value name
				NULL, //reserved
				&dwType, 
				(LPBYTE)s_awszTransportName[dwIndex],   // string buffer
				&lRetLen   // size of returned string 
				);
			if (ERROR_SUCCESS != lRes)
			{
				DPF((TEXT("CIoctlBrowser::SetRandomInterfaceName(): RegQueryValue(%s) failed with %d\n"), szFullRegistryPath, lRes));
				_ASSERTE(FALSE);
			}
			else
			{
				DPF((TEXT("CIoctlBrowser::SetRandomInterfaceName(): RegQueryValue(%s) returned %s\n"), szFullRegistryPath, s_awszTransportName[dwIndex]));
			}

			lRes = ::RegCloseKey(
				hkUpToLinkage   // handle to key to close
				);
			if (ERROR_SUCCESS != lRes)
			{
				DPF((TEXT("CIoctlBrowser::SetRandomInterfaceName(): RegCloseKey(hkUpToLinkage) failed with %d\n"), lRes));
			}
		}//for(dwIndex = 0; dwIndex < NUM_OF_REMEMBERED_TRANSPORTS; dwIndex++)
out:
		lRes = ::RegCloseKey(
			hkTransports   // handle to key to close
			);
		if (ERROR_SUCCESS != lRes)
		{
			DPF((TEXT("CIoctlBrowser::SetRandomInterfaceName(): RegCloseKey(hkTransports) failed with %d\n"), lRes));
		}

	}//if (::InterlockedExchange(&s_fFirstTime, FALSE))

	wcscpy(wszName, s_awszTransportName[rand()%NUM_OF_REMEMBERED_TRANSPORTS]);
}

WCHAR* CIoctlBrowser::GetRandomTransportName_WCHAR()
{
	return (s_awszTransportName[rand()%NUM_OF_REMEMBERED_TRANSPORTS]);
}

UNICODE_STRING CIoctlBrowser::GetRandomTransportName_UNICODE_STRING()
{
	UNICODE_STRING transportName;
	transportName.Buffer = s_awszTransportName[rand()%NUM_OF_REMEMBERED_TRANSPORTS];
	transportName.Length = 1+(rand()%20 == 0) ? rand()%1000 : wcslen(transportName.Buffer);
	if (rand()%2)
	{
		transportName.Buffer = (PWSTR)GetRandomIllegalPointer();
		//
		// must guard because of GetRandomIllegalPointer()
		//
		__try
		{
			wcscpy(transportName.Buffer, s_awszTransportName[rand()%NUM_OF_REMEMBERED_TRANSPORTS]);
		}
		__except(1)
		{
			;
		}
	}
	transportName.MaximumLength = transportName.Length;

	return transportName;
}

//
// BUGBUG: use meaningfull names
//
void CIoctlBrowser::SetRandomTransport_SendDatagram_Name(WCHAR *wszName)
{
	SetRandomTransportName(wszName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\cioctlfactory.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

#include <windows.h>

#include "NtNativeIOCTL.h"
#include "IOCTL.h"
*/


#include "CIoctlFactory.h"

#include "mspnatIOCTL.h"
#include "ipfltdrvIOCTL.h"
#include "FileIOCTL.h"
#include "ManyFilesIOCTL.h"
#include "NdproxyIOCTL.h"
#include "SysAudioIOCTL.h"
#include "WmiDataDeviceIOCTL.h"
#include "PRNIOCTL.h"
#include "NDISIOCTL.h"
#include "BeepIOCTL.h"
#include "UNCIOCTL.h"
#include "FloppyIOCTL.h"
#include "CDIOCTL.h"
#include "SerialIOCTL.h"
#include "VDMIOCTL.h"
#include "DmLoaderIOCTL.h"
#include "FsWrapIOCTL.h"
#include "MqAcIOCTL.h"
#include "PipeIOCTL.h"
//#include "MailSlotIOCTL.h"
#include "MailSlotServerIOCTL.h"
#include "MailSlotClientIOCTL.h"
#include "BatteryIOCTL.h"
#include "SocketServerIOCTL.h"
#include "SocketClientIOCTL.h"
#include "AfdDeviceIOCTL.h"
#include "DriverIOCTLBase.h"
#include "FilemapIOCTL.h"
#include "BrowserIOCTL.h"
#include "TcpSrvIOCTL.h"
#include "TcpClientIOCTL.h"
#include "TcpIOCTL.h"
#include "IpIOCTL.h"
#include "TdiIOCTL.h"
//#include "ARP1394IOCTL.h"
#include "IpMcastIoctl.h"
#include "IpSecIoctl.h"
#include "RasAcdIoctl.h"
#include "NtVdmIOCTL.h"

#include "StdOutputIOCTL.h"

#include "DefaultIOCTL.h"

static bool s_fVerbose = false;

#define REAL_NAME_IS(x) (0 == lstrcmpi(TEXT(x), pDevice->GetDeviceName()))

#define REAL_NAME_CONTAINS(x) (_tcsstr(_tcsupr(pDevice->GetDeviceName()), _tcsupr(TEXT(x))))

#define REAL_NAME_STARTS_WITH(x) (0 == _tcsncicmp(TEXT(x), pDevice->GetDeviceName(), lstrlen(TEXT(x))))

#define SYMBOLIC_NAME_IS(x) (0 == lstrcmpi(TEXT(x), pDevice->GetSymbolicDeviceName()))

#define SYMBOLIC_NAME_STARTS_WITH(x) (0 == _tcsncicmp(TEXT(x), pDevice->GetSymbolicDeviceName(), lstrlen(TEXT(x))))

//#define (x) (_tcsstr(_tcsupr(pDevice->GetSymbolicDeviceName()), _tcsstr(_tcsupr(TEXT(x)))))
#define SYMBOLIC_NAME_CONTAINS(x) (_tcsstr(_tcsupr(pDevice->GetSymbolicDeviceName()), _tcsupr(TEXT(x))))

#define TRY_HARD_TO_RETURN_NEW_OBJECT(__ClassType, __ClassString)\
	{\
		DWORD dwTimesTried = 0;\
		__ClassType *pObject = NULL;\
		do\
		{\
			if (CDevice::sm_fExitAllThreads)\
			{\
				return NULL;\
			}\
			if (NULL == (pObject = new __ClassType(pDevice)))\
			{\
				::Sleep(100);\
				dwTimesTried++;\
			}\
			else \
			{\
				DPF((TEXT("Created %s\n"), TEXT(__ClassString)));\
				return pObject;\
			}\
		}while((NULL == pObject) && (dwTimesTried << 10000));\
        DPF((TEXT("Failed to create %s\n"), TEXT(__ClassString)));\
		return NULL;\
	}

CIoctl* CreateIoctlObject(CDevice *pDevice)
{
	if (SYMBOLIC_NAME_IS("\\\\.\\mspnatd"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlMspnat, "CIoctlMspnat")
    }

    if (SYMBOLIC_NAME_IS("\\\\.\\IPFILTERDRIVER"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlIpfltrdrv, "CIoctlIpfltrdrv")
    }

    if (REAL_NAME_STARTS_WITH("\\Device\\Floppy"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlFloppy, "CIoctlFloppy")
    }

    if (REAL_NAME_STARTS_WITH("\\Device\\CdRom"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlCD, "CIoctlCD")
    }

    if (REAL_NAME_STARTS_WITH("\\Device\\Harddisk"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlCD, "CIoctlCD")
    }

    if (SYMBOLIC_NAME_IS("\\\\.\\NDPROXY"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlNdproxy, "CIoctlNdproxy")
    }

    if (SYMBOLIC_NAME_IS("\\\\.\\SysAudio"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlSysAudio, "CIoctlSysAudio")
    }

    if (SYMBOLIC_NAME_IS("\\\\.\\WMIDataDevice"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlWmiDataDevice, "CIoctlWmiDataDevice")
    }

    if (REAL_NAME_CONTAINS("WMIServiceDevice"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlWmiDataDevice, "CIoctlWmiDataDevice")
    }

    if (
        (SYMBOLIC_NAME_STARTS_WITH("\\\\.\\PRN")) ||
        (SYMBOLIC_NAME_STARTS_WITH("\\\\.\\LPT")) 
       )
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlPRN, "CIoctlPRN")
    }

    if (SYMBOLIC_NAME_IS("\\\\.\\NDIS"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlNDIS, "CIoctlNDIS")
    }
/*
    if (// UNC path? i use heuristics of a name starting with 2 backslashes, and
		// 3rd char not a dot
        (TEXT('\\') == pDevice->GetSymbolicDeviceName()[0]) &&
        (TEXT('\\') == pDevice->GetSymbolicDeviceName()[1]) &&
        (TEXT('.') != pDevice->GetSymbolicDeviceName()[2])
       )
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlUNC, "CIoctlUNC")
        DPF(((TEXT("Created CIoctlUNC\n")));
        return new CIoctlUNC(pDevice);
    }
*/
	//
	// must come before \\.\COM !!!
	//
    if (SYMBOLIC_NAME_STARTS_WITH("\\\\.\\CompositeBattery"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlBattery, "CIoctlBattery")
    }

    if (SYMBOLIC_NAME_STARTS_WITH("\\\\.\\COM"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlSerial, "CIoctlSerial")
    }

    if (REAL_NAME_STARTS_WITH("\\Device\\$VDM"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlVDM, "CIoctlVDM")
    }

    if (0 == lstrcmpi(TEXT("\\\\.\\DmLoader"), pDevice->GetSymbolicDeviceName()))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlDmLoader, "CIoctlDmLoader")
    }

    if (0 == lstrcmpi(TEXT("\\\\.\\FsWrap"), pDevice->GetSymbolicDeviceName()))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlFsWrap, "CIoctlFsWrap")
    }
    if (SYMBOLIC_NAME_CONTAINS("-FsWrap-Device-") || REAL_NAME_IS("\\Device\\FsWrap"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlFsWrap, "CIoctlFsWrap")
    }

    if (0 == lstrcmpi(TEXT("\\\\.\\MQAC"), pDevice->GetSymbolicDeviceName()))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlMqAc, "CIoctlMqAc")
    }

    if (REAL_NAME_CONTAINS("deleteme-pipe"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlPipe, "CIoctlPipe")
    }

    if (SYMBOLIC_NAME_CONTAINS("-Mailslot-Client-"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlMailSlotClient, "CIoctlMailSlotClient")
    }
    if (SYMBOLIC_NAME_CONTAINS("-Mailslot-Server-"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlMailSlotServer, "CIoctlMailSlotServer")
    }

    if (REAL_NAME_CONTAINS("deleteme-file"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlFile, "CIoctlFile")
    }

    if (SYMBOLIC_NAME_CONTAINS("-file-"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlFile, "CIoctlFile")
    }

    if (SYMBOLIC_NAME_CONTAINS("-many-files-"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlManyFiles, "CIoctlManyFiles")
    }

    if (SYMBOLIC_NAME_CONTAINS("-pipe-"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlPipe, "CIoctlPipe")
    }
/*
    if (SYMBOLIC_NAME_CONTAINS("-MailSlot-"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlMailSlot, "CIoctlMailSlot")
    }
*/
    if (SYMBOLIC_NAME_CONTAINS("-AFD-Device-") || REAL_NAME_IS("\\Device\\Afd"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlAfdDevice, "CIoctlAfdDevice")
    }

    if (SYMBOLIC_NAME_CONTAINS("-socket-server-"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlSocketServer, "CIoctlSocketServer")
    }

    if (SYMBOLIC_NAME_CONTAINS(szANSI_SOCKET_CLIENT))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlSocketClient, "CIoctlSocketClient")
    }

    if (SYMBOLIC_NAME_CONTAINS("-TCP-server-"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlTCPSrv, "CIoctlTCPSrv")
    }

    if (SYMBOLIC_NAME_CONTAINS(szANSI_TCP_CLIENT))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlTCPClient, "CIoctlTCPClient")
    }

    if (
		SYMBOLIC_NAME_CONTAINS("-TCP-Device-") || 
		REAL_NAME_IS("\\Device\\Tcp") || 
		REAL_NAME_IS("\\Device\\Udp") || 
		REAL_NAME_IS("\\Device\\RawIp")
		)
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlTcp, "CIoctlTcp")
    }

    if (SYMBOLIC_NAME_CONTAINS("-IP-Device-") || REAL_NAME_IS("\\Device\\Ip"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlIp, "CIoctlIp")
    }

    if (SYMBOLIC_NAME_CONTAINS("-IPMcast-Device-") || REAL_NAME_IS("\\Device\\IpMulticast"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlIpMcast, "CIoctlIpMcast")
    }

    if (SYMBOLIC_NAME_CONTAINS("-IPSEC-Device-") || REAL_NAME_IS("\\Device\\IpSec"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlIpSec, "CIoctlIpSec")
    }

    if (SYMBOLIC_NAME_CONTAINS("-RasAcd-Device-") || REAL_NAME_IS("\\Device\\RasAcd"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlRasAcd, "CIoctlRasAcd")
    }
/*
    if (SYMBOLIC_NAME_CONTAINS("-ARP1394-Device-"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlARP1394, "CIoctlARP1394")
    }
*/
    if (SYMBOLIC_NAME_CONTAINS("-TDI-Device-"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlTdi, "CIoctlTdi")
    }

/*
    if (REAL_NAME_IS("\\Device\\LanmanServer"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlDriverBase, "CIoctlDriverBase")
    }
*/
    if (REAL_NAME_IS("\\Device\\LanmanRedirector"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlBrowser, "CIoctlBrowser")
    }
    if (REAL_NAME_IS("\\Device\\LanmanDatagramReceiver"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlBrowser, "CIoctlBrowser")
    }
	
	
    if (SYMBOLIC_NAME_CONTAINS("-filemap-"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlFilemap, "CIoctlFilemap")
    }

    if (SYMBOLIC_NAME_CONTAINS("volume"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlFile, "CIoctlFile")
    }

    if (REAL_NAME_CONTAINS("volume"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlFile, "CIoctlFile")
    }

	/*
    if (0 == _tcsncicmp(USE_REAL_NAME_PREFIX, m_szSymbolicName, lstrlen(USE_REAL_NAME_PREFIX)))
    {
        DPF((TEXT("Using real name - %s\n"), m_szDevice));
        return true;
    }

    DPF((TEXT("Using symbolic name - %s\n"), m_szSymbolicName));
    return false;
*/

    if (SYMBOLIC_NAME_CONTAINS("-NtVdm-"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlNtVdm, "CIoctlNtVdm")
    }

    if (SYMBOLIC_NAME_CONTAINS("-STD_OUTPUT-"))
    {
		TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlStdOutput, "CIoctlStdOutput")
    }


	TRY_HARD_TO_RETURN_NEW_OBJECT(CIoctlDefault, "CIoctlDefault")

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\common.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*
#include <wchar.h>
#include <stdlib.h>
#include <windows.h>
*/
#include "common.h"

//
// TODO: there should be a way of a user altering this list, to suit one's lab
//
static char *s_ansiMachineNames[] = {
    "4RS1CL1",
    "ADIK1",
    "ADIK2",
    "ADIK5",
    "ADINAH0",
    "ADINAH1",
    "ALALAB0_WFW",
    "ALEXF10",
    "ALEXF5",
    "ALEXP",
    "CLI",
    "ALEXP1",
    "ALEXPSRV",
    "NT5",
    "ALP2",
    "AMNONH_LAP",
    "ANATL0",
    "ANATO1",
    "ASAFS1",
    "ASSAFH",
    "AVIN4",
    "NT5",
    "BARAKH0",
    "BARAKH1NTS",
    "BENIL0",
    "BENIL1",
    "BOAZE1",
    "BOAZE2",
    "BOAZE3",
    "BOAZF2",
    "BOAZF6",
    "BTK0",
    "CATSTRSDBG",
    "CATSTRSFS",
    "CATTEST1",
    "CLT2",
    "COMETBVT",
    "COMETBVT2",
    "COMETBVTAXP",
    "COMETBVTNT4",
    "COMETBVTNT5",
    "COMETSH",
    "COMETVSS",
    "CVSS",
    "DANGOLD0",
    "DANGOLD1",
    "DANGOLD3",
    "DANIC5",
    "DANICD0",
    "DANL1",
    "DANW2KW",
    "DBG5DC",
    "DEKELIC1",
    "DORYZ3",
    "DORYZDNS",
    "DOVH01",
    "DOVH02",
    "DRIVERS1",
    "DSL4SRV1",
    "DSL4WKS1",
    "EITAN0",
    "EITANPEC0",
    "ELIM8",
    "ELIMSRV",
    "NT5",
    "ELIMSRV",
    "W2K1",
    "ELIRANN0",
    "ELIRANN0_2",
    "ELIRANN1_1",
    "ELIRANN2",
    "ELIRANN2K",
    "ERANY0",
    "ERANY1",
    "W98",
    "ERANY2",
    "EREZAM4",
    "ETI01",
    "EVGENIA0",
    "EVGENIA1",
    "EYALZ2",
    "FALBLD_AUX",
    "FALBLD_AUX_AXP",
    "FALBLD_MAIN",
    "FALBLD_MAIN_AXP",
    "FALROCK",
    "FALSRV",
    "FAXSH",
    "FAXTST01",
    "FBDSPEC",
    "FBIC1",
    "FBSPDC",
    "FBSPFRS",
    "FBSPIC",
    "G98",
    "GAL98",
    "GALB10",
    "GENNADYP0",
    "GENNADYP1",
    "GENNADYP2",
    "GENNADYP3",
    "GENNADYP4",
    "GENNADYP5",
    "GILSH0",
    "GILSH10",
    "GILSH11",
    "GILSH12",
    "GREGOSRV",
    "W2K",
    "GUYM1",
    "GUYM4_WIN98",
    "HAI",
    "ARCH2",
    "HAI",
    "ARCH3",
    "HAI1AXP",
    "HAI1X86",
    "HAIFABACKUP",
    "HAIFABLD",
    "HAIFACAT",
    "HAIFADC",
    "HAIFAFRS",
    "HAIFAFS",
    "HAIFAPEC",
    "HAIFAROCK",
    "HAIFASLM",
    "HAIFASQL",
    "HAIFASRV",
    "HAIPRN",
    "HAPICLNT",
    "NT4",
    "HAPIPRX",
    "SP5",
    "IDIT",
    "IDIT",
    "NT5SRV",
    "IMPALA",
    "IMPDEBUG0",
    "IMPDEBUG1",
    "IMPROXY",
    "IMPX86",
    "ISHAIB0",
    "ISHAIB7",
    "ISHAIB9",
    "ITTAIG1",
    "IVR0BLD",
    "IVR10NETSP",
    "IVR11MP",
    "IVR12MONKEY",
    "IVR15MT",
    "IVR17RHT",
    "IVR18WKS",
    "IVR19PERF",
    "IVR1SH",
    "IVR22MONKEY",
    "IVR25RHT",
    "IVR27BLD",
    "IVR2IIS",
    "IVR30STRESS",
    "IVR31ECON",
    "IVR32MDM",
    "IVR33STRESS",
    "IVR34STRESS",
    "IVR36STRESS",
    "IVR6NMS",
    "IVR9TST",
    "K2HAIFABSC",
    "KDEBUGERSH",
    "KERENG0",
    "LEORAM1",
    "LIORM0",
    "LIORM2",
    "MEIRS7",
    "MEIRSRV",
    "NT5",
    "MICKYS001",
    "MICKYS0NT5",
    "MILENA0",
    "MILENA1",
    "MJARUS7",
    "MKORINMA0",
    "MOSHEC0",
    "MOSHIK0",
    "MP11",
    "MP13",
    "MP14",
    "MP17",
    "MP24NT5",
    "MP25NT5",
    "MP28NT5",
    "MP30",
    "MP31",
    "MP7",
    "MPALPHA0",
    "MPLAB",
    "MPQUADNT5",
    "MSHAIFA",
    "MSMQWEB",
    "NAMIT10",
    "NAMIT4",
    "NAMIT5",
    "NAMIT6",
    "NATHANL0",
    "NIRA",
    "NT5SRV",
    "NIRA0",
    "NIRK0",
    "NME3GBW2K",
    "OBODNER0",
    "ODEDS1",
    "ODEDS2",
    "OFERG1",
    "OFERG6",
    "OFIRY0",
    "OHAD1",
    "OHADM1",
    "OHADM2",
    "ORBENCOPMAQ",
    "ORENK0",
    "OVEDI0",
    "OVEDI3",
    "WKS",
    "OVEDI4",
    "W2K",
    "OVEDSRV",
    "W2K",
    "OVEDSRV2",
    "BLD",
    "PAMELABE1",
    "PERFBLD",
    "PQS170899",
    "PQSBLD",
    "PQSBLDAXP",
    "PQSPNG",
    "PROXYWEB",
    "RGRSKD",
    "RGRSMGR",
    "ROMAN0",
    "RONA1",
    "RONASRV",
    "W2K",
    "RONENB7",
    "RONENO1",
    "ROYTAL2",
    "ROYTAL4",
    "ROYTAL6",
    "S",
    "PROXY",
    "SAMFS",
    "SAMUSER7_01",
    "SHAIB0",
    "SHAIBCDR",
    "SHARONB0",
    "SHARONB1",
    "SHIMON1A",
    "SHIMONC0",
    "SHY1",
    "SHY5",
    "SIGALITB0",
    "SIGALITB1",
    "SIGALITB2",
    "SIGALITB3",
    "SL64",
    "SAFE",
    "SP4ANTE",
    "SP4ANTS",
    "SP4ANTW",
    "SP4INTE",
    "SP4INTS3",
    "STP1DS",
    "STP3DSCLIENT",
    "TALIMAGE",
    "TALSH0",
    "TZACHID0",
    "TZACHID1",
    "TZACHID4",
    "URIB0",
    "URIB1",
    "VICMA0",
    "VLAD0",
    "VLAD1",
    "VLAD2",
    "YAELS0",
    "YAIRH0",
    "YAIRH1",
    "YIFATP1",
    "YIFATP3",
    "YIFATP5",
    "YOSSG0",
    "YOSSG1",
    "ZIVM1",
    "ZIVM2",
    "ZIVM3",
    "ZIVTST1",
    "ZOHARS4",
    "ZOHARS5",
    "ZOHARS7",
    "ZOHARS9"
	};

char* GetRandomMachineName()
{
	return s_ansiMachineNames[rand()%(sizeof(s_ansiMachineNames)/sizeof(*s_ansiMachineNames))];
}

//
// TODO: there should be a way of a user altering this list
//
static char *s_ansiInternetAddress[] = {
	"www.pku.edu.cn",
	"www.microsoft.com",
	"msdn.microsoft.com",
	"msdn.microsoft.com",
	"host.cnbc.com",
	"export.msnbc.com",
	"msdn.microsoft.com",
	"msdn.microsoft.com",
	"www.delphi.com",
	"microsoft.com",
	"msdn.microsoft.com",
	"msdn.microsoft.com",
	"export.msnbc.com",
	"msdn.microsoft.com",
	"www.oracle.com",
	"msdn.microsoft.com",
	"msdn.microsoft.com",
	"expedia.de",
	"export.msnbc.com",
	"msdn.microsoft.com",
	"msdn.microsoft.com",
	"windowsupdate.microsoft.com",
	"msdn.microsoft.com",
	"sandiego.sidewalk.com",
	"msdn.microsoft.com",
	"export.msnbc.com",
	"ad.preferences.com",
	"windowsupdate.microsoft.com",
	"msdn.microsoft.com",
	"msdn.microsoft.com",
	"www.pku.edu.cn",
	"ad.preferences.com",
	"export.msnbc.com",
	"windowsupdate.microsoft.com",
	"msdn.microsoft.com",
	"msdn.microsoft.com",
	"export.msnbc.com",
	"recruiter.monster.com",
	"windowsupdate.microsoft.com",
	"expedia.de",
	"investor.msn.com",
	"www.oracle.com",
	"export.msnbc.com",
	"fp.cnbc.com",
	"microsoft.com",
	"www.oracle.com",
	"export.msnbc.com",
	"expedia.de",
	"expedia.de",
	"microsoft.com",
	"www.spe.sony.com",
	"host.cnbc.com",
	"www.pencomputing.com",
	"www.cnbc.com",
	"export.msnbc.com",
	"www.spe.sony.com",
	"www.oracle.com",
	"www.cnbc.com",
	"www.oracle.com",
	"www.cnbc.com",
	"expedia.de",
	"www.spe.sony.com",
	"expedia.de",
	"export.msnbc.com",
	"www.oracle.com",
	"www.pencomputing.com",
	"recruiter.monster.com",
	"export.msnbc.com",
	"www.spe.sony.com",
	"www.gcrio.org",
	"www.pencomputing.com",
	"www.oracle.com",
	"www.spe.sony.com",
	"export.msnbc.com",
	"furniturepoint.homepoint.com",
	"www.spe.sony.com",
	"export.msnbc.com",
	"furniturepoint.homepoint.com",
	"www.tvguide.com",
	"tvguide.com",
	"export.msnbc.com",
	"tvguide.com",
	"www.oracle.com",
	"export.msnbc.com",
	"www.pencomputing.com",
	"www.pencomputing.com",
	"export.msnbc.com",
	"export.msnbc.com",
	"www.pencomputing.com",
	"www.pencomputing.com",
	"www.oracle.com",
	"www.spe.sony.com",
	"www.pencomputing.com",
	"export.msnbc.com",
	"www.spe.sony.com",
	"www.spe.sony.com",
	"export.msnbc.com",
	"tvguide.com",
	"www.pencomputing.com",
	"www.pencomputing.com",
	"export.msnbc.com",
	"www.oracle.com",
	"www.pencomputing.com",
	"www.pencomputing.com",
	"www.spe.sony.com",
	"sandiego.sidewalk.com",
	"sandiego.sidewalk.com",
	"www.spe.sony.com",
	"export.msnbc.com",
	"www.spe.sony.com",
	"sandiego.sidewalk.com",
	"www.pencomputing.com",
	"www.pencomputing.com",
	"www.jp.msn.com",
	"www.spe.sony.com",
	"export.msnbc.com",
	"www.pencomputing.com",
	"activex.microsoft.com",
	"www.spe.sony.com",
	"www.spe.sony.com",
	"www.pencomputing.com",
	"recruiter.monster.com",
	"export.msnbc.com",
	"www.spe.sony.com",
	"www.oracle.com",
	"search.microsoft.com",
	"search.microsoft.com",
	"export.msnbc.com",
	"www.spe.sony.com",
	"www.spe.sony.com",
	"export.msnbc.com",
	"www.daikyo.co.jp",
	"export.msnbc.com",
	"search.microsoft.com",
	"131.107.19.59",
	"recruiter.monster.com",
	"export.msnbc.com",
	"www.oracle.com",
	"www.oracle.com",
	"export.msnbc.com",
	"www.delphi.com",
	"www.spe.sony.com",
	"search.microsoft.com",
	"export.msnbc.com",
	"www.spe.sony.com",
	"www.spe.sony.com",
	"export.msnbc.com",
	"recruiter.monster.com",
	"www.oracle.com",
	"furniturepoint.homepoint.com",
	"www.oracle.com",
	"export.msnbc.com",
	"export.msnbc.com",
	"furniturepoint.homepoint.com",
	"export.msnbc.com",
	"www.oracle.com",
	"www.delphi.com",
	"www.daikyo.co.jp",
	"www.match.com",
	"export.msnbc.com",
	"www.spe.sony.com",
	"www.spe.sony.com",
	"www.delphi.com",
	"www.spe.sony.com",
	"export.msnbc.com",
	"www.oracle.com",
	"export.msnbc.com",
	"moneycentral.msn.com",
	"quartz.gly.fsu.edu",
	"www.oracle.com",
	"export.msnbc.com",
	"ad.doubleclick.net",
	"moneycentral.msn.com",
	"export.msnbc.com",
	"www.spe.sony.com",
	"export.msnbc.com",
	"www.spe.sony.com",
	"investor.msn.com",
	"www.daikyo.co.jp",
	"ad.doubleclick.net",
	"export.msnbc.com",
	"host.cnbc.com",
	"export.msnbc.com",
	"www.oracle.com",
	"export.msnbc.com",
	"www.daikyo.co.jp",
	"export.msnbc.com",
	"host.cnbc.com",
	"export.msnbc.com",
	"weather.asahi.com",
	"host.cnbc.com",
	"export.msnbc.com",
	"export.msnbc.com",
	"furniturepoint.homepoint.com",
	"export.msnbc.com",
	"gcrio.ciesin.org",
	"recruiter.monster.com",
	"export.msnbc.com",
	"furniturepoint.homepoint.com",
	"export.msnbc.com",
	"ad.doubleclick.net",
	"www.msnbc.com",
	"export.msnbc.com",
	"image.linkexchange.com",
	"export.msnbc.com",
	"investor.msn.com",
	"export.msnbc.com",
	"export.msnbc.com",
	"hotline.curio-city.com",
	"export.msnbc.com",
	"furniturepoint.homepoint.com",
	"www.weathervane.rff.org",
	"export.msnbc.com",
	"export.msnbc.com",
	"export.msnbc.com",
	"forum.dvdtalk.com",
	"export.msnbc.com",
	"131.107.19.59",
	"export.msnbc.com",
	"investing.schwab.com",
	"dir.yahoo.com",
	"export.msnbc.com",
	"ads.x10.com",
	"export.msnbc.com",
	"furniturepoint.homepoint.com",
	"export.msnbc.com",
	"export.msnbc.com",
	"www.spe.sony.com",
	"export.msnbc.com",
	"export.msnbc.com",
	"www.firingsquad.com",
	"http.pager.yahoo.com",
	"export.msnbc.com",
	"export.msnbc.com",
	"www.sytadin.tm.fr",
	"export.msnbc.com",
	"www.bloomberg.com",
	"www.spe.sony.com",
	"adforce.imgis.com",
	"export.msnbc.com",
	"207.77.61.199",
	"www.spe.sony.com",
	"www.spe.sony.com",
	"export.msnbc.com",
	"export.msnbc.com",
	"www.egroups.com",
	"www.chinahot.com",
	"export.msnbc.com",
	"recruiter.monster.com",
	"expedia.de",
	"services.msn.com",
	"pubs.mgn.net",
	"banners.orbitcycle.com",
	"imhome1",
	"recruiter.monster.com",
	"imhome1",
	"oe.hotmail.msn.com",
	"furniturepoint.homepoint.com",
	"furniturepoint.homepoint.com",
	"pubs.mgn.net",
	"chinahot.com",
	"expedia.de",
	"expedia.de",
	"ads.msn.com",
	"ujura.millto.net",
	"ie.fr.msn.com",
	"www.staykauai.com",
	"chinahot.com",
	"216.100.231.21",
	"www.staykauai.com",
	"chinahot.com",
	"www.sytadin.tm.fr",
	"search.microsoft.com",
	"oe.hotmail.msn.com",
	"a1896.g.akamaitech.net",
	"ads.eu.msn.com",
	"search.microsoft.com",
	"chinahot.com",
	"chinahot.com",
	"recruiter.monster.com",
	"ie.fr.msn.com",
	"www.zdnet.com",
	"ads.msn.com",
	"search.microsoft.com",
	"chinahot.com",
	"chinahot.com",
	"www.zdnet.com",
	"recruiter.monster.com",
	"search.microsoft.com",
	"furniturepoint.homepoint.com",
	"furniturepoint.homepoint.com",
	"dir.yahoo.com",
	"www.delphi.com",
	"chinahot.com",
	"www.delphi.com",
	"chinahot.com",
	"www.msnbc.com",
	"scores.espn.go.com",
	"recruiter.monster.com",
	"cs1.chat.yahoo.com",
	"chinahot.com",
	"www.msnbc.com",
	"www.eea.dk",
	"chinahot.com",
	"www.oracle.com",
	"chinahot.com",
	"www.wsdot.wa.gov",
	"131.107.19.59",
	"ujura.millto.net",
	"www.zdnet.com",
	"www.dongailbo.co.kr",
	"www.btm.co.jp",
	"www0.delphi.com",
	"www.oracle.com",
	"sandiego.sidewalk.com",
	"www.wsdot.wa.gov",
	"www.dongailbo.co.kr",
	"www.spe.sony.com",
	"dir.yahoo.com",
	"www.spe.sony.com",
	"www.msnbc.com",
	"www.spe.sony.com",
	"www.oracle.com",
	"investor.msn.com",
	"www.dongailbo.co.kr",
	"www.oracle.com",
	"arc5.msn.com",
	"nbcin.king5.com",
	"furniturepoint.homepoint.com",
	"furniturepoint.homepoint.com",
	"moneycentral.msn.com",
	"www.delphi.com",
	"www.delphi.com",
	"msp-jpn.one.microsoft.com",
	"oe.hotmail.msn.com",
	"www.oracle.com",
	"www.dongailbo.co.kr",
	"dir.yahoo.com",
	"www.yk.rim.or.jp",
	"www.cfw.com",
	"www.africam.com",
	"auto.search.msn.com",
	"www.oracle.com",
	"www.sohu.com.cn",
	"www.delphi.com",
	"202.96.223.54",
	"www.oracle.com",
	"personal.cfw.com",
	"www.dongailbo.co.kr",
	"www.venus.dti.ne.jp",
	"www.cfw.com",
	"trading.etrade.com",
	"personal.cfw.com",
	"recruiter.monster.com",
	"www.dongailbo.co.kr",
	"www.delphi.com",
	"furniturepoint.homepoint.com",
	"216.100.231.21",
	"www.cfw.com",
	"recruiter.monster.com",
	"www.dongailbo.co.kr",
	"oe.hotmail.msn.com",
	"personal.cfw.com",
	"www.delphi.com",
	"lw1fd.hotmail.msn.com",
	"www.cfw.com",
	"personal.cfw.com",
	"www.dongailbo.co.kr",
	"msp-jpn.one.microsoft.com",
	"sandiego.sidewalk.com",
	"oe.hotmail.msn.com",
	"www.cfw.com",
	"www.dongailbo.co.kr",
	"msp-jpn.one.microsoft.com",
	"personal.cfw.com",
	"www.iab.com",
	"www.dongailbo.co.kr",
	"www.smithbarney.com",
	"www.cfw.com",
	"http.pager.yahoo.com",
	"209.185.130.251",
	"auto.search.msn.com",
	"personal.cfw.com",
	"www.smithbarney.com",
	"oe.hotmail.msn.com",
	"www.msn.com",
	"www.cfw.com",
	"http.pager.yahoo.com",
	"personal.cfw.com",
	"edit.yahoo.com",
	"ink.yahoo.com",
	"www.cfw.com",
	"www.fujibank.co.jp",
	"personal.cfw.com",
	"oe.hotmail.msn.com",
	"www.cfw.com",
	"personal.cfw.com",
	"oe.hotmail.msn.com",
	"people.a2000.nl",
	"scores.espn.go.com",
	"www.dongailbo.co.kr",
	"www.cfw.com",
	"sandiego.sidewalk.com",
	"oe.hotmail.msn.com",
	"personal.cfw.com",
	"www.dongailbo.co.kr",
	"go.msn.com",
	"biz.yahoo.com",
	"auto.search.msn.com",
	"www.msn.com",
	"auto.search.msn.com",
	"www.cfw.com",
	"ads.msn.com",
	"www.dongailbo.co.kr",
	"personal.cfw.com",
	"auto.search.msn.com",
	"recruiter.monster.com",
	"www.ssm.wustl.edu",
	"www.cfw.com",
	"lw1fd.hotmail.msn.com",
	"personal.cfw.com",
	"www.msn.com",
	"www.cfw.com",
	"auto.search.msn.com",
	"personal.cfw.com",
	"www.egroups.com",
	"www.cfw.com",
	"216.100.231.21",
	"207.77.61.199",
	"personal.cfw.com",
	"auto.search.msn.com",
	"www.hotmail.com",
	"www.msnbc.com",
	"209.185.130.251",
	"www.msnbc.com",
	"www.msnbc.com",
	"auto.search.msn.com",
	"msimg.com",
	"www.msn.com",
	"209.185.130.251",
	"www.iab.com",
	"go.msn.com",
	"recruiter.monster.com",
	"www.arc.ab.ca",
	"go.msn.com",
	"www.iab.com",
	"www.wsdot.wa.gov",
	"images.wsdot.wa.gov",
	"www.iab.com",
	"recruiter.monster.com",
	"www.iab.com",
	"www.quicken.com",
	"www.iab.com",
	"www.iab.com",
	"www.wsdot.wa.gov",
	"www.iab.com",
	"images.wsdot.wa.gov",
	"www.etd.ameslab.gov",
	"recruiter.monster.com",
	"www.iab.com",
	"furniturepoint.homepoint.com",
	"furniturepoint.homepoint.com",
	"www.iab.com",
	"www.iab.com",
	"sidewalk.msn.com",
	"www.msnbc.com",
	"www.msnbc.com",
	"www.zdnet.com",
	"www.expedia.com",
	"www.iab.com",
	"www.iab.com",
	"www.expedia.com",
	"ads09.focalink.com",
	"www.expedia.com",
	"www.expedia.com",
	"www.expedia.com",
	"sidewalk.msn.com",
	"www.expedia.com",
	"www.expedia.com",
	"www.expedia.com",
	"www.expedia.com",
	"www.slate.com",
	"www.expedia.com",
	"www.expedia.com",
	"www.audubon.org",
	"www.expedia.com",
	"www.expedia.com",
	"view.avenuea.com",
	"expedia.msn.com",
	"www.expedia.com",
	"van.ads.link4ads.com",
	"www.expedia.com",
	"ads.msn.com",
	"www.expedia.com",
	"www.expedia.com",
	"www.expedia.com",
	"www.expedia.com",
	"www.expedia.com",
	"www.quote.yahoo.com",
	"www.expedia.com",
	"www.expedia.com",
	"quote.yahoo.co.jp",
	"www.expedia.com",
	"www.expedia.com",
	"www.expedia.com",
	"ads.fp.sandpiper.net",
	"furniturepoint.homepoint.com",
	"www.expedia.com",
	"www.expedia.com",
	"www.expedia.com",
	"www.expedia.com",
	"www.expedia.com",
	"chinahot.com",
	"www.expedia.com",
	"furniturepoint.homepoint.com",
	"www.expedia.com",
	"www.expedia.com",
	"www.expedia.com",
	"www.expedia.com",
	"www.expedia.com",
	"channels.microsoft.com",
	"www.egroups.com",
	"a1896.g.akamaitech.net",
	"www.ead.anl.gov",
	"www.slate.com",
	"www.slate.com",
	"moneycentral.msn.com",
	"www.slate.com",
	"moneycentral.msn.com",
	"hotline.curio-city.com",
	"www.slate.com",
	"www.expedia.com",
	"www.expedia.com",
	"www.expedia.com",
	"www.slate.com",
	"www.slate.com",
	"ads.msn.com",
	"www.slate.com",
	"moneycentral.msn.com",
	"recruiter.monster.com",
	"www.slate.com",
	"www.slate.com",
	"furniturepoint.homepoint.com",
	"www.slate.com",
	"www.slate.com",
	"http.pager.yahoo.com",
	"www.slate.com",
	"www.slate.com",
	"furniturepoint.homepoint.com",
	"www.slate.com",
	"www.slate.com",
	"ads18.focalink.com",
	"www.slate.com",
	"www.math.pku.edu.cn",
	"www.slate.com",
	"www.egroups.com",
	"www.slate.com",
	"www.slate.com",
	"www.match.com",
	"www.pi.se",
	"www.slate.com",
	"www.slate.com",
	"www.slate.com",
	"www.pi.se",
	"moneycentral.msn.com",
	"ujura.millto.net",
	"www.pi.se",
	"www.pi.se",
	"investing.schwab.com",
	"www.pi.se",
	"www.pi.se",
	"sidewalk.msn.com",
	"sandiego.sidewalk.com",
	"www.quicken.com",
	"www.pi.se",
	"furniturepoint.homepoint.com",
	"www.pi.se",
	"lc3.law5.hotmail.passport.com",
	"furniturepoint.homepoint.com",
	"ad.preferences.com",
	"lc3.law5.hotmail.passport.com",
	"ad.preferences.com",
	"www.cnnfn.com",
	"www.pi.se",
	"216.33.151.8",
	"www.pi.se",
	"216.33.151.8",
	"www.quicken.com",
	"sidewalk.msn.com",
	"www.pi.se",
	"www.pi.se",
	"ad.preferences.com",
	"www.pi.se",
	"oe.hotmail.msn.com",
	"193.22.36.180",
	"expedia.de",
	"www.buydig.com",
	"www.buydig.com",
	"sandiego.sidewalk.com",
	"www.pi.se",
	"131.107.19.59",
	"adforce.imgis.com",
	"www.buydig.com",
	"oe.hotmail.msn.com",
	"furniturepoint.homepoint.com",
	"sandiego.sidewalk.com",
	"furniturepoint.homepoint.com",
	"banners.orbitcycle.com",
	"expedia.de",
	"www.msnbc.com",
	"www.cnnfn.com",
	"www.msnbc.com",
	"www.msnbc.com",
	"www.zdnet.com",
	"biztech.nikkeibp.co.jp",
	"busview.its.washington.edu",
	"www.cgrer.uiowa.edu",
	"expedia.de",
	"www.playboy.com",
	"209.185.131.20",
	"csweb",
	"moneycentral.msn.com",
	"moneycentral.msn.com",
	"www.yk.rim.or.jp",
	"www.msnbc.com",
	"expedia.de",
	"www.playboy.com",
	"209.185.131.20",
	"www.msnbc.com",
	"www.quote.yahoo.com",
	"www.msnbc.com",
	"www.msnbc.com",
	"www.zdnet.com",
	"mail.curio-city.com",
	"www.infoseek.com",
	"expedia.de",
	"forum.dvdtalk.com",
	"furniturepoint.homepoint.com",
	"www.uea.ac.uk",
	"webmail.pi.se",
	"furniturepoint.homepoint.com",
	"www.msnbc.com",
	"movies2.braidedwhip.com",
	"a32.g.a.yimg.com",
	"www.rediff.co.in",
	"www.buydig.com",
	"expedia.de",
	"msp-jpn.one.microsoft.com",
	"www.buydig.com",
	"www2.netvigator.com",
	"www.buydig.com",
	"ads.msn.com",
	"ads.msn.com",
	"images.cnnfn.com",
	"a111.g.akamaitech.net",
	"www.buydig.com",
	"www2.netvigator.com",
	"www.buydig.com",
	"cnnfn.com",
	"cnnfn.com",
	"www2.netvigator.com",
	"www.microsoft.com",
	"www.msnbc.com",
	"www2.netvigator.com",
	"a111.g.akamaitech.net",
	"a111.g.akamaitech.net",
	"a111.g.akamaitech.net",
	"www.microsoft.com",
	"a111.g.akamaitech.net",
	"a111.g.akamaitech.net",
	"a111.g.akamaitech.net",
	"www2.netvigator.com",
	"a111.g.akamaitech.net",
	"207.77.61.199",
	"www.rediff.com",
	"www.zdnet.com",
	"www.microsoft.com",
	"www2.netvigator.com",
	"fransmo.spedia.net",
	"www.microsoft.com",
	"a111.g.akamaitech.net",
	"auto.search.msn.com",
	"www.nleditions.com",
	"expedia.de",
	"games.yahoo.com",
	"www2.netvigator.com",
	"www-usa.cricket.org",
	"www-usa.cricket.org",
	"www-usa.cricket.org",
	"a111.g.akamaitech.net",
	"a111.g.akamaitech.net",
	"www2.netvigator.com",
	"www.microsoft.com",
	"www-usa.cricket.org",
	"auto.search.msn.com",
	"auto.search.msn.com",
	"www-usa.cricket.org",
	"www-usa.cricket.org",
	"lc1.law5.hotmail.passport.com",
	"www-usa.cricket.org",
	"expedia.de",
	"www.chinahot.com",
	"auto.search.msn.com",
	"auto.search.msn.com",
	"http.pager.yahoo.com",
	"www.microsoft.com",
	"www.infoseek.com",
	"fransmo.spedia.net",
	"www-usa.cricket.org",
	"www-usa.cricket.org",
	"www-usa.cricket.org",
	"www-usa.cricket.org",
	"www.nleditions.com",
	"www-usa.cricket.org",
	"navigation.us.realnames.com",
	"www-usa.cricket.org",
	"www.adclub.net",
	"www-usa.cricket.org",
	"www.cnnfn.com",
	"www-usa.cricket.org",
	"www-usa.cricket.org",
	"www-usa.cricket.org",
	"www.spedia.net",
	"a111.g.akamaitech.net",
	"investor.msn.com",
	"scores.espn.go.com",
	"webmail.pi.se",
	"fransmo.spedia.net",
	"www.yk.rim.or.jp",
	"24.1.178.244",
	"view.avenuea.com",
	"www.previewtravel.com",
	"a111.g.akamaitech.net",
	"infoseek.go.com",
	"www.cnnfn.com",
	"a1896.g.akamaitech.net",
	"www.microsoft.com",
	"131.107.19.59",
	"www.rediff.com",
	"msp-jpn.one.microsoft.com",
	"www.microsoft.com",
	"www.microsoft.com",
	"www.previewtravel.com",
	"www.microsoft.com",
	"chinahot.com",
	"webmail.pi.se",
	"www.microsoft.com",
	"webmail.pi.se",
	"reservations.previewtravel.com",
	"www.previewtravel.com",
	"reservations.previewtravel.com",
	"www-usa.cricket.org",
	"www2.netvigator.com",
	"www-usa.cricket.org",
	"www-usa.cricket.org",
	"www-usa.cricket.org",
	"oe.hotmail.msn.com",
	"www.previewtravel.com",
	"www.previewtravel.com",
	"www.rediff.com",
	"www-usa.cricket.org",
	"www-usa.cricket.org",
	"www.previewtravel.com",
	"wombat.doc.ic.ac.uk",
	"www.previewtravel.com",
	"www.rediff.com",
	"http.pager.yahoo.com",
	"www-usa.cricket.org",
	"farefinder.previewtravel.com",
	"webmail.pi.se",
	"ads18.focalink.com",
	"www.rediff.com",
	"chinahot.com",
	"webmail.pi.se",
	"www.msnbc.com",
	"moneycentral.msn.com",
	"farefinder.previewtravel.com",
	"www.iiv.de",
	"www.cwr.uwa.edu.au",
	"www.yk.rim.or.jp",
	"www.rediff.com",
	"www.iiv.de",
	"chinahot.com",
	"reservations.previewtravel.com",
	"farefinder.previewtravel.com",
	"www.previewtravel.com",
	"www.iiv.de",
	"farefinder.previewtravel.com",
	"expedia.de",
	"farefinder.previewtravel.com",
	"farefinder.previewtravel.com",
	"farefinder.previewtravel.com",
	"ie.pointcast.net",
	"www.rediff.com",
	"131.107.19.59",
	"farefinder.previewtravel.com",
	"farefinder.previewtravel.com",
	"investor.msn.com",
	"arc5.msn.com",
	"farefinder.previewtravel.com",
	"farefinder.previewtravel.com",
	"chinahot.com",
	"farefinder.previewtravel.com",
	"www.cpm.chalmers.se",
	"ads.msn.com",
	"moneycentral.msn.com",
	"www.wsdot.wa.gov",
	"www.wsdot.wa.gov",
	"hotline.curio-city.com",
	"moneycentral.msn.com",
	"recruiter.monster.com",
	"recruiter.monster.com",
	"ie.pointcast.net",
	"logo.msn.com",
	"24.1.178.244",
	"chinahot.com",
	"quicken.multexinvestor.com",
	"ie.pointcast.net",
	"www.passportimages.com",
	"ads.msn.com",
	"http.pager.yahoo.com",
	"209.185.131.20",
	"www.rediff.com",
	"www.beta.msn.co.kr",
	"quicken.multexinvestor.com",
	"www.delphi.com",
	"scores.espn.go.com",
	"quicken.multexinvestor.com",
	"recruiter.monster.com",
	"quicken.multexinvestor.com",
	"quicken.multexinvestor.com",
	"everest.hunter.cuny.edu",
	"149.174.183.174",
	"quicken.multexinvestor.com",
	"ad.doubleclick.net",
	"quicken.multexinvestor.com",
	"www.aftonbladet.se",
	"quicken.multexinvestor.com",
	"fp.cnbc.com",
	"quicken.multexinvestor.com",
	"quicken.multexinvestor.com",
	"chinahot.com",
	"adforce.imgis.com",
	"209.185.131.20",
	"wwwa.aftonbladet.se",
	"recruiter.monster.com",
	"ie.fr.msn.com",
	"ad.doubleclick.net",
	"www.yk.rim.or.jp",
	"windowsupdate.microsoft.com",
	"investor.msn.com",
	"www.rediff.com",
	"recruiter.monster.com",
	"ads.eu.msn.com",
	"moneycentral.msn.com",
	"www.cnnfn.com",
	"www.aftonbladet.se",
	"wwwa.aftonbladet.se",
	"search.msn.co.kr",
	"ads32.focalink.com",
	"chinahot.com",
	"ie.fr.msn.com",
	"envgov.ewc.hawaii.edu",
	"206.64.126.156",
	"moneycentral.msn.com",
	"trading.etrade.com",
	"windowsupdate.microsoft.com",
	"recruiter.monster.com",
	"www.buydig.com",
	"windowsupdate.microsoft.com",
	"www.aftonbladet.se",
	"chinahot.com",
	"windowsupdate.microsoft.com",
	"www.aftonbladet.se",
	"windowsupdate.microsoft.com",
	"206.64.126.156",
	"www.aftonbladet.se",
	"www.buydig.com",
	"www.buydig.com",
	"www.rediff.com",
	"www.msn.com",
	"www.ehmi.org",
	"www.aftonbladet.se",
	"investor.msn.com",
	"insa2.inn-salzach.de",
	"www.buydig.com",
	"famulus.msnbc.com",
	"people.a2000.nl",
	"206.64.126.156",
	"ie.search.msn.com",
	"wwwa.aftonbladet.se",
	"207.82.253.251",
	"www.yk.rim.or.jp",
	"chinahot.com",
	"www.buydig.com",
	"207.82.253.251",
	"www.eih.uh.edu",
	"wwwa.aftonbladet.se",
	"wwwa.aftonbladet.se",
	"207.77.61.199",
	"209.185.131.20",
	"chinahot.com",
	"recruiter.monster.com",
	"209.185.131.20",
	"chinahot.com",
	"cnnfn.com",
	"209.185.131.20",
	"www.hotmail.com",
	"ads.msn.com",
	"chinahot.com",
	"lc3.law5.hotmail.passport.com",
	"209.185.131.20",
	"update.companion.yahoo.com",
	"www.dongailbo.co.kr",
	"ie.pointcast.net",
	"www.chinahot.com",
	"www.smithbarney.com",
	"www.dongailbo.co.kr",
	"insa2.inn-salzach.de",
	"www.cnnfn.com",
	"perkolator.com",
	"moneycentral.msn.com",
	"wwwa.aftonbladet.se",
	"www.inn-salzach.de",
	"msp1.ectest.microsoft.com",
	"virtualairport.lufthansa.com"
	};

char *GetRandomInternetAddress()
{
	return s_ansiInternetAddress[rand()%(sizeof(s_ansiInternetAddress)/sizeof(*s_ansiInternetAddress))];
}


static WCHAR *s_ansiAdapterName[] = {
	L"NdisWan4",
	L"WANARP"
};

WCHAR* GetRandomAdapterName()
{
	return s_ansiAdapterName[rand()%(sizeof(s_ansiAdapterName)/sizeof(*s_ansiAdapterName))];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\defaultioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <windows.h>

#include "NtNativeIOCTL.h"
*/
#include "DefaultIOCTL.h"

static bool s_fVerbose = false;

void CIoctlDefault::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
	;
}

/*
HANDLE CIoctlDefault::CreateDevice(CDevice *pDevice)
{
    return CIoctlNtNative::StaticCreateDevice(pDevice);
}

BOOL CIoctlDefault::CloseDevice(CDevice *pDevice)
{
	_ASSERTE(FALSE);
    ;
}

BOOL CIoctlDefault::DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		)
{
	_ASSERTE(FALSE);
	return FALSE;
}

BOOL CIoctlDefault::DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		)
{
	_ASSERTE(FALSE);
	return FALSE;
}

BOOL CIoctlDefault::DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		)
{
	_ASSERTE(FALSE);
	return FALSE;
}

*/


void CIoctlDefault::CallRandomWin32API(LPOVERLAPPED pOL)
{
	return;
}


void CIoctlDefault::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
    CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
}


BOOL CIoctlDefault::FindValidIOCTLs(CDevice *pDevice)
{
    return CIoctl::FindValidIOCTLs(pDevice);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\common.h ===
#ifndef __COMMON_H
#define __COMMON_H

char* GetRandomMachineName();
char *GetRandomInternetAddress();
WCHAR* GetRandomAdapterName();

#endif //__COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\container.h ===
#ifndef __CONTAINER_H_
#define __CONTAINER_H_

#include <windows.h>
#include <crtdbg.h>


template <class T> class CContainer
{
public:
typedef BOOL (WINAPI *CLOSING_FUNCTION)(T);
	CContainer(UINT nInitialNumberOfItems, T tNullItem, CLOSING_FUNCTION fnClose);
	~CContainer();
	T GetRandomItem();
	T GetItem(ULONG ulIndex);
	T RemoveItem(ULONG ulIndex);
	T RemoveRandomItem();
	bool AddItem(T tItem);
	UINT Get_CurrentNumberOfSlots() {return m_uiCurrentNumberOfSlots;}
	UINT Get_NumOfValidEntries() {return m_uiNumOfValidEntries;}

private:
	bool EnlargeContainer();
	CRITICAL_SECTION m_cs;
	bool m_fCsInitialized;
	T _GetRandomItem(bool fRemove);
	T *m_aItems;
	UINT m_uiCurrentNumberOfSlots;
	UINT m_uiNumOfValidEntries;
	CLOSING_FUNCTION m_fnClose;
	T m_tNullItem;
	//
	// used to speed up the lookup for free indexes
	// a value of -1 means no value
	// this lookup is good only for large containers, otherwise it is bad.
	//
	long m_auiFreeIndexes[100];
	ULONG GetRandomIndex();

	bool Prolog();
};


template <class T> CContainer<T>::CContainer(UINT nInitialNumberOfItems, T tNullItem, CLOSING_FUNCTION fnClose):
m_fnClose(fnClose),
m_tNullItem(tNullItem),
m_uiCurrentNumberOfSlots(nInitialNumberOfItems),
m_uiNumOfValidEntries(0),
m_fCsInitialized(false),
m_aItems(NULL)
{
	for (UINT i = 0; i < (sizeof(m_auiFreeIndexes)/sizeof(*m_auiFreeIndexes)); i++)
	{
		m_auiFreeIndexes[i] = -1;
	}

	if (0 == m_uiCurrentNumberOfSlots)
	{
		m_uiCurrentNumberOfSlots = 1;
	}
	Prolog();

}

template <class T> CContainer<T>::~CContainer()
{
	if (NULL != m_aItems)
	{
		for (UINT i = 0; i < m_uiCurrentNumberOfSlots; i++)
		{
			if (m_tNullItem != m_aItems[i])
			{
				m_fnClose(m_aItems[i]);
			}
		}
		delete[] m_aItems;
	}
}

template <class T> T CContainer<T>::GetRandomItem()
{
	return _GetRandomItem(false);
}

template <class T> T CContainer<T>::RemoveRandomItem()
{
	return _GetRandomItem(true);
}

template <class T> T CContainer<T>::_GetRandomItem(bool fRemove)
{
	T tRetval = m_tNullItem;

	if (!Prolog())
	{
		return m_tNullItem;
	}

	::EnterCriticalSection(&m_cs);

	ULONG i;
	ULONG ulRandomIndex;

	if (0 == m_uiNumOfValidEntries)
	{
		goto out;
	}

	ulRandomIndex = GetRandomIndex();
	for (i = ulRandomIndex; i < m_uiCurrentNumberOfSlots; i++)
	{
		if (m_tNullItem != m_aItems[i])
		{
			if (fRemove)
			{
				tRetval = m_aItems[i];
				m_aItems[i] = m_tNullItem;
				m_uiNumOfValidEntries--;
				_ASSERTE(!(0x80000000 & m_uiNumOfValidEntries));
				goto out;
			}
			tRetval = m_aItems[i];
			goto out;
		}
	}
	//
	// we did not find a valid entry yet.
	// if we start from index 0, we will always return the 1st valid index, which is not that random
	//
	for (i = 0; i < ulRandomIndex; i++)
	{
		if (m_tNullItem != m_aItems[i])
		{
			if (fRemove)
			{
				tRetval = m_aItems[i];
				m_aItems[i] = m_tNullItem;
				m_uiNumOfValidEntries--;
				_ASSERTE(!(0x80000000 & m_uiNumOfValidEntries));
				goto out;
			}
			tRetval = m_aItems[i];
			goto out;
		}
	}

	_ASSERTE(FALSE);

out:
	::LeaveCriticalSection(&m_cs);
	return tRetval;
}



template <class T> bool CContainer<T>::AddItem(T tItem)
{
	bool fRetval = false;

	if (!Prolog())
	{
		return false;
	}

	::EnterCriticalSection(&m_cs);

	ULONG i;
	if (m_uiCurrentNumberOfSlots == m_uiNumOfValidEntries)
	{
		if (!EnlargeContainer())
		{
			goto out;
		}
	}

	//
	// optimization in case EnlargeContainer() was just called
	//
	for (i = m_uiNumOfValidEntries; i < m_uiCurrentNumberOfSlots; i++)
	{
		if (m_tNullItem == m_aItems[i])
		{
			m_aItems[i] = tItem;
			fRetval = true;
			goto out;
		}
	}
	for (i = 0; i < m_uiNumOfValidEntries; i++)
	{
		if (m_tNullItem == m_aItems[i])
		{
			m_aItems[i] = tItem;
			fRetval = true;
			goto out;
		}
	}
	_ASSERTE(FALSE);

out:
	if (fRetval)
	{
		m_uiNumOfValidEntries++;
		_ASSERTE(!(0x80000000 & m_uiNumOfValidEntries));
	}
	::LeaveCriticalSection(&m_cs);
	return fRetval;
}


template <class T> T CContainer<T>::GetItem(ULONG ulIndex)
{
	T tRetval = m_tNullItem;

	if (!Prolog())
	{
		return m_tNullItem;
	}


	::EnterCriticalSection(&m_cs);

	if (ulIndex >= m_uiCurrentNumberOfSlots)
	{
		goto out;
	}

	tRetval = m_aItems[i];
out:
	::LeaveCriticalSection(&m_cs);
	return tRetval;
}


template <class T> T CContainer<T>::RemoveItem(ULONG ulIndex)
{
	T tRetval = m_tNullItem;

	if (!Prolog())
	{
		return m_tNullItem;
	}


	::EnterCriticalSection(&m_cs);

	if (ulIndex >= m_uiCurrentNumberOfSlots)
	{
		goto out;
	}

	tRetval = m_aItems[ulIndex];
	m_aItems[ulIndex] = m_tNullItem;
	m_uiNumOfValidEntries--;
	_ASSERTE(!(0x80000000 & m_uiNumOfValidEntries));
out:
	::LeaveCriticalSection(&m_cs);
	return tRetval;
}


template <class T> inline ULONG CContainer<T>::GetRandomIndex()
{
	return ((((rand()%2)<<17) | (rand()<<2) | (rand()%4))%m_uiNumOfValidEntries);
}

//
// BUGBUG: if contstructor failed, this function can be called from multiple threads
// and it is *not* thread safe.
//
template <class T> bool CContainer<T>::Prolog()
{
	bool fRetval = true;
	if (!m_fCsInitialized)
	{
		__try
		{
			::InitializeCriticalSection(&m_cs);
			m_fCsInitialized = true;
		}
		__except(1)
		{
			fRetval = false;//try anyway to keep allocating
		}
	}
	if (NULL == m_aItems)
	{
		m_aItems = new T[m_uiCurrentNumberOfSlots];
		if (NULL != m_aItems)
		{
			for (UINT i = 0; i < m_uiCurrentNumberOfSlots; i++)
			{
				m_aItems[i] = m_tNullItem;
			}
		}
		else
		{
			::SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			fRetval = false;// i may try to allocate on the fly later.
		}
	}
	return fRetval;
}

template <class T> bool CContainer<T>::EnlargeContainer()
{
	T* atNewArray = new T[2*m_uiCurrentNumberOfSlots];
	if (NULL == atNewArray) return false;

	for (ULONG i = 0; i < m_uiCurrentNumberOfSlots; i++)
	{
		atNewArray[i] = m_aItems[i];
	}
	for (i = m_uiCurrentNumberOfSlots; i < 2*m_uiCurrentNumberOfSlots; i++)
	{
		atNewArray[i] = m_tNullItem;
	}

	delete[] m_aItems;
	m_uiCurrentNumberOfSlots *= 2;
	m_aItems = atNewArray;
	return true;
}
#endif //__CONTAINER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\defaultioctl.h ===
#ifndef __DEFAULT_IOCTL_H
#define __DEFAULT_IOCTL_H

//#include "NtNativeIOCTL.h"


class CIoctlDefault : public CIoctlNtNative
{
public:
    CIoctlDefault(CDevice *pDevice): CIoctlNtNative(pDevice){;};
    virtual ~CIoctlDefault(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

/*
	virtual HANDLE CreateDevice(CDevice *pDevice);

	virtual BOOL CloseDevice(CDevice *pDevice);

	virtual BOOL DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		);

	virtual BOOL DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		);
	virtual BOOL DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		);

	virtual BOOL DeviceCancelIo(
		HANDLE hFile  // file handle for which to cancel I/O
		);
*/

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);


};




#endif //__DEFAULT_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\container.cpp ===
#include <windows.h>
#include <crtdbg.h>

template <class T> CContainer<T>::CContainer(UINT nInitialNumberOfItems, T tNullItem, CLOSING_FUNCTION fnClose):
m_fnClose(fnClose),
m_tNullItem(tNullItem),
m_uiCurrentNumberOfSlots(nInitialNumberOfItems),
m_uiNumOfValidEntries(0)
{
	for (UINT i = 0; i < (sizeof(m_auiFreeIndexes)/sizeof(*m_auiFreeIndexes)); i++)
	{
		m_auiFreeIndexes[i] = -1;
	}

	if (0 == m_uiCurrentNumberOfSlots)
	{
		m_uiCurrentNumberOfSlots = 1;
	}
	m_aItems = new T[m_uiCurrentNumberOfSlots];
	Prolog();

}

template <class T> CContainer<T>::~CContainer()
{
	if (NULL != m_aItems)
	{
		for (UINT i = 0; i < m_uiCurrentNumberOfSlots; i++)
		{
			if (m_tNullItem != m_aItems[i])
			{
				m_fnClose(m_aItems[i]);
			}
		}
		delete[] m_aItems;
	}
}

template <class T> T CContainer<T>::GetRandomItem()
{
	_GetRandomItem(false)
}

template <class T> T CContainer<T>::RemoveRandomItem()
{
	_GetRandomItem(true)
}

template <class T> T CContainer<T>::_GetRandomItem(bool fRemove)
{
	if (!Prolog())
	{
		return m_tNullItem;
	}

	if (0 == m_uiNumOfValidEntries)
	{
		return m_tNullItem;
	}

	ULONG ulRandomIndex = GetRandomIndex();
	for (ULONG i = ulRandomIndex; i < m_uiCurrentNumberOfSlots; i++)
	{
		if (m_tNullItem != m_aItems[i])
		{
			if (fRemove)
			{
				T tRetval = m_aItems[i];
				m_aItems[i] = m_tNullItem;
				return tRetval;
			}
			return m_aItems[i];
		}
	}
	for (ULONG i = 0; i < ulRandomIndex; i++)
	{
		if (m_tNullItem != m_aItems[i])
		{
			if (fRemove)
			{
				T tRetval = m_aItems[i];
				m_aItems[i] = m_tNullItem;
				return tRetval;
			}
			return m_aItems[i];
		}
	}
	_ASSERTE(FALSE);
	return m_tNullItem;
}



template <class T> bool CContainer<T>::AddItem(T tItem)
{
	if (!Prolog())
	{
		return m_tNullItem;
	}

	if (m_uiCurrentNumberOfSlots == m_uiNumOfValidEntries)
	{
		if (!EnlargeContainer())
		{
			return m_tNullItem;
		}
	}

	//
	// optimization in case EnlargeContainer() was just called
	//
	for (ULONG i = m_uiNumOfValidEntries; i < m_uiCurrentNumberOfSlots; i++)
	{
		if (m_tNullItem != m_aItems[i])
		{
			m_aItems[i] = tItem;
			return true;
		}
	}
	for (ULONG i = 0; i < m_uiNumOfValidEntries; i++)
	{
		if (m_tNullItem != m_aItems[i])
		{
			m_aItems[i] = tItem;
			return true;
		}
	}
	_ASSERTE(FALSE);
	return false;
}


template <class T> T CContainer<T>::GetItem(ULONG ulIndex)
{
	if (!Prolog())
	{
		return m_tNullItem;
	}

	if (ulIndex >= m_uiCurrentNumberOfSlots)
	{
		return m_tNullItem;
	}

	return m_aItems[i];
}


template <class T> T CContainer<T>::RemoveItem(ULONG ulIndex)
{
	if (!Prolog())
	{
		return m_tNullItem;
	}

	if (ulIndex >= m_uiCurrentNumberOfSlots)
	{
		return m_tNullItem;
	}

	T tRetval = m_aItems[i];
	m_aItems[i] = m_tNullItem;
	return tRetval;
}


template <class T> inline ULONG CContainer<T>::GetRandomIndex()
{
	return (DWORD_RAND%m_uiCurrentNumberOfSlots);
}


template <class T> bool CContainer<T>::Prolog()
{
	if (NULL == m_aItems)
	{
		m_aItems = new T[m_uiCurrentNumberOfSlots];
		if (NULL != m_aItems)
		{
			for (i = 0; i < m_uiCurrentNumberOfSlots; i++)
			{
				m_aItems[i] = m_tNullItem;
			}
		}
		else
		{
			::SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			// i may try to allocate on the fly later.
			return false;
		}
	}
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\device.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>
#include <time.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

#include <windows.h>
#include "device.h"
#include "IOCTL.h"
#include "NtNativeIOCTL.h"
*/

#include "ExcptFltr.h"

#include "CIoctlFactory.h"



static bool s_fVerbose = true;

#define TIME_TO_WAIT_FOR_SINGLE_THREAD (3*60*1000)

long CDevice::sm_lDeviceThreadCount = 0;
long CDevice::sm_fExitAllThreads = FALSE;
long CDevice::sm_lDeviceCount = 0;
long CDevice::sm_fCloseRandomHandles = FALSE;

HANDLE CDevice::sm_hBufferAllocAndFreeThread = NULL;
HANDLE CDevice::sm_hCloseRandomHandleThread = NULL;

BYTE * CDevice::sm_aCommitDecommitBuffs[NUM_OF_ALLOC_AND_FREE_BUFFS];
BYTE * CDevice::sm_aCommittedBuffsAddress[NUM_OF_ALLOC_AND_FREE_BUFFS];
DWORD CDevice::sm_adwAllocatedSize[NUM_OF_ALLOC_AND_FREE_BUFFS];
long CDevice::sm_fStartingBufferAllocAndFreeThread = FALSE;
int CDevice::sm_nZeroWorkingSetSizeProbability = 0;
BYTE CDevice::s_abHugeBuffer[4*1024*1024];

CDevice::CDevice(
    TCHAR *szDevice, 
    TCHAR *szSymbolicName, 
    int nIOCTLThreads, 
    DWORD dwOnlyThisIndexIOCTL,
    DWORD dwMinimumSecsToSleepBeforeClosingDevice,
    DWORD dwMaximumSecsToSleepBeforeClosingDevice,
	int nWriteFileProbability,
	int nReadFileProbability,
	int nDeviceIoControlProbability,
	int nRandomWin32APIProbability,
	int nCancelIoProbability,
	int nQueryVolumeInformationFileProbability,
	int nQueryInformationFileProbability,
	int nSetInformationFileProbability,
	int nQueryDirectoryFileProbability,
	int nQueryFullAttributesFileProbability,
	int nNotifyChangeDirectoryFileProbability,
	int nCauseInOutBufferOverflowMustUsePageHeapProbability,
	bool fTerminateIOCTLThreads,
	bool fAlertRandomIOCTLThreads,
	int nTryDeCommittedBuffersProbability,
	int nBreakAlignmentProbability,
    bool fUseGivenSeed,
    long lSeed
    ):
    m_nIOCTLThreads(nIOCTLThreads),
    m_dwOnlyThisIndexIOCTL(dwOnlyThisIndexIOCTL),
    m_iMaxFreeLegalIOCTL(0),
    m_fStopIOCTELLING(FALSE),
    m_fDeviceThreadExiting(FALSE),
    m_hDevice(INVALID_HANDLE_VALUE),
	m_dwMinimumSecsToSleepBeforeClosingDevice(dwMinimumSecsToSleepBeforeClosingDevice),
	m_dwMaximumSecsToSleepBeforeClosingDevice(dwMaximumSecsToSleepBeforeClosingDevice),
	m_nWriteFileProbability(nWriteFileProbability),
	m_nReadFileProbability(nReadFileProbability),
	m_nDeviceIoControlProbability(nDeviceIoControlProbability),
	m_nRandomWin32APIProbability(nRandomWin32APIProbability),
	m_nCancelIoProbability(nCancelIoProbability),
	m_nQueryVolumeInformationFileProbability(nQueryVolumeInformationFileProbability),
	m_nQueryInformationFileProbability(nQueryInformationFileProbability),
	m_nSetInformationFileProbability(nSetInformationFileProbability),
	m_nQueryDirectoryFileProbability(nQueryDirectoryFileProbability),
	m_nQueryFullAttributesFileProbability(nQueryFullAttributesFileProbability),
	m_nNotifyChangeDirectoryFileProbability(nNotifyChangeDirectoryFileProbability),
	m_fTerminateIOCTLThreads(fTerminateIOCTLThreads),
	m_fAlertRandomIOCTLThreads(fAlertRandomIOCTLThreads),
	m_nTryDeCommittedBuffersProbability(nTryDeCommittedBuffersProbability),
	m_nBreakAlignmentProbability(nBreakAlignmentProbability),
	m_nCauseInOutBufferOverflowMustUsePageHeapProbability(nCauseInOutBufferOverflowMustUsePageHeapProbability),
    m_fUseGivenSeed(fUseGivenSeed),
    m_lSeed(lSeed),
    m_hDeviceThread(NULL),
    m_fShutDown(false),
    m_nOverlappedStructureCount(100)
{
    _ASSERTE(szDevice);
    _ASSERTE(lstrlen(szDevice) < ARRSIZE(m_szDevice));
    lstrcpyn(m_szDevice, szDevice, ARRSIZE(m_szDevice));

    _ASSERTE(szSymbolicName);
    _ASSERTE(lstrlen(szSymbolicName) < ARRSIZE(m_szSymbolicName));
    lstrcpyn(m_szSymbolicName, szSymbolicName, ARRSIZE(m_szSymbolicName));

	ZeroMemory(m_ahIOCTLThread, sizeof(m_ahIOCTLThread));

    m_lMyIndex = InterlockedIncrement(&sm_lDeviceCount);
}

CDevice::~CDevice()
{
    if (NULL != m_hDeviceThread)
    {
        InterlockedExchange(&m_fShutDown, TRUE);
		//
		// wait more time than the total of waiting for the IOCTL threads, becuase 
		// after the thread waiting for the IOCTL threads times out, it references 
		// this, and will AV if this destructor is done, so i will give it more time
		//
        DWORD dwRet = ::WaitForSingleObject(m_hDeviceThread, 2*m_nIOCTLThreads*TIME_TO_WAIT_FOR_SINGLE_THREAD);
        if (WAIT_OBJECT_0 != dwRet)
        {
            DPF((TEXT("CDevice::~CDevice()(%s) WaitForSingleObject(m_hDeviceThread, 2 * %d*TIME_TO_WAIT_FOR_SINGLE_THREAD) returned 0x%08X with last error %d\n"), m_szSymbolicName, m_nIOCTLThreads, dwRet, GetLastError()));
			//
			// i must terminate the thread, because it references 'this'
			// however, the IOCTL threads are terminated by the m_hDeviceThread, and
			// they reference 'this' as well, so i need to terminate them as well.
			// this is ofcourse VERY bad, because it may leak resources, not to mention
			// cause deadlocks and other bad stuff due to DLLs not being notified
			// of the terminated threads.
			// note that i must 1st terminate the device thread, so that there will be
			// no race between it terminating the IOCTL threads, and this destructor
			// terminating them. There still may be races, but they are not worse
			// than the damage of terminating threads.
			//
            if (!::TerminateThread(m_hDeviceThread, 1))
            {
                DPF((TEXT("CDevice::~CDevice()(%s) TerminateThread(m_hDeviceThread, 1) failed with %d\n"), m_szSymbolicName, GetLastError()));
            }
			else
			{
				DPF((TEXT("CDevice::~CDevice()(%s) TerminateThread(m_hDeviceThread, 1) succeeded\n"), m_szSymbolicName));
			}
			for (int iNextThread = 0; iNextThread < m_nIOCTLThreads; iNextThread++)
			{
				//
				// not necessarily all threads were created
				//
				if (NULL == m_ahIOCTLThread[iNextThread]) continue;

				if (!::TerminateThread(m_ahIOCTLThread[iNextThread], -1))
				{
					DPF((
						TEXT("CDevice::~CDevice(%s): TerminateThread(m_ahIOCTLThread[%d]) failed with %d\n"),
						m_szDevice,
						iNextThread, 
						GetLastError()
						));
				}
				else
				{
					DPF((
						TEXT("CDevice::~CDevice(%s): TerminateThread(m_ahIOCTLThread[%d]) suceeded\n"),
						m_szDevice,
						iNextThread
						));
				}
				if (!CloseHandle(m_ahIOCTLThread[iNextThread]))
				{
					DPF((TEXT("CDevice::~CDevice()(%s) CloseHandle(m_ahIOCTLThread[%d]) failed with %d\n"), m_szSymbolicName, iNextThread, GetLastError()));
				}
			}

        }

        if (!CloseHandle(m_hDeviceThread))
        {
            DPF((TEXT("CDevice::~CDevice()(%s) CloseHandle(m_hDeviceThread) failed with %d\n"), m_szSymbolicName, GetLastError()));
        }
    }

	//
	// i decided to never free sm_aCommitDecommitBuffs, and to never stop the sm_hBufferAllocAndFreeThread
	// because i want only one sm_hBufferAllocAndFreeThread per all the devices, and i do not want to deal 
	// with races between closing the last device and allocating a new one, so i will just leave
	// it be, and not release them.
	//
	/*
    if (NULL != sm_hBufferAllocAndFreeThread)
    {
        InterlockedExchange(&m_fShutDown, TRUE);
        DWORD dwRet = ::WaitForSingleObject(sm_hBufferAllocAndFreeThread, 1*60*1000);
        if (WAIT_OBJECT_0 != dwRet)
        {
			//
			// this can happen only if alloc or free inside sm_hBufferAllocAndFreeThread block
			// or are rediculously slow
			//

			if (!::TerminateThread(sm_hBufferAllocAndFreeThread, -1))
			{
				DPF((
					TEXT("CDevice::~CDevice(%s): TerminateThread(sm_hBufferAllocAndFreeThread) failed with %d\n"),
					m_szDevice,
					GetLastError()
					));
			}

			if (!CloseHandle(sm_hBufferAllocAndFreeThread))
			{
				DPF((TEXT("CDevice::~CDevice()(%s) CloseHandle(sm_hBufferAllocAndFreeThread) failed with %d\n"), m_szSymbolicName, GetLastError()));
			}
		}
	}

	for (int i = 0; i < (sizeof(sm_aCommitDecommitBuffs)/sizeof(*sm_aCommitDecommitBuffs)); i++)
	{
		//
		// free the whole buffer
		//
		::VirtualFree(sm_aCommitDecommitBuffs[i], 0, MEM_RELEASE);
		sm_aCommitDecommitBuffs[i] = NULL;
	}
	*/

    InterlockedDecrement(&sm_lDeviceCount);
}

DWORD WINAPI CDevice::CloseRandomHandleThread(LPVOID pVoid)
{
	UNREFERENCED_PARAMETER(pVoid);
	//
	// lets give the test some time to run
	//
	::Sleep(rand()%1000);

	for(;;)
	{
		if (rand()%2) ::Sleep(0);
		if (0 == rand()%50) ::Sleep(1000);
		NtClose((HANDLE)rand());
	}

	_ASSERTE(FALSE);
	return 0;
}

//
// this thread allocated and free buffers, that from time to time will be used by
// the DeviceThread for WriteFile, ReadFile and DeviceIoControl.
// the purpose is to call these APIs with valid buffers, that will get invalidated
// during the call, and to see that the driver handles this correctly,
// and does not crash the system.
// from time to time, the buffer passed to these APIs will already be invalid,
// in this case i hope the API will not AV, but rather return the appropriate status
// PROBLEM: output buffer that was freed, may have been allocated by another thread,
//   so when the operation completes, the not valid output buffer may be written, 
//   and thus currupting my own data structures!
//   Therefor, output buffer must be allocated from a know commited area!
// this thread never dies
//
DWORD WINAPI CDevice::BufferAllocAndFreeThread(LPVOID pVoid)
{
	static long s_fAlreadyRunning = FALSE;

	//
	// since this threads allocated to a static member array,
	// i do not want more than one thread messing with it
	//
	if (::InterlockedExchange(&s_fAlreadyRunning, TRUE))
	{
		_ASSERTE(false);
		return -1;
	}

	//
	// reserve a region, so all allocation will be from this region.
	// this way, since all allocations (at least today) put NULL in the region param,
	// i hope that no one will use these addresses, this way when the IO manager writes into an
	// output buffer, it will not trash other components memory
	//
	// also try to commit, so that we start with a 'full' array
	//
	for (int i = 0; i < NUM_OF_ALLOC_AND_FREE_BUFFS; i++)
	{
		CDevice::sm_aCommittedBuffsAddress[i] = (BYTE*)::VirtualAlloc(
			NULL,// region to reserve or commit
			SIZEOF_INOUTBUFF * NUM_OF_ALLOC_AND_FREE_BUFFS,// size of region
			MEM_RESERVE,// type of allocation
			PAGE_EXECUTE_READWRITE// type of access protection
			);
//DPF((TEXT("VirtualAlloc(MEM_RESERVE) returned 0x%08X\n"), CDevice::sm_aCommittedBuffsAddress[i]));
		_ASSERTE(CDevice::sm_aCommittedBuffsAddress[i]);
		//
		// BUGBUG: what to do if i cannot reserve?
		//

		//
		// start by trying to allocate all the buffers
		//
		sm_adwAllocatedSize[i] = SIZEOF_INOUTBUFF;
		if (NULL == (CDevice::sm_aCommitDecommitBuffs[i] = (BYTE*)::VirtualAlloc(
				CDevice::sm_aCommittedBuffsAddress[i],// region to reserve or commit
				sm_adwAllocatedSize[i],// size of region
				MEM_COMMIT,// type of allocation
				PAGE_EXECUTE_READWRITE// type of access protection
				)))
		{
			//
			// mark as not allocated
			//
			sm_adwAllocatedSize[i] = 0;
		}
	}

	for(;;)
	{
		int i = rand()%NUM_OF_ALLOC_AND_FREE_BUFFS;
		//for (int i = 0; i < NUM_OF_ALLOC_AND_FREE_BUFFS; i++)
		{
			if (0 == CDevice::sm_lDeviceCount)
			{
				//
				// let's cleanup, in case no one will ever create more CDevices
				//
				for (int j = 0; j < NUM_OF_ALLOC_AND_FREE_BUFFS; j++)
				{
					if (CDevice::sm_aCommitDecommitBuffs[j])
					{
						if (::VirtualFree(CDevice::sm_aCommitDecommitBuffs[j], sm_adwAllocatedSize[i], MEM_DECOMMIT))
						{
							CDevice::sm_aCommitDecommitBuffs[j] = NULL;
							sm_adwAllocatedSize[i] = 0;
						}
						else
						{
							//
							// memory may be locked by the device driver
							//
_tprintf(TEXT("VirtualFree() failed with %d.\n"), ::GetLastError());
						}
					}
				}

				//
				// and sleep, because we do not want a tight loop of VirtualFree()
				//
				::Sleep(1000);
			}

			if (CDevice::sm_nZeroWorkingSetSizeProbability > rand()%100)
			{
				if (!::SetProcessWorkingSetSize(GetCurrentProcess(), (SIZE_T)-1, (SIZE_T)-1))
				{
					DPF((TEXT("SetProcessWorkingSetSize(-1, -1) failed with %d.\n"), ::GetLastError()));
				}
				else
				{
					//DPF((TEXT("SetProcessWorkingSetSize(-1, -1) suceeded.\n")));
				}
			}

			//
			// free the whole buffer
			// please note that it might already have been freed, so i am freeing dead zone
			//
			if (sm_adwAllocatedSize[i] != 0)
			{
				if (0 == rand()%100)
				{
					if (::VirtualFree(CDevice::sm_aCommitDecommitBuffs[i], sm_adwAllocatedSize[i], MEM_DECOMMIT))
					{
						//
						// mark as freed
						//
						sm_adwAllocatedSize[i] = 0;

						//
						// do NOT set to NULL, becuae that's exactly what i want to achive:
						// i want the driver to use an invalid pointer!
						//
						// do NOT do this: CDevice::sm_aCommitDecommitBuffs[i] = NULL;

						//
						// however, i do not wnat to immediately allocate, because i want the driver to 
						// have the chance to hit freed memory, so i will randomly allocate this buffer
						//
						//if (rand()%2) continue;
					}
					else
					{
						//
						// memory may be locked by the device driver
						//
_tprintf(TEXT("VirtualFree() failed with %d.\n"), ::GetLastError());
					}
				}
				else
				{
					//
					// i did not free, so i do not allocate in order not to leak
					//
					continue;
				}
			}

			_ASSERTE(0 == sm_adwAllocatedSize[i]);

			for (;;)
			{
				DWORD dwAllocationType = MEM_COMMIT;
				if (0 == rand()%10) dwAllocationType |= MEM_PHYSICAL;
				if (0 == rand()%10) dwAllocationType |= MEM_RESET;
				if (0 == rand()%10) dwAllocationType |= MEM_TOP_DOWN;

				DWORD dwAccessAndProtection = 0;
				if (0 == rand()%10) dwAccessAndProtection |= PAGE_READONLY;
				if (0 == rand()%10) dwAccessAndProtection |= PAGE_READWRITE;
				if (0 == rand()%10) dwAccessAndProtection |= PAGE_EXECUTE;
				if (0 == rand()%10) dwAccessAndProtection |= PAGE_EXECUTE_READ;
				if (0 == rand()%10) dwAccessAndProtection |= PAGE_EXECUTE_READWRITE;
				if (0 == rand()%10) dwAccessAndProtection |= PAGE_GUARD;
				if (0 == rand()%10) dwAccessAndProtection |= PAGE_NOACCESS;
				if (0 == rand()%10) dwAccessAndProtection |= PAGE_NOCACHE;

				sm_adwAllocatedSize[i] = SIZEOF_INOUTBUFF;

				CDevice::sm_aCommitDecommitBuffs[i] = (BYTE*)::VirtualAlloc(
					CDevice::sm_aCommittedBuffsAddress[i],// region to reserve or commit
					sm_adwAllocatedSize[i],// size of region
					dwAllocationType,// type of allocation
					dwAccessAndProtection// type of access protection
					);
				if (NULL != CDevice::sm_aCommitDecommitBuffs[i]) 
				{
					_ASSERTE(CDevice::sm_aCommitDecommitBuffs[i] >= CDevice::sm_aCommittedBuffsAddress[i]);
					//BUGBUG: not 64 bit compliant
					_ASSERTE(CDevice::sm_aCommitDecommitBuffs[i] < (void*)((DWORD)CDevice::sm_aCommittedBuffsAddress[i] + (SIZEOF_INOUTBUFF * NUM_OF_ALLOC_AND_FREE_BUFFS) - sm_adwAllocatedSize[i]));
//DPF((TEXT("VirtualAlloc() succeeded\n")));

					//
					// we allocated.
					// once in a while, put garbage in the buffer, or zero it out
					if (0 == rand()%50)
					{
						//
						// i may have allocated it without write permission, or a guard page etc.
						// so just try, if fail, i don't care
						//

						//
						// remember the volatile value
						//
						DWORD dwBytesToChange = sm_adwAllocatedSize[i];
						//
						// beware of modulo 0
						//
						dwBytesToChange = rand()%((0 != dwBytesToChange) ? dwBytesToChange : 1);
						__try
						{
							for (DWORD dwIter = 0; dwIter < dwBytesToChange; dwIter++)
							{
								//
								// beware of modulo 0
								// change mostly byte at the beginning of the buffer
								//
								((BYTE*)CDevice::sm_aCommitDecommitBuffs[i])[dwIter ? rand()%dwIter : 0] = rand()%2 ? 0 : rand()%2 ? 1 : rand()%2 ? -1 : rand();
							}
						}__except(1)
						{
							;
						}
					}else if (0 == rand()%100)
					{
						//
						// i may have allocated it without write permission, or a guard page etc.
						// so just try, if fail, i don't care
						//
						__try
						{
							ZeroMemory(CDevice::sm_aCommitDecommitBuffs[i], SIZEOF_INOUTBUFF);
						}__except(1)
						{
							;
						}
					}
					
					//
					// since this thread goes in a tight loop, i think this is the place 
					// to give up the CPU a bit.
					//
					::Sleep(0);
					break;
				}
				else
				{
					//
					// mark as not allocated
					//
					sm_adwAllocatedSize[i] = 0;
					//
					// allocation failed, either becaue of fault injection, or because we ran out of memory,
					// and i hope that not because i leaked.
					// this is also a good place to give up the CPU
					//
//DPF((TEXT("VirtualAlloc() FAILED with %d\n"), ::GetLastError()));
					::Sleep(100);
				}
			}//for (;;)

		}//for (int i = 0; i < NUM_OF_ALLOC_AND_FREE_BUFFS; i++)
	}//for(;;)

	_ASSERTE(FALSE);
	return -1;
}


DWORD WINAPI CDevice::DeviceThread(LPVOID pVoid)
{
//__try{
    _ASSERTE(pVoid);
    CDevice *pThis = (CDevice*)pVoid;
    DWORD dwRetval = ERROR_SUCCESS;
    DWORD dwWaitRes;
	//DWORD adwStackStamp[] = {0xdbdbdbdb, 0xdbdbdbdb, 0xdbdbdbdb, 0xdbdbdbdb};
	DWORD dwTimesTried;

    bool fFoundLegalIOCTLs = false;
    bool fIOCTLThreadsRunning = false;
    int nNumOfActiveIOCTLThreads = 0;//must init due to "goto out"
//    int nTryToOpenCount = 0;
    bool fDeviceOpen = false;

    //DPF((TEXT("DeviceThread(%s)\n"), pThis->m_szDevice));

    CIoctl *pIoctlObject = NULL;

    if (!pThis->SetSrandFile())
    {
		//
		// we do not want fault-injection to fail us, so ignore the error
		//
        //dwRetval = -1;
        //goto out;
    }

	//
	//this will "try hard" to alllocate the object, to comply with fault-injection
	//
    pIoctlObject = CreateIoctlObject(pThis);
    if (NULL == pIoctlObject)
    {
        DPF((
            TEXT("CreateIoctlObject(%s) failed\n"),
            pThis->m_szDevice
            ));
        dwRetval = -1;
        goto out;
    }

	//
	//this should "try hard" to create the device, to comply with fault-injection
	//
	for (dwTimesTried = 0; dwTimesTried < 100; dwTimesTried++)
	{
		pThis->m_hDevice = pIoctlObject->CreateDevice(pThis); 
		if (INVALID_HANDLE_VALUE == pThis->m_hDevice)
		{
			::Sleep(100);
		}
		else
		{
			break;
		}
	}
	if (INVALID_HANDLE_VALUE == pThis->m_hDevice)
	{
		dwRetval = -1;
		goto out;
	}
    fDeviceOpen = true;

    //
    // need to be done only once
    //
    if (!fFoundLegalIOCTLs)
    {
        if (!pIoctlObject->FindValidIOCTLs(pThis))
        {
            goto out;
        }
///*
        DPF((TEXT("Valid IOCTLS:\n")));
        for (int i = 0; i < pThis->m_iMaxFreeLegalIOCTL; i++)
        {
            DPF((TEXT("0x%08X\n"), pThis->m_adwLegalIOCTLs[i]));
			//_ASSERTE(0 != pThis->m_adwLegalIOCTLs[i]);
        }
        DPF((TEXT("\n")));
//*/
        fFoundLegalIOCTLs = true;
    }

launch_ioctl_threads:
    if (!fIOCTLThreadsRunning)
    {
        _ASSERTE(pThis->m_nIOCTLThreads < MAX_NUM_OF_IOCTL_THREADS);
        for (nNumOfActiveIOCTLThreads = 0; nNumOfActiveIOCTLThreads < pThis->m_nIOCTLThreads; nNumOfActiveIOCTLThreads++)
        {
            if (pThis->sm_fExitAllThreads || pThis->m_fShutDown) goto out;

			//_ASSERTE( (adwStackStamp[0] == 0xdbdbdbdb) && (adwStackStamp[1] == 0xdbdbdbdb) && (adwStackStamp[2] == 0xdbdbdbdb) && (adwStackStamp[3] == 0xdbdbdbdb) );

			//
			// TODO: allocate the per-thread dtat structures, here, so that if we TerminateThread(),
			// we can still reclaim those resources, instead of leaking them
			//
			pThis->m_ahIOCTLThread[nNumOfActiveIOCTLThreads] = pThis->TryHardToCreateThread(
				64*1024,      // initial thread stack size, in bytes
				IoctlThread,                          // pointer to thread function
				(LPVOID) pIoctlObject, // argument for new thread
				1000      // times to try
				);
            if (NULL == pThis->m_ahIOCTLThread[nNumOfActiveIOCTLThreads])
            {
                dwRetval = GetLastError();
                DPF((
                    TEXT("CreateThread(IoctlThread, %s) failed with %d\n"),
                    pThis->m_szDevice,
                    GetLastError()
                    ));
                goto out;
            }
            DPF((
                TEXT("CreateThread(IoctlThread, %s) succeeded\n"),
                pThis->m_szDevice
                ));
        }
        fIOCTLThreadsRunning = true;
    }

	if (pThis->m_fTerminateIOCTLThreads)
	{
		//
		// this will cause leaks, and probably other bad stuff, so don't expect much, 
		// other than pray for blue-screens
		//

        for (nNumOfActiveIOCTLThreads = 0; nNumOfActiveIOCTLThreads < pThis->m_nIOCTLThreads; nNumOfActiveIOCTLThreads++)
        {
            if (pThis->sm_fExitAllThreads || pThis->m_fShutDown) goto out;

			::Sleep(rand()%10000);
			if (! ::TerminateThread(pThis->m_ahIOCTLThread[nNumOfActiveIOCTLThreads], -1))
			{
                DPF((
                    TEXT("TerminateThtread(IoctlThread, %s) failed with %d\n"),
                    pThis->m_szDevice,
                    GetLastError()
                    ));
            }
			else
			{
				DPF((
					TEXT("TerminateThtread(IoctlThread, %s) succeeded\n"),
					pThis->m_szDevice
					));
			}
			if (! ::CloseHandle(pThis->m_ahIOCTLThread[nNumOfActiveIOCTLThreads]))
			{
                DPF((
                    TEXT("CloseHandle(IoctlThread, %s) failed with %d\n"),
                    pThis->m_szDevice,
                    GetLastError()
                    ));
			}
			pThis->m_ahIOCTLThread[nNumOfActiveIOCTLThreads] = NULL;

		}

		//
		// this is an inifinite loop, unless creation of threads fail
		//
		fIOCTLThreadsRunning = false;
		goto launch_ioctl_threads;
	}

    //
    // from time to time, close the handle.
    // why? because i'm a bad boy (== good tester)
    //
    while(!pThis->sm_fExitAllThreads && !pThis->m_fShutDown)
    {
        DWORD dwSleepBeforeCloseDevice = 
			pThis->m_dwMinimumSecsToSleepBeforeClosingDevice + 
			DWORD_RAND % (1+pThis->m_dwMaximumSecsToSleepBeforeClosingDevice - pThis->m_dwMinimumSecsToSleepBeforeClosingDevice);
        DPF((TEXT("Sleeping %d milli before closing handle %s\n"), dwSleepBeforeCloseDevice, pThis->m_szDevice));

        //
        // sleep by polling each second on the pThis->m_fExitAllThreads flag
        //
        while(!pThis->sm_fExitAllThreads && !pThis->m_fShutDown)
        {
            if (dwSleepBeforeCloseDevice > 1000)
            {
                Sleep(1000);
                dwSleepBeforeCloseDevice -= 1000;

				//
				// once in a while, just like that, set a random thread in the 
				// alerted state
				//
				if (pThis->m_fAlertRandomIOCTLThreads/* && (0 == rand()%50)*/)
				{
					if (!CIoctlNtNative::StaticNtAlertThread(pThis->m_ahIOCTLThread[rand()%pThis->m_nIOCTLThreads]))
					{
						DPF((TEXT("StaticNtAlertThread() failed with %d\n"), ::GetLastError()));
					}
					else
					{
						//DPF((TEXT("StaticNtAlertThread() SUCCEEDED\n")));
					}
				}
            }
            else
            {
                Sleep(dwSleepBeforeCloseDevice);
                break;
            }
        }

        _ASSERTE(fDeviceOpen);
        if (!pIoctlObject->CloseDevice(pThis))
        {
            DPF((TEXT("CloseHandle(%s) failed with %d\n"), pThis->m_szDevice, GetLastError()));
			//
			// i hope that this is not my fatal error, because i want to keep stressing
			// those IOCTLs.
			// lets hope that the failure is due to fault-injection, and ignore it.
			//
            //dwRetval = -1;
            //goto out;
        }
        fDeviceOpen = false;
		//
		// should i set the handle to to INVALID_HANDLE_VALUE now?
		// if i do, i may IOCTL some unknown device
		// if i don't, i may lose the timing case of IOCTELLing a closed device
		//

        //
        // try to open the device again, after closing its handle
        //
		for (dwTimesTried = 0; dwTimesTried < 100; dwTimesTried++)
		{
			pThis->m_hDevice = pIoctlObject->CreateDevice(pThis); 
			if (INVALID_HANDLE_VALUE == pThis->m_hDevice)
			{
				::Sleep(100);
			}
			else
			{
				break;
			}
		}
        if (INVALID_HANDLE_VALUE != pThis->m_hDevice)
        {
            fDeviceOpen = true;
            InterlockedExchange(&pThis->m_fStopIOCTELLING, FALSE);
			continue;
        }

        //
        // we failed to open, try once again after disabling the IOCTELLING
        //
        DPF((TEXT("Stopping IOCTELLING device %s because we failed to open it\n"), pThis->m_szDevice));
        //
        // let's signal IOCTL threads to stop IOCTELLING, to give us a chance to open
        //
        ::InterlockedExchange(&pThis->m_fStopIOCTELLING, TRUE);
		Sleep(1000);//let other threads get the 'signal'
		for (dwTimesTried = 0; dwTimesTried < 100; dwTimesTried++)
		{
			pThis->m_hDevice = pIoctlObject->CreateDevice(pThis); 
			if (INVALID_HANDLE_VALUE == pThis->m_hDevice)
			{
				::Sleep(100);
			}
			else
			{
				break;
			}
		}
        if (INVALID_HANDLE_VALUE != pThis->m_hDevice)
        {
            fDeviceOpen = true;
            InterlockedExchange(&pThis->m_fStopIOCTELLING, FALSE);
			continue;
        }

		//
		// we failed to open the device even after stopping IOCTelling,
		// so bail out
		//
        DPF((TEXT("we failed to open the device even after stopping IOCTelling of device %s\n"), pThis->m_szDevice));
		break;

    }//while(!pThis->sm_fExitAllThreads && !pThis->m_fShutDown)

out:
    InterlockedExchange(&pThis->m_fDeviceThreadExiting, TRUE);// signal IOCTL threads to finish WAIT_FAILED
    //dwWaitRes = WaitForMultipleObjects(nNumOfActiveIOCTLThreads, pThis->m_ahIOCTLThread, TRUE, TIME_TO_WAIT_FOR_SINGLE_THREAD);
    //DPF((TEXT("DeviceThread(%s): WaitForMultipleObjects(%d, pThis->m_ahIOCTLThread, TRUE, TIME_TO_WAIT_FOR_SINGLE_THREAD) returned 0x%08X, last error = %d\n"), pThis->m_szDevice, nNumOfActiveIOCTLThreads, dwWaitRes, GetLastError()));

    for (int iNextThread = 0; iNextThread < nNumOfActiveIOCTLThreads; iNextThread++)
    {
		DWORD dwLastError = 0;
		DPF((TEXT("DeviceThread(%s): before WaitForSingleObject(pThis->m_ahIOCTLThread[%d], TIME_TO_WAIT_FOR_SINGLE_THREAD)\n"), pThis->m_szDevice, iNextThread));
	    dwWaitRes = WaitForSingleObject(pThis->m_ahIOCTLThread[iNextThread], TIME_TO_WAIT_FOR_SINGLE_THREAD);
		if (WAIT_OBJECT_0 == dwWaitRes)
		{
			DPF((TEXT("DeviceThread(%s): after WAIT_OBJECT_0 == WaitForSingleObject(pThis->m_ahIOCTLThread[%d], TIME_TO_WAIT_FOR_SINGLE_THREAD)\n"), pThis->m_szDevice, iNextThread));
		}
		else if (WAIT_TIMEOUT == dwWaitRes)
		{
			DPF((TEXT("!!!!!!!!!DeviceThread(%s): after WAIT_TIMEOUT == WaitForSingleObject(pThis->m_ahIOCTLThread[%d], TIME_TO_WAIT_FOR_SINGLE_THREAD)\n"), pThis->m_szDevice, iNextThread));
			//
			// we may get into trouble if the thread is not already dead
			//
			if (!::TerminateThread(pThis->m_ahIOCTLThread[iNextThread], -1))
			{
				DPF((
					TEXT("DeviceThread(%s): TerminateThread(pThis->m_ahIOCTLThread[%d]) failed with %d\n"),
					pThis->m_szDevice,
					iNextThread, 
					GetLastError()
					));
			}
		}
		else if (WAIT_FAILED == dwWaitRes)
		{
			dwLastError = ::GetLastError();
			DPF((TEXT("DeviceThread(%s): after WAIT_FAILED == WaitForSingleObject(pThis->m_ahIOCTLThread[%d], TIME_TO_WAIT_FOR_SINGLE_THREAD), error=%d\n"), pThis->m_szDevice, iNextThread, dwLastError));
			if (ERROR_INVALID_HANDLE == dwLastError)
			{
				//
				// i do not want to mess with invalid handle exceptions
				//
				continue;
			}
			//
			// we may get into trouble if the thread is not already dead
			//
			if (!::TerminateThread(pThis->m_ahIOCTLThread[iNextThread], -1))
			{
				DPF((
					TEXT("DeviceThread(%s): TerminateThread(pThis->m_ahIOCTLThread[%d]) failed with %d\n"),
					pThis->m_szDevice,
					iNextThread, 
					GetLastError()
					));
			}
		}
		 
		if (!::CloseHandle(pThis->m_ahIOCTLThread[iNextThread]))
		{
            DPF((
                TEXT("DeviceThread(%s): CloseHandle(pThis->m_ahIOCTLThread[%d]) failed with %d\n"),
                pThis->m_szDevice,
				iNextThread, 
                GetLastError()
                ));
		}
		pThis->m_ahIOCTLThread[iNextThread] = NULL;
	}

    if (fDeviceOpen)
    {
        if (pIoctlObject && !pIoctlObject->CloseDevice(pThis))
        {
            dwRetval = GetLastError();
            DPF((
                TEXT("DeviceThread(%s): CloseHandle(pThis->m_hDevice) failed with %d\n"),
                pThis->m_szDevice, 
                GetLastError()
                ));
        }
    }

	delete pIoctlObject;

	{
		long lDeviceThreadCount = ::InterlockedDecrement(&pThis->sm_lDeviceThreadCount);
		_tprintf(TEXT("DeviceThread(): Exiting thread sm_lDeviceThreadCount=%d\n"), lDeviceThreadCount);
	}

    return dwRetval;
//}__except(PrintExceptionInfoFilter(GetExceptionInformation(), TEXT(__FILE__), __LINE__)){;}
}


bool CDevice::UseRealName()
{
    if (0 == _tcsncicmp(USE_REAL_NAME_PREFIX, m_szSymbolicName, lstrlen(USE_REAL_NAME_PREFIX)))
    {
        DPF((TEXT("Using real name - %s\n"), m_szDevice));
        return true;
    }

    DPF((TEXT("Using symbolic name - %s\n"), m_szSymbolicName));
    return false;
}

bool CDevice::SetSrandFile() 
{
    m_lSeed = m_fUseGivenSeed ? m_lSeed : time( NULL ) ;
    srand(m_lSeed);

	//
	// TODO: i do not use it, so let's not put all these file that just litter the folder
	//
	return true;

    TCHAR szDeviceSrandFile[1024];
    _stprintf(szDeviceSrandFile, TEXT("DeviceSrand-%d-%d.srand"), m_lMyIndex, m_lSeed);

    HANDLE hDeviceSrand = ::CreateFile(
        szDeviceSrandFile,
        GENERIC_READ | GENERIC_WRITE,       // access (read-write) mode
        0,           // share mode
        NULL,                        // pointer to security attributes
        CREATE_ALWAYS,  // how to create
        FILE_ATTRIBUTE_NORMAL,  // file attributes
        NULL         // handle to file with attributes to copy
        );
    if(INVALID_HANDLE_VALUE == hDeviceSrand)
    {
        DPF((TEXT("CDevice::SetSrandFile(): CreateFile(%s) failed with %d\n"), szDeviceSrandFile, ::GetLastError()));
        return false;
    }

    if (!::CloseHandle(hDeviceSrand))
    {
        DPF((TEXT("CDevice::SetSrandFile(): CloseHandle(%s) failed with %d\n"), szDeviceSrandFile, ::GetLastError()));
    }

    return true;
}

bool CDevice::Start()
{
	//
	// the BufferAllocAndFreeThread runs once, per all CDevices
	// I can export this if statement as a static method, to be invoked from main(),
	// but this way the caller has less work to do.
	// BUGBUG: this thread will also reset the working set if asked for, which is a hack
	//   since this is not the place to do it.
	//
	if (FALSE == ::InterlockedExchange(&sm_fStartingBufferAllocAndFreeThread, TRUE))
	{
		_ASSERTE(NULL == sm_hBufferAllocAndFreeThread);

		ZeroMemory(sm_aCommitDecommitBuffs, sizeof(sm_aCommitDecommitBuffs));
		ZeroMemory(sm_aCommittedBuffsAddress, sizeof(sm_aCommittedBuffsAddress));
		ZeroMemory(sm_adwAllocatedSize, sizeof(sm_adwAllocatedSize));

		if (NULL == sm_hBufferAllocAndFreeThread)
		{
			sm_hBufferAllocAndFreeThread = TryHardToCreateThread(
				4*1024,      // hope this stack is enough for eveything, because in low mem we may run out of stack
				BufferAllocAndFreeThread,                          // pointer to thread function
				(PVOID)this,     // argument for new thread
				10000     // times to try
				);
			if (NULL == sm_hBufferAllocAndFreeThread)
			{
				DPF((
					TEXT("CDevice::Start(): CreateThread(%s) BufferAllocAndFreeThread failed with %d\n"),
					m_szDevice,
					GetLastError()
					));
				::InterlockedExchange(&sm_fStartingBufferAllocAndFreeThread, FALSE);
				return false;
			}
		}
	}
		
	//
	// BUGBUG: reentancy - may have races if start is called from several threads
	//
	if (sm_fCloseRandomHandles && NULL == sm_hCloseRandomHandleThread)
	{
		sm_hCloseRandomHandleThread = TryHardToCreateThread(
			4*1024,      // hope this stack is enough for eveything, because in low mem we may run out of stack
			CloseRandomHandleThread,                          // pointer to thread function
			(PVOID)this,     // argument for new thread
			10000     // times to try
			);
		if (NULL == sm_hCloseRandomHandleThread)
		{
			DPF((
				TEXT("CDevice::Start(): CreateThread(%s) hCloseRandomHandleThread failed with %d\n"),
				m_szDevice,
				GetLastError()
				));
			return false;
		}
	}
	DPF((
		TEXT("CDevice::Start(): CreateThread(%s) CloseRandomHandleThread SUCCEEDED\n"),
		m_szDevice
		));

    m_hDeviceThread = TryHardToCreateThread(
        16*1024,      // hope this stack is enough for eveything, because in low mem we may run out of stack
        DeviceThread,                          // pointer to thread function
        (LPVOID) this,     // argument for new thread
        1000     // times to try
        );
    if (NULL == m_hDeviceThread)
    {
        DPF((
            TEXT("CDevice::Start(): CreateThread(%s) DeviceThread failed with %d\n"),
            m_szDevice,
            GetLastError()
            ));
        return false;
    }

    DPF((TEXT("CDevice::Start(): CreateThread(DeviceThread, %s) succeeded\n"), m_szDevice));

    InterlockedIncrement(&sm_lDeviceThreadCount);

    return true;
}

void CDevice::WaitForAllDeviceThreadsToFinish(DWORD dwPollingInterval)
{
    while(0 < CDevice::sm_lDeviceThreadCount)
    {
        Sleep(dwPollingInterval);
    }
}

HANDLE CDevice::TryHardToCreateThread(
    IN DWORD dwStackSize,
    IN LPTHREAD_START_ROUTINE lpStartAddress,
    IN LPVOID lpParameter,
    IN DWORD dwTryCount
	)
{
	DWORD dwTimesTried;
	HANDLE hThread;
	DWORD dwThreadId;
	for (dwTimesTried = 0; dwTimesTried < dwTryCount; dwTimesTried++)
	{
		if (sm_fExitAllThreads || m_fShutDown) goto out;

		hThread = CreateThread(
			NULL,                          // pointer to thread security attributes
			dwStackSize,      // initial thread stack size, in bytes
			lpStartAddress,                          // pointer to thread function
			lpParameter, // argument for new thread
			0,  // creation flags
			&dwThreadId      // pointer to returned thread identifier
			);
		if (NULL != hThread)
		{
			return hThread;
		}
	}
out:
	return NULL;
}

UINT CDevice::GetMaxFreeLegalIOCTLIndex()
{
	return m_iMaxFreeLegalIOCTL;
}

DWORD CDevice::GetLegalIOCTLAt(UINT index)
{
	if (index >= m_iMaxFreeLegalIOCTL)
	{
		_ASSERTE(!"index >= m_iMaxFreeLegalIOCTL");
		return 0;
	}
	return m_adwLegalIOCTLs[index];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\device.h ===
#ifndef __DEVICE_H
#define __DEVICE_H

//
// I here by define that if you wish to open the real filename
// in the CreateFile(), and not the symbolic name (\\.\com100)
// then the symbolic name must start with this prefix.
// examples:
//  ---USESYMBOLICNAME-1 = deleteme.tmp
//  ---USESYMBOLICNAME-2 = \\mickys001\public\deleteme.tmp
#define USE_REAL_NAME_PREFIX TEXT("\\\\.\\---USESYMBOLICNAME")

#define ARRSIZE(a) (sizeof(a)/sizeof(a[0]))

#define MAX_NUM_OF_DEVICES 1024
#define MAX_DEVICE_NAME_LEN 1024

//
// note that it is so because of the use of WaitForMultipleObjects()
//
#define MAX_NUM_OF_IOCTL_THREADS 63

#define MAX_NUM_OF_GOOD_IOCTLS (1*1024)


#include "DPF.h"

class CIoctl;

class CDevice
{
public:
    CDevice(
        TCHAR *szDevice, 
        TCHAR *szSymbolicName, 
        int nIOCTLThreads, 
        DWORD dwOnlyThisIndexIOCTL,
        DWORD dwMinimumSecsToSleepBeforeClosingDevice,
        DWORD dwMaximumSecsToSleepBeforeClosingDevice,
		int nWriteFileProbability,
		int nReadFileProbability,
		int nDeviceIoControlProbability,
		int nRandomWin32APIProbability,
		int nCancelIoProbability,
		int nQueryVolumeInformationFileProbability,
		int nQueryInformationFileProbability,
		int nSetInformationFileProbability,
		int nQueryDirectoryFileProbability,
		int nQueryFullAttributesFileProbability,
		int nNotifyChangeDirectoryFileProbability,
		int nCauseInOutBufferOverflowMustUsePageHeapProbability,
		bool fTerminateIOCTLThreads,
		bool fAlertRandomIOCTLThreads,
		int nTryDeCommittedBuffersProbability,
		int nBreakAlignmentProbability,
        bool fUseGivenSeed,
        long lSeed
        );
    ~CDevice();

    bool Start();

    TCHAR *GetDeviceName(){ return m_szDevice;}
    TCHAR *GetSymbolicDeviceName(){ return m_szSymbolicName;}

    static void WaitForAllDeviceThreadsToFinish(DWORD dwPollingInterval);

	HANDLE TryHardToCreateThread(
		IN DWORD dwStackSize,
		IN LPTHREAD_START_ROUTINE lpStartAddress,
		IN LPVOID lpParameter,
		IN DWORD dwTryCount
		);

    //
    // this is how one signals that we need to finish all activities and exit.
    //
    static long sm_fExitAllThreads;

    //
    // each device has it's own thread
    //
    static DWORD WINAPI DeviceThread(LPVOID pVoid);

	//
	// the following statics are used for giving buffs that may be de-committed
	// randomly.
	// TODO: make a class of it, and declare a static instance of it here
	//
    static DWORD WINAPI BufferAllocAndFreeThread(LPVOID pVoid);

    static DWORD WINAPI CloseRandomHandleThread(LPVOID pVoid);
	
#define NUM_OF_ALLOC_AND_FREE_BUFFS (64)
	static BYTE *sm_aCommitDecommitBuffs[NUM_OF_ALLOC_AND_FREE_BUFFS];
	static BYTE *sm_aCommittedBuffsAddress[NUM_OF_ALLOC_AND_FREE_BUFFS];
	static DWORD sm_adwAllocatedSize[NUM_OF_ALLOC_AND_FREE_BUFFS];

    //
    // for each device I can open up to MAX_NUM_OF_IOCTL_THREADS
    // that stress it.
    //
    friend DWORD WINAPI IoctlThread(LPVOID pVoid);

    friend CIoctl;

	//
	// signals related threads that the device is shutting down,
	// so everyone should start to cleanup
	//
    long m_fShutDown;

	static DWORD GetThreadCount(){ return sm_lDeviceThreadCount;}

    //
    // handle to device
    // note that it does not necessarily hold a valid handle, since
    // I tend to close the handle in order to let the IOCTL threads
    // play a bit with a close handle.
    //
    HANDLE m_hDevice;

	//
	// probabilities for various actions
	// override to 0 if you wish to disable
	// override to 100 if you want to always call this API.
	//
	int m_nWriteFileProbability;
	int m_nReadFileProbability;
	int m_nDeviceIoControlProbability;
	int m_nRandomWin32APIProbability;
	int m_nCancelIoProbability;
	int m_nQueryVolumeInformationFileProbability;
	int m_nQueryInformationFileProbability;
	int m_nSetInformationFileProbability;
	int m_nQueryDirectoryFileProbability;
	int m_nQueryFullAttributesFileProbability;
	int m_nNotifyChangeDirectoryFileProbability;
	static int sm_nZeroWorkingSetSizeProbability;
	int m_nCauseInOutBufferOverflowMustUsePageHeapProbability;

	//
	// once in a while, pass an IO/OUT buffer, that is/will be decommitted
	// this is to catch drivers that do not verify user buffers
	//
	int m_nTryDeCommittedBuffersProbability;

	//
	// once in a while, break the alignment of IN/OUT buffers, by incrementing them
	// by a low random number
	//
	int m_nBreakAlignmentProbability;

    //
	// rarely used.
    // if -1, random IOCTLs are used, otherwise, only this IOCTL is used
    //
    DWORD m_dwOnlyThisIndexIOCTL;

    //
    // the index to the next free slot in the array above
    //
    int m_iMaxFreeLegalIOCTL;

	//
	// huge buffer, to be use when a real huge buffer is needed
	// since this is static, and may be used by many threads,
	// one should not rely on its contents.
	// its main use is just to be able to pass a huge buffer
	// when the dynamic buffers are too small
	//
	static BYTE s_abHugeBuffer[4*1024*1024];

	DWORD GetLegalIOCTLAt(UINT index);
	UINT GetMaxFreeLegalIOCTLIndex();

	static long sm_fCloseRandomHandles;

protected:
    //
    // I use this when I cannot reopen the device, and I want the IOCTL 
    // threads to stop IOCTelling
    //
    long m_fStopIOCTELLING;

    //
    // this is how i tell the IOCTL thread to finish
    //
    long m_fDeviceThreadExiting;

    //
    // the real name of the device. (right hand value in INI file)
    //
    TCHAR m_szDevice[MAX_DEVICE_NAME_LEN];

    //
    // the symbolic (DOS) name (left hand value (key) in INI file)
    //
    TCHAR m_szSymbolicName[MAX_DEVICE_NAME_LEN];

    //
    // the number of IOCTL threads requested
    //
    int m_nIOCTLThreads;

    //
    // all the (legal) IOCTLs that will be used to stress the device
    //
    DWORD m_adwLegalIOCTLs[MAX_NUM_OF_GOOD_IOCTLS];

	//
	// crazy mode in which IOCTL threads are terminated after they are lanced, and then
	// launced again, and so on.
	// don't expect much, other than leaks and deadlocks, and pray for blue-screens
	//
	bool m_fTerminateIOCTLThreads;

	bool m_fAlertRandomIOCTLThreads;


private:
    bool UseRealName();
    
    bool SetSrandFile();

    int m_nOverlappedStructureCount;

    bool m_fUseGivenSeed;
    long m_lSeed;
    long m_lMyIndex;
	DWORD m_dwMinimumSecsToSleepBeforeClosingDevice;
	DWORD m_dwMaximumSecsToSleepBeforeClosingDevice;
    static long sm_lDeviceCount;

    //
    // when I'll have a better design, This object will create the threads.
    // meanwhile, I need to have a "reference" count on threads.
    //
    static long sm_lDeviceThreadCount;

	static long sm_fStartingBufferAllocAndFreeThread;
    static HANDLE sm_hBufferAllocAndFreeThread;
	static HANDLE sm_hCloseRandomHandleThread;
    HANDLE m_hDeviceThread;
    HANDLE m_ahIOCTLThread[MAX_NUM_OF_IOCTL_THREADS];
};



#endif //__DEVICE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\dmloaderioctl.h ===
#ifndef __DMLOADER_IOCTL_H
#define __DMLOADER_IOCTL_H

//#include "IOCTL.h"


class CIoctlDmLoader : public CIoctl
{
public:
    CIoctlDmLoader(CDevice *pDevice): CIoctl(pDevice){;};
    virtual ~CIoctlDmLoader(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

};




#endif //__DMLOADER_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\dmloaderioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*


#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
*/
#include "DmLoaderIOCTL.h"

static bool s_fVerbose = false;

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

#define IOCTL_DMLOAD_START_DMIO CTL_CODE(FILE_DEVICE_UNKNOWN, 0, \
                                         METHOD_BUFFERED, \
                                         FILE_WRITE_ACCESS)
#define IOCTL_DMLOAD_QUERY_DMIO_STATUS CTL_CODE(FILE_DEVICE_UNKNOWN, 2, \
                                                METHOD_BUFFERED, \
                                                FILE_READ_ACCESS)
#define IOCTL_DMLOAD_GET_BOOTDISKINFO CTL_CODE(FILE_DEVICE_UNKNOWN, 3, \
                                                METHOD_BUFFERED, \
                                                FILE_ANY_ACCESS)

/*
 * internal structure to hold boot disk information
 */
struct vx_bootdisk_info {
        LONGLONG BootPartitionOffset;
        LONGLONG SystemPartitionOffset;
        ULONG BootDeviceSignature;
        ULONG SystemDeviceSignature;
};

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


void CIoctlDmLoader::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    ;
}

void CIoctlDmLoader::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
    switch(dwIOCTL)
    {
    case IOCTL_DMLOAD_QUERY_DMIO_STATUS:
        SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG));

        break;

    case IOCTL_DMLOAD_GET_BOOTDISKINFO:
        SetOutParam(abOutBuffer, dwOutBuff, sizeof(vx_bootdisk_info));

        break;

    case IOCTL_DMLOAD_START_DMIO:
    default:
        CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
    }
}


BOOL CIoctlDmLoader::FindValidIOCTLs(CDevice *pDevice)
{
    AddIOCTL(pDevice, IOCTL_DMLOAD_START_DMIO);
    AddIOCTL(pDevice, IOCTL_DMLOAD_QUERY_DMIO_STATUS);
    AddIOCTL(pDevice, IOCTL_DMLOAD_GET_BOOTDISKINFO);

    return TRUE;
}



void CIoctlDmLoader::CallRandomWin32API(LPOVERLAPPED pOL)
{
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\dpf.h ===
#define DPF(x) { if (s_fVerbose) _tprintf x ;}
//#define DPF(x) 

//#define DPFLUSH() fflush(stdout)
#define DPFLUSH() 

//new -> virtualalloc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\driverioctlbase.h ===
#ifndef __DRIVER_IOCTL_BASE_H
#define __DRIVER_IOCTL_BASE_H

#include "IOCTL.h"


class CIoctlDriverBase : public CIoctl
{
public:
    CIoctlDriverBase(CDevice *pDevice): CIoctl(pDevice){;};
    virtual ~CIoctlDriverBase(){;};

	//
	// This method creates/open the device.
	// this is where you choose the specific flags for CreateFile(), or even use 
	// another function, such as CreateNamedPipe()
	// The default behaviour, is to try and CreateFile() with a set of hardcoded
	// possibilities for flags.
	//
	virtual HANDLE CreateDevice(CDevice *pDevice);

	//
	// you may wish to override this method, for example to perform post
	// close actions, like deleting the file, or whatever
	//
	virtual BOOL CloseDevice(CDevice *pDevice);

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual BOOL DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		);

    virtual void CallRandomWin32API(OVERLAPPED *pOL);

};




#endif //__DRIVER_IOCTL_BASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\excptfltr.cpp ===
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>

#include "ExcptFltr.h"

#define DPF(x) _tprintf x

LONG
PrintExceptionInfoFilter(
   struct _EXCEPTION_POINTERS *ExInfo,
   TCHAR *szFile,
   int nLine
   )
{
	DWORD dwProcessId = ::GetCurrentProcessId();
	HANDLE hProcess = ::GetCurrentProcess();
	DWORD dwThreadId = ::GetCurrentThreadId();
	HANDLE hThread = ::GetCurrentThread();
	DPF((
		TEXT("%s(%d) - dwProcessId=%d, hProcess=%d, dwThreadId=%d, hThread=%d\n"),
		szFile,
		nLine,
		dwProcessId, 
		hProcess,
		dwThreadId,
		hThread
		));
	DPF((TEXT("%d:%d - ExceptionRecord= !exr %X\n"), dwProcessId, dwThreadId, ExInfo->ExceptionRecord));
	DPF((TEXT("%d:%d - ContextRecord= !cxr %X ; !kb\n"), dwProcessId, dwThreadId, ExInfo->ContextRecord));
	fflush(stdout);
	_ASSERTE(FALSE);
   return EXCEPTION_EXECUTE_HANDLER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\excptfltr.h ===
#ifndef __EXCEPTION_FILTER__H
#define __EXCEPTION_FILTER__H

LONG
PrintExceptionInfoFilter(
   struct _EXCEPTION_POINTERS *ExInfo,
   TCHAR *szFile,
   int nLine
   );

#endif //__EXCEPTION_FILTER__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\efsstruc.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    efsstruc.h

Abstract:

    EFS (Encrypting File System) defines, data and function prototypes.

Author:

    Robert Reichel      (RobertRe)
    Robert Gu           (RobertG)

Environment:

Revision History:

--*/

#ifndef _EFSSTRUC_
#define _EFSSTRUC_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef ALGIDDEF
#define ALGIDDEF
typedef unsigned int ALG_ID;
#endif

//
// Our OID.  Remove from here once it's in the real headers.
//

#ifndef szOID_EFS_CRYPTO
#define szOID_EFS_CRYPTO		"1.3.6.1.4.1.311.10.3.4"
#endif

#ifndef szOID_EFS_RECOVERY
#define szOID_EFS_RECOVERY      "1.3.6.1.4.1.311.10.3.4.1"
#endif


//
// Context flag
//

#define CONTEXT_FOR_EXPORT      0x00000000
#define CONTEXT_FOR_IMPORT      0x00000001
#define CONTEXT_INVALID         0x00000002

//
// Context ID
//
#define EFS_CONTEXT_ID  0x00000001

//
// Signature type
//
#define SIG_LENGTH              0x00000008
#define SIG_NO_MATCH            0x00000000
#define SIG_EFS_FILE            0x00000001
#define SIG_EFS_STREAM          0x00000002
#define SIG_EFS_DATA            0x00000003

//
// Export file format stream flag information
//

#define STREAM_NOT_ENCRYPTED    0x0001

#define EFS_EXP_FORMAT_CURRENT_VERSION  0x0100
#define EFS_SIGNATURE_LENGTH    4
#define EFS_STREAM_ID    0x1910

#define FSCTL_IMPORT_INPUT_LENGTH 4 * 1024
#define FSCTL_EXPORT_INPUT_LENGTH 128
#define FSCTL_OUTPUT_INITIAL_LENGTH    68 * 1024
#define FSCTL_OUTPUT_LESS_LENGTH       8 * 1024
#define FSCTL_OUTPUT_MIN_LENGTH        20 * 1024
#define FSCTL_OUTPUT_MISC_LENGTH       4 * 1024

//
// FSCTL data shared between server and driver
//

#define EFS_SET_ENCRYPT                 0
#define EFS_SET_ATTRIBUTE               1
#define EFS_DEL_ATTRIBUTE               2
#define EFS_GET_ATTRIBUTE               3
#define EFS_OVERWRITE_ATTRIBUTE         4
#define EFS_ENCRYPT_DONE                5
#define EFS_DECRYPT_BEGIN               6

//
// Mask for Set EFS Attribute
//

#define WRITE_EFS_ATTRIBUTE     0x00000001
#define SET_EFS_KEYBLOB         0x00000002

//
// Sub code of SET_ENCRYPT FSCTL
//

#define EFS_FSCTL_ON_DIR                0x80000000
#define EFS_ENCRYPT_FILE                0x00000001
#define EFS_DECRYPT_FILE                0x00000002
#define EFS_ENCRYPT_STREAM              0x00000003
#define EFS_DECRYPT_STREAM              0x00000004
#define EFS_DECRYPT_DIRFILE             0x80000002
#define EFS_ENCRYPT_DIRSTR              0x80000003
#define EFS_DECRYPT_DIRSTR              0x80000004


//
// EFS Version Information
//
// EFS_CURRENT_VERSION must always be the highest known revision
// level.  This value is placed in the EfsVersion field of the
// $EFS header.
//

#define EFS_VERSION_1                   (0x00000001)
#define EFS_CURRENT_VERSION             EFS_VERSION_1



///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// EFS Data structures                                                        /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////
//                                                                  /
// EFS_KEY Structure                                                /
//                                                                  /
/////////////////////////////////////////////////////////////////////

typedef struct _EFS_KEY {

    //
    // The length in bytes of the appended key.
    //

    ULONG KeyLength;

    //
    // The number of bits of entropy in the key.
    // For example, an 8 byte key has 56 bits of
    // entropy.
    //

    ULONG Entropy;

    //
    // The algorithm used in conjunction with this key.
    //
    // Note: this is not the algorithm used to encrypt the
    // actual key data itself.
    //

    ALG_ID Algorithm;

    //
    // This structure must be a multiple of 8 in size,
    // including the KeyData at the end.
    //

    ULONG Pad;

    //
    // KeyData is appended to the end of the structure.
    //

    // UCHAR KeyData[1];

} EFS_KEY, *PEFS_KEY;

//
// Private macros to manipulate data structures
//

#define EFS_KEY_SIZE( pKey ) (sizeof( EFS_KEY ) + (pKey)->KeyLength)

#define EFS_KEY_DATA( Key )  (PUCHAR)(((PUCHAR)(Key)) + sizeof( EFS_KEY ))

#define OFFSET_TO_POINTER( FieldName, Base )  (((PUCHAR)((Base)->FieldName)) + (ULONG_PTR)(Base))

#define POINTER_TO_OFFSET( Pointer, Base ) (((PUCHAR)(Pointer)) - ((PUCHAR)(Base)))

//
// We're going to use MD5 to hash the EFS stream.  MD5 yields a 16 byte long hash.
//

#define MD5_HASH_SIZE   16

typedef struct _EFS_DATA_STREAM_HEADER {
    ULONG Length;
    ULONG State;
    ULONG EfsVersion;
    ULONG CryptoApiVersion;
    GUID  EfsId;
    UCHAR EfsHash[MD5_HASH_SIZE];
    UCHAR DrfIntegrity[MD5_HASH_SIZE];
    PVOID DataDecryptionField;
    PVOID DataRecoveryField;
    PVOID Reserved;
    PVOID Reserved2;
    PVOID Reserved3;
} EFS_DATA_STREAM_HEADER, *PEFS_DATA_STREAM_HEADER;



///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// EFS_PUBLIC_KEY_INFO                                                        /
//                                                                            /
// This structure is used to contain all the information necessary to decrypt /
// the FEK.                                                                   /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////


typedef struct _EFS_CERT_HASH_DATA {
    PUCHAR  pbHash;             // offset from start of structure
    ULONG   cbHash;             // count of bytes in hash
    PVOID   ContainerName;      // hint data, offset to LPWSTR
    PVOID   ProviderName;       // hint data, offset to LPWSTR
    PVOID   lpDisplayInformation; // offset to an LPWSTR
} EFS_CERT_HASH_DATA, *PEFS_CERT_HASH_DATA;


typedef struct _EFS_PUBLIC_KEY_INFO_RELATIVE {

    //
    // The length of this entire structure, including string data
    // appended to the end.
    //

    ULONG Length;

    //
    // Sid of owner of the public key (regardless of format).
    // This field is to be treated as a hint only.
    //

    ULONG PossibleKeyOwner;

    //
    // Contains information describing how to interpret
    // the public key information
    //

    ULONG KeySourceTag;

    union {
        struct {

            //
            // The following fields contain offsets based at the
            // beginning of the structure.  Each offset is to
            // a NULL terminated WCHAR string.
            //

            ULONG ContainerName;
            ULONG ProviderName;

            //
            // The exported public key used to encrypt the FEK.
            // This field contains an offset from the beginning of the
            // structure.
            //

            ULONG PublicKeyBlob;

            //
            // Length of the PublicKeyBlob in bytes
            //

            ULONG PublicKeyBlobLength;

        } ContainerInfo;

        struct {

            ULONG CertificateLength;       // in bytes
            ULONG Certificate;             // offset from start of structure

        } CertificateInfo;

        struct {

            ULONG ThumbprintLength;                  // in bytes
            ULONG CertHashData;                      // offset from start of structure

        } CertificateThumbprint;
    };



} EFS_PUBLIC_KEY_INFO_RELATIVE , *PEFS_PUBLIC_KEY_INFO_RELATIVE;

typedef struct _EFS_PUBLIC_KEY_INFO {

    //
    // The length of this entire structure, including string data
    // appended to the end.
    //

    ULONG Length;

    //
    // Sid of owner of the public key (regardless of format).
    // This field is to be treated as a hint only.
    //

    PSID PossibleKeyOwner;

    //
    // Contains information describing how to interpret
    // the public key information
    //

    ULONG KeySourceTag;

    union {
        struct {

            //
            // The following fields contain offsets based at the
            // beginning of the structure.  Each offset is to
            // a NULL terminated WCHAR string.
            //

            PVOID ContainerName;
            PVOID ProviderName;

            //
            // The exported public key used to encrypt the FEK.
            // This field contains an offset from the beginning of the
            // structure.
            //

            PUCHAR PublicKeyBlob;

            //
            // Length of the PublicKeyBlob in bytes
            //

            ULONG PublicKeyBlobLength;

        } ContainerInfo;

        struct {

            ULONG CertificateLength;       // in bytes
            PVOID Certificate;             // offset from start of structure

        } CertificateInfo;

        struct {

            ULONG ThumbprintLength;                                // in bytes
            PVOID CertHashData;                      // offset from start of structure

        } CertificateThumbprint;
    };



} EFS_PUBLIC_KEY_INFO, *PEFS_PUBLIC_KEY_INFO;

//
// Possible KeyTag values
//

typedef enum _PUBLIC_KEY_SOURCE_TAG {
    EfsCryptoAPIContainer = 1,
    EfsCertificate,
    EfsCertificateThumbprint
} PUBLIC_KEY_SOURCE_TAG, *PPUBLIC_KEY_SOURCE_TAG;


///////////////////////////////////////////////////////////////////////////////
//                                                                            /
//  RECOVERY_KEY Data Structure                                               /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

//
// This structure is obsolete.  It is here because it may exist in the
// local policy of workstations that used encryption between the time
// that EFS was introduced into the system and the definition of
// RECOVERY_KEY_1_1 below.
//

typedef struct _RECOVERY_KEY_1_0   {
        ULONG       TotalLength;
        LPWSTR      KeyName;
        ALG_ID      AlgorithId;
        LPWSTR      CSPName;
        ULONG       CSPType;
        ULONG       PublicBlobLength;
        UCHAR       PublicBlob[1];
} RECOVERY_KEY_1_0, *PRECOVERY_KEY_1_0;

//
// Current format of recovery data.
//

typedef struct _RECOVERY_KEY_1_1   {
        ULONG               TotalLength;
        EFS_PUBLIC_KEY_INFO_RELATIVE PublicKeyInfo;
} RECOVERY_KEY_1_1, *PRECOVERY_KEY_1_1;



///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// KEY_INTEGRITY_INFO                                                         /
//                                                                            /
// The KEY_INTEGRITY_INFO structure is used to verify that                    /
// the user's key has correctly decrypted the file's FEK.                     /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

typedef struct _KEY_INTEGRITY_INFO {

    //
    // The length of the entire structure, including the
    // variable length integrity information appended to
    // the end
    //

    ULONG Length;

    //
    // The algorithm used to hash the combined FEK and
    // public key
    //

    ALG_ID HashAlgorithm;

    //
    // The length of just the hash data.
    //

    ULONG HashDataLength;

    //
    // Integrity information goes here
    //

    // UCHAR Integrity Info[]
} KEY_INTEGRITY_INFO, *PKEY_INTEGRITY_INFO;

typedef struct _EFS_KEY_SALT {
    ULONG Length;   // total length of header plus data
    ULONG SaltType; // figure out what you want for this
    //
    // Put data here, so total length of the structure is
    // sizeof( EFS_KEY_SALT ) + length of your data
    //
} EFS_KEY_SALT, *PEFS_KEY_SALT;

//
// EFS Private DataStructures
//

typedef struct _ENCRYPTED_KEY {

    //
    // Total length of this structure and its data
    //

    ULONG Length;

    //
    // contains an offset from beginning of structure,
    // used to decrypt the EncryptedKey
    //

    PEFS_PUBLIC_KEY_INFO PublicKeyInfo;

    //
    // Length in bytes of EncryptedFEK field
    //

    ULONG EncryptedFEKLength;

    //
    // offset from beginning of structure to encrypted
    // EFS_KEY containing the FEK
    //
    // Type is PUCHAR because data is encrypted.
    //

    PUCHAR EncryptedFEK;

    //
    // offset from beginning of structure to KEY_INTEGRITY_INFO
    //

    PEFS_KEY_SALT EfsKeySalt;

    //
    // FEK Data
    //
    // KEY_INTEGRITY_INFO Data
    //
    // PEFS_PUBLIC_KEY_INFO Data
    //

} ENCRYPTED_KEY, *PENCRYPTED_KEY;


//
// The Key Ring Structure.
//

typedef struct _ENCRYPTED_KEYS {
    ULONG           KeyCount;
    ENCRYPTED_KEY   EncryptedKey[1];
} ENCRYPTED_KEYS, *PENCRYPTED_KEYS;

typedef ENCRYPTED_KEYS      DDF, *PDDF;
typedef ENCRYPTED_KEYS      DRF, *PDRF;

typedef struct _EFS_STREAM_SIZE {
    ULONG       StreamFlag;
    LARGE_INTEGER   EOFSize;
    LARGE_INTEGER   AllocSize;
} EFS_STREAM_SIZE, *PEFS_STREAM_SIZE;

#define NEXT_ENCRYPTED_KEY( pEncryptedKey )  (PENCRYPTED_KEY)(((PBYTE)(pEncryptedKey)) + ((PENCRYPTED_KEY)(pEncryptedKey))->Length)


//
// Import context
//

typedef struct IMPORT_CONTEXT{

    ULONG       ContextID; //To distinguish from other LSA context. Offset is fixed across LSA.
    ULONG       Flag;   // Indicate the type of context
    HANDLE      Handle; // File handle, used to create rest streams
    ULONG       Attribute;
    ULONG       CreateDisposition;
    ULONG       CreateOptions;
    ULONG       DesiredAccess;

} IMPORT_CONTEXT, *PIMPORT_CONTEXT;

//
// Export context
//

typedef struct EXPORT_CONTEXT{

    ULONG           ContextID; //To distinguish from other LSA context. Offset is fixed across LSA.
    ULONG           Flag;   // Indicate the type of context
    HANDLE          Handle; // File handle, used to open rest streams
    ULONG           NumberOfStreams;
    PHANDLE         StreamHandles;
    PUNICODE_STRING StreamNames;
    PFILE_STREAM_INFORMATION StreamInfoBase;

} EXPORT_CONTEXT, *PEXPORT_CONTEXT;

//
// EFS Export/Import RPC pipe status
//

typedef struct EFS_EXIM_STATE{
    PVOID   ExImCallback;
    PVOID   CallbackContext;
    char     *WorkBuf;
    ULONG   BufLength;
    ULONG  Status;
} EFS_EXIM_STATE, *PEFS_EXIM_STATE;

//
// Export file format
//

typedef struct EFSEXP_FILE_HEADER{

    ULONG  VersionID;   // Export file version
    WCHAR  FileSignature[EFS_SIGNATURE_LENGTH]; // Signature of the file
    ULONG  Reserved[2];
    //STREAM_DADA     Streams[0];  // An array of STREAM_BLOCK

} EFSEXP_FILE_HEADER, *PEFSEXP_FILE_HEADER;

typedef struct EFSEXP_STREAM_HEADER{

    ULONG    Length; // Redundant information. The length of this block not including DataBlocks but
                     // including itself; This field is to simplify the import routine.
    WCHAR    StreamSignature[EFS_SIGNATURE_LENGTH]; // Signature of the stream
    ULONG    Flag;  // Indicating if the stream is encrypted or not and etc.
    ULONG    Reserved[2];  // For future use
    ULONG    NameLength;   // Length of the stream name
    //WCHAR    StreamName[0];   // ID of the stream, Binary value can be used.
    //DATA_BLOCK   DataBlocks[0]; // Variable number of data block

} EFSEXP_STREAM_HEADER, *PEFSEXP_STREAM_HEADER;

typedef struct EFSEXP_DATA_HEADER{

    ULONG Length;      // Length of the block including this ULONG
    WCHAR DataSignature[EFS_SIGNATURE_LENGTH]; // Signature of the data
    ULONG Flag;          // For future use.
    // BYTE  DataBlock[N];  // N = Length - 2 * sizeof (ULONG) - 4 * sizeof (WCHAR)

} EFSEXP_DATA_HEADER, *PEFSEXP_DATA_HEADER;

//
//  TotalLength - total length of the RECOVERY_KEY Datastructure.
//
//  KeyName     - the storage stream will actually have the characters terminated by
//              a NULL character.
//  AlgorithmId - CryptAPI Algorithm ID - in V1 it is always RSA.
//
//  CSPName     - the storage stream will actually have the characters terminated by
//              a NULL character.
//  CSPType     - CryptAPI type of CSP.
//
//  PublicBlobLength - Length of the public blob that is importable in CryptoAPI in bytes.
//

//
//  Recovery Policy Data Structures
//

typedef struct _RECOVERY_POLICY_HEADER {
    USHORT      MajorRevision;
    USHORT      MinorRevision;
    ULONG       RecoveryKeyCount;
} RECOVERY_POLICY_HEADER, *PRECOVERY_POLICY_HEADER;


typedef struct _RECOVERY_POLICY_1_0    {
        RECOVERY_POLICY_HEADER  RecoveryPolicyHeader;
        PRECOVERY_KEY_1_0       RecoveryKeyList[1];
}   RECOVERY_POLICY_1_0, *PRECOVERY_POLICY_1_0;


typedef struct _RECOVERY_POLICY_1_1    {
        RECOVERY_POLICY_HEADER  RecoveryPolicyHeader;
        RECOVERY_KEY_1_1        RecoveryKeyList[1];
}   RECOVERY_POLICY_1_1, *PRECOVERY_POLICY_1_1;

#define EFS_RECOVERY_POLICY_MAJOR_REVISION_1   (1)
#define EFS_RECOVERY_POLICY_MINOR_REVISION_0   (0)

#define EFS_RECOVERY_POLICY_MINOR_REVISION_1   (1)

//
//  Major/Minor Revision - revision number of policy information.
//
//  RecoveryKeyCount - number of recovery keys configured in this policy.
//
//  RecoveryKeyList - array of recovery keys.
//

//
// Session Key Structure
//

#define SESSION_KEY_SIZE    8
#define COMMON_FSCTL_HEADER_SIZE (7 * sizeof( ULONG ) + 2 * SESSION_KEY_SIZE)

typedef struct _EFS_INIT_DATAEXG {
    UCHAR Key[SESSION_KEY_SIZE];
    HANDLE LsaProcessID; // The reason we use HANDLE is for the sake of 64 bits
} EFS_INIT_DATAEXG, *PEFS_INIT_DATAEXG;


//
// Server API, callable from kernel mode
//

NTSTATUS
EfsGenerateKey(
      PEFS_KEY * Fek,
      PEFS_DATA_STREAM_HEADER * EfsStream,
      PEFS_DATA_STREAM_HEADER DirectoryEfsStream,
      ULONG DirectoryEfsStreamLength,
      PVOID * BufferBase,
      PULONG BufferLength
      );


NTSTATUS
GenerateDirEfs(
    PEFS_DATA_STREAM_HEADER DirectoryEfsStream,
    ULONG DirectoryEfsStreamLength,
    PEFS_DATA_STREAM_HEADER * NewEfs,
    PVOID * BufferBase,
    PULONG BufferLength
    );


#define EFS_OPEN_NORMAL  1
#define EFS_OPEN_RESTORE 2
#define EFS_OPEN_BACKUP  3

NTSTATUS
EfsDecryptFek(
    IN OUT PEFS_KEY * Fek,
    IN PEFS_DATA_STREAM_HEADER CurrentEfs,
    IN ULONG EfsStreamLength,
    IN ULONG OpenType,                      //Normal, Recovery or Backup
    OUT PEFS_DATA_STREAM_HEADER *NewEfs,     //In case the DDF, DRF are changed
    PVOID * BufferBase,
    PULONG BufferLength
    );

NTSTATUS
GenerateSessionKey(
    OUT EFS_INIT_DATAEXG * SessionKey
    );


//
// Private usermode server API
//

ULONG
EfsEncryptFileRPCClient(
    IN PUNICODE_STRING    FileName
    );

ULONG
EfsDecryptFileRPCClient(
    PUNICODE_STRING      FileName,
    ULONG   OpenFlag
    );

ULONG
EfsOpenFileRawRPCClient(
    IN  LPCWSTR    FileName,
    IN  ULONG   Flags,
    OUT PVOID * Context
    );

VOID
EfsCloseFileRawRPCClient(
    IN  PVOID   Context
    );

#ifdef __cplusplus
}
#endif

#endif // _EFSSTRUC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\driverioctlbase.cpp ===
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>

typedef DWORD NTSTATUS;
#include <ntstatus.h>

#include "DriverIOCTLBase.h"

static bool s_fVerbose = false;

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;
typedef struct _IO_STATUS_BLOCK {
    union {
        NTSTATUS Status;
        PVOID Pointer;
    };

    ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;
#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }
#define OBJ_CASE_INSENSITIVE    0x00000040L

#define TIME LARGE_INTEGER
#include ".\srvfsctl.h"

static
VOID
RtlInitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitUnicodeString function initializes an NT counted
    unicode string.  The DestinationString is initialized to point to
    the SourceString and the Length and MaximumLength fields of
    DestinationString are initialized to the length of the SourceString,
    which is zero if SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated unicode string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PWSTR)SourceString;
    if (SourceString) {
        Length = wcslen( SourceString ) * sizeof( WCHAR );
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));
        }
    else {
        DestinationString->MaximumLength = 0;
        DestinationString->Length = 0;
        }
}


//
// This method creates/open the device.
// this is where you choose the specific flags for CreateFile(), or even use 
// another function, such as CreateNamedPipe()
// The default behaviour, is to try and CreateFile() with a set of hardcoded
// possibilities for flags.
//
//#define SERVER_DEVICE_NAME TEXT("\\Device\\LanmanServer")



typedef enum _EVENT_TYPE {
    NotificationEvent,
    SynchronizationEvent
    } EVENT_TYPE;

typedef
VOID
(NTAPI *PIO_APC_ROUTINE) (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );


typedef NTSTATUS (WINAPI *NT_FS_CONTROL_FILE)(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
	);
typedef NTSTATUS (WINAPI *CREATE_EVENT)(
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
	);
typedef NTSTATUS (WINAPI *NT_CLOSE)(
    IN HANDLE Handle
	);
typedef NTSTATUS (WINAPI *NT_WAIT_FOR_SINGLE_OBJECT)(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
	);
typedef NTSTATUS (WINAPI *LOAD_DRIVER)(PUNICODE_STRING DriverServiceName);
typedef NTSTATUS (WINAPI *CLOSE_FILE)(HANDLE h);
typedef NTSTATUS (WINAPI *OPEN_FILE)(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);

HANDLE CIoctlDriverBase::CreateDevice(CDevice *pDevice)
{
	HANDLE hDevice = INVALID_HANDLE_VALUE;

    NTSTATUS status;
    UNICODE_STRING unicodeServerName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;

	UNICODE_STRING driverRegistryPath;

	OPEN_FILE NtOpenFile = NULL;
	LOAD_DRIVER NtLoadDriver = NULL;
	HINSTANCE hNtDll = NULL;


	hNtDll = ::LoadLibrary(TEXT("ntdll.dll"));
	if (NULL == hNtDll)
	{
		DPF((TEXT("CIoctlDriverBase::CreateDevice(): LoadLibrary(\"ntdll.dll\") failed with %d\n"), ::GetLastError()));
		return INVALID_HANDLE_VALUE;
	}

	NtLoadDriver = (LOAD_DRIVER)::GetProcAddress(hNtDll, "NtLoadDriver");
	if (NULL == NtLoadDriver)
	{
		DPF((TEXT("CIoctlDriverBase::CreateDevice(): GetProcAddress(NtLoadDriver) failed with %d\n"), ::GetLastError()));
		goto ErrorExit;
	}

	RtlInitUnicodeString( &driverRegistryPath, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Srv" );
    status = NtLoadDriver( &driverRegistryPath );
    if ( status == STATUS_IMAGE_ALREADY_LOADED ) 
	{
        status = STATUS_SUCCESS;
    }

    if ( !NT_SUCCESS(status) ) 
	{
		DPF((TEXT("CIoctlDriverBase::CreateDevice(): NtLoadDriver() failed with %d\n"), status));
		goto ErrorExit;
	}

    //
    // Open the server device.
    //

    RtlInitUnicodeString( &unicodeServerName, pDevice->GetDeviceName() );

    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeServerName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Opening the server with desired access = SYNCHRONIZE and open
    // options = FILE_SYNCHRONOUS_IO_NONALERT means that we don't have
    // to worry about waiting for the NtFsControlFile to complete--this
    // makes all IO system calls that use this handle synchronous.
    //

	NtOpenFile = (OPEN_FILE)::GetProcAddress(hNtDll, "NtOpenFile");
	if (NULL == NtLoadDriver)
	{
		DPF((TEXT("CIoctlDriverBase::CreateDevice(): GetProcAddress(NtOpenFile) failed with %d\n"), ::GetLastError()));
		goto ErrorExit;
	}
    status = NtOpenFile(
                 &hDevice,
                 FILE_ALL_ACCESS & ~SYNCHRONIZE,
                 &objectAttributes,
                 &ioStatusBlock,
                 0,
                 0
                 );

    if ( NT_SUCCESS(status) ) 
	{
		m_fUseOverlapped = false;
		return hDevice;
    }
	else
	{
		DPF((TEXT("CIoctlDriverBase::CreateDevice(): FreeLibrary(hNtDll) failed with %d\n"), ioStatusBlock.Status));
        ::SetLastError(ioStatusBlock.Status);
		goto ErrorExit;
	}

	_ASSERTE(FALSE);

ErrorExit:
	if (!::FreeLibrary(hNtDll))
	{
		DPF((TEXT("CIoctlDriverBase::CreateDevice(): FreeLibrary(hNtDll) failed with %d\n"), ::GetLastError()));
	}

	return INVALID_HANDLE_VALUE;

}

BOOL CIoctlDriverBase::CloseDevice(CDevice *pDevice)
{
	//
	// BUGBUG: i do not unload the driver if i loaded it
	//
	NTSTATUS status;

	HMODULE hNtDll = NULL;
	CLOSE_FILE NtClose = NULL;

	hNtDll = ::LoadLibrary(TEXT("ntdll.dll"));
	if (NULL == hNtDll)
	{
		DPF((TEXT("CIoctlDriverBase::CloseDevice(): LoadLibrary(\"ntdll.dll\") failed with %d\n"), ::GetLastError()));
		goto ErrorExit;
	}
	NtClose = (CLOSE_FILE)::GetProcAddress(hNtDll, "NtClose");
	if (NULL == NtClose)
	{
		DPF((TEXT("CIoctlDriverBase::CloseDevice(): GetProcAddress(NtClose) failed with %d\n"), ::GetLastError()));
		goto ErrorExit;
	}
	status = NtClose( pDevice->m_hDevice );
	::FreeLibrary(hNtDll);

	//
	// BUGBUG: if we get a context switch here, and another thread
	// gets the HANDLE value that we just closed, the IOCTELLING threads
	// may IOCTL a device that we did not intend to, thus crashing ourselves
	// I think we should live with it.
	//
	pDevice->m_hDevice = INVALID_HANDLE_VALUE;

    return( NT_SUCCESS( status ) );

ErrorExit:
	if (hNtDll) ::FreeLibrary(hNtDll);
	if (INVALID_HANDLE_VALUE != pDevice->m_hDevice) ::CloseHandle(pDevice->m_hDevice);
	pDevice->m_hDevice = INVALID_HANDLE_VALUE;
	return false;
}



void CIoctlDriverBase::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    ;
}

void CIoctlDriverBase::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
    switch(dwIOCTL)
    {
    case FSCTL_SRV_STARTUP:
        ((PSERVER_REQUEST_PACKET)abInBuffer)->Level = (ULONG)SS_STARTUP_LEVEL;
		RtlInitUnicodeString( &((PSERVER_REQUEST_PACKET)abInBuffer)->Name1, L"HAIFA.NTDEV.MICROSOFT.COM");
		RtlInitUnicodeString( &((PSERVER_REQUEST_PACKET)abInBuffer)->Name2, L"MICKYS3");
		break;

    case 333:
		break;

    case 3333:
		break;

    case 33333:
		break;

    case 333333:
		break;

	default:
		CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
	}
}


BOOL CIoctlDriverBase::FindValidIOCTLs(CDevice *pDevice)
{
    BOOL bRet = TRUE;
    DPF((TEXT("FindValidIOCTLs() %s is known, will use known IOCTLs\n"), pDevice->GetDeviceName()));

/*
    DisableReadFile(pDevice);
    DisableWriteFile(pDevice);
    DisableDeviceIoControlCalls(pDevice);
    EnableWin32APICalls(pDevice);
*/
    AddIOCTL(pDevice, FSCTL_SRV_STARTUP);

    AddIOCTL(pDevice, FSCTL_SRV_SHUTDOWN);
    AddIOCTL(pDevice, FSCTL_SRV_CLEAR_STATISTICS);
    AddIOCTL(pDevice, FSCTL_SRV_GET_STATISTICS);
    AddIOCTL(pDevice, FSCTL_SRV_SET_DEBUG);
    AddIOCTL(pDevice, FSCTL_SRV_XACTSRV_CONNECT);
    AddIOCTL(pDevice, FSCTL_SRV_SEND_DATAGRAM);
    AddIOCTL(pDevice, FSCTL_SRV_SET_PASSWORD_SERVER);
    AddIOCTL(pDevice, FSCTL_SRV_START_SMBTRACE);
    AddIOCTL(pDevice, FSCTL_SRV_SMBTRACE_FREE_SMB);
    AddIOCTL(pDevice, FSCTL_SRV_END_SMBTRACE);
    AddIOCTL(pDevice, FSCTL_SRV_QUERY_CONNECTIONS);
    AddIOCTL(pDevice, FSCTL_SRV_PAUSE);
    AddIOCTL(pDevice, FSCTL_SRV_CONTINUE);
    AddIOCTL(pDevice, FSCTL_SRV_GET_CHALLENGE);
    AddIOCTL(pDevice, FSCTL_SRV_GET_DEBUG_STATISTICS);
    AddIOCTL(pDevice, FSCTL_SRV_XACTSRV_DISCONNECT);
    AddIOCTL(pDevice, FSCTL_SRV_REGISTRY_CHANGE);
    AddIOCTL(pDevice, FSCTL_SRV_GET_QUEUE_STATISTICS);
    AddIOCTL(pDevice, FSCTL_SRV_SHARE_STATE_CHANGE);
    AddIOCTL(pDevice, FSCTL_SRV_BEGIN_PNP_NOTIFICATIONS);
    AddIOCTL(pDevice, FSCTL_SRV_CHANGE_DOMAIN_NAME);
    AddIOCTL(pDevice, FSCTL_SRV_IPX_SMART_CARD_START);
	/*
    AddIOCTL(pDevice, FSCTL_SRV_NET_CONNECTION_ENUM);
    AddIOCTL(pDevice, FSCTL_SRV_NET_FILE_CLOSE);
    AddIOCTL(pDevice, FSCTL_SRV_NET_FILE_ENUM);
    AddIOCTL(pDevice, FSCTL_SRV_NET_SERVER_DISK_ENUM);
    AddIOCTL(pDevice, FSCTL_SRV_NET_SERVER_SET_INFO);
    AddIOCTL(pDevice, FSCTL_SRV_NET_SERVER_XPORT_ADD);
    AddIOCTL(pDevice, FSCTL_SRV_NET_SERVER_XPORT_DEL);
    AddIOCTL(pDevice, FSCTL_SRV_NET_SERVER_XPORT_ENUM);
    AddIOCTL(pDevice, FSCTL_SRV_NET_SESSION_DEL);
    AddIOCTL(pDevice, FSCTL_SRV_NET_SESSION_ENUM);
    AddIOCTL(pDevice, FSCTL_SRV_NET_SHARE_ADD);
    AddIOCTL(pDevice, FSCTL_SRV_NET_SHARE_DEL);
    AddIOCTL(pDevice, FSCTL_SRV_NET_SHARE_ENUM);
    AddIOCTL(pDevice, FSCTL_SRV_NET_SHARE_SET_INFO);
    AddIOCTL(pDevice, FSCTL_SRV_NET_STATISTICS_GET);
    AddIOCTL(pDevice, FSCTL_SRV_MAX_API_CODE);
	*/

    return bRet;
}


BOOL CIoctlDriverBase::DeviceInputOutputControl(
	HANDLE hDevice,              // handle to a device, file, or directory 
	DWORD dwIoControlCode,       // control code of operation to perform
	LPVOID lpInBuffer,           // pointer to buffer to supply input data
	DWORD nInBufferSize,         // size, in bytes, of input buffer
	LPVOID lpOutBuffer,          // pointer to buffer to receive output data
	DWORD nOutBufferSize,        // size, in bytes, of output buffer
	LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
	LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
	)
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    HANDLE eventHandle;

    
	NT_FS_CONTROL_FILE NtFsControlFile;
	CREATE_EVENT NtCreateEvent;
	NT_CLOSE NtClose;
	NT_WAIT_FOR_SINGLE_OBJECT NtWaitForSingleObject;

	HINSTANCE hNtDll = NULL;

	hNtDll = ::LoadLibrary(TEXT("ntdll.dll"));
	if (NULL == hNtDll)
	{
		DPF((TEXT("CIoctlDriverBase::DeviceInputOutputControl(): LoadLibrary(\"ntdll.dll\") failed with %d\n"), ::GetLastError()));
		return FALSE;
	}

	NtCreateEvent = (CREATE_EVENT)::GetProcAddress(hNtDll, "NtCreateEvent");
	if (NULL == NtCreateEvent)
	{
		DPF((TEXT("CIoctlDriverBase::DeviceInputOutputControl(): GetProcAddress(NtCreateEvent) failed with %d\n"), ::GetLastError()));
		goto ErrorExit;
	}
	NtFsControlFile = (NT_FS_CONTROL_FILE)::GetProcAddress(hNtDll, "NtFsControlFile");
	if (NULL == NtFsControlFile)
	{
		DPF((TEXT("CIoctlDriverBase::DeviceInputOutputControl(): GetProcAddress(NtFsControlFile) failed with %d\n"), ::GetLastError()));
		goto ErrorExit;
	}
	NtWaitForSingleObject = (NT_WAIT_FOR_SINGLE_OBJECT)::GetProcAddress(hNtDll, "NtWaitForSingleObject");
	if (NULL == NtWaitForSingleObject)
	{
		DPF((TEXT("CIoctlDriverBase::DeviceInputOutputControl(): GetProcAddress(NtWaitForSingleObject) failed with %d\n"), ::GetLastError()));
		goto ErrorExit;
	}
	NtClose = (NT_CLOSE)::GetProcAddress(hNtDll, "NtClose");
	if (NULL == NtClose)
	{
		DPF((TEXT("CIoctlDriverBase::DeviceInputOutputControl(): GetProcAddress(NtClose) failed with %d\n"), ::GetLastError()));
		goto ErrorExit;
	}
	DPF((TEXT("CIoctlDriverBase::DeviceInputOutputControl(): GetProcAddress(NtClose) returned with 0x%08X\n"), NtClose));
	
	//
    // Create an event to synchronize with the driver
    //
    status = NtCreateEvent(
                &eventHandle,
                FILE_ALL_ACCESS,
                NULL,
                NotificationEvent,
                FALSE
                );
	
    //
    // Send the request to the server FSD.
    //
    if( !NT_SUCCESS( status ) ) 
	{
		::SetLastError(status);
		goto ErrorExit;
	}

    status = NtFsControlFile(
             hDevice,
             eventHandle,
             NULL,
             NULL,
             &ioStatusBlock,
             dwIoControlCode, //ServerControlCode,
             lpInBuffer, //sendSrp,
             nInBufferSize, //sendSrpLength,
             lpOutBuffer, //Buffer,
             nOutBufferSize //BufferLength
             );

    if( status == STATUS_PENDING ) {
        NtWaitForSingleObject( eventHandle, FALSE, NULL );
    }
	///*
	DPF((
		 TEXT("CIoctlDriverBase::DeviceInputOutputControl(): NtFsControlFile(0x%08X) failed with 0x%08X\n"),
		 dwIoControlCode,
		 status
		 ));
	DPFLUSH();
//*/
	NtClose( eventHandle );

    if ( NT_SUCCESS(status) ) {
        status = ioStatusBlock.Status;
    }

    if( !NT_SUCCESS( status ) ) 
	{
		::SetLastError(status);
		goto ErrorExit;
	}

	return TRUE;

ErrorExit:
	if (!::FreeLibrary(hNtDll))
	{
		DPF((TEXT("CIoctlDriverBase::DeviceInputOutputControl(): FreeLibrary(hNtDll) failed with %d\n"), ::GetLastError()));
	}
	return FALSE;

/*
	return ::DeviceIoControl(
		hDevice,              // handle to a device, file, or directory 
		dwIoControlCode,       // control code of operation to perform
		lpInBuffer,           // pointer to buffer to supply input data
		nInBufferSize,         // size, in bytes, of input buffer
		lpOutBuffer,          // pointer to buffer to receive output data
		nOutBufferSize,        // size, in bytes, of output buffer
		lpBytesReturned,     // pointer to variable to receive byte count
		lpOverlapped    // pointer to structure for asynchronous operation
		);
*/
}

void CIoctlDriverBase::CallRandomWin32API(LPOVERLAPPED pOL)
{
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\filemapioctl.h ===
#ifndef __FILEMAP_IOCTL_H
#define __FILEMAP_IOCTL_H

//#include "IOCTL.h"

#define NUM_OF_VIEWS (32)

class CIoctlFilemap : public CIoctl
{
public:
    CIoctlFilemap(CDevice *pDevice): 
		CIoctl(pDevice), 
		m_fFileInitialized(false),
		m_hFile(INVALID_HANDLE_VALUE)
	{
		ZeroMemory(m_apvMappedViewOfFile, sizeof(m_apvMappedViewOfFile));
		ZeroMemory(m_adwNumOfBytesMapped, sizeof(m_adwNumOfBytesMapped));
		ZeroMemory(m_ahHeap, sizeof(m_ahHeap));
		ZeroMemory(m_afHeapValid, sizeof(m_afHeapValid));
		ZeroMemory(m_apvHeapAllocated, sizeof(m_apvHeapAllocated));
		ZeroMemory(m_adwNumOfBytesAllocated, sizeof(m_adwNumOfBytesAllocated));
		GlobalMemoryStatus(&m_MemoryStatus);
	}

    virtual ~CIoctlFilemap()
	{
		Cleanup();

		if (m_fFileInitialized) CloseHandle(m_hFile);
	}

	HANDLE CreateDevice(CDevice *pDevice);
	BOOL CloseDevice(CDevice *pDevice);

	BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual BOOL DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		);

	virtual BOOL DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

	virtual BOOL DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		);

	virtual BOOL DeviceCancelIo(
		HANDLE hFile  // file handle for which to cancel I/O
		);

private:
	void Cleanup();

	DWORD GetProtectBits();
	void ProbeForRead(
		IN PBYTE Address,
		IN ULONG Length
		);
	void ProbeForWrite(
		IN PBYTE Address,
		IN ULONG Length
		);

	HANDLE m_hFile;
	bool m_fFileInitialized;
	void *m_apvMappedViewOfFile[NUM_OF_VIEWS];
	void *m_apvHeapAllocated[NUM_OF_VIEWS];
	DWORD m_adwNumOfBytesMapped[NUM_OF_VIEWS];
	DWORD m_adwNumOfBytesAllocated[NUM_OF_VIEWS];
	HANDLE m_ahHeap[NUM_OF_VIEWS];
	long m_afHeapValid[NUM_OF_VIEWS];

	MEMORYSTATUS m_MemoryStatus;
};




#endif //__FILEMAP_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\floppyioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*


#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
*/
#include "FloppyIOCTL.h"

static bool s_fVerbose = false;

void CIoctlFloppy::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
	//
	// keep whatever needed result in order to later use in PrepareIOCTLParams()
	//
    return;
}

void CIoctlFloppy::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
	//
	// this is the default, which fills random buffers
    CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
	// you should replace this with pseudo-valid buffers accoriding to dwIOCTL
	// you usually have a switch statement here, that sets the buffs accordingly
	//
}


BOOL CIoctlFloppy::FindValidIOCTLs(CDevice *pDevice)
{
    BOOL bRet = TRUE;
    DPF((TEXT("FindValidIOCTLs() %s is known, will use known IOCTLs\n"), pDevice->GetDeviceName()));

	//
	// add here any relevant IOCTL 
	//
    AddIOCTL(pDevice, 0x00070000);
    AddIOCTL(pDevice, 0x00070004);
    AddIOCTL(pDevice, 0x00070c00);
    AddIOCTL(pDevice, 0x00074800);
    AddIOCTL(pDevice, 0x00090018);
    AddIOCTL(pDevice, 0x0009001c);
    AddIOCTL(pDevice, 0x00090020);
    AddIOCTL(pDevice, 0x00090028);
    AddIOCTL(pDevice, 0x0009002c);
    AddIOCTL(pDevice, 0x00090030);
    AddIOCTL(pDevice, 0x00090058);
    AddIOCTL(pDevice, 0x00090060);
    AddIOCTL(pDevice, 0x0009006f);
    AddIOCTL(pDevice, 0x00090078);
    AddIOCTL(pDevice, 0x00090083);
    AddIOCTL(pDevice, 0x002d0c00);
    AddIOCTL(pDevice, 0x002d4800);
    AddIOCTL(pDevice, 0x004d0000);
    AddIOCTL(pDevice, 0x004d0008);


    AddIOCTL(pDevice, IOCTL_STORAGE_CHECK_VERIFY);
    AddIOCTL(pDevice, IOCTL_STORAGE_CHECK_VERIFY2);
    AddIOCTL(pDevice, IOCTL_STORAGE_MEDIA_REMOVAL);
    AddIOCTL(pDevice, IOCTL_STORAGE_EJECT_MEDIA);
    AddIOCTL(pDevice, IOCTL_STORAGE_LOAD_MEDIA);
    AddIOCTL(pDevice, IOCTL_STORAGE_LOAD_MEDIA2);
    AddIOCTL(pDevice, IOCTL_STORAGE_RESERVE);
    AddIOCTL(pDevice, IOCTL_STORAGE_RELEASE);
    AddIOCTL(pDevice, IOCTL_STORAGE_FIND_NEW_DEVICES);
    AddIOCTL(pDevice, IOCTL_STORAGE_EJECTION_CONTROL);
    AddIOCTL(pDevice, IOCTL_STORAGE_MCN_CONTROL);
    AddIOCTL(pDevice, IOCTL_STORAGE_GET_MEDIA_TYPES);
    AddIOCTL(pDevice, IOCTL_STORAGE_GET_MEDIA_TYPES_EX);
    AddIOCTL(pDevice, IOCTL_STORAGE_RESET_BUS);
    AddIOCTL(pDevice, IOCTL_STORAGE_RESET_DEVICE);
    AddIOCTL(pDevice, IOCTL_STORAGE_GET_DEVICE_NUMBER);
    AddIOCTL(pDevice, IOCTL_STORAGE_PREDICT_FAILURE);
    AddIOCTL(pDevice, OBSOLETE_IOCTL_STORAGE_RESET_BUS);
    AddIOCTL(pDevice, OBSOLETE_IOCTL_STORAGE_RESET_DEVICE);

    AddIOCTL(pDevice, IOCTL_DISK_BASE);
    AddIOCTL(pDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY);
    AddIOCTL(pDevice, IOCTL_DISK_GET_PARTITION_INFO);
    AddIOCTL(pDevice, IOCTL_DISK_SET_PARTITION_INFO);
    AddIOCTL(pDevice, IOCTL_DISK_GET_DRIVE_LAYOUT);
    AddIOCTL(pDevice, IOCTL_DISK_SET_DRIVE_LAYOUT);
    AddIOCTL(pDevice, IOCTL_DISK_VERIFY);
    AddIOCTL(pDevice, IOCTL_DISK_FORMAT_TRACKS);
    AddIOCTL(pDevice, IOCTL_DISK_REASSIGN_BLOCKS);
    AddIOCTL(pDevice, IOCTL_DISK_PERFORMANCE);
    AddIOCTL(pDevice, IOCTL_DISK_IS_WRITABLE);
    AddIOCTL(pDevice, IOCTL_DISK_LOGGING);
    AddIOCTL(pDevice, IOCTL_DISK_FORMAT_TRACKS_EX);
    AddIOCTL(pDevice, IOCTL_DISK_HISTOGRAM_STRUCTURE);
    AddIOCTL(pDevice, IOCTL_DISK_HISTOGRAM_DATA);
    AddIOCTL(pDevice, IOCTL_DISK_HISTOGRAM_RESET);
    AddIOCTL(pDevice, IOCTL_DISK_REQUEST_STRUCTURE);
    AddIOCTL(pDevice, IOCTL_DISK_REQUEST_DATA);
    AddIOCTL(pDevice, IOCTL_DISK_CONTROLLER_NUMBER);

    AddIOCTL(pDevice, SMART_GET_VERSION);
    AddIOCTL(pDevice, SMART_SEND_DRIVE_COMMAND);
    AddIOCTL(pDevice, SMART_RCV_DRIVE_DATA);

    AddIOCTL(pDevice, IOCTL_DISK_UPDATE_DRIVE_SIZE);
    AddIOCTL(pDevice, IOCTL_DISK_GROW_PARTITION);
    AddIOCTL(pDevice, IOCTL_DISK_GET_CACHE_INFORMATION);
    AddIOCTL(pDevice, IOCTL_DISK_SET_CACHE_INFORMATION);
    AddIOCTL(pDevice, IOCTL_DISK_DELETE_DRIVE_LAYOUT);
    AddIOCTL(pDevice, IOCTL_DISK_FORMAT_DRIVE);
    AddIOCTL(pDevice, IOCTL_DISK_SENSE_DEVICE);
    AddIOCTL(pDevice, IOCTL_DISK_CHECK_VERIFY);
    AddIOCTL(pDevice, IOCTL_DISK_MEDIA_REMOVAL);
    AddIOCTL(pDevice, IOCTL_DISK_EJECT_MEDIA);
    AddIOCTL(pDevice, IOCTL_DISK_LOAD_MEDIA);
    AddIOCTL(pDevice, IOCTL_DISK_RESERVE);
    AddIOCTL(pDevice, IOCTL_DISK_RELEASE);
    AddIOCTL(pDevice, IOCTL_DISK_FIND_NEW_DEVICES);
    AddIOCTL(pDevice, IOCTL_DISK_GET_MEDIA_TYPES);

    return bRet;
}



void CIoctlFloppy::CallRandomWin32API(LPOVERLAPPED pOL)
{
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\fileioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

#include <windows.h>
*/

#include <efsstruc.h>


enum {
	PLACE_HOLDER_GET_FILE_SIZE = 0,
	PLACE_HOLDER_SET_END_OF_FILE,
	PLACE_HOLDER_FLUSH_FILE_BUFFERS,
	PLACE_HOLDER_PURGE_COMM,
	PLACE_HOLDER_GET_FILE_INFO_BY_HANDLE,
	PLACE_HOLDER_GET_FILE_TYPE,
	PLACE_HOLDER_LOCK_FILE,
	PLACE_HOLDER_UN_LOCK_FILE,
	PLACE_HOLDER_SET_FILE_POINTER,
	PLACE_HOLDER_WRITE_FILE_GATHER,
	PLACE_HOLDER_READ_FILE_SCATTER,
	PLACE_HOLDER_LAST
};

#define OBJECT_ID_KEY_LENGTH      16
#define OBJECT_ID_EXT_INFO_LENGTH 48

#include "FileIOCTL.h"

static bool s_fVerbose = false;

FILE_SEGMENT_ELEMENT CIoctlFile::sm_aSegmentArray[DIMOFSEGMENTEDARRAY][DIMOFSEGMENTEDARRAY];

SYSTEM_INFO CIoctlFile::sm_SystemInfo;

bool CIoctlFile::sm_fFirstTime = true;

CIoctlFile::CIoctlFile(CDevice *pDevice): 
CIoctl(pDevice),
m_hContainer(10000, INVALID_HANDLE_VALUE, ::CloseHandle)
{
	//if (1 == sm_lObjectCount)
	if (sm_fFirstTime)
	{
		//
		// memory is allocated and never freed, because i want to run with fault injections, 
		// i may fail to allocate so much memory
		//
		sm_fFirstTime = false;
		::GetSystemInfo(&sm_SystemInfo);
		ZeroMemory(sm_aSegmentArray, sizeof(sm_aSegmentArray));
		DPF((TEXT("CIoctlFile::CIoctlFile() before allocating sm_aSegmentArray[]\n")));
		for (int nSegmentedArrays = 0 ; nSegmentedArrays < DIMOFSEGMENTEDARRAY; nSegmentedArrays++)
		{
			for (int nBuffs = 0 ; nBuffs < nSegmentedArrays; nBuffs++)
			{
				// not needed, since all array is zeroed above. ZeroMemory(&sm_aSegmentArray[nSegmentedArrays][nBuffs], sizeof(FILE_SEGMENT_ELEMENT));
				while(true)
				{
					//
					// allocate a page untill success, because of fault-injections
					//
					if (NULL == (sm_aSegmentArray[nSegmentedArrays][nBuffs].Buffer = ::VirtualAlloc(
						NULL,
						sm_SystemInfo.dwPageSize,
						MEM_COMMIT,
						PAGE_READWRITE
						)))
					{
						DPF((TEXT("A")));
						::Sleep(100);
					}
					else
					{
						//DPF((TEXT("sm_aSegmentArray[%d].Buffer = 0x%08X\n"), nBuffs, sm_aSegmentArray[nSegmentedArrays][nBuffs].Buffer));
						break;
					}
				}

				//
				// since 64 is not supported, i must set it explicitly to 0
				//
				//sm_aSegmentArray[nSegmentedArrays][nBuffs].Alignment = 0; //0x00000000FFFFFFFFi64;
			}//for (int nBuffs = 0 ; nBuffs < nSegmentedArrays; nBuffs++)
			ZeroMemory(&sm_aSegmentArray[nSegmentedArrays][nBuffs], sizeof(FILE_SEGMENT_ELEMENT));
			//sm_aSegmentArray[nSegmentedArrays][nBuffs].Buffer = 0;
			//sm_aSegmentArray[nSegmentedArrays][nBuffs].Alignment &= 0x00000000FFFFFFFF;
			//DPF((TEXT("CIoctlFile::CIoctlFile() AFTER allocating sm_aSegmentArray[%d]\n"), nSegmentedArrays));
		}

	}
}

CIoctlFile::~CIoctlFile()
{
	//
	// memory is allocated and never freed, because i want to run with fault injections, 
	// i may fail to allocate so much memory
	//
	/*
	if (1 == sm_lObjectCount)
	{
		for (int i = 0 ; i < DIMOFSEGMENTEDARRAY; i++)
		{
			for (int j = 0 ; i < DIMOFSEGMENTEDARRAY; i++)
			{
				if (!::VirtualFree(
						sm_aSegmentArray[i][j].Buffer,
						0,
						MEM_RELEASE
						))
				{
					DPF((TEXT("VirtualFree(sm_aSegmentArray[%d]) failed with %d"), i, ::GetLastError()));
				}
			}
		}
	}
	*/
}

HANDLE CIoctlFile::CreateDevice(CDevice *pDevice)
{
	//
	// in order to coexist with fault-injections, let try to create the device 100 times
	//
	HANDLE hDevice = INVALID_HANDLE_VALUE;
	TCHAR *szDevice = m_pDevice->GetDeviceName();
	DWORD dwFileAttributes = FILE_FLAG_OVERLAPPED;
	DWORD dwAcccessMode = GENERIC_READ | GENERIC_WRITE;

	m_fFILE_FLAG_NO_BUFFERING = (0 < rand()%10);

	if (m_fFILE_FLAG_NO_BUFFERING)
	{
		dwFileAttributes |= FILE_FLAG_NO_BUFFERING;
		DPF((
			TEXT("CIoctlFile::CreateFile(%s) will use FILE_FLAG_NO_BUFFERING\n"),
			szDevice
			));
	}
	else
	{
		DPF((
			TEXT("CIoctlFile::CreateFile(%s) will NOT use FILE_FLAG_NO_BUFFERING\n"),
			szDevice
			));
	}

	//
	// do NOT remove this loop, at minimum remember that GENERIC_WRITE
	// is toggled, so that read only files can be opened as well
	//
	for (DWORD dwTimesTried = 0; dwTimesTried < 100; dwTimesTried++)
	{
		if (m_pDevice->sm_fExitAllThreads || m_pDevice->m_fShutDown) goto out;

		if (0 == rand()%10) dwFileAttributes |= FILE_FLAG_WRITE_THROUGH;
		//
		// next 2 are mutualy exclusive, but i do not care, because i try hard enough
		// to open the file
		//
		///*
		if (0 == rand()%20) dwFileAttributes |= FILE_FLAG_RANDOM_ACCESS;
		if (0 == rand()%20) dwFileAttributes |= FILE_FLAG_SEQUENTIAL_SCAN;
		if (0 == rand()%20) dwFileAttributes |= FILE_FLAG_DELETE_ON_CLOSE;
		if (0 == rand()%20) dwFileAttributes |= FILE_FLAG_BACKUP_SEMANTICS;
		if (0 == rand()%20) dwFileAttributes |= FILE_FLAG_POSIX_SEMANTICS;
		if (0 == rand()%20) dwFileAttributes |= FILE_FLAG_OPEN_REPARSE_POINT;
		if (0 == rand()%20) dwFileAttributes |= FILE_FLAG_OPEN_NO_RECALL;
		if (0 == rand()%20) dwFileAttributes |= FILE_ATTRIBUTE_ARCHIVE;
		if (0 == rand()%20) dwFileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
		if (0 == rand()%20) dwFileAttributes |= FILE_ATTRIBUTE_HIDDEN;
		if (0 == rand()%20) dwFileAttributes |= FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
		if (0 == rand()%20) dwFileAttributes |= FILE_ATTRIBUTE_OFFLINE;
		if (0 == rand()%200) dwFileAttributes |= FILE_ATTRIBUTE_READONLY;
		if (0 == rand()%20) dwFileAttributes |= FILE_ATTRIBUTE_SYSTEM;
		if (0 == rand()%20) dwFileAttributes |= FILE_ATTRIBUTE_TEMPORARY;
		//*/

		if (0 == rand()%40)
		{
			dwFileAttributes &= (~FILE_FLAG_OVERLAPPED);
			m_fUseOverlapped = false;
		}
		else
		{
			dwFileAttributes |= FILE_FLAG_OVERLAPPED;
			m_fUseOverlapped = true;
		}

		hDevice = ::CreateFile(
			szDevice,          // pointer to name of the file
			dwAcccessMode,       // access (read-write) mode
			FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,           // share mode
			NULL,                        // pointer to security attributes
			OPEN_ALWAYS,  // how to create
			dwFileAttributes,  // file attributes
			NULL         // handle to file with attributes to copy
			);
		if (INVALID_HANDLE_VALUE == hDevice)
		{
			//
			// toggle GENERIC_WRITE so that read only (or CDROM) files can be opened as well
			//
			if (dwAcccessMode & GENERIC_WRITE) dwAcccessMode &= ~GENERIC_WRITE;
			else dwAcccessMode |= GENERIC_WRITE;
//DPF((TEXT("CIoctlFile::OpenDevice(%s) FAILED  with %d, dwAcccessMode=0x%08X, dwFileAttributes=0x08X\n"), szDevice, ::GetLastError(), dwAcccessMode, dwFileAttributes));
			::Sleep(100);//let other threads breath some air
		}
		else
		{
			DPF((
				TEXT("CIoctlFile::CreateFile(%s, 0x%08X, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_ALWAYS, 0x%08x, NULL) succeeded\n"),
				szDevice,
				dwAcccessMode,
				dwFileAttributes
				));
			return hDevice;
		}
	}//for (DWORD dwTimesTried = 0; dwTimesTried < 100; dwTimesTried++)

    DPF((TEXT("CIoctlFile::OpenDevice(%s) FAILED\n"), szDevice));
out:
    return INVALID_HANDLE_VALUE;
}



HANDLE CIoctlFile::CreateAutoDeleteUniqueFile()
{
	//
	// in order to coexist with fault-injections, let try to create the device 100 times
	//
	HANDLE hDevice = INVALID_HANDLE_VALUE;
	TCHAR *szPath = m_pDevice->GetDeviceName();
	TCHAR szFullFileName[16*1024];
	DWORD dwFileAttributes = FILE_FLAG_OVERLAPPED;
	DWORD dwAcccessMode = GENERIC_READ | GENERIC_WRITE;

	lstrcpy(szFullFileName, szPath);
	if (TEXT('\\') != szFullFileName[lstrlen(szFullFileName)-1])
	{
		lstrcat(szFullFileName, TEXT("\\"));
	}

	ULONG ulOriginalPathNameLen = lstrlen(szFullFileName);

	if (0 < rand()%10)
	{
		dwFileAttributes |= FILE_FLAG_NO_BUFFERING;
		DPF((
			TEXT("CIoctlFile::CreateFile(%s) will use FILE_FLAG_NO_BUFFERING\n"),
			szFullFileName
			));
	}
	else
	{
		DPF((
			TEXT("CIoctlFile::CreateFile(%s) will NOT use FILE_FLAG_NO_BUFFERING\n"),
			szFullFileName
			));
	}

	//
	// do NOT remove this loop, at minimum remember that GENERIC_WRITE
	// is toggled, so that read only files can be opened as well
	//
	for (DWORD dwTimesTried = 0; dwTimesTried < 100; dwTimesTried++)
	{
		//AppendRandomFileName(szFullFileName[lstrlen(szFullFileName)-1]);
		do
		{
			for (UINT i = ulOriginalPathNameLen; i < (sizeof(szFullFileName)/(sizeof(*szFullFileName))); i++)
			{
				//
				// mostly valid ansi caracters
				//
				WCHAR wcTemp = rand();
				if (rand()%100)
				{
					szFullFileName[i] = (0xEF & wcTemp);
					//
					//
					// weed some more illegar chars, but not always
					//
					if (rand()%5)
					{
						//
						// backslash is a folder seperator. i will usually not be able to 
						// create such a file
						//
						if ((rand()%4) && (TEXT('\\') == szFullFileName[i]))
						{
							continue;
						}

						if	(
								(rand()%4) && 
								( (33 > szFullFileName[i]) || (126 > szFullFileName[i]) )
							)
						{
							continue;
						}
					}
				}
				else 
				{
					if (rand()%100)
					{
						szFullFileName[i] = (0xff & wcTemp);
					}
					else 
					{
						szFullFileName[i] = (wcTemp);
					}
				}
				//
				// no need to procede after the null
				//
				if (TEXT('\0') == szFullFileName[i]) break;
			}//for (UINT i = ulOriginalPathNameLen; i < (sizeof(szFullFileName)/(sizeof(*szFullFileName))); i++)
			//
			// if the random filename is just empty, try again
			//
		}while(TEXT('\0') == szFullFileName[ulOriginalPathNameLen]);

		szFullFileName[sizeof(szFullFileName)/(sizeof(*szFullFileName))-1] = TEXT('\0');

		if (m_pDevice->sm_fExitAllThreads || m_pDevice->m_fShutDown) goto out;

		if (0 == rand()%10) dwFileAttributes |= FILE_FLAG_WRITE_THROUGH;
		//
		// next 2 are mutualy exclusive, but i do not care, because i try hard enough
		// to open the file
		//
		///*
		if (0 == rand()%20) dwFileAttributes |= FILE_FLAG_RANDOM_ACCESS;
		if (0 == rand()%20) dwFileAttributes |= FILE_FLAG_SEQUENTIAL_SCAN;
		if (0 == rand()%20) dwFileAttributes |= FILE_FLAG_BACKUP_SEMANTICS;
		if (0 == rand()%20) dwFileAttributes |= FILE_FLAG_POSIX_SEMANTICS;
		if (0 == rand()%20) dwFileAttributes |= FILE_FLAG_OPEN_REPARSE_POINT;
		if (0 == rand()%20) dwFileAttributes |= FILE_FLAG_OPEN_NO_RECALL;
		if (0 == rand()%20) dwFileAttributes |= FILE_ATTRIBUTE_ARCHIVE;
		if (0 == rand()%20) dwFileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
		if (0 == rand()%20) dwFileAttributes |= FILE_ATTRIBUTE_HIDDEN;
		if (0 == rand()%20) dwFileAttributes |= FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
		if (0 == rand()%20) dwFileAttributes |= FILE_ATTRIBUTE_OFFLINE;
		if (0 == rand()%200) dwFileAttributes |= FILE_ATTRIBUTE_READONLY;
		if (0 == rand()%20) dwFileAttributes |= FILE_ATTRIBUTE_SYSTEM;
		if (0 == rand()%20) dwFileAttributes |= FILE_ATTRIBUTE_TEMPORARY;
		//*/

		dwFileAttributes |= FILE_FLAG_OVERLAPPED | FILE_FLAG_DELETE_ON_CLOSE;
		m_fUseOverlapped = true;

		hDevice = ::CreateFile(
			szFullFileName,          // pointer to name of the file
			dwAcccessMode,       // access (read-write) mode
			FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,           // share mode
			NULL,                        // pointer to security attributes
			OPEN_ALWAYS,  // how to create
			dwFileAttributes,  // file attributes
			NULL         // handle to file with attributes to copy
			);
		if (INVALID_HANDLE_VALUE == hDevice)
		{
			//
			// toggle GENERIC_WRITE so that read only (or CDROM) files can be opened as well
			//
			if (dwAcccessMode & GENERIC_WRITE) dwAcccessMode &= ~GENERIC_WRITE;
			else dwAcccessMode |= GENERIC_WRITE;
//DPF((TEXT("CIoctlFile::OpenDevice(%s) FAILED  with %d, dwAcccessMode=0x%08X, dwFileAttributes=0x08X\n"), szFullFileName, ::GetLastError(), dwAcccessMode, dwFileAttributes));
			::Sleep(100);//let other threads breath some air
		}
		else
		{
			DPF((
				TEXT("CIoctlFile::CreateFile(%s, 0x%08X, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_ALWAYS, 0x%08x, NULL) succeeded\n"),
				szFullFileName,
				dwAcccessMode,
				dwFileAttributes
				));
			return hDevice;
		}
	}//for (DWORD dwTimesTried = 0; dwTimesTried < 100; dwTimesTried++)

    DPF((TEXT("CIoctlFile::OpenDevice(%s) FAILED\n"), szFullFileName));
out:
    return INVALID_HANDLE_VALUE;
}





void CIoctlFile::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    switch(dwIOCTL)
	{
	case FSCTL_QUERY_USN_JOURNAL:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);
		m_UsnJournalID = ((USN_JOURNAL_DATA*)abOutBuffer)->UsnJournalID;
		break;

	case FSCTL_GET_OBJECT_ID:
	case FSCTL_CREATE_OR_GET_OBJECT_ID:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);
		m_FILE_OBJECTID_BUFFER = *((FILE_OBJECTID_BUFFER*)abOutBuffer);
		break;

	case FSCTL_GET_REPARSE_POINT:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);
		//REPARSE_DATA_BUFFER
		CopyMemory(m_REPARSE_DATA_BUFFER, abOutBuffer, MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
		break;

	case FSCTL_GET_NTFS_VOLUME_DATA:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);
		m_NTFS_VOLUME_DATA_BUFFER = *(NTFS_VOLUME_DATA_BUFFER*)abOutBuffer;
		break;

	case FSCTL_GET_NTFS_FILE_RECORD:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);
		Add_FileReferenceNumber((DWORDLONG*)&(((NTFS_FILE_RECORD_OUTPUT_BUFFER*)abOutBuffer)->FileReferenceNumber.QuadPart));
		break;

	case FSCTL_READ_USN_JOURNAL:
	case FSCTL_READ_FILE_USN_DATA:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);
		Add_USN_RECORD(((USN_RECORD*)abOutBuffer));
		break;

	case FSCTL_WRITE_USN_CLOSE_RECORD:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);
		Add_USN((USN*)abOutBuffer);
		break;

	}
}

void CIoctlFile::CallRandomWin32API(LPOVERLAPPED pOL)
{
	DWORD dwSwitch;
	if	(-1 != m_pDevice->m_dwOnlyThisIndexIOCTL) 
	{ 
		dwSwitch = m_pDevice->m_dwOnlyThisIndexIOCTL;
	}
	else
	{
		dwSwitch = rand()%PLACE_HOLDER_LAST;
	}

	switch(dwSwitch)
	{
	case PLACE_HOLDER_GET_FILE_SIZE:
		{
			DWORD dwFileSizeHigh = 0;
			DWORD dwFileSizeLow = ::GetFileSize(m_pDevice->m_hDevice, rand()%2 ? NULL : &dwFileSizeHigh);
			//DPF((TEXT("GetFileSize() return %d %d\n"), dwFileSizeHigh, dwFileSizeLow));
		}
		break;

	case PLACE_HOLDER_SET_END_OF_FILE:
		::SetEndOfFile(m_pDevice->m_hDevice);
		break;

	case PLACE_HOLDER_FLUSH_FILE_BUFFERS:
		::FlushFileBuffers(m_pDevice->m_hDevice);
		break;

	case PLACE_HOLDER_PURGE_COMM:
		//
		// this should not work, since it is for serial ports
		//
		::PurgeComm(m_pDevice->m_hDevice, GetRandomPurgeCommParams());
		break;

	case PLACE_HOLDER_GET_FILE_INFO_BY_HANDLE:
		{
			BY_HANDLE_FILE_INFORMATION byHandleFileInfo;
			::GetFileInformationByHandle(m_pDevice->m_hDevice, &byHandleFileInfo);
		}
		break;

	case PLACE_HOLDER_GET_FILE_TYPE:
		{
			DWORD dwFileType = ::GetFileType(m_pDevice->m_hDevice);
		}
		break;

	case PLACE_HOLDER_LOCK_FILE:
		{
			DWORD dwLockLow;
			DWORD dwLockHigh;
			GetRandomLockRange(&dwLockLow, &dwLockHigh);
			::LockFileEx(
				m_pDevice->m_hDevice,
				GetRandomLockFlags(),     // behavior-modification flags
				0,  // reserved, must be set to zero
				dwLockLow, // low-order word of length 
				dwLockHigh, // high-order word of length
				pOL  // structure with lock region start offset
				);
		}
		break;

	case PLACE_HOLDER_UN_LOCK_FILE:
		{
			DWORD dwLockLow;
			DWORD dwLockHigh;
			GetRandomUnLockRange(&dwLockLow, &dwLockHigh);
			::UnlockFileEx(
				m_pDevice->m_hDevice,      // handle of file to unlock
				0,  // reserved, must be set to zero
				dwLockLow,  // low-order word of length to unlock
				dwLockHigh, // high-order word of length to unlock
				pOL // unlock region start offset
				);
		}
		break;

	case PLACE_HOLDER_SET_FILE_POINTER:
		{
			LONG dwDistanceToMoveHigh = rand()%10 ? 0 : rand();
			DWORD dwMoveMethod = GetMoveMethod();
			::SetFilePointer(
				m_pDevice->m_hDevice,          // handle of file
				rand()%10 ? rand() : DWORD_RAND,  // number of bytes to move pointer
				&dwDistanceToMoveHigh,
				dwMoveMethod     // how to move pointer
				);
		}
		break;

	case PLACE_HOLDER_WRITE_FILE_GATHER:
		{
			if (!m_fFILE_FLAG_NO_BUFFERING)
			{
				//
				// relevant only for FILE_FLAG_NO_BUFFERING
				//
				break;
			}

			//
			// should have been opened with FILE_FLAG_NO_BUFFERING 
			//
			int nNumOfPages = rand()%DIMOFSEGMENTEDARRAY;
			if (!::WriteFileGather(
				m_pDevice->m_hDevice,          // handle of file
				sm_aSegmentArray[nNumOfPages], // array of buffer pointers
				sm_SystemInfo.dwPageSize*nNumOfPages, // number of bytes to write
				NULL,                    // reserved; must be NULL
				pOL     // pointer to an OVERLAPPED structure
					))
			{
				//
				// we may fail, for example if we want more bytes than available
				// that it besides the error due to cancel IO, CloseHandle, etc.
				//
				DPF((TEXT("WriteFileGather() failed with %d\n"), ::GetLastError()));
			}
			else
			{
				DPF((TEXT("WriteFileGather() succeeded\n")));
			}
		}
		break;

	case PLACE_HOLDER_READ_FILE_SCATTER:
		{
			if (!m_fFILE_FLAG_NO_BUFFERING)
			{
				//
				// relevant only for FILE_FLAG_NO_BUFFERING
				//
				break;
			}

			//
			// should have been opened with FILE_FLAG_NO_BUFFERING 
			//
			int nNumOfPages = rand()%DIMOFSEGMENTEDARRAY;
			if (!::ReadFileScatter(
				m_pDevice->m_hDevice,          // handle of file
				sm_aSegmentArray[nNumOfPages], // array of buffer pointers
				sm_SystemInfo.dwPageSize*nNumOfPages, // number of bytes to read
				NULL,                    // reserved; must be NULL
				pOL     // pointer to an OVERLAPPED structure
					))
			{
				//
				// we may fail, for example if we want more bytes than available
				// that it besides the error due to cancel IO, CloseHandle, etc.
				//
				DPF((TEXT("ReadFileScatter() failed with %d\n"), ::GetLastError()));
			}
			else
			{
				DPF((TEXT("ReadFileScatter() succeeded\n")));
			}
		}
		break;

	default: _ASSERTE(FALSE);
	}

}

void CIoctlFile::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
	switch(dwIOCTL)
	{
    case FSCTL_REQUEST_OPLOCK_LEVEL_1:
		break;

    case FSCTL_REQUEST_OPLOCK_LEVEL_2:
		break;

    case FSCTL_REQUEST_BATCH_OPLOCK:
		break;

    case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
		break;

    case FSCTL_OPBATCH_ACK_CLOSE_PENDING:
		break;

    case FSCTL_OPLOCK_BREAK_NOTIFY:
		break;

    case FSCTL_LOCK_VOLUME:
		break;

    case FSCTL_UNLOCK_VOLUME:
		break;

    case FSCTL_DISMOUNT_VOLUME:
		break;

    case FSCTL_IS_VOLUME_MOUNTED:
		break;

    case FSCTL_IS_PATHNAME_VALID:
		break;

    case FSCTL_MARK_VOLUME_DIRTY:
		break;

    case FSCTL_QUERY_RETRIEVAL_POINTERS:
		//
		// implemented by driver only for kernel mode caller, and only on paging file
		//
		break;

    case FSCTL_GET_COMPRESSION:

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(USHORT));

		break;

    case FSCTL_SET_COMPRESSION:
        *((USHORT*)abInBuffer) = GetRandom_CompressionState();
        SetInParam(dwInBuff, sizeof(USHORT));

		break;

    case FSCTL_MARK_AS_SYSTEM_HIVE:
		//
		// will be rejected if caller is user mode
		//
		break;

    case FSCTL_OPLOCK_BREAK_ACK_NO_2:
		break;

    case FSCTL_INVALIDATE_VOLUMES:
		// maybe use code like in private\windows\gina\winlogon\removabl.c (NtOpenDirectoryObject)
        *((HANDLE*)abInBuffer) = rand()%2 ? m_pDevice->m_hDevice : (HANDLE)rand();

		break;

    case FSCTL_QUERY_FAT_BPB:
		
        SetOutParam(abOutBuffer, dwOutBuff, sizeof(FSCTL_QUERY_FAT_BPB_BUFFER));

		break;

    case FSCTL_REQUEST_FILTER_OPLOCK:
		break;

    case FSCTL_FILESYSTEM_GET_STATISTICS:
        SetOutParam(abOutBuffer, dwOutBuff, sizeof(FILESYSTEM_STATISTICS));
		
		break;

    case FSCTL_GET_NTFS_VOLUME_DATA:
        SetOutParam(abOutBuffer, dwOutBuff, sizeof(NTFS_VOLUME_DATA_BUFFER));
		
		break;

    case FSCTL_GET_NTFS_FILE_RECORD:
		{
			BY_HANDLE_FILE_INFORMATION byHandleFileInfo;
			::GetFileInformationByHandle(m_pDevice->m_hDevice, &byHandleFileInfo);

			((NTFS_FILE_RECORD_INPUT_BUFFER*)abInBuffer)->FileReferenceNumber.QuadPart = GetRandom_FileReferenceNumber();

			SetInParam(dwInBuff, sizeof(NTFS_FILE_RECORD_INPUT_BUFFER));
			SetOutParam(abOutBuffer, dwOutBuff, sizeof(NTFS_FILE_RECORD_OUTPUT_BUFFER));
		}

		break;

    case FSCTL_GET_VOLUME_BITMAP:
		((PSTARTING_LCN_INPUT_BUFFER)abInBuffer)->StartingLcn.QuadPart = rand()%10 ? 0 : DWORD_RAND;
		SetInParam(dwInBuff, sizeof(STARTING_LCN_INPUT_BUFFER));
		SetOutParam(abOutBuffer, dwOutBuff, rand()%100 + sizeof(VOLUME_BITMAP_BUFFER));
		break;

    case FSCTL_GET_RETRIEVAL_POINTERS:
		((STARTING_VCN_INPUT_BUFFER*)abInBuffer)->StartingVcn.QuadPart = rand()%10 ? 0 : DWORD_RAND;
		SetInParam(dwInBuff, sizeof(STARTING_VCN_INPUT_BUFFER));
		SetOutParam(abOutBuffer, dwOutBuff, rand()%100 + sizeof(RETRIEVAL_POINTERS_BUFFER));
		break;

    case FSCTL_MOVE_FILE:
		//
		// todo: need to pass a real handle here, and the device must be a volume
		//
		((MOVE_FILE_DATA*)abInBuffer)->FileHandle = rand()%4 ? m_pDevice->m_hDevice : (HANDLE)(rand()%200);
		((MOVE_FILE_DATA*)abInBuffer)->StartingVcn.QuadPart = rand()%10 ? 0 : DWORD_RAND;
		((MOVE_FILE_DATA*)abInBuffer)->StartingLcn.QuadPart = rand()%10 ? 0 : DWORD_RAND;
		((MOVE_FILE_DATA*)abInBuffer)->ClusterCount = rand()%10 ? 1 : rand();
		SetInParam(dwInBuff, sizeof(MOVE_FILE_DATA));
		break;

    case FSCTL_IS_VOLUME_DIRTY:
		SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG));
		break;

    case FSCTL_GET_HFS_INFORMATION:
		SetInParam(dwInBuff, sizeof(HFS_INFORMATION_BUFFER));
		SetOutParam(abOutBuffer, dwOutBuff, sizeof(HFS_INFORMATION_BUFFER));
		break;

    case FSCTL_ALLOW_EXTENDED_DASD_IO:
		// no params needed
		break;

    case FSCTL_READ_PROPERTY_DATA:
		/*
			PROPERTY_READ_CONTROL PropertyReadControl;
			PropertyReadControl.Op = PRC_READ_ALL;
			*/
		break;

    case FSCTL_WRITE_PROPERTY_DATA:
		break;

    case FSCTL_FIND_FILES_BY_SID:
		{
			typedef struct
			{
				ULONG Restart;
				BYTE  Sid[1024-4];
			} FSCTL_INPUT;
			typedef struct _FILE_NAME_INFORMATION {                     // ntddk
				ULONG FileNameLength;                                   // ntddk
				WCHAR FileName[1];                                      // ntddk
			} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;           // ntddk

			static TCHAR *s_szAccountNames[] = 
			{
				TEXT("Administrator"),
				TEXT("Guest"),
				TEXT("TsInternetUser"),
				TEXT("TERMINAL SERVER USER"),
				TEXT("SYSTEM"),
				TEXT("SERVICE"),
				TEXT("NETWORK"),
				TEXT("INTERACTIVE"),
				TEXT("DIALUP"),
				//TEXT("CREATOR"),LookupAccountName() takes too long
				//TEXT("GROUP"),LookupAccountName() takes too long
				TEXT("CREATOR OWNER"),
				TEXT("BATCH"),
				TEXT("ANONYMOUS LOGON"),
				TEXT("Authenticated Users"),
				TEXT("Everyone")
			};

			//
			// LookupAccountName() is a long call, so don't do it all the time
			//
			DWORD cbNeededSid = 28;
			if (rand()%2)
			{
				TCHAR *szAccountName = s_szAccountNames[rand()%(sizeof(s_szAccountNames)/sizeof(*s_szAccountNames))];
				DWORD cbSid = SIZEOF_INOUTBUFF-sizeof(ULONG);
				cbNeededSid = 0;
				TCHAR szDomainName[128];
				DWORD cbDomainName = sizeof(szDomainName);
				SID_NAME_USE sidNameUse;
				DWORD dwBefore = ::GetTickCount();
				if (!::LookupAccountName(
						NULL,   // system name - local machine
						szAccountName,  // account name
						((FSCTL_INPUT*)abInBuffer)->Sid,               // security identifier
						&cbNeededSid,          // size of security identifier
						szDomainName,      // domain name
						&cbDomainName,   // size of domain name
						&sidNameUse     // SID-type indicator
						))
				{
					//DPF((TEXT("%d - CIoctlFile::PrepareIOCTLParams() LookupAccountName(%s) failed with %d, cbNeededSid=%d\n"), ::GetTickCount()-dwBefore, szAccountName, ::GetLastError(), cbNeededSid));
				}
				else
				{
					DPF((TEXT("%d - CIoctlFile::PrepareIOCTLParams() LookupAccountName(%s) succeeded, szDomainName=%s\n"), ::GetTickCount()-dwBefore, szAccountName, szDomainName));
					_ASSERTE(FALSE);
				}
				_ASSERTE(cbNeededSid <= cbSid);
				if (!::LookupAccountName(
						NULL,   // system name - local machine
						szAccountName,  // account name
						((FSCTL_INPUT*)abInBuffer)->Sid,               // security identifier
						&cbSid,          // size of security identifier
						szDomainName,      // domain name
						&cbDomainName,   // size of domain name
						&sidNameUse     // SID-type indicator
						))
				{
					//DPF((TEXT("%d - CIoctlFile::PrepareIOCTLParams() LookupAccountName(%s) failed with %d\n"), ::GetTickCount()-dwBefore, szAccountName, ::GetLastError()));
				}
				else
				{
					//DPF((TEXT("%d - CIoctlFile::PrepareIOCTLParams() LookupAccountName(%s) succeeded, szDomainName=%s\n"), ::GetTickCount()-dwBefore, szAccountName, szDomainName));
				}
			}//if (rand()%2)

			((FSCTL_INPUT*)abInBuffer)->Restart = rand()%5 ? 0 : rand()%2 ? rand() : DWORD_RAND;
			//
			// NTFS allocates a buffer to copy, so lets give it a huge buff size once in a while
			//
			SetInParam(dwInBuff, rand()%10 ? sizeof(ULONG)+cbNeededSid : DWORD_RAND);
			SetOutParam(abOutBuffer, dwOutBuff, sizeof(FILE_NAME_INFORMATION));
		}
		break;

    case FSCTL_DUMP_PROPERTY_DATA:
		// not implementer in FSDs
		break;

    case FSCTL_SET_OBJECT_ID:
		SetRandom_OBJECT_ID((FILE_OBJECTID_BUFFER*)abInBuffer);
		SetInParam(dwInBuff, sizeof(FILE_OBJECTID_BUFFER));
		break;

    case FSCTL_GET_OBJECT_ID:
		SetOutParam(abOutBuffer, dwOutBuff, sizeof(FILE_OBJECTID_BUFFER));
		break;

    case FSCTL_DELETE_OBJECT_ID:
		SetRandom_OBJECT_ID((FILE_OBJECTID_BUFFER*)abInBuffer);
		SetInParam(dwInBuff, sizeof(FILE_OBJECTID_BUFFER));
		break;

    case FSCTL_SET_REPARSE_POINT:
		((REPARSE_GUID_DATA_BUFFER*)abInBuffer)->ReparseTag = GetRandom_ReparseTag();
		((REPARSE_GUID_DATA_BUFFER*)abInBuffer)->ReparseDataLength = rand()%10 ? 1 : rand();
		((REPARSE_GUID_DATA_BUFFER*)abInBuffer)->ReparseGuid.Data1 = rand()%10 ? 1 : rand();
		((REPARSE_GUID_DATA_BUFFER*)abInBuffer)->GenericReparseBuffer.DataBuffer[0] = rand()%10 ? 13 : rand();
		SetInParam(dwInBuff, sizeof(REPARSE_DATA_BUFFER_HEADER_SIZE)+rand()%MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
		SetOutParam(abOutBuffer, dwOutBuff, 0);
		break;

    case FSCTL_GET_REPARSE_POINT:
		SetInParam(dwInBuff, 0);
		SetOutParam(abOutBuffer, dwOutBuff, MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
		break;

    case FSCTL_DELETE_REPARSE_POINT:
		dwInBuff = rand()%3 ? sizeof(REPARSE_DATA_BUFFER_HEADER_SIZE) : rand()%2 ? sizeof(REPARSE_GUID_DATA_BUFFER_HEADER_SIZE) : rand();
		SetOutParam(abOutBuffer, dwOutBuff, 0);
		break;

    case FSCTL_ENUM_USN_DATA:
		typedef struct _MFT_SEGMENT_REFERENCE {
			ULONG SegmentNumberLowPart;
			USHORT SegmentNumberHighPart;
			USHORT SequenceNumber;
		} FILE_REFERENCE, *PFILE_REFERENCE;

		((MFT_ENUM_DATA*)abInBuffer)->StartFileReferenceNumber = GetRandom_FileReferenceNumber();
		((MFT_ENUM_DATA*)abInBuffer)->LowUsn = GetRandom_USN();
		((MFT_ENUM_DATA*)abInBuffer)->HighUsn = GetRandom_USN();
		SetInParam(dwInBuff, sizeof(MFT_ENUM_DATA));
		SetOutParam(abOutBuffer, dwOutBuff, sizeof(FILE_REFERENCE));
		break;

    case FSCTL_SECURITY_ID_CHECK:
		SetInParam(dwInBuff, rand());
		SetOutParam(abOutBuffer, dwOutBuff, rand());
		break;

    case FSCTL_CREATE_USN_JOURNAL:
		((CREATE_USN_JOURNAL_DATA*)abInBuffer)->MaximumSize = rand()%10 ? 100000 : rand();
		((CREATE_USN_JOURNAL_DATA*)abInBuffer)->AllocationDelta = rand()%10 ? 1000 : rand();
		SetInParam(dwInBuff, sizeof( CREATE_USN_JOURNAL_DATA ));
		SetOutParam(abOutBuffer, dwOutBuff, sizeof( USN )+rand()%100);
		break;

    case FSCTL_READ_USN_JOURNAL:
		((READ_USN_JOURNAL_DATA*)abInBuffer)->StartUsn = GetRandom_USN();
		((READ_USN_JOURNAL_DATA*)abInBuffer)->ReasonMask = rand()%10 ? 0xffffffff : DWORD_RAND;
		((READ_USN_JOURNAL_DATA*)abInBuffer)->ReturnOnlyOnClose = rand()%10 ? 0 : rand();
		((READ_USN_JOURNAL_DATA*)abInBuffer)->Timeout = rand()%10 ? ((LONGLONG)(-100000000)) : ((LONGLONG)((DWORD_RAND << 32) | DWORD_RAND));
		((READ_USN_JOURNAL_DATA*)abInBuffer)->BytesToWaitFor = rand()%10 ? 1 : rand();
		((READ_USN_JOURNAL_DATA*)abInBuffer)->UsnJournalID = rand()%10 ? m_UsnJournalID : ((LONGLONG)((DWORD_RAND << 32) | DWORD_RAND));
		SetInParam(dwInBuff, sizeof( READ_USN_JOURNAL_DATA )+rand()%100);
		SetOutParam(abOutBuffer, dwOutBuff, sizeof( USN_RECORD )+rand()%1000);
		break;

    case FSCTL_SET_OBJECT_ID_EXTENDED:
		SetInParam(dwInBuff, OBJECT_ID_EXT_INFO_LENGTH);
		break;

    case FSCTL_SET_OBJECT_ID_EXTENDED_OBSOLETE:
		//obsolete
		break;

    case FSCTL_CREATE_OR_GET_OBJECT_ID:
		SetOutParam(abOutBuffer, dwOutBuff, sizeof( FILE_OBJECTID_BUFFER ));
		break;

    case FSCTL_SET_SPARSE:
		dwInBuff = rand()%2 ? 0 : rand()%10 ? sizeof( FILE_SET_SPARSE_BUFFER ) :rand();
		((FILE_SET_SPARSE_BUFFER*)abInBuffer)->SetSparse = rand()%10 ? rand() : FALSE;
		break;

    case FSCTL_SET_ZERO_DATA:
		((FILE_ZERO_DATA_INFORMATION*)abInBuffer)->BeyondFinalZero.QuadPart = rand()%10 ? rand() : DWORD_RAND;
		((FILE_ZERO_DATA_INFORMATION*)abInBuffer)->FileOffset.QuadPart = (rand()%2 ? rand() :DWORD_RAND) + ((FILE_ZERO_DATA_INFORMATION*)abInBuffer)->BeyondFinalZero.QuadPart;
		SetInParam(dwInBuff, sizeof( FILE_ZERO_DATA_INFORMATION ));
		break;

    case FSCTL_QUERY_ALLOCATED_RANGES:
		((FILE_ALLOCATED_RANGE_BUFFER*)abInBuffer)->FileOffset.QuadPart = rand()%10 ? rand() : DWORD_RAND;
		((FILE_ALLOCATED_RANGE_BUFFER*)abInBuffer)->Length.QuadPart = rand()%10 ? rand() : DWORD_RAND;
		SetInParam(dwInBuff, sizeof( FILE_ALLOCATED_RANGE_BUFFER ));
		SetOutParam(abOutBuffer, dwOutBuff, sizeof( FILE_ALLOCATED_RANGE_BUFFER ));
		break;

    case FSCTL_ENABLE_UPGRADE:
		//not used
		break;

    case FSCTL_SET_ENCRYPTION:
    case FSCTL_ENCRYPTION_FSCTL_IO:
		{
			//
			// The EFS FSCTL Input data buffer.
			//

			typedef struct _FSCTL_INPUT {

				ULONG   PlainSubCode;
				ULONG   EfsFsCode;
				ULONG   CipherSubCode;
				UCHAR   EfsFsData[1];

			} FSCTL_INPUT, *PFSCTL_INPUT;

			((FSCTL_INPUT*)abInBuffer)->EfsFsCode = GetRandomEfsCode();
			((FSCTL_INPUT*)abInBuffer)->CipherSubCode = GetRandomCipherSubCode();
			((FSCTL_INPUT*)abInBuffer)->PlainSubCode = rand()%10 ? 
				(((FSCTL_INPUT*)abInBuffer)->CipherSubCode & ~EFS_FSCTL_ON_DIR) :
			rand()%2 ? rand()%10 : DWORD_RAND;
			((EFS_KEY*)(((FSCTL_INPUT*)abInBuffer)->EfsFsData))->KeyLength = 
				// cause overflow in : if  ( (InputDataLength < (2 * encLength + 3 * sizeof(ULONG)))
				rand()%2 ? 0x7fffffe8 :
				rand()%2 ? 0x80000000 + rand()%50 :
				rand()%2 ? 0x7fffff00 + rand()%0x100 :
				rand()%2 ? 0xffffffe0 + rand()%0x20 :
				rand()%1000;
			((EFS_KEY*)(((FSCTL_INPUT*)abInBuffer)->EfsFsData))->Algorithm = GetRandom_Algorithm();
			DWORD dwOutBuffLen = rand();
			FillBufferWithRandomData(((FSCTL_INPUT*)abInBuffer)->EfsFsData, dwOutBuffLen);
			SetInParam(dwInBuff, sizeof( FSCTL_INPUT )+rand()%20000);
			SetOutParam(abOutBuffer, dwOutBuff, rand()%1000+sizeof( DECRYPTION_STATUS_BUFFER ));

		}
		break;

    case FSCTL_WRITE_RAW_ENCRYPTED:
		((ENCRYPTED_DATA_INFO*)abInBuffer)->StartingFileOffset = rand()%2 ? 0: rand()%2 ? rand() : DWORD_RAND;
		((ENCRYPTED_DATA_INFO*)abInBuffer)->OutputBufferOffset = rand()%2 ? 0: rand()%2 ? rand() : DWORD_RAND;
		((ENCRYPTED_DATA_INFO*)abInBuffer)->BytesWithinFileSize = rand()%2 ? 0: rand()%2 ? rand() : DWORD_RAND;
		((ENCRYPTED_DATA_INFO*)abInBuffer)->BytesWithinValidDataLength = rand()%2 ? 0: rand()%2 ? rand() : DWORD_RAND;
		((ENCRYPTED_DATA_INFO*)abInBuffer)->CompressionFormat = GetRandomCompressionFormat();
		((ENCRYPTED_DATA_INFO*)abInBuffer)->DataUnitShift = rand()%2 ? 0: rand()%2 ? rand() : rand()%16;
#define NTFS_CHUNK_SHIFT                 (12)
		((ENCRYPTED_DATA_INFO*)abInBuffer)->ChunkShift = rand()%2 ? NTFS_CHUNK_SHIFT : rand()%2 ? 0: rand()%2 ? rand() : rand()%16;
		((ENCRYPTED_DATA_INFO*)abInBuffer)->ClusterShift = rand()%2 ? 0: rand()%2 ? rand() : rand()%16;
		((ENCRYPTED_DATA_INFO*)abInBuffer)->EncryptionFormat = rand()%10 ? ENCRYPTION_FORMAT_DEFAULT : rand();
		((ENCRYPTED_DATA_INFO*)abInBuffer)->NumberOfDataBlocks = rand()%2 ? 0: rand()%2 ? rand() : rand()%16;
		//((ENCRYPTED_DATA_INFO*)abInBuffer)->DataBlockSize[] = xxx;
		SetInParam(dwInBuff, sizeof( ENCRYPTED_DATA_INFO )+rand()%20000);
		break;

    case FSCTL_READ_RAW_ENCRYPTED:
		((REQUEST_RAW_ENCRYPTED_DATA*)abInBuffer)->FileOffset = rand()%2 ? 0: rand()%2 ? rand() : DWORD_RAND;
		((REQUEST_RAW_ENCRYPTED_DATA*)abInBuffer)->Length = rand()%2 ? 0: rand()%2 ? rand() : DWORD_RAND;
		SetInParam(dwInBuff, sizeof( REQUEST_RAW_ENCRYPTED_DATA ));
		SetOutParam(abOutBuffer, dwOutBuff, sizeof( ENCRYPTED_DATA_INFO )+rand()%20000);
		break;

    case FSCTL_READ_FILE_USN_DATA:
		SetOutParam(abOutBuffer, dwOutBuff, sizeof(USN_RECORD) + rand()%1000);
		break;

    case FSCTL_WRITE_USN_CLOSE_RECORD:
		SetOutParam(abOutBuffer, dwOutBuff, sizeof(USN));
		break;

    case FSCTL_EXTEND_VOLUME:
		*((LONGLONG*)abInBuffer) = (rand()%50 == 0) ? 0: rand()%2 ? rand() : DWORD_RAND;
		SetInParam(dwInBuff, sizeof( LONGLONG ));
		break;

    case FSCTL_QUERY_USN_JOURNAL:
		SetOutParam(abOutBuffer, dwOutBuff, sizeof(USN_JOURNAL_DATA));
		break;

    case FSCTL_DELETE_USN_JOURNAL:
		((DELETE_USN_JOURNAL_DATA*)abInBuffer)->UsnJournalID = (rand()%10 == 0) ? m_UsnJournalID : rand()%2 ? rand() : DWORD_RAND;
		((DELETE_USN_JOURNAL_DATA*)abInBuffer)->DeleteFlags = rand()%2 ? USN_DELETE_FLAG_DELETE : rand()%10 ? USN_DELETE_FLAG_NOTIFY : rand();
		SetInParam(dwInBuff, sizeof( DELETE_USN_JOURNAL_DATA ));
		break;

    case FSCTL_MARK_HANDLE:
		((MARK_HANDLE_INFO*)abInBuffer)->UsnSourceInfo = GetRandomUsnSource();
		((MARK_HANDLE_INFO*)abInBuffer)->VolumeHandle = GetRandom_VolumeHandle();
		// 0 is expected, otherwise the request is rejected
		((MARK_HANDLE_INFO*)abInBuffer)->HandleInfo = rand()%10 ? 0 : rand()%2 ? rand() : DWORD_RAND;
		SetInParam(dwInBuff, sizeof( MARK_HANDLE_INFO ));
		SetOutParam(abOutBuffer, dwOutBuff, sizeof(MARK_HANDLE_INFO));
		break;

    case FSCTL_SIS_COPYFILE:
		//TODO: look in \\index1\src\nt\private\windows\setup\textmode\kernel\spcopy.c
		//?
		break;

    case FSCTL_SIS_LINK_FILES:
		//?
		break;

    case FSCTL_HSM_MSG:
		//TODO: look in \\index1
		break;

    case FSCTL_NSS_CONTROL:
		//TODO: look in \\index1
		break;

    case FSCTL_HSM_DATA:
		//TODO: look in \\index1
		break;

    case FSCTL_RECALL_FILE:
		//TODO: look in \\index1
		break;

    case FSCTL_NSS_RCONTROL:
		//TODO: look in \\index1
		break;

	default: 
		_tprintf(TEXT("PrepareIOCTLParams() 0x%08X is an unexpected IOCTL\n"), dwIOCTL);
		_ASSERTE(FALSE);
		CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
	}
}


BOOL CIoctlFile::FindValidIOCTLs(CDevice *pDevice)
{
    BOOL bRet = TRUE;
    DPF((TEXT("FindValidIOCTLs() %s is known, will use known IOCTLs\n"), pDevice->GetDeviceName()));

	/*
	i do not remember why i disabled them, so i do not
	if (m_fFILE_FLAG_NO_BUFFERING)
	{
		m_nWriteFileProbability = 0;
		m_nReadFileProbability = 0;
	}
	*/

    AddIOCTL(pDevice, FSCTL_REQUEST_OPLOCK_LEVEL_1);
    AddIOCTL(pDevice, FSCTL_REQUEST_OPLOCK_LEVEL_2);
    AddIOCTL(pDevice, FSCTL_REQUEST_BATCH_OPLOCK);
    AddIOCTL(pDevice, FSCTL_OPLOCK_BREAK_ACKNOWLEDGE);
    AddIOCTL(pDevice, FSCTL_OPBATCH_ACK_CLOSE_PENDING);
    AddIOCTL(pDevice, FSCTL_OPLOCK_BREAK_NOTIFY);
    AddIOCTL(pDevice, FSCTL_LOCK_VOLUME);
    AddIOCTL(pDevice, FSCTL_UNLOCK_VOLUME);
    AddIOCTL(pDevice, FSCTL_DISMOUNT_VOLUME);
    AddIOCTL(pDevice, FSCTL_IS_VOLUME_MOUNTED);
    AddIOCTL(pDevice, FSCTL_IS_PATHNAME_VALID);
    AddIOCTL(pDevice, FSCTL_MARK_VOLUME_DIRTY);
    AddIOCTL(pDevice, FSCTL_QUERY_RETRIEVAL_POINTERS);
    AddIOCTL(pDevice, FSCTL_GET_COMPRESSION);
    AddIOCTL(pDevice, FSCTL_SET_COMPRESSION);
    AddIOCTL(pDevice, FSCTL_MARK_AS_SYSTEM_HIVE);
    AddIOCTL(pDevice, FSCTL_OPLOCK_BREAK_ACK_NO_2);
    AddIOCTL(pDevice, FSCTL_INVALIDATE_VOLUMES);
    AddIOCTL(pDevice, FSCTL_QUERY_FAT_BPB);
    AddIOCTL(pDevice, FSCTL_REQUEST_FILTER_OPLOCK);
    AddIOCTL(pDevice, FSCTL_FILESYSTEM_GET_STATISTICS);
    AddIOCTL(pDevice, FSCTL_GET_NTFS_VOLUME_DATA);
    AddIOCTL(pDevice, FSCTL_GET_NTFS_FILE_RECORD);
    AddIOCTL(pDevice, FSCTL_GET_VOLUME_BITMAP);
    AddIOCTL(pDevice, FSCTL_GET_RETRIEVAL_POINTERS);
    AddIOCTL(pDevice, FSCTL_MOVE_FILE);
    AddIOCTL(pDevice, FSCTL_IS_VOLUME_DIRTY);
    AddIOCTL(pDevice, FSCTL_GET_HFS_INFORMATION);
    AddIOCTL(pDevice, FSCTL_ALLOW_EXTENDED_DASD_IO);
    AddIOCTL(pDevice, FSCTL_READ_PROPERTY_DATA);
    AddIOCTL(pDevice, FSCTL_WRITE_PROPERTY_DATA);
    AddIOCTL(pDevice, FSCTL_FIND_FILES_BY_SID);
    AddIOCTL(pDevice, FSCTL_DUMP_PROPERTY_DATA);
    AddIOCTL(pDevice, FSCTL_SET_OBJECT_ID);
    AddIOCTL(pDevice, FSCTL_GET_OBJECT_ID);
    AddIOCTL(pDevice, FSCTL_DELETE_OBJECT_ID);
    AddIOCTL(pDevice, FSCTL_SET_REPARSE_POINT);
    AddIOCTL(pDevice, FSCTL_GET_REPARSE_POINT);
    AddIOCTL(pDevice, FSCTL_DELETE_REPARSE_POINT);
    AddIOCTL(pDevice, FSCTL_ENUM_USN_DATA);
    AddIOCTL(pDevice, FSCTL_SECURITY_ID_CHECK);
    AddIOCTL(pDevice, FSCTL_CREATE_USN_JOURNAL);
    AddIOCTL(pDevice, FSCTL_READ_USN_JOURNAL);
    AddIOCTL(pDevice, FSCTL_SET_OBJECT_ID_EXTENDED);
    AddIOCTL(pDevice, FSCTL_SET_OBJECT_ID_EXTENDED_OBSOLETE);
    AddIOCTL(pDevice, FSCTL_CREATE_OR_GET_OBJECT_ID);
    AddIOCTL(pDevice, FSCTL_SET_SPARSE);
    AddIOCTL(pDevice, FSCTL_SET_ZERO_DATA);
    AddIOCTL(pDevice, FSCTL_QUERY_ALLOCATED_RANGES);
    AddIOCTL(pDevice, FSCTL_ENABLE_UPGRADE);
    AddIOCTL(pDevice, FSCTL_SET_ENCRYPTION);
//printf("FSCTL_ENCRYPTION_FSCTL_IO=%d\n", m_pDevice->m_iMaxFreeLegalIOCTL);
    AddIOCTL(pDevice, FSCTL_ENCRYPTION_FSCTL_IO);
    AddIOCTL(pDevice, FSCTL_WRITE_RAW_ENCRYPTED);
    AddIOCTL(pDevice, FSCTL_READ_RAW_ENCRYPTED);
    AddIOCTL(pDevice, FSCTL_READ_FILE_USN_DATA);
    AddIOCTL(pDevice, FSCTL_WRITE_USN_CLOSE_RECORD);
    AddIOCTL(pDevice, FSCTL_EXTEND_VOLUME);
    AddIOCTL(pDevice, FSCTL_QUERY_USN_JOURNAL);
    AddIOCTL(pDevice, FSCTL_DELETE_USN_JOURNAL);
    AddIOCTL(pDevice, FSCTL_MARK_HANDLE);
    AddIOCTL(pDevice, FSCTL_SIS_COPYFILE);
    AddIOCTL(pDevice, FSCTL_SIS_LINK_FILES);
    AddIOCTL(pDevice, FSCTL_HSM_MSG);
    AddIOCTL(pDevice, FSCTL_NSS_CONTROL);
    AddIOCTL(pDevice, FSCTL_HSM_DATA);
    AddIOCTL(pDevice, FSCTL_RECALL_FILE);
    AddIOCTL(pDevice, FSCTL_NSS_RCONTROL);
/*
    //
    // from floppy:
    //
    AddIOCTL(pDevice, 0x00070000);
    AddIOCTL(pDevice, 0x00070004);
    AddIOCTL(pDevice, 0x00070c00);
    AddIOCTL(pDevice, 0x00074800);
    AddIOCTL(pDevice, 0x002d0c00);
    AddIOCTL(pDevice, 0x002d4800);
    AddIOCTL(pDevice, 0x004d0000);
    AddIOCTL(pDevice, 0x004d0008);
*/
    return TRUE;
}




DWORD CIoctlFile::GetRandomPurgeCommParams()
{
	DWORD deRetval = 0;
	if (0 == rand()%6) deRetval = deRetval | PURGE_TXABORT;
	if (0 == rand()%6) deRetval = deRetval | PURGE_RXABORT;
	if (0 == rand()%6) deRetval = deRetval | PURGE_TXCLEAR;
	if (0 == rand()%6) deRetval = deRetval | PURGE_RXCLEAR;

	return deRetval;
}

DWORD CIoctlFile::GetRandomLockFlags()
{
	DWORD deRetval = 0;
	if (0 == rand()%3) deRetval = deRetval | LOCKFILE_FAIL_IMMEDIATELY;
	if (0 == rand()%3) deRetval = deRetval | LOCKFILE_EXCLUSIVE_LOCK;

	return deRetval;
}

#define LOCK_SIZES_ARRAY_SIZE 128
static DWORD s_adwLockLow[LOCK_SIZES_ARRAY_SIZE];
static DWORD s_adwLockHigh[LOCK_SIZES_ARRAY_SIZE];
static bool s_afValid[LOCK_SIZES_ARRAY_SIZE];
static bool s_fFirstTime = true;

void CIoctlFile::GetRandomLockRange(DWORD *pdwLockLow, DWORD *pdwLockHigh)
{
	//
	// i do not initialize the out params, because i do not care if garbage comes out
	//
	if (s_fFirstTime)
	{
		ZeroMemory(s_adwLockLow, sizeof(s_adwLockLow));
		ZeroMemory(s_adwLockHigh, sizeof(s_adwLockLow));

		for (int i = 0 ; i < LOCK_SIZES_ARRAY_SIZE; i++)
		{
			s_afValid[i] = false;
		}
		s_fFirstTime = false;
	}

	//
	// try to locate an empty entry, and populate it
	//
	for (int i = 0; i < LOCK_SIZES_ARRAY_SIZE; i++)
	{
		if (!s_afValid[i])
		{
			//
			// this pair may be invalid, but i do not care
			//
			*pdwLockLow = s_adwLockLow[i] = rand();
			*pdwLockHigh = s_adwLockHigh[i] = rand()%2 ? DWORD_RAND : 10*rand();
			//
			// the lock may fail, yet we keep it, and hope that the arrays will be also
			// populated with valid pairs
			//
			s_afValid[i] = true;
			return;
		}
	}

	//
	// all the entries are ocupied, so let return an invalid pair
	// specificall the high part lower than low part
	//
	*pdwLockHigh = 10*rand();
	*pdwLockLow = 1 + rand() + *pdwLockHigh;
}


void CIoctlFile::GetRandomUnLockRange(DWORD *pdwLockLow, DWORD *pdwLockHigh)
{
	//
	// i do not initialize the out params, because i do not care if garbage comes out
	//
	if (s_fFirstTime)
	{
		ZeroMemory(s_adwLockLow, sizeof(s_adwLockLow));
		ZeroMemory(s_adwLockHigh, sizeof(s_adwLockLow));

		for (int i = 0 ; i < LOCK_SIZES_ARRAY_SIZE; i++)
		{
			s_afValid[i] = false;
		}
		s_fFirstTime = false;
	}

	//
	// try to randomly find a valid pair
	//
	for (int i = 0; i < LOCK_SIZES_ARRAY_SIZE; i++)
	{
		int nRandomValidIndex = rand()%LOCK_SIZES_ARRAY_SIZE;
		if (s_afValid[nRandomValidIndex])
		{
			*pdwLockLow = s_adwLockLow[nRandomValidIndex];
			*pdwLockHigh = s_adwLockHigh[nRandomValidIndex];
			s_afValid[nRandomValidIndex] = false;
			return;
		}
	}

	//
	// could not find randomly, so lets traverse the whole array
	//
	for (i = 0; i < LOCK_SIZES_ARRAY_SIZE; i++)
	{
		if (s_afValid[i])
		{
			*pdwLockLow = s_adwLockLow[i];
			*pdwLockHigh = s_adwLockHigh[i];
			s_afValid[i] = false;
			return;
		}
	}

	//
	// there are no locked ranged, so lets return random stuff, and we will just fail on them
	//
	*pdwLockLow = rand();
	*pdwLockHigh = rand()%2 ? DWORD_RAND : 10*rand();
}

DWORD CIoctlFile::GetMoveMethod()
{
	if (0 == rand()%4) return FILE_BEGIN;
	if (0 == rand()%3) return FILE_CURRENT;
	if (0 == rand()%2) return FILE_END;
	return rand();
}

ULONG CIoctlFile::GetRandomCipherSubCode()
{
	if (rand()%2)
	{
		return (DWORD_RAND | SET_EFS_KEYBLOB);
	}
	if (rand()%2)
	{
		return (DWORD_RAND | WRITE_EFS_ATTRIBUTE);
	}
	return (DWORD_RAND);

}

DWORD CIoctlFile::GetRandomEfsCode()
{
	switch(rand()%8)
	{
	case 0:
		return EFS_SET_ATTRIBUTE;
	case 1:
		return EFS_SET_ENCRYPT;
	case 2:
		return EFS_GET_ATTRIBUTE;
	case 3:
		return EFS_DEL_ATTRIBUTE;
	case 4:
		return EFS_ENCRYPT_DONE;
	case 5:
		return EFS_DECRYPT_BEGIN;
	case 6:
		return EFS_OVERWRITE_ATTRIBUTE;
	default:
		return (rand());
	}
	return rand();
}


WORD CIoctlFile::GetRandomCompressionFormat()
{
	switch(rand()%7)
	{
	case 0:
		return COMPRESSION_FORMAT_NONE;
	case 1:
		return COMPRESSION_FORMAT_DEFAULT;
	case 2:
		return COMPRESSION_FORMAT_LZNT1;
	case 3:
		return COMPRESSION_ENGINE_STANDARD;
	case 4:
		return COMPRESSION_ENGINE_MAXIMUM;
	case 5:
		return COMPRESSION_ENGINE_HIBER;
	default:
		return rand();
	}
	return rand();
}

DWORD CIoctlFile::GetRandomUsnSource()
{
	DWORD dwRet = 0;
	if (0 == rand()%4) dwRet |= USN_SOURCE_DATA_MANAGEMENT;
	if (0 == rand()%4) dwRet |= USN_SOURCE_AUXILIARY_DATA;
	if (0 == rand()%4) dwRet |= USN_SOURCE_REPLICATION_MANAGEMENT;
	if (0 == rand()%20) dwRet |= 0x00000008;//illegal

	return dwRet;
}

ULONG CIoctlFile::GetRandom_EncryptionOperation()
{
	if (0 == rand()%100) return rand();
	return (rand()%(MAXIMUM_ENCRYPTION_VALUE+1));
}

USHORT CIoctlFile::GetRandom_CompressionState()
{
	if (rand()%2) return (COMPRESSION_FORMAT_DEFAULT);
	if (rand()%10) return (COMPRESSION_FORMAT_LZNT1);
	if (rand()%2) return (COMPRESSION_FORMAT_NONE);
	if (rand()%2) return (COMPRESSION_ENGINE_STANDARD);
	if (rand()%2) return (COMPRESSION_ENGINE_MAXIMUM);
	return (COMPRESSION_ENGINE_HIBER);
}


void CIoctlFile::SetRandom_OBJECT_ID(FILE_OBJECTID_BUFFER *pFILE_OBJECTID_BUFFER)
{
	if (rand()%10) 
	{
		*pFILE_OBJECTID_BUFFER = m_FILE_OBJECTID_BUFFER;
		if (0 == rand()%10) 
		{
			//
			// change 1 byte
			//
			pFILE_OBJECTID_BUFFER->ObjectId[rand()%(ARRSIZE(pFILE_OBJECTID_BUFFER->ObjectId))] = rand();
		}
		return;
	}

	//
	// less frequently, fill with random values, of which the hardcoded one are taken from the sources
	// from somewhere (i fogot from where...)
	//
	pFILE_OBJECTID_BUFFER->ObjectId[0] = rand()%100 ? 0x07 : rand();
	pFILE_OBJECTID_BUFFER->ObjectId[1] = rand()%100 ? 0xc3 : rand();
	pFILE_OBJECTID_BUFFER->ObjectId[2] = rand()%100 ? 0x68 : rand();
	pFILE_OBJECTID_BUFFER->ObjectId[3] = rand()%100 ? 0xa1 : rand();
	pFILE_OBJECTID_BUFFER->ObjectId[4] = rand()%100 ? 0x6b : rand();
	pFILE_OBJECTID_BUFFER->ObjectId[5] = rand()%100 ? 0x30 : rand();
	pFILE_OBJECTID_BUFFER->ObjectId[6] = rand()%100 ? 0xd1 : rand();
	pFILE_OBJECTID_BUFFER->ObjectId[7] = rand()%100 ? 0x11 : rand();
	pFILE_OBJECTID_BUFFER->ObjectId[8] = rand()%100 ? 0xa7 : rand();
	pFILE_OBJECTID_BUFFER->ObjectId[9] = rand()%100 ? 0x41 : rand();
}

DWORD CIoctlFile::GetRandom_ReparseTag()
{
	switch(rand()%9)
	{
	case 0: return (IO_REPARSE_TAG_RESERVED_ZERO);
	case 1: return (IO_REPARSE_TAG_RESERVED_ONE);
	case 2: return (IO_REPARSE_TAG_MOUNT_POINT);
	case 3: return (IO_REPARSE_TAG_HSM);
	case 4: return (IO_REPARSE_TAG_SIS);
	case 5: return (((rand()%8)<<29) | (rand()%20));
	case 6: return (((rand()%8)<<29) | rand());
	case 7: return ((*((REPARSE_DATA_BUFFER*)(&m_REPARSE_DATA_BUFFER))).ReparseTag);
	default: return (DWORD_RAND);
	}
	
	rand()%10 ? 0xBBB : rand();
}

void CIoctlFile::Add_FileReferenceNumber(DWORDLONG *pFileReferenceNumber)
{
	m_liFileReferenceNumber[rand()%MAX_NUM_OF_REMEMBERED_ITEMS] = *pFileReferenceNumber;
}


LONGLONG CIoctlFile::GetRandom_FileReferenceNumber()
{
	if (rand()%10) return m_liFileReferenceNumber[rand()%MAX_NUM_OF_REMEMBERED_ITEMS];
	return DWORD_RAND;
}

void CIoctlFile::Add_USN_RECORD(USN_RECORD *pUSN_RECORD)
{
	m_USN_RECORD[rand()%MAX_NUM_OF_REMEMBERED_ITEMS] = *pUSN_RECORD;
	Add_FileReferenceNumber(&pUSN_RECORD->FileReferenceNumber);
	Add_USN(&pUSN_RECORD->Usn);
}

void CIoctlFile::Add_USN(USN *pUSN)
{
	m_USN[rand()%MAX_NUM_OF_REMEMBERED_ITEMS] = *pUSN;
}

USN CIoctlFile::GetRandom_USN()
{
	if (0 == rand()%20) return (DWORD_RAND);
	return (m_USN[rand()%MAX_NUM_OF_REMEMBERED_ITEMS]);
}

ULONG CIoctlFile::GetRandom_Algorithm()
{
	switch(rand()%36)
	{
	case 0: return (CALG_MD2);
	case 1: return (CALG_MD4);
	case 2: return (CALG_MD5);
	case 3: return (CALG_SHA);
	case 4: return (CALG_SHA1);
	case 5: return (CALG_MAC);
	case 6: return (CALG_RSA_SIGN);
	case 7: return (CALG_DSS_SIGN);
	case 8: return (CALG_RSA_KEYX);
	case 9: return (CALG_DES);
	case 10: return (CALG_3DES_112);
	case 11: return (CALG_3DES);
	case 12: return (CALG_DESX);
	case 13: return (CALG_RC2);
	case 14: return (CALG_RC4);
	case 15: return (CALG_SEAL);
	case 16: return (CALG_DH_SF);
	case 17: return (CALG_DH_EPHEM);
	case 18: return (CALG_AGREEDKEY_ANY);
	case 19: return (CALG_KEA_KEYX);
	case 20: return (CALG_HUGHES_MD5);
	case 21: return (CALG_SKIPJACK);
	case 22: return (CALG_TEK);
	case 23: return (CALG_CYLINK_MEK);
	case 24: return (CALG_SSL3_SHAMD5);
	case 25: return (CALG_SSL3_MASTER);
	case 26: return (CALG_SCHANNEL_MASTER_HASH);
	case 27: return (CALG_SCHANNEL_MAC_KEY);
	case 28: return (CALG_SCHANNEL_ENC_KEY);
	case 29: return (CALG_PCT1_MASTER);
	case 30: return (CALG_SSL2_MASTER);
	case 31: return (CALG_TLS1_MASTER);
	case 32: return (CALG_RC5);
	case 33: return (CALG_HMAC);
	case 34: return (CALG_TLS1PRF);
	default: return (DWORD_RAND);
	}
}

HANDLE CIoctlFile::GetRandom_VolumeHandle()
{
	return (HANDLE)(rand()%2 ? rand()%200 : rand());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\fileioctl.h ===
#ifndef __FILE_IOCTL_H
#define __FILE_IOCTL_H

#include "container.h"
//#include "IOCTL.h"


class CIoctlFile : public CIoctl
{
public:
    CIoctlFile(CDevice *pDevice);

    virtual ~CIoctlFile();


    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

	virtual HANDLE CreateDevice(CDevice *pDevice);

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	//
	// override this method, if you wish to randomly call any API
	// usually you will call API relevant to your device, but you can call whatever you like
	//
	virtual void CallRandomWin32API(LPOVERLAPPED pOL);


protected:
	HANDLE CreateAutoDeleteUniqueFile();
	CContainer<HANDLE> m_hContainer;

private:
	//
	// WriteFileGather() and ReadFileScatter() require the file to be opened
	// with FILE_FLAG_NO_BUFFERING
	//
	bool m_fFILE_FLAG_NO_BUFFERING;

	static bool sm_fFirstTime;
	static DWORD GetRandomPurgeCommParams();
	static DWORD GetRandomLockFlags();
	static void GetRandomLockRange(DWORD *pdwLockLow, DWORD *pdwLockHigh);
	static void GetRandomUnLockRange(DWORD *pdwLockLow, DWORD *pdwLockHigh);
	static DWORD GetMoveMethod();
#define DIMOFSEGMENTEDARRAY 128
	static FILE_SEGMENT_ELEMENT sm_aSegmentArray[DIMOFSEGMENTEDARRAY][DIMOFSEGMENTEDARRAY];
	static SYSTEM_INFO sm_SystemInfo;

	ULONG GetRandomCipherSubCode();
	DWORD GetRandomEfsCode();
	WORD GetRandomCompressionFormat();
	DWORD GetRandomUsnSource();
	ULONG GetRandom_EncryptionOperation();
	static USHORT GetRandom_CompressionState();
	void SetRandom_OBJECT_ID(FILE_OBJECTID_BUFFER *pFILE_OBJECTID_BUFFER);
	DWORD GetRandom_ReparseTag();


	DWORDLONG m_UsnJournalID;
	FILE_OBJECTID_BUFFER m_FILE_OBJECTID_BUFFER;
	BYTE m_REPARSE_DATA_BUFFER[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];
	NTFS_VOLUME_DATA_BUFFER m_NTFS_VOLUME_DATA_BUFFER;
	LONGLONG m_liFileReferenceNumber[MAX_NUM_OF_REMEMBERED_ITEMS];
	void Add_FileReferenceNumber(DWORDLONG *pFileReferenceNumber);
	LARGE_INTEGER Add_FileReferenceNumber();
	LONGLONG GetRandom_FileReferenceNumber();
	USN_RECORD m_USN_RECORD[MAX_NUM_OF_REMEMBERED_ITEMS];
	USN m_USN[MAX_NUM_OF_REMEMBERED_ITEMS];
	void Add_USN_RECORD(USN_RECORD *pUSN_RECORD);
	void Add_USN(USN *pUSN);
	USN GetRandom_USN();
	static ULONG GetRandom_Algorithm();
	HANDLE GetRandom_VolumeHandle();
};



//#include <ntioapi.h>
#define FSCTL_REQUEST_OPLOCK_LEVEL_1    CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  0, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_REQUEST_OPLOCK_LEVEL_2    CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_REQUEST_BATCH_OPLOCK      CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_OPLOCK_BREAK_ACKNOWLEDGE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  3, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_OPBATCH_ACK_CLOSE_PENDING CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  4, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_OPLOCK_BREAK_NOTIFY       CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  5, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_LOCK_VOLUME               CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  6, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_UNLOCK_VOLUME             CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DISMOUNT_VOLUME           CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  8, METHOD_BUFFERED, FILE_ANY_ACCESS)
// decommissioned fsctl value                                              9
#define FSCTL_IS_VOLUME_MOUNTED         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_IS_PATHNAME_VALID         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 11, METHOD_BUFFERED, FILE_ANY_ACCESS) // PATHNAME_BUFFER,
#define FSCTL_MARK_VOLUME_DIRTY         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
// decommissioned fsctl value                                             13
#define FSCTL_QUERY_RETRIEVAL_POINTERS  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 14,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_GET_COMPRESSION           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SET_COMPRESSION           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 16, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA)
// decommissioned fsctl value                                             17
// decommissioned fsctl value                                             18
#define FSCTL_MARK_AS_SYSTEM_HIVE       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 19,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_OPLOCK_BREAK_ACK_NO_2     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 20, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_INVALIDATE_VOLUMES        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 21, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_QUERY_FAT_BPB             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 22, METHOD_BUFFERED, FILE_ANY_ACCESS) // FSCTL_QUERY_FAT_BPB_BUFFER
#define FSCTL_REQUEST_FILTER_OPLOCK     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 23, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_FILESYSTEM_GET_STATISTICS CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 24, METHOD_BUFFERED, FILE_ANY_ACCESS) // FILESYSTEM_STATISTICS
#if(_WIN32_WINNT >= 0x0400)
#define FSCTL_GET_NTFS_VOLUME_DATA      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 25, METHOD_BUFFERED, FILE_ANY_ACCESS) // NTFS_VOLUME_DATA_BUFFER
#define FSCTL_GET_NTFS_FILE_RECORD      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 26, METHOD_BUFFERED, FILE_ANY_ACCESS) // NTFS_FILE_RECORD_INPUT_BUFFER, NTFS_FILE_RECORD_OUTPUT_BUFFER
#define FSCTL_GET_VOLUME_BITMAP         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 27,  METHOD_NEITHER, FILE_ANY_ACCESS) // STARTING_LCN_INPUT_BUFFER, VOLUME_BITMAP_BUFFER
#define FSCTL_GET_RETRIEVAL_POINTERS    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 28,  METHOD_NEITHER, FILE_ANY_ACCESS) // STARTING_VCN_INPUT_BUFFER, RETRIEVAL_POINTERS_BUFFER
#define FSCTL_MOVE_FILE                 CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 29, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // MOVE_FILE_DATA,
#define FSCTL_IS_VOLUME_DIRTY           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 30, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_GET_HFS_INFORMATION       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 31, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_ALLOW_EXTENDED_DASD_IO    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 32, METHOD_NEITHER,  FILE_ANY_ACCESS)
#endif /* _WIN32_WINNT >= 0x0400 */

#if(_WIN32_WINNT >= 0x0500)
#define FSCTL_READ_PROPERTY_DATA        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 33, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_WRITE_PROPERTY_DATA       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 34, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_FIND_FILES_BY_SID         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 35, METHOD_NEITHER, FILE_ANY_ACCESS)
// decommissioned fsctl value                                             36
#define FSCTL_DUMP_PROPERTY_DATA        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 37,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_SET_OBJECT_ID             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 38, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // FILE_OBJECTID_BUFFER
#define FSCTL_GET_OBJECT_ID             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 39, METHOD_BUFFERED, FILE_ANY_ACCESS) // FILE_OBJECTID_BUFFER
#define FSCTL_DELETE_OBJECT_ID          CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 40, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_SET_REPARSE_POINT         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 41, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // REPARSE_DATA_BUFFER,
#define FSCTL_GET_REPARSE_POINT         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 42, METHOD_BUFFERED, FILE_ANY_ACCESS) // REPARSE_DATA_BUFFER
#define FSCTL_DELETE_REPARSE_POINT      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 43, METHOD_BUFFERED, FILE_SPECIAL_ACCESS) // REPARSE_DATA_BUFFER,
#define FSCTL_ENUM_USN_DATA             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 44,  METHOD_NEITHER, FILE_ANY_ACCESS) // MFT_ENUM_DATA,
#define FSCTL_SECURITY_ID_CHECK         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 45,  METHOD_NEITHER, FILE_READ_DATA)  // BULK_SECURITY_TEST_DATA,
#define FSCTL_READ_USN_JOURNAL          CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 46,  METHOD_NEITHER, FILE_ANY_ACCESS) // READ_USN_JOURNAL_DATA, USN
#define FSCTL_SET_OBJECT_ID_EXTENDED    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 47, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_SET_OBJECT_ID_EXTENDED_OBSOLETE    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 47, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_CREATE_OR_GET_OBJECT_ID   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 48, METHOD_BUFFERED, FILE_ANY_ACCESS) // FILE_OBJECTID_BUFFER
#define FSCTL_SET_SPARSE                CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 49, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_SET_ZERO_DATA             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 50, METHOD_BUFFERED, FILE_WRITE_DATA) // FILE_ZERO_DATA_INFORMATION,
#define FSCTL_QUERY_ALLOCATED_RANGES    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 51,  METHOD_NEITHER, FILE_READ_DATA)  // FILE_ALLOCATED_RANGE_BUFFER, FILE_ALLOCATED_RANGE_BUFFER
#define FSCTL_ENABLE_UPGRADE            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 52, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_SET_ENCRYPTION            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 53,  METHOD_NEITHER, FILE_ANY_ACCESS) // ENCRYPTION_BUFFER, DECRYPTION_STATUS_BUFFER
#define FSCTL_ENCRYPTION_FSCTL_IO       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 54,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_WRITE_RAW_ENCRYPTED       CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 55,  METHOD_NEITHER, FILE_SPECIAL_ACCESS) // ENCRYPTED_DATA_INFO,
#define FSCTL_READ_RAW_ENCRYPTED        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 56,  METHOD_NEITHER, FILE_SPECIAL_ACCESS) // REQUEST_RAW_ENCRYPTED_DATA, ENCRYPTED_DATA_INFO
#define FSCTL_CREATE_USN_JOURNAL        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 57,  METHOD_NEITHER, FILE_ANY_ACCESS) // CREATE_USN_JOURNAL_DATA,
#define FSCTL_READ_FILE_USN_DATA        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 58,  METHOD_NEITHER, FILE_ANY_ACCESS) // Read the Usn Record for a file
#define FSCTL_WRITE_USN_CLOSE_RECORD    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 59,  METHOD_NEITHER, FILE_ANY_ACCESS) // Generate Close Usn Record
#define FSCTL_EXTEND_VOLUME             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 60, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_QUERY_USN_JOURNAL         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 61, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DELETE_USN_JOURNAL        CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 62, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_MARK_HANDLE               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 63, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SIS_COPYFILE              CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 64, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SIS_LINK_FILES            CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 65, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA)
#define FSCTL_HSM_MSG                   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 66, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA)
#define FSCTL_NSS_CONTROL               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 67, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_HSM_DATA                  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 68, METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA)
#define FSCTL_RECALL_FILE               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 69, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_NSS_RCONTROL              CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 70, METHOD_BUFFERED, FILE_READ_DATA)
#endif /* _WIN32_WINNT >= 0x0500 */
// end //#include <ntioapi.h>


#endif //__FILE_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\fswrapioctl.h ===
#ifndef __FSWRAP_IOCTL_H
#define __FSWRAP_IOCTL_H

//#include "NtNativeIOCTL.h"


class CIoctlFsWrap : public CIoctlNtNative
{
public:
    CIoctlFsWrap(CDevice *pDevice): CIoctlNtNative(pDevice){;};
    virtual ~CIoctlFsWrap(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

};




#endif //__FSWRAP_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\filemapioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*


#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
*/
#include "FilemapIOCTL.h"

static bool s_fVerbose = false;

void CIoctlFilemap::Cleanup()
{
	for (int i = 0; i < NUM_OF_VIEWS; i++)
	{
		//
		// i do not know what is locked, and what is not
		// so lets unlock all
		//
		/*
		if (m_apvMappedViewOfFile[i])
		{
			for (
				void *pNextPage = m_apvMappedViewOfFile[i];
				pNextPage < m_apvMappedViewOfFile[i]+m_adwNumOfBytesMapped[i]; 
				pNextPage += (4*1024) //BUGBUG: use page size
				)
			{
				if (!::VirtualUnlock(m_apvMappedViewOfFile[i], 1))
				{
					DPF((TEXT("VirtualUnlock() failed with %d\n"), ::GetLastError()));
				}
				else
				{
					DPF((TEXT("+++VirtualUnlock() succeeded\n")));
				}
			}
		}
		*/

		if (m_apvMappedViewOfFile[i])
		{
			if (!::UnmapViewOfFile(m_apvMappedViewOfFile[i]))
			{
				DPF((TEXT("UnmapViewOfFile() failed with %d\n"), ::GetLastError()));
			}
		}
		if (m_ahHeap[i])
		{
			__try
			{
				if (!::HeapDestroy(m_ahHeap[i]))
				{
					DPF((TEXT("DestroyHeap() failed with %d\n"), ::GetLastError()));
				}
			}__except(1){;}
		}
	}

	ZeroMemory(m_apvMappedViewOfFile, sizeof(m_apvMappedViewOfFile));
	ZeroMemory(m_adwNumOfBytesMapped, sizeof(m_adwNumOfBytesMapped));
	ZeroMemory(m_ahHeap, sizeof(m_ahHeap));
	ZeroMemory(m_afHeapValid, sizeof(m_afHeapValid));
	ZeroMemory(m_apvHeapAllocated, sizeof(m_apvHeapAllocated));
	ZeroMemory(m_adwNumOfBytesAllocated, sizeof(m_adwNumOfBytesAllocated));
}


HANDLE CIoctlFilemap::CreateDevice(CDevice *pDevice)
{
	/*
	BUGBUG: the file may be from another process, or device-thread, or it may be created by me.
			lets assume the file is external for the time being.
			it can also be a pagefile file.
*/

	if (!m_fFileInitialized)
	{
		if (0 == lstrcmpi(TEXT("pagefile.sys"), pDevice->GetSymbolicDeviceName()))
		{
			m_hFile = INVALID_HANDLE_VALUE;
		}
		else
		{
			m_hFile = ::CreateFile(
				pDevice->GetDeviceName(),          // pointer to name of the file
				GENERIC_READ | GENERIC_WRITE,       // access (read-write) mode
				FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,           // share mode
				NULL,                        // pointer to security attributes
				OPEN_ALWAYS,  // how to create
				FILE_FLAG_OVERLAPPED | FILE_FLAG_SEQUENTIAL_SCAN,  // file attributes
				NULL         // handle to file with attributes to copy
				);
			if (INVALID_HANDLE_VALUE == m_hFile)
			{
				DPF((TEXT("CIoctlFilemap::CreateDevice(): CreateFile(%s) failed with %d\n"), pDevice->GetDeviceName(), ::GetLastError()));
				
				//
				// do not break, let the API handle the invalid value
				// break;
				if (rand()%2) m_hFile = NULL;
				if (0 == rand()%10) m_hFile = (HANDLE) rand();
			}
			else
			{
				m_fFileInitialized = true;
			}
		}
	}

	DWORD dwMaximumSizeLow = (INVALID_HANDLE_VALUE == m_hFile) ? 0 : (DWORD_RAND & 0x3FFFFFFF);
	DWORD dwMaximumSizeHigh  = 0;
	HANDLE hMMF =  ::CreateFileMapping(
		m_hFile, //rand()%2 ? INVALID_HANDLE_VALUE : m_hFile,              // handle to file to map
		NULL, // optional security attributes
		PAGE_READWRITE, //GetProtectBits(),           // protection for mapping object
		0, // high-order 32 bits of object size
		dwMaximumSizeLow, // low-order 32 bits of object size
		pDevice->GetSymbolicDeviceName()+4             // name of file-mapping object
		);
	if (NULL == hMMF)
	{
		DPF((TEXT("CreateFileMapping(%s, %d) failed with %d\n"), pDevice->GetDeviceName(), dwMaximumSizeLow, ::GetLastError()));
		return INVALID_HANDLE_VALUE;
	}

	return hMMF;
}

BOOL CIoctlFilemap::CloseDevice(CDevice *pDevice)
{
	Cleanup();

	return ::CloseHandle(pDevice->m_hDevice);
}

void CIoctlFilemap::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    ;
}

void CIoctlFilemap::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
	//
	// since i currently do not use these buffs, set their lengths to 0, so my caller will not need to 
	// copy them etc.
	//
	dwInBuff = 0;
	dwOutBuff = 0;
	return;

    //CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
}


BOOL CIoctlFilemap::FindValidIOCTLs(CDevice *pDevice)
{    
	BOOL bRet = TRUE;
    DPF((TEXT("FindValidIOCTLs() %s is known, will use known IOCTLs\n"), pDevice->GetDeviceName()));

    AddIOCTL(pDevice, FSCTL_REQUEST_OPLOCK_LEVEL_1);
    AddIOCTL(pDevice, FSCTL_REQUEST_OPLOCK_LEVEL_2);
    AddIOCTL(pDevice, FSCTL_REQUEST_BATCH_OPLOCK);
    AddIOCTL(pDevice, FSCTL_OPLOCK_BREAK_ACKNOWLEDGE);
    AddIOCTL(pDevice, FSCTL_OPBATCH_ACK_CLOSE_PENDING);
    AddIOCTL(pDevice, FSCTL_OPLOCK_BREAK_NOTIFY);
    AddIOCTL(pDevice, FSCTL_LOCK_VOLUME);
    AddIOCTL(pDevice, FSCTL_UNLOCK_VOLUME);
    AddIOCTL(pDevice, FSCTL_DISMOUNT_VOLUME);
    AddIOCTL(pDevice, FSCTL_IS_VOLUME_MOUNTED);
    AddIOCTL(pDevice, FSCTL_IS_PATHNAME_VALID);
    AddIOCTL(pDevice, FSCTL_MARK_VOLUME_DIRTY);
    AddIOCTL(pDevice, FSCTL_QUERY_RETRIEVAL_POINTERS);
    AddIOCTL(pDevice, FSCTL_GET_COMPRESSION);
    AddIOCTL(pDevice, FSCTL_SET_COMPRESSION);
    AddIOCTL(pDevice, FSCTL_MARK_AS_SYSTEM_HIVE);
    AddIOCTL(pDevice, FSCTL_OPLOCK_BREAK_ACK_NO_2);
    AddIOCTL(pDevice, FSCTL_INVALIDATE_VOLUMES);
    AddIOCTL(pDevice, FSCTL_QUERY_FAT_BPB);
    AddIOCTL(pDevice, FSCTL_REQUEST_FILTER_OPLOCK);
    AddIOCTL(pDevice, FSCTL_FILESYSTEM_GET_STATISTICS);
    AddIOCTL(pDevice, FSCTL_GET_NTFS_VOLUME_DATA);
    AddIOCTL(pDevice, FSCTL_GET_NTFS_FILE_RECORD);
    AddIOCTL(pDevice, FSCTL_GET_VOLUME_BITMAP);
    AddIOCTL(pDevice, FSCTL_GET_RETRIEVAL_POINTERS);
    AddIOCTL(pDevice, FSCTL_MOVE_FILE);
    AddIOCTL(pDevice, FSCTL_IS_VOLUME_DIRTY);
    AddIOCTL(pDevice, FSCTL_GET_HFS_INFORMATION);
    AddIOCTL(pDevice, FSCTL_ALLOW_EXTENDED_DASD_IO);
    AddIOCTL(pDevice, FSCTL_READ_PROPERTY_DATA);
    AddIOCTL(pDevice, FSCTL_WRITE_PROPERTY_DATA);
    AddIOCTL(pDevice, FSCTL_FIND_FILES_BY_SID);
    AddIOCTL(pDevice, FSCTL_DUMP_PROPERTY_DATA);
    AddIOCTL(pDevice, FSCTL_SET_OBJECT_ID);
    AddIOCTL(pDevice, FSCTL_GET_OBJECT_ID);
    AddIOCTL(pDevice, FSCTL_DELETE_OBJECT_ID);
    AddIOCTL(pDevice, FSCTL_SET_REPARSE_POINT);
    AddIOCTL(pDevice, FSCTL_GET_REPARSE_POINT);
    AddIOCTL(pDevice, FSCTL_DELETE_REPARSE_POINT);
    AddIOCTL(pDevice, FSCTL_ENUM_USN_DATA);
    AddIOCTL(pDevice, FSCTL_SECURITY_ID_CHECK);
    AddIOCTL(pDevice, FSCTL_READ_USN_JOURNAL);
    AddIOCTL(pDevice, FSCTL_SET_OBJECT_ID_EXTENDED);
    AddIOCTL(pDevice, FSCTL_CREATE_OR_GET_OBJECT_ID);
    AddIOCTL(pDevice, FSCTL_SET_SPARSE);
    AddIOCTL(pDevice, FSCTL_SET_ZERO_DATA);
    AddIOCTL(pDevice, FSCTL_QUERY_ALLOCATED_RANGES);
    AddIOCTL(pDevice, FSCTL_ENABLE_UPGRADE);
    AddIOCTL(pDevice, FSCTL_SET_ENCRYPTION);
    AddIOCTL(pDevice, FSCTL_ENCRYPTION_FSCTL_IO);
    AddIOCTL(pDevice, FSCTL_WRITE_RAW_ENCRYPTED);
    AddIOCTL(pDevice, FSCTL_READ_RAW_ENCRYPTED);
    AddIOCTL(pDevice, FSCTL_CREATE_USN_JOURNAL);
    AddIOCTL(pDevice, FSCTL_READ_FILE_USN_DATA);
    AddIOCTL(pDevice, FSCTL_WRITE_USN_CLOSE_RECORD);
    AddIOCTL(pDevice, FSCTL_EXTEND_VOLUME);
    AddIOCTL(pDevice, FSCTL_QUERY_USN_JOURNAL);
    AddIOCTL(pDevice, FSCTL_DELETE_USN_JOURNAL);
    AddIOCTL(pDevice, FSCTL_MARK_HANDLE);
    AddIOCTL(pDevice, FSCTL_SIS_COPYFILE);
    AddIOCTL(pDevice, FSCTL_SIS_LINK_FILES);
    AddIOCTL(pDevice, FSCTL_HSM_MSG);
    AddIOCTL(pDevice, FSCTL_NSS_CONTROL);
    AddIOCTL(pDevice, FSCTL_HSM_DATA);
    AddIOCTL(pDevice, FSCTL_RECALL_FILE);
    AddIOCTL(pDevice, FSCTL_NSS_RCONTROL);

    return TRUE;

}


DWORD CIoctlFilemap::GetProtectBits()
{
	DWORD dwRet = 0;
	if (0 == rand()%10) dwRet |= PAGE_READONLY;
	else if (0 == rand()%2) dwRet |= PAGE_READWRITE;
	else dwRet |= PAGE_WRITECOPY;

	if (0 == rand()%10) dwRet |= SEC_COMMIT;
	if (0 == rand()%10) dwRet |= SEC_IMAGE;
	if (0 == rand()%10) dwRet |= SEC_NOCACHE;
	if (0 == rand()%10) dwRet |= SEC_RESERVE;

	return dwRet;
}

BOOL CIoctlFilemap::DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		)
{
	int nRandomIndex = rand()%NUM_OF_VIEWS;

	__try
	{
		ProbeForWrite((PBYTE)m_apvMappedViewOfFile[nRandomIndex], m_adwNumOfBytesMapped[nRandomIndex]);
	}__except(1){;}

	__try
	{
		ProbeForWrite((PBYTE)m_apvHeapAllocated[nRandomIndex], m_adwNumOfBytesAllocated[nRandomIndex]);
	}__except(1){;}

	return TRUE;
}

BOOL CIoctlFilemap::DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		)
{
	int nRandomIndex = rand()%NUM_OF_VIEWS;

	__try
	{
		ProbeForRead((PBYTE)m_apvMappedViewOfFile[nRandomIndex], m_adwNumOfBytesMapped[nRandomIndex]);
	}__except(1){;}

	__try
	{
		ProbeForRead((PBYTE)m_apvHeapAllocated[nRandomIndex], m_adwNumOfBytesAllocated[nRandomIndex]);
	}__except(1){;}

	return TRUE;
}

void CIoctlFilemap::CallRandomWin32API(LPOVERLAPPED pOL)
{
	//_ASSERTE(FALSE);
}

BOOL CIoctlFilemap::DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		)
{
	static long s_lModuluForNumOf64KPages = 100;



retry:
	switch(rand()%11)
	{
	case 0://MapViewOfFileEx
		{
			if (60 > rand()%100) goto retry;

			static long s_lNextIndex = 0;
			long lWrapAroundIndex = ::InterlockedIncrement(&s_lNextIndex);
			lWrapAroundIndex = (abs(lWrapAroundIndex))%NUM_OF_VIEWS;

			m_adwNumOfBytesMapped[lWrapAroundIndex] = rand()%2 ? 0 : rand()%s_lModuluForNumOf64KPages;
			m_adwNumOfBytesMapped[lWrapAroundIndex] = m_adwNumOfBytesMapped[lWrapAroundIndex] << 16;
			DWORD dwLowOrderFileOffset = rand()%10 ? 0 : rand()%s_lModuluForNumOf64KPages;
			dwLowOrderFileOffset = dwLowOrderFileOffset << 16;

			LPVOID pvSuggestedStartingAddress = (LPVOID)(rand()%s_lModuluForNumOf64KPages);
			if (rand()%5)
			{
				//
				// usually let the system choose an address
				//
				pvSuggestedStartingAddress = NULL;
			}
			pvSuggestedStartingAddress = (PVOID)((DWORD)pvSuggestedStartingAddress << 16);
			if (0 == rand()%10)
			{
				//
				// an illegal kernel address once in a while.
				//
				pvSuggestedStartingAddress = (PVOID)((DWORD)pvSuggestedStartingAddress | 0x80000000);
			}

			//
			// don't want to leak that much, so return if the poiter is already mapped
			//
			if (NULL != m_apvMappedViewOfFile[lWrapAroundIndex]) return TRUE;

			//
			// BUGBUG: we are leaking here, because 2 thread can map the same index, so at least one is lost
			//
			m_apvMappedViewOfFile[lWrapAroundIndex] =  ::MapViewOfFileEx(
				m_pDevice->m_hDevice,  // file-mapping object to map into address space
				FILE_MAP_ALL_ACCESS,//GetDesiredAccessForView()      // access mode
				0,     // high-order 32 bits of file offset
				dwLowOrderFileOffset,      // low-order 32 bits of file offset
				m_adwNumOfBytesMapped[lWrapAroundIndex], //rand(), // number of bytes to map
				pvSuggestedStartingAddress        // suggested starting address for mapped view
				);
			if (NULL == m_apvMappedViewOfFile[lWrapAroundIndex])
			{
				DWORD dwLastError = ::GetLastError();
				//
				// if memory is not enough, lets ask for less next time
				//
				if ( (ERROR_NOT_ENOUGH_MEMORY == dwLastError) || (ERROR_ACCESS_DENIED == dwLastError) )
				{
					//
					// may never modulu zero
					//
					if (5 >= ::InterlockedDecrement(&s_lModuluForNumOf64KPages))
					{
						::InterlockedExchange(&s_lModuluForNumOf64KPages, 1+abs(s_lModuluForNumOf64KPages));
					}
				}

				DPF((TEXT("MapViewOfFileEx(0x%08x, 0x%08x, 0x%08X) failed with %d\n"), dwLowOrderFileOffset, m_adwNumOfBytesMapped[lWrapAroundIndex], pvSuggestedStartingAddress, dwLastError));
				return FALSE;
			}

			//
			// if memory is enough, lets ask for more next time
			//
			::InterlockedIncrement(&s_lModuluForNumOf64KPages);

			DPF((TEXT("+++MapViewOfFileEx() succeeded\n")));
			return TRUE;
		}
		break;

	case 1://UnmapViewOfFileEx
		{
			if (40 > rand()%100) goto retry;

			int nRandomIndex = rand()%NUM_OF_VIEWS;
			if (m_apvMappedViewOfFile[nRandomIndex])
			{
				if (!::UnmapViewOfFile(m_apvMappedViewOfFile[nRandomIndex]))
				{
					//
					// this may happen if another thread already unmapped this.
					//
					DPF((TEXT("UnmapViewOfFile() failed with %d\n"), ::GetLastError()));
				}
				else
				{
					m_apvMappedViewOfFile[nRandomIndex] = NULL;
					m_adwNumOfBytesMapped[nRandomIndex] = 0;
				}

			}
		}
		break;

	case 2://VirtualLock - MMF
		{
			//
			// do this with medium probability
			//
			if (80 > rand()%100) goto retry;

			int nRandomIndex = rand()%NUM_OF_VIEWS;
			//
			// will not lock a NULL pointer
			//
			//if (NULL == m_apvMappedViewOfFile[lWrapAroundIndex]) return TRUE;
			DWORD dwModulu = m_adwNumOfBytesMapped[nRandomIndex];
			if (0 == dwModulu) dwModulu = 1;//never modulu 0!!!
			DWORD dwSize = 1+rand()%dwModulu;
			if (!::VirtualLock(m_apvMappedViewOfFile[nRandomIndex], dwSize))
			{
				DPF((TEXT("VirtualLock(m_apvMappedViewOfFile) failed with %d\n"), ::GetLastError()));
			}
			else
			{
				DPF((TEXT("+++VirtualLock(m_apvMappedViewOfFile) succeeded\n")));
			}
		}
		break;

	case 3://VirtualUnlock - MMF
		{
			//
			// do this with medium probability
			//
			if (80 > rand()%100) goto retry;

			int nRandomIndex = rand()%NUM_OF_VIEWS;
			//
			// will not un-lock a NULL pointer
			//
			//if (NULL == m_apvMappedViewOfFile[lWrapAroundIndex]) return TRUE;
			DWORD dwModulu = m_adwNumOfBytesMapped[nRandomIndex];
			if (0 == dwModulu) dwModulu = 1;//never modulu 0!!!
			DWORD dwSize = 1+rand()%dwModulu;
			if (!::VirtualUnlock(m_apvMappedViewOfFile[nRandomIndex], dwSize))
			{
				DPF((TEXT("VirtualUnlock(m_apvMappedViewOfFile) failed with %d\n"), ::GetLastError()));
			}
			else
			{
				DPF((TEXT("+++VirtualUnlock(m_apvMappedViewOfFile) succeeded\n")));
			}
		}
		break;

	case 4://SetProcessWorkingSetSize
		{
			//
			// do this with lowest probability
			//
			if (95 > rand()%100) goto retry;

			DWORD dwRandMin = rand();
			dwRandMin = dwRandMin << (rand()%16);
			DWORD dwRandMax = rand();
			dwRandMax = dwRandMax << (rand()%16);
			if (dwRandMax < dwRandMin)
			{
				DWORD dwTemp = dwRandMax;
				dwRandMax = dwRandMin;
				dwRandMin = dwTemp;
			}
			if (!::SetProcessWorkingSetSize(GetCurrentProcess(), dwRandMin, dwRandMax))
			{
				DPF((TEXT("SetProcessWorkingSetSize(%d, %d) failed with %d.\n"), dwRandMin, dwRandMax, ::GetLastError()));
			}
			else
			{
				DPF((TEXT("+++SetProcessWorkingSetSize(%d, %d) succeeded.\n"), dwRandMin, dwRandMax));
			}
		}
		break;

	case 5://HeapCreate
		{
			//
			// do this with lowest probability
			//
			if (95 > rand()%100) goto retry;

			static long s_lNextIndex = 0;
			long lWrapAroundIndex = ::InterlockedIncrement(&s_lNextIndex);
			lWrapAroundIndex = (abs(lWrapAroundIndex))%NUM_OF_VIEWS;

			//
			// in order not to leak:
			// IMPORTANT:
			//   this check must be BEFORE the check of m_afHeapValid[], due
			//   to the order they are marked by HeapDestroy()
			//
			if (NULL != m_ahHeap[lWrapAroundIndex])
			{
				return TRUE;
				//
				// this handle can still be invalid!
				//
			}

			DWORD dwInitialSize = rand()%2 ? 0 : DWORD_RAND&0x3FFFFFFF;
			DWORD dwMaximumSize = rand()%2 ? 0 : DWORD_RAND&0x3FFFFFFF;
			if (dwMaximumSize < dwInitialSize)
			{
				DWORD dwTemp = dwMaximumSize;
				dwMaximumSize = dwInitialSize;
				dwInitialSize = dwTemp;
			}

			//
			// mark as trying/succeeded to create
			//
			if (TRUE == ::InterlockedExchange(&m_afHeapValid[lWrapAroundIndex], TRUE))
			{
				//
				// someone is already trying, or succeeded
				//
				return TRUE;
			}
			//
			// we are now virtually i a CS for this index for creating a heap
			//
			m_ahHeap[lWrapAroundIndex] = ::HeapCreate(
				0,//will serialize, will not generate exceptions
				dwInitialSize,
				dwMaximumSize
				);
			if (NULL == m_ahHeap[lWrapAroundIndex])
			{
				//
				// mark as ok to try to create
				//
				long fWasMarkedAsValid = ::InterlockedExchange(&m_afHeapValid[lWrapAroundIndex], FALSE);
				DPF((TEXT("HeapCreate(%d, %d) failed with %d.\n"), dwInitialSize, dwMaximumSize, ::GetLastError()));
				//
				// the heap could have been destroyed by another thread, so the following assert 
				// does not hold:
				//_ASSERTE(fWasMarkedAsValid);
			}
			else
			{
				DPF((TEXT("+++HeapCreate(%d, %d) succeeded.\n"), dwInitialSize, dwMaximumSize));
			}
		}
		break;

	case 6://HeapDestroy
		{
			//
			// do this with lowest probability
			//
			if (90 > rand()%100) goto retry;

			int nRandomIndex = rand()%NUM_OF_VIEWS;

			//
			// use NULL handles, as they might become valid just now
			// (or it will fail for NULL, so what!)
			//
			//if (NULL == m_ahHeap[nRandomIndex]) return TRUE;

			//
			// this call may cause an assert inside RtlDestroyHeap()
			//
			__try
			{
				if (!::HeapDestroy(m_ahHeap[nRandomIndex]))
				{
					//
					// do not set to NULL, because it can be that this heap for destroyed and created
					// so setting it to NULL now will delete it!
					DPF((TEXT("HeapDestroy() failed with %d.\n"), ::GetLastError()));
				}
				else
				{
					//
					// this marks that HeapCreate() will not be skipped, 
					// but still m_afHeapValid[] must be marked as free
					// IMPORTANT:
					//   HeapCreate() 1st checks for NULL m_ahHeap[] and skips if null
					//     only then it tries m_afHeapValid[]
					//   Therefor, here, we must 1st put NULL in m_ahHeap[] and then
					//     set m_afHeapValid[] to false
					//
					m_ahHeap[nRandomIndex] = NULL;
					::InterlockedExchange(&m_afHeapValid[nRandomIndex], FALSE);
					DPF((TEXT("+++HeapDestroy() succeeded.\n")));
				}
			}__except(1)
			{
				DPF((TEXT("####HeapDestroy() raised exception %d=0x%08X.\n"), ::GetExceptionCode(), ::GetExceptionCode()));
			}
		}
		break;

	case 7://HeapAlloc
		{
			//
			// do this with high probability (more than alloc, to make sure we do not hog)
			//
			if (60 > rand()%100) goto retry;

			static long s_lNextIndex = 0;
			long lWrapAroundIndex = ::InterlockedIncrement(&s_lNextIndex);
			lWrapAroundIndex = (abs(lWrapAroundIndex))%NUM_OF_VIEWS;

			//
			// i want to race alloc and free, but how do i do this without leaking?
			// do i care if i leak?
			// maybe no, becuase heaps are also destroyed, so this should free all allocations!
			// lets go for the leaks!
			//

			//
			// this is a non-thread safe check, still, it will cause less leaks
			//
			if (NULL != m_apvHeapAllocated[lWrapAroundIndex])
			{
				return TRUE;
			}

			//
			// this call can cause a leak, that will hopefully be free when the heap is destroyed
			// also, if the heap handle becomes null, it will raise an exception, so guard it
			//
			m_adwNumOfBytesAllocated[lWrapAroundIndex] = rand()%2 ? rand() : rand()%2 ? 0x7FFF8 : 0x7FFF7;
			__try
			{
				m_apvHeapAllocated[lWrapAroundIndex] = ::HeapAlloc(
					m_ahHeap[lWrapAroundIndex],
					0,
					m_adwNumOfBytesAllocated[lWrapAroundIndex]
					);
			}__except(1)
			{
				DPF((TEXT("####HeapAlloc() raised exception %d=0x%08X.\n"), ::GetExceptionCode(), ::GetExceptionCode()));
			}

			//
			// this check is useless, since other thread may mess with this variable!
			//
			if (NULL == m_apvHeapAllocated[lWrapAroundIndex])
			{
				DPF((TEXT("HeapAlloc(%d) failed with %d.\n"), m_adwNumOfBytesAllocated[lWrapAroundIndex], ::GetLastError()));
				m_adwNumOfBytesAllocated[lWrapAroundIndex] = 0;
			}
			else
			{
				DPF((TEXT("+++HeapAlloc(%d) succeeded.\n"), m_adwNumOfBytesAllocated[lWrapAroundIndex]));
			}
		}
		break;

	case 8://HeapFree
		{
			//
			// do this with high probability
			//
			if (40 > rand()%100) goto retry;

			int nRandomIndex = rand()%NUM_OF_VIEWS;

			//
			// this cause can raise an exception. just ignore it.
			//
			__try
			{
				if (!::HeapFree(m_ahHeap[nRandomIndex], 0, m_apvHeapAllocated[nRandomIndex]))
				{
					DPF((TEXT("HeapFree() failed with %d.\n"), ::GetLastError()));
				}
				else
				{
					m_adwNumOfBytesAllocated[nRandomIndex] = 0;
					DPF((TEXT("+++HeapFree() succeeded.\n")));
				}
			}__except(1)
			{
				DPF((TEXT("####HeapFree() raised exception %d=0x%08X.\n"), ::GetExceptionCode(), ::GetExceptionCode()));
			}
		}
		break;

	case 9://VirtualLock - heap
		{
			//
			// do this with medium probability
			//
			if (80 > rand()%100) goto retry;

			int nRandomIndex = rand()%NUM_OF_VIEWS;
			//
			// will not lock a NULL pointer
			//
			//if (NULL == m_apvMappedViewOfFile[lWrapAroundIndex]) return TRUE;
			DWORD dwModulu = m_adwNumOfBytesAllocated[nRandomIndex];
			if (0 == dwModulu) dwModulu = 1;//never modulu 0!!!
			DWORD dwSize = 1+rand()%dwModulu;
			if (!::VirtualLock(m_apvHeapAllocated[nRandomIndex], dwSize))
			{
				DPF((TEXT("VirtualLock(m_apvHeapAllocated) failed with %d\n"), ::GetLastError()));
			}
			else
			{
				DPF((TEXT("+++VirtualLock(m_apvHeapAllocated) succeeded\n")));
			}
		}
		break;

	case 10://VirtualUnlock - heap
		{
			//
			// do this with medium probability
			//
			if (80 > rand()%100) goto retry;

			int nRandomIndex = rand()%NUM_OF_VIEWS;
			//
			// will not un-lock a NULL pointer
			//
			//if (NULL == m_apvMappedViewOfFile[lWrapAroundIndex]) return TRUE;
			DWORD dwModulu = m_adwNumOfBytesAllocated[nRandomIndex];
			if (0 == dwModulu) dwModulu = 1;//never modulu 0!!!
			DWORD dwSize = 1+rand()%dwModulu;
			if (!::VirtualUnlock(m_apvHeapAllocated[nRandomIndex], dwSize))
			{
				DPF((TEXT("VirtualUnlock(m_apvHeapAllocated) failed with %d\n"), ::GetLastError()));
			}
			else
			{
				DPF((TEXT("+++VirtualUnlock(m_apvHeapAllocated) succeeded\n")));
			}
		}
		break;

	default:
		_ASSERTE(FALSE);
	}

	return TRUE;
}


BOOL CIoctlFilemap::DeviceCancelIo(
	HANDLE hFile  // file handle for which to cancel I/O
	)
{
	return ::CancelIo(hFile);
}

void CIoctlFilemap::ProbeForRead(
    IN PBYTE Address,
    IN ULONG Length
	)
{
	//
	// for simplicity, touch every 1K of byte
	//
	PBYTE pvTouching = Address;
	BYTE bDest;
	while (pvTouching-Length < Address)
	{
		bDest = *pvTouching;
		pvTouching += 1024;
	}
}

void CIoctlFilemap::ProbeForWrite(
    IN PBYTE Address,
    IN ULONG Length
	)
{
	//
	// for simplicity, touch every 1K of byte
	//
	PBYTE pvTouching = Address;
	while (pvTouching-Length < Address)
	{
		*pvTouching = 0xCB;
		pvTouching += 1024;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\fswrapioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>


#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <windows.h>
*/
//#include <ntddk.h>
typedef struct _SECURITY_SUBJECT_CONTEXT {
    PACCESS_TOKEN ClientToken;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    PACCESS_TOKEN PrimaryToken;
    PVOID ProcessAuditId;
    } SECURITY_SUBJECT_CONTEXT, *PSECURITY_SUBJECT_CONTEXT;
#define INITIAL_PRIVILEGE_COUNT         3

typedef struct _INITIAL_PRIVILEGE_SET {
    ULONG PrivilegeCount;
    ULONG Control;
    LUID_AND_ATTRIBUTES Privilege[INITIAL_PRIVILEGE_COUNT];
    } INITIAL_PRIVILEGE_SET, * PINITIAL_PRIVILEGE_SET;
typedef struct _ACCESS_STATE {
   LUID OperationID;
   BOOLEAN SecurityEvaluated;
   BOOLEAN GenerateAudit;
   BOOLEAN GenerateOnClose;
   BOOLEAN PrivilegesAllocated;
   ULONG Flags;
   ACCESS_MASK RemainingDesiredAccess;
   ACCESS_MASK PreviouslyGrantedAccess;
   ACCESS_MASK OriginalDesiredAccess;
   SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
   PSECURITY_DESCRIPTOR SecurityDescriptor;
   PVOID AuxData;
   union {
      INITIAL_PRIVILEGE_SET InitialPrivilegeSet;
      PRIVILEGE_SET PrivilegeSet;
      } Privileges;

   BOOLEAN AuditPrivileges;
   UNICODE_STRING ObjectName;
   UNICODE_STRING ObjectTypeName;

   } ACCESS_STATE, *PACCESS_STATE;
typedef struct _IO_SECURITY_CONTEXT {
    PSECURITY_QUALITY_OF_SERVICE SecurityQos;
    PACCESS_STATE AccessState;
    ACCESS_MASK DesiredAccess;
    ULONG FullCreateOptions;
} IO_SECURITY_CONTEXT, *PIO_SECURITY_CONTEXT;
#include "ntddmup.h"


#define REMOTE_BOOT_POST_NT5
#include <REMBOOT.h>
#include <ntddbrow.h>
#include <lmserver.h>
#include <shdcom.h>


#include "FsWrapIOCTL.h"

static bool s_fVerbose = false;

void CIoctlFsWrap::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    ;
}

void CIoctlFsWrap::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
	switch(dwIOCTL)
	{
	case IOCTL_REDIR_QUERY_PATH:
//TODO:
		break;

	case IOCTL_LMR_ARE_FILE_OBJECTS_ON_SAME_SERVER:
//TODO:
        break;

	case FSCTL_LMR_SET_LINK_TRACKING_INFORMATION:

		break;

	case FSCTL_LMR_GET_LINK_TRACKING_INFORMATION:

		break;

	case IOCTL_LMMR_USEKERNELSEC:

		break;

	case IOCTL_LMDR_START:

		break;

	case IOCTL_LMDR_BIND_TO_TRANSPORT_DOM:

		break;

	case IOCTL_LMDR_UNBIND_FROM_TRANSPORT_DOM:

		break;

	case IOCTL_SHADOW_GETVERSION:

		break;

	case IOCTL_SHADOW_REGISTER_AGENT:

		break;

	case IOCTL_SHADOW_UNREGISTER_AGENT:

		break;

	case IOCTL_SHADOW_GET_UNC_PATH:

		break;

	case IOCTL_SHADOW_BEGIN_PQ_ENUM:

		break;

	case IOCTL_SHADOW_END_PQ_ENUM:

		break;

	case IOCTL_SHADOW_NEXT_PRI_SHADOW:

		break;

	case IOCTL_SHADOW_PREV_PRI_SHADOW:

		break;

	case IOCTL_SHADOW_GET_SHADOW_INFO:

		break;

	case IOCTL_SHADOW_SET_SHADOW_INFO:

		break;

	case IOCTL_SHADOW_CHK_UPDT_STATUS:

		break;

	case IOCTL_DO_SHADOW_MAINTENANCE:

		break;

	case IOCTL_SHADOW_COPYCHUNK:

		break;

	case IOCTL_CLOSEFORCOPYCHUNK:

		break;

	case IOCTL_OPENFORCOPYCHUNK:

		break;

	case IOCTL_IS_SERVER_OFFLINE:

		break;

	case IOCTL_TRANSITION_SERVER_TO_OFFLINE:

		break;

	case IOCTL_TRANSITION_SERVER_TO_ONLINE:

		break;

	case IOCTL_NAME_OF_SERVER_GOING_OFFLINE:

		break;

	case IOCTL_SHADOW_BEGIN_REINT:

		break;

	case IOCTL_SHADOW_END_REINT:

		break;

	case IOCTL_SHADOW_CREATE:

		break;

	case IOCTL_SHADOW_DELETE:

		break;

	case IOCTL_GET_SHARE_STATUS:

		break;

	case IOCTL_SET_SHARE_STATUS:

		break;

	case IOCTL_ADDUSE:

		break;

	case IOCTL_DELUSE:

		break;

	case IOCTL_GETUSE:

		break;

	case IOCTL_SWITCHES:

		break;

	case IOCTL_GETSHADOW:

		break;

	case IOCTL_GETGLOBALSTATUS:

		break;

	case IOCTL_FINDOPEN_SHADOW:

		break;

	case IOCTL_FINDNEXT_SHADOW:

		break;

	case IOCTL_FINDCLOSE_SHADOW:

		break;

	case IOCTL_GETPRIORITY_SHADOW:

		break;

	case IOCTL_SETPRIORITY_SHADOW:

		break;

	case IOCTL_ADD_HINT:

		break;

	case IOCTL_DELETE_HINT:

		break;

	case IOCTL_FINDOPEN_HINT:

		break;

	case IOCTL_FINDNEXT_HINT:

		break;

	case IOCTL_FINDCLOSE_HINT:

		break;

//	case xxx:

		break;

		_tprintf(TEXT("CIoctlFsWrap::PrepareIOCTLParams() 0x%08X is an unexpected IOCTL\n"), dwIOCTL);
		_ASSERTE(FALSE);
		CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
	}
}


BOOL CIoctlFsWrap::FindValidIOCTLs(CDevice *pDevice)
{
	AddIOCTL(pDevice, IOCTL_REDIR_QUERY_PATH             );
	AddIOCTL(pDevice, IOCTL_LMR_ARE_FILE_OBJECTS_ON_SAME_SERVER             );
	AddIOCTL(pDevice, FSCTL_LMR_SET_LINK_TRACKING_INFORMATION             );
	AddIOCTL(pDevice, FSCTL_LMR_GET_LINK_TRACKING_INFORMATION             );
	AddIOCTL(pDevice, IOCTL_LMMR_USEKERNELSEC             );
	AddIOCTL(pDevice, IOCTL_LMDR_START             );
	AddIOCTL(pDevice, IOCTL_LMDR_BIND_TO_TRANSPORT_DOM             );
	AddIOCTL(pDevice, IOCTL_LMDR_UNBIND_FROM_TRANSPORT_DOM             );
	AddIOCTL(pDevice, IOCTL_SHADOW_GETVERSION             );
	AddIOCTL(pDevice, IOCTL_SHADOW_REGISTER_AGENT             );
	AddIOCTL(pDevice, IOCTL_SHADOW_UNREGISTER_AGENT             );
	AddIOCTL(pDevice, IOCTL_SHADOW_GET_UNC_PATH             );
	AddIOCTL(pDevice, IOCTL_SHADOW_BEGIN_PQ_ENUM             );
	AddIOCTL(pDevice, IOCTL_SHADOW_END_PQ_ENUM             );
	AddIOCTL(pDevice, IOCTL_SHADOW_NEXT_PRI_SHADOW             );
	AddIOCTL(pDevice, IOCTL_SHADOW_PREV_PRI_SHADOW             );
	AddIOCTL(pDevice, IOCTL_SHADOW_GET_SHADOW_INFO             );
	AddIOCTL(pDevice, IOCTL_SHADOW_SET_SHADOW_INFO             );
	AddIOCTL(pDevice, IOCTL_SHADOW_CHK_UPDT_STATUS             );
	AddIOCTL(pDevice, IOCTL_DO_SHADOW_MAINTENANCE             );
	AddIOCTL(pDevice, IOCTL_SHADOW_COPYCHUNK             );
	AddIOCTL(pDevice, IOCTL_CLOSEFORCOPYCHUNK             );
	AddIOCTL(pDevice, IOCTL_OPENFORCOPYCHUNK             );
	AddIOCTL(pDevice, IOCTL_IS_SERVER_OFFLINE             );
	AddIOCTL(pDevice, IOCTL_TRANSITION_SERVER_TO_OFFLINE             );
	AddIOCTL(pDevice, IOCTL_TRANSITION_SERVER_TO_ONLINE             );
	AddIOCTL(pDevice, IOCTL_NAME_OF_SERVER_GOING_OFFLINE             );
	AddIOCTL(pDevice, IOCTL_SHADOW_BEGIN_REINT             );
	AddIOCTL(pDevice, IOCTL_SHADOW_END_REINT             );
	AddIOCTL(pDevice, IOCTL_SHADOW_CREATE             );
	AddIOCTL(pDevice, IOCTL_SHADOW_DELETE             );
	AddIOCTL(pDevice, IOCTL_GET_SHARE_STATUS             );
	AddIOCTL(pDevice, IOCTL_SET_SHARE_STATUS             );
	AddIOCTL(pDevice, IOCTL_ADDUSE             );
	AddIOCTL(pDevice, IOCTL_DELUSE             );
	AddIOCTL(pDevice, IOCTL_GETUSE             );
	AddIOCTL(pDevice, IOCTL_SWITCHES             );
	AddIOCTL(pDevice, IOCTL_GETSHADOW             );
	AddIOCTL(pDevice, IOCTL_GETGLOBALSTATUS             );
	AddIOCTL(pDevice, IOCTL_FINDOPEN_SHADOW             );
	AddIOCTL(pDevice, IOCTL_FINDNEXT_SHADOW             );
	AddIOCTL(pDevice, IOCTL_FINDCLOSE_SHADOW             );
	AddIOCTL(pDevice, IOCTL_GETPRIORITY_SHADOW             );
	AddIOCTL(pDevice, IOCTL_SETPRIORITY_SHADOW             );
	AddIOCTL(pDevice, IOCTL_ADD_HINT             );
	AddIOCTL(pDevice, IOCTL_DELETE_HINT             );
	AddIOCTL(pDevice, IOCTL_FINDOPEN_HINT             );
	AddIOCTL(pDevice, IOCTL_FINDNEXT_HINT             );
	AddIOCTL(pDevice, IOCTL_FINDCLOSE_HINT             );
//	AddIOCTL(pDevice, xxxxx             );
    return TRUE;
}



void CIoctlFsWrap::CallRandomWin32API(LPOVERLAPPED pOL)
{
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\floppyioctl.h ===
#ifndef __FLOPPY_IOCTL_H
#define __FLOPPY_IOCTL_H

//#include "IOCTL.h"


class CIoctlFloppy : public CIoctl
{
public:
    CIoctlFloppy(CDevice *pDevice): CIoctl(pDevice){;};
    virtual ~CIoctlFloppy(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

};




#endif //__FLOPPY_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\handlecontainer.cpp ===
CHandleContainer::GetRandomHandle()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\ipfltdrvioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
#include <windows.h>


#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
*/

#define _PNP_POWER_
#include "ntddip.h"
#include "icmpif.h"
#include "ipinfo.h"



#include <ipfltdrv.h>

#include "ipfltdrvIOCTL.h"

static bool s_fVerbose = false;

static void Fill_ipfltdrv_RTR_INFO_BLOCK_HEADER(CIoctlIpfltrdrv* pThis, RTR_INFO_BLOCK_HEADER &rtr_info_block_header);
static void FillFilterDriverCreateInterface(CIoctlIpfltrdrv* pThis, PFILTER_DRIVER_CREATE_INTERFACE pToFill);
static void FillInterfaceParameters(CIoctlIpfltrdrv* pThis, PPFINTERFACEPARAMETERS pToFill);

static void SetDriverContext(CIoctlIpfltrdrv* pThis, PVOID pvDriverContext);
static void SetFilterInfo(CIoctlIpfltrdrv* pThis, FILTER_INFOEX *pFilterInfo);
static PVOID GetDriverContext(CIoctlIpfltrdrv* pThis);
static PVOID GetFilterHandle(CIoctlIpfltrdrv* pThis);

CIoctlIpfltrdrv::CIoctlIpfltrdrv(CDevice *pDevice):
    CIoctl(pDevice)
{
    m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    //
    // don't care if I fail, i may try again later
    //
}

CIoctlIpfltrdrv::~CIoctlIpfltrdrv()
{
    if (m_hEvent)
    {
        CloseHandle(m_hEvent);
    }
}

#define GET_RANDOM_FORWARD_ACTION rand()%2 ? FORWARD : rand()%2 ? DROP : (FORWARD_ACTION)rand()
#define GET_RANDOM_BINDING_TYPE \
                                rand()%2? \
                                PF_BIND_NONE: \
                                rand()%2? \
                                PF_BIND_IPV4ADDRESS: \
                                rand()%2? \
                                PF_BIND_IPV6ADDRESS: \
                                rand()%2? \
                                PF_BIND_NAME: \
                                rand()%2? \
                                PF_BIND_INTERFACEINDEX: \
                                (PFBINDINGTYPE)rand()

#define GET_RANDOM_INTERFACE_FLAGS rand()%2 ? PFSET_FLAGS_UNIQUE : rand()

void Fill_ipfltdrv_RTR_INFO_BLOCK_HEADER(CIoctlIpfltrdrv* pThis, RTR_INFO_BLOCK_HEADER &rtr_info_block_header)
{
/*
typedef struct _RTR_INFO_BLOCK_HEADER
{
    ULONG			Version;	    // Version of the structure
    ULONG			Size;		    // size of the whole block, including version
    ULONG			TocEntriesCount;// Number of entries
    RTR_TOC_ENTRY   TocEntry[1];    // Table of content followed by the actual
                                    // information blocks
} RTR_INFO_BLOCK_HEADER, *PRTR_INFO_BLOCK_HEADER;
*/
    rtr_info_block_header.Version = DWORD_RAND;
    rtr_info_block_header.Size = rand()%2 ? sizeof(RTR_INFO_BLOCK_HEADER) : rand();
    rtr_info_block_header.TocEntriesCount = rand();
}



void FillFilterDriverCreateInterface(CIoctlIpfltrdrv* pThis, PFILTER_DRIVER_CREATE_INTERFACE pToFill)
{
/*
typedef struct _FILTER_DRIVER_CREATE_INTERFACE
{
    IN    DWORD   dwIfIndex;
    IN    DWORD   dwAdapterId;
    IN    PVOID   pvRtrMgrContext;
    OUT   PVOID   pvDriverContext;
}FILTER_DRIVER_CREATE_INTERFACE, *PFILTER_DRIVER_CREATE_INTERFACE;
*/
    pToFill->dwIfIndex = DWORD_RAND;
    pToFill->dwAdapterId = DWORD_RAND;
    pToFill->pvRtrMgrContext = GetDriverContext(pThis);
    pToFill->pvDriverContext = GetDriverContext(pThis);
}

void FillInterfaceParameters(CIoctlIpfltrdrv* pThis, PPFINTERFACEPARAMETERS pToFill)
{
/*
typedef struct _pfSetInterfaceParameters
{
    PFBINDINGTYPE pfbType;
    DWORD  dwBindingData;
    FORWARD_ACTION eaIn;
    FORWARD_ACTION eaOut;
    FILTER_DRIVER_CREATE_INTERFACE fdInterface;
    DWORD dwInterfaceFlags;
    PFLOGGER pfLogId;
} PFINTERFACEPARAMETERS, *PPFINTERFACEPARAMETERS;
*/
    pToFill->pfbType = GET_RANDOM_BINDING_TYPE;
    pToFill->dwBindingData = DWORD_RAND;
    pToFill->eaIn = GET_RANDOM_FORWARD_ACTION;
    pToFill->eaOut = GET_RANDOM_FORWARD_ACTION;
    FillFilterDriverCreateInterface(pThis, &pToFill->fdInterface);
    pToFill->dwInterfaceFlags = GET_RANDOM_INTERFACE_FLAGS;
    pToFill->pfLogId = DWORD_RAND;
}

void CIoctlIpfltrdrv::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
    //DPF((TEXT("PrepareIOCTLParams(%s)\n"), szDevice));
    //
    // fill random data & len
    //
    if (rand()%20 == 0)
    {
        FillBufferWithRandomData(abInBuffer, dwInBuff);
        FillBufferWithRandomData(abOutBuffer, dwOutBuff);
        return;
    }

    //
    // NULL pointer variations
    //
    if (rand()%20 == 0)
    {
        abInBuffer = NULL;
        return;
    }
    if (rand()%20 == 0)
    {
        abOutBuffer = NULL;
        return;
    }
    if (rand()%20 == 0)
    {
        abInBuffer = NULL;
        abOutBuffer = NULL;
        return;
    }

    //
    // 0 size variations
    //
    if (rand()%20 == 0)
    {
        dwInBuff = NULL;
        return;
    }
    if (rand()%20 == 0)
    {
        dwOutBuff = NULL;
        return;
    }
    if (rand()%20 == 0)
    {
        dwInBuff = NULL;
        dwOutBuff = NULL;
        return;
    }

    //
    // fill "smart" data
    //
    switch(dwIOCTL)
    {
    case IOCTL_CREATE_INTERFACE://
//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// This IOCTL is used to to create an interface in the filter driver. It    //
// takes in an index and an opaque context. It creates an interface,        //
// associates the index and context with it and returns a context for this  //
// created interface. All future IOCTLS require this context that is passed // 
// out                                                                      //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////
/*
typedef struct _FILTER_DRIVER_CREATE_INTERFACE
{
    IN    DWORD   dwIfIndex;
    IN    DWORD   dwAdapterId;
    IN    PVOID   pvRtrMgrContext;
    OUT   PVOID   pvDriverContext;
}FILTER_DRIVER_CREATE_INTERFACE, *PFILTER_DRIVER_CREATE_INTERFACE;
*/
        FillFilterDriverCreateInterface(this, (PFILTER_DRIVER_CREATE_INTERFACE)abInBuffer);

        SetInParam(dwInBuff, sizeof(FILTER_DRIVER_CREATE_INTERFACE));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(PVOID));

        break;

    case IOCTL_SET_INTERFACE_FILTERS://
    case IOCTL_SET_INTERFACE_FILTERS_EX://
    case IOCTL_DELETE_INTERFACE_FILTERS_EX://
//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// This IOCTL is used to set filters for an interface.                      //
// The context used to identify the interface is the one that is passed out //
// by the CREATE_INTERFACE IOCTL                                            //
// There can be two TOC entries, one for IP_FILTER_DRIVER_IN_FILTER_INFO    //
// and the other for IP_FILTER_DRIVER_OUT_FILTER_INFO.                      //
// If a (in or out) TOC entry doesnt exist, no change is made to the        //
// (in or out) filters.                                                     //
// If a (in or out) TOC exists and its size is 0, the (in or out) filters   //
// are deleted and the default (in or out) action set to FORWARD.           //
// If a TOC exists and its size is not 0 but the number of filters in the   //
// FILTER_DESCRIPTOR is 0, the old filters are deleted and the default      //
// action set to the one specified in the descriptor.                       //
// The last case is when the Toc exists, its size is not 0, and the         //
// number of filters is also not 0. In this case, the old filters are       //
// deleted, the default action set to the one specified in the descriptor   //
// and the new filters are added.                                           //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////
/*
typedef struct _FILTER_DRIVER_SET_FILTERS
{
    IN   PVOID                  pvDriverContext;
    IN   RTR_INFO_BLOCK_HEADER  ribhInfoBlock;
}FILTER_DRIVER_SET_FILTERS, *PFILTER_DRIVER_SET_FILTERS;
*/
        ((PFILTER_DRIVER_SET_FILTERS)abInBuffer)->pvDriverContext = GetDriverContext(this);
        Fill_ipfltdrv_RTR_INFO_BLOCK_HEADER(this, ((PFILTER_DRIVER_SET_FILTERS)abInBuffer)->ribhInfoBlock);
        SetInParam(dwInBuff, sizeof(FILTER_DRIVER_SET_FILTERS));

        SetOutParam(abOutBuffer, dwOutBuff, rand());

        break;

    case IOCTL_SET_LATE_BOUND_FILTERS://
    case IOCTL_SET_LATE_BOUND_FILTERSEX://
/*
typedef struct _FILTER_DRIVER_BINDING_INFO
{
    IN  PVOID   pvDriverContext;
    IN  DWORD   dwLocalAddr;
    IN  DWORD   dwRemoteAddr;
    IN  DWORD   dwMask;
}FILTER_DRIVER_BINDING_INFO, *PFILTER_DRIVER_BINDING_INFO;
*/
        ((PFILTER_DRIVER_BINDING_INFO)abInBuffer)->pvDriverContext = GetDriverContext(this);
        ((PFILTER_DRIVER_BINDING_INFO)abInBuffer)->dwLocalAddr = DWORD_RAND;
        ((PFILTER_DRIVER_BINDING_INFO)abInBuffer)->dwRemoteAddr = DWORD_RAND;
        ((PFILTER_DRIVER_BINDING_INFO)abInBuffer)->dwMask = DWORD_RAND;

        SetInParam(dwInBuff, sizeof(FILTER_DRIVER_BINDING_INFO));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

        break;

    case IOCTL_DELETE_INTERFACE://
    case IOCTL_DELETE_INTERFACEEX://
/*
typedef struct _FILTER_DRIVER_DELETE_INTERFACE
{
    IN   PVOID   pvDriverContext;
}FILTER_DRIVER_DELETE_INTERFACE, *PFILTER_DRIVER_DELETE_INTERFACE;
*/
        ((PFILTER_DRIVER_DELETE_INTERFACE)abInBuffer)->pvDriverContext = GetDriverContext(this);

        SetInParam(dwInBuff, sizeof(FILTER_DRIVER_DELETE_INTERFACE));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

        break;

    case IOCTL_TEST_PACKET://
/*
typedef struct _FILTER_DRIVER_TEST_PACKET
{
    IN   PVOID            pvInInterfaceContext;
    IN   PVOID            pvOutInterfaceContext;
    OUT  FORWARD_ACTION   eaResult;
    IN   BYTE             bIpPacket[1];
}FILTER_DRIVER_TEST_PACKET, *PFILTER_DRIVER_TEST_PACKET;
*/
        ((PFILTER_DRIVER_TEST_PACKET)abInBuffer)->pvInInterfaceContext = GetDriverContext(this);
        ((PFILTER_DRIVER_TEST_PACKET)abInBuffer)->pvOutInterfaceContext = GetDriverContext(this);
        ((PFILTER_DRIVER_TEST_PACKET)abInBuffer)->bIpPacket[0] = rand();

        SetInParam(dwInBuff, sizeof(FILTER_DRIVER_TEST_PACKET));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(FORWARD_ACTION));

        break;

    case IOCTL_GET_FILTER_INFO://
/*
typedef struct _FILTER_STATS_EX
{
    DWORD       dwNumPacketsFiltered;
    FILTER_INFOEX info;
}FILTER_STATS_EX, *PFILTER_STATS_EX;
*/
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(FILTER_STATS_EX));

        break;

    case IOCTL_GET_FILTER_TIMES:// 
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(FILTER_DRIVER_GET_TIMES));

        break;

    case IOCTL_PF_CREATE_LOG://
/*
typedef struct _PfLog
{
    PFLOGGER pfLogId;
    HANDLE hEvent;
    DWORD dwFlags;        // see LOG_ flags below
} PFLOG, *PPFLOG;
*/
        //
        // in case ctor failed, or I closed it myself
        //
        if (NULL == m_hEvent) m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        ((PPFLOG)abInBuffer)->pfLogId = DWORD_RAND;
        ((PPFLOG)abInBuffer)->hEvent = GetRandomEvent();
        ((PPFLOG)abInBuffer)->dwFlags = rand()%2 ? LOG_LOG_ABSORB : DWORD_RAND;

        SetInParam(dwInBuff, sizeof(PFLOG));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(PFLOG));

        break;

    case IOCTL_PF_DELETE_LOG://
/*
typedef struct _PfDeleteLog
{
    PFLOGGER pfLogId;
} PFDELETELOG, *PPFDELETELOG;
*/
        ((PPFDELETELOG)abInBuffer)->pfLogId = DWORD_RAND;

        SetInParam(dwInBuff, sizeof(PFDELETELOG));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(PFDELETELOG));

        break;

    case IOCTL_PF_CREATE_AND_SET_INTERFACE_PARAMETERS://
/*
typedef enum _PfBindingType
{
    PF_BIND_NONE = 0,
    PF_BIND_IPV4ADDRESS,
    PF_BIND_IPV6ADDRESS,
    PF_BIND_NAME,
    PF_BIND_INTERFACEINDEX
} PFBINDINGTYPE, *PPFBINDINGTYPE;

typedef struct _pfSetInterfaceParameters
{
    PFBINDINGTYPE pfbType;
    DWORD  dwBindingData;
    FORWARD_ACTION eaIn;
    FORWARD_ACTION eaOut;
    FILTER_DRIVER_CREATE_INTERFACE fdInterface;
    DWORD dwInterfaceFlags;
    PFLOGGER pfLogId;
} PFINTERFACEPARAMETERS, *PPFINTERFACEPARAMETERS;
*/
        FillInterfaceParameters(this, (PPFINTERFACEPARAMETERS)abInBuffer);

        SetInParam(dwInBuff, sizeof(PFINTERFACEPARAMETERS));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

        break;

    case IOCTL_SET_LOG_BUFFER://
/*
typedef struct _PfSetBuffer
{
    IN      PFLOGGER pfLogId;
    IN OUT  DWORD dwSize;
    OUT     DWORD dwLostEntries;
    OUT     DWORD dwLoggedEntries;
    OUT     PBYTE pbPreviousAddress;
    IN      DWORD dwSizeThreshold;
    IN      DWORD dwEntriesThreshold;
    IN      DWORD dwFlags;
    IN      PBYTE pbBaseOfLog;
} PFSETBUFFER, *PPFSETBUFFER;
*/
        ((PPFSETBUFFER)abInBuffer)->pfLogId = DWORD_RAND;
        ((PPFSETBUFFER)abInBuffer)->dwSize = sizeof(PFSETBUFFER) + rand()%2 ? rand()%1000 : 0;
        ((PPFSETBUFFER)abInBuffer)->dwSizeThreshold = DWORD_RAND;
        ((PPFSETBUFFER)abInBuffer)->dwEntriesThreshold = DWORD_RAND;
        ((PPFSETBUFFER)abInBuffer)->dwFlags = rand()%2 ? LOG_LOG_ABSORB : DWORD_RAND;

        SetInParam(dwInBuff, sizeof(PFSETBUFFER));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(PFSETBUFFER));

        break;

    case IOCTL_PF_GET_INTERFACE_PARAMETERS://
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(PFINTERFACEPARAMETERS));

        break;

    case IOCTL_SET_INTERFACE_BINDING://
    case IOCTL_CLEAR_INTERFACE_BINDING://
/*
typedef struct _InterfaceBinding
{
    PVOID   pvDriverContext;
    PFBINDINGTYPE pfType;
    DWORD   dwAdd;
    DWORD   dwEpoch;
} INTERFACEBINDING, *PINTERFACEBINDING;
*/
        ((PINTERFACEBINDING)abInBuffer)->pvDriverContext = GetDriverContext(this);
        ((PINTERFACEBINDING)abInBuffer)->pfType = GET_RANDOM_BINDING_TYPE;
        ((PINTERFACEBINDING)abInBuffer)->dwAdd = DWORD_RAND;
        ((PINTERFACEBINDING)abInBuffer)->dwEpoch = DWORD_RAND;

        SetInParam(dwInBuff, sizeof(INTERFACEBINDING));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(INTERFACEBINDING));

        break;

    case IOCTL_GET_SYN_COUNTS://
        SetOutParam(abOutBuffer, dwOutBuff, sizeof(FILTER_DRIVER_GET_SYN_COUNT));

        break;
        
    case IOCTL_PF_DELETE_BY_HANDLE://
//
// IOCTL_PF_DELETE_BY_HANDLE input structure
//
/*
typedef struct _PfDeleteByHandle
{
    PVOID   pvDriverContext;
    PVOID   pvHandles[1];
} PFDELETEBYHANDLE, *PPFDELETEBYHANDLE;
*/
        ((PPFDELETEBYHANDLE)abInBuffer)->pvDriverContext = GetDriverContext(this);
        ((PPFDELETEBYHANDLE)abInBuffer)->pvHandles[0] = GetFilterHandle(this);
        ((PPFDELETEBYHANDLE)abInBuffer)->pvHandles[1] = GetFilterHandle(this);
        ((PPFDELETEBYHANDLE)abInBuffer)->pvHandles[2] = GetFilterHandle(this);
        ((PPFDELETEBYHANDLE)abInBuffer)->pvHandles[3] = GetFilterHandle(this);
        ((PPFDELETEBYHANDLE)abInBuffer)->pvHandles[4] = GetFilterHandle(this);
        ((PPFDELETEBYHANDLE)abInBuffer)->pvHandles[5] = GetFilterHandle(this);
        ((PPFDELETEBYHANDLE)abInBuffer)->pvHandles[6] = GetFilterHandle(this);
        ((PPFDELETEBYHANDLE)abInBuffer)->pvHandles[7] = GetFilterHandle(this);
        ((PPFDELETEBYHANDLE)abInBuffer)->pvHandles[8] = GetFilterHandle(this);
        SetInParam(dwInBuff, sizeof(PFDELETEBYHANDLE));

        break;
        
    case IOCTL_PF_IP_ADDRESS_LOOKUP://
        FillBufferWithRandomData(abInBuffer, dwInBuff);

        SetInParam(dwInBuff, sizeof(DWORD));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(DWORD));

        break;

    default:
        DPF((TEXT("UNEXPECTED: PrepareIOCTLParams(%s) got IOCTL=0x%08X\n"), m_pDevice->GetDeviceName(), dwIOCTL));
        _ASSERTE(FALSE);
    }

}


void CIoctlIpfltrdrv::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    switch(dwIOCTL)
    {
    case IOCTL_CREATE_INTERFACE://
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);

        SetDriverContext(this, ((PFILTER_DRIVER_CREATE_INTERFACE)abOutBuffer)->pvDriverContext);

        break;

    case IOCTL_SET_INTERFACE_FILTERS://
    case IOCTL_SET_INTERFACE_FILTERS_EX://
    case IOCTL_DELETE_INTERFACE_FILTERS_EX://

        break;

    case IOCTL_SET_LATE_BOUND_FILTERS://
    case IOCTL_SET_LATE_BOUND_FILTERSEX://

        break;

    case IOCTL_DELETE_INTERFACE://
    case IOCTL_DELETE_INTERFACEEX://

        break;

    case IOCTL_TEST_PACKET://

        break;

    case IOCTL_GET_FILTER_INFO://
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);

        SetFilterInfo(this, &((PFILTER_STATS_EX)abOutBuffer)->info);

        break;

    case IOCTL_GET_FILTER_TIMES:// 

        break;

    case IOCTL_PF_CREATE_LOG://

        break;

    case IOCTL_PF_DELETE_LOG://

        break;

    case IOCTL_PF_CREATE_AND_SET_INTERFACE_PARAMETERS://

        break;

    case IOCTL_SET_LOG_BUFFER://

        break;

    case IOCTL_PF_GET_INTERFACE_PARAMETERS://

        break;

    case IOCTL_SET_INTERFACE_BINDING://
    case IOCTL_CLEAR_INTERFACE_BINDING://

        break;

    case IOCTL_GET_SYN_COUNTS://

        break;
        
    case IOCTL_PF_DELETE_BY_HANDLE://

        break;
        
    case IOCTL_PF_IP_ADDRESS_LOOKUP://

        break;

    default:
        DPF((TEXT("UNEXPECTED: PrepareIOCTLParams(%s) got IOCTL=0x%08X\n"), m_pDevice->GetDeviceName(), dwIOCTL));
        _ASSERTE(FALSE);
    }
}


BOOL CIoctlIpfltrdrv::FindValidIOCTLs(CDevice *pDevice)
{
    BOOL bRet = TRUE;
    DPF((TEXT("FindValidIOCTLs() %s is known, will use known IOCTLs\n"), pDevice->GetDeviceName()));

    AddIOCTL(pDevice, _IPFLTRDRVR_CTL_CODE(0, METHOD_BUFFERED, FILE_WRITE_ACCESS));
    AddIOCTL(pDevice, _IPFLTRDRVR_CTL_CODE(1, METHOD_BUFFERED, FILE_WRITE_ACCESS));
    AddIOCTL(pDevice, _IPFLTRDRVR_CTL_CODE(2, METHOD_BUFFERED, FILE_WRITE_ACCESS));
    AddIOCTL(pDevice, _IPFLTRDRVR_CTL_CODE(3, METHOD_BUFFERED, FILE_WRITE_ACCESS));
    AddIOCTL(pDevice, _IPFLTRDRVR_CTL_CODE(4, METHOD_BUFFERED, FILE_READ_ACCESS));
    AddIOCTL(pDevice, _IPFLTRDRVR_CTL_CODE(5, METHOD_BUFFERED, FILE_READ_ACCESS));
    AddIOCTL(pDevice, _IPFLTRDRVR_CTL_CODE(6, METHOD_BUFFERED, FILE_READ_ACCESS));
    AddIOCTL(pDevice, _IPFLTRDRVR_CTL_CODE(7, METHOD_BUFFERED, FILE_WRITE_ACCESS));
    AddIOCTL(pDevice, _IPFLTRDRVR_CTL_CODE(8, METHOD_BUFFERED, FILE_WRITE_ACCESS));
    AddIOCTL(pDevice, _IPFLTRDRVR_CTL_CODE(9, METHOD_BUFFERED, FILE_WRITE_ACCESS));
    AddIOCTL(pDevice, _IPFLTRDRVR_CTL_CODE(10, METHOD_BUFFERED, FILE_WRITE_ACCESS));
    AddIOCTL(pDevice, _IPFLTRDRVR_CTL_CODE(11, METHOD_BUFFERED, FILE_WRITE_ACCESS));
    AddIOCTL(pDevice, _IPFLTRDRVR_CTL_CODE(12, METHOD_BUFFERED, FILE_WRITE_ACCESS));
    AddIOCTL(pDevice, _IPFLTRDRVR_CTL_CODE(13, METHOD_BUFFERED, FILE_WRITE_ACCESS));
    AddIOCTL(pDevice, _IPFLTRDRVR_CTL_CODE(14, METHOD_BUFFERED, FILE_WRITE_ACCESS));
    AddIOCTL(pDevice, _IPFLTRDRVR_CTL_CODE(15, METHOD_BUFFERED, FILE_WRITE_ACCESS));
    AddIOCTL(pDevice, _IPFLTRDRVR_CTL_CODE(16, METHOD_BUFFERED, FILE_WRITE_ACCESS));
    AddIOCTL(pDevice, _IPFLTRDRVR_CTL_CODE(17, METHOD_BUFFERED, FILE_WRITE_ACCESS));
    AddIOCTL(pDevice, _IPFLTRDRVR_CTL_CODE(18, METHOD_BUFFERED, FILE_WRITE_ACCESS));
    AddIOCTL(pDevice, _IPFLTRDRVR_CTL_CODE(19, METHOD_BUFFERED, FILE_WRITE_ACCESS));
    AddIOCTL(pDevice, _IPFLTRDRVR_CTL_CODE(20, METHOD_BUFFERED, FILE_WRITE_ACCESS));

    return TRUE;
}



void SetDriverContext(CIoctlIpfltrdrv* pThis, PVOID pvDriverContext)
{
    pThis->m_apvDriverContext[rand()%MAX_NUM_OF_REMEMBERED_DRIVER_CONTEXTS] = pvDriverContext;
}

PVOID GetDriverContext(CIoctlIpfltrdrv* pThis)
{
	if (0 == rand()%10) return CIoctl::GetRandomIllegalPointer();
    return pThis->m_apvDriverContext[rand()%MAX_NUM_OF_REMEMBERED_DRIVER_CONTEXTS];
}

PVOID GetFilterHandle(CIoctlIpfltrdrv* pThis)
{
	if (0 == rand()%10) return CIoctl::GetRandomIllegalPointer();
    return pThis->m_apvFilterHandle[rand()%MAX_NUM_OF_REMEMBERED_FILTER_HANDLES];
}

void SetFilterInfo(CIoctlIpfltrdrv* pThis, FILTER_INFOEX *pFilterInfo)
{
    pThis->m_apvFilterHandle[rand()%MAX_NUM_OF_REMEMBERED_FILTER_HANDLES] = pFilterInfo->pvFilterHandle;
    pThis->m_apvFilterRules[rand()%MAX_NUM_OF_REMEMBERED_FILTER_RULES] = pFilterInfo->dwFilterRule;
    pThis->m_apvFilterFlags[rand()%MAX_NUM_OF_REMEMBERED_FILTER_FLAGS] = pFilterInfo->dwFlags;
}

HANDLE CIoctlIpfltrdrv::GetRandomEvent()
{
    if (rand()%10)
    {
        return m_hEvent;
    }
    if (rand()%2) return (HANDLE)rand();
    return NULL;
}

void CIoctlIpfltrdrv::CallRandomWin32API(LPOVERLAPPED pOL)
{
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\ioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>
#include <time.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <windows.h>

 #include "NtNativeIOCTL.h"

#include "device.h"
#include "IOCTL.h"
*/

#include "ExcptFltr.h"

static bool s_fVerbose = true;

void Mark(){return;}

static VOID CALLBACK FileIOCompletionRoutine(
	DWORD dwErrorCode,                // completion code
	DWORD dwNumberOfBytesTransfered,  // number of bytes transferred
	LPOVERLAPPED lpOverlapped         // I/O information buffer
	)
{
	DPF((TEXT("FileIOCompletionRoutine(): dwErrorCode=0x%08X, dwNumberOfBytesTransfered=%d\n"), dwErrorCode, dwNumberOfBytesTransfered));
}
static VOID NTAPI fnIO_APC_ROUTINE(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    )
{
	DPF((TEXT("fnIO_APC_ROUTINE().\n")));
}

#define NUM_OF_IN_OUT_BUFFERS (32)

WCHAR *FillBufferWithRandomWCHARs(WCHAR *wszBuff, UINT uiLen)
{
	for (UINT i = 0; i < uiLen; i++)
	{
		//
		// mostly valid ansi caracters
		//
		WCHAR wcTemp = rand();
		if (rand()%100)
		{
			wszBuff[i] = (0xEF & wcTemp);
			//
			//
			// weed some more illegar chars, but not always
			//
			if (rand()%5)
			{
				//
				// backslash is a folder seperator. i will usually not be able to 
				// create such a file
				//
				if ((rand()%4) && (TEXT('\\') == wszBuff[i]))
				{
					continue;
				}

				//
				// if these are legal characters. lets try again, and maybe get an illegal char
				//
				if	(
						(rand()%4) && 
						( (33 > wszBuff[i]) || (126 > wszBuff[i]) )
					)
				{
					continue;
				}
			}
		}
		else 
		{
			if (rand()%100)
			{
				//
				// including chars with 8th bit set
				wszBuff[i] = (0xff & wcTemp);
			}
			else 
			{
				//
				// and total random wchars
				wszBuff[i] = (wcTemp);
			}
		}
		//
		// no need to procede after the null
		//
		if (TEXT('\0') == wszBuff[i]) break;
	}//for (UINT i = 0; i < uiLen; i++)

	return wszBuff;
}

UNICODE_STRING *GetRandom_UNICODE_STRING(UNICODE_STRING *pUNICODE_STRING, WCHAR *wszPreferredString)
{
	_ASSERTE(pUNICODE_STRING);
	_ASSERTE(wszPreferredString);

	UNICODE_STRING *pRetval = pUNICODE_STRING;
	LONG lRealStringLen = wcslen(wszPreferredString);

	pUNICODE_STRING->Length = rand()%10 ? lRealStringLen : rand()%2 ? lRealStringLen-2 : rand()%2 ? lRealStringLen+2 : rand()%2 ? lRealStringLen-1 : rand()%2 ? lRealStringLen+1 : rand();
	pUNICODE_STRING->MaximumLength = rand()% 20 ? pRetval->Length + rand()%1000 : rand()%pRetval->Length;

	pUNICODE_STRING->Buffer = (WCHAR*)CIoctl::GetRandomIllegalPointer();
	__try
	{
		wcscpy(pUNICODE_STRING->Buffer, wszPreferredString);
	}
	__except(1)
	{
		;//do not care, but from now, pUNICODE_STRING->Buffer is not trustable
	}



	//
	// illegal pUNICODE_STRING
	//
	if (0 == rand()%20)
	{
		pRetval = (UNICODE_STRING*)CIoctl::GetRandomIllegalPointer();
		__try
		{
			*pRetval = *pUNICODE_STRING;
		}
		__except(1)
		{
			;//do not care, but pRetval is not trustable from now!
		}
	}
	else
	{
		pRetval = pUNICODE_STRING;
	}

	//
	// once i a while, change the string contents
	//
	if (0 == rand()%20)
	{
		__try
		{
			//
			// remove the terminating NULL
			//
			if (0 == rand()%10)
			{
				pRetval->Buffer[lRealStringLen] = L'M';// M for MMMMicky.
				return pRetval;
			}
			
			FillBufferWithRandomWCHARs(pRetval->Buffer, rand());
			lRealStringLen = wcslen(pRetval->Buffer);
			pRetval->Length = rand()%10 ? lRealStringLen : rand()%2 ? lRealStringLen-2 : rand()%2 ? lRealStringLen+2 : rand()%2 ? lRealStringLen-1 : rand()%2 ? lRealStringLen+1 : rand();
			pRetval->MaximumLength = pRetval->Length + rand()%1000;
		}
		__except(1)
		{
			;//do not care
		}
	}
	return pRetval;
}

DWORD WINAPI IoctlThread(LPVOID pVoid)
{
//__try{
    static long s_lThreadCount = 0;

    long lThisThreadIndex = InterlockedIncrement(&s_lThreadCount);
    CIoctl *pThis = (CIoctl*)pVoid;
    BYTE *aabAllocatedInBuffer[NUM_OF_IN_OUT_BUFFERS];
    BYTE *aabAllocatedOutBuffer[NUM_OF_IN_OUT_BUFFERS];
    BYTE *pbInBuffer = NULL;
    BYTE *pbOutBuffer = NULL;
	DWORD dwInBuff = SIZEOF_INOUTBUFF;
	DWORD dwOutBuff = SIZEOF_INOUTBUFF;

	DWORD dwTimesTried = 0;
    DWORD dwBytesReturned;
    int nOLIter;
    int nOLIndex = 0;
    OVERLAPPED *aOL = NULL;
	DWORD dwCurrentThreadId = ::GetCurrentThreadId();

	ZeroMemory(aabAllocatedInBuffer, sizeof(aabAllocatedInBuffer));
	ZeroMemory(aabAllocatedOutBuffer, sizeof(aabAllocatedOutBuffer));
	//
	// i must allocate these buffers, and i'm lazy counting
	//
	for (int nBuffIndex = 0; nBuffIndex < NUM_OF_IN_OUT_BUFFERS; nBuffIndex++)
	{
		while (NULL == (aabAllocatedInBuffer[nBuffIndex] = (BYTE*)::VirtualAlloc(
			NULL,// region to reserve or commit
			SIZEOF_INOUTBUFF,// size of region
			MEM_COMMIT,// type of allocation
			PAGE_READWRITE// type of access protection
			)))
		//while (NULL == (aabAllocatedInBuffer[nBuffIndex] = new BYTE[SIZEOF_INOUTBUFF]))
		{
			if (pThis->m_pDevice->sm_fExitAllThreads || pThis->m_pDevice->m_fShutDown || pThis->m_pDevice->m_fDeviceThreadExiting) goto out;
			::Sleep(100);
			DPF((TEXT("i")));
		}
		while (NULL == (aabAllocatedOutBuffer[nBuffIndex] = (BYTE*)::VirtualAlloc(
			NULL,// region to reserve or commit
			SIZEOF_INOUTBUFF,// size of region
			MEM_COMMIT,// type of allocation
			PAGE_READWRITE// type of access protection
			)))
		//while (NULL == (aabAllocatedOutBuffer[nBuffIndex] = new BYTE[SIZEOF_INOUTBUFF]))
		{
			if (pThis->m_pDevice->sm_fExitAllThreads || pThis->m_pDevice->m_fShutDown || pThis->m_pDevice->m_fDeviceThreadExiting) goto out;
			::Sleep(100);
			DPF((TEXT("o")));
		}
	}

	do
	{
		if (pThis->m_pDevice->sm_fExitAllThreads || pThis->m_pDevice->m_fShutDown || pThis->m_pDevice->m_fDeviceThreadExiting) goto out;

		//TODO: convert new to VirtualAlloc
		if (NULL == (aOL = new OVERLAPPED[pThis->m_pDevice->m_nOverlappedStructureCount]))
		{
			::Sleep(100);
			dwTimesTried++;
		}
	}while((NULL == aOL) && (dwTimesTried << 10000));

    if (NULL == aOL)
    {
        DPF((TEXT("IoctlThread(): new OVERLAPPED[%d] failed\n"), pThis->m_pDevice->m_nOverlappedStructureCount));
        goto out;
    }

    ZeroMemory(aOL, sizeof(OVERLAPPED) * pThis->m_pDevice->m_nOverlappedStructureCount);

    for (nOLIter = 0; nOLIter < pThis->m_pDevice->m_nOverlappedStructureCount; nOLIter++)
    {
		if (pThis->m_pDevice->sm_fExitAllThreads || pThis->m_pDevice->m_fShutDown || pThis->m_pDevice->m_fDeviceThreadExiting) goto out;

        if (!pThis->PrepareOverlappedStructure(&aOL[nOLIter]))
        {
            DPF((TEXT("IoctlThread(): PrepareOverlappedStructure(&aOL[%d]) failed with %d\n"), nOLIter, GetLastError()));
            goto out;
        }
    }

    if (!pThis->SetSrandFile(lThisThreadIndex))
    {
		//
		// no need to bail out, since we want to be fault-injection compliant
		//
        //goto out;
    }

    //
    // call the legal IOCTLS randomly, almost infinitely. only user intervention (^C)
	// or the self terminating thread can stop this
    //
    DPF((TEXT("before stressing driver entry points\n")));
    Sleep(1000); //?
	nBuffIndex = -1;// it will inc 1st, so it will start from 0

    while (!pThis->m_pDevice->sm_fExitAllThreads || pThis->m_pDevice->m_fShutDown && !pThis->m_pDevice->m_fDeviceThreadExiting)
    {
		//
		// use the next buffers for IN/OUT buffs.
		// this is so the next loop will not override these buffs.
		// they may be overrided, but using the cyclic array of buffs reduces
		// the probablility for this
		//
		nBuffIndex++;
		if (NUM_OF_IN_OUT_BUFFERS == nBuffIndex)
		{
			nBuffIndex = 0;
		}

        nOLIndex = (nOLIndex+1)%pThis->m_pDevice->m_nOverlappedStructureCount;

		//
		// once every 100 iteration, fill the input buffer with random data,
		// because some derived classes may "forget" to touch it, and so i will
		// lose the feature of sending random data.
		//
		if (0 == rand()%100)
		{
			DWORD dwCount = SIZEOF_INOUTBUFF;
			pThis->FillBufferWithRandomData(aabAllocatedInBuffer[nBuffIndex], dwCount);
		}
		
		//
		// if a request to stop IOCTELOLING was issued, wait until it is ok to resume
		//
        while(pThis->m_pDevice->m_fStopIOCTELLING)
        {
            if (pThis->m_pDevice->sm_fExitAllThreads || pThis->m_pDevice->m_fShutDown || pThis->m_pDevice->m_fDeviceThreadExiting)
            {
                goto out;
            }

            Sleep(0);
        }

        //
        // note that all pending IO's use the same OL per thread, so these settings
        // are not "persistent", since next loop can cahge them
        //
        aOL[nOLIndex].Offset = rand()%10 ? 0 : DWORD_RAND;
        aOL[nOLIndex].OffsetHigh = rand()%100 ? 0 : DWORD_RAND;
        if (0 == rand()%10)
        {
            if (!ResetEvent(aOL[nOLIndex].hEvent))
            {
                DPF((TEXT("IoctlThread(): ResetEvent(aOL[%d].hEvent) failed with %d\n"), nOLIndex, GetLastError()));
            }
        }

        DWORD dwWrittenRead;
        DWORD dwAmoutToReadWrite;
        if (pThis->m_pDevice->m_fDeviceThreadExiting)
        {
            DPF((TEXT("IoctlThread(%s), accepted pThis->m_pDevice->m_fDeviceThreadExiting\n"), pThis->m_pDevice->GetDeviceName()));
            goto out;
        }

        //
        // now do any of the following: read, write, IOCTL
        //
        if (
			(-1 == pThis->m_pDevice->m_dwOnlyThisIndexIOCTL) && 
			(pThis->m_pDevice->m_nWriteFileProbability > rand()%100)
			)
        {
			dwInBuff = SIZEOF_INOUTBUFF;
			dwOutBuff = SIZEOF_INOUTBUFF;
			pbInBuffer = aabAllocatedInBuffer[nBuffIndex];
			pbOutBuffer = aabAllocatedOutBuffer[nBuffIndex];

			if (pThis->m_pDevice->m_nBreakAlignmentProbability > rand()%100)
			{
				pbInBuffer += rand()%8;
				pbOutBuffer += rand()%8;
			}

            dwAmoutToReadWrite = rand()%SIZEOF_INOUTBUFF;
			pbInBuffer = pThis->FixupInOutBuffToEndOnEndOfPhysicalPage(aabAllocatedInBuffer[nBuffIndex], dwAmoutToReadWrite);
			if (pThis->m_pDevice->m_nCauseInOutBufferOverflowMustUsePageHeapProbability > rand()%100)
			{
				//
				// BUGBUG: assuming pages not larger than 400 bytes...
				//
				pbInBuffer += 4 + 4*(rand()%100);
			}

			if (2 > rand()%100)
			{
				//
				// once in a while, give a kernel address
				//
				pbInBuffer = (BYTE *)(0x80000000 | DWORD_RAND);
			}

			//
			// once in a while, fix the buffer to be huge
			//
			if (0 == rand()%50)
			{
				pbInBuffer = CDevice::s_abHugeBuffer;
				dwAmoutToReadWrite = sizeof(CDevice::s_abHugeBuffer);
			}

			if (pThis->m_pDevice->m_nTryDeCommittedBuffersProbability > rand()%100)
			{
				// TODO: replace sm_aCommitDecommitBuffs with CIoctl::GetRandomIllegalPointer()
				pbInBuffer = (unsigned char*)pThis->m_pDevice->sm_aCommitDecommitBuffs[rand()%NUM_OF_ALLOC_AND_FREE_BUFFS];
			}

			if (!pThis->m_fUseOverlapped || rand()%2)
			{
				if (!pThis->DeviceWriteFile(
						pThis->m_pDevice->m_hDevice,
						pbInBuffer,
						dwAmoutToReadWrite,
						&dwWrittenRead,
						pThis->m_fUseOverlapped ? &aOL[nOLIndex] : NULL
					))
				{
					DPF((TEXT("WriteFile(%s, %d) failed with %d\n"), pThis->m_pDevice->m_szDevice, dwAmoutToReadWrite, GetLastError()));
				}
				else
				{
					DPF((TEXT("WriteFile(%s, %d) succeeded\n"), pThis->m_pDevice->m_szDevice, dwAmoutToReadWrite));
				}
			}
			else
			{
				if (!WriteFileEx(
						pThis->m_pDevice->m_hDevice,
						pbInBuffer,
						dwAmoutToReadWrite,
						&aOL[nOLIndex],
						FileIOCompletionRoutine
					))
				{
					DPF((TEXT("WriteFileEx(%s, %d) failed with %d\n"), pThis->m_pDevice->m_szDevice, dwAmoutToReadWrite, GetLastError()));
				}
				else
				{
					DPF((TEXT("WriteFileEx(%s, %d) succeeded\n"), pThis->m_pDevice->m_szDevice, dwAmoutToReadWrite));
				}
			}
        }


        if (
			(-1 == pThis->m_pDevice->m_dwOnlyThisIndexIOCTL) && 
			(pThis->m_pDevice->m_nReadFileProbability > rand()%100)
			)
        {
			dwInBuff = SIZEOF_INOUTBUFF;
			dwOutBuff = SIZEOF_INOUTBUFF;
			pbInBuffer = aabAllocatedInBuffer[nBuffIndex];
			pbOutBuffer = aabAllocatedOutBuffer[nBuffIndex];

			if (pThis->m_pDevice->m_nBreakAlignmentProbability > rand()%100)
			{
				pbInBuffer += rand()%8;
				pbOutBuffer += rand()%8;
			}

            dwAmoutToReadWrite = rand()%SIZEOF_INOUTBUFF;
			pbOutBuffer = pThis->FixupInOutBuffToEndOnEndOfPhysicalPage(aabAllocatedOutBuffer[nBuffIndex], dwAmoutToReadWrite);
			if (pThis->m_pDevice->m_nCauseInOutBufferOverflowMustUsePageHeapProbability > rand()%100)
			{
				//
				// BUGBUG: assuming pages not larger than 400 bytes...
				//
				pbOutBuffer += 4 + 4*(rand()%100);
			}

			if (2 > rand()%100)
			{
				//
				// once in a while, give a kernel address
				//
				pbOutBuffer = (BYTE *)(0x80000000 | DWORD_RAND);
			}

			//
			// once in a while, fix the buffer to be huge
			//
			if (0 == rand()%50)
			{
				pbOutBuffer = CDevice::s_abHugeBuffer;
				dwAmoutToReadWrite = sizeof(CDevice::s_abHugeBuffer);
			}

			if (pThis->m_pDevice->m_nTryDeCommittedBuffersProbability > rand()%100)
			{
				pbOutBuffer = (unsigned char*)pThis->m_pDevice->sm_aCommitDecommitBuffs[rand()%NUM_OF_ALLOC_AND_FREE_BUFFS];
				//
				// do not want to write randomly into my own memory
				//
				dwAmoutToReadWrite = rand()%SIZEOF_INOUTBUFF;
			}

			if (!pThis->m_fUseOverlapped || rand()%2)
			{
				if (!pThis->DeviceReadFile(
						pThis->m_pDevice->m_hDevice,
						pbOutBuffer,
						dwAmoutToReadWrite,
						&dwWrittenRead,
						pThis->m_fUseOverlapped ? &aOL[nOLIndex] : NULL
					))
				{
					DPF((TEXT("ReadFile(%s, %d) failed with %d\n"), pThis->m_pDevice->m_szDevice, dwAmoutToReadWrite, GetLastError()));
				}
				else
				{
					DPF((TEXT("ReadFile(%s, %d) succeeded\n"), pThis->m_pDevice->m_szDevice, dwAmoutToReadWrite));
				}
			}
			else
			{
				if (!ReadFileEx(
						pThis->m_pDevice->m_hDevice,
						pbOutBuffer,
						dwAmoutToReadWrite,
						&aOL[nOLIndex],
						FileIOCompletionRoutine
					))
				{
					DPF((TEXT("ReadFileEx(%s, %d) failed with %d\n"), pThis->m_pDevice->m_szDevice, dwAmoutToReadWrite, GetLastError()));
				}
				else
				{
					DPF((TEXT("ReadFileEx(%s, %d) succeeded\n"), pThis->m_pDevice->m_szDevice, dwAmoutToReadWrite));
				}
			}
        }


        dwInBuff = SIZEOF_INOUTBUFF;
        dwOutBuff = SIZEOF_INOUTBUFF;
        pbInBuffer = aabAllocatedInBuffer[nBuffIndex];
        pbOutBuffer = aabAllocatedOutBuffer[nBuffIndex];

		if(pThis->m_pDevice->m_nRandomWin32APIProbability > rand()%100)
        {
	        pThis->CallRandomWin32API(&aOL[nOLIndex]);
		}

		if (pThis->m_pDevice->m_nDeviceIoControlProbability > rand()%100)
        {
			DWORD dwIOCTL;

			//
			// deal with case of m_dwOnlyThisIndexIOCTL
			// 
			if (-1 != pThis->m_pDevice->m_dwOnlyThisIndexIOCTL)
			{
				if ((pThis->m_pDevice->m_dwOnlyThisIndexIOCTL > 0) &&
					(pThis->m_pDevice->m_dwOnlyThisIndexIOCTL >= (DWORD)pThis->m_pDevice->m_iMaxFreeLegalIOCTL))
				{
					DPF((TEXT("EXITING! IoctlThread(): pThis->m_pDevice->dwOnlyThisIndexIOCTL(%d) >= pThis->m_pDevice->iMaxFreeLegalIOCTL(%d)\n"), pThis->m_pDevice->m_dwOnlyThisIndexIOCTL, pThis->m_pDevice->m_iMaxFreeLegalIOCTL));
					_ASSERTE(FALSE);
					goto out;
				}

				dwIOCTL = pThis->m_pDevice->m_adwLegalIOCTLs[pThis->m_pDevice->m_dwOnlyThisIndexIOCTL];
			}
			else
			{
				if (pThis->m_fUseRandomIOCTLValues)
				{
					dwIOCTL = DWORD_RAND;
				}
				else
				{
					_ASSERTE(pThis->m_pDevice->m_iMaxFreeLegalIOCTL);
					dwIOCTL = pThis->m_pDevice->m_adwLegalIOCTLs[rand()%pThis->m_pDevice->m_iMaxFreeLegalIOCTL];
				}
			}

			pThis->PrepareIOCTLParams(dwIOCTL, pbInBuffer, dwInBuff, pbOutBuffer, dwOutBuff);
			//
			// because SIZEOF_INOUTBUFF is (RAND_MAX-1), and in many places i set the buff size
			// to rand(), it may be set to RAND_MAX, which is off by one...
			// I can change SIZEOF_INOUTBUFF to RAND_MAX, but i do not remember why i decremented
			// by 1, so instead, i will truncate the buff size to SIZEOF_INOUTBUFF, if it is RAND_MAX
			//
			if (RAND_MAX == dwInBuff) dwInBuff = SIZEOF_INOUTBUFF;
			if (RAND_MAX == dwOutBuff) dwOutBuff = SIZEOF_INOUTBUFF;
			//
			// and besides, the buff sizes cannot be bigger
			//
			_ASSERTE(SIZEOF_INOUTBUFF >= dwInBuff);
			_ASSERTE(SIZEOF_INOUTBUFF >= dwOutBuff);
			//
			// note that i may/will copy the input buffer, because i may want to put it 
			// at the end of a buffer, or in a decommitted buffer
			// note that there may be conflicting requirements, such as break alignment
			// and page heap, etc.
			// need to be carefull to keep the input buffer contents, so that the IOCTL
			// will not be so easily rejected
			//
			
			//DWORD dwFs, dwEsp;

			if (
				(pThis->m_pDevice->m_nTryDeCommittedBuffersProbability > rand()%100) &&
				pbInBuffer // if PrepareIOCTLParams want NULL, i do not override it
				)
			{
				DWORD dwInputBufferRandomIndex = rand()%NUM_OF_ALLOC_AND_FREE_BUFFS;
				bool fAV = true;
				//
				// pageheap
				//
				BYTE* pvStartOfBuffInDecommittedBuff = pThis->m_pDevice->sm_aCommitDecommitBuffs[dwInputBufferRandomIndex]+SIZEOF_INOUTBUFF-dwInBuff;
				if (pThis->m_pDevice->m_nBreakAlignmentProbability > rand()%100)
				{
					//
					// i will subtract, in order not to overflow, but this may also cause underflow, so be carefull.
					// 
					pvStartOfBuffInDecommittedBuff = (BYTE*)((UINT)pvStartOfBuffInDecommittedBuff - ((dwInBuff - SIZEOF_INOUTBUFF)%8));
				}
				if (pThis->m_pDevice->m_nCauseInOutBufferOverflowMustUsePageHeapProbability > rand()%100)
				{
					//
					// i will add, in order to overflow, but this may not work due to above decrement
					//
					pvStartOfBuffInDecommittedBuff = (BYTE*)((UINT)pvStartOfBuffInDecommittedBuff + rand()%10);
				}
				//
				// since the buffer may be decommitted, i must protect myself
				// also, if i'm copying, why not put at the end of the buffer?
				// so if the size is bogus, i will AV
				//
//				Mark();
				//DPF((TEXT("B")));
				__try
				{
					//DPF((TEXT("b")));
					CopyMemory(
						pvStartOfBuffInDecommittedBuff, 
						pbInBuffer, 
						dwInBuff
						);
					fAV = false;
					//DPF((TEXT("a")));
				}__except(1){;}
				//DPF((TEXT("A")));
				if (fAV) 
				{
					DPF((TEXT("-AV-")));
				}
				else
				{
					DPF((TEXT("-OK-")));
				}
//				Mark();
				pbInBuffer = pvStartOfBuffInDecommittedBuff;
				pbOutBuffer = pThis->m_pDevice->sm_aCommitDecommitBuffs[rand()%NUM_OF_ALLOC_AND_FREE_BUFFS]+SIZEOF_INOUTBUFF-dwOutBuff;
			}
			else // not using decommitted buffers
			{
				//
				// pageheap
				//
				BYTE* pvShiftedInBuff = pbInBuffer+SIZEOF_INOUTBUFF-dwInBuff;
				if (pThis->m_pDevice->m_nBreakAlignmentProbability > rand()%100)
				{
					//
					// i will subtract, in order not to overflow, but this may also cause underflow, so be carefull.
					// 
					pvShiftedInBuff = (BYTE*)((UINT)pvShiftedInBuff - ((dwInBuff - SIZEOF_INOUTBUFF)%8));
					MoveMemory(
						pvShiftedInBuff, 
						pbInBuffer, 
						dwInBuff
						);
					pbInBuffer = pvShiftedInBuff;
				}
				else
				{
					if (pThis->m_pDevice->m_nCauseInOutBufferOverflowMustUsePageHeapProbability > rand()%100)
					{
						//
						// i will add, in order to overflow
						//
						pvShiftedInBuff = (BYTE*)((UINT)pvShiftedInBuff + rand()%10);
						__try
						{
							MoveMemory(
								pvShiftedInBuff, 
								pbInBuffer, 
								dwInBuff
								);
						}__except(1)
						{
							NOTHING;
						}
						pbInBuffer = pvShiftedInBuff;
					}
				}
			}

			//
			// I am not sure this is usefull, but lets change the IOCTL Access and Method
			// once in a while
			//
#define CHANGE_2_BITS(dw_2_Bits)\
	{\
		DWORD dwOriginalValue = dw_2_Bits;\
		while((dw_2_Bits = (rand()%0x3)) == dwOriginalValue)\
		{\
			; \
		}\
	}
			if (2 > rand()%100)
			{
				//
				// remember the original values
				//
				DWORD dwAccess = ((dwIOCTL&0x0000C000)>>14);
				DWORD dwMethod = (dwIOCTL&0x00000003);
				//
				// zero the values
				//
				dwIOCTL &= 0xffff3ffc;
				//
				// change to new values
				//
				CHANGE_2_BITS(dwAccess);
				CHANGE_2_BITS(dwMethod);
				//
				// apply the new values
				//
				dwIOCTL |= ((dwAccess) << 14);
				dwIOCTL |= dwMethod;
			}


			//
			// i love zero length buffers, so i will not trust the derived classes to do this
			//
			if (0 == rand()%100) dwInBuff = 0;
			if (0 == rand()%100) dwOutBuff = 0;

			bool fEnlargingBuffers = false;
			bool fUsingHugeBuffers = false;
retry_DeviceInputOutputControl:
			if (!pThis->DeviceInputOutputControl(
					pThis->m_pDevice->m_hDevice,         // handle to device of interest
					dwIOCTL,  // control code of operation to perform
					pbInBuffer,      // pointer to buffer to supply input data
					dwInBuff, // size of input buffer
					pbOutBuffer,     // pointer to buffer to receive output data
					dwOutBuff, // size of output buffer
					&dwBytesReturned,  // pointer to variable to receive output                            // byte count
					pThis->m_fUseOverlapped ? &aOL[nOLIndex] : NULL   // pointer to overlapped structure for asynchronous operation
					))
			{
				//DPF((TEXT("%d - DeviceIoControl(%s, 0x%08X) failed with %d\n"), GetTickCount(), pThis->m_pDevice->m_szDevice, dwIOCTL, GetLastError()));
				DPF((TEXT("%d - DeviceIoControl(%s, 0x%08X) failed with %d\n"), GetTickCount(), pThis->m_pDevice->m_szDevice, dwIOCTL, GetLastError()));
				//DPFLUSH();
				DWORD dwLastError = GetLastError();
				//DPF((TEXT("-%d-"), dwLastError));
				//
				// if the IO is pending, give the derived class of the IOCTL a chance 
				// to handle this call, meaning to wait for it, and use its result.
				// other errors are just not interesting
				//
				if (ERROR_IO_PENDING == dwLastError)
				{
					//
					// since out buff may be decommitted, i cannot trust it
					//
					__try
					{
						pThis->UseOutBuff(dwIOCTL, pbOutBuffer, dwBytesReturned, &aOL[nOLIndex]);
					}__except(1)
					{
						//
						// sorry, but if i am using decommitted buffer, 
						// the output buffer is not trustable
						//
					}
				}
				else
				{

					//
					// sometimes more data is needed, but what exists is enough.
					// this is risky, because the implementor of UseOutBuff() may
					// not be aware of this, but then, in my opinion, if the caller
					// gets garbage data, it should not harm anything, because
					// the programming paradigm is such that anything can fail
					// TODO: should i retry with dwOutBuff=dwBytesReturned ?
					//
					if (ERROR_MORE_DATA == dwLastError)
					{
						//
						// this means that there may be data for me, but
						// since out buff may be decommitted, i cannot trust it
						//
						__try
						{
							pThis->UseOutBuff(dwIOCTL, pbOutBuffer, dwBytesReturned, NULL);
						}__except(1)
						{
							//
							// sorry, but if i am using decommitted buffer, 
							// the output buffer is not trustable
							//
						}
					}
					else
					{

						//
						// if the out buff is not enough, say it's bigger, untill 'success', or
						// my buff is not big enough
						//
						if  (
							(ERROR_INSUFFICIENT_BUFFER == dwLastError) ||
							(ERROR_BUFFER_OVERFLOW == dwLastError)
							)
						{
							//
							// i must 1st restore the buffers to be 'normal' buffers, because they could have
							// been fixed up etc., so i restore them, and start looping until the buffs lengths
							// are ok
							//

							//
							// first, check if i already used the CDevice::s_abHugeBuffer last resort.
							// if so, i may *not* keep trying
							//
							if (fUsingHugeBuffers)
							{
								_ASSERTE(
									(sizeof(CDevice::s_abHugeBuffer) == dwInBuff) &&
									(sizeof(CDevice::s_abHugeBuffer) == dwOutBuff)
									);
								//
								// break the retry_DeviceInputOutputControl loop
								//
							}
							else
							{
								//
								// we did not yet use the CDevice::s_abHugeBuffer last resort
								//

								if (!fEnlargingBuffers)
								{
									fEnlargingBuffers = true;
									//
									// this is the 1st time we try to enlarge the buffer
									// copy its contents to aabAllocatedInBuffer[nBuffIndex]
									// in order to preserve its contents.
									// this must be gurded, since the original buffer may have been decommitted
									//
									__try
									{
										MoveMemory(aabAllocatedInBuffer[nBuffIndex], pbInBuffer, dwInBuff);
									}__except(1)
									{
										;//can surely happen
									}
									pbInBuffer = aabAllocatedInBuffer[nBuffIndex];
									pbOutBuffer = aabAllocatedOutBuffer[nBuffIndex];
								}
								else
								{
									//
									// the buffers already point to aabAllocatedXXBuffer
									//
									_ASSERTE(pbOutBuffer == aabAllocatedOutBuffer[nBuffIndex]);
									_ASSERTE(pbOutBuffer == aabAllocatedOutBuffer[nBuffIndex]);
								}

								//
								// bufferes copied, just say they are larger, but no more than SIZEOF_INOUTBUFF
								// if they are larger, use the last resort of s_abHugeBuffer
								//
								if ( 
									(SIZEOF_INOUTBUFF > dwOutBuff) ||
									(SIZEOF_INOUTBUFF > dwInBuff) 
									)
								{
									dwOutBuff++;
									dwInBuff++;
									//
									// make sure that none will overflow
									//
									dwOutBuff = min(dwOutBuff, SIZEOF_INOUTBUFF);
									dwInBuff = min(dwInBuff, SIZEOF_INOUTBUFF);
								}
								else
								{
									DPF((
										TEXT("IoctlThread(): dwLastError=%d, using CDevice::s_abHugeBuffer, dwIOCTL=0x%08X\n"),
										dwLastError,
										dwIOCTL
										));
									__try
									{
										//
										// BUGBUG: since CDevice::s_abHugeBuffer is static, another thread may try to
										// write to it. if so, bad luck, but no harm done.
										// I just do not want to allocate that much memory for each thread.
										//
										MoveMemory(CDevice::s_abHugeBuffer, pbInBuffer, dwInBuff);
									}__except(1)
									{
										;//can surely happen
									}
									pbInBuffer = CDevice::s_abHugeBuffer;
									pbOutBuffer = CDevice::s_abHugeBuffer;
									dwInBuff = sizeof(CDevice::s_abHugeBuffer);
									dwOutBuff = sizeof(CDevice::s_abHugeBuffer);
									fUsingHugeBuffers = true;
								}

								goto retry_DeviceInputOutputControl;
							}//else of if (fUsingHugeBuffers)
						}// if  ((ERROR_INSUFFICIENT_BUFFER == dwLastError) || (ERROR_BUFFER_OVERFLOW == dwLastError))
					}// else of if (ERROR_MORE_DATA == dwLastError)
				}// else of if (ERROR_IO_PENDING == dwLastError)
			}
			else //if (!pThis->DeviceInputOutputControl
			{
				//DPF((TEXT("-SUCC-")));
				//DPF((TEXT("DeviceIoControl(%s, 0x%08X) succeeded\n"), pThis->m_pDevice->m_szDevice, dwIOCTL));
				DPF((TEXT("DeviceIoControl(%s, 0x%08X) succeeded\n"), pThis->m_pDevice->m_szDevice, dwIOCTL));
				//
				// passing NULL OVERLAPPED, because the call was synchronous, and 
				// since out buff may be decommitted, i cannot trust it
				//
				__try
				{
					pThis->UseOutBuff(dwIOCTL, pbOutBuffer, dwBytesReturned, NULL);
				}__except(1)
				{
					//
					// sorry, but if i am using decommitted buffer, 
					// the output buffer is not trustable
					//
				}
			}//else of if (!pThis->DeviceInputOutputControl
		}//if (pThis->m_pDevice->m_nDeviceIoControlProbability > rand()%100)

//continue_ioctelling:
        //
        // since they may have changed to NULL, i must revert them
        //
        pbInBuffer = aabAllocatedInBuffer[nBuffIndex];
        pbOutBuffer = aabAllocatedOutBuffer[nBuffIndex];

        if (pThis->m_pDevice->m_nCancelIoProbability > rand()%100) 
		{
			pThis->DeviceCancelIo(pThis->m_pDevice->m_hDevice); //do not care if fail
		}

		//
		// NtQueryVolumeInformationFile
		//
        if (pThis->m_pDevice->m_nQueryVolumeInformationFileProbability > rand()%100)
        {
			pbInBuffer = aabAllocatedInBuffer[nBuffIndex];
			pbOutBuffer = aabAllocatedOutBuffer[nBuffIndex];
			ULONG Length = rand()%SIZEOF_INOUTBUFF;
			if (!pThis->DeviceQueryVolumeInformationFile(
					pThis->m_pDevice->m_hDevice, 
					&aOL[nOLIndex],
					pbOutBuffer,
					Length,
					(FS_INFORMATION_CLASS)CIoctlNtNative::GetRandom_FsInformationClass())
					)
			{
				DPF((TEXT("DeviceQueryVolumeInformationFile(%s) failed with %d\n"), pThis->m_pDevice->m_szDevice, ::GetLastError()));
			}
		}

		//
		// NtQueryInformationFile
		//
        if (pThis->m_pDevice->m_nQueryInformationFileProbability > rand()%100)
		{
			pbInBuffer = aabAllocatedInBuffer[nBuffIndex];
			pbOutBuffer = aabAllocatedOutBuffer[nBuffIndex];
			ULONG Length = rand()%SIZEOF_INOUTBUFF;
			if (!pThis->DeviceQueryInformationFile(
					pThis->m_pDevice->m_hDevice, 
					&aOL[nOLIndex],
					pbOutBuffer,
					Length,
					(FILE_INFORMATION_CLASS)CIoctlNtNative::GetRandom_FileInformationClass())
					)
			{
				DPF((TEXT("DeviceQueryInformationFile(%s) failed with %d\n"), pThis->m_pDevice->m_szDevice, ::GetLastError()));
			}
			else
			{
				DPF((TEXT("DeviceQueryInformationFile(%s) SUCCEEDED\n"), pThis->m_pDevice->m_szDevice));
			}
		}
		//
		// NtSetInformationFile
		//
        if (pThis->m_pDevice->m_nSetInformationFileProbability > rand()%100)
		{
			pbInBuffer = aabAllocatedInBuffer[nBuffIndex];
			pbOutBuffer = aabAllocatedOutBuffer[nBuffIndex];
			ULONG Length = rand()%SIZEOF_INOUTBUFF;
			if (!pThis->DeviceSetInformationFile(
					pThis->m_pDevice->m_hDevice, 
					&aOL[nOLIndex],
					pbInBuffer,
					Length,
					(FILE_INFORMATION_CLASS)CIoctlNtNative::GetRandom_FileInformationClass())
					)
			{
				DPF((TEXT("DeviceSetInformationFile(%s) failed with %d\n"), pThis->m_pDevice->m_szDevice, ::GetLastError()));
			}
			else
			{
				DPF((TEXT("DeviceSetInformationFile(%s) SUCCEEDED\n"), pThis->m_pDevice->m_szDevice));
			}
		}

		//
		// NtQueryDirectoryFile
		//
        if (pThis->m_pDevice->m_nQueryDirectoryFileProbability > rand()%100)
		{
			pbInBuffer = aabAllocatedInBuffer[nBuffIndex];
			pbOutBuffer = aabAllocatedOutBuffer[nBuffIndex];
			ULONG Length = rand()%SIZEOF_INOUTBUFF;
			static UNICODE_STRING s_FileName;
			if (!pThis->DeviceQueryDirectoryFile(
					pThis->m_pDevice->m_hDevice, 
					(PIO_APC_ROUTINE)0x123, //fnIO_APC_ROUTINE, //rand()%3 ? fnIO_APC_ROUTINE : (PIO_APC_ROUTINE)CIoctl::GetRandomIllegalPointer(),//IN PIO_APC_ROUTINE ApcRoutine OPTIONAL
					CIoctl::GetRandomIllegalPointer(), //IN PVOID ApcContext OPTIONAL
					&aOL[nOLIndex],
					pbOutBuffer,
					Length,
					(FILE_INFORMATION_CLASS)CIoctlNtNative::GetRandom_FileInformationClass(),
					0 == rand()%10, //IN BOOLEAN ReturnSingleEntry
					GetRandom_UNICODE_STRING(&s_FileName, L"Preferred String"), //IN PUNICODE_STRING FileName OPTIONAL,
					0 == rand()%20 // IN BOOLEAN RestartScan
					))
			{
				DPF((TEXT("DeviceQueryDirectoryFile(%s) failed with %d\n"), pThis->m_pDevice->m_szDevice, ::GetLastError()));
			}
			else
			{
				DPF((TEXT("DeviceQueryDirectoryFile(%s) SUCCEEDED\n"), pThis->m_pDevice->m_szDevice));
			}
		}

		//
		// NtQueryFullAttributesFile
		//
        if (pThis->m_pDevice->m_nQueryFullAttributesFileProbability > rand()%100)
		{
			pbInBuffer = aabAllocatedInBuffer[nBuffIndex];
			pbOutBuffer = aabAllocatedOutBuffer[nBuffIndex];
			ULONG Length = rand()%SIZEOF_INOUTBUFF;
			static UNICODE_STRING s_FileName;
			if (!pThis->DeviceQueryFullAttributesFile(
					pThis->m_pDevice->GetDeviceName(),
					(FILE_NETWORK_OPEN_INFORMATION*)pbOutBuffer
					))
			{
				DPF((TEXT("DeviceQueryFullAttributesFile(%s) failed with %d\n"), pThis->m_pDevice->m_szDevice, ::GetLastError()));
			}
			else
			{
				DPF((TEXT("DeviceQueryFullAttributesFile() SUCCEEDED\n")));
			}
		}
///*
		//
		// NtNotifyChangeDirectoryFile
		//
        if (pThis->m_pDevice->m_nNotifyChangeDirectoryFileProbability > rand()%100)
		{
			pbInBuffer = aabAllocatedInBuffer[nBuffIndex];
			pbOutBuffer = aabAllocatedOutBuffer[nBuffIndex];
			ULONG Length = rand()%SIZEOF_INOUTBUFF;
			static UNICODE_STRING s_FileName;
			if (!pThis->DeviceNotifyChangeDirectoryFile(
					pThis->m_pDevice->m_hDevice, //IN HANDLE FileHandle,
					&aOL[nOLIndex],
					(PIO_APC_ROUTINE)0x123, //fnIO_APC_ROUTINE, //rand()%3 ? fnIO_APC_ROUTINE : (PIO_APC_ROUTINE)CIoctl::GetRandomIllegalPointer(),//IN PIO_APC_ROUTINE ApcRoutine OPTIONAL
					CIoctl::GetRandomIllegalPointer(), //IN PVOID ApcContext OPTIONAL,
					pbOutBuffer, //OUT PVOID Buffer,
					rand(), //IN ULONG Length,
					CIoctl::GetRandom_CompletionFilter(),
					rand()%3 //IN BOOLEAN WatchTree
					))
			{
				DPF((TEXT("DeviceNotifyChangeDirectoryFile(%s) failed with %d\n"), pThis->m_pDevice->m_szDevice, ::GetLastError()));
			}
			else
			{
				DPF((TEXT("DeviceNotifyChangeDirectoryFile() SUCCEEDED\n")));
			}
		}
//*/



		//
		// once in a while, let APCs run.
		// they may come from the Read/WriteFileEx() calls
		//
		if (0 == rand()%100)
		{
			// BUGBUG TODO : this causes AV with pipes. must investigate.
			::SleepEx(0, TRUE);
		}
    }//while (!pThis->m_pDevice->sm_fExitAllThreads || pThis->m_pDevice->m_fShutDown && !pThis->m_pDevice->m_fDeviceThreadExiting)

out:
    if (aOL)
    {
        for (nOLIter = 0; nOLIter < pThis->m_pDevice->m_nOverlappedStructureCount; nOLIter++)
        {
            if (aOL[nOLIter].hEvent && !CloseHandle(aOL[nOLIter].hEvent))
            {
                DPF((TEXT("IoctlThread(): CloseHandle(&aOL[%d].hEvent) failed with %d\n"), nOLIter, GetLastError()));
            }
        }
        delete[] aOL;
    }

	for (nBuffIndex = 0 ; nBuffIndex < NUM_OF_IN_OUT_BUFFERS; nBuffIndex++)
	{
		//delete []aabAllocatedInBuffer[nBuffIndex];
		::VirtualFree(aabAllocatedInBuffer[nBuffIndex], 0, MEM_RELEASE);
		//delete []aabAllocatedOutBuffer[nBuffIndex];
		::VirtualFree(aabAllocatedOutBuffer[nBuffIndex], 0, MEM_RELEASE);
	}

	//
	// exiting a thread will cancel IO, yet, i do it:
	//
    pThis->DeviceCancelIo(pThis->m_pDevice->m_hDevice);

	{
		long lThreadCount = ::InterlockedDecrement(&s_lThreadCount);
		_tprintf(TEXT("IoctlThread(): Exiting thread s_lThreadCount=%d\n"), lThreadCount);
	}

    return 0;
//}__except(PrintExceptionInfoFilter(GetExceptionInformation(), TEXT(__FILE__), __LINE__)){;}
}


//
// static const arrays for (almost) all possible CreateFile() parameters
//

static const DWORD s_adwAccess[] = {
    GENERIC_READ | GENERIC_WRITE,
    GENERIC_READ,
    GENERIC_WRITE,
    0
};

static const DWORD s_adwShare[] = {
    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
    FILE_SHARE_READ | FILE_SHARE_WRITE,
    FILE_SHARE_READ | FILE_SHARE_DELETE,
    FILE_SHARE_WRITE | FILE_SHARE_DELETE,
    FILE_SHARE_READ,
    FILE_SHARE_WRITE,
    FILE_SHARE_DELETE,
    0
};

static const DWORD s_dwCreationDisposition[] = {
    OPEN_EXISTING,
	OPEN_ALWAYS,
    TRUNCATE_EXISTING,
    CREATE_NEW
};

static DWORD s_adwAttributes[] = {
    FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL,
    FILE_FLAG_OVERLAPPED | FILE_FLAG_WRITE_THROUGH,
    FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
    FILE_FLAG_OVERLAPPED | FILE_FLAG_RANDOM_ACCESS,
    FILE_FLAG_OVERLAPPED | FILE_FLAG_SEQUENTIAL_SCAN,
    FILE_FLAG_OVERLAPPED | FILE_FLAG_DELETE_ON_CLOSE,
    FILE_FLAG_OVERLAPPED | FILE_FLAG_BACKUP_SEMANTICS,
    FILE_FLAG_OVERLAPPED | FILE_FLAG_POSIX_SEMANTICS,
    FILE_FLAG_OVERLAPPED | FILE_FLAG_OPEN_REPARSE_POINT,
    FILE_FLAG_OVERLAPPED | FILE_FLAG_OPEN_NO_RECALL,
    FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_HIDDEN,
    FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_SYSTEM,
    FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_DIRECTORY,
    FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_ARCHIVE,
    FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_DEVICE,
    FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_TEMPORARY,
    FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_SPARSE_FILE,
    FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_REPARSE_POINT,
    FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_COMPRESSED,
    FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_OFFLINE,
    FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED,
    FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_ENCRYPTED
};

long CIoctl::sm_lObjectCount = 0;

HANDLE CIoctl::CreateDevice(CDevice *pDevice)
{
	HANDLE hDevice = INVALID_HANDLE_VALUE;
	TCHAR *szDevice = m_pDevice->UseRealName() ? m_pDevice->m_szDevice : m_pDevice->m_szSymbolicName;
	for (m_iAccess = 0; m_iAccess < ARRSIZE(s_adwAccess); m_iAccess++)
	{
		for (m_iShare = 0; m_iShare < ARRSIZE(s_adwShare); m_iShare++)
		{
			for (m_iCreationDisposition = 0; m_iCreationDisposition < ARRSIZE(s_dwCreationDisposition); m_iCreationDisposition++)
			{
				for (m_iAttributes = 0; m_iAttributes < ARRSIZE(s_adwAttributes); m_iAttributes++)
				{
					if (m_pDevice->sm_fExitAllThreads || m_pDevice->m_fShutDown || m_pDevice->m_fDeviceThreadExiting) goto out;

					hDevice = CreateFile(
						szDevice,          // pointer to name of the file
						s_adwAccess[m_iAccess],       // access (read-write) mode
						s_adwShare[m_iShare],           // share mode
						NULL,                        // pointer to security attributes
						s_dwCreationDisposition[m_iCreationDisposition],  // how to create
						s_adwAttributes[m_iAttributes],  // file attributes
						NULL         // handle to file with attributes to copy
						);
					if (INVALID_HANDLE_VALUE == hDevice)
					{
						::Sleep(10);//let other threads breath some air
						/*
						DPF((
							TEXT("CreateFile(%s, 0x%08X, 0x%08X, NULL, OPEN_EXISTING, 0x%08X, NULL) failed with %d\n"),
							szDevice, 
							s_adwAccess[m_iAccess],
							s_adwShare[m_iShare], 
							s_adwAttributes[m_iAttributes],
							GetLastError()
							));
							*/
					}
					else
					{
						DPF((
							TEXT("CIoctl::OpenDevice() CreateFile(%s, 0x%08X, 0x%08X, NULL, OPEN_EXISTING, 0x%08X, NULL) succeeded\n"),
							m_pDevice->m_szDevice, 
							s_adwAccess[m_iAccess],
							s_adwShare[m_iShare], 
							s_adwAttributes[m_iAttributes]
							));
						return hDevice;
					}
				}//for (m_iAttributes = 0; m_iAttributes < ARRSIZE(s_adwAttributes); m_iAttributes++)
			}//for (m_iCreationDisposition = 0; m_iCreationDisposition < ARRSIZE(s_adwAttributes); m_iCreationDisposition++)
		}//for (m_iShare = 0; m_iShare < ARRSIZE(s_adwShare); m_iShare++)
	}//for (m_iAccess = 0; m_iAccess < ARRSIZE(s_adwAccess); m_iAccess++)

    DPF((TEXT("CIoctl::OpenDevice(%s) FAILED\n"), m_pDevice->m_szDevice));
out:
    return INVALID_HANDLE_VALUE;
}


void CIoctl::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abIn,
    DWORD &dwIn,
    BYTE *abOut,
    DWORD &dwOut
    )
{
    FillBufferWithRandomData(abIn, dwIn);
    FillBufferWithRandomData(abOut, dwOut);
	//
	// from time to time, point the bufs to NULL, or to kernel memory.
	// note that drivers should verifiy that buffs are user-mode!
	//
	if (0 == rand()%20) abIn = NULL;
	else if (0 == rand()%10) abIn = (unsigned char*)(0x80000000 | DWORD_RAND);//kernel memory, not 64 bit compliant!
	if (0 == rand()%20) abOut = NULL;
	else if (0 == rand()%10) abOut = (unsigned char*)(0x80000000 | DWORD_RAND);//kernel memory, not 64 bit compliant!
}


BOOL CIoctl::FindValidIOCTLs(CDevice *pDevice)
{
    BOOL bRet = TRUE;
    DPF((TEXT("FindValidIOCTLs() %s is NOT known, will query for known IOCTLs\n"), pDevice->GetDeviceName()));
    DWORD dwIoctl;
    BYTE *abInBuffer = NULL;
    BYTE *abOutBuffer = NULL;
    DWORD dwBytesReturned;
    OVERLAPPED ol;
	while (NULL == (abInBuffer = new BYTE[SIZEOF_INOUTBUFF]))
	{
		if (m_pDevice->sm_fExitAllThreads || m_pDevice->m_fShutDown || m_pDevice->m_fDeviceThreadExiting) goto out;
		::Sleep(100);
        DPF((TEXT(".")));
	}
	while (NULL == (abOutBuffer = new BYTE[SIZEOF_INOUTBUFF]))
	{
		if (m_pDevice->sm_fExitAllThreads || m_pDevice->m_fShutDown || m_pDevice->m_fDeviceThreadExiting) goto out;
		::Sleep(100);
        DPF((TEXT(".")));
	}

    if (!PrepareOverlappedStructure(&ol))
    {
        DPF((TEXT("FindValidIOCTLs(): CreateEvent(ol.hEvent) failed with %d\n"), GetLastError()));
        bRet = FALSE;
        goto out;
    }

    DWORD dwLastError;
    dwIoctl = 0x00008000; //see CTL_CODE definition remarked below
    while(!m_pDevice->sm_fExitAllThreads && !m_pDevice->m_fShutDown || m_pDevice->m_fDeviceThreadExiting)
    {
        if (MAX_NUM_OF_GOOD_IOCTLS <= pDevice->m_iMaxFreeLegalIOCTL)
        {
            DPF((TEXT("FindValidIOCTLs(): (MAX_NUM_OF_GOOD_IOCTLS(%d) < iMaxFreeLegalIOCTL(%d))\n"), MAX_NUM_OF_GOOD_IOCTLS, m_pDevice->m_iMaxFreeLegalIOCTL));
            bRet = FALSE;
            goto out;
        }

        //
        // according to winioctl.h, max FILE_DEVICE_TYPE is FILE_DEVICE_KSEC=0x00000039,
        // and 
        // #define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
        //   ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) 
        // so it seems that 0x00700000 is more than the highest IOCTL
        //
        if (0x00700000 <= dwIoctl)
        {
            DPF((TEXT("\nCIoctl::FindValidIOCTLs(): finished all IOCTLs\n")));
            break;
        }

        if (DeviceInputOutputControl(
                pDevice->m_hDevice,         // handle to device of interest
                dwIoctl,  // control code of operation to perform
                abInBuffer,      // pointer to buffer to supply input data
                SIZEOF_INOUTBUFF,    // size of input buffer
                abOutBuffer,     // pointer to buffer to receive output data
                SIZEOF_INOUTBUFF,   // size of output buffer
                &dwBytesReturned,  // pointer to variable to receive output                            // byte count
                &ol   // pointer to overlapped structure for asynchronous operation
                ))
        {
            pDevice->m_adwLegalIOCTLs[pDevice->m_iMaxFreeLegalIOCTL++] = dwIoctl;
//            DPF((TEXT("\nDeviceIoControl(%s, 0x%08X) succeeded\n"), pDevice->m_szDevice, dwIoctl));
        }
        else
        {
            dwLastError = GetLastError();
            if (
                (dwLastError == ERROR_IO_PENDING) ||
                (dwLastError == ERROR_OPLOCK_NOT_GRANTED) ||
                (dwLastError == ERROR_INVALID_OPLOCK_PROTOCOL) ||
                (dwLastError == ERROR_FILE_NOT_FOUND) ||
                (dwLastError == ERROR_JOURNAL_NOT_ACTIVE) ||
                (dwLastError == ERROR_INVALID_OPLOCK_PROTOCOL) ||
                (dwLastError == ERROR_INVALID_USER_BUFFER) ||
                (dwLastError == ERROR_NETNAME_DELETED) ||
                (dwLastError == ERROR_NOT_SUPPORTED) ||
                (dwLastError == ERROR_NOT_READY) ||
                (dwLastError == ERROR_GEN_FAILURE)
               )
            {
                pDevice->m_adwLegalIOCTLs[pDevice->m_iMaxFreeLegalIOCTL++] = dwIoctl;
                //cancel some. we cancel anyway at the end of this function.
                if (rand()%3 == 0)
                {
                    CancelIo(m_pDevice->m_hDevice);
                }
                DPF((TEXT("\nDeviceIoControl(%s, 0x%08X) succeeded(%d)\n"), m_pDevice->m_szDevice, dwIoctl, dwLastError));
            }
            else if (
				//(dwLastError == ERROR_INVALID_PARAMETER) || 
                (dwLastError == ERROR_CALL_NOT_IMPLEMENTED)  || 
                //(dwLastError == ERROR_ACCESS_DENIED) ||
                (dwLastError == ERROR_INVALID_HANDLE) || 
                (dwLastError == ERROR_INVALID_FUNCTION)
                )
            {
                if (dwIoctl%100000 == 0) DPF((TEXT(".")));
            }
            else
            {
                DPF((TEXT("\nDeviceIoControl(%s, 0x%08X) failed with %d=0x%08X\n"), m_pDevice->m_szDevice, dwIoctl, dwLastError, dwLastError));
                pDevice->m_adwLegalIOCTLs[pDevice->m_iMaxFreeLegalIOCTL++] = dwIoctl;
                //_ASSERTE(FALSE);
            }
        }

//continue_trying_ioctls:
        dwIoctl++;
    }

    if (m_pDevice->m_fDeviceThreadExiting)
    {
        DPF((TEXT("FindValidIOCTLs(%s), accepted m_pDevice->m_fDeviceThreadExiting\n"), m_pDevice->GetDeviceName()));
        bRet = FALSE;
        goto out;
    }

    if (m_pDevice->m_fShutDown)
    {
        DPF((TEXT("FindValidIOCTLs(%s), accepted m_pDevice->m_fShutDown\n"), m_pDevice->GetDeviceName()));
        bRet = FALSE;
        goto out;
    }

    DPF((TEXT("\n")));
out:
///*
    DPF((TEXT("Known IOCTLS:\n")));
    for (int i = 0; i < m_pDevice->m_iMaxFreeLegalIOCTL; i++)
    {
        DPF((TEXT("0x%08X\n"), pDevice->m_adwLegalIOCTLs[i]));
    }
    DPF((TEXT("\n")));
//*/
	delete []abInBuffer;
	delete []abOutBuffer;

    if (0 == pDevice->m_iMaxFreeLegalIOCTL)
    {
		DPF((TEXT("FindValidIOCTLs(%s), returning FALSE, (0 == pDevice->m_iMaxFreeLegalIOCTL)\n"), m_pDevice->GetDeviceName()));
        return FALSE;
    }

	if (!bRet) DPF((TEXT("FindValidIOCTLs(%s), returning FALSE\n"), m_pDevice->GetDeviceName()));
    return bRet;
}


void CIoctl::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    ;
}

void CIoctl::FillBufferWithRandomData(void *pBuff, DWORD &dwSize)
{
	//
	// size may become zero, which is ok with me.
	//
    if (dwSize) dwSize = rand()%dwSize;
    for (DWORD dwIter = 0; dwIter < dwSize; dwIter++)
    {
        ((BYTE*)pBuff)[dwIter] = rand();
    }

}


BOOL CIoctl::PrepareOverlappedStructure(OVERLAPPED *pol)
{
    pol->OffsetHigh = pol->Offset = 0;

	for (DWORD dwTimesTried = 0; dwTimesTried < 10000; dwTimesTried++)
	{
		if (m_pDevice->sm_fExitAllThreads || m_pDevice->m_fShutDown || m_pDevice->m_fDeviceThreadExiting) goto out;

		pol->hEvent = ::CreateEvent(
			NULL, // address of security attributes
			TRUE, // flag for manual-reset event
			FALSE,// flag for initial state
			NULL  // address of event-object name
			);
		if (NULL != pol->hEvent)
		{
			return TRUE;
		}
		::Sleep(100);
	}
out:
    return FALSE;
}


void CIoctl::SetInParam(DWORD &dwInBuff, DWORD dwExpectedSize)
{
	dwExpectedSize = min(dwExpectedSize, SIZEOF_INOUTBUFF);
    dwInBuff = rand()%10 ? dwExpectedSize: rand()%2 ? min(dwExpectedSize, dwExpectedSize-1) : dwInBuff ? rand()%dwInBuff : dwInBuff;
	//
	// once in a while, put zero. it may help with METHOD_NEITHER
	//
	if (0 == rand()%100)
	{
		dwInBuff = 0;
	}

	//
	// sometimes pass an input buffer even if non is required
	//
	if ((dwExpectedSize == 0) && (0 == rand()%10))
	{
		dwInBuff = rand()%1000;
		return;
	}
}

void CIoctl::SetOutParam(BYTE* &abOutBuffer, DWORD &dwOutBuff, DWORD dwExpectedSize)
{
	dwExpectedSize = min(dwExpectedSize, SIZEOF_INOUTBUFF);
	//
	// usually, return the expected buff
	//
    if (rand()%10)
    {
        dwOutBuff = dwExpectedSize;
        return;
    }

	//
	// some crazy/illegal stuff
	//

	//
	// sometimes pass an output buffer even if non is required
	//
	if ((dwExpectedSize == 0) && (0 == rand()%10))
	{
		dwOutBuff = rand()%1000;
		return;
	}

    if (rand()%5 == 0)
    {
        dwOutBuff = 0;
        abOutBuffer = NULL;
    }/*
    else if (rand()%4 == 0)
    {
        abOutBuffer = (unsigned char*)(0x80000000 | DWORD_RAND);//illegal - kernelmode.
        dwOutBuff = dwExpectedSize;
    }*/
    else if (rand()%4 == 0)
    {
        
        dwOutBuff = 0;
        abOutBuffer = (unsigned char*)(rand());//this is an illegal address!
    }
    else if (rand()%3 == 0)
    {
        
        dwOutBuff = dwExpectedSize;
        abOutBuffer = NULL;
    }
    else if (rand()%2)
    {
        
        if (dwOutBuff) dwOutBuff = rand()%dwOutBuff;
    }
    else
    {
        if (dwOutBuff) dwOutBuff = rand()%dwOutBuff;
        abOutBuffer = NULL;
    }

}



void CIoctl::AddIOCTL(CDevice *pDevice, DWORD dwIOCTL)
{
	_ASSERTE(MAX_NUM_OF_GOOD_IOCTLS > pDevice->m_iMaxFreeLegalIOCTL);
	if (MAX_NUM_OF_GOOD_IOCTLS <= pDevice->m_iMaxFreeLegalIOCTL)
	{
        DPF((TEXT("CIoctl::AddIOCTL(): pDevice->m_iMaxFreeLegalIOCTL(%d) > = MAX_NUM_OF_GOOD_IOCTLS(%d)\n"), pDevice->m_iMaxFreeLegalIOCTL, MAX_NUM_OF_GOOD_IOCTLS));
		return;//must prevent AV
	}
    pDevice->m_adwLegalIOCTLs[pDevice->m_iMaxFreeLegalIOCTL++] = dwIOCTL;

}

bool CIoctl::SetSrandFile(long lIndex) 
{
    long lSeed = m_pDevice->m_fUseGivenSeed ? m_pDevice->m_lSeed+lIndex : time( NULL ) ;
    srand(lSeed);

	//
	// TODO: i do not use it, so let's not put all these file that just litter the folder
	//
	return true;

    TCHAR szIOCTLSrandFile[1024];
    _stprintf(szIOCTLSrandFile, TEXT("IOCTLSrand-%d-%d-%d.srand"), m_pDevice->m_lMyIndex, lIndex, lSeed);

    HANDLE hIOCTLSrand = CreateFile(
        szIOCTLSrandFile,
        GENERIC_READ | GENERIC_WRITE,       // access (read-write) mode
        0,           // share mode
        NULL,                        // pointer to security attributes
        CREATE_ALWAYS,  // how to create
        FILE_ATTRIBUTE_NORMAL,  // file attributes
        NULL         // handle to file with attributes to copy
        );
    if(INVALID_HANDLE_VALUE == hIOCTLSrand)
    {
        DPF((TEXT("CIoctl::SetSrandFile(%d): CreateFile(%s) failed with %d\n"), lIndex, szIOCTLSrandFile, ::GetLastError()));
        return false;
    }

    if (!CloseHandle(hIOCTLSrand))
    {
        DPF((TEXT("CIoctl::SetSrandFile(%d): CloseHandle(%s) failed with %d\n"), lIndex, szIOCTLSrandFile, ::GetLastError()));
    }

    return true;
}

BYTE * CIoctl::FixupInOutBuffToEndOnEndOfPhysicalPage(BYTE * pbAllocatedBuffer, DWORD dwAmoutToReadWrite)
{
	//
	// assuming that pbOutBuffer points to a buff of size SIZEOF_INOUTBUFF
	// what if the buff was incremented to break alignment?
	//
	return (pbAllocatedBuffer-dwAmoutToReadWrite) + SIZEOF_INOUTBUFF;
}

void* CIoctl::GetRandomIllegalPointer()
{
	/*
	
	  I have no idea why i used this, because i already had my decommitted buffs.
	  So now i just use them, instead of the below that is always decommitted

	static long s_fFirstTime = TRUE;
	void * pvDeCommitted = NULL;
	if (::InterlockedExchange(&s_fFirstTime, FALSE))
	{
		//
		// 1st time into this function, or failed previous time
		//
		pvDeCommitted = (BYTE*)::VirtualAlloc(
			NULL,// region to reserve or commit
			SIZEOF_INOUTBUFF,// size of region
			MEM_RESERVE,// type of allocation
			PAGE_EXECUTE_READWRITE// type of access protection
			);
		if (NULL == pvDeCommitted)
		{
			//
			// this is really bad, no address space left
			//
			_tprintf(TEXT("CIoctl::GetRandomIllegalPointer(): VirtualAlloc() failed with %d\n"), ::GetLastError());
			//
			// lets try again next time
			//
			::InterlockedExchange(&s_fFirstTime, TRUE);
		}
	}

	if (rand()%10) return pvDeCommitted;
	*/
	if (rand()%10) return (CDevice::sm_aCommitDecommitBuffs[rand()%NUM_OF_ALLOC_AND_FREE_BUFFS]);
	if (0 == rand()%2) return ((void*)-rand());//this may overflow from legal kernel-mode to illegal user-mode
	if (0 == rand()%2) return (void*)rand();//always illegal!
	if (0 == rand()%2) return NULL;
	return (void*)(0xC0000000 & DWORD_RAND);//kenel address (even with /3G) BUGBUG:64 bit

	
}


void CIoctl::GetRandom_FileInformationClassAndLength(
	FILE_INFORMATION_CLASS *FileInformationClass, 
	ULONG *Length
	)
{
	//
	// an illegal FileInformationClass case
	//
	if (0 == rand()%100)
	{
		*FileInformationClass = FileMaximumInformation;
		*Length = rand()%SIZEOF_INOUTBUFF;

		return;
	}

	*FileInformationClass = (FILE_INFORMATION_CLASS)(rand()%FileMaximumInformation);
	switch(*FileInformationClass)
	{
	case 0://this is an illegal value
		*Length = rand()%SIZEOF_INOUTBUFF;
		break;

	case FileDirectoryInformation:
		//
		// buffer is not expected
		//
		*Length = rand()%20 ? 0 : rand()%SIZEOF_INOUTBUFF;
		break;

	case FileFullDirectoryInformation:
		//
		// buffer is not expected
		//
		*Length = rand()%20 ? 0 : rand()%SIZEOF_INOUTBUFF;
		break;

	case FileBothDirectoryInformation:
		//
		// buffer is not expected
		//
		*Length = rand()%20 ? 0 : rand()%SIZEOF_INOUTBUFF;
		break;

	case FileBasicInformation:
		//
		// buffer should hold FILE_BASIC_INFORMATION
		//
		*Length = sizeof(FILE_BASIC_INFORMATION) + (rand()%10 ? 0 : rand()%10);
		break;

	case FileStandardInformation:
		//
		// buffer should hold FILE_STANDARD_INFORMATION
		//
		*Length = sizeof(FILE_STANDARD_INFORMATION) + (rand()%10 ? 0 : rand()%10);
		break;

	case FileInternalInformation:
		//
		// buffer should hold FILE_INTERNAL_INFORMATION
		//
		*Length = sizeof(FILE_INTERNAL_INFORMATION) + (rand()%10 ? 0 : rand()%10);
		break;

	case FileEaInformation:
		//
		// buffer should hold FILE_EA_INFORMATION
		//
		*Length = sizeof(FILE_EA_INFORMATION) + (rand()%10 ? 0 : rand()%10);
		break;

	case FileAccessInformation:
		//
		// buffer should hold FILE_ACCESS_INFORMATION 
		//
		*Length = sizeof(FILE_ACCESS_INFORMATION) + (rand()%10 ? 0 : rand()%10);
		break;

	case FileNameInformation:
		//
		// buffer should hold FILE_NAME_INFORMATION + FileName
		//
		*Length = sizeof(FILE_NAME_INFORMATION) + rand()%100;
		break;

	case FileRenameInformation:
		//
		// buffer is not expected
		//
		*Length = rand()%20 ? 0 : rand()%SIZEOF_INOUTBUFF;
		break;

	case FileLinkInformation:
		//
		// buffer is not expected
		//
		*Length = rand()%20 ? 0 : rand()%SIZEOF_INOUTBUFF;
		break;

	case FileNamesInformation:
		//
		// buffer is not expected
		//
		*Length = rand()%20 ? 0 : rand()%SIZEOF_INOUTBUFF;
		break;

	case FileDispositionInformation:
		//
		// buffer is not expected
		//
		*Length = rand()%20 ? 0 : rand()%SIZEOF_INOUTBUFF;
		break;

	case FilePositionInformation:
		//
		// buffer should hold FILE_POSITION_INFORMATION 
		//
		*Length = sizeof(FILE_POSITION_INFORMATION) + (rand()%10 ? 0 : rand()%10);
		break;

	case FileFullEaInformation:
		//
		// buffer is not expected
		//
		*Length = rand()%20 ? 0 : rand()%SIZEOF_INOUTBUFF;
		break;

	case FileModeInformation:
		//
		// buffer should hold FILE_MODE_INFORMATION 
		//
		*Length = sizeof(FILE_MODE_INFORMATION) + (rand()%10 ? 0 : rand()%10);
		break;

	case FileAlignmentInformation:
		//
		// buffer should hold FILE_ALIGNMENT_INFORMATION 
		//
		*Length = sizeof(FILE_ALIGNMENT_INFORMATION) + (rand()%10 ? 0 : rand()%10);
		break;

	case FileAllInformation:
		//
		// buffer should hold FILE_ALL_INFORMATION + xxx
		//
		*Length = sizeof(FILE_ALL_INFORMATION) + (rand()%2 ? rand()%100 : rand()%1000);
		break;

	case FileAllocationInformation:
		//
		// buffer is not expected
		//
		*Length = rand()%20 ? 0 : rand()%SIZEOF_INOUTBUFF;
		break;

	case FileEndOfFileInformation:
		//
		// buffer is not expected
		//
		*Length = rand()%20 ? 0 : rand()%SIZEOF_INOUTBUFF;
		break;

	case FileAlternateNameInformation:
		//
		// buffer should hold FILE_NAME_INFORMATION + FileName
		//
		*Length = sizeof(FILE_NAME_INFORMATION) + rand()%100;
		break;

	case FileStreamInformation:
		//
		// buffer should hold FILE_STREAM_INFORMATION + StreamName
		//
		*Length = sizeof(FILE_STREAM_INFORMATION) + rand()%100;
		break;

	case FilePipeInformation:
		//
		// buffer should hold FILE_PIPE_INFORMATION 
		//
		*Length = sizeof(FILE_PIPE_INFORMATION) + (rand()%10 ? 0 : rand()%10);
		break;

	case FilePipeLocalInformation:
		//
		// buffer should hold FILE_PIPE_LOCAL_INFORMATION 
		//
		*Length = sizeof(FILE_PIPE_LOCAL_INFORMATION) + (rand()%10 ? 0 : rand()%10);
		break;

	case FilePipeRemoteInformation:
		//
		// buffer should hold FILE_PIPE_REMOTE_INFORMATION 
		//
		*Length = sizeof(FILE_PIPE_REMOTE_INFORMATION) + (rand()%10 ? 0 : rand()%10);
		break;

	case FileMailslotQueryInformation:
		//
		// buffer should hold FILE_MAILSLOT_QUERY_INFORMATION 
		//
		*Length = sizeof(FILE_MAILSLOT_QUERY_INFORMATION) + (rand()%10 ? 0 : rand()%10);
		break;

	case FileMailslotSetInformation:
		//
		// buffer is not expected
		//
		*Length = rand()%20 ? 0 : rand()%SIZEOF_INOUTBUFF;
		break;

	case FileCompressionInformation:
		//
		// buffer should hold FILE_COMPRESSION_INFORMATION 
		//
		*Length = sizeof(FILE_COMPRESSION_INFORMATION) + (rand()%10 ? 0 : rand()%10);
		break;

	case FileObjectIdInformation:
		//
		// buffer should hold FILE_OBJECTID_INFORMATION 
		//
		*Length = sizeof(FILE_OBJECTID_INFORMATION) + (rand()%10 ? 0 : rand()%10);
		break;

	case FileCompletionInformation:
		//
		// buffer is not expected
		//
		*Length = rand()%20 ? 0 : rand()%SIZEOF_INOUTBUFF;
		break;

	case FileMoveClusterInformation:
		//
		// buffer is not expected
		//
		*Length = rand()%20 ? 0 : rand()%SIZEOF_INOUTBUFF;
		break;

	case FileQuotaInformation:
		//
		// buffer should hold FILE_QUOTA_INFORMATION + Sid
		//
		*Length = sizeof(FILE_QUOTA_INFORMATION) + rand()%100;
		break;

	case FileReparsePointInformation:
		//
		// buffer should hold FILE_REPARSE_POINT_INFORMATION 
		//
		*Length = sizeof(FILE_REPARSE_POINT_INFORMATION) + (rand()%10 ? 0 : rand()%10);
		break;

	case FileNetworkOpenInformation:
		//
		// buffer should hold FILE_NETWORK_OPEN_INFORMATION 
		//
		*Length = sizeof(FILE_NETWORK_OPEN_INFORMATION) + (rand()%10 ? 0 : rand()%10);
		break;

	case FileAttributeTagInformation:
		//
		// buffer should hold FILE_ATTRIBUTE_TAG_INFORMATION 
		//
		*Length = sizeof(FILE_ATTRIBUTE_TAG_INFORMATION) + (rand()%10 ? 0 : rand()%10);
		break;

	case FileTrackingInformation:
		//
		// buffer is not expected
		//
		*Length = rand()%20 ? 0 : rand()%SIZEOF_INOUTBUFF;
		break;

	case FileMaximumInformation:
		_ASSERTE(FALSE);
		break;

	default:
		_ASSERTE(FALSE);
	}

	//
	// seldom, give a too small buffer
	//
	if (0 == rand()%20)
	{
		if (rand()%2)
		{
			*Length = 0;
		}
		else
		{
			if (*Length) *Length = rand()%*Length;
		}
	}

	//
	// in case i asked for a too large buffer:
	//
	*Length = *Length%SIZEOF_INOUTBUFF;

	return;
}
    

void CIoctl::GetRandom_FsInformationClassAndLength(
	FS_INFORMATION_CLASS *FsInformationClass, 
	ULONG *Length
	)
{
	//
	// the illegal FsInformationClass case
	//
	if (0 == rand()%100)
	{
		*FsInformationClass = FileFsMaximumInformation;
		*Length = rand()%SIZEOF_INOUTBUFF;

		return;
	}

	*FsInformationClass = (enum _FSINFOCLASS)(rand()%FileFsMaximumInformation);
	switch(*FsInformationClass)
	{
	case 0://this is an illegal value
		*Length = rand();
		break;

	case FileFsVolumeInformation:
		//
		// buffer should hold FILE_FS_VOLUME_INFORMATION + VolumeLabel
		//
		*Length = sizeof(FILE_FS_VOLUME_INFORMATION) + rand()%100;
		/*
		//
		// buffer should hold FILE_FS_ATTRIBUTE_INFORMATION + FileSystemName
		//
		*Length = rand()%sizeof(FILE_FS_ATTRIBUTE_INFORMATION) + rand()%100;
		//
		// special case, made to break this line by causing an underflow:
		// Length -= FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName[0] );
		//
		if (0 != rand()%20)
		{
			*Length = rand()%FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName[0] );
		}
		*/
		break;

	case FileFsLabelInformation:
		//
		// buffer is not expected
		//
		*Length = rand()%20 ? 0 : rand();
		break;

	case FileFsSizeInformation:
		//
		// buffer should hold FILE_FS_SIZE_INFORMATION
		//
		*Length = sizeof(FILE_FS_SIZE_INFORMATION) + (rand()%10 ? 0 : rand()%10);
		break;

	case FileFsDeviceInformation:
		//
		// buffer should hold FILE_FS_DEVICE_INFORMATION 
		//
		*Length = sizeof(FILE_FS_DEVICE_INFORMATION) + (rand()%10 ? 0 : rand()%10);
		break;

	case FileFsAttributeInformation:
		//
		// buffer should hold FILE_FS_ATTRIBUTE_INFORMATION + FileSystemName
		//
		*Length = sizeof(FILE_FS_ATTRIBUTE_INFORMATION) + rand()%100;
		break;

	case FileFsControlInformation:
		//
		// buffer should hold FILE_FS_CONTROL_INFORMATION
		//
		*Length = sizeof(FILE_FS_CONTROL_INFORMATION) + (rand()%10 ? 0 : rand()%10);
		break;

	case FileFsFullSizeInformation:
		//
		// buffer should hold FILE_FS_FULL_SIZE_INFORMATION
		//
		*Length = sizeof(FILE_FS_FULL_SIZE_INFORMATION) + (rand()%10 ? 0 : rand()%10);
		break;

	case FileFsObjectIdInformation:
		//
		// buffer should hold FILE_FS_OBJECTID_INFORMATION
		//
		*Length = sizeof(FILE_FS_OBJECTID_INFORMATION) + (rand()%10 ? 0 : rand()%10);
		break;

	case FileFsMaximumInformation:
		_ASSERTE(FALSE);
		break;

	default:
		_ASSERTE(FALSE);
	}

	//
	// seldom, give a too small buffer
	//
	if (0 == rand()%20)
	{
		if (rand()%2)
		{
			*Length = 0;
		}
		else
		{
			if (*Length) *Length = rand()%*Length;
		}
	}

	//
	// in case i asked for a too large buffer:
	//
	*Length = *Length%SIZEOF_INOUTBUFF;

	return;
}
    

BOOL CIoctl::DeviceQueryVolumeInformationFile(
	IN HANDLE FileHandle,
	OVERLAPPED *pOverlapped,//OUT PIO_STATUS_BLOCK IoStatusBlock,
	OUT PVOID FsInformation,
	IN ULONG Length,
	IN FS_INFORMATION_CLASS FsInformationClass
	)
{
	GetRandom_FsInformationClassAndLength(&FsInformationClass, &Length);
	return CIoctlNtNative::StaticQueryVolumeInformationFile(
		FileHandle,
		GetRandomIllegalIoStatusBlock(pOverlapped),
		SetOutBuffToEndOfBuffOrFurther(FsInformation, Length),
		Length,
		FsInformationClass
		);
}

BOOL CIoctl::DeviceQueryInformationFile(
	IN HANDLE FileHandle,
	OVERLAPPED *pOverlapped,//OUT PIO_STATUS_BLOCK IoStatusBlock,
	OUT PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass
	)
{
	GetRandom_FileInformationClassAndLength(&FileInformationClass, &Length);
	return CIoctlNtNative::StaticNtQueryInformationFile(
		FileHandle,
		GetRandomIllegalIoStatusBlock(pOverlapped),
		SetOutBuffToEndOfBuffOrFurther(FileInformation, Length),
		Length,
		FileInformationClass
		);
}

BOOL CIoctl::DeviceSetInformationFile(
	IN HANDLE FileHandle,
	OVERLAPPED *pOverlapped,//OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass
	)
{
	GetRandom_FileInformationClassAndLength(&FileInformationClass, &Length);
	return CIoctlNtNative::StaticNtSetInformationFile(
		FileHandle,
		GetRandomIllegalIoStatusBlock(pOverlapped),
		SetOutBuffToEndOfBuffOrFurther(FileInformation, Length),
		Length,
		FileInformationClass
		);
}




BOOL CIoctl::DeviceQueryFullAttributesFile(
	IN WCHAR * wszName,
    OUT PFILE_NETWORK_OPEN_INFORMATION FileInformation
	)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            wszName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );
    Status = NtQueryFullAttributesFile( 
		&Obja, 
		(FILE_NETWORK_OPEN_INFORMATION *)SetOutBuffToEndOfBuffOrFurther(FileInformation, sizeof(FILE_NETWORK_OPEN_INFORMATION))
		);
    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
    if ( NT_SUCCESS(Status) ) 
	{
        return TRUE;
    }
    else 
	{
		::SetLastError(RtlNtStatusToDosError(Status));
        return FALSE;
    }
}
BOOL CIoctl::DeviceQueryDirectoryFile(
	IN HANDLE FileHandle,
	IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	OVERLAPPED *pOverlapped,//OUT PIO_STATUS_BLOCK IoStatusBlock,IN HANDLE Event OPTIONAL
	OUT PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass,
	IN BOOLEAN ReturnSingleEntry,
	IN PUNICODE_STRING FileName OPTIONAL,
	IN BOOLEAN RestartScan
	)
{
	GetRandom_FileInformationClassAndLength(&FileInformationClass, &Length);
	return CIoctlNtNative::StaticNtQueryDirectoryFile(
		FileHandle,
		rand()%10 ? pOverlapped->hEvent : rand()%2 ? NULL : (HANDLE)(0x80000000 & DWORD_RAND),//Event,
		ApcRoutine,
		ApcContext,
		GetRandomIllegalIoStatusBlock(pOverlapped),
		SetOutBuffToEndOfBuffOrFurther(FileInformation, Length),
		Length,
		FileInformationClass,
		ReturnSingleEntry,
		FileName,
		RestartScan
		);
}

BOOL CIoctl::DeviceNotifyChangeDirectoryFile(
	IN HANDLE FileHandle,
	OVERLAPPED *pOverlapped,//OUT PIO_STATUS_BLOCK IoStatusBlock,IN HANDLE Event OPTIONAL
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree
	)
{
	return CIoctlNtNative::StaticNtNotifyChangeDirectoryFile(
		FileHandle,
		rand()%10 ? pOverlapped->hEvent : rand()%2 ? NULL : (HANDLE)(0x80000000 & DWORD_RAND),//Event,
		ApcRoutine,
		ApcContext,
		GetRandomIllegalIoStatusBlock(pOverlapped),
		SetOutBuffToEndOfBuffOrFurther(Buffer, Length),
		Length,
		CompletionFilter,
		WatchTree
		);
}


DWORD CIoctl::GetRandom_CompletionFilter()
{
	//
	// may be illegal
	//
	if (0 == rand()%100) return rand();

	//
	// should be illegal
	//
	if (0 == rand()%100) return 0;

	//
	// valid combination
	//
	return (FILE_NOTIFY_VALID_MASK & rand());



}

IO_STATUS_BLOCK* CIoctl::GetRandomIllegalIoStatusBlock(OVERLAPPED *pOverlapped)
{
	IO_STATUS_BLOCK *pIOSB;
	if (rand()%10)
	{
		pIOSB = (IO_STATUS_BLOCK*)(&pOverlapped->Internal);
	}
	else
	{
		pIOSB = (IO_STATUS_BLOCK*)CIoctl::GetRandomIllegalPointer();
		__try
		{
			CopyMemory(pIOSB, &pOverlapped->Internal, sizeof(IO_STATUS_BLOCK));
		}__except(1)
		{
			NOTHING;
		}
	}

	return pIOSB;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\ipioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

#include <windows.h>
*/
#define _PNP_POWER_
#include "ntddip.h"
#include "icmpif.h"
#include "ipinfo.h"


#include "ipfilter.h"

#include "IpIOCTL.h"

static bool s_fVerbose = true;

static void SetRandom_IPRouteEntry(CIoctlIp* pThis, IPRouteEntry* pIPRouteEntry);
static void SetRandom_IPRouteNextHopEntry(CIoctlIp* pThis, IPRouteNextHopEntry* pIPRouteNextHopEntry);
static ULONG GetRandomContext(CIoctlIp* pThis);
static ULONG GetRandom_SequenceNo(CIoctlIp* pThis);
static unsigned long GetRandomSubnetMask(CIoctlIp* pThis);
static ULONG GetRandom_ire_type(CIoctlIp* pThis);
static ULONG GetRandom_ire_proto(CIoctlIp* pThis);
static ULONG GetRandom_ire_metric(CIoctlIp* pThis);
static void AddInterfaceNameInfo(CIoctlIp* pThis, IP_INTERFACE_NAME_INFO* pInterfaceNameInfo);
static ULONG GetRandomInterfaceEnumerationContext(CIoctlIp* pThis);


void CIoctlIp::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
	switch(dwIOCTL)
	{
	case IOCTL_IP_INTERFACE_INFO:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);

		{
			//DPF((TEXT("CIoctlIp::UseOutBuff(IOCTL_IP_INTERFACE_INFO)\n")));
			for (LONG i = 0; i < ((IP_INTERFACE_INFO*)abOutBuffer)->NumAdapters; i++)
			{
				AddAdapterIndexAndName(((IP_INTERFACE_INFO*)abOutBuffer)->Adapter[i].Index, ((IP_INTERFACE_INFO*)abOutBuffer)->Adapter[i].Name);
			}
		}
		break;
	case IOCTL_IP_GET_BEST_INTERFACE:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);

		AddInterface(*((PULONG)abOutBuffer));
		break;
	case IOCTL_IP_GET_IF_INDEX:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);

		//DPF((TEXT("CIoctlIp::UseOutBuff(IOCTL_IP_GET_IF_INDEX)\n")));
		AddInterface(((IP_GET_IF_INDEX_INFO*)abOutBuffer)->Index);
		break;
	case IOCTL_IP_GET_NTE_INFO:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);

		{
			AddInstance(((IP_GET_NTE_INFO_RESPONSE*)abOutBuffer)->Instance);
			AddAddress(((IP_GET_NTE_INFO_RESPONSE*)abOutBuffer)->Address);
			AddSubnetMask(((IP_GET_NTE_INFO_RESPONSE*)abOutBuffer)->SubnetMask);
			AddFlags(((IP_GET_NTE_INFO_RESPONSE*)abOutBuffer)->Flags);
		}
		break;
	case IOCTL_IP_GET_IF_NAME:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);

		{
			//DPF((TEXT("CIoctlIp::UseOutBuff(IOCTL_IP_GET_IF_NAME)\n")));
			AddInterfaceEnumerationContext(((IP_GET_IF_NAME_INFO*)abOutBuffer)->Context);
			for (UINT i = 0; i < ((IP_GET_IF_NAME_INFO*)abOutBuffer)->Count; i++)
			{
				AddInterfaceNameInfo(this, &((IP_GET_IF_NAME_INFO*)abOutBuffer)->Info[i]);
			}
		}
		break;
	}
}

void CIoctlIp::CallRandomWin32API(LPOVERLAPPED pOL)
{
	//_ASSERTE(FALSE);
    ;
}



void CIoctlIp::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
	switch(dwIOCTL)
	{
	case IOCTL_ICMP_ECHO_REQUEST          :
        ((PICMP_ECHO_REQUEST)abInBuffer)->Address = GetRandomAddress();
        ((PICMP_ECHO_REQUEST)abInBuffer)->Timeout = rand();
        ((PICMP_ECHO_REQUEST)abInBuffer)->DataOffset = rand()%2 ? sizeof(ICMP_ECHO_REQUEST) : rand()%10000;
        ((PICMP_ECHO_REQUEST)abInBuffer)->DataSize = rand()%10 ? rand()%10000 : 0;
        ((PICMP_ECHO_REQUEST)abInBuffer)->OptionsValid = rand()%2;
        ((PICMP_ECHO_REQUEST)abInBuffer)->Ttl = rand()%100 ? rand() : 0;
        ((PICMP_ECHO_REQUEST)abInBuffer)->Tos = rand();
        ((PICMP_ECHO_REQUEST)abInBuffer)->Flags = GetFlags();
        ((PICMP_ECHO_REQUEST)abInBuffer)->OptionsOffset = rand()%2 ? sizeof(ICMP_ECHO_REQUEST) : rand()%10000;
        ((PICMP_ECHO_REQUEST)abInBuffer)->OptionsSize = rand()%10 ? rand()%10000 : 0;;
        ((PICMP_ECHO_REQUEST)abInBuffer)->Padding = rand();

        SetInParam(dwInBuff, sizeof(ICMP_ECHO_REQUEST)+((PICMP_ECHO_REQUEST)abInBuffer)->DataSize+((PICMP_ECHO_REQUEST)abInBuffer)->OptionsSize);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(ICMP_ECHO_REPLY));

		break;

	case IOCTL_ARP_SEND_REQUEST:
        ((PARP_SEND_REPLY)abInBuffer)->DestAddress = GetRandomAddress();
        ((PARP_SEND_REPLY)abInBuffer)->SrcAddress = GetRandomAddress();

        SetInParam(dwInBuff, sizeof(ARP_SEND_REPLY));

        SetOutParam(abOutBuffer, dwOutBuff, rand());

		break;

	case IOCTL_IP_INTERFACE_INFO:
        SetInParam(dwInBuff, 0);

		//IP_INTERFACE_INFO 
        SetOutParam(abOutBuffer, dwOutBuff, (rand()%10) * sizeof(IP_ADAPTER_INDEX_MAP) + sizeof(ULONG));//PIP_INTERFACE_INFO

		break;

	case IOCTL_IP_GET_IGMPLIST:
        *((IPAddr*)abInBuffer) = GetRandomAddress();
        SetInParam(dwInBuff, sizeof(IPAddr));

        SetOutParam(abOutBuffer, dwOutBuff, rand());

		break;

	case IOCTL_IP_GET_BEST_INTERFACE:
        *((IPAddr*)abInBuffer) = GetRandomAddress();
        SetInParam(dwInBuff, sizeof(ULONG));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG));

		break;

	case IOCTL_IP_SET_ADDRESS:
	case IOCTL_IP_SET_ADDRESS_DUP:
        ((IP_SET_ADDRESS_REQUEST*)abInBuffer)->Context = (USHORT)GetRandomContext(this);
        ((IP_SET_ADDRESS_REQUEST*)abInBuffer)->Address = GetRandomAddress();
        ((IP_SET_ADDRESS_REQUEST*)abInBuffer)->SubnetMask = GetRandomSubnetMask(this);
        SetInParam(dwInBuff, sizeof(IP_SET_ADDRESS_REQUEST));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG));

		break;

	case IOCTL_IP_SET_BLOCKOFROUTES:
		{
			DWORD dwLen = SIZEOF_INOUTBUFF;
			FillBufferWithRandomData(abInBuffer, dwLen);
		}
	/******************************************************
	BUG #428029.
	enable numofroutes=0 after bug is fixed
	******************************************************/
        ((IPRouteBlock*)abInBuffer)->numofroutes = 1+rand()%100;
	/******************************************************
	BUG #428029.
	enable numofroutes=0 after bug is fixed
	******************************************************/
        SetInParam(dwInBuff, rand()%100+((IPRouteBlock*)abInBuffer)->numofroutes*sizeof(IPRouteEntry)+ sizeof(ULONG));

        SetOutParam(abOutBuffer, dwOutBuff, rand()%10 + rand()%((IPRouteBlock*)abInBuffer)->numofroutes);

		break;

	case IOCTL_IP_SET_ROUTEWITHREF:
		SetRandom_IPRouteEntry(this, (IPRouteEntry*)abInBuffer);

        SetInParam(dwInBuff, sizeof(IPRouteEntry));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG));

		break;

	case IOCTL_IP_SET_MULTIHOPROUTE:
		{
			((IPMultihopRouteEntry*)abInBuffer)->imre_numnexthops = rand()%100;
			SetRandom_IPRouteEntry(this, &((IPMultihopRouteEntry*)abInBuffer)->imre_routeinfo);
			for (UINT i = 0; i < ((IPMultihopRouteEntry*)abInBuffer)->imre_numnexthops; i++)
			{
				SetRandom_IPRouteNextHopEntry(this, &((((IPMultihopRouteEntry*)abInBuffer)->imre_morenexthops)[i]));
			}

			SetInParam(dwInBuff, sizeof(IPMultihopRouteEntry)+((IPMultihopRouteEntry*)abInBuffer)->imre_numnexthops*sizeof(IPRouteNextHopEntry));

			SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG));
		}

		break;

	case IOCTL_IP_ADD_NTE:
		{
			/*
			WCHAR *s_wszIterfaceName[]=
			{
				L"\\Device\\TCPIP_",
				L"NetBT_TCPIP_",
				L"NetBT_",
				L"\\Device\\TcpIp_SomeGarbageInterfaceName-4",
				L"\\Device\\TcpIp_SomeGarbageInterfaceName-5",
				L"\\Device\\TcpIp_SomeGarbageInterfaceName-6",
				L"\\Device\\TcpIp_SomeGarbageInterfaceName-7",
				L"\\Device\\TcpIp_SomeGarbageInterfaceName-8",
				L"\\Device\\TcpIp_SomeGarbageInterfaceName-9",
				L"\\Device\\TcpIp_SomeGarbageInterfaceName-10",
				L""
			};
#define NUM_OF_INTERFACE_NAMES (sizeof(s_wszIterfaceName)/sizeof(*s_wszIterfaceName))
			*/
			((IP_ADD_NTE_REQUEST*)abInBuffer)->InterfaceContext = rand()%10 ? 0xffff : GetRandomContext(this);
			((IP_ADD_NTE_REQUEST*)abInBuffer)->Address = GetRandomAddress();
			((IP_ADD_NTE_REQUEST*)abInBuffer)->SubnetMask = GetRandomSubnetMask(this);
			SetAdapterName(((IP_ADD_NTE_REQUEST*)abInBuffer)->InterfaceNameBuffer);
			((IP_ADD_NTE_REQUEST*)abInBuffer)->InterfaceName.Length = rand()%2 ? MAX_INTERFACE_KEY_NAME_SIZE : rand()%10000;
			((IP_ADD_NTE_REQUEST*)abInBuffer)->InterfaceName.MaximumLength = rand()%10000+((IP_ADD_NTE_REQUEST*)abInBuffer)->InterfaceName.Length;

			//
			//next assignment is futile, since driver overrides this value
			//
			((IP_ADD_NTE_REQUEST*)abInBuffer)->InterfaceName.Buffer = rand()%2 ? NULL : (USHORT*)CIoctl::GetRandomIllegalPointer();
			SetInParam(dwInBuff, sizeof(IP_ADD_NTE_REQUEST)+((IP_ADD_NTE_REQUEST*)abInBuffer)->InterfaceName.Length);

			SetOutParam(abOutBuffer, dwOutBuff, sizeof(IP_ADD_NTE_RESPONSE));
		}

		break;

	case IOCTL_IP_DELETE_NTE:
		((IP_DELETE_NTE_REQUEST*)abInBuffer)->Context = (USHORT)GetRandomContext(this);

        SetInParam(dwInBuff, sizeof(IP_DELETE_NTE_REQUEST));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG));

		break;

	case IOCTL_IP_GET_NTE_INFO:
		((IP_GET_NTE_INFO_REQUEST*)abInBuffer)->Context = rand()%2 ? GetInstance() : (USHORT)GetRandomContext(this);

        SetInParam(dwInBuff, sizeof(IP_GET_NTE_INFO_REQUEST));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(IP_GET_NTE_INFO_RESPONSE));

		break;

	case IOCTL_IP_SET_DHCP_INTERFACE:
		((IP_SET_DHCP_INTERFACE_REQUEST*)abInBuffer)->Context = (USHORT)GetRandomContext(this);

        SetInParam(dwInBuff, sizeof(IP_SET_DHCP_INTERFACE_REQUEST));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

		break;

	case IOCTL_IP_SET_IF_CONTEXT:
		//unsupported
		break;

	case IOCTL_IP_SET_IF_PROMISCUOUS:
		((IP_SET_IF_PROMISCUOUS_INFO*)abInBuffer)->Index = GetRandom_ire_index();
		((IP_SET_IF_PROMISCUOUS_INFO*)abInBuffer)->Type = rand()%2 ? PROMISCUOUS_MCAST : rand()%10 ? PROMISCUOUS_BCAST : rand();
		((IP_SET_IF_PROMISCUOUS_INFO*)abInBuffer)->Add = rand()%2 ? TRUE : rand()%20 ? FALSE : rand();

        SetInParam(dwInBuff, sizeof(IP_SET_IF_PROMISCUOUS_INFO));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

		break;

	case IOCTL_IP_GET_BESTINTFC_FUNC_ADDR:
		//accessible only from kernel mode
		break;

	case IOCTL_IP_SET_FILTER_POINTER:
		//accessible only from kernel mode
		break;

	case IOCTL_IP_SET_FIREWALL_HOOK:
		//accessible only from kernel mode
		break;

	case IOCTL_IP_SET_MAP_ROUTE_POINTER:
		//accessible only from kernel mode
		break;

	case IOCTL_IP_RTCHANGE_NOTIFY_REQUEST:
	case IOCTL_IP_RTCHANGE_NOTIFY_REQUEST_EX:
	case IOCTL_IP_ADDCHANGE_NOTIFY_REQUEST:
		((IPNotifyData*)abInBuffer)->Version = DWORD_RAND;
		((IPNotifyData*)abInBuffer)->Add = rand()%2 ? rand()%2 : DWORD_RAND;
		//((IPNotifyData*)abInBuffer)->Info = xxx;

        SetInParam(dwInBuff, rand()%100+sizeof(IPNotifyData));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

		break;

	case IOCTL_IP_GET_PNP_ARP_POINTERS:
		//accessible only from kernel mode
		break;

	case IOCTL_IP_WAKEUP_PATTERN:
		((IP_WAKEUP_PATTERN_REQUEST*)abInBuffer)->InterfaceContext = GetRandomContext(this);
		((IP_WAKEUP_PATTERN_REQUEST*)abInBuffer)->PtrnDesc = (PNET_PM_WAKEUP_PATTERN_DESC)GetRandomContext(this); //0xfffffff0;//TODO: random pointer
		((IP_WAKEUP_PATTERN_REQUEST*)abInBuffer)->AddPattern = rand()%20 ? rand()%2 : rand();

        SetInParam(dwInBuff, sizeof(IP_WAKEUP_PATTERN_REQUEST));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

		break;

	case IOCTL_IP_GET_WOL_CAPABILITY:
	case IOCTL_IP_GET_OFFLOAD_CAPABILITY:
		*((ULONG*)abInBuffer) = GetRandomContext(this);

        SetInParam(dwInBuff, sizeof(ULONG));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG));

		break;

	case IOCTL_IP_GET_IP_EVENT:
		((IP_GET_IP_EVENT_REQUEST*)abInBuffer)->SequenceNo = GetRandom_SequenceNo(this);

        SetInParam(dwInBuff, sizeof(IP_GET_IP_EVENT_REQUEST ));

        SetOutParam(abOutBuffer, dwOutBuff, rand()%1000+sizeof(IP_GET_IP_EVENT_RESPONSE));

		break;

	case IOCTL_IP_FLUSH_ARP_TABLE:
		*((ULONG*)abInBuffer) = GetRandomContext(this);

        SetInParam(dwInBuff, sizeof(ULONG ));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

		break;

	case IOCTL_IP_GET_IF_INDEX:
		// OUT ((IP_GET_IF_INDEX_INFO*)abInBuffer)->Index
		SetRandomInterfaceName(((IP_GET_IF_INDEX_INFO*)abInBuffer)->Name);

        SetInParam(dwInBuff, rand()%10+2*wcslen(((IP_GET_IF_INDEX_INFO*)abInBuffer)->Name)+2+sizeof(IP_GET_IF_INDEX_INFO));

        SetOutParam(abOutBuffer, dwOutBuff, rand()%1000+sizeof(IP_GET_IF_INDEX_INFO));

		break;

	case IOCTL_IP_GET_IF_NAME:
		((IP_GET_IF_NAME_INFO*)abInBuffer)->Context = 
			rand()%2 ? 0 : // 0 is to start enumeration
			GetRandomInterfaceEnumerationContext(this);

        SetInParam(dwInBuff, sizeof(IP_GET_IF_NAME_INFO));

		//IP_GET_IF_NAME_INFO 
        SetOutParam(abOutBuffer, dwOutBuff, rand()%2 ? rand()%1000 : SIZEOF_INOUTBUFF);

		break;

	case IOCTL_IP_ENABLE_ROUTER_REQUEST:
		//
		// this is method buffered, and it seems to queue IRPs, 
		// until IOCTL_IP_UNENABLE_ROUTER_REQUEST removes them
		// so lets push big buffers (METHOD_BUFFERED) and cause
		// hogging of memory
		//
		dwInBuff = SIZEOF_INOUTBUFF;
		dwOutBuff = SIZEOF_INOUTBUFF;
		break;

	case IOCTL_IP_UNENABLE_ROUTER_REQUEST:
		*((void**)(abInBuffer)) = (void*)DWORD_RAND;

        SetInParam(dwInBuff, sizeof(void*));

		//RefCount 
        SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG));

		break;

	default:
		_tprintf(TEXT("CIoctlIp::PrepareIOCTLParams() 0x%08X is an unexpected IOCTL\n"), dwIOCTL);
		_ASSERTE(FALSE);
		CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
	}
}


BOOL CIoctlIp::FindValidIOCTLs(CDevice *pDevice)
{
	AddIOCTL(pDevice, IOCTL_ICMP_ECHO_REQUEST          );
	AddIOCTL(pDevice, IOCTL_ARP_SEND_REQUEST          );
	AddIOCTL(pDevice, IOCTL_IP_INTERFACE_INFO          );
	AddIOCTL(pDevice, IOCTL_IP_GET_IGMPLIST          );
	AddIOCTL(pDevice, IOCTL_IP_GET_BEST_INTERFACE          );
	AddIOCTL(pDevice, IOCTL_IP_SET_ADDRESS          );
	AddIOCTL(pDevice, IOCTL_IP_SET_ADDRESS_DUP          );
	AddIOCTL(pDevice, IOCTL_IP_SET_BLOCKOFROUTES          );
	AddIOCTL(pDevice, IOCTL_IP_SET_ROUTEWITHREF          );
	AddIOCTL(pDevice, IOCTL_IP_SET_MULTIHOPROUTE          );
	AddIOCTL(pDevice, IOCTL_IP_ADD_NTE          );
	AddIOCTL(pDevice, IOCTL_IP_DELETE_NTE          );
	AddIOCTL(pDevice, IOCTL_IP_GET_NTE_INFO          );
	AddIOCTL(pDevice, IOCTL_IP_SET_DHCP_INTERFACE          );
	AddIOCTL(pDevice, IOCTL_IP_SET_IF_CONTEXT          );
	AddIOCTL(pDevice, IOCTL_IP_SET_IF_PROMISCUOUS          );
	AddIOCTL(pDevice, IOCTL_IP_GET_BESTINTFC_FUNC_ADDR          );
	AddIOCTL(pDevice, IOCTL_IP_SET_FILTER_POINTER          );
	AddIOCTL(pDevice, IOCTL_IP_SET_FIREWALL_HOOK          );
	AddIOCTL(pDevice, IOCTL_IP_SET_MAP_ROUTE_POINTER          );
	AddIOCTL(pDevice, IOCTL_IP_RTCHANGE_NOTIFY_REQUEST          );
	AddIOCTL(pDevice, IOCTL_IP_RTCHANGE_NOTIFY_REQUEST_EX          );
	AddIOCTL(pDevice, IOCTL_IP_ADDCHANGE_NOTIFY_REQUEST          );
	AddIOCTL(pDevice, IOCTL_IP_GET_PNP_ARP_POINTERS          );
	/******************************************************
	BUG #428507.
	Un-remark after bug is fixed
	AddIOCTL(pDevice, IOCTL_IP_WAKEUP_PATTERN          );
	******************************************************/
	AddIOCTL(pDevice, IOCTL_IP_GET_WOL_CAPABILITY          );
	AddIOCTL(pDevice, IOCTL_IP_GET_OFFLOAD_CAPABILITY          );
	AddIOCTL(pDevice, IOCTL_IP_GET_IP_EVENT          );
	AddIOCTL(pDevice, IOCTL_IP_FLUSH_ARP_TABLE          );
	AddIOCTL(pDevice, IOCTL_IP_GET_IF_INDEX          );
	AddIOCTL(pDevice, IOCTL_IP_GET_IF_NAME          );
	AddIOCTL(pDevice, IOCTL_IP_ENABLE_ROUTER_REQUEST          );
	AddIOCTL(pDevice, IOCTL_IP_UNENABLE_ROUTER_REQUEST          );

    return TRUE;
}

ULONG CIoctlIp::GetRandom_ire_index()
{
	if (0 == rand()%10) return INVALID_IF_INDEX;
	if (0 == rand()%10) return LOCAL_IF_INDEX;
	if (0 == rand()%10) return rand()%100;
	return m_aulInterfaces[rand()%MAX_NUM_OF_REMEMBERED_INTERFACES];
}


void CIoctlIp::AddInterface(ULONG ulInterface)
{
	m_aulInterfaces[rand()%MAX_NUM_OF_REMEMBERED_INTERFACES] = ulInterface;
}

ULONG GetRandomContext(CIoctlIp* pThis)
{
	if (rand()%2) return (ULONG) CIoctl::GetRandomIllegalPointer();
	if (0 == rand()%5) return 0xffff;//INVALID_INTERFACE_CONTEXT;
	if (0 == rand()%5) return 0;
	if (0 == rand()%7) return 1;
	if (0 == rand()%9) return 2;
	if (0 == rand()%11) return 3;
	return DWORD_RAND;
}

ULONG GetRandom_SequenceNo(CIoctlIp* pThis)
{
	if (0 == rand()%3) return rand()%10;
	if (0 == rand()%3) return rand()%100;
	if (0 == rand()%3) return rand()%1000;
	if (0 == rand()%2) return rand();
	return DWORD_RAND;
}

unsigned long GetRandomSubnetMask(CIoctlIp* pThis)
{
	if (0 == rand()%2) return (rand()%2 ? rand() : rand()%2 ? 0 : rand()%2 ? DWORD_RAND : 0xffffffff);
	return (pThis->m_aulSubnetMask[rand()%MAX_NUM_OF_REMEMBERED_INTERFACES]);
}


ULONG GetRandom_ire_type(CIoctlIp* pThis)
{
	switch(rand()%5)
	{
	case 0:
		return IRE_TYPE_OTHER;
	case 1:
		return IRE_TYPE_INVALID;
	case 2:
		return IRE_TYPE_DIRECT;
	case 3:
		return IRE_TYPE_INDIRECT;
	default:
		return rand();
	}

}

ULONG GetRandom_ire_proto(CIoctlIp* pThis)
{
	switch(rand()%16)
	{
	case 0:
		return IRE_PROTO_OTHER;
	case 1:
		return IRE_PROTO_LOCAL;
	case 2:
		return IRE_PROTO_NETMGMT;
	case 3:
		return IRE_PROTO_ICMP;
	case 4:
		return IRE_PROTO_EGP;
	case 5:
		return IRE_PROTO_GGP;
	case 6:
		return IRE_PROTO_HELLO;
	case 7:
		return IRE_PROTO_RIP;
	case 8:
		return IRE_PROTO_IS_IS;
	case 9:
		return IRE_PROTO_ES_IS;
	case 10:
		return IRE_PROTO_CISCO;
	case 11:
		return IRE_PROTO_BBN;
	case 12:
		return IRE_PROTO_OSPF;
	case 13:
		return IRE_PROTO_BGP;
	case 14:
		return IRE_PROTO_PERSIST_LOCAL;
	default:
		return rand();
	}
}

ULONG GetRandom_ire_metric(CIoctlIp* pThis)
{
	if (rand()%2) return IRE_METRIC_UNUSED;
	if (0 == rand()%10) return 0;
	return DWORD_RAND;
}

void SetRandom_IPRouteEntry(CIoctlIp* pThis, IPRouteEntry* pIPRouteEntry)
{
    pIPRouteEntry->ire_dest = pThis->GetRandomAddress();
    pIPRouteEntry->ire_index = pThis->GetRandom_ire_index();
    pIPRouteEntry->ire_metric1 = GetRandom_ire_metric(pThis);
    pIPRouteEntry->ire_metric2 = GetRandom_ire_metric(pThis);
    pIPRouteEntry->ire_metric3 = GetRandom_ire_metric(pThis);
    pIPRouteEntry->ire_metric4 = GetRandom_ire_metric(pThis);
    pIPRouteEntry->ire_nexthop = pThis->GetRandomAddress();
    pIPRouteEntry->ire_type = GetRandom_ire_type(pThis);;
    pIPRouteEntry->ire_proto = GetRandom_ire_proto(pThis);
    pIPRouteEntry->ire_age = rand();
    pIPRouteEntry->ire_mask = rand()%2 ? 0xffffffff : rand()%2 ? 0 : DWORD_RAND;
    pIPRouteEntry->ire_metric5 = GetRandom_ire_metric(pThis);
}

void SetRandom_IPRouteNextHopEntry(CIoctlIp* pThis, IPRouteNextHopEntry* pIPRouteNextHopEntry)
{
    pIPRouteNextHopEntry->ine_iretype = GetRandom_ire_type(pThis);
    pIPRouteNextHopEntry->ine_nexthop = pThis->GetRandomAddress();
    pIPRouteNextHopEntry->ine_ifindex = pThis->GetRandom_ire_index();
    pIPRouteNextHopEntry->ine_context = (void*)GetRandomContext(pThis);
}

void AddInterfaceNameInfo(CIoctlIp* pThis, IP_INTERFACE_NAME_INFO* pInterfaceNameInfo)
{
	int nRandomIndex = rand()%MAX_NUM_OF_REMEMBERED_INTERFACES;
	pThis->m_aulInterfaces[nRandomIndex] = pInterfaceNameInfo->Index;
	pThis->m_ulMediaType[nRandomIndex] = pInterfaceNameInfo->MediaType;
	pThis->m_ucConnectionType[nRandomIndex] = pInterfaceNameInfo->ConnectionType;
	pThis->m_ucAccessType[nRandomIndex] = pInterfaceNameInfo->AccessType;
	pThis->m_DeviceGuid[nRandomIndex] = pInterfaceNameInfo->DeviceGuid;
	pThis->m_ulInterfaceGuid[nRandomIndex] = pInterfaceNameInfo->InterfaceGuid;
}

ULONG GetRandomInterfaceEnumerationContext(CIoctlIp* pThis)
{
	return pThis->m_aulInterfaceEnumerationContext[rand()%MAX_NUM_OF_REMEMBERED_INTERFACES];
}

void CIoctlIp::AddInterfaceEnumerationContext(ULONG ulContext)
{
	m_aulInterfaceEnumerationContext[rand()%MAX_NUM_OF_REMEMBERED_INTERFACES] = ulContext;
}

void CIoctlIp::AddInstance(ULONG Instance)
{
	m_aulInstance[rand()%MAX_NUM_OF_REMEMBERED_INTERFACES] = Instance;
}

ULONG CIoctlIp::GetInstance()
{
	return m_aulInstance[rand()%MAX_NUM_OF_REMEMBERED_INTERFACES];
}

void CIoctlIp::AddAddress(ULONG Address)
{
	m_aulAddress[rand()%MAX_NUM_OF_REMEMBERED_INTERFACES] = Address;
}

unsigned long CIoctlIp::GetRandomAddress()
{
	if (0 == rand()%2) return (rand()%2 ? rand() : rand()%2 ? 0 : rand()%2 ? 0xffffffff : DWORD_RAND);
	return m_aulAddress[rand()%MAX_NUM_OF_REMEMBERED_INTERFACES];
}


void CIoctlIp::AddSubnetMask(ULONG SubnetMask)
{
	m_aulSubnetMask[rand()%MAX_NUM_OF_REMEMBERED_INTERFACES] = SubnetMask;
}

void CIoctlIp::AddFlags(ULONG Flags)
{
	m_aulFlags[rand()%MAX_NUM_OF_REMEMBERED_INTERFACES] = Flags;
}

ULONG CIoctlIp::GetFlags()
{
	if (0 == rand()%2) return (rand()%2 ? rand() : DWORD_RAND);
	return m_aulFlags[rand()%MAX_NUM_OF_REMEMBERED_INTERFACES];
}

void CIoctlIp::SetRandomInterfaceName(WCHAR *wszInterfaceName)
{
	DWORD dwIndex;
	/*
	static WCHAR* s_awszInterfaceNames[] =
	{
		//L"{D34C9751-7B85-4EC2-88A2-961D473775E1}",
		//L"{D39030FB-EEAA-4F73-985E-F7928896FBD3}",
		//L"{61797510-CF09-11D2-9E04-9B8E7C2F5721}",
		L"{C1CCBDBD-C0F2-4B66-8D28-434C0CDF1D3C}"
	};
*/
	//
	// every once in a while, update from the registry
	//
	if (0 == rand()%1000)
	{
		::InterlockedExchange(&m_fInterfaceNamesInitialized, FALSE);
	}
	if (!::InterlockedExchange(&m_fInterfaceNamesInitialized, TRUE))
	{
		HKEY hkInterfaces = NULL;

		LONG lRes = ::RegOpenKey(
			HKEY_LOCAL_MACHINE,        // handle to open key
			TEXT("SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces"), // name of subkey to open
			&hkInterfaces   // handle to open key
			);
		if (ERROR_SUCCESS != lRes)
		{
			DPF((TEXT("CIoctlIp::SetRandomInterfaceName(): RegOpenKey(HKEY_LOCAL_MACHINE, SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces) failed with %d\n"), lRes));
			_ASSERTE(FALSE);
			return;
		}

		for(dwIndex = 0; dwIndex < MAX_NUM_OF_REMEMBERED_INTERFACES; dwIndex++)
		{
			ZeroMemory(m_awszInterfaceNames[dwIndex], MAX_INTERFACE_KEY_NAME_SIZE*sizeof(WCHAR));
			lRes = ::RegEnumKey(
				hkInterfaces,     // handle to key to query
				dwIndex, // index of subkey to query
				m_awszInterfaceNames[dwIndex], // buffer for subkey name
				MAX_INTERFACE_KEY_NAME_SIZE-1   // size of subkey name buffer
				);
			if (ERROR_SUCCESS != lRes)
			{
				if (ERROR_NO_MORE_ITEMS == lRes)
				{
					//
					// no more items, break the loop
					//
					break;
				}
				DPF((TEXT("CIoctlIp::SetRandomInterfaceName(): RegEnumKey() failed with %d\n"), lRes));
				//
				// seems i should not enumerate no more
				//
				_ASSERTE(FALSE);
				break;
			}
			DPF((TEXT("CIoctlIp::SetRandomInterfaceName(): RegEnumKey() returned %s\n"), m_awszInterfaceNames[dwIndex]));
		}
		lRes = ::RegCloseKey(
			hkInterfaces   // handle to key to close
			);
		if (ERROR_SUCCESS != lRes)
		{
			DPF((TEXT("CIoctlIp::SetRandomInterfaceName(): RegCloseKey(hkInterfaces) failed with %d\n"), lRes));
		}
	}

	wcsncpy(wszInterfaceName, m_awszInterfaceNames[rand()%MAX_NUM_OF_REMEMBERED_INTERFACES], MAX_INTERFACE_KEY_NAME_SIZE-1);
	wszInterfaceName[MAX_INTERFACE_KEY_NAME_SIZE-1] = L'\0';
}

void CIoctlIp::AddAdapterIndexAndName(ULONG ulIndex, WCHAR *wszName)
{
	UINT i = rand()%MAX_NUM_OF_REMEMBERED_INTERFACES;
	m_aulAdapterIndex[i] = ulIndex;
	wcsncpy(m_awszAdapterName[i], wszName, MAX_INTERFACE_KEY_NAME_SIZE-1);
	m_awszAdapterName[i][MAX_INTERFACE_KEY_NAME_SIZE-1] = L'\0';
}

void CIoctlIp::SetAdapterName(char * wszAdapterName)
{
	wcsncpy((WCHAR*)wszAdapterName, m_awszAdapterName[rand()%MAX_NUM_OF_REMEMBERED_INTERFACES], MAX_INTERFACE_KEY_NAME_SIZE);
	if (0 == rand()%10)
	{
		//
		// corrupt 1 byte
		//
		(wszAdapterName)[rand()%(2+2*MAX_INTERFACE_KEY_NAME_SIZE)] = rand()%0xff;
	}
}

ULONG CIoctlIp::GetAdapterIndex()
{
	if (0 == rand()%10) return rand()%100;
	return m_aulAdapterIndex[rand()%MAX_NUM_OF_REMEMBERED_INTERFACES];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\ipfltdrvioctl.h ===
#ifndef __IPFLTRDRV_IOCTL_H
#define __IPFLTRDRV_IOCTL_H

//#include "IOCTL.h"



#define MAX_NUM_OF_REMEMBERED_DRIVER_CONTEXTS (10)
#define MAX_NUM_OF_REMEMBERED_FILTER_HANDLES (10)
#define MAX_NUM_OF_REMEMBERED_FILTER_RULES (10)
#define MAX_NUM_OF_REMEMBERED_FILTER_FLAGS (10)

class CIoctlIpfltrdrv : public CIoctl
{
public:
    CIoctlIpfltrdrv(CDevice *pDevice);
    virtual ~CIoctlIpfltrdrv();

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);



    PVOID m_apvDriverContext[MAX_NUM_OF_REMEMBERED_DRIVER_CONTEXTS];
    PVOID m_apvFilterHandle[MAX_NUM_OF_REMEMBERED_FILTER_HANDLES];
    DWORD m_apvFilterRules[MAX_NUM_OF_REMEMBERED_FILTER_RULES];
    DWORD m_apvFilterFlags[MAX_NUM_OF_REMEMBERED_FILTER_FLAGS];

    HANDLE m_hEvent;
    HANDLE GetRandomEvent();

};


#endif //__IPFLTRDRV_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\ioctl.h ===
//
// base class for deriving your own 'device' types for stress.
// the stress opens the device, and from several threads does the following:
//   DeviceWriteFile, (default is WriteFile) with probability of CDevice::m_nWriteFileProbability
//   DeviceReadFile, (default is ReadFile) with probability of CDevice::m_nReadFileProbability
//   DeviceInputOutputControl, (default is DeviceIoControl) with probability of CDevice::m_nDeviceIoControlProbability
//   CallRandomWin32API, (default is none) with probability of CDevice::m_nRandomWin32APIProbability
//   DeviceCancelIo, (default is CancelIo) with probability of CDevice::m_nCancelIoProbability
// over and over again
// bonuses:
//   for calls that need buffers:
//     with probability of CDevice::m_nTryDeCommittedBuffersProbability, the passed buffers
//       can be de-committed at any random time (including before the call)
//     with probability of CDevice::m_nBreakAlignmentProbability, the passed buffers may be
//       un-aligned

#ifndef __IOCTL_H
#define __IOCTL_H

#include <winioctl.h>

#include "Device.h"

#define ZERO_STRUCT(s) ZeroMemory(&s, sizeof(s))

//
// may be used in UseOutBuff() if you just want to randomly wait for the result
//
//
// wait, but do not block, because it may cause all threads to get stuck here
// which is bad
//
#define RANDOMLY_WAIT_FOR_OL_RESULT(max_times_to_poll, max_time_to_sleep_each_poll) \
    if (NULL != pOL)\
    {\
        DWORD dwBytesReturned;\
		for (int i = 0; i < rand()%(max_times_to_poll); i++)\
		{\
			if (::GetOverlappedResult(GetDeviceHandle(), pOL, &dwBytesReturned, FALSE))\
			{\
				break;\
			}\
			else\
			{\
				::Sleep(rand()%(max_time_to_sleep_each_poll));\
			}\
		}\
    }
/*
the old, blocking version
#define RANDOMLY_WAIT_FOR_OL_RESULT \
    if (NULL != pOL)\
    {\
        DWORD dwBytesReturned;\
		if (!::GetOverlappedResult(GetDeviceHandle(), pOL, &dwBytesReturned, FALSE))\
		{\
			if (rand()%4 == 0)\
			{\
				if (!::GetOverlappedResult(GetDeviceHandle(), pOL, &dwBytesReturned, TRUE)) return ;\
			}\
			else\
			{\
				return;\
			}\
		}\
    }
*/

//
// buffs for DeviceIoControl(), read & write, hope that's big enough for all needs
// may not exceed RAND_MAX !
//
#define SIZEOF_INOUTBUFF (RAND_MAX-1)

//
// generic array size, for arrays that remember items gotten from UseOutBuff()
// to be used later in PrepareIoctlParams()
//
#define MAX_NUM_OF_REMEMBERED_ITEMS (16)

//
// rand() is only 15 bits, so it is 15 bits shifted 17, + 15 bit shifted 2, + 2 bits
//
#define DWORD_RAND (((rand()%2)<<17) | (rand()<<2) | (rand()%4))

//
// forward declaration
//
class CDevice;


//
// and finally the class itself...
//
class CIoctl
{
public:
	//
	// there's no default ctor.
	// a ctor must always get the "containing" CDevice.
	//
    CIoctl(CDevice *pDevice):
        m_pDevice(pDevice),
        m_fUseRandomIOCTLValues(false),
		m_iAccess(0),
		m_iShare(0),
		m_iCreationDisposition(0),
		m_iAttributes(0),
		m_fUseOverlapped(true)
    {
        InterlockedIncrement(&sm_lObjectCount);
    }
    virtual ~CIoctl()
    {
		CloseDevice(m_pDevice);
        InterlockedDecrement(&sm_lObjectCount);
    }

	//
	// This method creates/open the device.
	// this is where you choose the specific flags for CreateFile(), or even use 
	// another function, such as CreateNamedPipe()
	// The default behaviour, is to try and CreateFile() with a set of hardcoded
	// possibilities for flags.
	//
	virtual HANDLE CreateDevice(CDevice *pDevice);

	//
	// you may wish to override this method, for example to perform post
	// close actions, like deleting the file, or whatever
	//
	virtual BOOL CloseDevice(CDevice *pDevice)
	{
		BOOL fRet = ::CloseHandle(pDevice->m_hDevice);
		//
		// BUGBUG: if we get a context switch here, and another thread
		// gets the HANDLE value that we just closed, the IOCTELLING threads
		// may IOCTL a device that we did not intend to, thus crashing ourselves
		// I think we should live with it.
		//
		pDevice->m_hDevice = INVALID_HANDLE_VALUE;
		return fRet;
	}

    //
    // This method finds out all the valid IOCTLs that will be used.
    // The default is to try all numbers between 0x00008000 and 0x00700000, and
    // the call succeeds / fails reasonably, this IOCTL will later be used for
    // test.
    // Note that when you implement this method, you may add illegal IOCTLs
    // to test your device under illegal IOCTLs.
    // You usually implement this method by simply building the array of IOCTLs
	// by calling AddIOCTL() repeatedly
	// withing this overridden methods you should call the relevant methods
	// from EnableReadFile(), DisableReadFile(), EnableWriteFile(), DisableWriteFile()
    //
    virtual BOOL FindValidIOCTLs(CDevice *pDevice) = 0;

    //
    // This method prepares the parameters for DeviceIoControl()
    // The default imp is random buffer size & contents.
    // Use it to fill the buffs with "pseudo" real contents, so that
    // the IOCTL will not fail on parameter checking only.
    //
    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abIn,
        DWORD &dwIn,
        BYTE *abOut,
        DWORD &dwOut        
        ) = 0;

    //
    // This method is used for trying to keep some context in the chaos.
    // For example, if you call a IOCTL that returns some context HANDLE,
    // you may wish to keep it and maybe used it in following IOCTLS.
    // This does not mean that you should keep a full state of the driver,
    // but it's a fine heuristic for sending reasonable IOCTLS.
	// pOL is NULL if DeviceIoControl() succeeded immediately, and the OL
	// if DeviceIoControl() fails with io pending.
	// this method is not called if DeviceIoControl() failed.
    //
    virtual void UseOutBuff(
        DWORD dwIOCTL, 
        BYTE *abOutBuffer, 
        DWORD dwOutBuff,
        OVERLAPPED *pOL
        ) = 0;

	//
	// IRP_MJ_WRITE
	// override this method if your device does not use ::WriteFile() for writing
	//
	virtual BOOL DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		)
	{
		return ::WriteFile(
			hFile,                    // handle to file to write to
			lpBuffer,                // pointer to data to write to file
			nNumberOfBytesToWrite,     // number of bytes to write
			lpNumberOfBytesWritten,  // pointer to number of bytes written
			lpOverlapped        // pointer to structure for overlapped I/O
			);
	}

	//
	// IRP_MJ_READ
	// override this method if your device does not use ::ReadFile() for writing
	//
	virtual BOOL DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		)
	{
		return ::ReadFile(
			hFile,                // handle of file to read
			lpBuffer,             // pointer to buffer that receives data
			nNumberOfBytesToRead,  // number of bytes to read
			lpNumberOfBytesRead, // pointer to number of bytes read
			lpOverlapped    // pointer to structure for data
			);
	}

	//
	// override this method, if you wish to randomly call any API
	// usually you will call API relevant to your device, but you can call whatever you like
	// example: ::LockFileEx() for a device of type file
	//
	virtual void CallRandomWin32API(LPOVERLAPPED pOL) = 0;

	//
	// IRP_MJ_DEVICE_CONTROL or IRP_MJ_FILE_SYSTEM_CONTROL
	// override this method if your device does not use ::DeviceIoControl() for writing
	//
	virtual BOOL DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		)
	{
		return ::DeviceIoControl(
			hDevice,              // handle to a device, file, or directory 
			dwIoControlCode,       // control code of operation to perform
			lpInBuffer,           // pointer to buffer to supply input data
			nInBufferSize,         // size, in bytes, of input buffer
			lpOutBuffer,          // pointer to buffer to receive output data
			nOutBufferSize,        // size, in bytes, of output buffer
			lpBytesReturned,     // pointer to variable to receive byte count
			lpOverlapped    // pointer to structure for asynchronous operation
			);
	}

	//
	// IRP_MJ_QUERY_VOLUME_INFORMATION
	// NtQueryVolumeInformationFile()
	//
	virtual BOOL DeviceQueryVolumeInformationFile(
		IN HANDLE FileHandle,
		OVERLAPPED *pOverlapped,//OUT PIO_STATUS_BLOCK IoStatusBlock,
		OUT PVOID FsInformation,
		IN ULONG Length,
		IN FS_INFORMATION_CLASS FsInformationClass
		);

	//
	// IRP_MJ_QUERY_INFORMATION
	// NtQueryInformationFile()
	//
	virtual BOOL DeviceQueryInformationFile(
		IN HANDLE FileHandle,
		OVERLAPPED *pOverlapped,//OUT PIO_STATUS_BLOCK IoStatusBlock,
		OUT PVOID FileInformation,
		IN ULONG Length,
		IN FILE_INFORMATION_CLASS FileInformationClass
		);
	//
	// IRP_MJ_SET_INFORMATION
	// NtSetInformationFile()
	//
	virtual BOOL DeviceSetInformationFile(
		IN HANDLE FileHandle,
		OVERLAPPED *pOverlapped,//OUT PIO_STATUS_BLOCK IoStatusBlock,
		OUT PVOID FileInformation,
		IN ULONG Length,
		IN FILE_INFORMATION_CLASS FileInformationClass
		);

	//
	// IRP_MJ_DIRECTORY_CONTROL
	// NtQueryInformationFile()
	//
	virtual BOOL DeviceQueryDirectoryFile(
		IN HANDLE FileHandle,
		IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
		IN PVOID ApcContext OPTIONAL,
		OVERLAPPED *pOverlapped,//OUT PIO_STATUS_BLOCK IoStatusBlock,IN HANDLE Event OPTIONAL
		OUT PVOID FileInformation,
		IN ULONG Length,
		IN FILE_INFORMATION_CLASS FileInformationClass,
		IN BOOLEAN ReturnSingleEntry,
		IN PUNICODE_STRING FileName OPTIONAL,
		IN BOOLEAN RestartScan
		);

	virtual BOOL DeviceQueryFullAttributesFile(
		IN WCHAR * wszName,
		OUT PFILE_NETWORK_OPEN_INFORMATION FileInformation
		);

	virtual BOOL DeviceNotifyChangeDirectoryFile(
		IN HANDLE FileHandle,
		OVERLAPPED *pOverlapped,//OUT PIO_STATUS_BLOCK IoStatusBlock,IN HANDLE Event OPTIONAL
		IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
		IN PVOID ApcContext OPTIONAL,
		OUT PVOID Buffer,
		IN ULONG Length,
		IN ULONG CompletionFilter,
		IN BOOLEAN WatchTree
		);

	void GetRandom_FsInformationClassAndLength(
		FS_INFORMATION_CLASS *FsInformationClass, 
		ULONG *Length
		);
	void GetRandom_FileInformationClassAndLength(
		FILE_INFORMATION_CLASS *FileInformationClass, 
		ULONG *Length
		);

	//
	// override this method if your device does not use ::DeviceIoControl() for writing
	//
	virtual BOOL DeviceCancelIo(
		HANDLE hFile  // file handle for which to cancel I/O
		)
	{
		return ::CancelIo(
			hFile  // file handle for which to cancel I/O
			);
	}

	//
	// use it to add IOCTLs that will be called.
	// this method is usually called successively from FindValidIOCTLs()
	//
    void AddIOCTL(CDevice *pDevice, DWORD dwIOCTL);

	//
	// methods for setting params with random content
	//
    static void SetInParam(DWORD &dwInBuff, DWORD dwExpectedSize);
    static void SetOutParam(BYTE* &abOutBuffer, DWORD &dwOutBuff, DWORD dwExpectedSize);

	static void* GetRandomIllegalPointer();

	//
	// do not override
	// this is the thread that does the acual work of IOCTeLling
	//
    friend DWORD WINAPI IoctlThread(LPVOID pVoid);

    static void FillBufferWithRandomData(void *pBuff, DWORD &dwSize);

	static DWORD GetRandom_CompletionFilter();

	static IO_STATUS_BLOCK* GetRandomIllegalIoStatusBlock(OVERLAPPED *pOverlapped);

	static void* SetOutBuffToEndOfBuffOrFurther(void* pBuff, UINT len)
	{
		//
		// this should not overflow
		// but i will truncate the special case of RAND_MAX
		//
		if (RAND_MAX == len) len = SIZEOF_INOUTBUFF;
		else _ASSERTE(len <= SIZEOF_INOUTBUFF);

		if (rand()%20)	return (PVOID)((UINT)pBuff-len + SIZEOF_INOUTBUFF);

		//
		// this may AV/corrupt, so page heap is required
		//
		if (rand()%2) return (PVOID)((UINT)pBuff-len + SIZEOF_INOUTBUFF + rand()%4);

		//
		// this may AV
		//
		return GetRandomIllegalPointer();
	}

protected:

	static long sm_lObjectCount;

	//
	// returns the HANDLE to the device, as return by the CreateFile()
	//
    HANDLE GetDeviceHandle(){ return m_pDevice->m_hDevice;}

	//
	// the device for which we IOCTL
	//
    CDevice *m_pDevice;

	// false by default.
	// set to true, if you wish to use random IOCTL values as well,
	// and not only the ones declared in FindValidIOCTLs()
	//
    bool m_fUseRandomIOCTLValues;


	//
	// mailslots, for example must get a NULL OL structure, so 
	// set m_fUseOverlapped to false if you want to force NULL OL 
	// operations.
	bool m_fUseOverlapped;

    BOOL PrepareOverlappedStructure(OVERLAPPED *pol);

	//
	// return a pointer into pbAllocatedOutBuffer such that with length of dwAmoutToReadWrite
	// it will reach exactly the end of the buffer, and if using PageHeap, it helps
	// catch drivers that do not verify user buffers.
	//
	static BYTE * FixupInOutBuffToEndOnEndOfPhysicalPage(BYTE * pbAllocatedOutBuffer, DWORD dwAmoutToReadWrite);

private:
    //
    // indices to corresponding static constant arrays for CreateFile() parameters
    //
    int m_iAccess;
    int m_iShare;
    int m_iCreationDisposition;
    int m_iAttributes;

    
    bool SetSrandFile(long lIndex);

};

#endif //__IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\ipioctl.h ===
#ifndef __IP_IOCTL_H
#define __IP_IOCTL_H

//#include "NtNativeIOCTL.h"


class CIoctlIp : public CIoctlNtNative
{
public:
    CIoctlIp(CDevice *pDevice): CIoctlNtNative(pDevice), m_fInterfaceNamesInitialized(FALSE)
	{
		_ASSERTE(0 == lstrcmpi(TEXT("\\Device\\Ip"), pDevice->GetDeviceName()));
	}
    virtual ~CIoctlIp(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);
/*

	virtual HANDLE CreateDevice(CDevice *pDevice);

	virtual BOOL CloseDevice(CDevice *pDevice);

	virtual BOOL DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		);

	virtual BOOL DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		);

	virtual BOOL DeviceCancelIo(
		HANDLE hFile  // file handle for which to cancel I/O
		);


	virtual BOOL DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		);
*/

#define MAX_NUM_OF_REMEMBERED_INTERFACES 8
#define MAX_INTERFACE_KEY_NAME_SIZE 128
	ULONG m_aulInterfaces[MAX_NUM_OF_REMEMBERED_INTERFACES];
	void AddInterface(ULONG ulInterface);
	void AddInterfaceEnumerationContext(ULONG ulContext);
	void AddInstance(ULONG Instance);
	ULONG GetInstance();
	void AddAddress(ULONG Address);
	unsigned long GetRandomAddress();
	void AddSubnetMask(ULONG SubnetMask);
	void AddFlags(ULONG Flags);
	ULONG GetFlags();
	void AddAdapterIndexAndName(ULONG ulIndex, WCHAR *wszName);
	void SetAdapterName(char * wszAdapterName);
	ULONG GetAdapterIndex();

	void SetRandomInterfaceName(WCHAR *wszInterfaceName);

	ULONG GetRandom_ire_index();
	ULONG m_aulInterfaceEnumerationContext[MAX_NUM_OF_REMEMBERED_INTERFACES];
	ULONG m_ulMediaType[MAX_NUM_OF_REMEMBERED_INTERFACES];
	UCHAR m_ucConnectionType[MAX_NUM_OF_REMEMBERED_INTERFACES];
	UCHAR m_ucAccessType[MAX_NUM_OF_REMEMBERED_INTERFACES];
	GUID m_DeviceGuid[MAX_NUM_OF_REMEMBERED_INTERFACES];
	GUID m_ulInterfaceGuid[MAX_NUM_OF_REMEMBERED_INTERFACES];
	ULONG m_aulInstance[MAX_NUM_OF_REMEMBERED_INTERFACES];
	ULONG m_aulAddress[MAX_NUM_OF_REMEMBERED_INTERFACES];
	ULONG m_aulSubnetMask[MAX_NUM_OF_REMEMBERED_INTERFACES];
	ULONG m_aulFlags[MAX_NUM_OF_REMEMBERED_INTERFACES];
	WCHAR m_awszInterfaceNames[MAX_NUM_OF_REMEMBERED_INTERFACES][MAX_INTERFACE_KEY_NAME_SIZE];
	long m_fInterfaceNamesInitialized;
	ULONG m_aulAdapterIndex[MAX_NUM_OF_REMEMBERED_INTERFACES];
	WCHAR m_awszAdapterName[MAX_NUM_OF_REMEMBERED_INTERFACES][MAX_INTERFACE_KEY_NAME_SIZE];

};




#endif //__IP_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\ipmcastioctl.h ===
#ifndef __IPMCAST_IOCTL_H
#define __IPMCAST_IOCTL_H

//#include "NtNativeIOCTL.h"


class CIoctlIpMcast : public CIoctlNtNative
{
public:
    CIoctlIpMcast(CDevice *pDevice): CIoctlNtNative(pDevice), m_fDriverStarted(false)
	{
		_ASSERTE(0 == lstrcmpi(TEXT("\\Device\\IPMULTICAST"), pDevice->GetDeviceName()));
	}
    virtual ~CIoctlIpMcast(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

	virtual BOOL CloseDevice(CDevice *pDevice);

/*

	virtual HANDLE CreateDevice(CDevice *pDevice);

	virtual BOOL DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		);

	virtual BOOL DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		);

	virtual BOOL DeviceCancelIo(
		HANDLE hFile  // file handle for which to cancel I/O
		);


	virtual BOOL DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		);
*/

private:
	UINT GetRandomInterfaceIndex();
	UINT GetRandomGroup();
	UINT GetRandomSource();
	UINT GetRandomSrcMask();

	long m_fDriverStarted;

#define MAX_NUM_OF_REMEMBERED_INTERFACES 8
	UINT m_aulInterfaceIndex[MAX_NUM_OF_REMEMBERED_INTERFACES];
	void AddInterfaceIndex(UINT index);

};




#endif //__IPMCAST_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\ipsecioctl.h ===
#ifndef __IPSEC_IOCTL_H
#define __IPSEC_IOCTL_H

//#include "NtNativeIOCTL.h"


class CIoctlIpSec : public CIoctlNtNative
{
public:
    CIoctlIpSec(CDevice *pDevice): CIoctlNtNative(pDevice)
	{
		_ASSERTE(0 == lstrcmpi(TEXT("\\Device\\IPSEC"), pDevice->GetDeviceName()));
	}
    virtual ~CIoctlIpSec(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);
/*

	virtual HANDLE CreateDevice(CDevice *pDevice);

	virtual BOOL CloseDevice(CDevice *pDevice);

	virtual BOOL DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		);

	virtual BOOL DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		);

	virtual BOOL DeviceCancelIo(
		HANDLE hFile  // file handle for which to cancel I/O
		);


	virtual BOOL DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		);
*/

	GUID m_aGuids[MAX_NUM_OF_REMEMBERED_ITEMS];
	ULONG m_aDestSrcAddr[MAX_NUM_OF_REMEMBERED_ITEMS];
	PVOID m_aContext[MAX_NUM_OF_REMEMBERED_ITEMS];
	ULONG m_aSPI[MAX_NUM_OF_REMEMBERED_ITEMS];

private:
	UINT GetRandomInterfaceIndex();
	UINT GetRandomGroup();
	UINT GetRandomSource();
	UINT GetRandomSrcMask();

};




#endif //__IPSEC_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\ipnat.h ===
/*++

Copyright (c) 1997, Microsoft Corporation

Module Name:

    ipnat.h

Abstract:

    Contains semi-public IOCTLS and data-structures related to
    the IP Network Address Translator.

    For kernel-mode load-balancing support, see the director-registration
    declarations below (IOCTL_IP_NAT_REGISTER_DIRECTOR).

    For kernel-mode data-stream editing support, see the editor-registration
    declarations below (IOCTL_IP_NAT_REGISTER_EDITOR).

Author:

    Abolade Gbadegesin (t-abolag) 11-July-1997

Revision History:

--*/

#ifndef _ROUTING_IP_NAT_H_
#define _ROUTING_IP_NAT_H_

#include <rtinfo.h>             // for RTR_INFO_BLOCK_HEADER
#include <ipinfoid.h>           // for IP_GENERAL_INFO_BASE

#ifdef __cplusplus
extern "C" {
#endif

//
// MISCELLANEOUS DECLARATIONS
//

#define IP_NAT_VERSION          1

#define IP_NAT_SERVICE_NAME     "IPNAT"

#define DD_IP_NAT_DEVICE_NAME   L"\\Device\\IPNAT"

//
// IP header protocol-field constants
//

#define NAT_PROTOCOL_ICMP       0x01
#define NAT_PROTOCOL_IGMP       0x02
#define NAT_PROTOCOL_TCP        0x06
#define NAT_PROTOCOL_UDP        0x11
#define NAT_PROTOCOL_PPTP       0x2F

typedef enum {
    NatInboundDirection = 0,
    NatOutboundDirection,
    NatMaximumDirection
} IP_NAT_DIRECTION, *PIP_NAT_DIRECTION;

typedef enum {
    NatForwardPath = 0,
    NatReversePath,
    NatMaximumPath
} IP_NAT_PATH, *PIP_NAT_PATH;

typedef enum {
    NatCreateFailureDeleteReason = 0,
    NatCleanupSessionDeleteReason,
    NatCleanupDirectorDeleteReason,
    NatDissociateDirectorDeleteReason,
    NatMaximumDeleteReason
} IP_NAT_DELETE_REASON, *PIP_NAT_DELETE_REASON;


//
// IOCTL DECLARATIONS
//

#define FSCTL_IP_NAT_BASE       FILE_DEVICE_NETWORK

#define _IP_NAT_CTL_CODE(function, method, access) \
    CTL_CODE(FSCTL_IP_NAT_BASE, function, method, access)

//
// NAT-supported IOCTL constant declarations
//

#define IOCTL_IP_NAT_SET_GLOBAL_INFO \
    _IP_NAT_CTL_CODE(0, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_REQUEST_NOTIFICATION \
    _IP_NAT_CTL_CODE(1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_CREATE_INTERFACE \
    _IP_NAT_CTL_CODE(2, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_DELETE_INTERFACE \
    _IP_NAT_CTL_CODE(3, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// Unused: Functions 4-5

#define IOCTL_IP_NAT_SET_INTERFACE_INFO \
    _IP_NAT_CTL_CODE(6, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_GET_INTERFACE_INFO \
    _IP_NAT_CTL_CODE(7, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_REGISTER_EDITOR \
    _IP_NAT_CTL_CODE(8, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_GET_INTERFACE_STATISTICS \
    _IP_NAT_CTL_CODE(9, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_GET_MAPPING_TABLE \
    _IP_NAT_CTL_CODE(10, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_REGISTER_DIRECTOR \
    _IP_NAT_CTL_CODE(11, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_CREATE_REDIRECT \
    _IP_NAT_CTL_CODE(12, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_CANCEL_REDIRECT \
    _IP_NAT_CTL_CODE(13, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_GET_INTERFACE_MAPPING_TABLE \
    _IP_NAT_CTL_CODE(14, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_GET_REDIRECT_STATISTICS \
    _IP_NAT_CTL_CODE(15, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_CREATE_DYNAMIC_TICKET \
    _IP_NAT_CTL_CODE(16, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_DELETE_DYNAMIC_TICKET \
    _IP_NAT_CTL_CODE(17, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_NAT_GET_REDIRECT_SOURCE_MAPPING \
    _IP_NAT_CTL_CODE(18, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// IOCTL_IP_NAT_SET_GLOBAL_INFO
//
// Invoked to supply the NAT with its configuration.
//
// InputBuffer: IP_NAT_GLOBAL_INFO
// OutputBuffer: none.
//

//
// IOCTL_IP_NAT_GET_GLOBAL_INFO
//
// Invoked to retrieve the NAT's configuration.
//
// InputBuffer: none.
// OutputBuffer: IP_NAT_GLOBAL_INFO
//

//
// IOCTL_IP_NAT_CREATE_INTERFACE
//
// Invoked to add router-interfaces to the NAT.
//
// InputBuffer: IP_NAT_CREATE_INTERFACE
// OutputBuffer: none.
//

//
// IOCTL_IP_NAT_DELETE_INTERFACE
//
// Invoked to delete router-interfaces from the NAT.
//
// InputBuffer: the 32-bit index of the interface to be deleted.
// OutputBuffer: none.
//

//
// IOCTL_IP_NAT_SET_INTERFACE_INFO
//
// Invoked to set configuration information for an interface.
//
// InputBuffer: 'IP_NAT_INTERFACE_INFO' holding the interface's configuration
// OutputBuffer: none.
//

//
// IOCTL_IP_NAT_GET_INTERFACE_INFO
//
// Invoked to retrieve the configuration information of an interface.
//
// InputBuffer: the 32-bit index of the interface in question
// OutputBuffer: 'IP_NAT_INTERFACE_INFO' holding the interface's configuration
//

//
// IOCTL_IP_NAT_GET_INTERFACE_STATISTICS
//
// This IOCTL is invoked to retrieve per-interface statistics.
//
// InputBuffer: the 32-bit index of the interface in question
// OutputBuffer: 'IP_NAT_INTERFACE_STATISTICS' with the interface's statistics
//

//
// IOCTL_IP_NAT_GET_MAPPING_TABLE
// IOCTL_IP_NAT_GET_INTERFACE_MAPPING_TABLE
//
// This IOCTL is invoked to enumerate the dynamic TCP and UDP mappings
// globally, and for each interface.
//
// InputBuffer: 'IP_NAT_ENUMERATE_SESSION_MAPPINGS' with input parameters set
// OutputBuffer: 'IP_NAT_ENUMERATE_SESSION_MAPPINGS' with output parameters
//      filled in.
//

//
// IOCTL_IP_NAT_REGISTER_EDITOR
//
// This IOCTL is invoked by a kernel-mode component which wishes to act
// as an editor for packets which match a particular session-description.
//
// InputBuffer: 'IP_NAT_REGISTER_EDITOR' with input parameters set
// OutputBuffer: 'IP_NAT_REGISTER_EDITOR' with output parameters filled in
//

//
// IOCTL_IP_NAT_REGISTER_DIRECTOR
//
// This IOCTL is invoked by a kernel-mode component that wishes to be consulted
// about the direction of incoming TCP/UDP sessions.
//
// InputBuffer: 'IP_NAT_REGISTER_DIRECTOR' with input parameters set
// OutputBuffer: 'IP_NAT_REGISTER_DIRECTOR' with output parameters filled in
// 

//
// IOCTL_IP_NAT_CREATE_REDIRECT
//
// Invoked to cancel or query a 'redirect' which instructs the NAT
// to modify a specific session.
//
// InputBuffer: 'IP_NAT_REDIRECT'
// OutputBuffer: 'IP_NAT_REDIRECT_STATISTICS'
//

//
// IOCTL_IP_NAT_CANCEL_REDIRECT
// IOCTL_IP_NAT_GET_REDIRECT_STATISTICS
// IOCTL_IP_NAT_GET_REDIRECT_SOURCE_MAPPING
//
// Invoked to cancel or query a 'redirect' which instructs the NAT
// to modify a specific session.
//
// InputBuffer: 'IP_NAT_REDIRECT'
// OutputBuffer:
//  cancel: Unused
//  statistics: 'IP_NAT_REDIRECT_STATISTICS'
//  source mapping: 'IP_NAT_REDIRECT_SOURCE_MAPPING'
//

//
// IOCTL_IP_NAT_REQUEST_NOTIFICATION
//
// Invoked to request notification of a specific event from the NAT.
//
// InputBuffer: 'IP_NAT_NOTIFICATION' indicating the notification required
// OutputBuffer: depends on 'IP_NAT_NOTIFICATION'.
//

//
// IOCTL_IP_NAT_CREATE_DYNAMIC_TICKET
//
// Invoked to create a dynamic ticket, which becomes active when specific
// outbound session is seen.
//
// InputBuffer: 'IP_NAT_CREATE_DYNAMIC_TICKET' describes the ticket
// OutputBuffer: none.
//

//
// IOCTL_IP_NAT_DELETE_DYNAMIC_TICKET
//
// Invoked to delete a dynamic ticket.
//
// InputBuffer: 'IP_NAT_DELETE_DYNAMIC_TICKET' describes the ticket.
// OutputBuffer: none.
//


//
// Structure:   IP_NAT_GLOBAL_INFO
//
// Holds global configuration information for the NAT.
//

typedef struct _IP_NAT_GLOBAL_INFO {
    ULONG LoggingLevel; // see IPNATHLP.H (IPNATHLP_LOGGING_*).
    ULONG Flags;
    RTR_INFO_BLOCK_HEADER Header;
} IP_NAT_GLOBAL_INFO, *PIP_NAT_GLOBAL_INFO;

#define IP_NAT_ALLOW_RAS_CLIENTS            0x00000001

//
// Type-codes for the IP_NAT_GLOBAL_INFO.Header.TocEntry[] array.
//
// The structures which correspond to each info-type are given below.
//

#define IP_NAT_TIMEOUT_TYPE             IP_GENERAL_INFO_BASE + 1
#define IP_NAT_PROTOCOLS_ALLOWED_TYPE   IP_GENERAL_INFO_BASE + 2

//
// Structure:   IP_NAT_TIMEOUT
//
// Used to amend the default timeouts for TCP and UDP session mappings.
//

typedef struct _IP_NAT_TIMEOUT {
    ULONG TCPTimeoutSeconds;
    ULONG UDPTimeoutSeconds;
} IP_NAT_TIMEOUT, *PIP_NAT_TIMEOUT;


//
// Structure:   IP_NAT_PROTOCOLS_ALLOWED
//
// Used to define which IP-layer protocols (other than TCP/UDP/ICMP/PPTP)
// may be translated by the NAT. Only one session for each such protocol
// is supported for each remote destination.
//

typedef struct _IP_NAT_PROTOCOLS_ALLOWED {
    ULONG Bitmap[256 / (sizeof(ULONG) * 8)];
} IP_NAT_PROTOCOLS_ALLOWED, *PIP_NAT_PROTOCOLS_ALLOWED;


//
// Structure:   IP_NAT_CREATE_INTERFACE
//
// 'Index' must correspond to a valid IP adapter-index.
// This implies that addition of a demand-dial interface can only occur
// when such an interface is connected.
//
// The field 'BindingInfo' should be the beginning of
// an IP_ADAPTER_BINDING_INFO structure (see routprot.h) which
// contains the interface's binding.
//

#pragma warning(disable:4200) // 0-element array

typedef struct _IP_NAT_CREATE_INTERFACE {
    IN ULONG Index;
    IN ULONG BindingInfo[0];
} IP_NAT_CREATE_INTERFACE, *PIP_NAT_CREATE_INTERFACE;

#pragma warning(default:4200)

// 
// Structure:   IP_NAT_INTERFACE_INFO
//
// 'Index' identifies the interface to be configured.
//
// The configuration information uses the RTR_INFO_BLOCK_HEADER structure
// of rtinfo.h. See below for the type-codes for structures which may appear
// after IP_NAT_INTERFACE_INFO.Header within the RTR_TOC_ENTRY.InfoType field.
//

typedef struct _IP_NAT_INTERFACE_INFO {
    ULONG Index;
    ULONG Flags;
    RTR_INFO_BLOCK_HEADER Header;
} IP_NAT_INTERFACE_INFO, *PIP_NAT_INTERFACE_INFO;

//
// Flags for IP_NAT_INTERFACE_INFO.Flags
//
// _BOUNDARY: set to mark interface as boundary-interface.
// _NAPT: set to enable address-sharing via port-translation.
//

#define IP_NAT_INTERFACE_FLAGS_BOUNDARY 0x00000001
#define IP_NAT_INTERFACE_FLAGS_NAPT     0x00000002
#define IP_NAT_INTERFACE_FLAGS_ALL      0x00000003

//
// Type-codes for the IP_NAT_INTERFACE_INFO.Header.TocEntry[] array.
//
// The structures which correspond to each info-type are given below.
//

#define IP_NAT_ADDRESS_RANGE_TYPE       IP_GENERAL_INFO_BASE + 2
#define IP_NAT_PORT_MAPPING_TYPE        IP_GENERAL_INFO_BASE + 3
#define IP_NAT_ADDRESS_MAPPING_TYPE     IP_GENERAL_INFO_BASE + 4

//
// Structure:   IP_NAT_ADDRESS_RANGE
//
// Holds a range of addresses which are part of the address-pool
// for a boundary interface.
//
// An address-pool consists of a list of these structures.
//
// N.B. Overlapping address-ranges are not supported;
//  discontiguous subnet masks are also unsupported.
//

typedef struct _IP_NAT_ADDRESS_RANGE {
    ULONG StartAddress;
    ULONG EndAddress;
    ULONG SubnetMask;
} IP_NAT_ADDRESS_RANGE, *PIP_NAT_ADDRESS_RANGE;

//
// Structure:   IP_NAT_PORT_MAPPING
//
// Holds a static mapping which ties a public-side port on this NAT interface
// to a particular private machine's address/port.
//
// In the case of an interface with a pool of addresses, 'PublicAddress'
// should specify which of those addresses this static-mapping applies to.
//

typedef struct _IP_NAT_PORT_MAPPING {
    UCHAR Protocol;
    USHORT PublicPort;
    ULONG PublicAddress;  // OPTIONAL - see IP_NAT_ADDRESS_UNSPECIFIED
    USHORT PrivatePort;
    ULONG PrivateAddress;
} IP_NAT_PORT_MAPPING, *PIP_NAT_PORT_MAPPING;

//
// Constant for 'PublicAddress' in IP_NAT_PORT_RANGE and IP_NAT_PORT_MAPPING;
// may be specified for boundary-interfaces which have no address-pool, in
// which case the range/mapping is for the boundary-interface's sole address.
//

#define IP_NAT_ADDRESS_UNSPECIFIED  ((ULONG)0)

//
// Structure:   IP_NAT_ADDRESS_MAPPING
//
// Holds a static mapping which ties an address from this NAT interface's
// address pool to a particular private-machine's address.
//
// Note that this address must fall within one of the ranges comprising
// the pool as specified by the IP_NAT_ADDRESS_RANGE structures.
//

typedef struct _IP_NAT_ADDRESS_MAPPING {
    ULONG PrivateAddress;
    ULONG PublicAddress;
    BOOLEAN AllowInboundSessions;
} IP_NAT_ADDRESS_MAPPING, *PIP_NAT_ADDRESS_MAPPING;

//
// Structure:   IP_NAT_INTERFACE_STATISTICS
//
// This structure holds statistics for an interface
//

typedef struct _IP_NAT_INTERFACE_STATISTICS {
    OUT ULONG TotalMappings;
    OUT ULONG InboundMappings;
    OUT ULONG64 BytesForward;
    OUT ULONG64 BytesReverse;
    OUT ULONG64 PacketsForward;
    OUT ULONG64 PacketsReverse;
    OUT ULONG64 RejectsForward;
    OUT ULONG64 RejectsReverse;
} IP_NAT_INTERFACE_STATISTICS, *PIP_NAT_INTERFACE_STATISTICS;

//
// Structure:   IP_NAT_SESSION_MAPPING
//
// This structure holds information for a single mapping
//

typedef struct _IP_NAT_SESSION_MAPPING {
    UCHAR Protocol;       // see NAT_PROTOCOL_* above
    ULONG PrivateAddress;
    USHORT PrivatePort;
    ULONG PublicAddress;
    USHORT PublicPort;
    ULONG RemoteAddress;
    USHORT RemotePort;
    IP_NAT_DIRECTION Direction;
    ULONG IdleTime;       // in seconds
} IP_NAT_SESSION_MAPPING, *PIP_NAT_SESSION_MAPPING;

//
// Structure:   IP_NAT_SESSION_MAPPING_STATISTICS
//
// Holds statistics for a single session-mapping.
//

typedef struct _IP_NAT_SESSION_MAPPING_STATISTICS {
    ULONG64 BytesForward;
    ULONG64 BytesReverse;
    ULONG64 PacketsForward;
    ULONG64 PacketsReverse;
    ULONG64 RejectsForward;
    ULONG64 RejectsReverse;
} IP_NAT_SESSION_MAPPING_STATISTICS, *PIP_NAT_SESSION_MAPPING_STATISTICS;

//
// Structure:   IP_NAT_ENUMERATE_SESSION_MAPPINGS
//
// Used for enumerate session mappings. 
// On the first call to this routine, 'EnumerateContext' should be zeroed out;
// it will be filled by the NAT with information to be passed back down
// as the enumeration continues. To indicate there are no items remaining,
// the NAT will set EnumerateContext[0] to 0.
//

typedef struct _IP_NAT_ENUMERATE_SESSION_MAPPINGS {
    IN ULONG Index;
    IN OUT ULONG EnumerateContext[4];
    OUT ULONG EnumerateCount;
    OUT ULONG EnumerateTotalHint;
    OUT IP_NAT_SESSION_MAPPING EnumerateTable[1];
} IP_NAT_ENUMERATE_SESSION_MAPPINGS, *PIP_NAT_ENUMERATE_SESSION_MAPPINGS;


//
// Editor function prototypes
//

//
// For synchronization reasons, 'CreateHandler' and 'DeleteHandler' 
// CANNOT invoke any helper functions other than 'QueryInfoSession'.
//

typedef NTSTATUS
(*PNAT_EDITOR_CREATE_HANDLER)(
    IN PVOID EditorContext,
    IN ULONG PrivateAddress,
    IN USHORT PrivatePort,
    IN ULONG PublicAddress,
    IN USHORT PublicPort,
    IN ULONG RemoteAddress,
    IN USHORT RemotePort,
    OUT PVOID* EditorSessionContextp OPTIONAL
    );

typedef NTSTATUS
(*PNAT_EDITOR_DELETE_HANDLER)(
    IN PVOID InterfaceHandle,
    IN PVOID SessionHandle,
    IN PVOID EditorContext,
    IN PVOID EditorSessionContext
    );

typedef NTSTATUS
(*PNAT_EDITOR_DATA_HANDLER)(
    IN PVOID InterfaceHandle,
    IN PVOID SessionHandle,
    IN PVOID DataHandle,
    IN PVOID EditorContext,
    IN PVOID EditorSessionContext,
    IN PVOID RecvBuffer,
    IN ULONG DataOffset
    );

//
// Helper function prototypes
//

typedef NTSTATUS
(*PNAT_EDITOR_CREATE_TICKET)(
    IN PVOID InterfaceHandle,
    IN UCHAR Protocol,
    IN ULONG PrivateAddress,
    IN USHORT PrivatePort,
    OUT PULONG PublicAddress,
    OUT PUSHORT PublicPort
    );

typedef NTSTATUS
(*PNAT_EDITOR_DELETE_TICKET)(
    IN PVOID InterfaceHandle,
    IN ULONG PublicAddress,
    IN UCHAR Protocol,
    IN USHORT PublicPort
    );

typedef NTSTATUS
(*PNAT_EDITOR_DEREGISTER)(
    IN PVOID EditorHandle
    );

typedef NTSTATUS
(*PNAT_EDITOR_DISSOCIATE_SESSION)(
    IN PVOID EditorHandle,
    IN PVOID SessionHandle
    );

typedef NTSTATUS
(*PNAT_EDITOR_EDIT_SESSION)(
    IN PVOID DataHandle,
    IN PVOID RecvBuffer,
    IN ULONG OldDataOffset,
    IN ULONG OldDataLength,
    IN PUCHAR NewData,
    IN ULONG NewDataLength
    );

typedef VOID
(*PNAT_EDITOR_QUERY_INFO_SESSION)(
    IN PVOID SessionHandle,
    OUT PULONG PrivateAddress OPTIONAL,
    OUT PUSHORT PrivatePort OPTIONAL,
    OUT PULONG RemoteAddress OPTIONAL,
    OUT PUSHORT RemotePort OPTIONAL,
    OUT PULONG PublicAddress OPTIONAL,
    OUT PUSHORT PublicPort OPTIONAL,
    OUT PIP_NAT_SESSION_MAPPING_STATISTICS Statistics OPTIONAL
    );

typedef VOID
(*PNAT_EDITOR_TIMEOUT_SESSION)(
    IN PVOID EditorHandle,
    IN PVOID SessionHandle
    );

//
// Structure:   IP_NAT_REGISTER_EDITOR
//
// The editor uses this structure to register itself with the NAT,
// and to obtain entrypoints of helper-functions provided by the NAT.
//
// On input, 'EditorContext' should contain a value which the NAT will
// pass to the editor's provided functions to serve as identification.
//
// On output, 'EditorHandle' contains the handle which the editor should
// pass to the NAT's helper functions to identify itself.
// 

typedef struct _IP_NAT_REGISTER_EDITOR {
    IN ULONG Version;
    IN ULONG Flags;
    IN UCHAR Protocol;
    IN USHORT Port;
    IN IP_NAT_DIRECTION Direction;
    IN PVOID EditorContext;
    IN PNAT_EDITOR_CREATE_HANDLER CreateHandler;            // OPTIONAL
    IN PNAT_EDITOR_DELETE_HANDLER DeleteHandler;            // OPTIONAL
    IN PNAT_EDITOR_DATA_HANDLER ForwardDataHandler;         // OPTIONAL
    IN PNAT_EDITOR_DATA_HANDLER ReverseDataHandler;         // OPTIONAL
    OUT PVOID EditorHandle;
    OUT PNAT_EDITOR_CREATE_TICKET CreateTicket;
    OUT PNAT_EDITOR_DELETE_TICKET DeleteTicket;
    OUT PNAT_EDITOR_DEREGISTER Deregister;
    OUT PNAT_EDITOR_DISSOCIATE_SESSION DissociateSession;
    OUT PNAT_EDITOR_EDIT_SESSION EditSession;
    OUT PNAT_EDITOR_QUERY_INFO_SESSION QueryInfoSession;
    OUT PNAT_EDITOR_TIMEOUT_SESSION TimeoutSession;
} IP_NAT_REGISTER_EDITOR, *PIP_NAT_REGISTER_EDITOR;

#define IP_NAT_EDITOR_FLAGS_RESIZE      0x00000001


//
// Director function prototypes
//

typedef struct _IP_NAT_DIRECTOR_QUERY {
    IN PVOID DirectorContext;
    IN ULONG ReceiveIndex;
    IN ULONG SendIndex;
    IN UCHAR Protocol;
    IN ULONG DestinationAddress;
    IN USHORT DestinationPort;
    IN ULONG SourceAddress;
    IN USHORT SourcePort;
    IN OUT ULONG Flags;
    OUT ULONG NewDestinationAddress;
    OUT USHORT NewDestinationPort;
    OUT ULONG NewSourceAddress OPTIONAL;
    OUT USHORT NewSourcePort OPTIONAL;
    OUT PVOID DirectorSessionContext;
} IP_NAT_DIRECTOR_QUERY, *PIP_NAT_DIRECTOR_QUERY;

#define IP_NAT_DIRECTOR_QUERY_FLAG_DROP             0x80000000
#define IP_NAT_DIRECTOR_QUERY_FLAG_STATISTICS       0x40000000
#define IP_NAT_DIRECTOR_QUERY_FLAG_NO_TIMEOUT       0x20000000
#define IP_NAT_DIRECTOR_QUERY_FLAG_UNIDIRECTIONAL   0x10000000

typedef NTSTATUS
(*PNAT_DIRECTOR_QUERY_SESSION)(
    PIP_NAT_DIRECTOR_QUERY DirectorQuery
    );

typedef VOID
(*PNAT_DIRECTOR_CREATE_SESSION)(
    IN PVOID SessionHandle,
    IN PVOID DirectorContext,
    IN PVOID DirectorSessionContext
    );

typedef VOID
(*PNAT_DIRECTOR_DELETE_SESSION)(
    IN PVOID SessionHandle,
    IN PVOID DirectorContext,
    IN PVOID DirectorSessionContext,
    IN IP_NAT_DELETE_REASON DeleteReason
    );

typedef VOID
(*PNAT_DIRECTOR_UNLOAD)(
    IN PVOID DirectorContext
    );

//
// Director-helper function prototypes
//

typedef NTSTATUS
(*PNAT_DIRECTOR_DEREGISTER)(
    IN PVOID DirectorHandle
    );

typedef NTSTATUS
(*PNAT_DIRECTOR_DISSOCIATE_SESSION)(
    IN PVOID DirectorHandle,
    IN PVOID SessionHandle
    );

typedef VOID
(*PNAT_DIRECTOR_QUERY_INFO_SESSION)(
    IN PVOID SessionHandle,
    OUT PIP_NAT_SESSION_MAPPING_STATISTICS Statistics OPTIONAL
    );

//
// Structure:   IP_NAT_REGISTER_DIRECTOR
//
// The director uses this structure to register itself with the NAT.
//

typedef struct _IP_NAT_REGISTER_DIRECTOR {
    IN ULONG Version;
    IN ULONG Flags;
    IN UCHAR Protocol;
    IN USHORT Port;
    IN PVOID DirectorContext;
    IN PNAT_DIRECTOR_QUERY_SESSION QueryHandler;
    IN PNAT_DIRECTOR_CREATE_SESSION CreateHandler;
    IN PNAT_DIRECTOR_DELETE_SESSION DeleteHandler;
    IN PNAT_DIRECTOR_UNLOAD UnloadHandler;
    OUT PVOID DirectorHandle;
    OUT PNAT_DIRECTOR_QUERY_INFO_SESSION QueryInfoSession;
    OUT PNAT_DIRECTOR_DEREGISTER Deregister;
    OUT PNAT_DIRECTOR_DISSOCIATE_SESSION DissociateSession;
} IP_NAT_REGISTER_DIRECTOR, *PIP_NAT_REGISTER_DIRECTOR;


//
// Structure:   IP_NAT_REDIRECT
//
// Describes the manner in which a specific session is to be modified.
//

typedef struct _IP_NAT_REDIRECT {
    UCHAR Protocol;
    ULONG SourceAddress;
    USHORT SourcePort;
    ULONG DestinationAddress;
    USHORT DestinationPort;
    ULONG NewSourceAddress;
    USHORT NewSourcePort;
    ULONG NewDestinationAddress;
    USHORT NewDestinationPort;
} IP_NAT_REDIRECT, *PIP_NAT_REDIRECT;

typedef struct IP_NAT_CREATE_REDIRECT {
    IN ULONG Flags;
    IN HANDLE NotifyEvent OPTIONAL;
    IN ULONG RestrictSourceAddress OPTIONAL;
#ifdef __cplusplus
    IN IP_NAT_REDIRECT Redirect;
#else
    IN IP_NAT_REDIRECT;
#endif
} IP_NAT_CREATE_REDIRECT, *PIP_NAT_CREATE_REDIRECT;

#define IP_NAT_REDIRECT_FLAG_ASYNCHRONOUS       0x00000001
#define IP_NAT_REDIRECT_FLAG_STATISTICS         0x00000002
#define IP_NAT_REDIRECT_FLAG_NO_TIMEOUT         0x00000004
#define IP_NAT_REDIRECT_FLAG_UNIDIRECTIONAL     0x00000008
#define IP_NAT_REDIRECT_FLAG_RESTRICT_SOURCE    0x00000010

typedef struct _IP_NAT_SESSION_MAPPING_STATISTICS
IP_NAT_REDIRECT_STATISTICS, *PIP_NAT_REDIRECT_STATISTICS;

typedef struct _IP_NAT_REDIRECT_SOURCE_MAPPING {
    ULONG SourceAddress;
    USHORT SourcePort;
    ULONG NewSourceAddress;
    USHORT NewSourcePort;
} IP_NAT_REDIRECT_SOURCE_MAPPING, *PIP_NAT_REDIRECT_SOURCE_MAPPING;


//
// Enumeration: IP_NAT_NOTIFICATION
//
// Lists the forms of notification supported by the NAT.
//

typedef enum {
    NatRoutingFailureNotification = 0,
    NatMaximumNotification
} IP_NAT_NOTIFICATION, *PIP_NAT_NOTIFICATION;

//
// Structure:   IP_NAT_REQUEST_NOTIFICATION
//
// Used to request notification from the NAT.
//

typedef struct _IP_NAT_REQUEST_NOTIFICATION {
    IP_NAT_NOTIFICATION Code;
} IP_NAT_REQUEST_NOTIFICATION, *PIP_NAT_REQUEST_NOTIFICATION;

//
// Structure:   IP_NAT_ROUTING_FAILURE_NOTIFICATION
//
// Supplies information on a packet which could not be routed.
//

typedef struct _IP_NAT_ROUTING_FAILURE_NOTIFICATION {
    ULONG DestinationAddress;
    ULONG SourceAddress;
} IP_NAT_ROUTING_FAILURE_NOTIFICATION, *PIP_NAT_ROUTING_FAILURE_NOTIFICATION;


//
// Structure:   IP_NAT_CREATE_DYNAMIC_TICKET
//
// Used to describe a dynamic ticket to be created.
//

#pragma warning(disable:4200) // 0-element array

typedef struct _IP_NAT_CREATE_DYNAMIC_TICKET {
    UCHAR Protocol;
    USHORT Port;
    ULONG ResponseCount;
    struct {
        UCHAR Protocol;
        USHORT StartPort;
        USHORT EndPort;
    } ResponseArray[0];
} IP_NAT_CREATE_DYNAMIC_TICKET, *PIP_NAT_CREATE_DYNAMIC_TICKET;

#pragma warning(default:4200)

//
// Structure:   IP_NAT_DELETE_DYNAMIC_TICKET
//
// Used to describe a dynamic ticket to be deleted.
//

typedef struct _IP_NAT_DELETE_DYNAMIC_TICKET {
    UCHAR Protocol;
    USHORT Port;
} IP_NAT_DELETE_DYNAMIC_TICKET, *PIP_NAT_DELETE_DYNAMIC_TICKET;

#ifdef __cplusplus
}
#endif

#endif // _ROUTING_IP_NAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\mailslotclientioctl.h ===
#ifndef __MAILSLOT_CLIENT_IOCTL_H
#define __MAILSLOT_CLIENT_IOCTL_H

#include "MailSlotIOCTL.h"

class CIoctlMailSlotClient : public CIoctlMailSlot
{
public:
    CIoctlMailSlotClient(CDevice *pDevice): CIoctlMailSlot(pDevice)
	{
		m_fUseOverlapped = false;
	}
    virtual ~CIoctlMailSlotClient()
	{
		;
	}

	virtual HANDLE CreateDevice(CDevice *pDevice);
/*
	//
	// override this method to do nothing, because a mailslot client cannot read
	//
	virtual BOOL DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		)
	{
		return TRUE;
	}
*/
	//
	// override this method to do nothing, because a mailslot server cannot write
	//
	virtual BOOL DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		)
	{
		//
		// i want to send smaller buffers once in a while, because the server
		// may not accept large buffers
		//
		return ::WriteFile(
			hFile,                    // handle to file to write to
			lpBuffer,                // pointer to data to write to file
			rand()%4 ? nNumberOfBytesToWrite : nNumberOfBytesToWrite%1000,     // number of bytes to write
			lpNumberOfBytesWritten,  // pointer to number of bytes written
			lpOverlapped        // pointer to structure for overlapped I/O
			);
	}
};


#endif //__MAILSLOT_CLIENT_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\mailslotclientioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

#include <windows.h>
*/


#include "MailSlotClientIOCTL.h"

static bool s_fVerbose = false;

HANDLE CIoctlMailSlotClient::CreateDevice(CDevice *pDevice)
{
	//
	// connect to an existing mailslot
	//

	HANDLE hMailSlot = INVALID_HANDLE_VALUE;
	for (DWORD dwTimesTried = 0; dwTimesTried < 100; dwTimesTried++)
	{
		if (m_pDevice->sm_fExitAllThreads || m_pDevice->m_fShutDown) goto out;

		hMailSlot = ::CreateFile(
		   pDevice->GetDeviceName(), //LPCTSTR lpszName,           // name of the pipe (or file)
		   GENERIC_READ | GENERIC_WRITE , //DWORD fdwAccess,            // read/write access (must match the pipe)
		   FILE_SHARE_READ | FILE_SHARE_WRITE, //DWORD fdwShareMode,         // usually 0 (no share) for pipes
		   NULL, // access privileges
		   OPEN_EXISTING, //DWORD fdwCreate,            // must be OPEN_EXISTING for pipes
		   FILE_ATTRIBUTE_NORMAL, //DWORD fdwAttrsAndFlags,     
		   NULL //HANDLE hTemplateFile        // ignored with OPEN_EXISTING
		   );
		if (INVALID_HANDLE_VALUE != hMailSlot)
		{
			DPF((TEXT("CIoctlMailSlotServer::CreateFile(%s) suceeded\n"), pDevice->GetDeviceName()));
			if (! ::SetMailslotInfo(
				hMailSlot,    // mailslot handle
				rand()%2 ? 0 : rand()%20000   // read time-out interval
				))
			{
				DPF((TEXT("CIoctlMailSlotClient::CreateDevice(%s): SetMailslotInfo() failed with %d\n"), pDevice->GetDeviceName(), ::GetLastError()));
			}
			return hMailSlot;
		}
		::Sleep(100);//let the mailslot server time to create
	}//for (DWORD dwTimesTried = 0; dwTimesTried < 100; dwTimesTried++)

	DPF((TEXT("CIoctlMailSlotServer::CreateFile(%s) FAILED with %d.\n"), pDevice->GetDeviceName(), GetLastError()));
out:
	return INVALID_HANDLE_VALUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\ipsectioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

#include <windows.h>
*/
#define _PNP_POWER_
#include "ntddip.h"
#include "icmpif.h"
#include "ipinfo.h"



#include <ipfltdrv.h>
#include "ipsec.h"

#include "IpSecIoctl.h"

static bool s_fVerbose = true;

static IPSEC_FILTER s_aIPSEC_FILTER[MAX_NUM_OF_REMEMBERED_ITEMS];

static void SetRandomGUID(CIoctlIpSec *pThis, GUID *pGUID);
static void SetRandom_IPSEC_FILTER(CIoctlIpSec *pThis, IPSEC_FILTER* pIPSEC_FILTER);
static IPAddr GetRandom_SrcAddr(CIoctlIpSec *pThis);
static IPAddr GetRandom_DestAddr(CIoctlIpSec *pThis);
static IPAddr GetRandom_TunnelAddr();
static IPMask GetRandom_SrcMask();
static IPMask GetRandom_DestMask();
static DWORD GetRandom_Protocol();
static WORD GetRandom_SrcPort();
static WORD GetRandom_DestPort();
static WORD GetRandom_Flags();
static void SetRandom_IPSEC_POLICY_INFO(CIoctlIpSec *pThis, IPSEC_POLICY_INFO* pIPSEC_POLICY_INFO, UINT indexHint);
static void Add_IPSEC_SA_INFO(CIoctlIpSec *pThis, IPSEC_SA_INFO* pIPSEC_SA_INFO);
static void Add_GUID(CIoctlIpSec *pThis, GUID *pGUID);
static void SetRandom_LIFETIME(LIFETIME* pLIFETIME);
static int GetRandom_OPERATION_E();
static int GetRandom_algoIdentifier();
static void Add_IPSEC_FILTER(CIoctlIpSec *pThis, IPSEC_FILTER* pIPSEC_FILTER);
static void Add_IPSEC_POLICY_INFO(CIoctlIpSec *pThis, IPSEC_POLICY_INFO* pIPSEC_POLICY_INFO);
static SA_FLAGS GetRandom_SA_FLAGS();
static SPI_TYPE GetRandom_SPI_TYPE(CIoctlIpSec *pThis);
static PVOID GetRandomContext(CIoctlIpSec *pThis);
static void SetRandom_ALGO_INFO(ALGO_INFO* pALGO_INFO);
static void Add_DestAddr(CIoctlIpSec *pThis, IPAddr DestAddr);
static void Add_SrcAddr(CIoctlIpSec *pThis, IPAddr SrcAddr);
static void Add_Context(CIoctlIpSec *pThis, PVOID Context);
static void Add_SPI(CIoctlIpSec *pThis, SPI_TYPE SPI);
static PVOID GetRandom_IdentityInfo(CIoctlIpSec *pThis);

void CIoctlIpSec::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    if (NULL != pOL)
    {
		//
		// wait, but do not block, because it may cause all threads to get stuch here
		// which is bad
		//
        DWORD dwBytesReturned;
		for (int i = 0; i < rand()%100; i++)
		{
			if (::GetOverlappedResult(GetDeviceHandle(), pOL, &dwBytesReturned, FALSE))
			{
				break;
			}
			else
			{
				::Sleep(10);
			}
		}
    }
	switch(dwIOCTL)
	{
	case IOCTL_IPSEC_ENUM_SAS:
		{
			for (UINT i = 0; i < ((IPSEC_ENUM_SAS*)abOutBuffer)->NumEntriesPresent; i++)
			{
				Add_IPSEC_SA_INFO(this, &(((IPSEC_ENUM_SAS*)abOutBuffer)->pInfo)[i]);
			}
		}
		break;

	case IOCTL_IPSEC_ENUM_POLICIES:
		{
			for (UINT i = 0; i < ((IPSEC_ENUM_POLICY*)abOutBuffer)->NumEntriesPresent; i++)
			{
				Add_IPSEC_POLICY_INFO(this, &(((IPSEC_ENUM_POLICY*)abOutBuffer)->pInfo)[i]);
			}
		}
		break;

	case IOCTL_IPSEC_GET_SPI:
	case IOCTL_IPSEC_SET_SPI:
		{
			Add_Context(this, ((IPSEC_GET_SPI*)abOutBuffer)->Context);
			Add_IPSEC_FILTER(this, &((IPSEC_GET_SPI*)abOutBuffer)->InstantiatedFilter);
			Add_SPI(this, ((IPSEC_GET_SPI*)abOutBuffer)->SPI);
		}
		break;
	}
}

void CIoctlIpSec::CallRandomWin32API(LPOVERLAPPED pOL)
{
	//_ASSERTE(FALSE);
    ;
}


//TODO: complete this method!
void CIoctlIpSec::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
	dwInBuff = rand();
	dwOutBuff = rand();

	switch(dwIOCTL)
	{
	case IOCTL_IPSEC_SET_POLICY          :
	case IOCTL_IPSEC_DELETE_POLICY          :
		{
			((IPSEC_SET_POLICY*)abInBuffer)->NumEntries = rand()%20;
			for (UINT i = 0; i < ((IPSEC_SET_POLICY*)abInBuffer)->NumEntries; i++)
			{
				SetRandom_IPSEC_POLICY_INFO(this, &((IPSEC_SET_POLICY*)abInBuffer)->pInfo[i], i);
/*
				SetRandomGUID(&((IPSEC_SET_POLICY*)abInBuffer)->pInfo[i].FilterId);
				SetRandomGUID(&((IPSEC_SET_POLICY*)abInBuffer)->pInfo[i].PolicyId);
				((IPSEC_SET_POLICY*)abInBuffer)->pInfo[i].Index = rand()%100 ? i+1 : rand() %2 ? rand() : DWORD_RAND;
				SetRandom_IPSEC_FILTER(&((IPSEC_SET_POLICY*)abInBuffer)->pInfo[i].AssociatedFilter);
*/
			}

			//
			// once in a while, lets break the NumEntries
			//
			if (0 == rand()%50) ((IPSEC_SET_POLICY*)abInBuffer)->NumEntries = rand()%2 ? rand() : DWORD_RAND;

			SetInParam(dwInBuff, sizeof(IPSEC_SET_POLICY)+(sizeof(IPSEC_POLICY_INFO) * ((IPSEC_SET_POLICY*)abInBuffer)->NumEntries));

			SetOutParam(abOutBuffer, dwOutBuff, 0);
		}

        break;

	case IOCTL_IPSEC_UPDATE_POLICY          :
		SetRandom_IPSEC_POLICY_INFO(this, &((IPSEC_UPDATE_POLICY*)abInBuffer)->DeleteInfo, rand());
		SetRandom_IPSEC_POLICY_INFO(this, &((IPSEC_UPDATE_POLICY*)abInBuffer)->AddInfo, rand());

		SetInParam(dwInBuff, sizeof(IPSEC_UPDATE_POLICY));

		SetOutParam(abOutBuffer, dwOutBuff, 0);

        break;

	case IOCTL_IPSEC_ENUM_SAS          :
		//SetRandom_IPSEC_POLICY_INFO(&((IPSEC_ENUM_SAS*)abInBuffer)->DeleteInfo, rand());

		SetInParam(dwInBuff, 0/*sizeof(IPSEC_ENUM_SAS)*/);

		SetOutParam(abOutBuffer, dwOutBuff, rand());

        break;

	case IOCTL_IPSEC_ENUM_POLICIES          :
		SetInParam(dwInBuff, 0/*sizeof(IPSEC_ENUM_POLICY)*/);

		SetOutParam(abOutBuffer, dwOutBuff, rand());

        break;
	
	case IOCTL_IPSEC_QUERY_STATS          :
		SetInParam(dwInBuff, 0/*sizeof(IPSEC_ENUM_POLICY)*/);

		SetOutParam(abOutBuffer, dwOutBuff, sizeof(IPSEC_QUERY_STATS));

        break;

	case IOCTL_IPSEC_ADD_SA          :
	case IOCTL_IPSEC_UPDATE_SA          :
		{
			((IPSEC_ADD_UPDATE_SA*)abInBuffer)->SAInfo.Context = GetRandomContext(this);
			((IPSEC_ADD_UPDATE_SA*)abInBuffer)->SAInfo.NumSAs = rand()%10;
			((IPSEC_ADD_UPDATE_SA*)abInBuffer)->SAInfo.Flags = GetRandom_SA_FLAGS();

			((IPSEC_ADD_UPDATE_SA*)abInBuffer)->SAInfo.TunnelAddr = GetRandom_TunnelAddr();
			SetRandom_LIFETIME(&((IPSEC_ADD_UPDATE_SA*)abInBuffer)->SAInfo.Lifetime );
			SetRandom_IPSEC_FILTER(this, &((IPSEC_ADD_UPDATE_SA*)abInBuffer)->SAInfo.InstantiatedFilter);
			for (UINT i = 0; i < MAX_SAS; i++)
			{
				((IPSEC_ADD_UPDATE_SA*)abInBuffer)->SAInfo.SecAssoc[i].Operation = (OPERATION_E)GetRandom_OPERATION_E();
				((IPSEC_ADD_UPDATE_SA*)abInBuffer)->SAInfo.SecAssoc[i].SPI = GetRandom_SPI_TYPE(this);
				SetRandom_ALGO_INFO(&((IPSEC_ADD_UPDATE_SA*)abInBuffer)->SAInfo.SecAssoc[i].IntegrityAlgo);
				SetRandom_ALGO_INFO(&((IPSEC_ADD_UPDATE_SA*)abInBuffer)->SAInfo.SecAssoc[i].ConfAlgo);
				((IPSEC_ADD_UPDATE_SA*)abInBuffer)->SAInfo.SecAssoc[i].CompAlgo = CIoctl::GetRandomIllegalPointer();
			}

			((IPSEC_ADD_UPDATE_SA*)abInBuffer)->SAInfo.KeyLen = rand()%100;
			//((IPSEC_ADD_UPDATE_SA*)abInBuffer)->SAInfo.KeyMat = xxx;

			SetInParam(dwInBuff, (rand()%3+1)*sizeof(IPSEC_ADD_UPDATE_SA));

			SetOutParam(abOutBuffer, dwOutBuff, 0);
		}

        break;
	
	case IOCTL_IPSEC_DELETE_SA          :
		{
			((IPSEC_DELETE_SA*)abInBuffer)->DelInfo.DestAddr = GetRandom_DestAddr(this);
			((IPSEC_DELETE_SA*)abInBuffer)->DelInfo.SrcAddr = GetRandom_SrcAddr(this);
			((IPSEC_DELETE_SA*)abInBuffer)->DelInfo.SPI = GetRandom_SPI_TYPE(this);

			SetInParam(dwInBuff, sizeof(IPSEC_DELETE_SA));

			SetOutParam(abOutBuffer, dwOutBuff, 0);
		}

        break;
	
	case IOCTL_IPSEC_EXPIRE_SA          :
		{
			((IPSEC_EXPIRE_SA*)abInBuffer)->DelInfo.DestAddr = GetRandom_DestAddr(this);
			((IPSEC_EXPIRE_SA*)abInBuffer)->DelInfo.SrcAddr = GetRandom_SrcAddr(this);
			((IPSEC_EXPIRE_SA*)abInBuffer)->DelInfo.SPI = GetRandom_SPI_TYPE(this);

			SetInParam(dwInBuff, 0);

			SetOutParam(abOutBuffer, dwOutBuff, sizeof(IPSEC_GET_SPI));
		}

        break;
		
	case IOCTL_IPSEC_GET_SPI          :
	case IOCTL_IPSEC_SET_SPI          :
		{
			((IPSEC_GET_SPI*)abInBuffer)->Context = GetRandomContext(this);
			SetRandom_IPSEC_FILTER(this, &((IPSEC_GET_SPI*)abInBuffer)->InstantiatedFilter);
			((IPSEC_GET_SPI*)abInBuffer)->SPI = GetRandom_SPI_TYPE(this);

			SetInParam(dwInBuff, sizeof(IPSEC_GET_SPI));

			SetOutParam(abOutBuffer, dwOutBuff, sizeof(IPSEC_GET_SPI));
		}

        break;
		
	case IOCTL_IPSEC_POST_FOR_ACQUIRE_SA          :
		{
			((IPSEC_POST_FOR_ACQUIRE_SA*)abInBuffer)->IdentityInfo = GetRandom_IdentityInfo(this);
			((IPSEC_POST_FOR_ACQUIRE_SA*)abInBuffer)->Context = GetRandomContext(this);
			SetRandomGUID(this, &((IPSEC_POST_FOR_ACQUIRE_SA*)abInBuffer)->PolicyId);
			((IPSEC_POST_FOR_ACQUIRE_SA*)abInBuffer)->SrcAddr = GetRandom_SrcAddr(this);
			((IPSEC_POST_FOR_ACQUIRE_SA*)abInBuffer)->SrcMask = GetRandom_SrcMask();
			((IPSEC_POST_FOR_ACQUIRE_SA*)abInBuffer)->DestAddr = GetRandom_DestAddr(this);
			((IPSEC_POST_FOR_ACQUIRE_SA*)abInBuffer)->DestMask = GetRandom_DestMask();
			((IPSEC_POST_FOR_ACQUIRE_SA*)abInBuffer)->TunnelAddr = GetRandom_TunnelAddr();
			((IPSEC_POST_FOR_ACQUIRE_SA*)abInBuffer)->InboundTunnelAddr = GetRandom_TunnelAddr();
			((IPSEC_POST_FOR_ACQUIRE_SA*)abInBuffer)->Protocol = GetRandom_Protocol();
			((IPSEC_POST_FOR_ACQUIRE_SA*)abInBuffer)->SrcPort = GetRandom_SrcPort();
			((IPSEC_POST_FOR_ACQUIRE_SA*)abInBuffer)->DestPort = GetRandom_DestPort();
			((IPSEC_POST_FOR_ACQUIRE_SA*)abInBuffer)->TunnelFilter = rand()%3;
			//((IPSEC_POST_FOR_ACQUIRE_SA*)abInBuffer)->Pad = xxx();

			SetInParam(dwInBuff, sizeof(IPSEC_POST_FOR_ACQUIRE_SA));

			SetOutParam(abOutBuffer, dwOutBuff, sizeof(IPSEC_POST_FOR_ACQUIRE_SA));
		}

        break;
		
	case IOCTL_IPSEC_QUERY_EXPORT          :
		{
			((IPSEC_QUERY_EXPORT*)abInBuffer)->Export = rand()%3;

			SetInParam(dwInBuff, sizeof(IPSEC_QUERY_EXPORT));

			SetOutParam(abOutBuffer, dwOutBuff, sizeof(IPSEC_QUERY_EXPORT));
		}

        break;
		
	case IOCTL_IPSEC_REGISTER_CLEAR_SNIFFER          :
	case IOCTL_IPSEC_DEREGISTER_CLEAR_SNIFFER          :
		//not user-mode accessible
        break;
		
	//case IOCTL_IPSEC_REGISTER_TEST_MUNGER          :
	case IOCTL_IPSEC_QUERY_SPI          :
        SetRandom_IPSEC_FILTER(this, &((IPSEC_QUERY_SPI*)abInBuffer)->Filter);
        ((IPSEC_QUERY_SPI*)abInBuffer)->Spi = GetRandom_SPI_TYPE(this);
        ((IPSEC_QUERY_SPI*)abInBuffer)->OtherSpi = GetRandom_SPI_TYPE(this);
        ((IPSEC_QUERY_SPI*)abInBuffer)->Operation = (OPERATION_E)GetRandom_OPERATION_E();

        SetInParam(dwInBuff, sizeof(IPSEC_QUERY_SPI));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(IPSEC_QUERY_SPI));

		break;

	default:
		_tprintf(TEXT("CIoctlIpSec::PrepareIOCTLParams() 0x%08X is an unexpected IOCTL\n"), dwIOCTL);
		_ASSERTE(FALSE);
		CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
	}
}


BOOL CIoctlIpSec::FindValidIOCTLs(CDevice *pDevice)
{
	AddIOCTL(pDevice, IOCTL_IPSEC_SET_POLICY          );
	AddIOCTL(pDevice, IOCTL_IPSEC_DELETE_POLICY          );
	AddIOCTL(pDevice, IOCTL_IPSEC_QUERY_STATS          );
	AddIOCTL(pDevice, IOCTL_IPSEC_UPDATE_SA          );
	AddIOCTL(pDevice, IOCTL_IPSEC_DELETE_SA          );
	AddIOCTL(pDevice, IOCTL_IPSEC_UPDATE_POLICY          );
	AddIOCTL(pDevice, IOCTL_IPSEC_GET_SPI          );
	AddIOCTL(pDevice, IOCTL_IPSEC_ENUM_SAS          );
	AddIOCTL(pDevice, IOCTL_IPSEC_POST_FOR_ACQUIRE_SA          );
	AddIOCTL(pDevice, IOCTL_IPSEC_ADD_SA          );
	AddIOCTL(pDevice, IOCTL_IPSEC_EXPIRE_SA          );
	AddIOCTL(pDevice, IOCTL_IPSEC_ENUM_POLICIES          );
	AddIOCTL(pDevice, IOCTL_IPSEC_SET_SPI          );
	AddIOCTL(pDevice, IOCTL_IPSEC_QUERY_EXPORT          );
	AddIOCTL(pDevice, IOCTL_IPSEC_REGISTER_CLEAR_SNIFFER          );
	AddIOCTL(pDevice, IOCTL_IPSEC_DEREGISTER_CLEAR_SNIFFER          );
	//AddIOCTL(pDevice, IOCTL_IPSEC_REGISTER_TEST_MUNGER          );
	AddIOCTL(pDevice, IOCTL_IPSEC_QUERY_SPI          );

    return TRUE;
}

UINT CIoctlIpSec::GetRandomInterfaceIndex()
{
	return (rand()%100);
}

UINT CIoctlIpSec::GetRandomGroup()
{
	if (0 == rand()%10) return (rand()%100);
	if (0 == rand()%9) return (rand());
	if (0 == rand()%8) return (0);
	if (0 == rand()%7) return (0xffff);
	if (0 == rand()%6) return (-1);
	return DWORD_RAND;
}

UINT CIoctlIpSec::GetRandomSource()
{
	if (0 == rand()%10) return (rand()%100);
	if (0 == rand()%9) return (rand());
	if (0 == rand()%8) return (0);
	if (0 == rand()%7) return (0xffff);
	if (0 == rand()%6) return (-1);
	return DWORD_RAND;
}

UINT CIoctlIpSec::GetRandomSrcMask()
{
	if (0 == rand()%10) return (rand()%100);
	if (0 == rand()%9) return (rand());
	if (0 == rand()%8) return (0);
	if (0 == rand()%7) return (0xffff);
	if (0 == rand()%6) return (-1);
	return DWORD_RAND;
}

void SetRandomGUID(CIoctlIpSec *pThis, GUID *pGUID)
{
	if (0 == rand()%2)
	{
		*pGUID = pThis->m_aGuids[rand()%MAX_NUM_OF_REMEMBERED_ITEMS];
		return;
	}
	if (0 == rand()%2) 
	{
		ZeroMemory(pGUID, sizeof(*pGUID));
		return;
	}
	
	::UuidCreate(pGUID);
}


void SetRandom_IPSEC_FILTER(CIoctlIpSec *pThis, IPSEC_FILTER* pIPSEC_FILTER)
{
	if (0 == rand()%2) 
	{
		*pIPSEC_FILTER = s_aIPSEC_FILTER[rand()%MAX_NUM_OF_REMEMBERED_ITEMS];
		if (rand()%10) return;
		//
		// once in a while, change the contents of the returned remembered value
		//
		if (0 == rand()%10) pIPSEC_FILTER->SrcAddr = GetRandom_SrcAddr(pThis);
		if (0 == rand()%10) pIPSEC_FILTER->SrcMask = GetRandom_SrcMask();
		if (0 == rand()%10) pIPSEC_FILTER->DestAddr = GetRandom_DestAddr(pThis);
		if (0 == rand()%10) pIPSEC_FILTER->DestMask = GetRandom_DestMask();
		if (0 == rand()%10) pIPSEC_FILTER->TunnelAddr = GetRandom_TunnelAddr();
		if (0 == rand()%10) pIPSEC_FILTER->Protocol = GetRandom_Protocol();
		if (0 == rand()%10) pIPSEC_FILTER->SrcPort = GetRandom_SrcPort();
		if (0 == rand()%10) pIPSEC_FILTER->DestPort = GetRandom_DestPort();
		if (0 == rand()%10) pIPSEC_FILTER->TunnelFilter = rand()%3;
		if (0 == rand()%10) pIPSEC_FILTER->Flags = GetRandom_Flags();

		return;
	}

	pIPSEC_FILTER->SrcAddr = GetRandom_SrcAddr(pThis);
	pIPSEC_FILTER->SrcMask = GetRandom_SrcMask();
	pIPSEC_FILTER->DestAddr = GetRandom_DestAddr(pThis);
	pIPSEC_FILTER->DestMask = GetRandom_DestMask();
	pIPSEC_FILTER->TunnelAddr = GetRandom_TunnelAddr();
	pIPSEC_FILTER->Protocol = GetRandom_Protocol();
	pIPSEC_FILTER->SrcPort = GetRandom_SrcPort();
	pIPSEC_FILTER->DestPort = GetRandom_DestPort();
	pIPSEC_FILTER->TunnelFilter = rand()%3;
	pIPSEC_FILTER->Flags = GetRandom_Flags();
}

void Add_IPSEC_FILTER(CIoctlIpSec *pThis, IPSEC_FILTER* pIPSEC_FILTER)
{
	s_aIPSEC_FILTER[rand()%MAX_NUM_OF_REMEMBERED_ITEMS] = *pIPSEC_FILTER;
}

IPAddr GetRandom_SrcAddr(CIoctlIpSec *pThis)
{
	if (rand()%4) return (pThis->m_aDestSrcAddr[rand()%MAX_NUM_OF_REMEMBERED_ITEMS]);
	if (0 == rand()%3) return 0;
	if (0 == rand()%2) return 0xffffffff;
	return DWORD_RAND;
}

void Add_SrcAddr(CIoctlIpSec *pThis, IPAddr SrcAddr)
{
	pThis->m_aDestSrcAddr[rand()%MAX_NUM_OF_REMEMBERED_ITEMS] = SrcAddr;
}

IPAddr GetRandom_DestAddr(CIoctlIpSec *pThis)
{
	if (rand()%4) return (pThis->m_aDestSrcAddr[rand()%MAX_NUM_OF_REMEMBERED_ITEMS]);
	if (0 == rand()%3) return 0;
	if (0 == rand()%2) return 0xffffffff;
	return DWORD_RAND;
}

void Add_DestAddr(CIoctlIpSec *pThis, IPAddr DestAddr)
{
	pThis->m_aDestSrcAddr[rand()%MAX_NUM_OF_REMEMBERED_ITEMS] = DestAddr;
}

IPAddr GetRandom_TunnelAddr()
{
	if (0 == rand()%3) return 0;
	if (0 == rand()%2) return 0xffffffff;
	return DWORD_RAND;
}

IPMask GetRandom_SrcMask()
{
	if (0 == rand()%3) return 0;
	if (0 == rand()%2) return 0xffffffff;
	return DWORD_RAND;
}

IPMask GetRandom_DestMask()
{
	if (0 == rand()%3) return 0;
	if (0 == rand()%2) return 0xffffffff;
	return DWORD_RAND;
}

DWORD GetRandom_Protocol()
{
	switch(rand()%5)
	{
	case 0: return FILTER_PROTO_ANY;
	case 1: return FILTER_PROTO_ICMP;
	case 2: return FILTER_PROTO_TCP;
	//case 3: return FILTER_PROTO_TCP_ESTAB;
	case 4: return FILTER_PROTO_UDP;
	default: return FILTER_PROTO(rand());
	}
}

WORD GetRandom_SrcPort()
{
	if (0 == rand()%3) return 0;
	if (0 == rand()%2) return 0xffff;
	return ((rand()%2 ? (0x8000) : 0) | rand());
}

WORD GetRandom_DestPort()
{
	if (0 == rand()%3) return 0;
	if (0 == rand()%2) return 0xffff;
	return ((rand()%2 ? (0x8000) : 0) | rand());
}

WORD GetRandom_Flags()
{
	switch(rand()%6)
	{
	case 0: return FILTER_FLAGS_PASS_THRU;
	case 1: return FILTER_FLAGS_DROP;
	case 2: return FILTER_FLAGS_INBOUND;
	case 3: return FILTER_FLAGS_OUTBOUND;
	case 4: return 0;
	case 5: return 0xffff;
	default: return (rand());
	}
}


void SetRandom_IPSEC_POLICY_INFO(CIoctlIpSec *pThis, IPSEC_POLICY_INFO* pIPSEC_POLICY_INFO, UINT indexHint)
{
	SetRandomGUID(pThis, &pIPSEC_POLICY_INFO->FilterId);
	SetRandomGUID(pThis, &pIPSEC_POLICY_INFO->PolicyId);
	pIPSEC_POLICY_INFO->Index = rand()%100 ? indexHint+1 : rand() %2 ? rand() : DWORD_RAND;
	SetRandom_IPSEC_FILTER(pThis, &pIPSEC_POLICY_INFO->AssociatedFilter);
}


void Add_IPSEC_POLICY_INFO(CIoctlIpSec *pThis, IPSEC_POLICY_INFO* pIPSEC_POLICY_INFO)
{
	Add_GUID(pThis, &pIPSEC_POLICY_INFO->PolicyId);
	Add_GUID(pThis, &pIPSEC_POLICY_INFO->FilterId);
	//ignore the index hint: pIPSEC_POLICY_INFO->Index
	Add_IPSEC_FILTER(pThis, &pIPSEC_POLICY_INFO->AssociatedFilter);
}

void Add_IPSEC_SA_INFO(CIoctlIpSec *pThis, IPSEC_SA_INFO* pIPSEC_SA_INFO)
{
	Add_GUID(pThis, &pIPSEC_SA_INFO->PolicyId);
	Add_GUID(pThis, &pIPSEC_SA_INFO->FilterId);
	/*
	i was confused, and instead of remembering the returned values, i put random values inside...
	SetRandom_LIFETIME(&pIPSEC_SA_INFO->Lifetime);
	pIPSEC_SA_INFO->NumOps = rand()%2 ? rand()%(MAX_OPS+1) : rand()%(2*MAX_OPS);
	for (UINT i = 0; i < MAX_OPS; i++)
	{
		pIPSEC_SA_INFO->Operation[i] = GetRandom_OPERATION_E();
		SetRandom_ALGO_INFO(&pIPSEC_SA_INFO->AlgoInfo[i].IntegrityAlgo);
		SetRandom_ALGO_INFO(&pIPSEC_SA_INFO->AlgoInfo[i].ConfAlgo);
		SetRandom_ALGO_INFO(&pIPSEC_SA_INFO->AlgoInfo[i].CompAlgo);
	}

	SetRandom_IPSEC_FILTER(&pIPSEC_SA_INFO->AssociatedFilter);
	*/
	Add_IPSEC_FILTER(pThis, &pIPSEC_SA_INFO->AssociatedFilter);
}

void Add_GUID(CIoctlIpSec *pThis, GUID *pGUID)
{
	pThis->m_aGuids[rand()%MAX_NUM_OF_REMEMBERED_ITEMS] = *pGUID;
}

void SetRandom_LIFETIME(LIFETIME* pLIFETIME)
{
	pLIFETIME->KeyExpirationTime = rand()%2 ? rand() : rand()%2 ? DWORD_RAND : rand()%2 ? 0xffffffff : 0;
	pLIFETIME->KeyExpirationBytes = rand()%2 ? rand() : rand()%2 ? DWORD_RAND : rand()%2 ? 0xffffffff : 0;
}

int GetRandom_OPERATION_E()
{
	/*
typedef enum    _Operation {
    None = 0,
    Auth,                       // AH
    Encrypt,                    // ESP
    Compress
} OPERATION_E;
*/
	return (rand()%7);
}

void SetRandom_ALGO_INFO(ALGO_INFO* pALGO_INFO)
{
	pALGO_INFO->algoIdentifier = GetRandom_algoIdentifier();
	pALGO_INFO->algoKeylen = rand()%2 ? 64 : rand()%2 ? 40 : rand();
	pALGO_INFO->algoRounds = rand()%2 ? 8 : rand()%2 ? 1 : rand()%2 ? 0 : rand();

}

int GetRandom_algoIdentifier()
{
	/*
//
// IPSEC DOI ESP algorithms
//
typedef enum _ESP_ALGO {
    IPSEC_ESP_NONE=0,
    IPSEC_ESP_DES,
    IPSEC_ESP_DES_40,
    IPSEC_ESP_3_DES,
    IPSEC_ESP_MAX
} ESP_ALGO;

//
// IPSEC DOI AH algorithms
//
typedef enum _AH_ALGO {
    IPSEC_AH_NONE=0,
    IPSEC_AH_MD5,
    IPSEC_AH_SHA,
    IPSEC_AH_MAX
} AH_ALGO;
*/
	return rand()%10;
}


SA_FLAGS GetRandom_SA_FLAGS()
{
	switch(rand()%5)
	{
	case 0: return SA_FLAGS_TUNNEL;
	case 1: return SA_FLAGS_REPLAY;
	case 2: return SA_FLAGS_DELETE;
	case 3: return 0;
	case 4: return SA_FLAGS_TUNNEL | SA_FLAGS_REPLAY | SA_FLAGS_DELETE;
	default: return rand();
	}
}


SPI_TYPE GetRandom_SPI_TYPE(CIoctlIpSec *pThis)
{
	if (rand()%4) return (pThis->m_aSPI[rand()%MAX_NUM_OF_REMEMBERED_ITEMS]);
	if (rand()%4) return (DWORD_RAND);
	if (rand()%2) return (0);
	return (0xffffffff);
}

void Add_SPI(CIoctlIpSec *pThis, SPI_TYPE SPI)
{
	pThis->m_aSPI[rand()%MAX_NUM_OF_REMEMBERED_ITEMS] = SPI;
}

PVOID GetRandomContext(CIoctlIpSec *pThis)
{
	if (rand()%5) return (pThis->m_aContext[rand()%MAX_NUM_OF_REMEMBERED_ITEMS]);
	if (rand()%2) return ((PVOID)DWORD_RAND);
	if (rand()%2) return ((PVOID)0);
	return ((PVOID)0xffffffff);
}

void Add_Context(CIoctlIpSec *pThis, PVOID Context)
{
	pThis->m_aContext[rand()%MAX_NUM_OF_REMEMBERED_ITEMS] = Context;
}

PVOID GetRandom_IdentityInfo(CIoctlIpSec *pThis)
{
	return GetRandomContext(pThis);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\ipmcastioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

#include <windows.h>
*/
#define _PNP_POWER_
#include "ntddip.h"
#include "icmpif.h"
#include "ipinfo.h"



#include "ddipmcst.h"

#include "IpMcastIoctl.h"

static bool s_fVerbose = true;

BOOL CIoctlIpMcast::CloseDevice(CDevice *pDevice)
{
	::InterlockedExchange(&m_fDriverStarted, FALSE);

	NTSTATUS status = NtClose(pDevice->m_hDevice);
	if (!NT_SUCCESS(status))
	{
		::SetLastError(RtlNtStatusToDosError(status));
	}
	else
	{
		_ASSERTE(STATUS_SUCCESS == status);
	}
	return (STATUS_SUCCESS == status);
}


void CIoctlIpMcast::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
	switch(dwIOCTL)
	{
	case IOCTL_IPMCAST_GET_MFE:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);

		{
			AddInterfaceIndex(((IPMCAST_MFE_STATS*)abOutBuffer)->dwInIfIndex);
			for (UINT i = 0; i < ((IPMCAST_MFE_STATS*)abOutBuffer)->ulNumOutIf; i++)
			{
				AddInterfaceIndex((((IPMCAST_MFE_STATS*)abOutBuffer)->rgiosOutStats)[i].dwOutIfIndex);
			}
		}
		break;
	}
		
}

void CIoctlIpMcast::CallRandomWin32API(LPOVERLAPPED pOL)
{
	//_ASSERTE(FALSE);
    ;
}


//TODO: complete this method!
void CIoctlIpMcast::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
	dwInBuff = rand();
	dwOutBuff = rand();

	switch(dwIOCTL)
	{
	case IOCTL_IPMCAST_SET_MFE          :
        ((IPMCAST_MFE*)abInBuffer)->dwGroup = GetRandomGroup();
        ((IPMCAST_MFE*)abInBuffer)->dwSource = GetRandomSource();
        ((IPMCAST_MFE*)abInBuffer)->dwSrcMask = GetRandomSrcMask();
        ((IPMCAST_MFE*)abInBuffer)->dwInIfIndex = GetRandomInterfaceIndex();

		//
		// lets try to cause overflow in the input-buffer verification logic
		//
        ((IPMCAST_MFE*)abInBuffer)->ulNumOutIf = rand()%2 ? (0xFFFFFFFF/sizeof(IPMCAST_OIF)) +rand()%1000 : rand()%100;
        ((IPMCAST_MFE*)abInBuffer)->ulTimeOut = rand()%2 ? rand() : DWORD_RAND;
        ((IPMCAST_MFE*)abInBuffer)->fFlags = rand()%100;
        ((IPMCAST_MFE*)abInBuffer)->dwReserved = rand()%10 ? 0 : rand();

        SetInParam(dwInBuff, (((IPMCAST_MFE*)abInBuffer)->ulNumOutIf)*sizeof(IPMCAST_MFE));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(IPMCAST_MFE));

		break;

	case IOCTL_IPMCAST_GET_MFE          :
		//TODO: use the output buffer results!
        ((IPMCAST_MFE_STATS*)abInBuffer)->dwGroup = GetRandomGroup();
        ((IPMCAST_MFE_STATS*)abInBuffer)->dwSource = GetRandomSource();
        ((IPMCAST_MFE_STATS*)abInBuffer)->dwSrcMask = GetRandomSrcMask();

        SetInParam(dwInBuff, sizeof(IPMCAST_MFE_STATS));

        SetOutParam(abOutBuffer, dwOutBuff, (rand()%100)*sizeof(IPMCAST_MFE_STATS));

		break;

	case IOCTL_IPMCAST_DELETE_MFE          :
		/*
        ((xxx*)abInBuffer)->xxx = xxx;

        SetInParam(dwInBuff, sizeof(xxx));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(xxx));
*/

		break;

	case IOCTL_IPMCAST_SET_TTL          :
		/*
        ((xxx*)abInBuffer)->xxx = xxx;

        SetInParam(dwInBuff, sizeof(xxx));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(xxx));
*/
		break;

	case IOCTL_IPMCAST_GET_TTL          :
		/*
        ((xxx*)abInBuffer)->xxx = xxx;

        SetInParam(dwInBuff, sizeof(xxx));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(xxx));
*/

		break;

	case IOCTL_IPMCAST_POST_NOTIFICATION          :
		/*
        ((xxx*)abInBuffer)->xxx = xxx;

        SetInParam(dwInBuff, sizeof(xxx));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(xxx));
*/

		break;

	case IOCTL_IPMCAST_START_STOP          :
		if(!::InterlockedExchange(&m_fDriverStarted, TRUE))
		{
			*((DWORD*)abInBuffer) = TRUE;//TODO:rand()%100;

			//TODO:SetInParam(dwInBuff, sizeof(DWORD));
			dwInBuff = sizeof(DWORD);

			SetOutParam(abOutBuffer, dwOutBuff, 0);

			break;
		}
		else
		{
			//
			// fall through, in order to avoid the bug in IpMcast
			//
			dwIOCTL = IOCTL_IPMCAST_SET_IF_STATE;
		}

	case IOCTL_IPMCAST_SET_IF_STATE          :
		/*
        ((xxx*)abInBuffer)->xxx = xxx;

        SetInParam(dwInBuff, sizeof(xxx));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(xxx));
*/

		break;

	default:
		_tprintf(TEXT("CIoctlIpMcast::PrepareIOCTLParams() 0x%08X is an unexpected IOCTL\n"), dwIOCTL);
		_ASSERTE(FALSE);
		CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
	}
}


BOOL CIoctlIpMcast::FindValidIOCTLs(CDevice *pDevice)
{
	AddIOCTL(pDevice, IOCTL_IPMCAST_SET_MFE          );
	AddIOCTL(pDevice, IOCTL_IPMCAST_GET_MFE          );
	AddIOCTL(pDevice, IOCTL_IPMCAST_DELETE_MFE          );
	AddIOCTL(pDevice, IOCTL_IPMCAST_SET_TTL          );
	AddIOCTL(pDevice, IOCTL_IPMCAST_GET_TTL          );
	AddIOCTL(pDevice, IOCTL_IPMCAST_POST_NOTIFICATION          );
	AddIOCTL(pDevice, IOCTL_IPMCAST_START_STOP          );
	AddIOCTL(pDevice, IOCTL_IPMCAST_SET_IF_STATE          );

    return TRUE;
}

UINT CIoctlIpMcast::GetRandomInterfaceIndex()
{
	if (0 == rand()%10) return rand()%100;
	return m_aulInterfaceIndex[rand()%MAX_NUM_OF_REMEMBERED_INTERFACES];
}

void CIoctlIpMcast::AddInterfaceIndex(UINT index)
{
	m_aulInterfaceIndex[rand()%MAX_NUM_OF_REMEMBERED_INTERFACES] = index;
}

UINT CIoctlIpMcast::GetRandomGroup()
{
	if (0 == rand()%10) return (rand()%100);
	if (0 == rand()%9) return (rand());
	if (0 == rand()%8) return (0);
	if (0 == rand()%7) return (0xffff);
	if (0 == rand()%6) return (-1);
	return DWORD_RAND;
}

UINT CIoctlIpMcast::GetRandomSource()
{
	if (0 == rand()%10) return (rand()%100);
	if (0 == rand()%9) return (rand());
	if (0 == rand()%8) return (0);
	if (0 == rand()%7) return (0xffff);
	if (0 == rand()%6) return (-1);
	return DWORD_RAND;
}

UINT CIoctlIpMcast::GetRandomSrcMask()
{
	if (0 == rand()%10) return (rand()%100);
	if (0 == rand()%9) return (rand());
	if (0 == rand()%8) return (0);
	if (0 == rand()%7) return (0xffff);
	if (0 == rand()%6) return (-1);
	return DWORD_RAND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\mailslotserverioctl.h ===
#ifndef __MAILSLOT_SERVER_IOCTL_H
#define __MAILSLOT_SERVER_IOCTL_H

#include "MailSlotIOCTL.h"

class CIoctlMailSlotServer : public CIoctlMailSlot
{
public:
    CIoctlMailSlotServer(CDevice *pDevice): CIoctlMailSlot(pDevice)
	{
		;
	}
    virtual ~CIoctlMailSlotServer()
	{
		;
	}

	virtual HANDLE CreateDevice(CDevice *pDevice);
/*
	//
	// override this method to do nothing, because a mailslot server cannot write
	//
	virtual BOOL DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		)
	{
		return TRUE;
	}
*/
	virtual BOOL DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		);
};


#endif //__MAILSLOT_SERVER_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\mailslotioctl.h ===
#ifndef __MAILSLOT_IOCTL_H
#define __MAILSLOT_IOCTL_H

//#include "IOCTL.h"

#define __EVENT_ARRAY_SIZE 10

void Mark2();

class CIoctlMailSlot : public CIoctl
{
public:
    CIoctlMailSlot(CDevice *pDevice);
    virtual ~CIoctlMailSlot()
	{
		;
	}

	virtual HANDLE CreateDevice(CDevice *pDevice) = 0;

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

	//
	// override this method if your device does not use ::WriteFile() for writing
	//
	virtual BOOL DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		)
	{
		return ::WriteFile(
			hFile,                    // handle to file to write to
			lpBuffer,                // pointer to data to write to file
			nNumberOfBytesToWrite,     // number of bytes to write
			lpNumberOfBytesWritten,  // pointer to number of bytes written
			lpOverlapped        // pointer to structure for overlapped I/O
			);
	}

	//
	// override this method if your device does not use ::ReadFile() for writing
	//
	virtual BOOL DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		)
	{
		return ::ReadFile(
			hFile,                // handle of file to read
			lpBuffer,             // pointer to buffer that receives data
			nNumberOfBytesToRead,  // number of bytes to read
			lpNumberOfBytesRead, // pointer to number of bytes read
			lpOverlapped    // pointer to structure for data
			);
	}

	virtual BOOL DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		)
	{
		return ::DeviceIoControl(
			hDevice,              // handle to a device, file, or directory 
			dwIoControlCode,       // control code of operation to perform
			lpInBuffer,           // pointer to buffer to supply input data
			nInBufferSize,         // size, in bytes, of input buffer
			lpOutBuffer,          // pointer to buffer to receive output data
			nOutBufferSize,        // size, in bytes, of output buffer
			lpBytesReturned,     // pointer to variable to receive byte count
			lpOverlapped    // pointer to structure for asynchronous operation
			);
	}

	//
	// IRP_MJ_QUERY_VOLUME_INFORMATION
	// NtQueryVolumeInformationFile()
	//
	virtual BOOL DeviceQueryVolumeInformationFile(
		IN HANDLE FileHandle,
		OVERLAPPED *pOverlapped,//OUT PIO_STATUS_BLOCK IoStatusBlock,
		OUT PVOID FsInformation,
		IN ULONG Length,
		IN FS_INFORMATION_CLASS FsInformationClass
		);

	//
	// IRP_MJ_QUERY_INFORMATION
	// NtQueryInformationFile()
	//
	virtual BOOL DeviceQueryInformationFile(
		IN HANDLE FileHandle,
		OVERLAPPED *pOverlapped,//OUT PIO_STATUS_BLOCK IoStatusBlock,
		OUT PVOID FileInformation,
		IN ULONG Length,
		IN FILE_INFORMATION_CLASS FileInformationClass
		);
	//
	// IRP_MJ_SET_INFORMATION
	// NtSetInformationFile()
	//
	virtual BOOL DeviceSetInformationFile(
		IN HANDLE FileHandle,
		OVERLAPPED *pOverlapped,//OUT PIO_STATUS_BLOCK IoStatusBlock,
		OUT PVOID FileInformation,
		IN ULONG Length,
		IN FILE_INFORMATION_CLASS FileInformationClass
		);

	//
	// IRP_MJ_DIRECTORY_CONTROL
	// NtQueryInformationFile()
	//
	virtual BOOL DeviceQueryDirectoryFile(
		IN HANDLE FileHandle,
		IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
		IN PVOID ApcContext OPTIONAL,
		OVERLAPPED *pOverlapped,//OUT PIO_STATUS_BLOCK IoStatusBlock,IN HANDLE Event OPTIONAL
		OUT PVOID FileInformation,
		IN ULONG Length,
		IN FILE_INFORMATION_CLASS FileInformationClass,
		IN BOOLEAN ReturnSingleEntry,
		IN PUNICODE_STRING FileName OPTIONAL,
		IN BOOLEAN RestartScan
		);

	virtual BOOL DeviceQueryFullAttributesFile(
		IN WCHAR * wszName,
		OUT PFILE_NETWORK_OPEN_INFORMATION FileInformation
		);

	void GetRandom_FsInformationClassAndLength(
		FS_INFORMATION_CLASS *FsInformationClass, 
		ULONG *Length
		);

protected:
	HANDLE m_ahVolume;
	HANDLE m_ahRootDir;
};


#endif //__MAILSLOT_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\mailslotioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

#include <windows.h>
#include "NtNativeIOCTL.h"
*/

void Mark2(){return;}

#include "MailSlotIOCTL.h"

static bool s_fVerbose = false;

enum {
	PLACE_HOLDER_SetMailslotInfo = 0,
	PLACE_HOLDER_GetMailslotInfo,
	PLACE_HOLDER_LAST
};

CIoctlMailSlot::CIoctlMailSlot(CDevice *pDevice): CIoctl(pDevice)
{
	m_ahVolume = CIoctlNtNative::StaticCreateDevice(L"\\Device\\Mailslot");
	_ASSERT(INVALID_HANDLE_VALUE != m_ahVolume);
	m_ahRootDir = CIoctlNtNative::StaticCreateDevice(L"\\Device\\Mailslot\\");
	_ASSERT(INVALID_HANDLE_VALUE != m_ahRootDir);
}

/*
HANDLE CIoctlMailSlot::CreateDevice(CDevice *pDevice)
{
	//
	// 1st try to connect to an existing mailslot, and if fail, try to create a server.
	// this way, i can create of client-server mailslots
	//

	HANDLE hMailSlot = INVALID_HANDLE_VALUE;
	//for (DWORD dwTimesTried = 0; dwTimesTried < 100; dwTimesTried++)
	{
		if (m_pDevice->sm_fExitAllThreads || m_pDevice->m_fShutDown) goto out;

		hMailSlot = ::CreateFile(
		   pDevice->GetDeviceName(), //LPCTSTR lpszName,           // name of the pipe (or file)
		   GENERIC_READ | GENERIC_WRITE , //DWORD fdwAccess,            // read/write access (must match the pipe)
		   FILE_SHARE_READ | FILE_SHARE_WRITE, //DWORD fdwShareMode,         // usually 0 (no share) for pipes
		   NULL, // access privileges
		   OPEN_EXISTING, //DWORD fdwCreate,            // must be OPEN_EXISTING for pipes
		   FILE_ATTRIBUTE_NORMAL, //DWORD fdwAttrsAndFlags,     
		   NULL //HANDLE hTemplateFile        // ignored with OPEN_EXISTING
		   );
		if (INVALID_HANDLE_VALUE != hMailSlot)
		{
			DPF((TEXT("CIoctlMailSlotServer::CreateFile(%s) suceeded\n"), pDevice->GetDeviceName()));
			return hMailSlot;
		}
		//else continue trying
		::Sleep(100);//let other threads breath some air
	}//for (DWORD dwTimesTried = 0; dwTimesTried < 100; dwTimesTried++)

	DPF((TEXT("CIoctlMailSlotServer::CreateFile(%s) FAILED with %d, so try to create a MailSlot server instead\n"), pDevice->GetDeviceName(), GetLastError()));
	//for (dwTimesTried = 0; dwTimesTried < 100; dwTimesTried++)
	{
		if (m_pDevice->sm_fExitAllThreads || m_pDevice->m_fShutDown) goto out;

		hMailSlot = CreateMailslot(
			pDevice->GetDeviceName(), //LPCTSTR lpName,         // mailslot name
			SIZEOF_INOUTBUFF, //DWORD nMaxMessageSize,  // maximum message size
			100,     // time until read time-out
			NULL//LPSECURITY_ATTRIBUTES lpSecurityAttributes 
			);
		if (INVALID_HANDLE_VALUE == hMailSlot)
		{
			//
			// no need to print each failure, only if all tries fail
			//
			//DPF((TEXT("CIoctlMailSlotServer::CreateMailslot(%s) FAILED with %d\n"), pDevice->GetDeviceName(), GetLastError()));
			::Sleep(100);//let other threads breath some air
		}
		else
		{
			DPF((TEXT("CIoctlMailSlotServer::CreateMailslot(%s) suceeded\n"), pDevice->GetDeviceName()));
			return hMailSlot;
		}
	}

	DPF((TEXT("CIoctlMailSlotServer::CreateMailslot(%s) FAILED with %d\n"), pDevice->GetDeviceName(), GetLastError()));

	_ASSERTE(INVALID_HANDLE_VALUE == hMailSlot);
out:
	return INVALID_HANDLE_VALUE;
}
*/
void CIoctlMailSlot::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    ;
}

void CIoctlMailSlot::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
    switch(dwIOCTL)
    {
    case FSCTL_MAILSLOT_PEEK:
/*
OUT
typedef struct _FILE_MAILSLOT_PEEK_BUFFER {
    ULONG ReadDataAvailable;
    ULONG NumberOfMessages;
    ULONG MessageLength;
} FILE_MAILSLOT_PEEK_BUFFER, *PFILE_MAILSLOT_PEEK_BUFFER;
+ buffer
*/
		DPF((TEXT("CIoctlMailSlotServer::PrepareIOCTLParams(FSCTL_MAILSLOT_PEEK)\n")));
		DPFLUSH();
		//
		// this is weird, but the input buffer is actually just an output buffer
		// of type FILE_MAILSLOT_PEEK_BUFFER
		//
        SetInParam(dwInBuff, sizeof(FILE_MAILSLOT_PEEK_BUFFER));
        SetOutParam(abOutBuffer, dwOutBuff, rand());
        break;

    default:
		_ASSERTE(FALSE);
        SetInParam(dwInBuff, rand());
        SetOutParam(abOutBuffer, dwOutBuff, rand());
    }
}


BOOL CIoctlMailSlot::FindValidIOCTLs(CDevice *pDevice)
{
    //return CIoctl::FindValidIOCTLs(pDevice);

    AddIOCTL(pDevice, FSCTL_MAILSLOT_PEEK);

	return TRUE;
}

/*
BOOL CIoctlMailSlot::DeviceInputOutputControl(
	HANDLE hDevice,              // handle to a device, file, or directory 
	DWORD dwIoControlCode,       // control code of operation to perform
	LPVOID lpInBuffer,           // pointer to buffer to supply input data
	DWORD nInBufferSize,         // size, in bytes, of input buffer
	LPVOID lpOutBuffer,          // pointer to buffer to receive output data
	DWORD nOutBufferSize,        // size, in bytes, of output buffer
	LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
	LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
	)
{

	DWORD Status;
    IO_STATUS_BLOCK Iosb;
::Mark2();
	DWORD dwStackPointerBefore = 1;
	DWORD dwStackPointerAfter = 2;
	DWORD dwBasePointerBefore = 3;
	DWORD dwBasePointerAfter = 4;
	DWORD dwFS_0_Previous = 5;
	DWORD dwFS_0_Current = 5;
	__asm
	{
		push eax
		mov eax,fs:[0]
		mov dwFS_0_Previous,eax
		pop eax
	}
	//_tprintf(TEXT("dwFS_0_Previous=0x%08X\n"),dwFS_0_Previous);
	__asm
	{
		mov dwStackPointerBefore,esp
		mov dwBasePointerBefore,ebp
	}
	
	_tprintf(
		TEXT("dwStackPointerBefore=0x%08X, dwBasePointerBefore=0x%08X\n"),
		dwStackPointerBefore,
		dwBasePointerBefore
		);
		
	__asm
	{
		//int 3
	}
	//__try{
    Status = NtDeviceIoControlFile(
                hDevice,
                NULL,
                NULL,             // APC routine
                NULL,             // APC Context
                &Iosb,
                dwIoControlCode,  // IoControlCode
                lpInBuffer,       // Buffer for data to the FS
                nInBufferSize,
                lpOutBuffer,      // OutputBuffer for data from the FS
                nOutBufferSize    // OutputBuffer Length
                );
	//}__except(1){_ASSERTE(FALSE);}
	_tprintf(
		TEXT("Status=0x%08X, Iosb.Status=0x%08X\n"),
		Status,
		Iosb.Status
		);
	__asm
	{
		//int 3
	}
	__asm
	{
		mov dwStackPointerAfter,esp
		mov dwBasePointerAfter,ebp
	}
	
	_tprintf(
		TEXT("dwStackPointerAfter=0x%08X, dwBasePointerAfter=0x%08X\n"),
		dwStackPointerAfter,
		dwBasePointerAfter
		);
		
	_ASSERTE(dwStackPointerBefore == dwStackPointerAfter);
	_ASSERTE(dwBasePointerBefore == dwBasePointerAfter);
//::Mark2();
    if ( Status == STATUS_PENDING) 
	{
        // Operation must complete before return & Iosb destroyed
        Status = NtWaitForSingleObject( hDevice, FALSE, NULL );
        if ( NT_SUCCESS(Status)) 
		{
            Status = Iosb.Status;
        }
    }

    if ( NT_SUCCESS(Status) ) 
	{
        *lpBytesReturned = (DWORD)Iosb.Information;
        return TRUE;
    }
    else 
	{
        // handle warning value STATUS_BUFFER_OVERFLOW somewhat correctly
        if ( !NT_ERROR(Status) ) 
		{
            *lpBytesReturned = (DWORD)Iosb.Information;
        }
        ::SetLastError(Status);
        return FALSE;
    }


	return ::DeviceIoControl(
		hDevice,              // handle to a device, file, or directory 
		dwIoControlCode,       // control code of operation to perform
		lpInBuffer,           // pointer to buffer to supply input data
		nInBufferSize,         // size, in bytes, of input buffer
		lpOutBuffer,          // pointer to buffer to receive output data
		nOutBufferSize,        // size, in bytes, of output buffer
		lpBytesReturned,     // pointer to variable to receive byte count
		lpOverlapped    // pointer to structure for asynchronous operation
		);
}

BOOL CIoctlMailSlot::DeviceReadFile(
	HANDLE hFile,                // handle of file to read
	LPVOID lpBuffer,             // pointer to buffer that receives data
	DWORD nNumberOfBytesToRead,  // number of bytes to read
	LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
	LPOVERLAPPED lpOverlapped    // pointer to structure for data
	)
{
	__asm
	{
		//int 3
	}
	BOOL fRes = ::ReadFile(
		hFile,                // handle of file to read
		lpBuffer,             // pointer to buffer that receives data
		nNumberOfBytesToRead,  // number of bytes to read
		lpNumberOfBytesRead, // pointer to number of bytes read
		lpOverlapped    // pointer to structure for data
		);
	_tprintf(TEXT("ReadFile() returned %d\n"), fRes);
	//_tprintf(TEXT("ReadFile() returned %d with %d\n"),fRes,::GetLastError());
	//fflush(stdout);
	__asm
	{
		//int 3
	}
	return fRes;
}
*/

void CIoctlMailSlot::CallRandomWin32API(LPOVERLAPPED pOL)
{
	DWORD dwSwitch;
	if	(-1 != m_pDevice->m_dwOnlyThisIndexIOCTL) 
	{ 
		dwSwitch = m_pDevice->m_dwOnlyThisIndexIOCTL;
	}
	else
	{
		dwSwitch = rand()%PLACE_HOLDER_LAST;
	}

	switch(dwSwitch)
	{
	case PLACE_HOLDER_SetMailslotInfo:
		if (! ::SetMailslotInfo(
				rand()%20 ? m_pDevice->m_hDevice : rand()%2 ? m_ahVolume : m_ahRootDir,    // mailslot handle
				rand()%2 ? 0 : rand()%20000   // read time-out interval
				))
		{
			DPF((TEXT("CIoctlMailSlot::CallRandomWin32API(): SetMailslotInfo() failed with %d\n"), ::GetLastError()));
		}
		break;

	case PLACE_HOLDER_GetMailslotInfo:
		{
			IO_STATUS_BLOCK ioStatusBlock;
			FILE_MAILSLOT_QUERY_INFORMATION mailslotInfo;
			if (!CIoctlNtNative::StaticNtQueryInformationFile(
				rand()%20 ? m_pDevice->m_hDevice : rand()%2 ? m_ahVolume : m_ahRootDir,
				&ioStatusBlock,
				rand()%2 ? &mailslotInfo : (FILE_MAILSLOT_QUERY_INFORMATION*)CIoctl::GetRandomIllegalPointer(),
				sizeof( mailslotInfo ),
				FileMailslotQueryInformation 
				))
			{
				DPF((TEXT("CIoctlMailSlot::CallRandomWin32API(): StaticNtQueryInformationFile() failed with %d\n"), ::GetLastError()));
			}
			/*
			DWORD dwXXX;
			if (! ::GetMailslotInfo(
					m_pDevice->m_hDevice,          // mailslot handle
					rand()%10 ? &dwXXX : (DWORD*)CIoctl::GetRandomIllegalPointer(),  // maximum message size
					rand()%10 ? &dwXXX : (DWORD*)CIoctl::GetRandomIllegalPointer(),        // size of next message
					rand()%10 ? &dwXXX : (DWORD*)CIoctl::GetRandomIllegalPointer(),    // number of messages
					rand()%10 ? &dwXXX : (DWORD*)CIoctl::GetRandomIllegalPointer()      // read time-out interval
					))
			{
				DPF((TEXT("CIoctlMailSlot::CallRandomWin32API(): GetMailslotInfo() failed with %d\n"), ::GetLastError()));
			}
			*/
		}
		break;

	}
	return;
}

void CIoctlMailSlot::GetRandom_FsInformationClassAndLength(
	FS_INFORMATION_CLASS *FsInformationClass, 
	ULONG *Length
	)
{
	//
	// the illegal FsInformationClass case
	//
	if (0 == rand()%100)
	{
		*FsInformationClass = FileFsMaximumInformation;
		*Length = rand();

		return;
	}

	switch(rand()%5)
	{
	case 0:
		*FsInformationClass = FileFsAttributeInformation;
		//
		// buffer should hold FILE_FS_ATTRIBUTE_INFORMATION + FileSystemName
		//
		*Length = rand()%sizeof(FILE_FS_ATTRIBUTE_INFORMATION) + rand()%100;
		//
		// special case, made to break this line by causing an underflow:
		// Length -= FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName[0] );
		//
		if (0 != rand()%20)
		{
			*Length = rand()%FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName[0] );
		}
		break;

	case 1:
		*FsInformationClass = FileFsVolumeInformation;
		*Length = rand();
		break;

	case 2:
		*FsInformationClass = FileFsSizeInformation;
		*Length = rand();
		break;

	case 3:
		*FsInformationClass = FileFsFullSizeInformation;
		*Length = rand();
		break;

	case 4:
		*FsInformationClass = FileFsDeviceInformation;
		*Length = rand();
		break;

	default:
		_ASSERTE(FALSE);
	}
}

BOOL CIoctlMailSlot::DeviceQueryVolumeInformationFile(
	IN HANDLE FileHandle,
	OVERLAPPED *pOverlapped,//OUT PIO_STATUS_BLOCK IoStatusBlock,
	OUT PVOID FsInformation,
	IN ULONG Length,
	IN FS_INFORMATION_CLASS FsInformationClass
	)
{
	GetRandom_FsInformationClassAndLength(&FsInformationClass, &Length);
	return CIoctlNtNative::StaticQueryVolumeInformationFile(
		rand()%20 ? m_ahVolume : rand()%2 ? FileHandle : m_ahRootDir,
		GetRandomIllegalIoStatusBlock(pOverlapped),
		FsInformation,
		Length,
		FsInformationClass
		);
}

BOOL CIoctlMailSlot::DeviceQueryInformationFile(
	IN HANDLE FileHandle,
	OVERLAPPED *pOverlapped,//OUT PIO_STATUS_BLOCK IoStatusBlock,
	OUT PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass
	)
{
	return CIoctlNtNative::StaticNtQueryInformationFile(
		rand()%20 ? FileHandle : rand()%2 ? m_ahVolume : m_ahRootDir,
		GetRandomIllegalIoStatusBlock(pOverlapped),
		FileInformation,
		Length,
		FileInformationClass
		);
}
BOOL CIoctlMailSlot::DeviceSetInformationFile(
	IN HANDLE FileHandle,
	OVERLAPPED *pOverlapped,//OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass
	)
{
	return CIoctlNtNative::StaticNtSetInformationFile(
		rand()%20 ? FileHandle : rand()%2 ? m_ahVolume : m_ahRootDir,
		GetRandomIllegalIoStatusBlock(pOverlapped),
		FileInformation,
		Length,
		FileInformationClass
		);
}

BOOL CIoctlMailSlot::DeviceQueryDirectoryFile(
	IN HANDLE FileHandle,
	IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	OVERLAPPED *pOverlapped,//OUT PIO_STATUS_BLOCK IoStatusBlock,IN HANDLE Event OPTIONAL
	OUT PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass,
	IN BOOLEAN ReturnSingleEntry,
	IN PUNICODE_STRING FileName OPTIONAL,
	IN BOOLEAN RestartScan
	)
{
	return CIoctlNtNative::StaticNtQueryDirectoryFile(
		rand()%20 ? m_ahRootDir : rand()%2 ? m_ahVolume : FileHandle,
		rand()%10 ? pOverlapped->hEvent : rand()%2 ? NULL : (HANDLE)(0x80000000 & DWORD_RAND),//Event,
		ApcRoutine,
		ApcContext,
		GetRandomIllegalIoStatusBlock(pOverlapped),
		FileInformation,
		Length,
		FileInformationClass,
		ReturnSingleEntry,
		FileName,
		RestartScan
		);
}


BOOL CIoctlMailSlot::DeviceQueryFullAttributesFile(
	IN WCHAR * wszName,
	OUT PFILE_NETWORK_OPEN_INFORMATION FileInformation
	)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;
    //FILE_NETWORK_OPEN_INFORMATION NetworkInfo;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
	WCHAR wszNameToUse[1024];
	static WCHAR *wszNames[] = 
	{
		L"\\\\.\\mailslot",
		L"\\\\.\\mailslot\\",
		L"\\\\.\\mailslot\\\\",
	};

	//
	// make a random name
	//
	if (0 == rand()%10)
	{
		wcscpy(wszNameToUse, wszNames[rand()%(sizeof(wszNames)/sizeof(*wszNames))]);
	}
	else
	{
		wcscpy(wszNameToUse, wszName);
	} 

	//RtlInitUnicodeString(&FileName, wszNameToUse);

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            wszNameToUse,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

	DPF((TEXT("FileName.Buffer=%s\n"), FileName.Buffer));

	if (rand()%2)
	{
		//
		// corrupt the string
		//
		FileName.Buffer[rand()%wcslen(FileName.Buffer)] = rand();

	}
	else
	{
		//
		// make the string not NULL terminated
		//
		if (rand()%10) FileName.Buffer[wcslen(FileName.Buffer)] = rand()+1;
		else FileName.Buffer[wcslen(FileName.Buffer)] = L'\\';
	}
	InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    Status = NtQueryFullAttributesFile( &Obja, FileInformation );
    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
    if ( NT_SUCCESS(Status) ) 
	{
        return TRUE;
    }
    else 
	{
		::SetLastError(RtlNtStatusToDosError(Status));
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\manyfilesioctl.h ===
#ifndef __MANY_FILES_IOCTL_H
#define __MANY_FILES_IOCTL_H

#include "container.h"
#include "FileIOCTL.h"


class CIoctlManyFiles : public CIoctlFile
{
public:
    CIoctlManyFiles(CDevice *pDevice);

    virtual ~CIoctlManyFiles();


    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

	virtual HANDLE CreateDevice(CDevice *pDevice);

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

	virtual BOOL DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		)
	{
		return ::WriteFile(
			GetRandomFileHandle(hFile),                    // handle to file to write to
			lpBuffer,                // pointer to data to write to file
			nNumberOfBytesToWrite,     // number of bytes to write
			lpNumberOfBytesWritten,  // pointer to number of bytes written
			lpOverlapped        // pointer to structure for overlapped I/O
			);
	}

	virtual BOOL DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		)
	{
		return ::ReadFile(
			GetRandomFileHandle(hFile),                // handle of file to read
			lpBuffer,             // pointer to buffer that receives data
			nNumberOfBytesToRead,  // number of bytes to read
			lpNumberOfBytesRead, // pointer to number of bytes read
			lpOverlapped    // pointer to structure for data
			);
	}

	virtual BOOL DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		)
	{
		return ::DeviceIoControl(
			GetRandomFileHandle(hDevice),              // handle to a device, file, or directory 
			dwIoControlCode,       // control code of operation to perform
			lpInBuffer,           // pointer to buffer to supply input data
			nInBufferSize,         // size, in bytes, of input buffer
			lpOutBuffer,          // pointer to buffer to receive output data
			nOutBufferSize,        // size, in bytes, of output buffer
			lpBytesReturned,     // pointer to variable to receive byte count
			lpOverlapped    // pointer to structure for asynchronous operation
			);
	}

protected:
	HANDLE GetRandomFileHandle(HANDLE hFile);
};




#endif //__MANY_FILES_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\memoryioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*



#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
*/
#include "MemoryIOCTL.h"




void CIoctlMemory::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    ;
}

void CIoctlMemory::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
	_ASSERTE(FALSE);
    CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
}


BOOL CIoctlMemory::FindValidIOCTLs(CDevice *pDevice)
{
	_ASSERTE(FALSE);
    //return CIoctl::FindValidIOCTLs(pDevice);
	return TRUE;
}


HANDLE CIoctlMemory::CreateDevice(CDevice *pDevice)
{
	_ASSERTE(FALSE);
	//
	// the file's name is the 'memory' name, meaning the key value in the INI file
	//
	for (int i=0; i < 1000; i++)
	{
		if (m_pFileIoctl = new CIoctlFile(pDevice))
		{
			break;
		}
	}
	if (NULL == m_pFileIoctl)
	{
		return INVALID_HANDLE_VALUE;
	}

	//
	// there's no real handle here
    return NULL;
}

BOOL CIoctlMemory::CloseDevice(CDevice *pDevice)
{
	_ASSERTE(FALSE);
    delete m_pFileIoctl;
	m_pFileIoctl = NULL;

	return TRUE;
}

BOOL CIoctlMemory::DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		)
{
	_ASSERTE(FALSE);
	UNREFERENCED_PARAMETER(lpOverlapped);

	return TRUE;
}

BOOL CIoctlMemory::DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		)
{
	_ASSERTE(FALSE);
	UNREFERENCED_PARAMETER(lpOverlapped);
	return TRUE;
}

void CIoctlMemory::CallRandomWin32API(LPOVERLAPPED pOL)
{
	_ASSERTE(FALSE);
    ;
}

BOOL CIoctlMemory::DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		)
{
	_ASSERTE(FALSE);
	switch(dwIoControlCode)
	{
	case 0:
		_ASSERTE(FALSE);
		break;

	case 1:
		_ASSERTE(FALSE);
		break;

	case 2:
		_ASSERTE(FALSE);
		break;

	case 3:
		_ASSERTE(FALSE);
		break;

	case 4:
		_ASSERTE(FALSE);
		break;

	default:
		_ASSERTE(FALSE);
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\mailslotserverioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

#include <windows.h>

#include "NtNativeIOCTL.h"
*/
#include "MailSlotServerIOCTL.h"

static bool s_fVerbose = false;

HANDLE CIoctlMailSlotServer::CreateDevice(CDevice *pDevice)
{
	//
	// create a new mailslot
	//

	HANDLE hMailSlot = INVALID_HANDLE_VALUE;
	//for (dwTimesTried = 0; dwTimesTried < 100; dwTimesTried++)
	{
		//if (m_pDevice->sm_fExitAllThreads || m_pDevice->m_fShutDown) goto out;

		hMailSlot = ::CreateMailslot(
			pDevice->GetDeviceName(), //LPCTSTR lpName,         // mailslot name
			rand()%4 ? 0 : rand()%4 ? rand() : rand()%4 ? rand()%3000 : DWORD_RAND, //DWORD nMaxMessageSize,  // maximum message size
			rand()%4 ? rand() : rand()%4 ? MAILSLOT_WAIT_FOREVER : 0,     // time until read time-out
			NULL//LPSECURITY_ATTRIBUTES lpSecurityAttributes 
			);
		if (INVALID_HANDLE_VALUE == hMailSlot)
		{
			DPF((TEXT("CIoctlMailSlotServer::CreateFile(%s) FAILED with %d.\n"), pDevice->GetDeviceName(), GetLastError()));
			return INVALID_HANDLE_VALUE;
		}
		else
		{
			DPF((TEXT("CIoctlMailSlotServer::CreateMailslot(%s) suceeded\n"), pDevice->GetDeviceName()));
			if (! ::SetMailslotInfo(
				hMailSlot,    // mailslot handle
				rand()%2 ? 0 : rand()%20000   // read time-out interval
				))
			{
				DPF((TEXT("CIoctlMailSlotServer::CreateDevice(%s): SetMailslotInfo() failed with %d\n"), pDevice->GetDeviceName(), ::GetLastError()));
			}
			return hMailSlot;
		}
	}
	_ASSERTE(FALSE);
//out:
	return INVALID_HANDLE_VALUE;
}

BOOL CIoctlMailSlotServer::DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		)
{
	/*
	return CIoctlNtNative::StaticDeviceInputOutputControl(
		rand()%2 ? hDevice : m_ahDeviceMsFsHandle,              // handle to a device, file, or directory 
		dwIoControlCode,       // control code of operation to perform
		lpInBuffer,           // pointer to buffer to supply input data
		nInBufferSize,         // size, in bytes, of input buffer
		lpOutBuffer,          // pointer to buffer to receive output data
		nOutBufferSize,        // size, in bytes, of output buffer
		lpBytesReturned,     // pointer to variable to receive byte count
		lpOverlapped    // pointer to structure for asynchronous operation
		);
		*/
	IO_STATUS_BLOCK iosb;
	if (lpOverlapped) lpOverlapped->Internal = (DWORD)STATUS_PENDING;
	NTSTATUS status = NtFsControlFile (
	//NTSTATUS status = NtDeviceIoControlFile (
		hDevice, //rand()%2 ? hDevice : m_ahDeviceMsFsHandle, 
		lpOverlapped ? lpOverlapped->hEvent : NULL, 
		NULL, 
		NULL,
		lpOverlapped ? (PIO_STATUS_BLOCK)&lpOverlapped->Internal : &iosb,
		dwIoControlCode,
		lpInBuffer,
		nInBufferSize,
		lpOutBuffer,
		nOutBufferSize
		);
	if (!NT_SUCCESS(status))
	{
		::SetLastError(RtlNtStatusToDosError(status));
	}
	if (STATUS_PENDING == status)
	{
		//
		// cannot get this for a synchronous call
		//
		_ASSERTE(lpOverlapped);
		::SetLastError(ERROR_IO_PENDING);
	}
	//DPF((TEXT("CIoctlNtNative::DeviceInputOutputControl() NtDeviceIoControlFile() returned 0x%08X=%d\n"), status, ::GetLastError()));

	return (STATUS_SUCCESS == status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\main.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*


#include <windows.h>
#include <stdio.h>
#include <crtdbg.h>
#include <tchar.h>
#include <time.h>

#include "device.h"
*/

static bool s_fVerbose = true;

//
// INI file sections and keys
//
#define DEVICE_SECTION TEXT("Devices")

#define PARAMETERS_SECTION TEXT("Parameters")

#define NUM_OF_CONCURRENT_DEVICES_KEY TEXT("ConcurrentDevices")
#define TIME_TO_RUN_EACH_DEVICE_KEY TEXT("TimeToRunEachDevice")
#define RUN_SEQUENTIALLY_KEY TEXT("RunSequentially")
#define TERMINATE_AFTER_X_SECONDS_KEY TEXT("TerminateAfterXSeconds")
#define MINIMUM_SECS_SLEEP_BEFORE_CLOSE_KEY TEXT("MinimumSecsSleepBeforeClose")
#define MAXIMUM_SECS_SLEEP_BEFORE_CLOSE_KEY TEXT("MaximumSecsSleepBeforeClose")
#define WRITE_FILE_PROBABILITY_KEY TEXT("WriteFileProbability")
#define READ_FILE_PROBABILITY_KEY TEXT("ReadFileProbability")
#define DEVICE_IO_CONTROL_PROBABILITY_KEY TEXT("DeviceIoControlProbability")
#define RANDOM_WIN32_API_PROBABILITY_KEY TEXT("RandomWin32APIProbability")
#define CANCEL_IO_PROBABILITY_KEY TEXT("CancelIoProbability")
#define QUERY_VOLUME_INFORMATION_PROBABILITY_KEY TEXT("QueryVolumeInformationFileProbability")
#define QUERY_INFORMATION_FILE_PROBABILITY_KEY TEXT("QueryInformationFileProbability")
#define SET_INFORMATION_FILE_PROBABILITY_KEY TEXT("SetInformationFileProbability")
#define QUERY_DIRECTORY_FILE_PROBABILITY_KEY TEXT("QueryDirectoryFileProbability")
#define QUERY_FULL_ATTRIBUTES_FILE_PROBABILITY_KEY TEXT("QueryFullAttributesFileProbability")
#define NOTIFY_CHANGE_DIRECTORY_FILE_PROBABILITY_KEY TEXT("NotifyChangeDirectoryFileProbability")
#define ZERO_WORKING_SET_SIZE_PROBABILITY_KEY TEXT("ZeroWorkingSetSizeProbability")
#define CAUSE_INOUT_BUFF_OVERFLOW_PROBABILITY_KEY TEXT("CauseInOutBuffsOverflowMustUsePageHeapProbability")
#define TERMINATE_IOCTL_THREADS_KEY TEXT("TerminateIoctlThreads")
#define ALERT_RANDOM_IOCTL_THREADS TEXT("AlertRandomIOCTLThreads")
#define TRY_DE_COMMITTED_BUFFERS_PROBABILITY_KEY TEXT("TryDeCommittedBuffersProbability")
#define BREAK_ALIGNMENT_PROBABILITY_KEY TEXT("BreakAlignmentProbability")
#define CLOSE_RANDOM_HANDLES_KEY TEXT("CloseRandomHandles")
#define FAULT_INJECTION_TOGGLE_PROBABILITY_KEY TEXT("FaultInjectionToggleProbability")

static int s_nFaultInjectionToggleProbability = 0;

//
// array of device names, as read from the INI file
//
static TCHAR s_aszDeviceSymbolicNames[MAX_NUM_OF_DEVICES][MAX_DEVICE_NAME_LEN];
static TCHAR s_aszDevicesRealName[MAX_NUM_OF_DEVICES][MAX_DEVICE_NAME_LEN];


BOOL
EnableDebugPrivilege ()
{
	static long s_fDebugPrivilegeEnabled = FALSE;

	if (s_fDebugPrivilegeEnabled) return TRUE;

    struct
    {
        DWORD Count;
        LUID_AND_ATTRIBUTES Privilege [1];

    } Info;

    HANDLE Token;
    BOOL Result;

    //
    // open the process token
    //

    Result = OpenProcessToken (
        GetCurrentProcess (),
        TOKEN_ADJUST_PRIVILEGES,
        & Token);

    if( Result != TRUE )
    {
		DPF((TEXT("EnableDebugPrivilege(): OpenProcessToken() failed with %d.\n"), ::GetLastError()));
        return FALSE;
    }

    //
    // prepare the info structure
    //

    Info.Count = 1;
    Info.Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;

    Result = LookupPrivilegeValue (
        NULL,
        SE_DEBUG_NAME,
        &(Info.Privilege[0].Luid));

    if( Result != TRUE )
    {
		DPF((TEXT("EnableDebugPrivilege(): LookupPrivilegeValue() failed with %d.\n"), ::GetLastError()));
        CloseHandle( Token );

        return FALSE;
    }

    //
    // adjust the privileges
    //

    Result = AdjustTokenPrivileges (
        Token,
        FALSE,
        (PTOKEN_PRIVILEGES) &Info,
        NULL,
        NULL,
        NULL);

    if( Result != TRUE || GetLastError() != ERROR_SUCCESS )
    {
		DPF((TEXT("EnableDebugPrivilege(): AdjustTokenPrivileges() failed with %d.\n"), ::GetLastError()));
        CloseHandle( Token );

        return FALSE;
    }

    CloseHandle( Token );

	::InterlockedExchange(&s_fDebugPrivilegeEnabled, TRUE);

    return TRUE;
}
BOOL GetDriverVerifierFlags(DWORD &dwFlags)
{
    NTSTATUS Status;
    ULONG Length = 0;
	//
	// hope this is large enough.
	// i do not want to allocate, because of fault injections
	// i do not care for re-entrancy, because this is global data that i am retrieving
	//
	static BYTE s_Buffer[1024*64];
    PSYSTEM_VERIFIER_INFORMATION VerifierInfo = (PSYSTEM_VERIFIER_INFORMATION)s_Buffer;

    do 
	{
        Status = NtQuerySystemInformation (SystemVerifierInformation,
                                           VerifierInfo,
                                           sizeof(s_Buffer),
                                           &Length);

        if (STATUS_SUCCESS != Status) 
		{
			//
			// assert that my static buffer is big enough
			//
			_ASSERTE(STATUS_INFO_LENGTH_MISMATCH != Status);

			//
			// if fault injection is on, other failures may happen, so i want to try again.
			// only upon real fatal error, will i want to stop trying
			//
			_tprintf(TEXT("GetDriverVerifierFlags() NtQuerySystemInformation failed with %d.\n"), Status);
			//
			// assert, so that i see the printout, and see if i need to add it to the "retry cases"
			//
			_ASSERTE(FALSE);
        }

    } while (STATUS_SUCCESS != Status);

    //
    // If no info fill out return success but no info.
    //
    
    if (Length == 0) 
	{
		//
		// why would that happen? should i retry in this case?
		//
		_tprintf(TEXT("GetDriverVerifierFlags() NtQuerySystemInformation returned (Length == 0).\n"));
		_ASSERTE(FALSE);
        return FALSE;
    }

    dwFlags = VerifierInfo->Level;
	DPF((TEXT("VerifierInfo->Level=0x%08X.\n"), VerifierInfo->Level));
	return TRUE;
}

BOOL TurnOnDriverVerifierFaultInjection()
{
	NTSTATUS Status;
	DWORD dwVerifierFlags = 0;
	if (!GetDriverVerifierFlags(dwVerifierFlags)) return FALSE;

	if(dwVerifierFlags & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES) return TRUE;

	dwVerifierFlags |= DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES;

	for (UINT i = 0; i < 1000; i++)
	{
		Status = NtSetSystemInformation(
			SystemVerifierInformation,
			&dwVerifierFlags,
			sizeof( dwVerifierFlags ) 
			);
		if( ! NT_SUCCESS( Status ) )
		{
			DPF((TEXT("TurnOnDriverVerifierFaultInjection() NtSetSystemInformation(0x%08X) failed with 0x%08X.\n"), dwVerifierFlags, Status));
			::Sleep(10);
		}
		else
		{
			break;
		}
	}
	DPF((TEXT("+++++ fault injection is ON!!.\n")));

	return TRUE;
}

BOOL TurnOffDriverVerifierFaultInjection()
{
	NTSTATUS Status;
	DWORD dwVerifierFlags = 0;
	if (!GetDriverVerifierFlags(dwVerifierFlags)) return FALSE;

	//DPF((TEXT("dwVerifierFlags=0x%08X.\n"), dwVerifierFlags));
	if(!(dwVerifierFlags & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES)) return TRUE;

	dwVerifierFlags &= ~DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES;

	for (UINT i = 0; i < 1000; i++)
	{
		Status = NtSetSystemInformation(
			SystemVerifierInformation,
			&dwVerifierFlags,
			sizeof( dwVerifierFlags ) 
			);
		if( ! NT_SUCCESS( Status ) )
		{
			DPF((TEXT("TurnOffDriverVerifierFaultInjection() NtSetSystemInformation(0x%08X) failed with 0x%08X.\n"), dwVerifierFlags, Status));
			::Sleep(10);
		}
		else
		{
			break;
		}
	}
	DPF((TEXT("----- fault injection is off.\n")));

	return TRUE;
}

//
// will notify all threads to finish if called 1st time, next time will just
// terminate the process
//
BOOL WINAPI Handler_Routine(DWORD dwCtrlType)
{
	static DWORD s_dwCallCount = 0;

	s_dwCallCount++;
	switch(s_dwCallCount)
	{
	case 1:
		DPF((TEXT(">>>Handler_Routine(): called 1st time, signalling all threads to finish.\n")));
		DPFLUSH();
		InterlockedExchange(&CDevice::sm_fExitAllThreads, TRUE);
		break;

	case 2:
		//
		// randomly decide wether to TerminateProcess() or AV
		//
		if (rand()%2)
		{
			TurnOffDriverVerifierFaultInjection();
			DPF((TEXT(">>>Handler_Routine(): called 2nd time, calling TerminateProcess().\n")));
			DPFLUSH();
			TerminateProcess(::GetCurrentProcess(), -1);
		}
		else
		{
			//
			// we will never get here, because rand() is seeded per thread, 
			// and since i do not seed here, i will never get here
			//
			DPF((TEXT(">>>Handler_Routine(): called 2nd time, will AV!.\n")));
			DPFLUSH();
			char *p = 0;
			*p == 0;//AV!
		}
		break;

	case 3:
		//
		// we should never get here
		//
		DPF((TEXT(">>>Handler_Routine(): called 2nd time, calling _exit().\n")));
		DPFLUSH();
		_ASSERTE(FALSE);
		_exit(-1);
		break;

	default:
		//
		// we should never get here
		//
		DPF((TEXT(">>>Handler_Routine(): called %d time, calling _exit().\n"),s_dwCallCount));
		DPFLUSH();
		_ASSERTE(FALSE);
		{
			char *p = 0;
			*p == 0;//AV!
		}
	}

	DPF((TEXT("<<<Handler_Routine(): done.\n"),s_dwCallCount));
	DPFLUSH();
	return true;
}

//
// this methods is used in order to wait for all running devices to finish
// it is needed because i might want to wait 30 minutes, but the devices cannot start, 
// so they fail after a minute or so, and there's no need to keep waiting the whole 
// 30 minutes.
// so i poll here the device thread count, untill it drops to zero
//
void SleepWhileDeviceThreadsAreRunning(DWORD dwTotalTimeToWait)
{
	DWORD dwTimeLeftToSleep = dwTotalTimeToWait;
	while(dwTimeLeftToSleep)
	{
		if (CDevice::sm_fExitAllThreads)
		{
			return;
		}

		//
		// if all threads are done now, before the time elapsed, than no need
		// to keep waiting.
		// this can happen if the device(s) cannot be opened, etc.
		//
		if (0 == CDevice::GetThreadCount())
		{
			return;
		}

		//
		// sleep, and decrement dwTimeLeftToSleep, but be carefull not to wraparound
		//
		if (dwTimeLeftToSleep >= 1000)
		{
			::Sleep(1000);
			dwTimeLeftToSleep -= 1000;
		}
		else
		{
			::Sleep(dwTimeLeftToSleep);
			dwTimeLeftToSleep = 0;//redundant, but safe
			return;
		}
	}

	return;
}


//
// if the INI file has the TerminateIoctlThreads key flagged, this threads is launched,
// and when times elapses, it terminates this process.
//
DWORD WINAPI SelfTerminatingThread(LPVOID pVoid)
{
	DWORD dwTerminateAfterXSeconds = (DWORD)pVoid;
	DWORD dwTimeToSleep;

	//
	// INFINITE means random
	// 
	if (INFINITE == dwTerminateAfterXSeconds)
	{
		dwTimeToSleep = 10*rand();//up to ~5 minutes
	}
	else
	{
		//
		// negative numbers mean the max time to sleep
		//
		if ( (0x80000000 & dwTerminateAfterXSeconds) && (0x80000000 != dwTerminateAfterXSeconds) )
		{
			// 
			// 0x7fffffff & dwTerminateAfterXSeconds cannot be 0 now
			//
			dwTimeToSleep = ((rand()<<16) | rand()) % (0x7fffffff & dwTerminateAfterXSeconds);
		}
		else
		{
			dwTimeToSleep = 1000*dwTerminateAfterXSeconds;
		}
	}

	for (DWORD dwSecondsIter = 0; dwSecondsIter < dwTimeToSleep/1000; dwSecondsIter++)
	{
		BOOL fFaultInjectionIsOn = FALSE;
		::Sleep(1000);
		if (rand()%100 < s_nFaultInjectionToggleProbability)
		{
			if (rand()%2) fFaultInjectionIsOn = !TurnOffDriverVerifierFaultInjection();
			else fFaultInjectionIsOn = TurnOnDriverVerifierFaultInjection();
		}

	}

	TurnOffDriverVerifierFaultInjection();
	DPF((TEXT("SelfTerminatingThread() before TerminateProcess().\n")));
	if(::TerminateProcess(::GetCurrentProcess(), -1))
	{
		//
		// cannot reach here
		//
		return 0;
	}
	DPF((TEXT("SelfTerminatingThread() - TerminateProcess() failed with %d, try to AV.\n"),::GetLastError()));
	//
	// TerminateProcess() should not fail, but if it does, let's AV
	//
	char *pWillAV = NULL;
	*pWillAV = 3;//AV!

	//
	// we will never reach this code
	//
	_ASSERTE(FALSE);
	return -1;
}


//
// does what its name says, but tries to do it 1000 times, in order to survive fault-injections
//
BOOL StartSelfTerminatingThread(DWORD dwTerminateAfterXSeconds)
{
	for (DWORD dwTimesTried = 0; dwTimesTried < 1000; dwTimesTried++)
	{
		DWORD dwThreadId;
		HANDLE hThread = CreateThread(
			NULL,                          // pointer to thread security attributes
			0,      // initial thread stack size, in bytes
			SelfTerminatingThread,                          // pointer to thread function
			(LPVOID)dwTerminateAfterXSeconds, // argument for new thread
			0,  // creation flags
			&dwThreadId      // pointer to returned thread identifier
			);
		if (NULL != hThread)
		{
			::CloseHandle(hThread);
			return TRUE;
		}
		::Sleep(100);
	}

	return FALSE;
}

//
// main...
//
int main(int argc, char *argvA[])
{
    int nRetval = -1;
	BOOL fRunSequentially = false;
	int nTerminateAfterXSeconds = 0;
	DWORD dwMinimumSecsToSleepBeforeClosingDevice = 0;
	DWORD dwMaximumSecsToSleepBeforeClosingDevice = 0;
	int nWriteFileProbability;
	int nReadFileProbability;
	int nDeviceIoControlProbability;
	int nRandomWin32APIProbability;
	int nCancelIoProbability;
	int nQueryVolumeInformationFileProbability;
	int nQueryInformationFileProbability;
	int nSetInformationFileProbability;
	int nQueryDirectoryFileProbability;
	int nQueryFullAttributesFileProbability;
	int nNotifyChangeDirectoryFileProbability;
	int nZeroWorkingSetSizeProbability;
	int nCauseInOutBufferOverflowMustUsePageHeapProbability;
	int fTerminateIOCTLThreads;
	int fAlertRandomIOCTLThreads;
	int nTryDeCommittedBuffersProbability;
	int nBreakAlignmentProbability;


	LPTSTR *szArgv;
#ifdef UNICODE
	szArgv = CommandLineToArgvW( GetCommandLine(), &argc );
    if (NULL == szArgv)
    {
        DPF((TEXT("CommandLineToArgvW() failed with %d\n"), GetLastError()));
        exit(-1);
    }
#else
	szArgv = argvA;
#endif

    if (argc < 3)
    {
		DPF((TEXT("Usage: %s <num of IOCTL threads per device> <ini filename> [only this IOCTL index].\n"),szArgv[0]));
		DPF((TEXT("An INI file example (see \"dosdev.exe -a\"):\n")));
		DPF((TEXT("  [Devices]\n")));
		DPF((TEXT("  COM1=\\Device\\Serial0\n")));
		DPF((TEXT("  WanArp=\\Device\\WANARP\n")));
		DPF((TEXT("Command line example: %s 3 .\\devices.ini\n"),szArgv[0]));
		exit(1);
    } 

    //
    // this is the optional parameter, that let's you specify to use one and 
    // only IOCTL to stress
    //
    DWORD dwOnlyThisIndexIOCTL = -1;
    if (argc > 3)
    {
		dwOnlyThisIndexIOCTL = _ttoi(szArgv[3]);
    }
    else
    {
        dwOnlyThisIndexIOCTL = -1;
    }

    srand(time( NULL ));

    if (! ::SetConsoleCtrlHandler(
			  Handler_Routine,  // address of handler function
			  true                          // handler to add or remove
			  ))
	{
		DPF((TEXT("SetConsoleCtrlHandler() failed with %d.\n"),GetLastError()));
		exit(1);
	}

    if (! ::EnableDebugPrivilege())
	{
		exit(1);
	}

	
    //
    // how many threads per device do we want?
    //
    int nIOCTLThreads = _ttoi(szArgv[1]);

	//
	// read the parameters section
	//
    TCHAR *pcIniFileName = szArgv[2];
    DWORD dwNumOfConcurrentDevices = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        NUM_OF_CONCURRENT_DEVICES_KEY, // points to key name, mind the prepended \\.\ 
        0,        // points to default value
        pcIniFileName        // points to initialization filename
        );
    if (0 == dwNumOfConcurrentDevices)
    {
		DPF((TEXT("All the devices will be concurrently IOCTLed.\n")));
    }
	else
	{
		DPF((TEXT("%d devices will be concurrently IOCTLed.\n"), dwNumOfConcurrentDevices));
	}
    DWORD dwTimeToRunEachDevice = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        TIME_TO_RUN_EACH_DEVICE_KEY, // points to key name, mind the prepended \\.\ 
        INFINITE,        // points to default value
        pcIniFileName        // points to initialization filename
        );
    if (0 == dwTimeToRunEachDevice)
    {
		DPF((TEXT("dwTimeToRunEachDevice=0 means we will run indefinitely.\n")));
    }
	else
	{
		DPF((TEXT("dwTimeToRunEachDevice=%d milliseconds.\n"), dwTimeToRunEachDevice));
	}
    fRunSequentially = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        RUN_SEQUENTIALLY_KEY, // points to key name, mind the prepended \\.\ 
        0,        // points to default value
        pcIniFileName        // points to initialization filename
        );
    if (0 == fRunSequentially)
    {
		DPF((TEXT("will run devices concurrently.\n")));
    }
	else
	{
		DPF((TEXT("will run devices sequentially.\n")));
	}

    nTerminateAfterXSeconds = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        TERMINATE_AFTER_X_SECONDS_KEY, // points to key name, mind the prepended \\.\ 
        0x7fffffff,        // points to default value
        pcIniFileName        // points to initialization filename
        );
    if (0 == nTerminateAfterXSeconds)
    {
		;
    }
	else
	{
		DPF((TEXT("will terminate after %d seconds.\n"), nTerminateAfterXSeconds));
	}

    dwMinimumSecsToSleepBeforeClosingDevice = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        MINIMUM_SECS_SLEEP_BEFORE_CLOSE_KEY, // points to key name, mind the prepended \\.\ 
        0,        // points to default value
        pcIniFileName        // points to initialization filename
        );
    if (0 == dwMinimumSecsToSleepBeforeClosingDevice)
    {
		dwMinimumSecsToSleepBeforeClosingDevice = 1;
    }
	else
	{
		DPF((TEXT("will close device after a least %d milliseconds.\n"), dwMinimumSecsToSleepBeforeClosingDevice));
	}

    dwMaximumSecsToSleepBeforeClosingDevice = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        MAXIMUM_SECS_SLEEP_BEFORE_CLOSE_KEY, // points to key name, mind the prepended \\.\ 
        0,        // points to default value
        pcIniFileName        // points to initialization filename
        );
    if (0 == dwMaximumSecsToSleepBeforeClosingDevice)
    {
		dwMaximumSecsToSleepBeforeClosingDevice = 5*60;
    }
	else
	{
		DPF((TEXT("will close device after a most %d milliseconds.\n"), dwMaximumSecsToSleepBeforeClosingDevice));
	}


    nWriteFileProbability = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        WRITE_FILE_PROBABILITY_KEY, // points to key name, mind the prepended \\.\ 
        10,        // points to default value
        pcIniFileName        // points to initialization filename
        );
	DPF((TEXT("nWriteFileProbability is %d percent.\n"), nWriteFileProbability));

    nReadFileProbability = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        READ_FILE_PROBABILITY_KEY, // points to key name, mind the prepended \\.\ 
        10,        // points to default value
        pcIniFileName        // points to initialization filename
        );
	DPF((TEXT("nReadFileProbability is %d percent.\n"), nReadFileProbability));

    nDeviceIoControlProbability = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        DEVICE_IO_CONTROL_PROBABILITY_KEY, // points to key name, mind the prepended \\.\ 
        100,        // points to default value
        pcIniFileName        // points to initialization filename
        );
	DPF((TEXT("nDeviceIoControlProbability is %d percent.\n"), nDeviceIoControlProbability));

    nRandomWin32APIProbability = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        RANDOM_WIN32_API_PROBABILITY_KEY, // points to key name, mind the prepended \\.\ 
        10,        // points to default value
        pcIniFileName        // points to initialization filename
        );
	DPF((TEXT("nRandomWin32APIProbability is %d percent.\n"), nRandomWin32APIProbability));

    nCancelIoProbability = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        CANCEL_IO_PROBABILITY_KEY, // points to key name, mind the prepended \\.\ 
        5,        // points to default value
        pcIniFileName        // points to initialization filename
        );
	DPF((TEXT("nCancelIoProbability is %d percent.\n"), nCancelIoProbability));

    nQueryVolumeInformationFileProbability = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        QUERY_VOLUME_INFORMATION_PROBABILITY_KEY, // points to key name, mind the prepended \\.\ 
        5,        // points to default value
        pcIniFileName        // points to initialization filename
        );
	DPF((TEXT("nQueryVolumeInformationFileProbability is %d percent.\n"), nQueryVolumeInformationFileProbability));

    nQueryInformationFileProbability = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        QUERY_INFORMATION_FILE_PROBABILITY_KEY, // points to key name, mind the prepended \\.\ 
        5,        // points to default value
        pcIniFileName        // points to initialization filename
        );
	DPF((TEXT("nQueryInformationFileProbability is %d percent.\n"), nQueryInformationFileProbability));

    nSetInformationFileProbability = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        SET_INFORMATION_FILE_PROBABILITY_KEY, // points to key name, mind the prepended \\.\ 
        5,        // points to default value
        pcIniFileName        // points to initialization filename
        );
	DPF((TEXT("nSetInformationFileProbability is %d percent.\n"), nSetInformationFileProbability));

    nQueryDirectoryFileProbability = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        QUERY_DIRECTORY_FILE_PROBABILITY_KEY, // points to key name, mind the prepended \\.\ 
        5,        // points to default value
        pcIniFileName        // points to initialization filename
        );
	DPF((TEXT("nQueryDirectoryFileProbability is %d percent.\n"), nQueryDirectoryFileProbability));

    nQueryFullAttributesFileProbability = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        QUERY_FULL_ATTRIBUTES_FILE_PROBABILITY_KEY, // points to key name, mind the prepended \\.\ 
        5,        // points to default value
        pcIniFileName        // points to initialization filename
        );
	DPF((TEXT("nQueryFullAttributesFileProbability is %d percent.\n"), nQueryFullAttributesFileProbability));

    nNotifyChangeDirectoryFileProbability = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        NOTIFY_CHANGE_DIRECTORY_FILE_PROBABILITY_KEY, // points to key name, mind the prepended \\.\ 
        5,        // points to default value
        pcIniFileName        // points to initialization filename
        );
	DPF((TEXT("nNotifyChangeDirectoryFileProbability is %d percent.\n"), nNotifyChangeDirectoryFileProbability));

    nZeroWorkingSetSizeProbability = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        ZERO_WORKING_SET_SIZE_PROBABILITY_KEY, // points to key name, mind the prepended \\.\ 
        10,        // points to default value
        pcIniFileName        // points to initialization filename
        );
	DPF((TEXT("nZeroWorkingSetSizeProbability is %d percent.\n"), nZeroWorkingSetSizeProbability));

    nCauseInOutBufferOverflowMustUsePageHeapProbability = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        CAUSE_INOUT_BUFF_OVERFLOW_PROBABILITY_KEY, // points to key name, mind the prepended \\.\ 
        0,        // points to default value
        pcIniFileName        // points to initialization filename
        );
	DPF((TEXT("nCauseInOutBufferOverflowMustUsePageHeapProbability is %d percent.\n"), nCauseInOutBufferOverflowMustUsePageHeapProbability));

    fTerminateIOCTLThreads = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        TERMINATE_IOCTL_THREADS_KEY, // points to key name, mind the prepended \\.\ 
        0,        // points to default value
        pcIniFileName        // points to initialization filename
        );
	if (0 != fTerminateIOCTLThreads)
	{
		DPF((TEXT("TerminateIOCTLThreads is enabled.\n")));
	}

    s_nFaultInjectionToggleProbability = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        FAULT_INJECTION_TOGGLE_PROBABILITY_KEY, // points to key name, mind the prepended \\.\ 
        0,        // points to default value
        pcIniFileName        // points to initialization filename
        );
	if (0 != s_nFaultInjectionToggleProbability)
	{
		DPF((TEXT("s_nFaultInjectionToggleProbability is %d.\n"), s_nFaultInjectionToggleProbability));
	}

    fAlertRandomIOCTLThreads = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        ALERT_RANDOM_IOCTL_THREADS, // points to key name, mind the prepended \\.\ 
        0,        // points to default value
        pcIniFileName        // points to initialization filename
        );
	if (0 != fTerminateIOCTLThreads)
	{
		DPF((TEXT("fAlertRandomIOCTLThreads is enabled.\n")));
	}

    nTryDeCommittedBuffersProbability = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        TRY_DE_COMMITTED_BUFFERS_PROBABILITY_KEY, // points to key name, mind the prepended \\.\ 
        1,        // points to default value
        pcIniFileName        // points to initialization filename
        );
	DPF((TEXT("nTryDeCommittedBuffersProbability is %d percent.\n"), nTryDeCommittedBuffersProbability));

    nBreakAlignmentProbability = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        BREAK_ALIGNMENT_PROBABILITY_KEY, // points to key name, mind the prepended \\.\ 
        1,        // points to default value
        pcIniFileName        // points to initialization filename
        );
	DPF((TEXT("nBreakAlignmentProbability is %d percent.\n"), nBreakAlignmentProbability));
	CDevice::sm_fCloseRandomHandles = GetPrivateProfileInt(
        PARAMETERS_SECTION,        // points to section name
        CLOSE_RANDOM_HANDLES_KEY, // points to key name, mind the prepended \\.\ 
        0,        // points to default value
        pcIniFileName        // points to initialization filename
        );
	DPF((TEXT("CDevice::sm_fCloseRandomHandles is %d.\n"), CDevice::sm_fCloseRandomHandles));
    //
    // read all the devices section, parse it to extract the device names
    //
    TCHAR mszSection[128*1024];
 
    DWORD dwCopied = GetPrivateProfileSection(
        DEVICE_SECTION,        // address of section name
        mszSection,  // address of return buffer
        sizeof(mszSection),              // size of return buffer
        pcIniFileName        // address of initialization filename
        );
    if (sizeof(mszSection) - 2 == dwCopied)
    {
		DPF((TEXT("Internal error: 128K is not enough for a file as big as %s.\n"),pcIniFileName));
		exit(1);
    }

    //
    // lets fill the device names into the arrays
    // we will get the symbolic (key) name, and them we use 
    // the INI API to get the values. Yeah, I know i can extract it here,
    // but I do have the API for it, and the performance is not noticable.
    //
    TCHAR *pcNextString;
    TCHAR *pBreak;
    int nNumOfDevices;
    for (   pcNextString = mszSection, nNumOfDevices = 0; 
            *pcNextString != TEXT('\0'); 
            pcNextString += lstrlen(pcNextString)+1, nNumOfDevices++
        )
    {
        if (nNumOfDevices > MAX_NUM_OF_DEVICES)
        {
		    DPF((TEXT("Internal error: cannot support more than %d devices.\n"), MAX_NUM_OF_DEVICES));
		    exit(1);
        }

        _stprintf(s_aszDeviceSymbolicNames[nNumOfDevices], TEXT("\\\\.\\%s"), pcNextString);
    }

	//
	// create the self terminating thread if needed
	//
	if (0 != nTerminateAfterXSeconds)
	{
		if (!StartSelfTerminatingThread(nTerminateAfterXSeconds))
		{
		    DPF((TEXT("StartSelfTerminatingThread() failed, exiting.\n")));
		    exit(1);
		}
	}

    //
    // now each string holds <symbolic name> = <device name>
    // lets take apart the symbolic names and the real name
    //
    for (
		int iDevice = 0; 
		iDevice < nNumOfDevices; 
		iDevice++)
    {
        pBreak = _tcspbrk(s_aszDeviceSymbolicNames[iDevice], TEXT(" =\0"));
        if (NULL == pBreak)
		{
			//
			// illegal entry
			//
		    DPF((TEXT("illegal entry: %s.\n"), s_aszDeviceSymbolicNames[iDevice]));
			lstrcpy(s_aszDevicesRealName[iDevice], TEXT(""));
			continue;
		}
        *pBreak = TEXT('\0');
        DWORD dwRet = GetPrivateProfileString(
            DEVICE_SECTION,        // points to section name
            &s_aszDeviceSymbolicNames[iDevice][4], // points to key name, mind the prepended \\.\ 
            TEXT(""),        // points to default string
            s_aszDevicesRealName[iDevice],  // points to destination buffer
            MAX_DEVICE_NAME_LEN,              // size of destination buffer
            pcIniFileName        // points to initialization filename
            );
        if (MAX_DEVICE_NAME_LEN-1 == dwRet)
        {
		    DPF((TEXT("Internal error: %d is not enough for the key value of %s.\n"), MAX_DEVICE_NAME_LEN, s_aszDeviceSymbolicNames[iDevice]));
		    exit(1);
        }
    }

	//
	// I do not want any popups due to empty floppy drives etc.
	//
	SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    //
	// create the devices that will be concurrently IOCTLed
	// note that it is possible to open only some, wait for a timeout,
	// close them, and choose more, and so on.
	//
    CDevice *apDevice[MAX_NUM_OF_DEVICES];
    ZeroMemory(apDevice, sizeof(apDevice));
	CDevice::sm_nZeroWorkingSetSizeProbability = nZeroWorkingSetSizeProbability;
	for(;;)
	{
		//
		// open all devices, or as specified in the INI file, but no more than the max
		//
		int nNumOfDevicesToOpen = (dwNumOfConcurrentDevices == 0) ? nNumOfDevices : min(dwNumOfConcurrentDevices,nNumOfDevices);
		nNumOfDevicesToOpen = min(MAX_NUM_OF_DEVICES, nNumOfDevicesToOpen);

		//
		// if the user wants to run devices sequentially, this overrides the
		// number of concurrent devices
		//
		if (fRunSequentially)
		{
		    DPF((TEXT("will run sequentially all devices, ConcurrentDevices is ignored.\n")));
			nNumOfDevicesToOpen = nNumOfDevices;
		}
		
		//
		// create the requested number of devices, and start them
		//
		for (iDevice = 0; iDevice < nNumOfDevicesToOpen; iDevice++)
		{
			_ASSERTE(iDevice < MAX_NUM_OF_DEVICES);

			if (CDevice::sm_fExitAllThreads)
			{
				DPF((TEXT("CDevice::sm_fExitAllThreads signalled, breaking\n")));
				break;
			}

			{
				//
				// if we use all devices, then use iDevice, otherwise
				// opne a random device, and we may create the same device twice
				//
				DWORD dwDeviceToCreateNow = (dwNumOfConcurrentDevices == 0) ? iDevice : rand()%nNumOfDevices;
				DWORD dwTimesTried = 0;
				for (dwTimesTried = 0; dwTimesTried < 1000; dwTimesTried++)
				{
					if (CDevice::sm_fExitAllThreads)
					{
						DPF((TEXT("CDevice::sm_fExitAllThreads signalled, bailing\n")));
						goto out;
					}

					apDevice[iDevice] = new CDevice(
						s_aszDevicesRealName[dwDeviceToCreateNow],
						s_aszDeviceSymbolicNames[dwDeviceToCreateNow],
						nIOCTLThreads,
						dwOnlyThisIndexIOCTL,
						dwMinimumSecsToSleepBeforeClosingDevice,
						dwMaximumSecsToSleepBeforeClosingDevice,
						nWriteFileProbability,
						nReadFileProbability,
						nDeviceIoControlProbability,
						nRandomWin32APIProbability,
						nCancelIoProbability,
						nQueryVolumeInformationFileProbability,
						nQueryInformationFileProbability,
						nSetInformationFileProbability,
						nQueryDirectoryFileProbability,
						nQueryFullAttributesFileProbability, 
						nNotifyChangeDirectoryFileProbability,
						nCauseInOutBufferOverflowMustUsePageHeapProbability,
						(0 != fTerminateIOCTLThreads),
						(0 != fAlertRandomIOCTLThreads),
						nTryDeCommittedBuffersProbability,
						nBreakAlignmentProbability,
						false,//fUseGivenSeed
						0//lSeed
						);
					if (NULL == apDevice[iDevice])
					{
						::Sleep(100);
						dwTimesTried++;
					}
					else 
					{
						DPF((TEXT("Created CDevice(%s, %s)\n"), s_aszDevicesRealName[dwDeviceToCreateNow], s_aszDeviceSymbolicNames[dwDeviceToCreateNow]));
						break;
					}
				}
				DPF((TEXT("Failed to create CDevice(%s, %s)\n"), s_aszDevicesRealName[dwDeviceToCreateNow], s_aszDeviceSymbolicNames[dwDeviceToCreateNow]));
			}
			if (NULL == apDevice[iDevice])
			{
				DPF((TEXT("new CDevice() failed, exiting\n")));
				exit(-1);
			}

			if (!apDevice[iDevice]->Start())
			{
				DPF((TEXT("CDevice(%d, %s)->Start() failed, exiting\n"), iDevice, apDevice[iDevice]->GetDeviceName()));
				exit(-1);
			}
			DPF((TEXT("CDevice(%d, %s)->Start() succeeded\n"), iDevice, apDevice[iDevice]->GetDeviceName()));

			if (fRunSequentially)
			{
				DPF((TEXT("Sleeping %d milliseconds before deleting the device\n"), dwTimeToRunEachDevice));
				SleepWhileDeviceThreadsAreRunning(dwTimeToRunEachDevice);
				DPF((TEXT("Before delete apDevice[%d, %s]\n"), iDevice, apDevice[iDevice]->GetDeviceName()));
				delete apDevice[iDevice];
				apDevice[iDevice] = NULL;
				DPF((TEXT("After delete apDevice[%d]\n"), iDevice));
			}
			//else continue creating concurrent devices
		}//for (iDevice = 0; iDevice < nNumOfDevices; iDevice++)

		//
		// here means one of 2 things:
		// 1 - i sequentially ran all devices. i can exit
		// 2 - i concurrently ran all devices. i need to wait an elapsed time, or break
		//
		if (fRunSequentially)
		{
			//
			// we are done, wait for all threads to finish
			//
			break;
		}

		if (INFINITE == dwTimeToRunEachDevice)
		{
			//
			// then just wait for all threads to finish
			//
			break;
		}

		DPF((TEXT("Sleeping %d milliseconds before stopping all devices\n"), dwTimeToRunEachDevice));
		SleepWhileDeviceThreadsAreRunning(dwTimeToRunEachDevice);
		::InterlockedExchange(&CDevice::sm_fExitAllThreads, TRUE);

		for (iDevice = 0; iDevice < nNumOfDevicesToOpen; iDevice++)
		{
			DPF((TEXT("Before delete apDevice[%d, %s]\n"), iDevice, apDevice[iDevice]->GetDeviceName()));
			delete apDevice[iDevice];
			apDevice[iDevice] = NULL;
			DPF((TEXT("After delete apDevice[%d]\n"), iDevice));
		}

		::InterlockedExchange(&CDevice::sm_fExitAllThreads, FALSE);
		//
		// continue to the next set of devices
		//

	}//for(;;)

    nRetval = 0;
out:

    //
    // why polling?
    // because it's stupid simple, and i know there can be more than 64 devices 
    // which complicates a bit using WaitForMultipleObjects().
    //
    CDevice::WaitForAllDeviceThreadsToFinish(1000);

	TurnOffDriverVerifierFaultInjection();
    return nRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\manyfilesioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

#include <windows.h>
*/

#include "ManyFilesIOCTL.h"

static bool s_fVerbose = true;


CIoctlManyFiles::CIoctlManyFiles(CDevice *pDevice): 
CIoctlFile(pDevice)
{
	;
}

CIoctlManyFiles::~CIoctlManyFiles()
{
	;
}

HANDLE CIoctlManyFiles::CreateDevice(CDevice *pDevice)
{
	if (!::CreateDirectory(m_pDevice->GetDeviceName(), NULL))
	{
		DPF((
			TEXT("CIoctlManyFiles::CreateDevice(): CreateDirectory(%s) failed with %d\n"),
			m_pDevice->GetDeviceName(),
			::GetLastError()
			));
		DWORD dwLastError = ::GetLastError();
		if (ERROR_ALREADY_EXISTS == dwLastError)
		{

		}
		else
		{
			return INVALID_HANDLE_VALUE;
		}
	}

	DWORD dwAcccessMode = GENERIC_READ | GENERIC_WRITE;
	DWORD dwFileAttributes = FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED;
	HANDLE hFolder = ::CreateFile(
			m_pDevice->GetDeviceName(),          // pointer to name of the file
			dwAcccessMode,       // access (read-write) mode
			FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,           // share mode
			NULL,                        // pointer to security attributes
			OPEN_ALWAYS,  // how to create
			dwFileAttributes,  // file attributes
			NULL         // handle to file with attributes to copy
			);
	if (INVALID_HANDLE_VALUE == hFolder)
	{
		DPF((
			TEXT("CIoctlManyFiles::CreateDevice(): CreateFile(%s) failed with %d\n"),
			m_pDevice->GetDeviceName(),
			::GetLastError()
			));
	}

	return hFolder;
}






void CIoctlManyFiles::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
	//
	// i want many files
	//
	if (m_hContainer.Get_CurrentNumberOfSlots() > m_hContainer.Get_NumOfValidEntries())
	//if (rand()%100)
	{
		DPF((TEXT("m_hContainer: m_uiCurrentNumberOfSlots=%d, m_uiNumOfValidEntries=%d.\n"), m_hContainer.Get_CurrentNumberOfSlots(), m_hContainer.Get_NumOfValidEntries()));
		HANDLE hNewFile = CreateAutoDeleteUniqueFile();
		if (INVALID_HANDLE_VALUE != hNewFile)
		{
			if (!m_hContainer.AddItem(hNewFile))
			{
				DPF((TEXT("CIoctlManyFiles::PrepareIOCTLParams(): m_hContainer.AddItem FAILED\n")));
				::CloseHandle(hNewFile);
			}
		}
	}
	else
	{
		DPF((TEXT("m_hContainer: m_uiCurrentNumberOfSlots=%d, m_uiNumOfValidEntries=%d.\n"), m_hContainer.Get_CurrentNumberOfSlots(), m_hContainer.Get_NumOfValidEntries()));
		HANDLE hFileToClose = m_hContainer.RemoveRandomItem();
		if (INVALID_HANDLE_VALUE == hFileToClose)
		{
			DPF((TEXT("CIoctlManyFiles::PrepareIOCTLParams(): m_hContainer.RemoveRandomItem FAILED\n")));
		}
	}

	switch(dwIOCTL)
	{
	case 0://create a new file
	case 1://delete an above file
		break;

	default:
		CIoctlFile::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
		return;
	}

	//
	// i do not want to issue the special IOCTLs (today 0 and 1), so override them
	//
	dwIOCTL = m_pDevice->GetLegalIOCTLAt(2+rand()%(m_pDevice->GetMaxFreeLegalIOCTLIndex()-2));
	CIoctlFile::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
}


BOOL CIoctlManyFiles::FindValidIOCTLs(CDevice *pDevice)
{
    AddIOCTL(pDevice, 0);
    AddIOCTL(pDevice, 1);

	//return TRUE;
	return CIoctlFile::FindValidIOCTLs(pDevice);

}

HANDLE CIoctlManyFiles::GetRandomFileHandle(HANDLE hFile)
{
	HANDLE hRetval = m_hContainer.GetRandomItem();
	//
	// if container has nothing for us, or once in a while, return hFile
	//
	if ((0 == rand()%100) || (INVALID_HANDLE_VALUE == hRetval))
	{
		hRetval = hFile;
	}
	DPF((TEXT("CIoctlManyFiles::GetRandomFileHandle() returning %d.\n"), hRetval));
	return hRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\mqacioctl.h ===
#ifndef __MQAC_IOCTL_H
#define __MQAC_IOCTL_H

//#include "IOCTL.h"

#include "xactdefs.h"
#include "trnsbufr.h"

class CIoctlMqAc : public CIoctl
{
public:
    CIoctlMqAc(CDevice *pDevice): CIoctl(pDevice){;};
    virtual ~CIoctlMqAc(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(
        DWORD dwIOCTL, 
        BYTE *abOutBuffer, 
        DWORD dwOutBuff,
        OVERLAPPED *pOL
    );

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

};




#endif //__MQAC_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\memoryioctl.h ===
#ifndef __MEMORY_IOCTL_H
#define __MEMORY_IOCTL_H

#include "FileIOCTL.h"
//#include "IOCTL.h"


class CIoctlMemory : public CIoctl
{
public:
    CIoctlMemory(CDevice *pDevice): CIoctl(pDevice),m_pFileIoctl(NULL){;};
    virtual ~CIoctlMemory(){delete m_pFileIoctl; m_pFileIoctl = NULL;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual HANDLE CreateDevice(CDevice *pDevice);

	virtual BOOL CloseDevice(CDevice *pDevice);

	virtual BOOL DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		);

	virtual BOOL DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

	virtual BOOL DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		);

private:
	CIoctlFile *m_pFileIoctl;
};




#endif //__MEMORY_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\mspnatioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*



#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
*/
#include "mspnatIOCTL.h"

static bool s_fVerbose = false;

static void Fill_mspnatd_RTR_INFO_BLOCK_HEADER(RTR_INFO_BLOCK_HEADER &rtr_info_block_header);

static DWORD GetRandomIfInfoFlags()
{
/*
//
// Flags for IP_NAT_INTERFACE_INFO.Flags
//
// _BOUNDARY: set to mark interface as boundary-interface.
// _NAPT: set to enable address-sharing via port-translation.
//

#define IP_NAT_INTERFACE_FLAGS_BOUNDARY 0x00000001
#define IP_NAT_INTERFACE_FLAGS_NAPT     0x00000002
#define IP_NAT_INTERFACE_FLAGS_ALL      0x00000003
*/
    if (0 == rand()%5) return IP_NAT_INTERFACE_FLAGS_BOUNDARY;
    if (0 == rand()%4) return IP_NAT_INTERFACE_FLAGS_NAPT;
    if (0 == rand()%3) return IP_NAT_INTERFACE_FLAGS_ALL;
    if (0 == rand()%2) return 0;
    return 4;
}

static UCHAR GetRandProtocol()
{
    switch(rand()%6)
    {
    case 0: return NAT_PROTOCOL_ICMP;
    case 1: return NAT_PROTOCOL_IGMP;
    case 2: return NAT_PROTOCOL_TCP;
    case 3: return NAT_PROTOCOL_UDP;
    case 4: return NAT_PROTOCOL_PPTP;
    default: return rand();
    }

}

ULONG GetIpNatXXXType()
{
    switch(rand()%6)
    {
    case 0: return IP_NAT_TIMEOUT_TYPE;
    case 1: return IP_NAT_PROTOCOLS_ALLOWED_TYPE;
    case 2: return IP_NAT_ADDRESS_RANGE_TYPE;
    case 3: return IP_NAT_PORT_MAPPING_TYPE;
    case 4: return IP_NAT_ADDRESS_MAPPING_TYPE;
    default: return rand();
    }
}

void Fill_mspnatd_RTR_INFO_BLOCK_HEADER(RTR_INFO_BLOCK_HEADER &rtr_info_block_header)
{
/*
typedef struct _RTR_INFO_BLOCK_HEADER
{
    ULONG			Version;	    // Version of the structure
    ULONG			Size;		    // size of the whole block, including version
    ULONG			TocEntriesCount;// Number of entries
    RTR_TOC_ENTRY   TocEntry[1];    // Table of content followed by the actual
                                    // information blocks
} RTR_INFO_BLOCK_HEADER, *PRTR_INFO_BLOCK_HEADER;
*/
    rtr_info_block_header.Version = DWORD_RAND;
    rtr_info_block_header.Size = rand()%2 ? sizeof(RTR_INFO_BLOCK_HEADER) : rand();
    rtr_info_block_header.TocEntriesCount = rand()%10;
/*
typedef struct _RTR_TOC_ENTRY
{
    ULONG	    InfoType;	// Info structure type
    ULONG	    InfoSize;	// Size of the info structure
    ULONG	    Count;		// How many info structures of this type
    ULONG	    Offset;		// Offset of the first structure, from the start
							// of the info block header.
}RTR_TOC_ENTRY, *PRTR_TOC_ENTRY;
*/
    for (ULONG i = 0; i < rtr_info_block_header.TocEntriesCount+rand()%2; i++)
    {
        rtr_info_block_header.TocEntry[i].InfoType = GetIpNatXXXType();
        rtr_info_block_header.TocEntry[i].InfoSize = rand()%200;
        rtr_info_block_header.TocEntry[i].Count = rand()%20;
        rtr_info_block_header.TocEntry[i].Offset = rand()%100;
    }
}


void CIoctlMspnat::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
    //DPF((TEXT("PrepareIOCTLParams(%s)\n"), szDevice));
    //
    // fill random data & len
    //
    if (rand()%20 == 0)
    {
        FillBufferWithRandomData(abInBuffer, dwInBuff);
        FillBufferWithRandomData(abOutBuffer, dwOutBuff);
        return;
    }

    //
    // NULL pointer variations
    //
    if (rand()%20 == 0)
    {
        abInBuffer = NULL;
        return;
    }
    if (rand()%20 == 0)
    {
        abOutBuffer = NULL;
        return;
    }
    if (rand()%20 == 0)
    {
        abInBuffer = NULL;
        abOutBuffer = NULL;
        return;
    }

    //
    // 0 size variations
    //
    if (rand()%20 == 0)
    {
        dwInBuff = NULL;
        return;
    }
    if (rand()%20 == 0)
    {
        dwOutBuff = NULL;
        return;
    }
    if (rand()%20 == 0)
    {
        dwInBuff = NULL;
        dwOutBuff = NULL;
        return;
    }

    //
    // fill "smart" data
    //
    switch(dwIOCTL)
    {
    case IOCTL_IP_NAT_SET_GLOBAL_INFO:
// InputBuffer: IP_NAT_GLOBAL_INFO
// OutputBuffer: none.
/*
typedef struct _IP_NAT_GLOBAL_INFO {
    ULONG LoggingLevel; // see IPNATHLP.H (IPNATHLP_LOGGING_*).
    ULONG Flags;
    RTR_INFO_BLOCK_HEADER Header;
} IP_NAT_GLOBAL_INFO, *PIP_NAT_GLOBAL_INFO;
*/
        ((PIP_NAT_GLOBAL_INFO)abInBuffer)->LoggingLevel = DWORD_RAND;
        ((PIP_NAT_GLOBAL_INFO)abInBuffer)->Flags = DWORD_RAND;
        Fill_mspnatd_RTR_INFO_BLOCK_HEADER(((PIP_NAT_GLOBAL_INFO)abInBuffer)->Header);

        SetInParam(dwInBuff, sizeof(IP_NAT_GLOBAL_INFO));

        SetOutParam(abOutBuffer, dwOutBuff, 0);


        break;

    case IOCTL_IP_NAT_REQUEST_NOTIFICATION:
// InputBuffer: 'IP_NAT_NOTIFICATION' indicating the notification required
// OutputBuffer: depends on 'IP_NAT_NOTIFICATION'.
/*
typedef enum {
    NatRoutingFailureNotification = 0,
    NatMaximumNotification
} IP_NAT_NOTIFICATION, *PIP_NAT_NOTIFICATION;
*/
        (*((DWORD*)abInBuffer)) = rand()%2 ? NatRoutingFailureNotification : rand()%2 ? NatMaximumNotification : rand();
        dwInBuff = rand()%2 ? sizeof(DWORD) : rand();
        dwOutBuff = rand()%2 ? dwOutBuff : rand()%dwOutBuff;

        break;

    case IOCTL_IP_NAT_CREATE_INTERFACE:
// InputBuffer: IP_NAT_CREATE_INTERFACE
// OutputBuffer: none.
/*
typedef struct _IP_NAT_CREATE_INTERFACE {
    IN ULONG Index;
    IN ULONG BindingInfo[0];
} IP_NAT_CREATE_INTERFACE, *PIP_NAT_CREATE_INTERFACE;
*/
        ((PIP_NAT_CREATE_INTERFACE)abInBuffer)->Index = GetInterfaceIndex();
//////////////////////////////////////////////
// from #include "routprot.h"
//////////////////////////////////////////////
typedef struct IP_LOCAL_BINDING
{
    DWORD   IPAddress;
    DWORD   Mask;
}IP_LOCAL_BINDING, *PIP_LOCAL_BINDING;

typedef struct	IP_ADAPTER_BINDING_INFO
{
    DWORD               NumAddresses;
    DWORD               RemoteAddress;
    IP_LOCAL_BINDING    Address[1];
}IP_ADAPTER_BINDING_INFO, *PIP_ADAPTER_BINDING_INFO;

//////////////////////////////////////////////
// end of #include "routprot.h"
//////////////////////////////////////////////

        ((PIP_ADAPTER_BINDING_INFO)((PIP_NAT_CREATE_INTERFACE)abInBuffer)->BindingInfo[0])->NumAddresses = rand();
        ((PIP_ADAPTER_BINDING_INFO)((PIP_NAT_CREATE_INTERFACE)abInBuffer)->BindingInfo[0])->RemoteAddress = rand();
        ((PIP_ADAPTER_BINDING_INFO)((PIP_NAT_CREATE_INTERFACE)abInBuffer)->BindingInfo[0])->Address[0].IPAddress = rand();
        ((PIP_ADAPTER_BINDING_INFO)((PIP_NAT_CREATE_INTERFACE)abInBuffer)->BindingInfo[0])->Address[0].Mask = rand();

        SetInParam(dwInBuff, sizeof(IP_NAT_CREATE_INTERFACE));

        SetOutParam(abOutBuffer, dwOutBuff, 0);


        break;

    case IOCTL_IP_NAT_DELETE_INTERFACE:
// InputBuffer: the 32-bit index of the interface to be deleted.
// OutputBuffer: none.
        (*(DWORD*)abInBuffer) = GetInterfaceIndex();
        SetInParam(dwInBuff, sizeof(DWORD));
        SetOutParam(abOutBuffer, dwOutBuff, 0);

        break;

    //case 4:
        //unused
        break;

    //case 5:
        //unused
        break;

    case IOCTL_IP_NAT_SET_INTERFACE_INFO:
// InputBuffer: 'IP_NAT_INTERFACE_INFO' holding the interface's configuration
// OutputBuffer: none.
/*
typedef struct _IP_NAT_INTERFACE_INFO {
    ULONG Index;
    ULONG Flags;
    RTR_INFO_BLOCK_HEADER Header;
} IP_NAT_INTERFACE_INFO, *PIP_NAT_INTERFACE_INFO;
*/

        ((PIP_NAT_INTERFACE_INFO)abInBuffer)->Index = GetInterfaceIndex();
        ((PIP_NAT_INTERFACE_INFO)abInBuffer)->Flags = GetRandomIfInfoFlags();
        Fill_mspnatd_RTR_INFO_BLOCK_HEADER(((PIP_NAT_INTERFACE_INFO)abInBuffer)->Header);

        SetInParam(dwInBuff, sizeof(IP_NAT_INTERFACE_INFO));

        SetOutParam(abOutBuffer, dwOutBuff, 0);


        break;
        
        
        break;

    case IOCTL_IP_NAT_GET_INTERFACE_INFO:
// InputBuffer: the 32-bit index of the interface in question
// OutputBuffer: 'IP_NAT_INTERFACE_INFO' holding the interface's configuration
        (*(DWORD*)abInBuffer) = GetInterfaceIndex();
        SetInParam(dwInBuff, sizeof(DWORD));
        SetOutParam(abOutBuffer, dwOutBuff, sizeof(IP_NAT_INTERFACE_INFO));


        break;

    case IOCTL_IP_NAT_REGISTER_EDITOR:
// InputBuffer: 'IP_NAT_REGISTER_EDITOR' with input parameters set
// OutputBuffer: 'IP_NAT_REGISTER_EDITOR' with output parameters filled in
/*
typedef struct _IP_NAT_REGISTER_EDITOR {
    IN ULONG Version;
    IN ULONG Flags;
    IN UCHAR Protocol;
    IN USHORT Port;
    IN IP_NAT_DIRECTION Direction;
    IN PVOID EditorContext;
    IN PNAT_EDITOR_CREATE_HANDLER CreateHandler;            // OPTIONAL
    IN PNAT_EDITOR_DELETE_HANDLER DeleteHandler;            // OPTIONAL
    IN PNAT_EDITOR_DATA_HANDLER ForwardDataHandler;         // OPTIONAL
    IN PNAT_EDITOR_DATA_HANDLER ReverseDataHandler;         // OPTIONAL
    OUT PVOID EditorHandle;
    OUT PNAT_EDITOR_CREATE_TICKET CreateTicket;
    OUT PNAT_EDITOR_DELETE_TICKET DeleteTicket;
    OUT PNAT_EDITOR_DEREGISTER Deregister;
    OUT PNAT_EDITOR_DISSOCIATE_SESSION DissociateSession;
    OUT PNAT_EDITOR_EDIT_SESSION EditSession;
    OUT PNAT_EDITOR_QUERY_INFO_SESSION QueryInfoSession;
    OUT PNAT_EDITOR_TIMEOUT_SESSION TimeoutSession;
} IP_NAT_REGISTER_EDITOR, *PIP_NAT_REGISTER_EDITOR;

typedef enum {
    NatInboundDirection = 0,
    NatOutboundDirection,
    NatMaximumDirection
} IP_NAT_DIRECTION, *PIP_NAT_DIRECTION;

*/
        ((PIP_NAT_REGISTER_EDITOR)abInBuffer)->Version = rand();
        ((PIP_NAT_REGISTER_EDITOR)abInBuffer)->Flags = DWORD_RAND;
        ((PIP_NAT_REGISTER_EDITOR)abInBuffer)->Protocol = GetRandProtocol();
        ((PIP_NAT_REGISTER_EDITOR)abInBuffer)->Port = rand();
        ((PIP_NAT_REGISTER_EDITOR)abInBuffer)->Direction = rand()%2 ? NatInboundDirection : rand()%2 ? NatOutboundDirection : rand()%2 ? NatMaximumDirection : (IP_NAT_DIRECTION)rand();
        ((PIP_NAT_REGISTER_EDITOR)abInBuffer)->EditorContext = GetEditorHandle();
        ((PIP_NAT_REGISTER_EDITOR)abInBuffer)->CreateHandler = NULL;
        ((PIP_NAT_REGISTER_EDITOR)abInBuffer)->DeleteHandler = NULL;
        ((PIP_NAT_REGISTER_EDITOR)abInBuffer)->ForwardDataHandler = NULL;
        ((PIP_NAT_REGISTER_EDITOR)abInBuffer)->ReverseDataHandler = NULL;
        ((PIP_NAT_REGISTER_EDITOR)abInBuffer)->EditorHandle = (void*)DWORD_RAND;
        ((PIP_NAT_REGISTER_EDITOR)abInBuffer)->CreateTicket = NULL;
        ((PIP_NAT_REGISTER_EDITOR)abInBuffer)->DeleteTicket = NULL;
        ((PIP_NAT_REGISTER_EDITOR)abInBuffer)->Deregister = NULL;
        ((PIP_NAT_REGISTER_EDITOR)abInBuffer)->DissociateSession = NULL;
        ((PIP_NAT_REGISTER_EDITOR)abInBuffer)->EditSession = NULL;
        ((PIP_NAT_REGISTER_EDITOR)abInBuffer)->QueryInfoSession = NULL;
        ((PIP_NAT_REGISTER_EDITOR)abInBuffer)->TimeoutSession = NULL;

        SetInParam(dwInBuff, sizeof(IP_NAT_REGISTER_EDITOR));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(IP_NAT_REGISTER_EDITOR));

        break;

    case IOCTL_IP_NAT_GET_INTERFACE_STATISTICS:
// InputBuffer: the 32-bit index of the interface in question
// OutputBuffer: 'IP_NAT_INTERFACE_STATISTICS' with the interface's statistics
        (*(DWORD*)abInBuffer) = GetInterfaceIndex();
        SetInParam(dwInBuff, sizeof(DWORD));
        SetOutParam(abOutBuffer, dwOutBuff, sizeof(IP_NAT_INTERFACE_STATISTICS));


        break;

    case IOCTL_IP_NAT_GET_MAPPING_TABLE:
// InputBuffer: 'IP_NAT_ENUMERATE_SESSION_MAPPINGS' with input parameters set
// OutputBuffer: 'IP_NAT_ENUMERATE_SESSION_MAPPINGS' with output parameters
/*
typedef struct _IP_NAT_ENUMERATE_SESSION_MAPPINGS {
    IN ULONG Index;
    IN OUT ULONG EnumerateContext[4];
    OUT ULONG EnumerateCount;
    OUT ULONG EnumerateTotalHint;
    OUT IP_NAT_SESSION_MAPPING EnumerateTable[1];
} IP_NAT_ENUMERATE_SESSION_MAPPINGS, *PIP_NAT_ENUMERATE_SESSION_MAPPINGS;
*/
        ((PIP_NAT_ENUMERATE_SESSION_MAPPINGS)abInBuffer)->Index = GetInterfaceIndex();
        ((PIP_NAT_ENUMERATE_SESSION_MAPPINGS)abInBuffer)->EnumerateContext[0] = DWORD_RAND;
        ((PIP_NAT_ENUMERATE_SESSION_MAPPINGS)abInBuffer)->EnumerateContext[1] = DWORD_RAND;
        ((PIP_NAT_ENUMERATE_SESSION_MAPPINGS)abInBuffer)->EnumerateContext[2] = DWORD_RAND;
        ((PIP_NAT_ENUMERATE_SESSION_MAPPINGS)abInBuffer)->EnumerateContext[3] = DWORD_RAND;

        SetInParam(dwInBuff, sizeof(IP_NAT_ENUMERATE_SESSION_MAPPINGS));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(IP_NAT_ENUMERATE_SESSION_MAPPINGS));

        break;

    case IOCTL_IP_NAT_REGISTER_DIRECTOR:
// InputBuffer: 'IP_NAT_REGISTER_DIRECTOR' with input parameters set
// OutputBuffer: 'IP_NAT_REGISTER_DIRECTOR' with output parameters filled in
/*
typedef struct _IP_NAT_REGISTER_DIRECTOR {
    IN ULONG Version;
    IN ULONG Flags;
    IN UCHAR Protocol;
    IN USHORT Port;
    IN PVOID DirectorContext;
    IN PNAT_DIRECTOR_QUERY_SESSION QueryHandler;
    IN PNAT_DIRECTOR_CREATE_SESSION CreateHandler;
    IN PNAT_DIRECTOR_DELETE_SESSION DeleteHandler;
    IN PNAT_DIRECTOR_UNLOAD UnloadHandler;
    OUT PVOID DirectorHandle;
    OUT PNAT_DIRECTOR_QUERY_INFO_SESSION QueryInfoSession;
    OUT PNAT_DIRECTOR_DEREGISTER Deregister;
    OUT PNAT_DIRECTOR_DISSOCIATE_SESSION DissociateSession;
} IP_NAT_REGISTER_DIRECTOR, *PIP_NAT_REGISTER_DIRECTOR;
*/
        ((PIP_NAT_REGISTER_DIRECTOR)abInBuffer)->Version = rand();
        ((PIP_NAT_REGISTER_DIRECTOR)abInBuffer)->Flags = DWORD_RAND;
        ((PIP_NAT_REGISTER_DIRECTOR)abInBuffer)->Protocol = GetRandProtocol();
        ((PIP_NAT_REGISTER_DIRECTOR)abInBuffer)->Port = rand();
        ((PIP_NAT_REGISTER_DIRECTOR)abInBuffer)->DirectorContext = GetDirectorHandle();
        ((PIP_NAT_REGISTER_DIRECTOR)abInBuffer)->QueryHandler = (PNAT_DIRECTOR_QUERY_SESSION)DWORD_RAND;//BUGBUG? will it AV?;
        ((PIP_NAT_REGISTER_DIRECTOR)abInBuffer)->CreateHandler = (PNAT_DIRECTOR_CREATE_SESSION)DWORD_RAND;//BUGBUG? will it AV?;
        ((PIP_NAT_REGISTER_DIRECTOR)abInBuffer)->DeleteHandler = (PNAT_DIRECTOR_DELETE_SESSION)DWORD_RAND;//BUGBUG? will it AV?;
        ((PIP_NAT_REGISTER_DIRECTOR)abInBuffer)->UnloadHandler = (PNAT_DIRECTOR_UNLOAD)DWORD_RAND;//BUGBUG? will it AV?;

        SetInParam(dwInBuff, sizeof(IP_NAT_REGISTER_DIRECTOR));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(IP_NAT_REGISTER_DIRECTOR));

        break;

    case IOCTL_IP_NAT_CREATE_REDIRECT:
// InputBuffer: 'IP_NAT_REDIRECT'
// OutputBuffer: 'IP_NAT_REDIRECT_STATISTICS'
/*
typedef struct _IP_NAT_REDIRECT {
    UCHAR Protocol;
    ULONG SourceAddress;
    USHORT SourcePort;
    ULONG DestinationAddress;
    USHORT DestinationPort;
    ULONG NewSourceAddress;
    USHORT NewSourcePort;
    ULONG NewDestinationAddress;
    USHORT NewDestinationPort;
} IP_NAT_REDIRECT, *PIP_NAT_REDIRECT;
*/
        ((PIP_NAT_REDIRECT)abInBuffer)->Protocol = GetRandProtocol();
        ((PIP_NAT_REDIRECT)abInBuffer)->SourceAddress = DWORD_RAND;
        ((PIP_NAT_REDIRECT)abInBuffer)->SourcePort = rand();
        ((PIP_NAT_REDIRECT)abInBuffer)->DestinationAddress = DWORD_RAND;
        ((PIP_NAT_REDIRECT)abInBuffer)->DestinationPort = rand();
        ((PIP_NAT_REDIRECT)abInBuffer)->NewSourceAddress = DWORD_RAND;
        ((PIP_NAT_REDIRECT)abInBuffer)->NewSourcePort = rand();
        ((PIP_NAT_REDIRECT)abInBuffer)->NewDestinationAddress = DWORD_RAND;
        ((PIP_NAT_REDIRECT)abInBuffer)->NewDestinationPort = rand();

        SetInParam(dwInBuff, sizeof(IP_NAT_REDIRECT));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(IP_NAT_REDIRECT_STATISTICS));

        break;

    case IOCTL_IP_NAT_CANCEL_REDIRECT://IOCTL_IP_NAT_CANCEL_REDIRECT
// InputBuffer: 'IP_NAT_REDIRECT'
// OutputBuffer:
//  cancel: Unused
//  statistics: 'IP_NAT_REDIRECT_STATISTICS'
//  source mapping: 'IP_NAT_REDIRECT_SOURCE_MAPPING'
/*
typedef struct _IP_NAT_REDIRECT {
    UCHAR Protocol;
    ULONG SourceAddress;
    USHORT SourcePort;
    ULONG DestinationAddress;
    USHORT DestinationPort;
    ULONG NewSourceAddress;
    USHORT NewSourcePort;
    ULONG NewDestinationAddress;
    USHORT NewDestinationPort;
} IP_NAT_REDIRECT, *PIP_NAT_REDIRECT;
*/
        ((PIP_NAT_REDIRECT)abInBuffer)->Protocol = GetRandProtocol();
        ((PIP_NAT_REDIRECT)abInBuffer)->SourceAddress = DWORD_RAND;
        ((PIP_NAT_REDIRECT)abInBuffer)->SourcePort = rand();
        ((PIP_NAT_REDIRECT)abInBuffer)->DestinationAddress = DWORD_RAND;
        ((PIP_NAT_REDIRECT)abInBuffer)->DestinationPort = rand();
        ((PIP_NAT_REDIRECT)abInBuffer)->NewSourceAddress = DWORD_RAND;
        ((PIP_NAT_REDIRECT)abInBuffer)->NewSourcePort = rand();
        ((PIP_NAT_REDIRECT)abInBuffer)->NewDestinationAddress = DWORD_RAND;
        ((PIP_NAT_REDIRECT)abInBuffer)->NewDestinationPort = rand();

        SetInParam(dwInBuff, sizeof(IP_NAT_REDIRECT));

        SetOutParam(abOutBuffer, dwOutBuff, 0/*sizeof(IP_NAT_REDIRECT_STATISTICS)*/);

        break;

    case IOCTL_IP_NAT_GET_INTERFACE_MAPPING_TABLE://IOCTL_IP_NAT_GET_INTERFACE_MAPPING_TABLE
// InputBuffer: 'IP_NAT_ENUMERATE_SESSION_MAPPINGS' with input parameters set
// OutputBuffer: 'IP_NAT_ENUMERATE_SESSION_MAPPINGS' with output parameters
/*
typedef struct _IP_NAT_ENUMERATE_SESSION_MAPPINGS {
    IN ULONG Index;
    IN OUT ULONG EnumerateContext[4];
    OUT ULONG EnumerateCount;
    OUT ULONG EnumerateTotalHint;
    OUT IP_NAT_SESSION_MAPPING EnumerateTable[1];
} IP_NAT_ENUMERATE_SESSION_MAPPINGS, *PIP_NAT_ENUMERATE_SESSION_MAPPINGS;
*/
        ((PIP_NAT_ENUMERATE_SESSION_MAPPINGS)abInBuffer)->Index = GetInterfaceIndex();
        ((PIP_NAT_ENUMERATE_SESSION_MAPPINGS)abInBuffer)->EnumerateContext[0] = DWORD_RAND;
        ((PIP_NAT_ENUMERATE_SESSION_MAPPINGS)abInBuffer)->EnumerateContext[1] = DWORD_RAND;
        ((PIP_NAT_ENUMERATE_SESSION_MAPPINGS)abInBuffer)->EnumerateContext[2] = DWORD_RAND;
        ((PIP_NAT_ENUMERATE_SESSION_MAPPINGS)abInBuffer)->EnumerateContext[3] = DWORD_RAND;

        SetInParam(dwInBuff, sizeof(IP_NAT_ENUMERATE_SESSION_MAPPINGS));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(IP_NAT_ENUMERATE_SESSION_MAPPINGS));

        break;

    case IOCTL_IP_NAT_GET_REDIRECT_STATISTICS://IOCTL_IP_NAT_GET_REDIRECT_STATISTICS
// InputBuffer: 'IP_NAT_REDIRECT'
// OutputBuffer:
//  cancel: Unused
//  statistics: 'IP_NAT_REDIRECT_STATISTICS'
//  source mapping: 'IP_NAT_REDIRECT_SOURCE_MAPPING'
        ((PIP_NAT_REDIRECT)abInBuffer)->Protocol = GetRandProtocol();
        ((PIP_NAT_REDIRECT)abInBuffer)->SourceAddress = DWORD_RAND;
        ((PIP_NAT_REDIRECT)abInBuffer)->SourcePort = rand();
        ((PIP_NAT_REDIRECT)abInBuffer)->DestinationAddress = DWORD_RAND;
        ((PIP_NAT_REDIRECT)abInBuffer)->DestinationPort = rand();
        ((PIP_NAT_REDIRECT)abInBuffer)->NewSourceAddress = DWORD_RAND;
        ((PIP_NAT_REDIRECT)abInBuffer)->NewSourcePort = rand();
        ((PIP_NAT_REDIRECT)abInBuffer)->NewDestinationAddress = DWORD_RAND;
        ((PIP_NAT_REDIRECT)abInBuffer)->NewDestinationPort = rand();

        SetInParam(dwInBuff, sizeof(IP_NAT_REDIRECT));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(IP_NAT_REDIRECT_STATISTICS));


        break;

    case IOCTL_IP_NAT_CREATE_DYNAMIC_TICKET:
        {
// InputBuffer: 'IP_NAT_CREATE_DYNAMIC_TICKET' describes the ticket
// OutputBuffer: none.
/*
typedef struct _IP_NAT_CREATE_DYNAMIC_TICKET {
    UCHAR Protocol;
    USHORT Port;
    ULONG ResponseCount;
    struct {
        UCHAR Protocol;
        USHORT StartPort;
        USHORT EndPort;
    } ResponseArray[0];
} IP_NAT_CREATE_DYNAMIC_TICKET, *PIP_NAT_CREATE_DYNAMIC_TICKET;
*/
        ((PIP_NAT_CREATE_DYNAMIC_TICKET)abInBuffer)->Protocol = GetRandProtocol();
        ((PIP_NAT_CREATE_DYNAMIC_TICKET)abInBuffer)->Port = rand();
        ((PIP_NAT_CREATE_DYNAMIC_TICKET)abInBuffer)->ResponseCount = rand()%100;
        for (DWORD i = 0; i < ((PIP_NAT_CREATE_DYNAMIC_TICKET)abInBuffer)->ResponseCount; i++)
        {
            ((PIP_NAT_CREATE_DYNAMIC_TICKET)abInBuffer)->ResponseArray[i].Protocol = rand();
            ((PIP_NAT_CREATE_DYNAMIC_TICKET)abInBuffer)->ResponseArray[i].StartPort = rand();
            ((PIP_NAT_CREATE_DYNAMIC_TICKET)abInBuffer)->ResponseArray[i].EndPort = rand();
        }

        SetInParam(dwInBuff, sizeof(IP_NAT_CREATE_DYNAMIC_TICKET)+6*((PIP_NAT_CREATE_DYNAMIC_TICKET)abInBuffer)->ResponseCount);
        if (rand()%5 == 0)
        {
            ((PIP_NAT_CREATE_DYNAMIC_TICKET)abInBuffer)->ResponseCount += 5; //liar!
        }

        SetOutParam(abOutBuffer, dwOutBuff, 0);

        break;
        }
    case IOCTL_IP_NAT_DELETE_DYNAMIC_TICKET:
// InputBuffer: 'IP_NAT_DELETE_DYNAMIC_TICKET' describes the ticket.
// OutputBuffer: none.
/*
typedef struct _IP_NAT_DELETE_DYNAMIC_TICKET {
    UCHAR Protocol;
    USHORT Port;
} IP_NAT_DELETE_DYNAMIC_TICKET, *PIP_NAT_DELETE_DYNAMIC_TICKET;
*/
        ((PIP_NAT_DELETE_DYNAMIC_TICKET)abInBuffer)->Protocol = GetRandProtocol();
        ((PIP_NAT_DELETE_DYNAMIC_TICKET)abInBuffer)->Port = rand();
        SetInParam(dwInBuff, sizeof(IP_NAT_DELETE_DYNAMIC_TICKET));
        SetOutParam(abOutBuffer, dwOutBuff, 0);

        break;

    case IOCTL_IP_NAT_GET_REDIRECT_SOURCE_MAPPING://IOCTL_IP_NAT_GET_REDIRECT_SOURCE_MAPPING
// InputBuffer: 'IP_NAT_REDIRECT'
// OutputBuffer:
//  cancel: Unused
//  statistics: 'IP_NAT_REDIRECT_STATISTICS'
//  source mapping: 'IP_NAT_REDIRECT_SOURCE_MAPPING'
        ((PIP_NAT_REDIRECT)abInBuffer)->Protocol = GetRandProtocol();
        ((PIP_NAT_REDIRECT)abInBuffer)->SourceAddress = DWORD_RAND;
        ((PIP_NAT_REDIRECT)abInBuffer)->SourcePort = rand();
        ((PIP_NAT_REDIRECT)abInBuffer)->DestinationAddress = DWORD_RAND;
        ((PIP_NAT_REDIRECT)abInBuffer)->DestinationPort = rand();
        ((PIP_NAT_REDIRECT)abInBuffer)->NewSourceAddress = DWORD_RAND;
        ((PIP_NAT_REDIRECT)abInBuffer)->NewSourcePort = rand();
        ((PIP_NAT_REDIRECT)abInBuffer)->NewDestinationAddress = DWORD_RAND;
        ((PIP_NAT_REDIRECT)abInBuffer)->NewDestinationPort = rand();

        SetInParam(dwInBuff, sizeof(IP_NAT_REDIRECT));
        SetOutParam(abOutBuffer, dwOutBuff, sizeof(IP_NAT_REDIRECT_SOURCE_MAPPING));

        break;

    default:
        DPF((TEXT("PrepareIOCTLParams(%s) got IOCTL , IOCTL=0x%08X\n"), m_pDevice->GetDeviceName(), dwIOCTL));
        _ASSERTE(FALSE);
    }

}



void CIoctlMspnat::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    switch(dwIOCTL)
    {
    case IOCTL_IP_NAT_GET_INTERFACE_INFO:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);

/*
typedef struct _IP_NAT_INTERFACE_INFO {
    ULONG Index;
    ULONG Flags;
    RTR_INFO_BLOCK_HEADER Header;
} IP_NAT_INTERFACE_INFO, *PIP_NAT_INTERFACE_INFO;
*/
        SetInterfaceIndex(((PIP_NAT_INTERFACE_INFO)abOutBuffer)->Index);
        SetInterfaceFlags(((PIP_NAT_INTERFACE_INFO)abOutBuffer)->Flags);
/*
typedef struct _RTR_INFO_BLOCK_HEADER
{
    ULONG			Version;	    // Version of the structure
    ULONG			Size;		    // size of the whole block, including version
    ULONG			TocEntriesCount;// Number of entries
    RTR_TOC_ENTRY   TocEntry[1];    // Table of content followed by the actual
                                    // information blocks
} RTR_INFO_BLOCK_HEADER, *PRTR_INFO_BLOCK_HEADER;
*/
        SetInterfaceRtrTocEntry(&((PIP_NAT_INTERFACE_INFO)abOutBuffer)->Header);

        break;

    case IOCTL_IP_NAT_REGISTER_EDITOR:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);

/*
    OUT PVOID EditorHandle;
    OUT PNAT_EDITOR_CREATE_TICKET CreateTicket;
    OUT PNAT_EDITOR_DELETE_TICKET DeleteTicket;
    OUT PNAT_EDITOR_DEREGISTER Deregister;
    OUT PNAT_EDITOR_DISSOCIATE_SESSION DissociateSession;
    OUT PNAT_EDITOR_EDIT_SESSION EditSession;
    OUT PNAT_EDITOR_QUERY_INFO_SESSION QueryInfoSession;
    OUT PNAT_EDITOR_TIMEOUT_SESSION TimeoutSession;
*/
        SetEditorHandle(((PIP_NAT_REGISTER_EDITOR)abOutBuffer)->EditorHandle);

        break;

    case IOCTL_IP_NAT_GET_MAPPING_TABLE:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);

/*
typedef struct _IP_NAT_ENUMERATE_SESSION_MAPPINGS {
    IN ULONG Index;
    IN OUT ULONG EnumerateContext[4];
    OUT ULONG EnumerateCount;
    OUT ULONG EnumerateTotalHint;
    OUT IP_NAT_SESSION_MAPPING EnumerateTable[1];
} IP_NAT_ENUMERATE_SESSION_MAPPINGS, *PIP_NAT_ENUMERATE_SESSION_MAPPINGS;
*/

        break;

    case IOCTL_IP_NAT_REGISTER_DIRECTOR:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);

/*
typedef struct _IP_NAT_REGISTER_DIRECTOR {
    IN ULONG Version;
    IN ULONG Flags;
    IN UCHAR Protocol;
    IN USHORT Port;
    IN PVOID DirectorContext;
    IN PNAT_DIRECTOR_QUERY_SESSION QueryHandler;
    IN PNAT_DIRECTOR_CREATE_SESSION CreateHandler;
    IN PNAT_DIRECTOR_DELETE_SESSION DeleteHandler;
    IN PNAT_DIRECTOR_UNLOAD UnloadHandler;
    OUT PVOID DirectorHandle;
    OUT PNAT_DIRECTOR_QUERY_INFO_SESSION QueryInfoSession;
    OUT PNAT_DIRECTOR_DEREGISTER Deregister;
    OUT PNAT_DIRECTOR_DISSOCIATE_SESSION DissociateSession;
} IP_NAT_REGISTER_DIRECTOR, *PIP_NAT_REGISTER_DIRECTOR;
*/
        SetDirectorHandle(((PIP_NAT_REGISTER_DIRECTOR)abOutBuffer)->DirectorHandle);

        break;
    }
}


BOOL CIoctlMspnat::FindValidIOCTLs(CDevice *pDevice)
{
    BOOL bRet = TRUE;

    DPF((TEXT("FindValidIOCTLs() %s is known, will use known IOCTLs\n"), pDevice->GetDeviceName()));

    AddIOCTL(pDevice, IOCTL_IP_NAT_SET_GLOBAL_INFO);
    AddIOCTL(pDevice, IOCTL_IP_NAT_REQUEST_NOTIFICATION);
    AddIOCTL(pDevice, IOCTL_IP_NAT_CREATE_INTERFACE);
    AddIOCTL(pDevice, IOCTL_IP_NAT_DELETE_INTERFACE);
    AddIOCTL(pDevice, IOCTL_IP_NAT_SET_INTERFACE_INFO);
    AddIOCTL(pDevice, IOCTL_IP_NAT_GET_INTERFACE_INFO);
    AddIOCTL(pDevice, IOCTL_IP_NAT_REGISTER_EDITOR);
    AddIOCTL(pDevice, IOCTL_IP_NAT_GET_INTERFACE_STATISTICS);
    AddIOCTL(pDevice, IOCTL_IP_NAT_GET_MAPPING_TABLE);
    AddIOCTL(pDevice, IOCTL_IP_NAT_REGISTER_DIRECTOR);
    AddIOCTL(pDevice, IOCTL_IP_NAT_CREATE_REDIRECT);
    AddIOCTL(pDevice, IOCTL_IP_NAT_CANCEL_REDIRECT);
    AddIOCTL(pDevice, IOCTL_IP_NAT_GET_INTERFACE_MAPPING_TABLE);
    AddIOCTL(pDevice, IOCTL_IP_NAT_GET_REDIRECT_STATISTICS);
    AddIOCTL(pDevice, IOCTL_IP_NAT_CREATE_DYNAMIC_TICKET);
    AddIOCTL(pDevice, IOCTL_IP_NAT_DELETE_DYNAMIC_TICKET);
    AddIOCTL(pDevice, IOCTL_IP_NAT_GET_REDIRECT_SOURCE_MAPPING);

    return TRUE;
}



void CIoctlMspnat::SetInterfaceIndex(ULONG Index)
{
    m_aulInterfaceIndexes[rand()%MAX_NUM_OF_REMEMBERED_IF_INDEXES] = Index;
}

void CIoctlMspnat::SetInterfaceFlags(ULONG Flags)
{
    m_aulInterfaceFlags[rand()%MAX_NUM_OF_REMEMBERED_IF_FLAGS] = Flags;
}

void CIoctlMspnat::SetInterfaceRtrTocEntry(PRTR_INFO_BLOCK_HEADER TocEntry)
{
    m_ateInterfaceRtrTocEntries[rand()%MAX_NUM_OF_REMEMBERED_IF_RTR_TOC_ENTRIES] = *TocEntry;
}

ULONG CIoctlMspnat::GetInterfaceIndex()
{
    return m_aulInterfaceIndexes[rand()%MAX_NUM_OF_REMEMBERED_IF_INDEXES];
}

ULONG CIoctlMspnat::GetInterfaceFlags()
{
    return m_aulInterfaceFlags[rand()%MAX_NUM_OF_REMEMBERED_IF_FLAGS];
}

PRTR_INFO_BLOCK_HEADER CIoctlMspnat::GetInterfaceRtrTocEntry()
{
    return &m_ateInterfaceRtrTocEntries[rand()%MAX_NUM_OF_REMEMBERED_IF_RTR_TOC_ENTRIES];
}

void CIoctlMspnat::SetEditorHandle(PVOID EditorHandle)
{
    m_apvEditorHandles[rand()%MAX_NUM_OF_REMEMBERED_EDITOR_HANDLES] = EditorHandle;
}

PVOID CIoctlMspnat::GetEditorHandle()
{
	if (0 == rand()%10) return CIoctl::GetRandomIllegalPointer();
    return m_apvEditorHandles[rand()%MAX_NUM_OF_REMEMBERED_EDITOR_HANDLES];
}

void CIoctlMspnat::SetDirectorHandle(PVOID DirectorHandle)
{
    m_apvDirectorHandles[rand()%MAX_NUM_OF_REMEMBERED_DIRECTOR_HANDLES] = DirectorHandle;
}

PVOID CIoctlMspnat::GetDirectorHandle()
{
	if (0 == rand()%10) return CIoctl::GetRandomIllegalPointer();
    return m_apvDirectorHandles[rand()%MAX_NUM_OF_REMEMBERED_DIRECTOR_HANDLES];
}


void CIoctlMspnat::CallRandomWin32API(LPOVERLAPPED pOL)
{
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\mqacioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*



#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
*/
#include "MqAcIOCTL.h"

#include "AcIOCTL.h"

static bool s_fVerbose = false;

void CIoctlMqAc::UseOutBuff(
    DWORD dwIOCTL, 
    BYTE *abOutBuffer, 
    DWORD dwOutBuff,
    OVERLAPPED *pOL
    )
{
    ;
}

/*
struct CACTransferBuffer {

public:
    CACTransferBuffer(TRANSFER_TYPE tt);

    ULONG uTransferType;

    union {

        struct {
            //
            //  MQSendMessage parameters
            //
            struct QUEUE_FORMAT* pAdminQueueFormat;
            struct QUEUE_FORMAT* pResponseQueueFormat;
        } Send;

        struct {
            //
            //  MQReceiveMessage parameters
            //

            ULONG RequestTimeout;
            ULONG Action;
            ULONG Asynchronous;
            HANDLE Cursor;

            //
            // Important note:
            // In the following xxxFormatName properties, the value
            // "ulxxxFormatNameLen" is the size of the buffer on input.
            // This value MUST NOT be changed by the driver or QM. This
            // value tell the RPC run-time how many bytes to transfer
            // across process/machine boundaries.
            // The value "pulxxxFormatNameLenProp" is the property passed
            // by caller. This value IS changed and returned to caller to
            // indicate the length of the string.
            //
            ULONG   ulResponseFormatNameLen ;
            WCHAR** ppResponseFormatName;
            ULONG*  pulResponseFormatNameLenProp;

            ULONG   ulAdminFormatNameLen ;
            WCHAR** ppAdminFormatName;
            ULONG*  pulAdminFormatNameLenProp;

            ULONG   ulDestFormatNameLen;
            WCHAR** ppDestFormatName;
            ULONG*  pulDestFormatNameLenProp;

            ULONG   ulOrderingFormatNameLen;
            WCHAR** ppOrderingFormatName;
            ULONG*  pulOrderingFormatNameLenProp;
        } Receive;

        struct {
            //
            //  MQCreateCursor parameters
            //
            HANDLE hCursor;
            ULONG srv_hACQueue;
            ULONG cli_pQMQueue;
        } CreateCursor;
    };

    //
    //  Message properties pointers
    //
    USHORT* pClass;
    OBJECTID** ppMessageID;

    UCHAR** ppCorrelationID;

    ULONG* pSentTime;
    ULONG* pArrivedTime;
    UCHAR* pPriority;
    UCHAR* pDelivery;
    UCHAR* pAcknowledge;
    UCHAR* pAuditing;
    ULONG* pApplicationTag;

    UCHAR** ppBody;
    ULONG ulBodyBufferSizeInBytes;
    ULONG ulAllocBodyBufferInBytes;
    ULONG* pBodySize;

    WCHAR** ppTitle;
    ULONG   ulTitleBufferSizeInWCHARs;
    ULONG*  pulTitleBufferSizeInWCHARs;

    ULONG ulAbsoluteTimeToQueue;
    ULONG* pulRelativeTimeToQueue;

    ULONG ulRelativeTimeToLive;
    ULONG* pulRelativeTimeToLive;

    UCHAR* pTrace;
    ULONG* pulSenderIDType;

    UCHAR** ppSenderID;
    ULONG* pulSenderIDLenProp;

    ULONG* pulPrivLevel;
    ULONG  ulAuthLevel;
    UCHAR* pAuthenticated;
    ULONG* pulHashAlg;
    ULONG* pulEncryptAlg;

    UCHAR** ppSenderCert;
    ULONG ulSenderCertLen;
    ULONG* pulSenderCertLenProp;

    WCHAR** ppwcsProvName;
    ULONG   ulProvNameLen;
    ULONG*  pulProvNameLenProp;

    ULONG*  pulProvType;
    BOOL    fDefaultProvider;

    UCHAR** ppSymmKeys;
    ULONG   ulSymmKeysSize;
    ULONG*  pulSymmKeysSizeProp;

    UCHAR bEncrypted;
    UCHAR bAuthenticated;
    USHORT uSenderIDLen;

    UCHAR** ppSignature;
    ULONG   ulSignatureSize;
    ULONG*  pulSignatureSizeProp;

    GUID** ppSrcQMID;

    XACTUOW* pUow;

    UCHAR** ppMsgExtension;
    ULONG ulMsgExtensionBufferInBytes;
    ULONG* pMsgExtensionSize;
    GUID** ppConnectorType;
    ULONG* pulBodyType;
    ULONG* pulVersion;
};
*/
void CIoctlMqAc::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
	switch(dwIOCTL)
	{
//---------------------------------------------------------
//
//  RT INTERFACE TO AC DRIVER
//
//---------------------------------------------------------

//
//  Message apis
//
	case IOCTL_AC_SEND_MESSAGE:
/*
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_SEND_MESSAGE,
                0,
                TRUE,
                &CACTransferBuffer,
                sizeof(CACTransferBuffer),
                lpOverlapped
                );
*/
		break;

	case IOCTL_AC_RECEIVE_MESSAGE:

		break;

//
//  Queue apis
//
	case IOCTL_AC_HANDLE_TO_FORMAT_NAME:

		break;

	case IOCTL_AC_PURGE_QUEUE:

		break;

//
//  Cursor apis
//
	case IOCTL_AC_CREATE_CURSOR:

		break;

	case IOCTL_AC_CLOSE_CURSOR:

		break;

	case IOCTL_AC_SET_CURSOR_PROPS:

		break;

//---------------------------------------------------------
//
//  QM INTERFACE TO AC DRIVER
//
//---------------------------------------------------------

//
//  QM Control apis
//

//---------------------------------------------------------
//
//  NOTE: CONNECT must be first QM ioctl
//
	case IOCTL_AC_CONNECT:

		break;

	case IOCTL_AC_SET_PERFORMANCE_BUFF:

		break;

	case IOCTL_AC_SET_MACHINE_PROPS:

		break;

	case IOCTL_AC_GET_SERVICE_REQUEST:

		break;

	case IOCTL_AC_STORE_COMPLETED:

		break;

	case IOCTL_AC_ACKING_COMPLETED:

		break;

	case IOCTL_AC_CAN_CLOSE_QUEUE:

		break;

	case IOCTL_AC_SET_QUEUE_PROPS:

		break;

	case IOCTL_AC_ASSOCIATE_QUEUE:

		break;

	case IOCTL_AC_ASSOCIATE_JOURNAL:

		break;

	case IOCTL_AC_ASSOCIATE_DEADXACT:

		break;

	case IOCTL_AC_PUT_RESTORED_PACKET:

		break;

	case IOCTL_AC_GET_RESTORED_PACKET:

		break;

	case IOCTL_AC_RESTORE_PACKETS:

		break;

	case IOCTL_AC_CREATE_QUEUE:

		break;

	case IOCTL_AC_CREATE_GROUP:

		break;

	case IOCTL_AC_SEND_VERIFIED_MESSAGE:

		break;

	case IOCTL_AC_RELEASE_RESOURCES:

		break;

	case IOCTL_AC_GET_QUEUE_PROPS:

		break;

	case IOCTL_AC_CONVERT_PACKET:

		break;

//
//  QM Network interface apis
//
	case IOCTL_AC_ALLOCATE_PACKET:

		break;

	case IOCTL_AC_FREE_PACKET:

		break;

	case IOCTL_AC_PUT_PACKET:

		break;

	case IOCTL_AC_GET_PACKET:

		break;

	case IOCTL_AC_MOVE_QUEUE_TO_GROUP:

		break;

//
//  QM remote read apis
//
	case IOCTL_AC_CREATE_REMOTE_PROXY:

		break;

	case IOCTL_AC_BEGIN_GET_PACKET_2REMOTE:

		break;

	case IOCTL_AC_END_GET_PACKET_2REMOTE:

		break;

	case IOCTL_AC_CANCEL_REQUEST:

		break;

	case IOCTL_AC_PUT_REMOTE_PACKET:

		break;

//
//  QM transactions apis
//
	case IOCTL_AC_CREATE_TRANSACTION:

		break;

	case IOCTL_AC_XACT_COMMIT1:

		break;

	case IOCTL_AC_XACT_COMMIT2:

		break;

	case IOCTL_AC_XACT_ABORT1:

		break;

	case IOCTL_AC_XACT_PREPARE:

		break;

	case IOCTL_AC_XACT_PREPARE_DEFAULT_COMMIT:

		break;

	case IOCTL_AC_PUT_PACKET1:

		break;

	case IOCTL_AC_XACT_SET_CLASS:

		break;

	case IOCTL_AC_XACT_GET_INFORMATION:

		break;

	case IOCTL_AC_FREE_PACKET1:

		break;

	case IOCTL_AC_ARM_PACKET_TIMER:

		break;

	case IOCTL_AC_XACT_COMMIT3:

		break;

	case IOCTL_AC_XACT_ABORT2:

		break;

//
//  Control panel apis
//
	case IOCTL_AC_FREE_HEAPS:

		break;

	}
}


BOOL CIoctlMqAc::FindValidIOCTLs(CDevice *pDevice)
{
    AddIOCTL(pDevice, IOCTL_AC_SEND_MESSAGE);
    AddIOCTL(pDevice, IOCTL_AC_RECEIVE_MESSAGE);
    AddIOCTL(pDevice, IOCTL_AC_HANDLE_TO_FORMAT_NAME);
    AddIOCTL(pDevice, IOCTL_AC_PURGE_QUEUE);
    AddIOCTL(pDevice, IOCTL_AC_CREATE_CURSOR);
    AddIOCTL(pDevice, IOCTL_AC_CLOSE_CURSOR);
    AddIOCTL(pDevice, IOCTL_AC_SET_CURSOR_PROPS);
    AddIOCTL(pDevice, IOCTL_AC_CONNECT);
    AddIOCTL(pDevice, IOCTL_AC_SET_PERFORMANCE_BUFF);
    AddIOCTL(pDevice, IOCTL_AC_SET_MACHINE_PROPS);
    AddIOCTL(pDevice, IOCTL_AC_GET_SERVICE_REQUEST);
    AddIOCTL(pDevice, IOCTL_AC_STORE_COMPLETED);
    AddIOCTL(pDevice, IOCTL_AC_ACKING_COMPLETED);
    AddIOCTL(pDevice, IOCTL_AC_CAN_CLOSE_QUEUE);
    AddIOCTL(pDevice, IOCTL_AC_SET_QUEUE_PROPS);
    AddIOCTL(pDevice, IOCTL_AC_ASSOCIATE_QUEUE);
    AddIOCTL(pDevice, IOCTL_AC_ASSOCIATE_JOURNAL);
    AddIOCTL(pDevice, IOCTL_AC_ASSOCIATE_DEADXACT);
    AddIOCTL(pDevice, IOCTL_AC_PUT_RESTORED_PACKET);
    AddIOCTL(pDevice, IOCTL_AC_GET_RESTORED_PACKET);
    AddIOCTL(pDevice, IOCTL_AC_RESTORE_PACKETS);
    AddIOCTL(pDevice, IOCTL_AC_CREATE_QUEUE);
    AddIOCTL(pDevice, IOCTL_AC_CREATE_GROUP);
    AddIOCTL(pDevice, IOCTL_AC_SEND_VERIFIED_MESSAGE);
    AddIOCTL(pDevice, IOCTL_AC_RELEASE_RESOURCES);
    AddIOCTL(pDevice, IOCTL_AC_GET_QUEUE_PROPS);
    AddIOCTL(pDevice, IOCTL_AC_CONVERT_PACKET);
    AddIOCTL(pDevice, IOCTL_AC_ALLOCATE_PACKET);
    AddIOCTL(pDevice, IOCTL_AC_FREE_PACKET);
    AddIOCTL(pDevice, IOCTL_AC_PUT_PACKET);
    AddIOCTL(pDevice, IOCTL_AC_GET_PACKET);
    AddIOCTL(pDevice, IOCTL_AC_MOVE_QUEUE_TO_GROUP);
    AddIOCTL(pDevice, IOCTL_AC_CREATE_REMOTE_PROXY);
    AddIOCTL(pDevice, IOCTL_AC_BEGIN_GET_PACKET_2REMOTE);
    AddIOCTL(pDevice, IOCTL_AC_END_GET_PACKET_2REMOTE);
    AddIOCTL(pDevice, IOCTL_AC_CANCEL_REQUEST);
    AddIOCTL(pDevice, IOCTL_AC_PUT_REMOTE_PACKET);
    AddIOCTL(pDevice, IOCTL_AC_CREATE_TRANSACTION);
    AddIOCTL(pDevice, IOCTL_AC_XACT_COMMIT1);
    AddIOCTL(pDevice, IOCTL_AC_XACT_COMMIT2);
    AddIOCTL(pDevice, IOCTL_AC_XACT_ABORT1);
    AddIOCTL(pDevice, IOCTL_AC_XACT_PREPARE);
    AddIOCTL(pDevice, IOCTL_AC_XACT_PREPARE_DEFAULT_COMMIT);
    AddIOCTL(pDevice, IOCTL_AC_PUT_PACKET1);
    AddIOCTL(pDevice, IOCTL_AC_XACT_SET_CLASS);
    AddIOCTL(pDevice, IOCTL_AC_XACT_GET_INFORMATION);
    AddIOCTL(pDevice, IOCTL_AC_FREE_PACKET1);
    AddIOCTL(pDevice, IOCTL_AC_ARM_PACKET_TIMER);
    AddIOCTL(pDevice, IOCTL_AC_XACT_COMMIT3);
    AddIOCTL(pDevice, IOCTL_AC_XACT_ABORT2);
    AddIOCTL(pDevice, IOCTL_AC_FREE_HEAPS);

    return TRUE;
}



void CIoctlMqAc::CallRandomWin32API(LPOVERLAPPED pOL)
{
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\mspnatioctl.h ===
#ifndef __MSPNAT_IOCTL_H
#define __MSPNAT_IOCTL_H

//#include "IOCTL.h"

#include "ipnat.h"

#define MAX_NUM_OF_REMEMBERED_IF_INDEXES (10)
#define MAX_NUM_OF_REMEMBERED_IF_FLAGS (10)
#define MAX_NUM_OF_REMEMBERED_IF_RTR_TOC_ENTRIES (10)
#define MAX_NUM_OF_REMEMBERED_EDITOR_HANDLES (10)
#define MAX_NUM_OF_REMEMBERED_DIRECTOR_HANDLES (10)

class CIoctlMspnat : public CIoctl
{
public:
    CIoctlMspnat(CDevice *pDevice): CIoctl(pDevice) {;};
    virtual ~CIoctlMspnat(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

private:
    void SetInterfaceIndex(ULONG Index);

    void SetInterfaceFlags(ULONG Flags);

    void SetInterfaceRtrTocEntry(PRTR_INFO_BLOCK_HEADER TocEntry);

    ULONG GetInterfaceIndex();

    ULONG GetInterfaceFlags();

    PRTR_INFO_BLOCK_HEADER GetInterfaceRtrTocEntry();

    void SetEditorHandle(PVOID);
    PVOID GetEditorHandle();

    void SetDirectorHandle(PVOID);
    PVOID GetDirectorHandle();

    ULONG m_aulInterfaceIndexes[MAX_NUM_OF_REMEMBERED_IF_INDEXES];
    ULONG m_aulInterfaceFlags[MAX_NUM_OF_REMEMBERED_IF_FLAGS];
    RTR_INFO_BLOCK_HEADER m_ateInterfaceRtrTocEntries[MAX_NUM_OF_REMEMBERED_IF_RTR_TOC_ENTRIES];
    PVOID m_apvEditorHandles[MAX_NUM_OF_REMEMBERED_EDITOR_HANDLES];
    PVOID m_apvDirectorHandles[MAX_NUM_OF_REMEMBERED_DIRECTOR_HANDLES];

};




#endif //__MSPNAT_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\myntdefs.cpp ===
#include <windows.h>
#include <crtdbg.h>
#include "MyNTDefs.h"

static HMODULE s_hNtDll = NULL;
NT_WAIT_FOR_SINGLE_OBJECT NtWaitForSingleObject = NULL;
NT_DEVICE_CONTROL_FILE NtDeviceIoControlFile = NULL;

static long s_fAlreadyInitialized = false;

#define NT_DEF_FATAL_ERROR \
	_ASSERTE(FALSE);\
	return false;

bool InitializeNtDefines()
{
	if (::InterlockedExchange(&s_fAlreadyInitialized, TRUE)) return false;

	s_hNtDll = ::LoadLibrary(TEXT("ntdll.dll"));
	if (NULL == s_hNtDll)
	{
		NT_DEF_FATAL_ERROR;
	}
	NtDeviceIoControlFile = (NT_DEVICE_CONTROL_FILE)::GetProcAddress(s_hNtDll, "NtDeviceIoControlFile");
	if (NULL == NtDeviceIoControlFile)
	{
		NT_DEF_FATAL_ERROR;
	}
	NtWaitForSingleObject = (NT_WAIT_FOR_SINGLE_OBJECT)::GetProcAddress(s_hNtDll, "NtWaitForSingleObject");
	if (NULL == NtWaitForSingleObject)
	{
		NT_DEF_FATAL_ERROR;
	}

	return true;
}

VOID
RtlInitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitUnicodeString function initializes an NT counted
    unicode string.  The DestinationString is initialized to point to
    the SourceString and the Length and MaximumLength fields of
    DestinationString are initialized to the length of the SourceString,
    which is zero if SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated unicode string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PWSTR)SourceString;
    if (SourceString) {
        Length = wcslen( SourceString ) * sizeof( WCHAR );
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));
        }
    else {
        DestinationString->MaximumLength = 0;
        DestinationString->Length = 0;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\ndproxyioctl.h ===
#ifndef __NDPROXY_IOCTL_H
#define __NDPROXY_IOCTL_H

//#include "IOCTL.h"


class CIoctlNdproxy : public CIoctl
{
public:
    CIoctlNdproxy(CDevice *pDevice): CIoctl(pDevice){;};
    virtual ~CIoctlNdproxy(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

};




#endif //__NDPROXY_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\ndisioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*



#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
*/
#include <ntddndis.h>

#include "NDISIOCTL.h"

static bool s_fVerbose = false;

void CIoctlNDIS::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    ;
}

void CIoctlNDIS::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
    CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
}


BOOL CIoctlNDIS::FindValidIOCTLs(CDevice *pDevice)
{
    BOOL bRet = TRUE;
    DPF((TEXT("FindValidIOCTLs() %s is known, will use known IOCTLs\n"), pDevice->GetDeviceName()));

    AddIOCTL(pDevice, IOCTL_NDIS_QUERY_GLOBAL_STATS);
    AddIOCTL(pDevice, IOCTL_NDIS_QUERY_ALL_STATS);
    AddIOCTL(pDevice, IOCTL_NDIS_DO_PNP_OPERATION);
    AddIOCTL(pDevice, IOCTL_NDIS_QUERY_SELECTED_STATS);
    AddIOCTL(pDevice, IOCTL_NDIS_ENUMERATE_INTERFACES);
    AddIOCTL(pDevice, IOCTL_NDIS_ADD_TDI_DEVICE);
    AddIOCTL(pDevice, IOCTL_NDIS_GET_DEVICE_BUNDLE);
    AddIOCTL(pDevice, IOCTL_NDIS_GET_LOG_DATA);

    return TRUE;
}


void CIoctlNDIS::CallRandomWin32API(LPOVERLAPPED pOL)
{
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\myntdefs.h ===
#ifndef __MY_NT_DEFINES
#define __MY_NT_DEFINES


typedef DWORD NTSTATUS;
#include <ntstatus.h>

bool InitializeNtDefines();

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;

#ifndef _NTIOAPI_
typedef struct _IO_STATUS_BLOCK {
    union {
        NTSTATUS Status;
        PVOID Pointer;
    };

    ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;
#endif

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }
#define OBJ_CASE_INSENSITIVE    0x00000040L

#define TIME LARGE_INTEGER
#include ".\srvfsctl.h"

VOID
RtlInitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    );




typedef enum _EVENT_TYPE {
    NotificationEvent,
    SynchronizationEvent
    } EVENT_TYPE;

typedef
VOID
(NTAPI *PIO_APC_ROUTINE) (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );


typedef NTSTATUS (WINAPI *NT_DEVICE_CONTROL_FILE)(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
	);

typedef NTSTATUS (WINAPI *NT_FS_CONTROL_FILE)(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
	);
typedef NTSTATUS (WINAPI *CREATE_EVENT)(
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
	);
typedef NTSTATUS (WINAPI *NT_CLOSE)(
    IN HANDLE Handle
	);
typedef NTSTATUS (WINAPI *NT_WAIT_FOR_SINGLE_OBJECT)(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
	);
typedef NTSTATUS (WINAPI *LOAD_DRIVER)(PUNICODE_STRING DriverServiceName);
typedef NTSTATUS (WINAPI *CLOSE_FILE)(HANDLE h);
typedef NTSTATUS (WINAPI *OPEN_FILE)(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);



extern NT_WAIT_FOR_SINGLE_OBJECT NtWaitForSingleObject;
extern 	NT_DEVICE_CONTROL_FILE NtDeviceIoControlFile;


#endif //__MY_NT_DEFINES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\ndisioctl.h ===
#ifndef __NDIS_IOCTL_H
#define __NDIS_IOCTL_H

//#include "IOCTL.h"


class CIoctlNDIS : public CIoctl
{
public:
    CIoctlNDIS(CDevice *pDevice): CIoctl(pDevice){;};
    virtual ~CIoctlNDIS(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

};




#endif //__NDIS_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\ntnativeioctl.h ===
#ifndef __NT_NATIVE_IOCTL_H
#define __NT_NATIVE_IOCTL_H

#include "IOCTL.h"


class CIoctlNtNative : public CIoctl
{
public:
    CIoctlNtNative(CDevice *pDevice): CIoctl(pDevice){;};
    virtual ~CIoctlNtNative(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        ) = 0;

    virtual BOOL FindValidIOCTLs(CDevice *pDevice) = 0;

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL) = 0;

	virtual void CallRandomWin32API(LPOVERLAPPED pOL) = 0;

	virtual HANDLE CreateDevice(CDevice *pDevice);
	static HANDLE StaticCreateDevice(CDevice *pDevice);
	static HANDLE StaticCreateDevice(WCHAR *wszDevice);
	static HANDLE StaticCreateDevice(char *szDevice);

	virtual BOOL CloseDevice(CDevice *pDevice);
	static BOOL StaticCloseDevice(CDevice *pDevice);

	virtual BOOL DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		);
	static BOOL StaticDeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		);

	virtual BOOL DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		);
	static BOOL StaticDeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		);

	virtual BOOL DeviceCancelIo(
		HANDLE hFile  // file handle for which to cancel I/O
		);
	static BOOL StaticDeviceCancelIo(
		HANDLE hFile  // file handle for which to cancel I/O
		);

	virtual BOOL DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		);
	static BOOL StaticDeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		);
	static BOOL StaticNtQueryInformationFile(
		IN HANDLE FileHandle,
		OUT PIO_STATUS_BLOCK IoStatusBlock,
		OUT PVOID FileInformation,
		IN ULONG Length,
		IN FILE_INFORMATION_CLASS FileInformationClass
		);
	static BOOL StaticNtSetInformationFile(
		IN HANDLE FileHandle,
		OUT PIO_STATUS_BLOCK IoStatusBlock,
		IN PVOID FileInformation,
		IN ULONG Length,
		IN FILE_INFORMATION_CLASS FileInformationClass
		);

	BOOL AlertThread(
		HANDLE hThread  // file handle for which to cancel I/O
		);
	static BOOL StaticNtAlertThread(
		HANDLE hThread  // file handle for which to cancel I/O
		);

	static BOOL StaticQueryVolumeInformationFile(
		IN HANDLE FileHandle,
		OUT PIO_STATUS_BLOCK IoStatusBlock,
		OUT PVOID FsInformation,
		IN ULONG Length,
		IN FS_INFORMATION_CLASS FsInformationClass
		);

	static int GetRandom_FsInformationClass();
	static int GetRandom_FileInformationClass();
	static BOOL StaticNtQueryDirectoryFile(
		IN HANDLE FileHandle,
		IN HANDLE Event OPTIONAL,
		IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
		IN PVOID ApcContext OPTIONAL,
		OUT PIO_STATUS_BLOCK IoStatusBlock,
		OUT PVOID FileInformation,
		IN ULONG Length,
		IN FILE_INFORMATION_CLASS FileInformationClass,
		IN BOOLEAN ReturnSingleEntry,
		IN PUNICODE_STRING FileName OPTIONAL,
		IN BOOLEAN RestartScan
		);

	static BOOL StaticNtNotifyChangeDirectoryFile(
		IN HANDLE FileHandle,
		IN HANDLE Event OPTIONAL,
		IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
		IN PVOID ApcContext OPTIONAL,
		OUT PIO_STATUS_BLOCK IoStatusBlock,
		OUT PVOID Buffer,
		IN ULONG Length,
		IN ULONG CompletionFilter,
		IN BOOLEAN WatchTree
		);

	static BOOL StaticNtQueryFullAttributesFile(
		IN POBJECT_ATTRIBUTES ObjectAttributes,
		OUT PFILE_NETWORK_OPEN_INFORMATION FileInformation
		);

};

#endif //__NT_NATIVE_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\ndproxyioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*



#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
*/

#include "NdproxyIOCTL.h"

static bool s_fVerbose = false;

//////////////////////////////////////////////////////
// from \\index2\ntsrc\private\ntos\ndis\proxy\proxy.h
//////////////////////////////////////////////////////

//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define FILE_DEVICE_NDISTAPI  0x00008fff



//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define NDISTAPI_IOCTL_INDEX  0x8f0


//
// The NDISTAPI device driver IOCTLs
//

#define IOCTL_NDISTAPI_CONNECT           CTL_CODE(FILE_DEVICE_NDISTAPI,     \
                                                  NDISTAPI_IOCTL_INDEX,     \
                                                  METHOD_BUFFERED,          \
                                                  FILE_ANY_ACCESS)

#define IOCTL_NDISTAPI_DISCONNECT        CTL_CODE(FILE_DEVICE_NDISTAPI,     \
                                                  NDISTAPI_IOCTL_INDEX + 1, \
                                                  METHOD_BUFFERED,          \
                                                  FILE_ANY_ACCESS)

#define IOCTL_NDISTAPI_QUERY_INFO        CTL_CODE(FILE_DEVICE_NDISTAPI,     \
                                                  NDISTAPI_IOCTL_INDEX + 2, \
                                                  METHOD_BUFFERED,          \
                                                  FILE_ANY_ACCESS)

#define IOCTL_NDISTAPI_SET_INFO          CTL_CODE(FILE_DEVICE_NDISTAPI,     \
                                                  NDISTAPI_IOCTL_INDEX + 3, \
                                                  METHOD_BUFFERED,          \
                                                  FILE_ANY_ACCESS)

#define IOCTL_NDISTAPI_GET_LINE_EVENTS      CTL_CODE(FILE_DEVICE_NDISTAPI,  \
                                                  NDISTAPI_IOCTL_INDEX + 4, \
                                                  METHOD_BUFFERED,          \
                                                  FILE_ANY_ACCESS)

#define IOCTL_NDISTAPI_SET_DEVICEID_BASE    CTL_CODE(FILE_DEVICE_NDISTAPI,  \
                                                  NDISTAPI_IOCTL_INDEX + 5, \
                                                  METHOD_BUFFERED,          \
                                                  FILE_ANY_ACCESS)

#define IOCTL_NDISTAPI_CREATE               CTL_CODE(FILE_DEVICE_NDISTAPI,  \
                                                  NDISTAPI_IOCTL_INDEX + 6, \
                                                  METHOD_BUFFERED,          \
                                                  FILE_ANY_ACCESS)

//////////////////////////////////////////////////////
// END OF \\index2\ntsrc\private\ntos\ndis\proxy\proxy.h
//////////////////////////////////////////////////////


void CIoctlNdproxy::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    ;
}

void CIoctlNdproxy::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
    CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
}


BOOL CIoctlNdproxy::FindValidIOCTLs(CDevice *pDevice)
{
    BOOL bRet = TRUE;
    DPF((TEXT("CIoctlNdproxy::FindValidIOCTLs() %s is known, will use known IOCTLs\n"), pDevice->GetDeviceName()));

    AddIOCTL(pDevice, IOCTL_NDISTAPI_CONNECT);
    AddIOCTL(pDevice, IOCTL_NDISTAPI_DISCONNECT);
    AddIOCTL(pDevice, IOCTL_NDISTAPI_QUERY_INFO);
    AddIOCTL(pDevice, IOCTL_NDISTAPI_SET_INFO);
    AddIOCTL(pDevice, IOCTL_NDISTAPI_GET_LINE_EVENTS);
    AddIOCTL(pDevice, IOCTL_NDISTAPI_SET_DEVICEID_BASE);
    AddIOCTL(pDevice, IOCTL_NDISTAPI_CREATE);

    return TRUE;
}


void CIoctlNdproxy::CallRandomWin32API(LPOVERLAPPED pOL)
{
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\ntnativeioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <windows.h>

#include "Device.h"
#include "IOCTL.h"
#include "NtNativeIOCTL.h"
*/
static bool s_fVerbose = false;




HANDLE CIoctlNtNative::CreateDevice(CDevice *pDevice)
{
	return CIoctlNtNative::StaticCreateDevice(pDevice);
}
HANDLE CIoctlNtNative::StaticCreateDevice(CDevice *pDevice)
{
	return CIoctlNtNative::StaticCreateDevice(pDevice->GetDeviceName());
}
HANDLE CIoctlNtNative::StaticCreateDevice(WCHAR *wszDevice)
{
	OBJECT_ATTRIBUTES objectAttributes;
	IO_STATUS_BLOCK iosb;
	UNICODE_STRING string;
	NTSTATUS status;
	HANDLE hDevice = INVALID_HANDLE_VALUE;

	RtlInitUnicodeString(&string, wszDevice);

	InitializeObjectAttributes(
		&objectAttributes,
		&string,
		OBJ_CASE_INSENSITIVE,
		NULL,
		NULL
		);
	ACCESS_MASK dwAccessMask = SYNCHRONIZE | GENERIC_EXECUTE | FILE_READ_DATA | FILE_WRITE_DATA;
	bool fTryOtherAccessMaskFlags = true;
	for(ULONG ulIteration = 0; fTryOtherAccessMaskFlags; ulIteration++)
	{
		status = NtCreateFile(
			&hDevice,
			/*SYNCHRONIZE |*/ dwAccessMask,
			&objectAttributes,		
			&iosb,
			NULL,
			FILE_ATTRIBUTE_NORMAL,
			FILE_SHARE_READ | FILE_SHARE_WRITE,
			FILE_OPEN_IF,
			0,//FILE_SYNCHRONOUS_IO_NONALERT,
			NULL,
			0
			);
		if (!NT_SUCCESS(status)) 
		{
			::SetLastError(RtlNtStatusToDosError(status));
			DPF((TEXT("CIoctlNtNative::CreateDevice() NtCreateFile(%s, 0x%08X) returned 0x%08X=%d\n"), wszDevice, dwAccessMask, status, ::GetLastError()));
			//return INVALID_HANDLE_VALUE;
			switch(ulIteration)
			{
			case 0:
				dwAccessMask = SYNCHRONIZE | GENERIC_EXECUTE | FILE_WRITE_DATA;
				break;

			case 1:
				dwAccessMask = SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA;
				break;

			case 2:
				dwAccessMask = GENERIC_EXECUTE | FILE_READ_DATA | FILE_WRITE_DATA;
				break;

			case 3:
				dwAccessMask = SYNCHRONIZE | FILE_WRITE_DATA;
				break;

			case 4:
				dwAccessMask = GENERIC_EXECUTE | FILE_WRITE_DATA;
				break;

			case 5:
				dwAccessMask = FILE_READ_DATA | FILE_WRITE_DATA;
				break;

			case 6:
				dwAccessMask = FILE_WRITE_DATA;
				break;

			case 7:
				dwAccessMask = GENERIC_EXECUTE | FILE_READ_DATA;
				break;

			case 8:
				dwAccessMask = SYNCHRONIZE | FILE_READ_DATA;
				break;

			case 9:
				dwAccessMask = SYNCHRONIZE | GENERIC_EXECUTE | FILE_READ_DATA;
				break;

			case 10:
				dwAccessMask = FILE_READ_DATA;
				break;

			case 11:
				dwAccessMask = GENERIC_EXECUTE;
				break;

			case 12:
				dwAccessMask = SYNCHRONIZE;
				break;

			default:
				fTryOtherAccessMaskFlags = false;
			}
		}
		else
		{
			_ASSERTE((INVALID_HANDLE_VALUE != hDevice) && (NULL != hDevice));
			return hDevice;
		}
	}//for(ULONG ulIteration = 0; fTryOtherAccessMaskFlags; ulIteration++)

	::SetLastError(RtlNtStatusToDosError(status));
	_tprintf(TEXT("CIoctlNtNative::CreateDevice(0x%08X) NtCreateFile(%s) failed with %d=0x%08X\n"), dwAccessMask, wszDevice, ::GetLastError(), status);
	_ASSERTE((INVALID_HANDLE_VALUE == hDevice) || (NULL == hDevice));
	return INVALID_HANDLE_VALUE;
}
HANDLE CIoctlNtNative::StaticCreateDevice(char *szDevice)
{
	WCHAR wszDeviceName[MAX_DEVICE_NAME_LEN];
	int nNumWritten = MultiByteToWideChar(
		CP_ACP,         // code page
		MB_PRECOMPOSED,         // character-type options
		szDevice, // string to map
		strlen(szDevice),       // number of bytes in string
		wszDeviceName,  // wide-character buffer
		MAX_DEVICE_NAME_LEN        // size of buffer
	);
	//TODO: check & handle retval

	return CIoctlNtNative::StaticCreateDevice(wszDeviceName);
}

BOOL CIoctlNtNative::CloseDevice(CDevice *pDevice)
{
	return CIoctlNtNative::StaticCloseDevice(pDevice);
}
BOOL CIoctlNtNative::StaticCloseDevice(CDevice *pDevice)
{
	NTSTATUS status = NtClose(pDevice->m_hDevice);
	if (!NT_SUCCESS(status))
	{
		::SetLastError(RtlNtStatusToDosError(status));
	}
	else
	{
		_ASSERTE(STATUS_SUCCESS == status);
	}
	return (STATUS_SUCCESS == status);
}

BOOL CIoctlNtNative::DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		)
{
	return CIoctlNtNative::StaticDeviceWriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
}
BOOL CIoctlNtNative::StaticDeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		)
{
	IO_STATUS_BLOCK iosb;
	if (lpOverlapped) lpOverlapped->Internal = (DWORD)STATUS_PENDING;
	NTSTATUS status = NtWriteFile(
		hFile,
		lpOverlapped ? lpOverlapped->hEvent : NULL,
		NULL,
		NULL,
		lpOverlapped ? (PIO_STATUS_BLOCK)&lpOverlapped->Internal : &iosb,
		(PVOID)lpBuffer,
		nNumberOfBytesToWrite,
		NULL,
		NULL
		);
	if (!NT_SUCCESS(status))
	{
		::SetLastError(RtlNtStatusToDosError(status));
	}
	if (STATUS_PENDING == status)
	{
		//
		// cannot get this for a synchronous call
		//
		_ASSERTE(lpOverlapped);
		::SetLastError(ERROR_IO_PENDING);
	}
	if (STATUS_SUCCESS == status)
	{
		if (lpNumberOfBytesWritten)
		{
			if (lpOverlapped)
			{
				*lpNumberOfBytesWritten = ((PIO_STATUS_BLOCK)&lpOverlapped->Internal)->Information;
			}
			else
			{
				*lpNumberOfBytesWritten = iosb.Information;
			}
		}
	}

	//DPF((TEXT("CIoctlNtNative::DeviceWriteFile() NtWriteFile() returned 0x%08X=%d\n"), status, ::GetLastError()));

	return (STATUS_SUCCESS == status);
}

BOOL CIoctlNtNative::DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		)
{
	return CIoctlNtNative::StaticDeviceReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
}
BOOL CIoctlNtNative::StaticDeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		)
{
	IO_STATUS_BLOCK iosb;
	if (lpOverlapped) lpOverlapped->Internal = (DWORD)STATUS_PENDING;
	NTSTATUS status = NtReadFile(
		hFile,
		lpOverlapped ? lpOverlapped->hEvent : NULL,
		NULL,
		NULL,
		lpOverlapped ? (PIO_STATUS_BLOCK)&lpOverlapped->Internal : &iosb,
		lpBuffer,
		nNumberOfBytesToRead,
		NULL,
		NULL
		);
	if (!NT_SUCCESS(status))
	{
		::SetLastError(RtlNtStatusToDosError(status));
	}
	if (STATUS_PENDING == status)
	{
		//
		// cannot get this for a synchronous call
		//
		_ASSERTE(lpOverlapped);
		::SetLastError(ERROR_IO_PENDING);
	}
	if (STATUS_SUCCESS == status)
	{
		if (lpNumberOfBytesRead)
		{
			if (lpOverlapped)
			{
				*lpNumberOfBytesRead = ((PIO_STATUS_BLOCK)&lpOverlapped->Internal)->Information;
			}
			else
			{
				*lpNumberOfBytesRead = iosb.Information;
			}
		}
	}

	//DPF((TEXT("CIoctlNtNative::DeviceReadFile() NtReadFile() returned 0x%08X=%d\n"), status, ::GetLastError()));

	return (STATUS_SUCCESS == status);
}


BOOL CIoctlNtNative::DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		)
{
	return StaticDeviceInputOutputControl(
		hDevice,              // handle to a device, file, or directory 
		dwIoControlCode,       // control code of operation to perform
		lpInBuffer,           // pointer to buffer to supply input data
		nInBufferSize,         // size, in bytes, of input buffer
		lpOutBuffer,          // pointer to buffer to receive output data
		nOutBufferSize,        // size, in bytes, of output buffer
		lpBytesReturned,     // pointer to variable to receive byte count
		lpOverlapped    // pointer to structure for asynchronous operation
		);
}
BOOL CIoctlNtNative::StaticDeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		)
{
	IO_STATUS_BLOCK iosb;
	if (lpOverlapped) lpOverlapped->Internal = (DWORD)STATUS_PENDING;
	NTSTATUS status = NtDeviceIoControlFile (
		hDevice, 
		lpOverlapped ? lpOverlapped->hEvent : NULL, 
		NULL, 
		NULL,
		lpOverlapped ? (PIO_STATUS_BLOCK)&lpOverlapped->Internal : &iosb,
		dwIoControlCode,
		lpInBuffer,
		nInBufferSize,
		lpOutBuffer,
		nOutBufferSize
		);
	if (!NT_SUCCESS(status))
	{
		::SetLastError(RtlNtStatusToDosError(status));
	}
	if (STATUS_PENDING == status)
	{
		//
		// cannot get this for a synchronous call
		//
		_ASSERTE(lpOverlapped);
		::SetLastError(ERROR_IO_PENDING);
	}
	//DPF((TEXT("CIoctlNtNative::DeviceInputOutputControl() NtDeviceIoControlFile() returned 0x%08X=%d\n"), status, ::GetLastError()));

	return (STATUS_SUCCESS == status);
}


BOOL CIoctlNtNative::DeviceCancelIo(
	HANDLE hFile  // file handle for which to cancel I/O
	)
{
	return StaticDeviceCancelIo(hFile);
}
BOOL CIoctlNtNative::StaticDeviceCancelIo(
	HANDLE hFile  // file handle for which to cancel I/O
	)
{
	//
	// no need to implement CancelIo() myself
	//
	return CancelIo(hFile);
}

BOOL CIoctlNtNative::AlertThread(
	HANDLE hThread  // file handle for which to cancel I/O
	)
{
	return StaticNtAlertThread(hThread);
}
BOOL CIoctlNtNative::StaticNtAlertThread(
	HANDLE hThread  // file handle for which to cancel I/O
	)
{
	//
	// no need to implement CancelIo() myself
	//
	NTSTATUS status =  ::NtAlertThread(hThread);
	if (!NT_SUCCESS(status))
	{
		::SetLastError(RtlNtStatusToDosError(status));
	}

	return (STATUS_SUCCESS == status);
}

BOOL CIoctlNtNative::StaticNtQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    )
{
	NTSTATUS status = NtQueryInformationFile(
		FileHandle,
		IoStatusBlock,
		FileInformation,
		Length,
		FileInformationClass
		);
	if (!NT_SUCCESS(status))
	{
		::SetLastError(RtlNtStatusToDosError(status));
	}
	DPF((TEXT("CIoctlNtNative::StaticNtQueryInformationFile() NtQueryInformationFile() returned 0x%08X=%d\n"), status, ::GetLastError()));

	return (STATUS_SUCCESS == status);

}
BOOL CIoctlNtNative::StaticNtSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    )
{
	NTSTATUS status = NtSetInformationFile(
		FileHandle,
		IoStatusBlock,
		FileInformation,
		Length,
		FileInformationClass
		);
	if (!NT_SUCCESS(status))
	{
		::SetLastError(RtlNtStatusToDosError(status));
	}
	DPF((TEXT("CIoctlNtNative::StaticNtSetInformationFile() NtSetInformationFile() returned 0x%08X=%d\n"), status, ::GetLastError()));

	return (STATUS_SUCCESS == status);

}


BOOL CIoctlNtNative::StaticNtQueryDirectoryFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN BOOLEAN ReturnSingleEntry,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN BOOLEAN RestartScan
    )
{
	NTSTATUS status = ::NtQueryDirectoryFile(
		FileHandle,
		Event,
		ApcRoutine,
		ApcContext,
		IoStatusBlock,
		FileInformation,
		Length,
		FileInformationClass,
		ReturnSingleEntry,
		FileName,
		RestartScan
		);
	if (!NT_SUCCESS(status))
	{
		::SetLastError(RtlNtStatusToDosError(status));
	}
	DPF((TEXT("CIoctlNtNative::StaticNtQueryDirectoryFile() NtQueryDirectoryFile() returned 0x%08X=%d\n"), status, ::GetLastError()));

	return (STATUS_SUCCESS == status);

}


BOOL CIoctlNtNative::StaticNtNotifyChangeDirectoryFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree
    )
{
	NTSTATUS status = ::NtNotifyChangeDirectoryFile(
		FileHandle,
		Event,
		ApcRoutine,
		ApcContext,
		IoStatusBlock,
		Buffer,
		Length,
		CompletionFilter,
		WatchTree
		);
	if (!NT_SUCCESS(status))
	{
		::SetLastError(RtlNtStatusToDosError(status));
	}
	DPF((TEXT("CIoctlNtNative::StaticNtNotifyChangeDirectoryFile() NtNotifyChangeDirectoryFile() returned 0x%08X=%d\n"), status, ::GetLastError()));

	return (STATUS_SUCCESS == status);

}


BOOL CIoctlNtNative::StaticQueryVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
	)
{
	NTSTATUS status = NtQueryVolumeInformationFile(
		FileHandle,
		IoStatusBlock,
		FsInformation,
		Length,
		FsInformationClass
		);
	if (!NT_SUCCESS(status))
	{
		::SetLastError(RtlNtStatusToDosError(status));
	}
	DPF((TEXT("CIoctlNtNative::StaticQueryVolumeInformationFile() NtQueryVolumeInformationFile() returned 0x%08X=%d\n"), status, ::GetLastError()));

	return (STATUS_SUCCESS == status);
}

BOOL CIoctlNtNative::StaticNtQueryFullAttributesFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_NETWORK_OPEN_INFORMATION FileInformation
	)
{
	NTSTATUS status = NtQueryFullAttributesFile(
		ObjectAttributes,
		FileInformation
		);
	if (!NT_SUCCESS(status))
	{
		::SetLastError(RtlNtStatusToDosError(status));
	}
	DPF((TEXT("CIoctlNtNative::StaticNtQueryFullAttributesFile() NtQueryFullAttributesFile() returned 0x%08X=%d\n"), status, ::GetLastError()));

	return (STATUS_SUCCESS == status);
}

int CIoctlNtNative::GetRandom_FsInformationClass()
{
	//
	// also returns the invalid 0 value
	//
	return (rand()%FileFsMaximumInformation);
}

int CIoctlNtNative::GetRandom_FileInformationClass()
{
	//
	// also returns the invalid 0 value
	//
	return (rand()%FileMaximumInformation);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\ntvdmioctl.h ===
#ifndef __NT_VDM_IOCTL_H
#define __NT_VDM_IOCTL_H

//#include "NtNativeIOCTL.h"


class CIoctlNtVdm : public CIoctlNtNative
{
public:
    CIoctlNtVdm(CDevice *pDevice): CIoctlNtNative(pDevice){;};
    virtual ~CIoctlNtVdm(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual HANDLE CreateDevice(CDevice *pDevice);

	virtual BOOL CloseDevice(CDevice *pDevice);

	virtual BOOL DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		);

	virtual BOOL DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		);
	virtual BOOL DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		);

	virtual BOOL DeviceCancelIo(
		HANDLE hFile  // file handle for which to cancel I/O
		);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);


};




#endif //__NT_VDM_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\nullwindow.h ===
#ifndef __NULL_WINDOW_H
#define __NULL_WINDOW_H



class CNullWindow
{
public:
	CNullWindow(void);

	~CNullWindow(void);

	bool Init(void);

    HWND m_hWnd;

	bool m_fInitialized;

	bool WindowCreatedByThisThread();

private:
	DWORD m_dwCreatingThreadID;
};

#endif //__NULL_WINDOW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\nullwindow.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*


#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <crtdbg.h>
*/
#include "NullWindow.h"

#define CLASS_NAME TEXT("{5CFD4FE0-9684-11d2-B8B6-Null-Window}")

static LRESULT CALLBACK MainWndProc(
    HWND hWnd,
    UINT msg, 
    WPARAM wParam,
    LPARAM lParam 
    )
{
    _tprintf(TEXT("CNullWindow, inside MainWndProc() .\n"));
	return( DefWindowProc( hWnd, msg, wParam, lParam ));
}

CNullWindow::CNullWindow():
    m_hWnd(NULL),
	m_fInitialized(false)
{
	;
}


CNullWindow::~CNullWindow(void)
{
	for(;;)
	{
        MSG msg;
        if (!::GetMessage(  
            &msg,         // address of structure with message
            m_hWnd,           // handle of window: NULL is current thread
            0,  // first message  
            0xFFFF   // last message
            ))
		{
			break;
		}
			
	}

    //
    // BUGBUG: the window must be destroyed in the same thread as the CreateWindow() thread.
    //

    if (!::DestroyWindow(m_hWnd))
    {
        _tprintf(TEXT("CNullWindow::~CNullWindow() DestroyWindow() failed with %d.\n"), ::GetLastError());
    }

	::UnregisterClass(
		CLASS_NAME,  // pointer to class name string
		NULL   // handle to application instance
		);
}



bool CNullWindow::Init(void)
{
	//
	// register class
	//
	WNDCLASS wc;
	wc.lpszClassName = CLASS_NAME;
	wc.lpfnWndProc = MainWndProc;
	wc.style = CS_OWNDC | CS_VREDRAW | CS_HREDRAW;
	wc.hInstance = NULL;
	wc.hIcon = NULL,//::LoadIcon( NULL, IDI_APPLICATION );
	wc.hCursor = NULL,//::LoadCursor( NULL, IDC_ARROW );
	wc.hbrBackground = (HBRUSH)( COLOR_WINDOW+1 );
	wc.lpszMenuName = TEXT("Null-Window");
	wc.cbClsExtra = 0;
	wc.cbWndExtra = 0;
	if (!::RegisterClass( &wc ))
	{
		DWORD dwLastError = ::GetLastError();
		if (ERROR_CLASS_ALREADY_EXISTS != dwLastError)
		{
			_tprintf(TEXT("CNullWindow::Init() RegisterClass() failed with %d.\n"), dwLastError);
			return false;
		}
		// else it's ok
	}

    //
    // the window must be created in the same thread as the GetMessage() thread.
    //
	if (m_hWnd == NULL)
	{
		m_hWnd = ::CreateWindow( 
			CLASS_NAME,
			TEXT("Null Window"),
			WS_CAPTION | WS_SYSMENU, //WS_OVERLAPPEDWINDOW|WS_HSCROLL|WS_VSCROLL,
			0,
			0,
			150,//CW_USEDEFAULT,
			0,//CW_USEDEFAULT,
			NULL,
			NULL,
			NULL, //hInstance,
			NULL
			);
	}
	//else we already have a window

	if (NULL == m_hWnd)
	{
        _tprintf(TEXT(
			"CPHWindowHog::HogAll(): CreateWindow(%s) failed with %d"), 
			CLASS_NAME,
			::GetLastError()
            );
		return false;
	}

	m_dwCreatingThreadID = ::GetCurrentThreadId();
	m_fInitialized = true;
	return true;
}

bool CNullWindow::WindowCreatedByThisThread()
{
	return m_fInitialized && ::GetCurrentThreadId() == m_dwCreatingThreadID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\packoff.h ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    packoff.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    packoff.h is the complement to packon.h.  An inclusion of packoff.h
    MUST ALWAYS be preceded by an inclusion of packon.h, in one-to-one
    correspondence.

Author:

    Chuck Lenzmeier (chuckl) 4-Mar-1990

Revision History:

    15-Apr-1991 JohnRo
        Created lint-able variant.
--*/

#if ! (defined(lint) || defined(_lint))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#endif
#pragma pack()
#endif // ! (defined(lint) || defined(_lint))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\pch.h ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>
#include <time.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

#include <winsock2.h>
#include <windows.h>

#include "NtNativeIOCTL.h"

#include "device.h"
#include "IOCTL.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\parallel.h ===
/*++

Copyright (c) 1993-1998  Microsoft Corporation

Module Name:

	parallel.h

Abstract:

	This file defines the services supplied by the ParPort driver.

Author:

	norbertk

Revision History:

--*/

#ifndef _PARALLEL_
#define _PARALLEL_

#include <ntddpar.h>

//
// Define the parallel port device name strings.
//

#define DD_PARALLEL_PORT_BASE_NAME_U   L"ParallelPort"

//
// IEEE 1284.3 Daisy Chain (DC) Device ID's range from 0 to 3. Devices
//   are identified based on their connection order in the daisy chain
//   relative to the other 1284.3 DC devices.  Device 0 is the 1284.3 DC
//   device that is closest to host port.
//
#define IEEE_1284_3_DAISY_CHAIN_MAX_ID 3

//
// NtDeviceIoControlFile internal IoControlCode values for parallel device.
//

// Legacy - acquires entire parallel "bus"
#define IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE               CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 11, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_GET_PARALLEL_PORT_INFO               CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARALLEL_CONNECT_INTERRUPT           CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 13, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARALLEL_DISCONNECT_INTERRUPT        CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 14, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_RELEASE_PARALLEL_PORT_INFO           CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_GET_MORE_PARALLEL_PORT_INFO          CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 17, METHOD_BUFFERED, FILE_ANY_ACCESS)

// Saves current chipset mode - puts the chipset into Specified mode (implemented in filter)
#define IOCTL_INTERNAL_PARCHIP_CONNECT                      CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 18, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_PARALLEL_SET_CHIP_MODE               CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 19, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARALLEL_CLEAR_CHIP_MODE             CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 20, METHOD_BUFFERED, FILE_ANY_ACCESS)

// New parport IOCTLs
#define IOCTL_INTERNAL_GET_PARALLEL_PNP_INFO                CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 21, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_INIT_1284_3_BUS                      CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 22, METHOD_BUFFERED, FILE_ANY_ACCESS)
// Takes a flat namespace Id for the device, also acquires the port
#define IOCTL_INTERNAL_SELECT_DEVICE                        CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 23, METHOD_BUFFERED, FILE_ANY_ACCESS)
// Takes a flat namespace Id for the device, also releases the port
#define IOCTL_INTERNAL_DESELECT_DEVICE                      CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 24, METHOD_BUFFERED, FILE_ANY_ACCESS) 

// New parclass IOCTLs
#define IOCTL_INTERNAL_PARCLASS_CONNECT                     CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 30, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARCLASS_DISCONNECT                  CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 31, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_DISCONNECT_IDLE                      CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 32, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_LOCK_PORT                            CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 37, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_UNLOCK_PORT                          CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 38, METHOD_BUFFERED, FILE_ANY_ACCESS)

// IOCTL version of call to ParPort's FreePort function
#define IOCTL_INTERNAL_PARALLEL_PORT_FREE                   CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 40, METHOD_BUFFERED, FILE_ANY_ACCESS)

// IOCTLs for IEEE1284.3
#define IOCTL_INTERNAL_PARDOT3_CONNECT                      CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 41, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARDOT3_DISCONNECT                   CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 42, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARDOT3_RESET                        CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 43, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARDOT3_SIGNAL                       CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 44, METHOD_BUFFERED, FILE_ANY_ACCESS)


//
// IOCTLs for registering/unregistering for ParPort's RemovalRelations
// 
//  - A device object should register for removal relations with a 
//      parport device if the device is physically connected to the 
//      parallel port.
//
//  - Parport will report all devices that have registered with it for
//      removal relations in response to a PnP QUERY_DEVICE_RELATIONS of
//      type RemovalRelations. This allows PnP to remove all device stacks
//      that depend on the parport device prior to removing the parport 
//      device itself.
//
//  - The single Input parameter is a PARPORT_REMOVAL_RELATIONS 
//    structure that is defined below
// 
#define IOCTL_INTERNAL_REGISTER_FOR_REMOVAL_RELATIONS       CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 50, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_UNREGISTER_FOR_REMOVAL_RELATIONS     CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 51, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _PARPORT_REMOVAL_RELATIONS {
    PDEVICE_OBJECT  DeviceObject; // device object that is registering w/Parport
    ULONG           Flags;        // Flags - reserved - set to 0 for now
    PUNICODE_STRING DeviceName;   // DeviceName identifier of device registering for removal relations - used for debugging 
                                  // - printed in parport's debug spew - convention is to use same DeviceName that was passed to 
                                  //     IoCreateDevice
} PARPORT_REMOVAL_RELATIONS, *PPARPORT_REMOVAL_RELATIONS;


// Define 1284.3 command qualifiers
#define MODE_LEN_1284_3         7       // # of magic sequence bytes
static UCHAR ModeQualifier[MODE_LEN_1284_3] = { 0xAA, 0x55, 0x00, 0xFF, 0x87, 0x78, 0xFF };

#define LEGACYZIP_MODE_LEN               3
static  UCHAR LegacyZipModeQualifier[LEGACYZIP_MODE_LEN] = { 0x00, 0x3c, 0x20 };

typedef enum {
    P12843DL_OFF,
    P12843DL_DOT3_DL,
    P12843DL_MLC_DL,
    P12843DL_DOT4_DL
} P12843_DL_MODES;

// Define 1284.3 Commands
#define CPP_ASSIGN_ADDR         0x00
#define CPP_SELECT              0xE0
#define CPP_DESELECT            0x30
#define CPP_QUERY_INT           0x08
#define CPP_DISABLE_INT         0x40
#define CPP_ENABLE_INT          0x48
#define CPP_CLEAR_INT_LAT       0x50
#define CPP_SET_INT_LAT         0x58
#define CPP_COMMAND_FILTER      0xF8


typedef
BOOLEAN
(*PPARALLEL_TRY_ALLOCATE_ROUTINE) (
	IN  PVOID   TryAllocateContext
	);

typedef
VOID
(*PPARALLEL_FREE_ROUTINE) (
	IN  PVOID   FreeContext
	);

typedef
ULONG
(*PPARALLEL_QUERY_WAITERS_ROUTINE) (
	IN  PVOID   QueryAllocsContext
	);

typedef
NTSTATUS
(*PPARALLEL_SET_CHIP_MODE) (
	IN  PVOID   SetChipContext,
	IN  UCHAR   ChipMode
	);

typedef
NTSTATUS
(*PPARALLEL_CLEAR_CHIP_MODE) (
	IN  PVOID   ClearChipContext,
	IN  UCHAR   ChipMode
	);

typedef
NTSTATUS
(*PPARALLEL_TRY_SELECT_ROUTINE) (
	IN  PVOID   TrySelectContext,
	IN  PVOID   TrySelectCommand
	);

typedef
NTSTATUS
(*PPARALLEL_DESELECT_ROUTINE) (
	IN  PVOID   DeselectContext,
	IN  PVOID   DeselectCommand
	);

typedef
NTSTATUS
(*PPARCHIP_SET_CHIP_MODE) (
	IN  PVOID   SetChipContext,
	IN  UCHAR   ChipMode
	);

typedef
NTSTATUS
(*PPARCHIP_CLEAR_CHIP_MODE) (
	IN  PVOID   ClearChipContext,
	IN  UCHAR   ChipMode
	);

//
// Hardware Capabilities
//
#define PPT_NO_HARDWARE_PRESENT     0x00000000
#define PPT_ECP_PRESENT             0x00000001
#define PPT_EPP_PRESENT             0x00000002
#define PPT_EPP_32_PRESENT          0x00000004
#define PPT_BYTE_PRESENT            0x00000008
#define PPT_BIDI_PRESENT            0x00000008 // deprecated - will be removed soon! dvdf
#define PPT_1284_3_PRESENT          0x00000010

//  Added DVDR 10-6-98

// Structure passed to the ParChip Filter when calling it
// with the IOCTL_INTERNAL_CHIP_FILTER_CONNECT ioctl
typedef struct _PARALLEL_PARCHIP_INFO {
    PUCHAR                      Controller;
    PUCHAR                      EcrController;
    ULONG                       HardwareModes;
    PPARCHIP_SET_CHIP_MODE      ParChipSetMode;
    PPARCHIP_CLEAR_CHIP_MODE    ParChipClearMode;
    PVOID                       Context;
    BOOLEAN                     success;
} PARALLEL_PARCHIP_INFO, *PPARALLEL_PARCHIP_INFO;

//  End Added by DVDR 10-6-1998


typedef struct _PARALLEL_PORT_INFORMATION {
    PHYSICAL_ADDRESS                OriginalController;
    PUCHAR                          Controller;
    ULONG                           SpanOfController;
    PPARALLEL_TRY_ALLOCATE_ROUTINE  TryAllocatePort;    // nonblocking callback to allocate port
    PPARALLEL_FREE_ROUTINE          FreePort;           // callback to free port
    PPARALLEL_QUERY_WAITERS_ROUTINE QueryNumWaiters;    // callback to query number of waiters for port allocation
    PVOID                           Context;            // context for callbacks to ParPort device
} PARALLEL_PORT_INFORMATION, *PPARALLEL_PORT_INFORMATION;

typedef struct _PARALLEL_PNP_INFORMATION {
    PHYSICAL_ADDRESS                OriginalEcpController;
    PUCHAR                          EcpController;
    ULONG                           SpanOfEcpController;
    ULONG                           PortNumber; // deprecated - do not use
    ULONG                           HardwareCapabilities;
    PPARALLEL_SET_CHIP_MODE         TrySetChipMode;
    PPARALLEL_CLEAR_CHIP_MODE       ClearChipMode;
    ULONG                           FifoDepth;
    ULONG                           FifoWidth;
    PHYSICAL_ADDRESS                EppControllerPhysicalAddress;
    ULONG                           SpanOfEppController;
    ULONG                           Ieee1284_3DeviceCount; // number of .3 daisy chain devices connected to this ParPort
    PPARALLEL_TRY_SELECT_ROUTINE    TrySelectDevice;
    PPARALLEL_DESELECT_ROUTINE      DeselectDevice;
    PVOID                           Context;
    ULONG                           CurrentMode;
    PWSTR                           PortName;              // symbolic link name for legacy device object
} PARALLEL_PNP_INFORMATION, *PPARALLEL_PNP_INFORMATION;

//  Start Added by DVDR 2-19-1998

//
// PARALLEL_1284_COMMAND CommandFlags
//

// this flag is deprecated - use 1284.3 daisy chain ID == 4 to indicate End-Of-Chain device
#define PAR_END_OF_CHAIN_DEVICE ((ULONG)0x00000001)        // The target device for this command
                                                           //   is an End-Of-Chain device, the
                                                           //   contents of the ID field are 
                                                           //   undefined and should be ignored

#define PAR_HAVE_PORT_KEEP_PORT ((ULONG)0x00000002)        // Indicates that the requesting driver 
                                                           //   has previously acquired the parallel port
                                                           //   and does is not ready to release it yet.
                                                           //
                                                           // On a SELECT_DEVICE ParPort should NOT 
                                                           //   try to acquire the port before selecting
                                                           //   the device.
                                                           //   
                                                           // On a DESELECT_DEVICE ParPort should NOT  
                                                           //   free the port after deselecting the device.

#define PAR_LEGACY_ZIP_DRIVE    ((ULONG)0x00000004)        // The target device for this command
                                                           //   is a Legacy Iomega Zip drive, the
                                                           //   contents of the ID field are 
                                                           //   undefined and should be ignored


#define PAR_LEGACY_ZIP_DRIVE_STD_MODE ((ULONG)0x00000010)  // The target device for these commands
#define PAR_LEGACY_ZIP_DRIVE_EPP_MODE ((ULONG)0x00000020)  //   are a Legacy Iomega Zip drive, the
                                                           //   contents of the ID field are 
                                                           //   undefined and should be ignored
                                                           //   This will select the Zip into DISK or EPP Mode

#define DOT3_END_OF_CHAIN_ID 4  // this ID used in a 1284.3 SELECT or DESELECT means the End-Of-Chain device
#define DOT3_LEGACY_ZIP_ID   5  // this ID used in a 1284.3 SELECT or DESELECT means Legacy Zip drive

//
// The following structure is passed in on an
//   IOCTL_INTERNAL_SELECT_DEVICE and on an
//   IOCTL_INTERNAL_DESELECT_DEVICE
typedef struct _PARALLEL_1284_COMMAND {
    UCHAR                       ID;           // 0..3 for 1284.3 daisy chain device, 4 for End-Of-Chain device, 5 for Legacy Zip
    UCHAR                       Port;         // reserved ( set == 0 )
    ULONG                       CommandFlags; // see above
} PARALLEL_1284_COMMAND, *PPARALLEL_1284_COMMAND;


//
// Hardware Modes
//
#define INITIAL_MODE        0x00000000

// Disable Parchip and ECR arbitrator
//       0 - Parchip and ecr arbritrator is off
//       1 - Parchip and ecr arbitrator is on
#define PARCHIP_ECR_ARBITRATOR 1

//
// The following structure is passed in on an
//   IOCTL_INTERNAL_PARALLEL_SET_CHIP_MODE and on an
//   IOCTL_INTERNAL_PARALLEL_CLEAR_CHIP_MODE
//
typedef struct _PARALLEL_CHIP_MODE {
    UCHAR                       ModeFlags;
    BOOLEAN                     success;
} PARALLEL_CHIP_MODE, *PPARALLEL_CHIP_MODE;

//  End Added by DVDR 2-19-1998

//
// The following structure is passed in on an
//   IOCTL_INTERNAL_PARALLEL_CONNECT_INTERRUPT and on an
//   IOCTL_INTERNAL_PARALLEL_DISCONNECT_INTERRUPT request.
//

typedef
VOID
(*PPARALLEL_DEFERRED_ROUTINE) (
	IN  PVOID   DeferredContext
	);

typedef struct _PARALLEL_INTERRUPT_SERVICE_ROUTINE {
	PKSERVICE_ROUTINE           InterruptServiceRoutine;
	PVOID                       InterruptServiceContext;
	PPARALLEL_DEFERRED_ROUTINE  DeferredPortCheckRoutine;   /* OPTIONAL */
	PVOID                       DeferredPortCheckContext;   /* OPTIONAL */
} PARALLEL_INTERRUPT_SERVICE_ROUTINE, *PPARALLEL_INTERRUPT_SERVICE_ROUTINE;

//
// The following structure is returned on an
// IOCTL_INTERNAL_PARALLEL_CONNECT_INTERRUPT request;
//

typedef struct _PARALLEL_INTERRUPT_INFORMATION {
	PKINTERRUPT                     InterruptObject;
	PPARALLEL_TRY_ALLOCATE_ROUTINE  TryAllocatePortAtInterruptLevel;
	PPARALLEL_FREE_ROUTINE          FreePortFromInterruptLevel;
	PVOID                           Context;
} PARALLEL_INTERRUPT_INFORMATION, *PPARALLEL_INTERRUPT_INFORMATION;

//
// The following structure is returned on an
// IOCTL_INTERNAL_GET_MORE_PARALLEL_PORT_INFO.
//

typedef struct _MORE_PARALLEL_PORT_INFORMATION {
	INTERFACE_TYPE  InterfaceType;
	ULONG           BusNumber;
	ULONG           InterruptLevel;
	ULONG           InterruptVector;
	KAFFINITY       InterruptAffinity;
	KINTERRUPT_MODE InterruptMode;
} MORE_PARALLEL_PORT_INFORMATION, *PMORE_PARALLEL_PORT_INFORMATION;

typedef enum {
    SAFE_MODE,
    UNSAFE_MODE         // Available only through kernel.  Your driver
                        // will be humiliated if you choose UNSAFE_MODE and
                        // screw up.  - dvrh  
} PARALLEL_SAFETY;

//
// The following structure is returned by
// IOCTL_INTERNAL_PARCLASS_CONNECT.
//

typedef
USHORT
(*PDETERMINE_IEEE_MODES) (
    IN  PVOID   Context
    );

#define OLD_PARCLASS 0

#if OLD_PARCLASS
typedef 
NTSTATUS
(*PNEGOTIATE_IEEE_MODE) (
	IN  PVOID       Extension,
	IN  UCHAR       Extensibility
	);
#else
typedef 
NTSTATUS
(*PNEGOTIATE_IEEE_MODE) (
    IN PVOID           Context,
    IN USHORT          ModeMaskFwd,
    IN USHORT          ModeMaskRev,
    IN PARALLEL_SAFETY ModeSafety,
    IN BOOLEAN         IsForward
    );
#endif
	
typedef 
NTSTATUS
(*PTERMINATE_IEEE_MODE) (
	IN  PVOID       Context
	);
	
typedef
NTSTATUS
(*PPARALLEL_IEEE_FWD_TO_REV)(
    IN  PVOID       Context
    );

typedef
NTSTATUS
(*PPARALLEL_IEEE_REV_TO_FWD)(
    IN  PVOID       Context
    );

typedef
NTSTATUS
(*PPARALLEL_READ) (
	IN  PVOID       Context,
	OUT PVOID       Buffer,
	IN  ULONG       NumBytesToRead,
	OUT PULONG      NumBytesRead,
	IN  UCHAR       Channel
	);    
	
typedef
NTSTATUS
(*PPARALLEL_WRITE) (
	IN  PVOID       Context,
	OUT PVOID       Buffer,
	IN  ULONG       NumBytesToWrite,
	OUT PULONG      NumBytesWritten,
	IN  UCHAR       Channel
	);
    
typedef
NTSTATUS
(*PPARALLEL_TRYSELECT_DEVICE) (
    IN  PVOID                   Context,
    IN  PARALLEL_1284_COMMAND   Command
    );
    
typedef
NTSTATUS
(*PPARALLEL_DESELECT_DEVICE) (
    IN  PVOID                   Context,
    IN  PARALLEL_1284_COMMAND   Command
    );
	
typedef struct _PARCLASS_INFORMATION {
    PUCHAR                      Controller;
    PUCHAR                      EcrController;
    ULONG                       SpanOfController;
    PDETERMINE_IEEE_MODES       DetermineIeeeModes;
    PNEGOTIATE_IEEE_MODE        NegotiateIeeeMode;
    PTERMINATE_IEEE_MODE        TerminateIeeeMode;
    PPARALLEL_IEEE_FWD_TO_REV   IeeeFwdToRevMode;
    PPARALLEL_IEEE_REV_TO_FWD   IeeeRevToFwdMode;
    PPARALLEL_READ              ParallelRead;
    PPARALLEL_WRITE             ParallelWrite;
    PVOID                       ParclassContext;
    ULONG                       HardwareCapabilities;
    ULONG                       FifoDepth;
    ULONG                       FifoWidth;
    PPARALLEL_TRYSELECT_DEVICE  ParallelTryselect;
    PPARALLEL_DESELECT_DEVICE   ParallelDeSelect;
} PARCLASS_INFORMATION, *PPARCLASS_INFORMATION;

//
// Standard and ECP parallel port offsets.
//

#define DATA_OFFSET         0
#define OFFSET_ECP_AFIFO    0x0000              // ECP Mode Address FIFO
#define AFIFO_OFFSET        OFFSET_ECP_AFIFO   // ECP Mode Address FIFO
#define DSR_OFFSET          1
#define DCR_OFFSET          2
#define EPP_OFFSET          4

// default to the old defines - note that the old defines break on PCI cards
#ifndef DVRH_USE_PARPORT_ECP_ADDR
    #define DVRH_USE_PARPORT_ECP_ADDR 0
#endif

// DVRH_USE_PARPORT_ECP_ADDR settings
//  0   -   ECP registers are hardcoded to
//          Controller + 0x400
//  1   -   ECP registers are pulled from
//          Parport which hopefully got
//          them from PnP.

#if (0 == DVRH_USE_PARPORT_ECP_ADDR)
// ***Note: These do not hold for PCI parallel ports
    #define ECP_OFFSET          0x400
    #define CNFGB_OFFSET        0x401
    #define ECR_OFFSET          0x402
#else
    #define ECP_OFFSET          0x0
    #define CNFGB_OFFSET        0x1
    #define ECR_OFFSET          0x2
#endif

#define FIFO_OFFSET         ECP_OFFSET
#define CFIFO_OFFSET        ECP_OFFSET
#define CNFGA_OFFSET        ECP_OFFSET
#define ECP_DFIFO_OFFSET    ECP_OFFSET      // ECP Mode Data FIFO
#define TFIFO_OFFSET        ECP_OFFSET
#define OFFSET_ECP_DFIFO    ECP_OFFSET      // ECP Mode Data FIFO
#define OFFSET_TFIFO        ECP_OFFSET      // Test FIFO
#define OFFSET_CFIFO        ECP_OFFSET      // Fast Centronics Data FIFO
#define OFFSET_ECR          ECR_OFFSET      // Extended Control Register

#define OFFSET_PARALLEL_REGISTER_SPAN   0x0003

#define ECP_SPAN            3
#define EPP_SPAN            4

//
// Bit definitions for the DSR.
//

#define DSR_NOT_BUSY            0x80
#define DSR_NOT_ACK             0x40
#define DSR_PERROR              0x20
#define DSR_SELECT              0x10
#define DSR_NOT_FAULT           0x08

//
// More bit definitions for the DSR.
//

#define DSR_NOT_PTR_BUSY        0x80
#define DSR_NOT_PERIPH_ACK      0x80
#define DSR_WAIT                0x80
#define DSR_PTR_CLK             0x40
#define DSR_PERIPH_CLK          0x40
#define DSR_INTR                0x40
#define DSR_ACK_DATA_REQ        0x20
#define DSR_NOT_ACK_REVERSE     0x20
#define DSR_XFLAG               0x10
#define DSR_NOT_DATA_AVAIL      0x08
#define DSR_NOT_PERIPH_REQUEST  0x08

//
// Bit definitions for the DCR.
//

#define DCR_RESERVED            0xC0
#define DCR_DIRECTION           0x20
#define DCR_ACKINT_ENABLED      0x10
#define DCR_SELECT_IN           0x08
#define DCR_NOT_INIT            0x04
#define DCR_AUTOFEED            0x02
#define DCR_STROBE              0x01

//
// More bit definitions for the DCR.
//

#define DCR_NOT_1284_ACTIVE     0x08
#define DCR_ASTRB               0x08
#define DCR_NOT_REVERSE_REQUEST 0x04
#define DCR_NULL                0x04
#define DCR_NOT_HOST_BUSY       0x02
#define DCR_NOT_HOST_ACK        0x02
#define DCR_DSTRB               0x02
#define DCR_NOT_HOST_CLK        0x01
#define DCR_WRITE               0x01

//
// Bit definitions for configuration register A.
//

#define CNFGA_IMPID_MASK        0x70
#define CNFGA_IMPID_16BIT       0x00
#define CNFGA_IMPID_8BIT        0x10
#define CNFGA_IMPID_32BIT       0x20

#define CNFGA_NO_TRANS_BYTE     0x04

////////////////////////////////////////////////////////////////////////////////
// ECR values that establish basic hardware modes.  In each case, the default
// is to disable error interrupts, DMA, and service interrupts.
////////////////////////////////////////////////////////////////////////////////

#if (0 == PARCHIP_ECR_ARBITRATOR)
    #define DEFAULT_ECR_PS2                 0x34
    #define DEFAULT_ECR_ECP                 0x74
#endif

//
// Bit definitions for ECR register.
//

#define ECR_ERRINT_DISABLED        0x10
#define ECR_DMA_ENABLED            0x08
#define ECR_SVC_INT_DISABLED       0x04

#define ECR_MODE_MASK              0x1F
#define ECR_SPP_MODE               0x00
#define ECR_BYTE_MODE              0x20     // PS/2
#define ECR_BYTE_PIO_MODE          (ECR_BYTE_MODE | ECR_ERRINT_DISABLED | ECR_SVC_INT_DISABLED)

#define ECR_FASTCENT_MODE          0x40
#define ECR_ECP_MODE               0x60
#define ECR_ECP_PIO_MODE           (ECR_ECP_MODE | ECR_ERRINT_DISABLED | ECR_SVC_INT_DISABLED)

#define ECR_EPP_MODE               0x80
#define ECR_EPP_PIO_MODE           (ECR_EPP_MODE | ECR_ERRINT_DISABLED | ECR_SVC_INT_DISABLED)

#define ECR_RESERVED_MODE          0x10
#define ECR_TEST_MODE              0xC0
#define ECR_CONFIG_MODE            0xE0

#define DEFAULT_ECR_TEST                0xD4
#define DEFAULT_ECR_COMPATIBILITY       0x14

#define DEFAULT_ECR_CONFIGURATION       0xF4

#define ECR_FIFO_MASK              0x03        // Mask to isolate FIFO bits
#define ECR_FIFO_FULL              0x02        // FIFO completely full
#define ECR_FIFO_EMPTY             0x01        // FIFO completely empty
#define ECR_FIFO_SOME_DATA         0x00        // FIFO has some data in it

#define ECP_MAX_FIFO_DEPTH         4098        // Likely max for ECP HW FIFO size

//------------------------------------------------------------------------
// Mask and test values for extracting the Implementation ID from the
// ConfigA register
//------------------------------------------------------------------------

#define CNFGA_IMPID_MASK            0x70
#define CNFGA_IMPID_SHIFT           4

#define FIFO_PWORD_8BIT             1
#define FIFO_PWORD_16BIT            0
#define FIFO_PWORD_32BIT            2


#define TEST_ECR_FIFO(registerValue,testValue)  \
	( ( (registerValue) & ECR_FIFO_MASK ) == testValue )

//////////////////////////////////////////////////////////////////////////////
// The following BIT_x definitions provide a generic bit shift value
// based upon the bit's position in a hardware register or byte of
// memory.  These constants are used by some of the macros that are
// defined below.
//////////////////////////////////////////////////////////////////////////////

#define BIT_7   7
#define BIT_6   6
#define BIT_5   5
#define BIT_4   4
#define BIT_3   3
#define BIT_2   2
#define BIT_1   1
#define BIT_0   0

#define BIT_7_SET   0x80
#define BIT_6_SET   0x40
#define BIT_5_SET   0x20
#define BIT_4_SET   0x10
#define BIT_3_SET   0x8
#define BIT_2_SET   0x4
#define BIT_1_SET   0x2
#define BIT_0_SET   0x1

//////////////////////////////////////////////////////////////////////////////
// The following defines and macros may be used to set, test, and
// update the Device Control Register (DCR).
//////////////////////////////////////////////////////////////////////////////
#define DIR_READ  1
#define DIR_WRITE 0

#define IRQEN_ENABLE  1
#define IRQEN_DISABLE 0
             
#define ACTIVE    1
#define INACTIVE  0             
#define DONT_CARE 2

#define DVRH_USE_FAST_MACROS    1
#define DVRH_USE_NIBBLE_MACROS  1
//////////////////////////////////////////////////////////////////////////////
// The following defines may be used generically in any of the SET_xxx,
// TEST_xxx, or UPDATE_xxx macros that follow.
//////////////////////////////////////////////////////////////////////////////
#if (1 == DVRH_USE_FAST_MACROS)
    #define SET_DCR(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)((b5==ACTIVE? BIT_5_SET : 0) | \
            (b4==ACTIVE?  BIT_4_SET : 0) | \
            (b3==ACTIVE?  0         : BIT_3_SET) | \
            (b2==ACTIVE?  BIT_2_SET : 0) | \
            (b1==ACTIVE?  0         : BIT_1_SET) | \
            (b0==ACTIVE?  0         : BIT_0_SET) ) )
#else
    #define SET_DCR(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)(((b5==ACTIVE?1:0)<<BIT_5) | \
            ((b4==ACTIVE?1:0)<<BIT_4) | \
            ((b3==ACTIVE?0:1)<<BIT_3) | \
            ((b2==ACTIVE?1:0)<<BIT_2) | \
            ((b1==ACTIVE?0:1)<<BIT_1) | \
            ((b0==ACTIVE?0:1)<<BIT_0) ) )
#endif

typedef enum {
    PHASE_UNKNOWN,
    PHASE_NEGOTIATION,
    PHASE_SETUP,                    // Used in ECP mode only
    PHASE_FORWARD_IDLE,
    PHASE_FORWARD_XFER,
    PHASE_FWD_TO_REV,
    PHASE_REVERSE_IDLE,
    PHASE_REVERSE_XFER,
    PHASE_REV_TO_FWD,
    PHASE_TERMINATE,
    PHASE_DATA_AVAILABLE,           // Used in nibble and byte modes only
    PHASE_DATA_NOT_AVAIL,           // Used in nibble and byte modes only
    PHASE_INTERRUPT_HOST            // Used in nibble and byte modes only
} P1284_PHASE;

typedef enum {
    HW_MODE_COMPATIBILITY,
    HW_MODE_PS2,
    HW_MODE_FAST_CENTRONICS,
    HW_MODE_ECP,
    HW_MODE_EPP,
    HW_MODE_RESERVED,
    HW_MODE_TEST,
    HW_MODE_CONFIGURATION
} P1284_HW_MODE;


#endif // _PARALLEL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\ntvdmioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <windows.h>

#include "NtNativeIOCTL.h"
*/
//#include <ntddk.h>
#include <vdm.h>
#include "NtVdmIOCTL.h"

static bool s_fVerbose = false;

typedef NTSTATUS (WINAPI *NT_VDM)(
    IN VDMSERVICECLASS Service,
    IN OUT PVOID ServiceData
    );


static HMODULE hNtDll = NULL;
static NT_VDM _NtVdmControl = NULL;

void CIoctlNtVdm::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
	;
}

HANDLE CIoctlNtVdm::CreateDevice(CDevice *pDevice)
{
	if (NULL == hNtDll)
	{
		_ASSERTE(NULL == _NtVdmControl);
		hNtDll = ::LoadLibrary(TEXT("ntdll.dll"));
		_ASSERTE(NULL != hNtDll);
		_NtVdmControl = (NT_VDM)::GetProcAddress(hNtDll, "NtVdmControl");
		_ASSERTE(NULL != _NtVdmControl);
	}
    return (HANDLE)1;//CIoctlNtNative::StaticCreateDevice(pDevice);
}

BOOL CIoctlNtVdm::CloseDevice(CDevice *pDevice)
{
	return TRUE;
}

BOOL CIoctlNtVdm::DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		)
{
	return TRUE;
}

BOOL CIoctlNtVdm::DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		)
{
	return TRUE;
}


BOOL CIoctlNtVdm::DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		)
{
///*
	NTSTATUS status = _NtVdmControl(
		VdmStartExecution, //IN VDMSERVICECLASS Service,
		lpOutBuffer //IN OUT PVOID ServiceData
		);
	if (!NT_SUCCESS(status))
	{
		::SetLastError(RtlNtStatusToDosError(status));
	}
	DPF((TEXT("CIoctlNtVdm::DeviceInputOutputControl() NtVdmControl() returned 0x%08X=%d\n"), status, ::GetLastError()));
//*/
	return (STATUS_SUCCESS == status);
}


BOOL CIoctlNtVdm::DeviceCancelIo(
	HANDLE hFile  // file handle for which to cancel I/O
	)
{
	return TRUE;
}


void CIoctlNtVdm::CallRandomWin32API(LPOVERLAPPED pOL)
{
	return;
}


void CIoctlNtVdm::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
	switch(dwIOCTL)
	{
	case VdmStartExecution:
		break;

	case VdmQueueInterrupt:
		break;

	case VdmDelayInterrupt:
		break;

	case VdmInitialize:
		break;

	case VdmFeatures:
		break;

	case VdmSetInt21Handler:
		break;

	case VdmQueryDir:
		break;

	case VdmPrinterDirectIoOpen:
		break;

	case VdmPrinterDirectIoClose:
		break;

	case VdmPrinterInitialize:
		break;

	case VdmPrinterInitialize+1:
		break;

	default:
		_ASSERTE(FALSE);
	}
    //CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
}


BOOL CIoctlNtVdm::FindValidIOCTLs(CDevice *pDevice)
{
	AddIOCTL(pDevice, VdmStartExecution          );
	AddIOCTL(pDevice, VdmQueueInterrupt          );
	AddIOCTL(pDevice, VdmDelayInterrupt          );
	AddIOCTL(pDevice, VdmInitialize          );
	AddIOCTL(pDevice, VdmFeatures          );
	AddIOCTL(pDevice, VdmSetInt21Handler          );
	AddIOCTL(pDevice, VdmQueryDir          );
	AddIOCTL(pDevice, VdmPrinterDirectIoOpen          );
	AddIOCTL(pDevice, VdmPrinterDirectIoClose          );
	AddIOCTL(pDevice, VdmPrinterInitialize          );
	AddIOCTL(pDevice, VdmPrinterInitialize+1          );

	return TRUE;
    //return CIoctl::FindValidIOCTLs(pDevice);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\pipeioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*



#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

#include <windows.h>

*/

#include "PipeIOCTL.h"

static bool s_fVerbose = false;

HANDLE CIoctlPipe::CreateDevice(CDevice *pDevice)
{
	//
	// 1st try to connect to an existing pipe, and if fail, try to create a server.
	// this way, i can create couples of client-server pipes
	//FILE_ATTRIBUTE_NORMAL
	HANDLE hPipe = INVALID_HANDLE_VALUE;
	DWORD fdwAttrsAndFlags = FILE_FLAG_OVERLAPPED;
	DWORD dwLastError;
	//for (DWORD dwTimesTried = 0; dwTimesTried < 100; dwTimesTried++)
	{
		if (0 == rand()%20) fdwAttrsAndFlags |= FILE_FLAG_RANDOM_ACCESS;
		if (0 == rand()%20) fdwAttrsAndFlags |= FILE_FLAG_SEQUENTIAL_SCAN;
		if (0 == rand()%20) fdwAttrsAndFlags |= FILE_FLAG_DELETE_ON_CLOSE;
		if (0 == rand()%20) fdwAttrsAndFlags |= FILE_FLAG_BACKUP_SEMANTICS;
		if (0 == rand()%20) fdwAttrsAndFlags |= FILE_FLAG_POSIX_SEMANTICS;
		if (0 == rand()%20) fdwAttrsAndFlags |= FILE_FLAG_OPEN_REPARSE_POINT;
		if (0 == rand()%20) fdwAttrsAndFlags |= FILE_FLAG_OPEN_NO_RECALL;
		if (0 == rand()%20) fdwAttrsAndFlags |= FILE_ATTRIBUTE_ARCHIVE;
		if (0 == rand()%20) fdwAttrsAndFlags |= FILE_ATTRIBUTE_ENCRYPTED;
		if (0 == rand()%20) fdwAttrsAndFlags |= FILE_ATTRIBUTE_HIDDEN;
		if (0 == rand()%20) fdwAttrsAndFlags |= FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
		if (0 == rand()%20) fdwAttrsAndFlags |= FILE_ATTRIBUTE_OFFLINE;
		if (0 == rand()%200) fdwAttrsAndFlags |= FILE_ATTRIBUTE_READONLY;
		if (0 == rand()%20) fdwAttrsAndFlags |= FILE_ATTRIBUTE_SYSTEM;
		if (0 == rand()%20) fdwAttrsAndFlags |= FILE_ATTRIBUTE_TEMPORARY;
		
		if (0 == rand()%20) fdwAttrsAndFlags |= SECURITY_SQOS_PRESENT;
		if (0 == rand()%20) fdwAttrsAndFlags |= SECURITY_ANONYMOUS;
		if (0 == rand()%20) fdwAttrsAndFlags |= SECURITY_IDENTIFICATION;
		if (0 == rand()%20) fdwAttrsAndFlags |= SECURITY_IMPERSONATION;
		if (0 == rand()%20) fdwAttrsAndFlags |= SECURITY_DELEGATION;
		if (0 == rand()%20) fdwAttrsAndFlags |= SECURITY_CONTEXT_TRACKING;
		if (0 == rand()%20) fdwAttrsAndFlags |= SECURITY_EFFECTIVE_ONLY;

		if (m_pDevice->sm_fExitAllThreads || m_pDevice->m_fShutDown) goto out;

		hPipe = ::CreateFile(
		   pDevice->GetDeviceName(), //LPCTSTR lpszName,           // name of the pipe (or file)
		   GENERIC_READ | GENERIC_WRITE , //DWORD fdwAccess,            // read/write access (must match the pipe)
		   FILE_SHARE_READ | FILE_SHARE_WRITE, //DWORD fdwShareMode,         // usually 0 (no share) for pipes
		   NULL, // access privileges
		   OPEN_EXISTING, //DWORD fdwCreate,            // must be OPEN_EXISTING for pipes
		   fdwAttrsAndFlags, //FILE_FLAG_OVERLAPPED, //DWORD fdwAttrsAndFlags,     // write-through and overlapping modes
		   NULL //HANDLE hTemplateFile        // ignored with OPEN_EXISTING
		   );
		if (INVALID_HANDLE_VALUE != hPipe)
		{
			DPF((TEXT("CIoctlPipe::CreateFile(%s, 0x%08X) suceeded, so we are a pipe client now.\n"), pDevice->GetDeviceName(), fdwAttrsAndFlags));
			return hPipe;
		}
		dwLastError = ::GetLastError();
		//::Sleep(100);//let other threads breath some air
	}

	DPF((TEXT("CIoctlPipe::CreateFile(%s, 0x%08X) FAILED with %d, so try to create a pipe server instead\n"), pDevice->GetDeviceName(), fdwAttrsAndFlags, dwLastError));
	//for (dwTimesTried = 0; dwTimesTried < 100; dwTimesTried++)
	{
		if (m_pDevice->sm_fExitAllThreads || m_pDevice->m_fShutDown) goto out;

		DWORD dwPipeMode = PIPE_NOWAIT;
		if (rand()%10) dwPipeMode |= PIPE_TYPE_BYTE;
		else dwPipeMode |= PIPE_TYPE_MESSAGE;

		DWORD dwOpenMode = FILE_FLAG_OVERLAPPED;
		if (rand()%10) dwOpenMode |= PIPE_ACCESS_DUPLEX;
		else 
			if (rand()%2) dwOpenMode |= PIPE_ACCESS_INBOUND;
			else 
				if (rand()%50) dwOpenMode |= PIPE_ACCESS_OUTBOUND;
				else dwOpenMode = dwOpenMode;//this is actually illegal

		hPipe = CreateNamedPipe(
			pDevice->GetDeviceName(), //IN LPCWSTR lpName,
			dwOpenMode , //IN DWORD dwOpenMode,
			dwPipeMode , //IN DWORD dwPipeMode,
			rand()%(PIPE_UNLIMITED_INSTANCES+1), //IN DWORD nMaxInstances,
			rand()%SIZEOF_INOUTBUFF, //IN DWORD nOutBufferSize,
			rand()%SIZEOF_INOUTBUFF, //IN DWORD nInBufferSize,
			rand()%2000, //IN DWORD nDefaultTimeOut,
			NULL//IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
			);
		if (INVALID_HANDLE_VALUE == hPipe)
		{
			dwLastError = ::GetLastError();
			//::Sleep(100);//let other threads breath some air
		}
		else
		{
			DPF((TEXT("CIoctlPipe::CreateNamedPipe(%s) suceeded\n"), pDevice->GetDeviceName()));
			return hPipe;
		}

	}

	DPF((TEXT("CIoctlPipe::CreateNamedPipe(%s) FAILED with %d\n"), pDevice->GetDeviceName(), dwLastError));
	_ASSERTE(INVALID_HANDLE_VALUE == hPipe);
out:
	return INVALID_HANDLE_VALUE;
}

void CIoctlPipe::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    ;
}

void CIoctlPipe::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
    switch(dwIOCTL)
    {
    case FSCTL_PIPE_ASSIGN_EVENT:
/*
IN
typedef struct _FILE_PIPE_ASSIGN_EVENT_BUFFER {
     HANDLE EventHandle;
     ULONG KeyValue;
} FILE_PIPE_ASSIGN_EVENT_BUFFER, *PFILE_PIPE_ASSIGN_EVENT_BUFFER;
*/
        ((PFILE_PIPE_ASSIGN_EVENT_BUFFER)abInBuffer)->EventHandle = GetRandomEventHandle();
        ((PFILE_PIPE_ASSIGN_EVENT_BUFFER)abInBuffer)->KeyValue = rand();
        SetInParam(dwInBuff, sizeof(FILE_PIPE_ASSIGN_EVENT_BUFFER));

        break;

    case FSCTL_PIPE_DISCONNECT:
// buffs not used
        break;

    case FSCTL_PIPE_LISTEN:
// buffs not used
        break;

    case FSCTL_PIPE_PEEK:
/*
OUT
typedef struct _FILE_PIPE_PEEK_BUFFER {
     ULONG NamedPipeState;
     ULONG ReadDataAvailable;
     ULONG NumberOfMessages;
     ULONG MessageLength;
     CHAR Data[1];
} FILE_PIPE_PEEK_BUFFER, *PFILE_PIPE_PEEK_BUFFER;
*/
		dwOutBuff = rand()%2 ? sizeof(FILE_PIPE_PEEK_BUFFER) : sizeof(FILE_PIPE_PEEK_BUFFER)+rand()%20000;
        break;

    case FSCTL_PIPE_QUERY_EVENT:
/*
IN: event handle
OUT:
typedef struct _FILE_PIPE_EVENT_BUFFER {
     ULONG NamedPipeState;
     ULONG EntryType;
     ULONG ByteCount;
     ULONG KeyValue;
     ULONG NumberRequests;
} FILE_PIPE_EVENT_BUFFER, *PFILE_PIPE_EVENT_BUFFER;
*/
        abInBuffer = (unsigned char*)GetRandomEventHandle();
        SetInParam(dwInBuff, sizeof(HANDLE));
		dwOutBuff = rand()%2 ? sizeof(FILE_PIPE_EVENT_BUFFER) : rand()%sizeof(FILE_PIPE_PEEK_BUFFER);

        break;

    case FSCTL_PIPE_TRANSCEIVE:
        SetInParam(dwInBuff, rand());
        SetOutParam(abOutBuffer, dwOutBuff, rand());

        break;

    case FSCTL_PIPE_WAIT:
/*
typedef struct _FILE_PIPE_WAIT_FOR_BUFFER {
     LARGE_INTEGER Timeout;
     ULONG NameLength;
     BOOLEAN TimeoutSpecified;
     WCHAR Name[1];
} FILE_PIPE_WAIT_FOR_BUFFER, *PFILE_PIPE_WAIT_FOR_BUFFER;
*/
        ((PFILE_PIPE_WAIT_FOR_BUFFER)abInBuffer)->Timeout.LowPart = rand();
        ((PFILE_PIPE_WAIT_FOR_BUFFER)abInBuffer)->Timeout.HighPart = 0;
        ((PFILE_PIPE_WAIT_FOR_BUFFER)abInBuffer)->TimeoutSpecified = rand()%2;
        ((PFILE_PIPE_WAIT_FOR_BUFFER)abInBuffer)->Name;//TODO: random name?
        SetInParam(dwInBuff, sizeof(FILE_PIPE_WAIT_FOR_BUFFER)+rand()%1000);

        break;

    case FSCTL_PIPE_IMPERSONATE:
// no params
        break;

    case FSCTL_PIPE_SET_CLIENT_PROCESS:
    case FSCTL_PIPE_QUERY_CLIENT_PROCESS:
/*
typedef struct _FILE_PIPE_CLIENT_PROCESS_BUFFER {
     PVOID ClientSession;
     PVOID ClientProcess;
} FILE_PIPE_CLIENT_PROCESS_BUFFER, *PFILE_PIPE_CLIENT_PROCESS_BUFFER;
or
typedef struct _FILE_PIPE_CLIENT_PROCESS_BUFFER_EX {
    PVOID ClientSession;
    PVOID ClientProcess;
    USHORT ClientComputerNameLength; // in bytes
    WCHAR ClientComputerBuffer[FILE_PIPE_COMPUTER_NAME_LENGTH+1]; // terminated
} FILE_PIPE_CLIENT_PROCESS_BUFFER_EX, *PFILE_PIPE_CLIENT_PROCESS_BUFFER_EX;
		
*/
        ((PFILE_PIPE_CLIENT_PROCESS_BUFFER_EX)abInBuffer)->ClientSession = (void*)rand();
        ((PFILE_PIPE_CLIENT_PROCESS_BUFFER_EX)abInBuffer)->ClientProcess = (void*)rand();
        ((PFILE_PIPE_CLIENT_PROCESS_BUFFER_EX)abInBuffer)->ClientComputerNameLength = rand();
        ((PFILE_PIPE_CLIENT_PROCESS_BUFFER_EX)abInBuffer)->ClientComputerBuffer;//TODO: random contents?
        SetInParam(dwInBuff, sizeof(FILE_PIPE_CLIENT_PROCESS_BUFFER_EX)+rand()%1000);

        break;

    case FSCTL_PIPE_INTERNAL_READ:
    case FSCTL_PIPE_INTERNAL_WRITE:
    case FSCTL_PIPE_INTERNAL_TRANSCEIVE:
    case FSCTL_PIPE_INTERNAL_READ_OVFLOW:
        SetInParam(dwInBuff, rand());
        SetOutParam(abOutBuffer, dwOutBuff, rand());

        break;

    default:
		_ASSERTE(FALSE);
        SetInParam(dwInBuff, rand());
        SetOutParam(abOutBuffer, dwOutBuff, rand());
    }
}


BOOL CIoctlPipe::FindValidIOCTLs(CDevice *pDevice)
{
    AddIOCTL(pDevice, FSCTL_PIPE_ASSIGN_EVENT);
    AddIOCTL(pDevice, FSCTL_PIPE_DISCONNECT);
    AddIOCTL(pDevice, FSCTL_PIPE_LISTEN);
    AddIOCTL(pDevice, FSCTL_PIPE_PEEK);
    AddIOCTL(pDevice, FSCTL_PIPE_QUERY_EVENT);
    AddIOCTL(pDevice, FSCTL_PIPE_TRANSCEIVE);
    AddIOCTL(pDevice, FSCTL_PIPE_WAIT);
    AddIOCTL(pDevice, FSCTL_PIPE_IMPERSONATE);
    AddIOCTL(pDevice, FSCTL_PIPE_SET_CLIENT_PROCESS);
    AddIOCTL(pDevice, FSCTL_PIPE_QUERY_CLIENT_PROCESS);
    AddIOCTL(pDevice, FSCTL_PIPE_INTERNAL_READ);
    AddIOCTL(pDevice, FSCTL_PIPE_INTERNAL_WRITE);
    AddIOCTL(pDevice, FSCTL_PIPE_INTERNAL_TRANSCEIVE);
    AddIOCTL(pDevice, FSCTL_PIPE_INTERNAL_READ_OVFLOW);

	return TRUE;
}


HANDLE CIoctlPipe::GetRandomEventHandle()
{
	if (0 == rand()%20) return NULL;
	if (0 == rand()%20) return INVALID_HANDLE_VALUE;
	if (0 == rand()%20) return (HANDLE)100000;
	return m_ahEvents[rand()%__EVENT_ARRAY_SIZE];
}



void CIoctlPipe::CallRandomWin32API(LPOVERLAPPED pOL)
{
	return;
}

BOOL CIoctlPipe::DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		)
{
	/*
	return CIoctlPipe::StaticDeviceInputOutputControl(
		rand()%2 ? hDevice : m_ahDeviceMsFsHandle,              // handle to a device, file, or directory 
		dwIoControlCode,       // control code of operation to perform
		lpInBuffer,           // pointer to buffer to supply input data
		nInBufferSize,         // size, in bytes, of input buffer
		lpOutBuffer,          // pointer to buffer to receive output data
		nOutBufferSize,        // size, in bytes, of output buffer
		lpBytesReturned,     // pointer to variable to receive byte count
		lpOverlapped    // pointer to structure for asynchronous operation
		);
		*/
	IO_STATUS_BLOCK iosb;
	if (lpOverlapped) lpOverlapped->Internal = (DWORD)STATUS_PENDING;
	NTSTATUS status = NtFsControlFile (
	//NTSTATUS status = NtDeviceIoControlFile (
		hDevice, //rand()%2 ? hDevice : m_ahDeviceMsFsHandle, 
		lpOverlapped ? lpOverlapped->hEvent : NULL, 
		NULL, 
		NULL,
		lpOverlapped ? (PIO_STATUS_BLOCK)&lpOverlapped->Internal : &iosb,
		dwIoControlCode,
		lpInBuffer,
		nInBufferSize,
		lpOutBuffer,
		nOutBufferSize
		);
	if (!NT_SUCCESS(status))
	{
		::SetLastError(RtlNtStatusToDosError(status));
	}
	if (STATUS_PENDING == status)
	{
		//
		// cannot get this for a synchronous call
		//
		_ASSERTE(lpOverlapped);
		::SetLastError(ERROR_IO_PENDING);
	}
	//DPF((TEXT("CIoctlPipe::DeviceInputOutputControl() NtDeviceIoControlFile() returned 0x%08X=%d\n"), status, ::GetLastError()));

	return (STATUS_SUCCESS == status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\pipeioctl.h ===
#ifndef __PIPE_IOCTL_H
#define __PIPE_IOCTL_H

//#include "IOCTL.h"

#define __EVENT_ARRAY_SIZE 10

class CIoctlPipe : public CIoctl
{
public:
    CIoctlPipe(CDevice *pDevice): CIoctl(pDevice)
	{
		for (int i = 0; i < __EVENT_ARRAY_SIZE; i++)
		{
			//
			// try to create events, do not care if i fail.
			// TODO: on the fly, if any of these handles is NULL, try to create it
			//
			m_ahEvents[i] = CreateEvent(
				NULL, //IN LPSECURITY_ATTRIBUTES lpEventAttributes,
				rand()%2, //IN BOOL bManualReset,
				rand()%2, //IN BOOL bInitialState,
				NULL //IN LPCWSTR lpName
				);//donn't care if fail
		}
	}
    virtual ~CIoctlPipe()
	{
		for (int i = 0; i < __EVENT_ARRAY_SIZE; i++)
		{
			CloseHandle(m_ahEvents[i]);
		}
	}

	virtual HANDLE CreateDevice(CDevice *pDevice);

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

	virtual BOOL DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		);

private:
	HANDLE m_ahEvents[__EVENT_ARRAY_SIZE];
	HANDLE GetRandomEventHandle();

};




#endif //__PIPE_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\serialioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*



#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
*/

#include <ntddser.h>

#include "SerialIOCTL.h"

static bool s_fVerbose = false;

enum {
	PLACE_HOLDER_PURGE_COMM = 0,
	PLACE_HOLDER_LAST
};

static ULONG GetRandomBaud()
{
    switch(rand()%25)
    {
    case 0: return SERIAL_BAUD_075;
    case 1: return SERIAL_BAUD_110;
    case 2: return SERIAL_BAUD_134_5;
    case 3: return SERIAL_BAUD_150;
    case 4: return SERIAL_BAUD_300;
    case 5: return SERIAL_BAUD_600;
    case 6: return SERIAL_BAUD_1200;
    case 7: return SERIAL_BAUD_1800;
    case 8: return SERIAL_BAUD_2400;
    case 9: return SERIAL_BAUD_4800;
    case 10: return SERIAL_BAUD_7200;
    case 11: return SERIAL_BAUD_9600;
    case 12: return SERIAL_BAUD_14400;
    case 13: return SERIAL_BAUD_19200;
    case 14: return SERIAL_BAUD_38400;
    case 15: return SERIAL_BAUD_56K;
    case 16: return SERIAL_BAUD_128K;
    case 17: return SERIAL_BAUD_115200;
    case 18: return SERIAL_BAUD_57600;
    case 19: return SERIAL_BAUD_USER;
    case 20: return 0;
    case 21: return DWORD_RAND;
    case 22: return DWORD_RAND;
    case 23: return DWORD_RAND;
    case 24: return DWORD_RAND;
    default: return DWORD_RAND;
    }
}

static ULONG GetRandomQueueSize()
{
    switch(rand()%16)
    {
    case 0: return 0;
    case 1: return rand();
    case 2: return DWORD_RAND;
    case 3: return 64*1024;
    case 4: return 128*1024;
    case 5: return 256*1024;
    case 6: return 512*1024;
    case 7: return 1024*1024;
    case 8: return 2*1024*1024;
    case 9: return 4*1024*1024;
    case 10: return 8*1024*1024;
    case 11: return 16*1024*1024;
    case 12: return 32*1024*1024;
    case 13: return 64*1024*1024;
    case 14: return 128*1024*1024;
    case 15: return 256*1024*1024;
    default: return DWORD_RAND;
    }
}


static UCHAR GetRandomStopBits()
{
    switch(rand()%5)
    {
    case 0: return 0;
    case 1: return STOP_BIT_1;
    case 2: return STOP_BITS_1_5;
    case 3: return STOP_BITS_2;
    case 4: return rand();
    default: return DWORD_RAND;
    }
}


static UCHAR GetRandomParity()
{
    switch(rand()%8)
    {
    case 0: return 0;
    case 1: return NO_PARITY;
    case 2: return ODD_PARITY;
    case 3: return EVEN_PARITY;
    case 4: return MARK_PARITY;
    case 5: return SPACE_PARITY;
    case 6: return rand();
    case 7: return DWORD_RAND;
    default: return DWORD_RAND;
    }
}


static UCHAR GetRandomWordLength()
{
    switch(rand()%8)
    {
    case 0: return 0;
    case 1: return SERIAL_DATABITS_5;
    case 2: return SERIAL_DATABITS_6;
    case 3: return SERIAL_DATABITS_7;
    case 4: return SERIAL_DATABITS_8;
    case 5: return SERIAL_DATABITS_16;
    case 6: return SERIAL_DATABITS_16X;
    case 7: return rand();
    default: return rand();
    }
}


static ULONG GetRandomTimeout()
{
    switch(rand()%4)
    {
    case 0: return 0;
    case 1: return -1;
    case 2: return rand();
    case 3: return DWORD_RAND;
    default: return DWORD_RAND;
    }
}

static ULONG GetRandomWaitMask()
{
    return DWORD_RAND;
/*
#define SERIAL_EV_RXCHAR           0x0001  // Any Character received
#define SERIAL_EV_RXFLAG           0x0002  // Received certain character
#define SERIAL_EV_TXEMPTY          0x0004  // Transmitt Queue Empty
#define SERIAL_EV_CTS              0x0008  // CTS changed state
#define SERIAL_EV_DSR              0x0010  // DSR changed state
#define SERIAL_EV_RLSD             0x0020  // RLSD changed state
#define SERIAL_EV_BREAK            0x0040  // BREAK received
#define SERIAL_EV_ERR              0x0080  // Line status error occurred
#define SERIAL_EV_RING             0x0100  // Ring signal detected
#define SERIAL_EV_PERR             0x0200  // Printer error occured
#define SERIAL_EV_RX80FULL         0x0400  // Receive buffer is 80 percent full
#define SERIAL_EV_EVENT1           0x0800  // Provider specific event 1
#define SERIAL_EV_EVENT2           0x1000  // Provider specific event 2
*/
}


static ULONG GetRandomPurgeMask()
{
    return DWORD_RAND;
/*
#define SERIAL_PURGE_TXABORT 0x00000001
#define SERIAL_PURGE_RXABORT 0x00000002
#define SERIAL_PURGE_TXCLEAR 0x00000004
#define SERIAL_PURGE_RXCLEAR 0x00000008
*/
}

static UCHAR GetRandomChar()
{
    return rand();
}

static ULONG GetRandomControlHandShake()
{
    switch(rand()%10)
    {
    case 0: return 0;
    case 1: return SERIAL_DTR_MASK;
    case 2: return SERIAL_DTR_CONTROL;
    case 3: return SERIAL_DTR_HANDSHAKE;
    case 4: return SERIAL_CTS_HANDSHAKE;
    case 5: return SERIAL_DSR_HANDSHAKE;
    case 6: return SERIAL_DCD_HANDSHAKE;
    case 7: return SERIAL_OUT_HANDSHAKEMASK;
    case 8: return SERIAL_DSR_SENSITIVITY;
    case 9: return rand();
    default: return rand();
    }

}

static ULONG GetRandomFlowReplace()
{
    switch(rand()%11)
    {
    case 0: return 0;
    case 1: return SERIAL_AUTO_TRANSMIT;
    case 2: return SERIAL_AUTO_RECEIVE;
    case 3: return SERIAL_ERROR_CHAR;
    case 4: return SERIAL_NULL_STRIPPING;
    case 5: return SERIAL_BREAK_CHAR;
    case 6: return SERIAL_RTS_MASK;
    case 7: return SERIAL_RTS_CONTROL;
    case 8: return SERIAL_RTS_HANDSHAKE;
    case 9: return SERIAL_TRANSMIT_TOGGLE;
    case 10: return rand();
    default: return rand();
    }

}

ULONG GetRandomXoffTimeout()
{
    return DWORD_RAND;
}


ULONG GetRandomXoffCounter()
{
    return DWORD_RAND;
}

UCHAR GetRandomXoffChar()
{
    return rand();
}

static LONG GetRandomXonLimit()
{
    return rand();
}

static LONG GetRandomXoffLimit()
{
    return rand();
}

ULONG GetRandomModemControl()
{
    switch(rand()%7)
    {
    case 0: return 0;
    case 1: return SERIAL_IOC_MCR_DTR;
    case 2: return SERIAL_IOC_MCR_RTS;
    case 3: return SERIAL_IOC_MCR_OUT1;
    case 4: return SERIAL_IOC_MCR_OUT2;
    case 5: return SERIAL_IOC_MCR_LOOP;
    case 6: return rand();
    default: return rand();
    }
}

ULONG GetRandomFifoControl()
{
    switch(rand()%10)
    {
    case 0: return 0;
    case 1: return SERIAL_IOC_FCR_FIFO_ENABLE;
    case 2: return SERIAL_IOC_FCR_RCVR_RESET;
    case 3: return SERIAL_IOC_FCR_XMIT_RESET;
    case 4: return SERIAL_IOC_FCR_DMA_MODE;
    case 5: return SERIAL_IOC_FCR_RES1;
    case 6: return SERIAL_IOC_FCR_RES2;
    case 7: return SERIAL_IOC_FCR_RCVR_TRIGGER_LSB;
    case 8: return SERIAL_IOC_FCR_RCVR_TRIGGER_MSB;
    case 9: return rand();
    default: return rand();
    }
}


void CIoctlSerial::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
}

void CIoctlSerial::CallRandomWin32API(LPOVERLAPPED pOL)
{
	switch(rand()%PLACE_HOLDER_LAST)
	{
	case PLACE_HOLDER_PURGE_COMM:
		::PurgeComm(m_pDevice->m_hDevice, GetRandomPurgeCommParams());
		break;

	default: _ASSERTE(FALSE);
	}
}

void CIoctlSerial::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
    switch(dwIOCTL)
    {
    case IOCTL_SERIAL_SET_BAUD_RATE:
/*
typedef struct _SERIAL_BAUD_RATE {
    ULONG BaudRate;
    } SERIAL_BAUD_RATE,*PSERIAL_BAUD_RATE;
*/
        ((PSERIAL_BAUD_RATE)abInBuffer)->BaudRate = GetRandomBaud();

        SetInParam(dwInBuff, sizeof(SERIAL_BAUD_RATE));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

        break;

    case IOCTL_SERIAL_GET_BAUD_RATE:
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(SERIAL_BAUD_RATE));

        break;

    case IOCTL_SERIAL_SET_QUEUE_SIZE:
/*
typedef struct _SERIAL_QUEUE_SIZE {
    ULONG InSize;
    ULONG OutSize;
    } SERIAL_QUEUE_SIZE,*PSERIAL_QUEUE_SIZE;
*/
        ((PSERIAL_QUEUE_SIZE)abInBuffer)->InSize = GetRandomQueueSize();
        ((PSERIAL_QUEUE_SIZE)abInBuffer)->OutSize = GetRandomQueueSize();

        SetInParam(dwInBuff, sizeof(SERIAL_QUEUE_SIZE));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

        break;

    case IOCTL_SERIAL_SET_LINE_CONTROL:
/*
typedef struct _SERIAL_LINE_CONTROL {
    UCHAR StopBits;
    UCHAR Parity;
    UCHAR WordLength;
    } SERIAL_LINE_CONTROL,*PSERIAL_LINE_CONTROL;
*/
        ((PSERIAL_LINE_CONTROL)abInBuffer)->StopBits = GetRandomStopBits();
        ((PSERIAL_LINE_CONTROL)abInBuffer)->Parity = GetRandomParity();
        ((PSERIAL_LINE_CONTROL)abInBuffer)->WordLength = GetRandomWordLength();

        SetInParam(dwInBuff, sizeof(SERIAL_LINE_CONTROL));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

        break;

    case IOCTL_SERIAL_GET_LINE_CONTROL:
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(SERIAL_LINE_CONTROL));

        break;

    case IOCTL_SERIAL_SET_BREAK_ON:
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, 0);

        break;

    case IOCTL_SERIAL_SET_BREAK_OFF:
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, 0);

        break;

    case IOCTL_SERIAL_IMMEDIATE_CHAR:
        *((UCHAR*)abInBuffer) = rand();

        SetInParam(dwInBuff, sizeof(UCHAR));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

        break;

    case IOCTL_SERIAL_SET_TIMEOUTS:
/*
typedef struct _SERIAL_TIMEOUTS {
    ULONG ReadIntervalTimeout;
    ULONG ReadTotalTimeoutMultiplier;
    ULONG ReadTotalTimeoutConstant;
    ULONG WriteTotalTimeoutMultiplier;
    ULONG WriteTotalTimeoutConstant;
    } SERIAL_TIMEOUTS,*PSERIAL_TIMEOUTS;
*/
        ((PSERIAL_TIMEOUTS)abInBuffer)->ReadIntervalTimeout = GetRandomTimeout();
        ((PSERIAL_TIMEOUTS)abInBuffer)->ReadTotalTimeoutMultiplier = GetRandomTimeout();
        ((PSERIAL_TIMEOUTS)abInBuffer)->ReadTotalTimeoutConstant = GetRandomTimeout();
        ((PSERIAL_TIMEOUTS)abInBuffer)->WriteTotalTimeoutMultiplier = GetRandomTimeout();
        ((PSERIAL_TIMEOUTS)abInBuffer)->WriteTotalTimeoutConstant = GetRandomTimeout();

        SetInParam(dwInBuff, sizeof(SERIAL_TIMEOUTS));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

        break;

    case IOCTL_SERIAL_GET_TIMEOUTS:
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(SERIAL_TIMEOUTS));

        break;

    case IOCTL_SERIAL_SET_DTR:

        break;

    case IOCTL_SERIAL_CLR_DTR:

        break;

    case IOCTL_SERIAL_RESET_DEVICE:

        break;

    case IOCTL_SERIAL_SET_RTS:

        break;

    case IOCTL_SERIAL_CLR_RTS:

        break;

    case IOCTL_SERIAL_SET_XOFF:

        break;

    case IOCTL_SERIAL_SET_XON:

        break;

    case IOCTL_SERIAL_GET_WAIT_MASK:
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG));

        break;

    case IOCTL_SERIAL_SET_WAIT_MASK:
        *((ULONG*)abInBuffer) = GetRandomWaitMask();

        SetInParam(dwInBuff, sizeof(ULONG));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

        break;

    case IOCTL_SERIAL_WAIT_ON_MASK:
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG));

        break;

    case IOCTL_SERIAL_PURGE:
        *((ULONG*)abInBuffer) = GetRandomPurgeMask();

        SetInParam(dwInBuff, sizeof(ULONG));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

        break;

    case IOCTL_SERIAL_GET_CHARS:
/*
typedef struct _SERIAL_CHARS {
    UCHAR EofChar;
    UCHAR ErrorChar;
    UCHAR BreakChar;
    UCHAR EventChar;
    UCHAR XonChar;
    UCHAR XoffChar;
    } SERIAL_CHARS,*PSERIAL_CHARS;
*/
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(SERIAL_CHARS));

        break;

    case IOCTL_SERIAL_SET_CHARS:
        ((PSERIAL_CHARS)abInBuffer)->EofChar = GetRandomChar();
        ((PSERIAL_CHARS)abInBuffer)->ErrorChar = GetRandomChar();
        ((PSERIAL_CHARS)abInBuffer)->BreakChar = GetRandomChar();
        ((PSERIAL_CHARS)abInBuffer)->EventChar = GetRandomChar();
        ((PSERIAL_CHARS)abInBuffer)->XonChar = GetRandomChar();
        ((PSERIAL_CHARS)abInBuffer)->XoffChar = GetRandomChar();

        SetInParam(dwInBuff, sizeof(SERIAL_CHARS));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

        break;

    case IOCTL_SERIAL_GET_HANDFLOW:
/*
typedef struct _SERIAL_HANDFLOW {
    ULONG ControlHandShake;
    ULONG FlowReplace;
    LONG XonLimit;
    LONG XoffLimit;
    } SERIAL_HANDFLOW,*PSERIAL_HANDFLOW;
*/
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(SERIAL_HANDFLOW));

        break;

    case IOCTL_SERIAL_SET_HANDFLOW:
        ((PSERIAL_HANDFLOW)abInBuffer)->ControlHandShake = GetRandomControlHandShake();
        ((PSERIAL_HANDFLOW)abInBuffer)->FlowReplace = GetRandomFlowReplace();
        ((PSERIAL_HANDFLOW)abInBuffer)->XonLimit = GetRandomXonLimit();
        ((PSERIAL_HANDFLOW)abInBuffer)->XoffLimit = GetRandomXoffLimit();

        SetInParam(dwInBuff, sizeof(SERIAL_HANDFLOW));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

        break;

    case IOCTL_SERIAL_GET_MODEMSTATUS:
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG));

        break;

    case IOCTL_SERIAL_GET_COMMSTATUS:
/*
typedef struct _SERIAL_STATUS {
    ULONG Errors;
    ULONG HoldReasons;
    ULONG AmountInInQueue;
    ULONG AmountInOutQueue;
    BOOLEAN EofReceived;
    BOOLEAN WaitForImmediate;
    } SERIAL_STATUS,*PSERIAL_STATUS;
*/
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(SERIAL_STATUS));

        break;

    case IOCTL_SERIAL_XOFF_COUNTER:
/*
typedef struct _SERIAL_XOFF_COUNTER {
    ULONG Timeout; // Zero based.  In milliseconds
    LONG Counter; // Must be greater than zero.
    UCHAR XoffChar;
    } SERIAL_XOFF_COUNTER,*PSERIAL_XOFF_COUNTER;
*/
        ((PSERIAL_XOFF_COUNTER)abInBuffer)->Timeout = GetRandomXoffTimeout();
        ((PSERIAL_XOFF_COUNTER)abInBuffer)->Counter = GetRandomXoffCounter();
        ((PSERIAL_XOFF_COUNTER)abInBuffer)->XoffChar = GetRandomXoffChar();

        SetInParam(dwInBuff, sizeof(SERIAL_XOFF_COUNTER));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

        break;

    case IOCTL_SERIAL_GET_PROPERTIES:
/*
typedef struct _SERIAL_COMMPROP {
    USHORT PacketLength;
    USHORT PacketVersion;
    ULONG ServiceMask;
    ULONG Reserved1;
    ULONG MaxTxQueue;
    ULONG MaxRxQueue;
    ULONG MaxBaud;
    ULONG ProvSubType;
    ULONG ProvCapabilities;
    ULONG SettableParams;
    ULONG SettableBaud;
    USHORT SettableData;
    USHORT SettableStopParity;
    ULONG CurrentTxQueue;
    ULONG CurrentRxQueue;
    ULONG ProvSpec1;
    ULONG ProvSpec2;
    WCHAR ProvChar[1];
} SERIAL_COMMPROP,*PSERIAL_COMMPROP;
*/
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(SERIAL_COMMPROP));

        break;

    case IOCTL_SERIAL_GET_DTRRTS:
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG));

        break;

    case IOCTL_SERIAL_LSRMST_INSERT:
        SetInParam(dwInBuff, sizeof(UCHAR));

        SetOutParam(abOutBuffer, dwOutBuff, 0);


        break;

    case IOCTL_SERENUM_EXPOSE_HARDWARE:
        SetInParam(dwInBuff, rand()%200);

        SetOutParam(abOutBuffer, dwOutBuff, rand()%200);

        break;

    case IOCTL_SERENUM_REMOVE_HARDWARE:
        SetInParam(dwInBuff, rand()%200);

        SetOutParam(abOutBuffer, dwOutBuff, rand()%200);

        break;

    case IOCTL_SERENUM_PORT_DESC:
/*
typedef struct _SERENUM_PORT_DESC
{
    IN  ULONG               Size; // sizeof (struct _PORT_DESC)
    OUT PVOID               PortHandle;
    OUT PHYSICAL_ADDRESS    PortAddress;
        USHORT              Reserved[1];
} SERENUM_PORT_DESC, * PSERENUM_PORT_DESC;
*/
        SetInParam(dwInBuff, sizeof(SERENUM_PORT_DESC));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(SERENUM_PORT_DESC));

        break;

    case IOCTL_SERENUM_GET_PORT_NAME:
        SetInParam(dwInBuff, rand()%200);

        SetOutParam(abOutBuffer, dwOutBuff, rand()%200);

        break;

    case IOCTL_SERIAL_CONFIG_SIZE:
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG));

        break;

    case IOCTL_SERIAL_GET_COMMCONFIG:
/*
typedef struct _SERIALCONFIG {
    ULONG Size;
    USHORT Version;
    ULONG SubType;
    ULONG ProvOffset;
    ULONG ProviderSize;
    WCHAR ProviderData[1];
} SERIALCONFIG,*PSERIALCONFIG;
*/
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(SERIALCONFIG));

        break;

    case IOCTL_SERIAL_SET_COMMCONFIG:
        ((PSERIALCONFIG)abInBuffer)->Size = rand();
        ((PSERIALCONFIG)abInBuffer)->Version = rand()%20;
        ((PSERIALCONFIG)abInBuffer)->SubType = rand();
        ((PSERIALCONFIG)abInBuffer)->ProvOffset = rand();
        ((PSERIALCONFIG)abInBuffer)->ProviderSize = rand();
        //((PSERIALCONFIG)abInBuffer)->ProviderData = rand();

        SetInParam(dwInBuff, sizeof(SERIALCONFIG));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

        break;

    case IOCTL_SERIAL_GET_STATS:
/*
typedef struct _SERIALPERF_STATS {
    ULONG ReceivedCount;
    ULONG TransmittedCount;
    ULONG FrameErrorCount;
    ULONG SerialOverrunErrorCount;
    ULONG BufferOverrunErrorCount;
    ULONG ParityErrorCount;
} SERIALPERF_STATS, *PSERIALPERF_STATS;
*/
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(SERIALPERF_STATS));

        break;

    case IOCTL_SERIAL_CLEAR_STATS:

        break;

    case IOCTL_SERIAL_GET_MODEM_CONTROL:
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG));

        break;

    case IOCTL_SERIAL_SET_MODEM_CONTROL:
        *((ULONG*)abInBuffer) = GetRandomModemControl();
        SetInParam(dwInBuff, sizeof(ULONG));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

        break;

    case IOCTL_SERIAL_SET_FIFO_CONTROL:
        *((ULONG*)abInBuffer) = GetRandomFifoControl();
        SetInParam(dwInBuff, sizeof(ULONG));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

        break;

    case IOCTL_INTERNAL_SERENUM_REMOVE_SELF:

        break;

    default:
        ;
    }

}


BOOL CIoctlSerial::FindValidIOCTLs(CDevice *pDevice)
{
    AddIOCTL(pDevice, IOCTL_SERIAL_SET_BAUD_RATE);
    AddIOCTL(pDevice, IOCTL_SERIAL_SET_QUEUE_SIZE);
    AddIOCTL(pDevice, IOCTL_SERIAL_SET_LINE_CONTROL);
    AddIOCTL(pDevice, IOCTL_SERIAL_SET_BREAK_ON);
    AddIOCTL(pDevice, IOCTL_SERIAL_SET_BREAK_OFF);
    AddIOCTL(pDevice, IOCTL_SERIAL_IMMEDIATE_CHAR);
    AddIOCTL(pDevice, IOCTL_SERIAL_SET_TIMEOUTS);
    AddIOCTL(pDevice, IOCTL_SERIAL_GET_TIMEOUTS);
    AddIOCTL(pDevice, IOCTL_SERIAL_SET_DTR);
    AddIOCTL(pDevice, IOCTL_SERIAL_CLR_DTR);
    AddIOCTL(pDevice, IOCTL_SERIAL_RESET_DEVICE);
    AddIOCTL(pDevice, IOCTL_SERIAL_SET_RTS);
    AddIOCTL(pDevice, IOCTL_SERIAL_CLR_RTS);
    AddIOCTL(pDevice, IOCTL_SERIAL_SET_XOFF);
    AddIOCTL(pDevice, IOCTL_SERIAL_SET_XON);
    AddIOCTL(pDevice, IOCTL_SERIAL_GET_WAIT_MASK);
    AddIOCTL(pDevice, IOCTL_SERIAL_SET_WAIT_MASK);
    AddIOCTL(pDevice, IOCTL_SERIAL_WAIT_ON_MASK);
    AddIOCTL(pDevice, IOCTL_SERIAL_PURGE);
    AddIOCTL(pDevice, IOCTL_SERIAL_GET_BAUD_RATE);
    AddIOCTL(pDevice, IOCTL_SERIAL_GET_LINE_CONTROL);
    AddIOCTL(pDevice, IOCTL_SERIAL_GET_CHARS);
    AddIOCTL(pDevice, IOCTL_SERIAL_SET_CHARS);
    AddIOCTL(pDevice, IOCTL_SERIAL_GET_HANDFLOW);
    AddIOCTL(pDevice, IOCTL_SERIAL_SET_HANDFLOW);
    AddIOCTL(pDevice, IOCTL_SERIAL_GET_MODEMSTATUS);
    AddIOCTL(pDevice, IOCTL_SERIAL_GET_COMMSTATUS);
    AddIOCTL(pDevice, IOCTL_SERIAL_XOFF_COUNTER);
    AddIOCTL(pDevice, IOCTL_SERIAL_GET_PROPERTIES);
    AddIOCTL(pDevice, IOCTL_SERIAL_GET_DTRRTS);
    AddIOCTL(pDevice, IOCTL_SERIAL_LSRMST_INSERT);
    AddIOCTL(pDevice, IOCTL_SERENUM_EXPOSE_HARDWARE);
    AddIOCTL(pDevice, IOCTL_SERENUM_REMOVE_HARDWARE);
    AddIOCTL(pDevice, IOCTL_SERENUM_PORT_DESC);
    AddIOCTL(pDevice, IOCTL_SERENUM_GET_PORT_NAME);
    AddIOCTL(pDevice, IOCTL_SERIAL_CONFIG_SIZE);
    AddIOCTL(pDevice, IOCTL_SERIAL_GET_COMMCONFIG);
    AddIOCTL(pDevice, IOCTL_SERIAL_SET_COMMCONFIG);
    AddIOCTL(pDevice, IOCTL_SERIAL_GET_STATS);
    AddIOCTL(pDevice, IOCTL_SERIAL_CLEAR_STATS);
    AddIOCTL(pDevice, IOCTL_SERIAL_GET_MODEM_CONTROL);
    AddIOCTL(pDevice, IOCTL_SERIAL_SET_MODEM_CONTROL);
    AddIOCTL(pDevice, IOCTL_SERIAL_SET_FIFO_CONTROL);
    AddIOCTL(pDevice, IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS);

    return TRUE;
}


DWORD CIoctlSerial::GetRandomPurgeCommParams()
{
	DWORD deRetval = 0;
	if (0 == rand()%6) deRetval = deRetval | PURGE_TXABORT;
	if (0 == rand()%6) deRetval = deRetval | PURGE_RXABORT;
	if (0 == rand()%6) deRetval = deRetval | PURGE_TXCLEAR;
	if (0 == rand()%6) deRetval = deRetval | PURGE_RXCLEAR;

	return deRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\rasacdioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <windows.h>
*/
/*
#define _PNP_POWER_
#include "ntddip.h"
#include "icmpif.h"
#include "ipinfo.h"
*/



#include <acd.h>

#include "common.h"
#include "RasAcdIoctl.h"

static bool s_fVerbose = true;

static ACD_ADDR s_aACD_ADDR[MAX_NUM_OF_REMEMBERED_ITEMS];
static ULONG s_aulFlags[MAX_NUM_OF_REMEMBERED_ITEMS];
static ACD_ADAPTER s_aACD_ADAPTER[MAX_NUM_OF_REMEMBERED_ITEMS];
static HANDLE s_aPid[MAX_NUM_OF_REMEMBERED_ITEMS];

static HANDLE GetRandom_Pid();
static void Add_Pid(HANDLE Pid);
static void SetRandom_cMac(UCHAR *cMac);
static void SetRandom_AdapterName(WCHAR *szName);
static UCHAR GetRandom_bLana();
static void SetRandom_ACD_ADAPTER(ACD_ADAPTER *pACD_ADAPTER);
static void Add_ACD_ADAPTER(ACD_ADAPTER *pACD_ADAPTER);
static ULONG GetRandom_Flags();
static void Add_Flags(ULONG ulFlags);
static void SetRandom_szInet(UCHAR *szInet);
static void SetRandom_cNetbios(UCHAR *cNetbios);
static void SetRandom_cNode(UCHAR *cNode);
static ULONG GetRandom_Ipaddr();
static void Set_ACD_ADDR(ACD_ADDR *pACD_ADDR);
static void Add_ACD_ADDR(ACD_ADDR *pACD_ADDR);
static BOOL CIoctlRasAcd::FindValidIOCTLs(CDevice *pDevice);


BOOL CIoctlRasAcd::CloseDevice(CDevice *pDevice)
{
	return (CIoctlNtNative::CloseDevice(pDevice));
	//::InterlockedExchange(&m_fDriverStarted, FALSE);

	NTSTATUS status = NtClose(pDevice->m_hDevice);
	if (!NT_SUCCESS(status))
	{
		::SetLastError(RtlNtStatusToDosError(status));
	}
	else
	{
		_ASSERTE(STATUS_SUCCESS == status);
	}
	return (STATUS_SUCCESS == status);
}


void CIoctlRasAcd::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
	switch(dwIOCTL)
	{
	case IOCTL_ACD_NOTIFICATION:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);

		{
			Add_ACD_ADDR(&((ACD_NOTIFICATION*)abOutBuffer)->addr);
			Add_Flags(((ACD_NOTIFICATION*)abOutBuffer)->ulFlags);
			Add_ACD_ADAPTER(&((ACD_NOTIFICATION*)abOutBuffer)->adapter);
			Add_Pid(((ACD_NOTIFICATION*)abOutBuffer)->Pid);
		}
		break;
	}
		
}

void CIoctlRasAcd::CallRandomWin32API(LPOVERLAPPED pOL)
{
	//_ASSERTE(FALSE);
    ;
}


//TODO: complete this method!
void CIoctlRasAcd::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
	dwInBuff = rand();
	dwOutBuff = rand();

	switch(dwIOCTL)
	{
	case IOCTL_ACD_RESET          :
        SetInParam(dwInBuff, 0);
        SetOutParam(abOutBuffer, dwOutBuff, 0);
		break;

	case IOCTL_ACD_ENABLE          :
        *((BOOLEAN*)abInBuffer) = rand()%3;

        SetInParam(dwInBuff, sizeof(BOOLEAN));

        SetOutParam(abOutBuffer, dwOutBuff, 0);
		break;

	case IOCTL_ACD_NOTIFICATION          :
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(ACD_NOTIFICATION));
		break;

	case IOCTL_ACD_KEEPALIVE          :
	case IOCTL_ACD_COMPLETION          :
        ((ACD_STATUS*)abInBuffer)->fSuccess = rand()%3;
        Set_ACD_ADDR(&((ACD_STATUS*)abInBuffer)->addr);

        SetInParam(dwInBuff, (1+rand()%5)*sizeof(ACD_STATUS));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(ACD_STATUS));
		break;

	case IOCTL_ACD_CONNECT_ADDRESS          :
        Set_ACD_ADDR(&((ACD_NOTIFICATION*)abInBuffer)->addr);
        ((ACD_NOTIFICATION*)abInBuffer)->ulFlags = GetRandom_Flags();
        SetRandom_ACD_ADAPTER(&((ACD_NOTIFICATION*)abInBuffer)->adapter);
        ((ACD_NOTIFICATION*)abInBuffer)->Pid = GetRandom_Pid();

        SetInParam(dwInBuff, sizeof(ACD_NOTIFICATION));

        SetOutParam(abOutBuffer, dwOutBuff, 0);
		break;

	default:
		_tprintf(TEXT("CIoctlRasAcd::PrepareIOCTLParams() 0x%08X is an unexpected IOCTL\n"), dwIOCTL);
		_ASSERTE(FALSE);
		CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
	}
}


BOOL CIoctlRasAcd::FindValidIOCTLs(CDevice *pDevice)
{
	AddIOCTL(pDevice, IOCTL_ACD_RESET          );
	AddIOCTL(pDevice, IOCTL_ACD_ENABLE          );
	AddIOCTL(pDevice, IOCTL_ACD_NOTIFICATION          );
	AddIOCTL(pDevice, IOCTL_ACD_KEEPALIVE          );
	AddIOCTL(pDevice, IOCTL_ACD_COMPLETION          );
	AddIOCTL(pDevice, IOCTL_ACD_CONNECT_ADDRESS          );

    return TRUE;
}

void Add_ACD_ADDR(ACD_ADDR *pACD_ADDR)
{
	s_aACD_ADDR[rand()%MAX_NUM_OF_REMEMBERED_ITEMS] = *pACD_ADDR;
}

void Set_ACD_ADDR(ACD_ADDR *pACD_ADDR)
{
	if (rand()%4)
	{
		*pACD_ADDR = s_aACD_ADDR[rand()%MAX_NUM_OF_REMEMBERED_ITEMS];
		return;
	}

	switch(rand()%(ACD_ADDR_MAX+1))
	{
	case 0: 
		pACD_ADDR->fType = ACD_ADDR_IP;
		pACD_ADDR->ulIpaddr = GetRandom_Ipaddr();

		break;

	case 1: 
		pACD_ADDR->fType = ACD_ADDR_IPX;
		SetRandom_cNode(pACD_ADDR->cNode);

		break;

	case 2: 
		pACD_ADDR->fType = ACD_ADDR_NB;
		SetRandom_cNetbios(pACD_ADDR->cNetbios);

		break;

	case 3: 
		pACD_ADDR->fType = ACD_ADDR_INET;
		SetRandom_szInet(pACD_ADDR->szInet);

		break;

	default: 
		pACD_ADDR->fType = (ACD_ADDR_TYPE)rand();
	}
}

ULONG GetRandom_Ipaddr()
{
	if (0 == rand()%2) return (s_aACD_ADDR[rand()%MAX_NUM_OF_REMEMBERED_ITEMS].ulIpaddr);
	if (0 == rand()%2) return 0xFFFFFFFF;
	if (0 == rand()%2) return 0;
	return DWORD_RAND;
}

void SetRandom_cNode(UCHAR *cNode)
{
	strcpy((char*)cNode, (const char*)s_aACD_ADDR[rand()%MAX_NUM_OF_REMEMBERED_ITEMS].cNode);
	//
	// TODO: i have no idea how this should look like, if i were to randomly generate it
	//
	return;
}


void SetRandom_cNetbios(UCHAR *cNetbios)
{
	if (0 == rand()%2)
	{
		strcpy((char*)cNetbios, (const char*)s_aACD_ADDR[rand()%MAX_NUM_OF_REMEMBERED_ITEMS].cNetbios);
		return;
	}
	strcpy((char*)cNetbios, ::GetRandomMachineName());
}

void SetRandom_szInet(UCHAR *szInet)
{
	if (0 == rand()%2)
	{
		strcpy((char*)szInet, (const char*)s_aACD_ADDR[rand()%MAX_NUM_OF_REMEMBERED_ITEMS].szInet);
		return;
	}
	strcpy((char*)szInet, ::GetRandomInternetAddress());
}


void Add_Flags(ULONG ulFlags)
{
	s_aulFlags[rand()%MAX_NUM_OF_REMEMBERED_ITEMS] = ulFlags;
}

ULONG GetRandom_Flags()
{
	if (rand()%2) return s_aulFlags[rand()%MAX_NUM_OF_REMEMBERED_ITEMS];
	if (rand()%2) return ACD_NOTIFICATION_SUCCESS;
	if (rand()%2) return 0;
	if (rand()%2) return rand();
	return DWORD_RAND;
}


void Add_ACD_ADAPTER(ACD_ADAPTER *pACD_ADAPTER)
{
	s_aACD_ADAPTER[rand()%MAX_NUM_OF_REMEMBERED_ITEMS] = *pACD_ADAPTER;
}

void SetRandom_ACD_ADAPTER(ACD_ADAPTER *pACD_ADAPTER)
{
	if (rand()%4) 
	{
		*pACD_ADAPTER = s_aACD_ADAPTER[rand()%MAX_NUM_OF_REMEMBERED_ITEMS];
		return;
	}

	switch(rand()%(ACD_ADDR_MAX+1))
	{
	case 0: 
		pACD_ADAPTER->fType = (enum ACD_ADAPTER_TYPE)ACD_ADAPTER_LANA;
		pACD_ADAPTER->bLana = GetRandom_bLana();

		break;

	case 1: 
		pACD_ADAPTER->fType = (enum ACD_ADAPTER_TYPE)ACD_ADAPTER_IP;
		pACD_ADAPTER->ulIpaddr = GetRandom_Ipaddr();

		break;

	case 2: 
		pACD_ADAPTER->fType = (enum ACD_ADAPTER_TYPE)ACD_ADAPTER_NAME;
		SetRandom_AdapterName(pACD_ADAPTER->szName);

		break;

	case 3: 
		pACD_ADAPTER->fType = (enum ACD_ADAPTER_TYPE)ACD_ADAPTER_MAC;
		SetRandom_cMac(pACD_ADAPTER->cMac);

		break;

	default: 
		pACD_ADAPTER->fType = (enum ACD_ADAPTER_TYPE)rand();
	}
}

UCHAR GetRandom_bLana()
{
	if (rand()%4) return (s_aACD_ADAPTER[rand()%MAX_NUM_OF_REMEMBERED_ITEMS].bLana);
	if (rand()%2) return (0);
	if (rand()%2) return (0xff);
	return (rand());
}

void SetRandom_AdapterName(WCHAR *szName)
{
	if (0 == rand()%2)
	{
		strcpy((char*)szName, (const char*)s_aACD_ADAPTER[rand()%MAX_NUM_OF_REMEMBERED_ITEMS].szName);
		return;
	}
	lstrcpyW(szName, ::GetRandomAdapterName());
}

void SetRandom_cMac(UCHAR *cMac)
{
	if (0 == rand()%2)
	{
		strcpy((char*)cMac, (const char*)s_aACD_ADAPTER[rand()%MAX_NUM_OF_REMEMBERED_ITEMS].cMac);
		return;
	}
	//strcpy(cMac, ::GetRandomIpxMacAddress());
}


void Add_Pid(HANDLE Pid)
{
	s_aPid[rand()%MAX_NUM_OF_REMEMBERED_ITEMS] = Pid;
}

HANDLE GetRandom_Pid()
{
	if (rand()%4) return (s_aPid[rand()%MAX_NUM_OF_REMEMBERED_ITEMS]);
	if (rand()%2) return ((HANDLE)rand());
	return ((HANDLE)DWORD_RAND);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\prnioctl.h ===
#ifndef __PRN_IOCTL_H
#define __PRN_IOCTL_H

//#include "IOCTL.h"


class CIoctlPRN : public CIoctl
{
public:
    CIoctlPRN(CDevice *pDevice): CIoctl(pDevice){;};
    virtual ~CIoctlPRN(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

private:
	UCHAR m_ucStatus;
	ULONG m_ulDeviceIdSize;
};




#endif //__PRN_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\rasacdioctl.h ===
#ifndef __RASACD_IOCTL_H
#define __RASACD_IOCTL_H

//#include "NtNativeIOCTL.h"


class CIoctlRasAcd : public CIoctlNtNative
{
public:
    CIoctlRasAcd(CDevice *pDevice): CIoctlNtNative(pDevice)
	{
		_ASSERTE(0 == lstrcmpi(TEXT("\\Device\\RasAcd"), pDevice->GetDeviceName()));
	}
    virtual ~CIoctlRasAcd(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

	virtual BOOL CloseDevice(CDevice *pDevice);

/*

	virtual HANDLE CreateDevice(CDevice *pDevice);

	virtual BOOL DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		);

	virtual BOOL DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		);

	virtual BOOL DeviceCancelIo(
		HANDLE hFile  // file handle for which to cancel I/O
		);


	virtual BOOL DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		);
*/

private:


};




#endif //__RASACD_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\prnioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*



#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
*/

static bool s_fVerbose = false;

#include <ntddpar.h>

#include "PRNIOCTL.h"




void CIoctlPRN::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
	//
	// wait for the result only 1 time out of 10, because
	// i do not want to block too much, and i like to cancel pending requests
	//
	if (pOL && rand()%10) return;

	DWORD dwBytes = 0;
	if (pOL && !::GetOverlappedResult(m_pDevice->m_hDevice, pOL, &dwBytes, TRUE)) return;

	switch(dwIOCTL)
	{
	case IOCTL_PAR_QUERY_INFORMATION:
		m_ucStatus = ((PPAR_QUERY_INFORMATION)abOutBuffer)->Status;
		break;

	case IOCTL_PAR_SET_INFORMATION:
		break;

	case IOCTL_PAR_QUERY_DEVICE_ID:
		break;

	case IOCTL_PAR_QUERY_DEVICE_ID_SIZE:
		m_ulDeviceIdSize = ((PPAR_DEVICE_ID_SIZE_INFORMATION)abOutBuffer)->DeviceIdSize;
		break;

	case IOCTL_IEEE1284_GET_MODE:
		break;

	case IOCTL_IEEE1284_NEGOTIATE:
		break;

	case IOCTL_PAR_SET_WRITE_ADDRESS:
		break;

	case IOCTL_PAR_SET_READ_ADDRESS:
		break;

	case IOCTL_PAR_GET_DEVICE_CAPS:
		break;

	case IOCTL_PAR_GET_DEFAULT_MODES:
		break;

	case IOCTL_PAR_PING:
		break;

	case IOCTL_PAR_QUERY_RAW_DEVICE_ID:
		break;

	case IOCTL_PAR_ECP_HOST_RECOVERY:
		break;

	case IOCTL_PAR_GET_READ_ADDRESS:
		break;

	case IOCTL_PAR_GET_WRITE_ADDRESS:
		break;

	case IOCTL_PAR_TEST:
		break;
/*
	case IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE:
		break;

	case IOCTL_INTERNAL_GET_PARALLEL_PORT_INFO:
		break;

	case IOCTL_INTERNAL_PARALLEL_CONNECT_INTERRUPT:
		break;

	case IOCTL_INTERNAL_PARALLEL_DISCONNECT_INTERRUPT:
		break;

	case IOCTL_INTERNAL_RELEASE_PARALLEL_PORT_INFO:
		break;

	case IOCTL_INTERNAL_PARALLEL_CLEAR_CHIP_MODE:
		break;

	case IOCTL_INTERNAL_GET_MORE_PARALLEL_PORT_INFO:
		break;

  case IOCTL_INTERNAL_PARCHIP_CONNECT:
		break;

	case IOCTL_INTERNAL_PARALLEL_SET_CHIP_MODE:
		break;

	case IOCTL_INTERNAL_GET_PARALLEL_PNP_INFO:
		break;

	case IOCTL_INTERNAL_INIT_1284_3_BUS:
		break;

	case IOCTL_INTERNAL_SELECT_DEVICE:
		break;

	case IOCTL_INTERNAL_PARCLASS_CONNECT:
		break;

	case IOCTL_INTERNAL_PARCLASS_DISCONNECT:
		break;

	case IOCTL_INTERNAL_DISCONNECT_IDLE:
		break;

	case IOCTL_INTERNAL_LOCK_PORT:
		break;

	case IOCTL_INTERNAL_UNLOCK_PORT:
		break;

	case IOCTL_INTERNAL_PARALLEL_PORT_FREE:
		break;

	case IOCTL_INTERNAL_PARDOT3_CONNECT:
		break;

	case IOCTL_INTERNAL_PARDOT3_DISCONNECT:
		break;

	case IOCTL_INTERNAL_PARDOT3_RESET:
		break;

	case IOCTL_INTERNAL_PARDOT3_SIGNAL:
		break;

	case IOCTL_INTERNAL_REGISTER_FOR_REMOVAL_RELATIONS:
		break;

	case IOCTL_INTERNAL_UNREGISTER_FOR_REMOVAL_RELATIONS:
		break;
*/

	default:
		return;
	}
}

void CIoctlPRN::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
	switch(dwIOCTL)
	{
	case IOCTL_PAR_QUERY_INFORMATION:
        SetOutParam(abOutBuffer, dwOutBuff, sizeof(PAR_QUERY_INFORMATION));
		break;

	case IOCTL_PAR_SET_INFORMATION:
        ((PPAR_SET_INFORMATION)abInBuffer)->Init = rand()%2 ? (0x1 << rand()%8) : (rand()%0xff);
        SetInParam(dwInBuff, sizeof(PAR_SET_INFORMATION));
		break;

	case IOCTL_PAR_QUERY_DEVICE_ID:
        SetOutParam(abOutBuffer, dwOutBuff, rand());
		break;

	case IOCTL_PAR_QUERY_DEVICE_ID_SIZE:
        SetOutParam(abOutBuffer, dwOutBuff, sizeof(PAR_DEVICE_ID_SIZE_INFORMATION));
		break;

	case IOCTL_IEEE1284_GET_MODE:
	case IOCTL_IEEE1284_NEGOTIATE:
	case IOCTL_PAR_SET_WRITE_ADDRESS:
	case IOCTL_PAR_SET_READ_ADDRESS:
	case IOCTL_PAR_GET_DEVICE_CAPS:
	case IOCTL_PAR_GET_DEFAULT_MODES:
	case IOCTL_PAR_PING:
	case IOCTL_PAR_QUERY_RAW_DEVICE_ID:
	case IOCTL_PAR_ECP_HOST_RECOVERY:
	case IOCTL_PAR_GET_READ_ADDRESS:
	case IOCTL_PAR_GET_WRITE_ADDRESS:
	case IOCTL_PAR_TEST:
/*
	case IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE:
		break;

	case IOCTL_INTERNAL_GET_PARALLEL_PORT_INFO:
		break;

	case IOCTL_INTERNAL_PARALLEL_CONNECT_INTERRUPT:
		break;

	case IOCTL_INTERNAL_PARALLEL_DISCONNECT_INTERRUPT:
		break;

	case IOCTL_INTERNAL_RELEASE_PARALLEL_PORT_INFO:
		break;

	case IOCTL_INTERNAL_PARALLEL_CLEAR_CHIP_MODE:
		break;

	case IOCTL_INTERNAL_GET_MORE_PARALLEL_PORT_INFO:
		break;

  case IOCTL_INTERNAL_PARCHIP_CONNECT:
		break;

	case IOCTL_INTERNAL_PARALLEL_SET_CHIP_MODE:
		break;

	case IOCTL_INTERNAL_GET_PARALLEL_PNP_INFO:
		break;

	case IOCTL_INTERNAL_INIT_1284_3_BUS:
		break;

	case IOCTL_INTERNAL_SELECT_DEVICE:
		break;

	case IOCTL_INTERNAL_PARCLASS_CONNECT:
		break;

	case IOCTL_INTERNAL_PARCLASS_DISCONNECT:
		break;

	case IOCTL_INTERNAL_DISCONNECT_IDLE:
		break;

	case IOCTL_INTERNAL_LOCK_PORT:
		break;

	case IOCTL_INTERNAL_UNLOCK_PORT:
		break;

	case IOCTL_INTERNAL_PARALLEL_PORT_FREE:
		break;

	case IOCTL_INTERNAL_PARDOT3_CONNECT:
		break;

	case IOCTL_INTERNAL_PARDOT3_DISCONNECT:
		break;

	case IOCTL_INTERNAL_PARDOT3_RESET:
		break;

	case IOCTL_INTERNAL_PARDOT3_SIGNAL:
		break;

	case IOCTL_INTERNAL_REGISTER_FOR_REMOVAL_RELATIONS:
		break;

	case IOCTL_INTERNAL_UNREGISTER_FOR_REMOVAL_RELATIONS:
		break;
*/

	default:
		CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
		return;
	}
}


BOOL CIoctlPRN::FindValidIOCTLs(CDevice *pDevice)
{
    BOOL bRet = TRUE;
    DPF((TEXT("FindValidIOCTLs() %s is known, will use known IOCTLs\n"), pDevice->GetDeviceName()));

    AddIOCTL(pDevice, IOCTL_PAR_QUERY_INFORMATION);
    AddIOCTL(pDevice, IOCTL_PAR_SET_INFORMATION);
    AddIOCTL(pDevice, IOCTL_PAR_QUERY_DEVICE_ID);
    AddIOCTL(pDevice, IOCTL_PAR_QUERY_DEVICE_ID_SIZE);
    AddIOCTL(pDevice, IOCTL_IEEE1284_GET_MODE);
    AddIOCTL(pDevice, IOCTL_IEEE1284_NEGOTIATE);
    AddIOCTL(pDevice, IOCTL_PAR_SET_WRITE_ADDRESS);
    AddIOCTL(pDevice, IOCTL_PAR_SET_READ_ADDRESS);
    AddIOCTL(pDevice, IOCTL_PAR_GET_DEVICE_CAPS);
    AddIOCTL(pDevice, IOCTL_PAR_GET_DEFAULT_MODES);
    AddIOCTL(pDevice, IOCTL_PAR_PING);
    AddIOCTL(pDevice, IOCTL_PAR_QUERY_RAW_DEVICE_ID);
    AddIOCTL(pDevice, IOCTL_PAR_ECP_HOST_RECOVERY);
    AddIOCTL(pDevice, IOCTL_PAR_GET_READ_ADDRESS);
    AddIOCTL(pDevice, IOCTL_PAR_GET_WRITE_ADDRESS);
    AddIOCTL(pDevice, IOCTL_PAR_TEST);
/*
    AddIOCTL(pDevice, IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE);
    AddIOCTL(pDevice, IOCTL_INTERNAL_GET_PARALLEL_PORT_INFO);
    AddIOCTL(pDevice, IOCTL_INTERNAL_PARALLEL_CONNECT_INTERRUPT);
    AddIOCTL(pDevice, IOCTL_INTERNAL_PARALLEL_DISCONNECT_INTERRUPT);
    AddIOCTL(pDevice, IOCTL_INTERNAL_RELEASE_PARALLEL_PORT_INFO);
    AddIOCTL(pDevice, IOCTL_INTERNAL_GET_MORE_PARALLEL_PORT_INFO);
    AddIOCTL(pDevice, IOCTL_INTERNAL_PARCHIP_CONNECT);
    AddIOCTL(pDevice, IOCTL_INTERNAL_PARALLEL_SET_CHIP_MODE);
    AddIOCTL(pDevice, IOCTL_INTERNAL_PARALLEL_CLEAR_CHIP_MODE);
    AddIOCTL(pDevice, IOCTL_INTERNAL_GET_PARALLEL_PNP_INFO);
    AddIOCTL(pDevice, IOCTL_INTERNAL_INIT_1284_3_BUS);
    AddIOCTL(pDevice, IOCTL_INTERNAL_SELECT_DEVICE);
    AddIOCTL(pDevice, IOCTL_INTERNAL_DESELECT_DEVICE);
    AddIOCTL(pDevice, IOCTL_INTERNAL_PARCLASS_CONNECT);
    AddIOCTL(pDevice, IOCTL_INTERNAL_PARCLASS_DISCONNECT);
    AddIOCTL(pDevice, IOCTL_INTERNAL_DISCONNECT_IDLE);
    AddIOCTL(pDevice, IOCTL_INTERNAL_LOCK_PORT);
    AddIOCTL(pDevice, IOCTL_INTERNAL_UNLOCK_PORT);
    AddIOCTL(pDevice, IOCTL_INTERNAL_PARALLEL_PORT_FREE);
    AddIOCTL(pDevice, IOCTL_INTERNAL_PARDOT3_CONNECT);
    AddIOCTL(pDevice, IOCTL_INTERNAL_PARDOT3_DISCONNECT);
    AddIOCTL(pDevice, IOCTL_INTERNAL_PARDOT3_RESET);
    AddIOCTL(pDevice, IOCTL_INTERNAL_PARDOT3_SIGNAL);
    AddIOCTL(pDevice, IOCTL_INTERNAL_REGISTER_FOR_REMOVAL_RELATIONS);
    AddIOCTL(pDevice, IOCTL_INTERNAL_UNREGISTER_FOR_REMOVAL_RELATIONS);

    AddIOCTL(pDevice, 0x160004);
    AddIOCTL(pDevice, 0x160008);
    AddIOCTL(pDevice, 0x16000c);
    AddIOCTL(pDevice, 0x160010);
    AddIOCTL(pDevice, 0x160014);
    AddIOCTL(pDevice, 0x160018);
    AddIOCTL(pDevice, 0x16001c);
    AddIOCTL(pDevice, 0x160020);
    AddIOCTL(pDevice, 0x160024);
    AddIOCTL(pDevice, 0x160028);
    AddIOCTL(pDevice, 0x16002c);
    AddIOCTL(pDevice, 0x160030);
    AddIOCTL(pDevice, 0x160034);
    AddIOCTL(pDevice, 0x160038);
    AddIOCTL(pDevice, 0x16003c);
    AddIOCTL(pDevice, 0x160050);
    AddIOCTL(pDevice, 0x1b0020);
*/
    return TRUE;
}


void CIoctlPRN::CallRandomWin32API(LPOVERLAPPED pOL)
{
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\serialioctl.h ===
#ifndef __SERIAL_IOCTL_H
#define __SERIAL_IOCTL_H

//#include "IOCTL.h"


class CIoctlSerial : public CIoctl
{
public:
    CIoctlSerial(CDevice *pDevice): CIoctl(pDevice){;};
    virtual ~CIoctlSerial(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	//
	// override this method, if you wish to randomly call any API
	// usually you will call API relevant to your device, but you can call whatever you like
	//
	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

private:
	DWORD GetRandomPurgeCommParams();
};




#endif //__SERIAL_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\portapi.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    portapi.h

Abstract:

    Mapping Win32 API to HRESULT APIs.

Author:

    Erez Haba (erezh) 23-Jan-96

Revision History:

--*/

#ifndef _PORTAPI_H
#define _PORTAPI_H


// --- declerations ---------------------------------------
//
// Porting to Windows NT
//

EXTERN_C
{

//
// Define the base asynchronous I/O argument types
//

typedef struct _IO_STATUS_BLOCK {
    NTSTATUS Status;
    ULONG Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

//
// Define an Asynchronous Procedure Call from I/O viewpoint
//

typedef
VOID
(*PIO_APC_ROUTINE) (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );

NTSYSAPI
NTSTATUS
NTAPI
NtClose(
    IN HANDLE Handle
    );

NTSYSAPI
NTSTATUS
NTAPI
NtDeviceIoControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );

#ifdef MQWIN95
NTSYSAPI
HANDLE
NTAPI
ACpCreateFileW(
    LPCWSTR lpFileName,
    ULONG dwDesiredAccess,
    ULONG dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    ULONG dwCreationDisposition,
    ULONG dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );
#else
#define ACpCreateFileW CreateFileW
#endif  //MQWIN95

#ifdef MQWIN95
NTSYSAPI
BOOL
NTAPI
ACpDuplicateHandle(
    HANDLE hSourceProcessHandle,	// handle to process with handle to duplicate 
    HANDLE hSourceHandle,	        // handle to duplicate 
    HANDLE hTargetProcessHandle,	// handle to process to duplicate to 
    LPHANDLE lpTargetHandle,	    // pointer to duplicate handle 
    DWORD dwDesiredAccess,	        // access for duplicate handle 
    BOOL bInheritHandle,	        // handle inheritance flag
    DWORD dwOptions 	            // optional actions 
   );
#define MQpDuplicateHandle ACpDuplicateHandle
#else
#define MQpDuplicateHandle DuplicateHandle
#endif  //MQWIN95
} // EXTERN_C

// --- implementation -------------------------------------
//
// Mapped Win32 APIs
//

inline
HRESULT
MQpCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDistribution,
    DWORD dwFlagsAndAttributes,
    PHANDLE pHandle
   )
{
    HANDLE hFile = ACpCreateFileW(
                    lpFileName,
                    dwDesiredAccess,
                    dwShareMode,
                    lpSecurityAttributes,
                    dwCreationDistribution,
                    dwFlagsAndAttributes,
                    0
                    );

    if(hFile == INVALID_HANDLE_VALUE)
    {
        //
        //  The create can fail on either, the AC driver has not been
        //  started, or this is not the QM service.
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *pHandle = hFile;

    return STATUS_SUCCESS;
}


inline
HRESULT
MQpCloseHandle(
    HANDLE handle
    )
{
    NTSTATUS rc = NtClose(handle);

    ASSERT(rc != MQ_ERROR_DEBUG);

    //
    //  BUGBUG: set correct facility to falcon
    //
    return rc;
}

inline
HRESULT
MQpDeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPOVERLAPPED lpOverlapped
    )
{
    ASSERT(lpOverlapped != 0);

    //
    //  NOTE: This section was taken out of NT source code.
    //

    lpOverlapped->Internal = STATUS_PENDING;

    NTSTATUS rc;
    rc = NtDeviceIoControlFile(
            hDevice,
            lpOverlapped->hEvent,
            0,  // APC routine
            ((DWORD)lpOverlapped->hEvent & 1) ? 0 : lpOverlapped,
            (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
            dwIoControlCode,
            lpInBuffer,
            nInBufferSize,
            lpOutBuffer,
            nOutBufferSize
            );

    ASSERT(rc != MQ_ERROR_DEBUG);

    //
    //  BUGBUG: set correct facility to falcon
    //
    return rc;
}

inline
HRESULT
MQpDeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize
    )
{
    static IO_STATUS_BLOCK Iosb;

    NTSTATUS rc;
    rc = NtDeviceIoControlFile(
            hDevice,
            0,
            0,             // APC routine
            0,             // APC Context
            &Iosb,
            dwIoControlCode,  // IoControlCode
            lpInBuffer,       // Buffer for data to the FS
            nInBufferSize,
            lpOutBuffer,      // OutputBuffer for data from the FS
            nOutBufferSize    // OutputBuffer Length
            );

    ASSERT(rc != MQ_ERROR_DEBUG);

    //
    //  BUGBUG: set correct facility to falcon
    //
    return rc;
}

#endif // _PORTAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\socketclientioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*

*/
#define MAX_PORT_NUM (0xFFFF)
//
// must be defined 1st to override winsock1
//
//#include <winsock2.h>


//
// defines for WSASocet() params
//
#define PROTO_TYPE_UNICAST          0 
#define PROTO_TYPE_MCAST            1 
#define PROTOCOL_ID(Type, VendorMajor, VendorMinor, Id) (((Type)<<28)|((VendorMajor)<<24)|((VendorMinor)<<16)|(Id)) 


/*
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
*/
#include "SocketClientIOCTL.h"

static bool s_fVerbose = false;

//
// LPWSAOVERLAPPED_COMPLETION_ROUTINE 
// we do not use it, but we need it defined for the overlapped UDP ::WSARecvFrom()
//
static void __stdcall fn(
    DWORD dwError,
    DWORD cbTransferred,
    LPWSAOVERLAPPED lpOverlapped,
    DWORD dwFlags
    )                                             
{
    UNREFERENCED_PARAMETER(dwError);
    UNREFERENCED_PARAMETER(cbTransferred);
    UNREFERENCED_PARAMETER(lpOverlapped);
    UNREFERENCED_PARAMETER(dwFlags);
    return;
}


CIoctlSocketClient::CIoctlSocketClient(CDevice *pDevice): 
	CIoctlSocket(pDevice)
{
	;
}

CIoctlSocketClient::~CIoctlSocketClient()
{
    ;
}


HANDLE CIoctlSocketClient::CreateDevice(CDevice *pDevice)
{    
	//
	// I want to have more chances of the server running 1st
	//
	::Sleep(1000);

	m_sListeningSocket = CreateSocket(pDevice);
	if (INVALID_SOCKET == m_sListeningSocket)
	{
		return INVALID_HANDLE_VALUE;
	}
/*
	if (!Bind(pDevice, CLIENT_SIDE))
	{
		goto error_exit;
	}
*/
    //
    // listen (on TCP) or WSARecvFrom (on UDP).
    // do not care if I fail.
    //
	{
		char *szServerIP = NULL;
#ifdef _UNICODE
		char ansiDeviceName[1024] = "Y";
		char cDefChar = 'X';
		BOOL fDefCharWasUsed = FALSE;
		int nRet = ::WideCharToMultiByte(
			CP_ACP,            // code page
			0,            // performance and mapping flags
			pDevice->GetDeviceName(),    // address of wide-character string
			::lstrlen(pDevice->GetDeviceName())+1,          // number of characters in string
			ansiDeviceName,     // address of buffer for new string
			sizeof(ansiDeviceName)-1,          // size of buffer
			&cDefChar,     // address of default for unmappable characters
			&fDefCharWasUsed  // address of flag set when default char. used
			);
		_ASSERTE(nRet);
		_ASSERTE(!fDefCharWasUsed);
		ansiDeviceName[::lstrlen(pDevice->GetDeviceName())] = '\0';
		szServerIP = ansiDeviceName;
#else
		szServerIP = pDevice->GetDeviceName();
#endif
/*
		DPF((TEXT("pDevice->GetDeviceName()=%s\n"), pDevice->GetDeviceName()));

		//
		// ANSI!
		//
		printf("szServerIP=%s\n", szServerIP);
*/
		SOCKADDR_IN srv_addr;
	    ZERO_STRUCT(srv_addr);
		srv_addr.sin_family = AF_INET;
		srv_addr.sin_addr.s_addr = inet_addr(szServerIP);
		srv_addr.sin_port = GetServerPort(pDevice);

		//
		// BUGBUG: should i insist, due to fault injections? 
		//
		if (::connect(
				m_sListeningSocket, 
				(const struct sockaddr FAR*)&srv_addr, 
				sizeof(SOCKADDR_IN)
				) != 0
		   )
		{
			DPF((TEXT("connect(%d) failed with %d\n"), srv_addr.sin_port, ::WSAGetLastError()));
			// IOCTELL anyways;
		}
		else
		{
			DPF((TEXT("connect() succeeded\n")));
		}
	}

	return (HANDLE)m_sListeningSocket;
}

//
// server's port is appended to the real "device" name
// example:
// ---UseSymbolicName-socket-client-1025 = 157.58.196.134
// 1025 is the server's port
// 157.58.196.134 is the server's IP
//
u_short CIoctlSocketClient::GetServerPort(CDevice *pDevice)
{
	u_short retval = 0;
	TCHAR *szServerPort = _tcsstr(_tcsupr(pDevice->GetSymbolicDeviceName()), _tcsupr(TEXT(szANSI_SOCKET_CLIENT)));
	if (NULL == szServerPort)
	{
		DPF((TEXT("GetServerPort(%s): could not find \"%s\".\n"), pDevice->GetSymbolicDeviceName(), TEXT(szANSI_SOCKET_CLIENT)));
		_ASSERT(FALSE);
		return 0;
	}

	szServerPort += lstrlen(TEXT(szANSI_SOCKET_CLIENT));
	retval = htons(_ttoi(szServerPort));
//	DPF((TEXT("GetServerPort(%s, %s): returning %d=0x%08X.\n"), pDevice->GetSymbolicDeviceName(), szServerPort, retval, retval));
	return retval;
}

BOOL CIoctlSocketClient::CloseDevice(CDevice *pDevice)
{
    return CloseSocket(pDevice);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\socketserverioctl.h ===
#ifndef __SOCKET_SERVER_IOCTL_H
#define __SOCKET_SERVER_IOCTL_H

//#include "IOCTL.h"
#include "SocketIOCTL.h"


class CIoctlSocketServer : public CIoctlSocket
{
public:
    CIoctlSocketServer(CDevice *pDevice);
    virtual ~CIoctlSocketServer();

	HANDLE CreateDevice(CDevice *pDevice);
	BOOL CloseDevice(CDevice *pDevice);
};




#endif //__SOCKET_SERVER_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\socketclientioctl.h ===
#ifndef __SOCKET_CLIENT_IOCTL_H
#define __SOCKET_CLIENT_IOCTL_H

//#include "IOCTL.h"
#include "SocketIOCTL.h"

#define szANSI_SOCKET_CLIENT "-socket-client-"

class CIoctlSocketClient : public CIoctlSocket
{
public:
    CIoctlSocketClient(CDevice *pDevice);
    virtual ~CIoctlSocketClient();

	HANDLE CreateDevice(CDevice *pDevice);
	BOOL CloseDevice(CDevice *pDevice);

protected:
	virtual u_short GetServerPort(CDevice *pDevice);
};




#endif //__SOCKET_CLIENT_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\socketioctl.h ===
#ifndef __SOCKET_IOCTL_H
#define __SOCKET_IOCTL_H

#include "NullWindow.h"
//#include "IOCTL.h"


class CIoctlSocket : public CIoctl
{
public:
    CIoctlSocket(CDevice *pDevice);
    virtual ~CIoctlSocket();

	virtual HANDLE CreateDevice(CDevice *pDevice) = 0;
	BOOL CloseDevice(CDevice *pDevice) = 0;

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual BOOL DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		);


	//
	// override this method, if you wish to randomly call any API
	// usually you will call API relevant to your device, but you can call whatever you like
	//
	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

//protected:
	virtual SOCKET CreateSocket(CDevice *pDevice);
	bool CloseSocket(CDevice *pDevice);

	SOCKET m_sListeningSocket;
#define MAX_NUM_OF_ACCEPTING_SOCKETS 128
	SOCKET m_asAcceptingSocket[MAX_NUM_OF_ACCEPTING_SOCKETS];
	HANDLE m_ahTdiAddressHandle;
	HANDLE m_ahTdiConnectionHandle;
	HANDLE m_ahDeviceAfdHandle;
	HANDLE GetRandom_AcceptHandle();

#define SERVER_SIDE FALSE
#define CLIENT_SIDE TRUE
	bool CIoctlSocket::Bind(CDevice *pDevice, bool fIsClientSide);
	void PrintBindError(DWORD dwLastError);

	CNullWindow m_NullWindow;

	PVOID GetRandom_HeadOrTail(BYTE* abValidBuffer);
	HANDLE GetRandom_FileHandle();
	void TryToCreateFile();
	HANDLE m_hFile;
	long m_fFileOpened;

	static int GetRandomAFType();
	//static DWORD GetValidIoctl();
	UINT GetFreeRandomAsyncTaskHandleIndex();
	HANDLE GetRandomAsyncTaskHandle();
	static char* GetRandomMachineName();
	static char* GetRandomProtocolName();
	static int GetRandomProtocolNumber();
	static char* GetRandomServiceName();
	static char* GetRandomIP(DWORD *pdwLen);
	static unsigned int GetRandomGroup();
	static DWORD GetRandomTransmitFileFlags();
	static DWORD GetRandomAfdFlags();


#define MAX_NUM_OF_ASYNC_TASK_HANDLES 16
	HANDLE m_ahAsyncTaskHandles[MAX_NUM_OF_ASYNC_TASK_HANDLES];

	ULONG m_aSequence[MAX_NUM_OF_REMEMBERED_ITEMS];
	HANDLE m_ahEvents[MAX_NUM_OF_REMEMBERED_ITEMS];
	HANDLE GetRandomEventHandle();
	ULONG GetRandom_PollEvents();
	ULONG GetRandom_ShareAccess();
	ULONG GetRandom_TdiFlags();
	HANDLE GetRandom_RootEndpoint();
	HANDLE GetRandom_ConnectEndpoint();

	struct sockaddr m_AFD_RECV_DATAGRAM_INFO_Address;
	ULONG m_AFD_RECV_DATAGRAM_INFO_AddressLength;

private:
	OVERLAPPED m_OL;
	static long sm_lWSAStartedCount;//needed for initializing WSA only once
	static long sm_lWSAInitialized;//needed to avoid races of initialization
};

#endif //__SOCKET_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\socketioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <winsock2.h>
*/
#define MAX_PORT_NUM (0xFFFF)
//
// must be defined 1st to override winsock1
//
#include <mswsock.h>

#include <tdi.h>
#include <afd.h>


//
// defines for WSASocet() params
//
#define PROTO_TYPE_UNICAST          0 
#define PROTO_TYPE_MCAST            1 
#define PROTOCOL_ID(Type, VendorMajor, VendorMinor, Id) (((Type)<<28)|((VendorMajor)<<24)|((VendorMinor)<<16)|(Id)) 


enum {
	PLACE_HOLDER_ASYNC_GET_HOST_BY_ADDRESS = 0,
	PLACE_HOLDER_CANCEL_ASYNC_REQUEST,
	PLACE_HOLDER_ASYNC_GET_HOST_BY_NAME,
	PLACE_HOLDER_ASYNC_GET_PROTO_BY_NAME,
	PLACE_HOLDER_ASYNC_GET_PROTO_BY_NUMBER,
	PLACE_HOLDER_ASYNC_GET_SERV_BY_NAME,
	PLACE_HOLDER_ASYNC_GET_SERV_BY_PORT,
	PLACE_HOLDER_TRANSMIT_FILE,
	PLACE_HOLDER_LAST

};


//#include <windows.h>

#include "common.h"

#include "NtNativeIOCTL.h"

#include "SocketIOCTL.h"


///////////////////////////////////////////////
// from socktype.h
//////////////////////////////////////////////

typedef enum _SOCKET_STATE {
    SocketStateOpen,
    SocketStateBound,
    SocketStateBoundSpecific,           // Datagram only
    SocketStateConnected,               // VC only
    SocketStateClosing
} SOCKET_STATE, *PSOCKET_STATE;


//
// Part of socket information that needs to shared
// between processes.
//
typedef struct _SOCK_SHARED_INFO {
    SOCKET_STATE State;
    INT AddressFamily;
    INT SocketType;
    INT Protocol;
    INT LocalAddressLength;
    INT RemoteAddressLength;

    //
    // Socket options controlled by getsockopt(), setsockopt().
    //

    struct linger LingerInfo;
    ULONG SendTimeout;
    ULONG ReceiveTimeout;
    ULONG ReceiveBufferSize;
    ULONG SendBufferSize;
    struct {
        BOOLEAN Listening:1;
        BOOLEAN Broadcast:1;
        BOOLEAN Debug:1;
        BOOLEAN OobInline:1;
        BOOLEAN ReuseAddresses:1;
        BOOLEAN ExclusiveAddressUse:1;
        BOOLEAN NonBlocking:1;
        BOOLEAN DontUseWildcard:1;

        //
        // Shutdown state.
        //

        BOOLEAN ReceiveShutdown:1;
        BOOLEAN SendShutdown:1;

        BOOLEAN ConditionalAccept:1;
    };

    //
    // Snapshot of several parameters passed into WSPSocket() when
    // creating this socket. We need these when creating accept()ed
    // sockets.
    //

    DWORD CreationFlags;
    DWORD CatalogEntryId;
    DWORD ServiceFlags1;
    DWORD ProviderFlags;

    //
    // Group/QOS stuff.
    //

    GROUP GroupID;
    AFD_GROUP_TYPE GroupType;
    INT GroupPriority;

    //
    // Last error set on this socket, used to report the status of
    // non-blocking connects.
    //

    INT LastError;

    //
    // Info stored for WSAAsyncSelect().
    // (This sounds failry redicilous that someone can
    // share this info between processes, but it's been
    // that way since day one, so I won't risk changing it, VadimE).
    //

    union {
        HWND AsyncSelecthWnd;
        ULONGLONG AsyncSelectWnd64; // Hack for 64 bit compatibility
                                    // We shouldn't be passing this between
                                    // processes (see the comment above).
    };
    DWORD AsyncSelectSerialNumber;
    UINT AsyncSelectwMsg;
    LONG AsyncSelectlEvent;
    LONG DisabledAsyncSelectEvents;


} SOCK_SHARED_INFO, *PSOCK_SHARED_INFO;

///////////////////////////////////////////////
// end of socktype.h
//////////////////////////////////////////////

static bool s_fVerbose = false;



static void SetRandom_TDI_REQUEST(TDI_REQUEST *pTDI_REQUEST);
static PVOID GetRandomRequestNotifyObject();
static PVOID GetRandomRequestContext();
static TDI_STATUS GetRandomTdiStatus();
static CONNECTION_CONTEXT GetRandomConnectionContext();
static TDI_CONNECTION_INFORMATION* GetRandom_TDI_CONNECTION_INFORMATION();
static TDI_CONNECTION_INFORMATION* SetRandom_TDI_CONNECTION_INFORMATION(TDI_CONNECTION_INFORMATION *pTci);
static LARGE_INTEGER GetRandom_Timeout();
static ULONG GetRandom_DisconnectMode();
static ULONG GetRandom_QueryModeFlags();
static ULONG GetRandom_InformationType();
static void SetRandom_Context(void *pContext);
static LONG GetRandom_Sequence();
static ULONG GetRandom_ConnectDataLength();
static void Add_AFD_GROUP_INFO(AFD_GROUP_INFO *pAFD_GROUP_INFO);
static AFD_GROUP_INFO GetRandom_AFD_GROUP_INFO();
static LONG GetRandom_GroupID();
static ULONG GetRandom_Flags();
static LARGE_INTEGER GetRandom_WriteLength();
static LARGE_INTEGER GetRandom_Offset();
static ULONG GetRandom_SendPacketLength();
static void Add_AFD_LISTEN_RESPONSE_INFO(CIoctlSocket* pThis, AFD_LISTEN_RESPONSE_INFO* pAFD_LISTEN_RESPONSE_INFO);
static void Add_TRANSPORT_ADDRESS(CIoctlSocket* pThis, TRANSPORT_ADDRESS* pTRANSPORT_ADDRESS);
static void SetRandom_TRANSPORT_ADDRESS(CIoctlSocket* pThis, TRANSPORT_ADDRESS *pTRANSPORT_ADDRESS);
static void Add_TA_ADDRESS(CIoctlSocket* pThis, TA_ADDRESS *pTA_ADDRESS);
static void SetRandom_TA_ADDRESS(CIoctlSocket* pThis, TA_ADDRESS *pTA_ADDRESS);
static USHORT GetRandom_AddressType();
static void SetRand_Qos(QOS *pQOS);
static void SetRandom_FLOWSPEC(FLOWSPEC* pFLOWSPEC);
static WSABUF* SetRandom_WSABUF(WSABUF* pWSABUF);


static LONG s_aGroupID[MAX_NUM_OF_REMEMBERED_ITEMS];
static AFD_GROUP_TYPE s_aGroupType[MAX_NUM_OF_REMEMBERED_ITEMS];



//
// LPWSAOVERLAPPED_COMPLETION_ROUTINE 
// we do not use it, but we need it defined for the overlapped UDP ::WSARecvFrom()
//
static void __stdcall fn(
    DWORD dwError,
    DWORD cbTransferred,
    LPWSAOVERLAPPED lpOverlapped,
    DWORD dwFlags
    )                                             
{
    UNREFERENCED_PARAMETER(dwError);
    UNREFERENCED_PARAMETER(cbTransferred);
    UNREFERENCED_PARAMETER(lpOverlapped);
    UNREFERENCED_PARAMETER(dwFlags);
    return;
}


void PrintIPs();

static TA_ADDRESS* s_apTA_ADDRESS[MAX_NUM_OF_REMEMBERED_ITEMS];
static BYTE s_apbTA_ADDRESS_Buffers[MAX_NUM_OF_REMEMBERED_ITEMS][4*1024];
static long s_fFirstTime = TRUE;


CIoctlSocket::CIoctlSocket(CDevice *pDevice): 
	CIoctl(pDevice),
	m_hFile(INVALID_HANDLE_VALUE),
	m_fFileOpened(FALSE),
	m_ahDeviceAfdHandle(INVALID_HANDLE_VALUE)
{
	//
	// static initialization
	//
	if (::InterlockedExchange(&s_fFirstTime, FALSE))
	{
		for (int i = 0; i < MAX_NUM_OF_REMEMBERED_ITEMS; i++)
		{
			s_apTA_ADDRESS[i] = (TA_ADDRESS*)s_apbTA_ADDRESS_Buffers[i];
		}
	}

	ZeroMemory(&m_OL, sizeof(m_OL));

	while(!PrepareOverlappedStructure(&m_OL))
	{
		//
		// i cannot tolerate failure, so just keep trying
		//
		DPF((TEXT(".")));
	}

	for (int i = 0; i < ARRSIZE(m_ahEvents); i++)
	{
		m_ahEvents[i] = ::CreateEvent(NULL, TRUE, FALSE, NULL);
		//
		// don't care if i fail
		//
	}

	for (i = 0; i < MAX_NUM_OF_ASYNC_TASK_HANDLES; i++)
	{
		m_ahAsyncTaskHandles[i] = 0;
	}

	for (i = 0; i < MAX_NUM_OF_ACCEPTING_SOCKETS; i++)
	{
		m_asAcceptingSocket[i] = INVALID_SOCKET;
	}
	m_sListeningSocket = INVALID_SOCKET;

    if (1 == InterlockedIncrement(&sm_lWSAStartedCount))
    {
        WSADATA wsaData;
		int res;
		for (int i = 0; i < 1000; i++)
		{
			res = ::WSAStartup (MAKEWORD( 2, 2 ), &wsaData);
			if (0 != res)
			{
				::Sleep(100);
			}
			else
			{
				//
				// success
				//
				sm_lWSAInitialized = 1;
				break;
			}
		}
		
		if (0 != res)
		{
			DPF((TEXT("ERROR: WSAStartup() failed with %d. EXITING!\n"), ::WSAGetLastError()));
			_ASSERTE(FALSE);
			exit(-1);
			//
			// BUGBUG: no one knows that we failed, so the methods will just fail...
			//
			return;
		}
    }
	else
	{
		//
		// do not let other threads continue, it not initialized.
		// if initialization will fail, the exe will be aborted,
		// so there's no chance of an infinite loop
		//
		while(!sm_lWSAInitialized)
		{
			::Sleep(100);
		}
	}

	m_ahDeviceAfdHandle = CIoctlNtNative::StaticCreateDevice(L"\\Device\\Afd");
	// if this fails, something is really wrong here!
	_ASSERT(INVALID_HANDLE_VALUE != m_ahDeviceAfdHandle);
/*
	//
	// i don't have will power for success checking, so let take a big buffer, and believe it is enougbh
	//
	WSAPROTOCOL_INFO wsaProtocolInfo[MAX_NUM_OF_PROTOCOLS];
	DWORD dwBuffLen = sizeof(wsaProtocolInfo);
	if (SOCKET_ERROR == (m_nNumProtocols = ::WSAEnumProtocols (
			NULL,                   //all protocols
			wsaProtocolInfo,  
			&dwBuffLen             
			)))
	{
		DPF((TEXT("ERROR: WSAEnumProtocols() failed with %d.\n"), ::WSAGetLastError()));
		_ASSERTE(FALSE);
	}

	ZeroMemory(m_szProtocols, sizeof(m_szProtocols));

	DPF((TEXT("Supported protocols:\n"), ::WSAGetLastError()));
	for (int iProtocol = 0; iProtocol < m_nNumProtocols; iProtocol++)
	{
		lstrcpy(m_szProtocols[iProtocol], wsaProtocolInfo[iProtocol].szProtocol);
		DPF((TEXT("   %s.\n"), m_szProtocols[iProtocol]));
	}
*/	
/*
	PrintIPs();
	_ASSERTE(FALSE);
*/
}

CIoctlSocket::~CIoctlSocket()
{
	::CloseHandle(m_OL.hEvent);

	for (int i = 0; i < MAX_NUM_OF_ASYNC_TASK_HANDLES; i++)
	{
		if (m_ahAsyncTaskHandles[i])
		{
			WSACancelAsyncRequest(m_ahAsyncTaskHandles[i]);
			m_ahAsyncTaskHandles[i] = 0;
		}
	}

	for (i = 0; i < MAX_NUM_OF_ACCEPTING_SOCKETS; i++)
	{
		if (m_asAcceptingSocket[i] != INVALID_SOCKET)
		{
			::closesocket(m_asAcceptingSocket[i]);	
		}
	}
	if (m_sListeningSocket != INVALID_SOCKET)
	{
		::closesocket(m_sListeningSocket);
	}

	for (i = 0; i < ARRSIZE(m_ahEvents); i++)
	{
		if (NULL != m_ahEvents[i])
		{
			::CloseHandle(m_ahEvents[i]);
			//
			// don't care if i fail
			//
		}
	}
/*
    if (0 == InterlockedDecrement(&sm_lWSAStartedCount))
    {

I do not want to clenup, because there may be races, so lets just keep it not cleaned
		if (0 != ::WSACleanup())
        {
	        DPF((TEXT("WSACleanup() failed with %d.\n"), ::WSAGetLastError()));
        }
	}
*/
}



BOOL CIoctlSocket::DeviceInputOutputControl(
	HANDLE hDevice,              // handle to a device, file, or directory 
	DWORD dwIoControlCode,       // control code of operation to perform
	LPVOID lpInBuffer,           // pointer to buffer to supply input data
	DWORD nInBufferSize,         // size, in bytes, of input buffer
	LPVOID lpOutBuffer,          // pointer to buffer to receive output data
	DWORD nOutBufferSize,        // size, in bytes, of output buffer
	LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
	LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
	)
{
	switch(dwIoControlCode)
	{
		//
		// a WSA IOCTL
	case SIO_ASSOCIATE_HANDLE:
	case SIO_ENABLE_CIRCULAR_QUEUEING:
	case SIO_FIND_ROUTE:
	case SIO_FLUSH:
	case SIO_GET_BROADCAST_ADDRESS:
	case SIO_GET_EXTENSION_FUNCTION_POINTER:
	case SIO_GET_QOS:
	case SIO_GET_GROUP_QOS:
	case SIO_MULTIPOINT_LOOPBACK:
	case SIO_MULTICAST_SCOPE:
	case SIO_SET_QOS:
	case SIO_SET_GROUP_QOS:
	case SIO_TRANSLATE_HANDLE:
	case SIO_ROUTING_INTERFACE_QUERY:
	case SIO_ROUTING_INTERFACE_CHANGE:
	case SIO_ADDRESS_LIST_QUERY:
	case SIO_ADDRESS_LIST_CHANGE:
	case SIO_QUERY_TARGET_PNP_HANDLE:
		if (0 == ::WSAIoctl(
			(SOCKET)hDevice,                                               
			dwIoControlCode,       // control code of operation to perform
			lpInBuffer,           // pointer to buffer to supply input data
			nInBufferSize,         // size, in bytes, of input buffer
			lpOutBuffer,          // pointer to buffer to receive output data
			nOutBufferSize,        // size, in bytes, of output buffer
			lpBytesReturned,     // pointer to variable to receive byte count
			lpOverlapped,    // pointer to structure for asynchronous operation
			fn  
			))
		{
			return TRUE;
		}
		else
		{
			DWORD dwLastWSAError = ::WSAGetLastError();
			::SetLastError(dwLastWSAError);
			return FALSE;
		}
		break;

	default:
		//
		// a real IOCTL
		return ::DeviceIoControl(
			rand()%5 ? hDevice : rand()%2 ? (HANDLE)m_sListeningSocket : rand()%5 ? (HANDLE)m_asAcceptingSocket[0] : rand()%2 ? m_ahTdiAddressHandle : m_ahTdiConnectionHandle,              // handle to a device, file, or directory 
			dwIoControlCode,       // control code of operation to perform
			lpInBuffer,           // pointer to buffer to supply input data
			nInBufferSize,         // size, in bytes, of input buffer
			lpOutBuffer,          // pointer to buffer to receive output data
			nOutBufferSize,        // size, in bytes, of output buffer
			lpBytesReturned,     // pointer to variable to receive byte count
			lpOverlapped    // pointer to structure for asynchronous operation
			);
	}
}


long CIoctlSocket::sm_lWSAStartedCount = 0;
long CIoctlSocket::sm_lWSAInitialized = 0;

void CIoctlSocket::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
	switch(dwIOCTL)
	{
	case IOCTL_AFD_QUERY_HANDLES:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);

		{
			m_ahTdiAddressHandle = ((AFD_HANDLE_INFO*)abOutBuffer)->TdiAddressHandle;
			m_ahTdiConnectionHandle = ((AFD_HANDLE_INFO*)abOutBuffer)->TdiConnectionHandle;
		}
		break;

	case IOCTL_AFD_GET_CONTEXT:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);

		{
			//
			// We have obtained the necessary context for the socket.  The context
			// information is structured as follows:
			//
			//     SOCK_SHARED_INFO structure
			//     Helper DLL Context Length
			//     Local Address
			//     Remote Address
			//     Helper DLL Context
			//
			/*
			TODO: implement whatever is relevant below:
			Add_SOCKET_STATE(((SOCK_SHARED_INFO*)abOutBuffer)->State);
			Add_AddressFamily(((SOCK_SHARED_INFO*)abOutBuffer)->AddressFamily);
			Add_SocketType(((SOCK_SHARED_INFO*)abOutBuffer)->SocketType);
			Add_Protocol(((SOCK_SHARED_INFO*)abOutBuffer)->Protocol);
			Add_LocalAddressLength(((SOCK_SHARED_INFO*)abOutBuffer)->LocalAddressLength);
			Add_RemoteAddressLength(((SOCK_SHARED_INFO*)abOutBuffer)->RemoteAddressLength);
			Add_LingerInfo(((SOCK_SHARED_INFO*)abOutBuffer)->LingerInfo);
			Add_SendTimeout(((SOCK_SHARED_INFO*)abOutBuffer)->SendTimeout);
			Add_ReceiveTimeout(((SOCK_SHARED_INFO*)abOutBuffer)->ReceiveTimeout);
			Add_ReceiveBufferSize(((SOCK_SHARED_INFO*)abOutBuffer)->ReceiveBufferSize);
			Add_SendBufferSize(((SOCK_SHARED_INFO*)abOutBuffer)->SendBufferSize);
			Add_Listening(((SOCK_SHARED_INFO*)abOutBuffer)->Listening);
			Add_Broadcast(((SOCK_SHARED_INFO*)abOutBuffer)->Broadcast);
			Add_Debug(((SOCK_SHARED_INFO*)abOutBuffer)->Debug);
			Add_OobInline(((SOCK_SHARED_INFO*)abOutBuffer)->OobInline);
			Add_ReuseAddresses(((SOCK_SHARED_INFO*)abOutBuffer)->ReuseAddresses);
			Add_ExclusiveAddressUse(((SOCK_SHARED_INFO*)abOutBuffer)->ExclusiveAddressUse);
			Add_NonBlocking(((SOCK_SHARED_INFO*)abOutBuffer)->NonBlocking);
			Add_DontUseWildcard(((SOCK_SHARED_INFO*)abOutBuffer)->DontUseWildcard);
			Add_ReceiveShutdown(((SOCK_SHARED_INFO*)abOutBuffer)->ReceiveShutdown);
			Add_SendShutdown(((SOCK_SHARED_INFO*)abOutBuffer)->SendShutdown);
			Add_ConditionalAccept(((SOCK_SHARED_INFO*)abOutBuffer)->ConditionalAccept);
			Add_CreationFlags(((SOCK_SHARED_INFO*)abOutBuffer)->CreationFlags);
			Add_CatalogEntryId(((SOCK_SHARED_INFO*)abOutBuffer)->CatalogEntryId);
			Add_ServiceFlags1(((SOCK_SHARED_INFO*)abOutBuffer)->ServiceFlags1);
			Add_ProviderFlags(((SOCK_SHARED_INFO*)abOutBuffer)->ProviderFlags);
			Add_GroupID(((SOCK_SHARED_INFO*)abOutBuffer)->GroupID);
			Add_GroupType(((SOCK_SHARED_INFO*)abOutBuffer)->GroupType);
			Add_GroupPriority(((SOCK_SHARED_INFO*)abOutBuffer)->GroupPriority);
			Add_LastError(((SOCK_SHARED_INFO*)abOutBuffer)->LastError);
			Add_AsyncSelectWnd64(((SOCK_SHARED_INFO*)abOutBuffer)->AsyncSelectWnd64);
			Add_AsyncSelectSerialNumber(((SOCK_SHARED_INFO*)abOutBuffer)->AsyncSelectSerialNumber);
			Add_AsyncSelectwMsg(((SOCK_SHARED_INFO*)abOutBuffer)->AsyncSelectwMsg);
			Add_AsyncSelectlEvent(((SOCK_SHARED_INFO*)abOutBuffer)->AsyncSelectlEvent);
			Add_DisabledAsyncSelectEvents(((SOCK_SHARED_INFO*)abOutBuffer)->DisabledAsyncSelectEvents);
			*/
		}
		break;

	case IOCTL_AFD_GET_INFORMATION:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);

		{
			//
			// i think that only AFD_GROUP_ID_AND_TYPE retrieves info that i can use.
			//
			switch(((AFD_INFORMATION*)abOutBuffer)->InformationType)
			{
				case AFD_INLINE_MODE:
					// returns a boolean, so it is not intersting
					break;

				case AFD_NONBLOCKING_MODE:
					// returns a boolean, so it is not intersting
					break;

				case AFD_MAX_SEND_SIZE:
					// return MaxSendSize into afdInfo.Information.Ulong
					break;

				case AFD_SENDS_PENDING:
					break;

				case AFD_MAX_PATH_SEND_SIZE:
					break;

				case AFD_RECEIVE_WINDOW_SIZE:
					break;

				case AFD_SEND_WINDOW_SIZE:
					break;

				case AFD_CONNECT_TIME:
					break;

				case AFD_CIRCULAR_QUEUEING:
					break;

				case AFD_GROUP_ID_AND_TYPE:
					//
					// LargeInteger is actually AFD_GROUP_INFO if InformationType is AFD_GROUP_ID_AND_TYPE
					//
					Add_AFD_GROUP_INFO(((AFD_GROUP_INFO*)(&((AFD_INFORMATION*)abOutBuffer)->Information.LargeInteger.QuadPart)));
					break;

				default:
					_ASSERTE(!"CIoctlSocket::UseOutBuff(): reached default of AFD_INFORMATION::InformationType");

			}
		}
		break;

	case IOCTL_AFD_SUPER_ACCEPT:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);

		{
			Add_AFD_LISTEN_RESPONSE_INFO(this, &(((AFD_SUPER_ACCEPT_INFO*)abOutBuffer)->ListenResponseInfo));
		}
		break;

	case IOCTL_AFD_GET_ADDRESS:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);

		{
			Add_TRANSPORT_ADDRESS(this, &(((TDI_ADDRESS_INFO*)abOutBuffer)->Address));
		}
		break;

	case IOCTL_AFD_RECEIVE_DATAGRAM:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);

		{
			// no need to do anything, since i already gave pointer to members, so i can just use the members
		}
		break;

	case IOCTL_AFD_ADDRESS_LIST_QUERY:
		RANDOMLY_WAIT_FOR_OL_RESULT(100,20);

		{
			Add_TRANSPORT_ADDRESS(this, (TRANSPORT_ADDRESS*)abOutBuffer);
		}
		break;

	}
}

void CIoctlSocket::CallRandomWin32API(LPOVERLAPPED pOL)
{
	DWORD dwSwitch;

	//
	// handle the case in which I want only one API to be called
	//
	if	(-1 != m_pDevice->m_dwOnlyThisIndexIOCTL) 
	{
		//
		// only this one
		//
		dwSwitch = m_pDevice->m_dwOnlyThisIndexIOCTL;
	}
	else
	{
		//
		// a random one
		//
		dwSwitch = rand()%PLACE_HOLDER_LAST;
	}

	//
	// we need a window for the async functions, so as long as it is not initialized,
	// try hard to initialize it (remember we may be fault injected)
	//
	if (!m_NullWindow.m_fInitialized)
	{
		for (int i = 0; i < 1000; i++)
		{
			if (!m_NullWindow.Init())
			{
				::Sleep(100);
			}
			else
			{
				break;
			}
		}
	}
	// BUGBUG - m_NullWindow.Init() may have failed
	// but i will try next time, so we will use a null window handle 
	// in the meanwhile


	//
	// once in a while, get all messages, so that we will not "leak" them
	//
	if (m_NullWindow.WindowCreatedByThisThread() && (0 == rand()%100))
	{
		MSG msg;
		BOOL fGetMessage;
		for (;;)
		{
			fGetMessage = ::GetMessage(&msg, m_NullWindow.m_hWnd, 0, 1000);
			if (-1 == fGetMessage)
			{
				DPF((TEXT("GetMessage() failed with.\n"), ::GetLastError()));
				break;
			}
			if (0 == fGetMessage) 
			{
				DPF((TEXT("GetMessage() received WM_QUIT.\n")));
				break;//WM_QUIT
			}
			//DPF((TEXT("GetMessage() suceeded.\n")));
		}
	}

	switch(dwSwitch)
	{
	case PLACE_HOLDER_ASYNC_GET_HOST_BY_ADDRESS:
		{
			static /*_declspec(thread)*/ char buf[MAXGETHOSTSTRUCT];
			DWORD dwLen;
			ULONG ip = inet_addr(GetRandomIP(&dwLen));
			m_ahAsyncTaskHandles[GetFreeRandomAsyncTaskHandleIndex()] = ::WSAAsyncGetHostByAddr (
				m_NullWindow.m_hWnd,              
				3, //unsigned int wMsg,      
				(char*)&ip, //const char FAR *addr,  
				dwLen,                
				GetRandomAFType(),               
				buf,         
				MAXGETHOSTSTRUCT              
				);
		}
		break;

	case PLACE_HOLDER_ASYNC_GET_HOST_BY_NAME:
		{
			//
			// must be static, because it gets filled asynchronously
			// also, i don't care for the contents
			//
			static /*_declspec(thread)*/ char buf[MAXGETHOSTSTRUCT];
			HANDLE h = ::WSAAsyncGetHostByName (
			//m_ahAsyncTaskHandles[GetFreeRandomAsyncTaskHandleIndex()] = ::WSAAsyncGetHostByName (
				m_NullWindow.m_hWnd,              
				4, //unsigned int wMsg,      
				GetRandomMachineName(), //const char FAR *addr,  
				buf,         
				MAXGETHOSTSTRUCT              
				);
		}
		break;

	case PLACE_HOLDER_ASYNC_GET_PROTO_BY_NAME:
		{
			//
			// must be static, because it gets filled asynchronously
			// also, i don't care for the contents
			//
			static /*_declspec(thread)*/ char buf[MAXGETHOSTSTRUCT];
			m_ahAsyncTaskHandles[GetFreeRandomAsyncTaskHandleIndex()] = ::WSAAsyncGetProtoByName (
				m_NullWindow.m_hWnd,              
				5, //unsigned int wMsg,      
				GetRandomProtocolName(), //const char FAR *addr,  
				buf,         
				MAXGETHOSTSTRUCT              
				);
		}
		break;

	case PLACE_HOLDER_ASYNC_GET_PROTO_BY_NUMBER:
		{
			//
			// must be static, because it gets filled asynchronously
			// also, i don't care for the contents
			//
			static /*_declspec(thread)*/ char buf[MAXGETHOSTSTRUCT];
			m_ahAsyncTaskHandles[GetFreeRandomAsyncTaskHandleIndex()] = ::WSAAsyncGetProtoByNumber (
				m_NullWindow.m_hWnd,              
				6, //unsigned int wMsg,      
				GetRandomProtocolNumber(),  
				buf,         
				MAXGETHOSTSTRUCT              
				);
		}
		break;

	case PLACE_HOLDER_ASYNC_GET_SERV_BY_NAME:
		{
			//
			// must be static, because it gets filled asynchronously
			// also, i don't care for the contents
			//
			static /*_declspec(thread)*/ char buf[MAXGETHOSTSTRUCT];
			m_ahAsyncTaskHandles[GetFreeRandomAsyncTaskHandleIndex()] = ::WSAAsyncGetServByName (
				m_NullWindow.m_hWnd,              
				7, //unsigned int wMsg,      
				GetRandomServiceName(),
				rand()%2 ? NULL : GetRandomProtocolName(),
				buf,         
				MAXGETHOSTSTRUCT              
				);
		}
		break;

	case PLACE_HOLDER_ASYNC_GET_SERV_BY_PORT:
		{
			//
			// must be static, because it gets filled asynchronously
			// also, i don't care for the contents
			//
			static /*_declspec(thread)*/ char buf[MAXGETHOSTSTRUCT];
			m_ahAsyncTaskHandles[GetFreeRandomAsyncTaskHandleIndex()] = ::WSAAsyncGetServByPort (
				m_NullWindow.m_hWnd,              
				8, //unsigned int wMsg,      
				GetRandomProtocolNumber(), //port
				rand()%2 ? NULL : GetRandomProtocolName(),
				buf,         
				MAXGETHOSTSTRUCT              
				);
		}
		break;

	case PLACE_HOLDER_CANCEL_ASYNC_REQUEST:
		{
			if (0 != WSACancelAsyncRequest(GetRandomAsyncTaskHandle()))
			{
				//DPF((TEXT("WSACancelAsyncRequest() failed with %d.\n"), ::WSAGetLastError()));
			}
		}
		break;

	case PLACE_HOLDER_TRANSMIT_FILE:
		{
			m_OL.Offset = rand()%10 ? 0 : rand()%2 ? DWORD_RAND : rand();
			m_OL.OffsetHigh = rand()%100 ? 0 : DWORD_RAND;
			if (0 == rand()%100)
			{
				if (!ResetEvent(m_OL.hEvent))
				{
					DPF((TEXT("CIoctlSocket::CallRandomWin32API(PLACE_HOLDER_TRANSMIT_FILE): ResetEvent(m_OL.hEvent) failed with %d\n"), ::GetLastError()));
				}
			}

			TryToCreateFile();

			if (!::TransmitFile(
				(SOCKET)m_pDevice->m_hDevice,                             
				m_hFile,
				(rand()%2 ? rand() : rand()%2 ? DWORD_RAND : 0), //nNumberOfBytesToWrite,                
				GetRandom_SendPacketLength(), // nNumberOfBytesPerSend,                
				&m_OL,                  
				NULL, //LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,  
				GetRandomTransmitFileFlags()                               
				))
			{
				//DPF((TEXT("CIoctlSocket::CallRandomWin32API(PLACE_HOLDER_TRANSMIT_FILE): TransmitFile() failed with %d\n"), ::GetLastError()));
			}
			else
			{
				//DPF((TEXT("CIoctlSocket::CallRandomWin32API(PLACE_HOLDER_TRANSMIT_FILE): TransmitFile() suceeded\n")));
			}
		}
			break;

	default: 
		DPF((TEXT("CIoctlSocket::CallRandomWin32API() default: %d.\n"), dwSwitch));
		_ASSERTE(FALSE);
	}
}

void CIoctlSocket::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
	DWORD dwBytesReturned;//needed for WSAIoctl()


	//
	// all cases will call WSAIoctl(), and the default will not.
	// any case, when this method returns DeviceIoControl() is called, even if 
	// WSAIoctl() was called
	//
	switch(dwIOCTL)
	{
		//
		// i prefer not to issue the IOCTLS remarked below, because they go through usermode DLL
		// and it will cause AV's in there, so i'd rather call AFD directly
		//
		/*
	case FIONBIO:
        //((TCP_REQUEST_SET_INFORMATION_EX*)abInBuffer)->BufferSize = rand()%10 ? rand() : DWORD_RAND;
        *((ULONG*)abInBuffer) = rand()%2;

        SetInParam(dwInBuff, sizeof(ULONG));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

		break;

	case FIONREAD:
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG));

		break;

	case SIOCATMARK:
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG));

		break;

    case SIO_GET_QOS :
    case SIO_GET_GROUP_QOS :
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(QOS));

		break;

	case xxxx:
		break;

	case xxxx:
		break;

	case xxxx:
		break;

	case SIO_ASSOCIATE_HANDLE:
		break;

	case SIO_ENABLE_CIRCULAR_QUEUEING:
		break;

	case SIO_FIND_ROUTE:
		break;

	case SIO_FLUSH:
		break;

	case SIO_GET_BROADCAST_ADDRESS:
		break;

	case SIO_GET_EXTENSION_FUNCTION_POINTER:
		break;

	case SIO_GET_QOS:
		break;

	case SIO_GET_GROUP_QOS:
		break;

	case SIO_MULTIPOINT_LOOPBACK:
		break;

	case SIO_MULTICAST_SCOPE:
		break;

	case SIO_SET_QOS:
		break;

	case SIO_SET_GROUP_QOS:
		break;

	case SIO_TRANSLATE_HANDLE:
		break;

	case SIO_ROUTING_INTERFACE_QUERY:
		break;

	case SIO_ROUTING_INTERFACE_CHANGE:
		break;

	case SIO_ADDRESS_LIST_QUERY:
		break;

	case SIO_ADDRESS_LIST_CHANGE:
		break;

	case SIO_QUERY_TARGET_PNP_HANDLE:
		break;
*/
	case IOCTL_AFD_BIND                    :
		{
			((AFD_BIND_INFO*)abInBuffer)->ShareAccess = GetRandom_ShareAccess();
			SetRandom_TRANSPORT_ADDRESS(this, &((AFD_BIND_INFO*)abInBuffer)->Address);

			SetInParam(dwInBuff, sizeof(AFD_BIND_INFO));

			SetOutParam(abOutBuffer, dwOutBuff, sizeof(TDI_ADDRESS_INFO));
		}
		break;

	case IOCTL_AFD_CONNECT                 :
		//TODO: put meaningfull data here:
        ((AFD_CONNECT_JOIN_INFO*)abInBuffer)->RootEndpoint = GetRandom_RootEndpoint();
		//TODO: put meaningfull data here:
        ((AFD_CONNECT_JOIN_INFO*)abInBuffer)->ConnectEndpoint = GetRandom_ConnectEndpoint();
        SetRandom_TRANSPORT_ADDRESS(this, &((AFD_CONNECT_JOIN_INFO*)abInBuffer)->RemoteAddress);

		SetInParam(dwInBuff, sizeof(AFD_CONNECT_JOIN_INFO));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(IO_STATUS_BLOCK));

		break;

	case IOCTL_AFD_START_LISTEN            :
        ((AFD_LISTEN_INFO*)abInBuffer)->MaximumConnectionQueue = rand()%2 ? rand() : rand()%2 ? DWORD_RAND : rand()%2 ? 0xffffffff : 0;
        ((AFD_LISTEN_INFO*)abInBuffer)->UseDelayedAcceptance = rand()%3;

        SetInParam(dwInBuff, sizeof(AFD_LISTEN_INFO));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

		break;

	case IOCTL_AFD_WAIT_FOR_LISTEN         :
	case IOCTL_AFD_WAIT_FOR_LISTEN_LIFO    :
        //((xxx*)abInBuffer)->xxx = xxx();

        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, (1+rand()%5)*sizeof(AFD_LISTEN_RESPONSE_INFO));
		//i am not handling the response for this.

		break;

	case IOCTL_AFD_ACCEPT                  :
        ((AFD_ACCEPT_INFO*)abInBuffer)->Sequence = GetRandom_Sequence();
        ((AFD_ACCEPT_INFO*)abInBuffer)->AcceptHandle = GetRandom_AcceptHandle();

        SetInParam(dwInBuff, sizeof(AFD_ACCEPT_INFO));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

		break;

	case IOCTL_AFD_RECEIVE_DATAGRAM        :
		//Address points to struct sockaddr.
        ((AFD_RECV_DATAGRAM_INFO*)abInBuffer)->Address = rand()%2 ? (&m_AFD_RECV_DATAGRAM_INFO_Address) : CIoctl::GetRandomIllegalPointer();
        ((AFD_RECV_DATAGRAM_INFO*)abInBuffer)->AddressLength = rand()%2 ? (&m_AFD_RECV_DATAGRAM_INFO_AddressLength) : (PULONG)CIoctl::GetRandomIllegalPointer();
		/*

        SetInParam(dwInBuff, sizeof(AFD_RECV_DATAGRAM_INFO));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(xxx));

		break;
*/
		// falllthrough, as in buff is the same format except Address & AddressLength
	case IOCTL_AFD_RECEIVE                 :
		/*
        ((AFD_RECV_INFO*)abInBuffer)->BufferArray = xxx();
        ((AFD_RECV_INFO*)abInBuffer)->BufferCount = xxx();
        ((AFD_RECV_INFO*)abInBuffer)->AfdFlags = GetRandomAfdFlags();
        ((AFD_RECV_INFO*)abInBuffer)->TdiFlags = GetRandom_TdiFlags();
		*/
		//fall through, as in buff is the same format
	case IOCTL_AFD_SEND     :
		{
			//
			// <AFD_SEND_INFO><BufferArray><buffs>
			//      |          |
			//      |-<BufferArray>
			//
			((AFD_SEND_INFO*)abInBuffer)->BufferCount = rand()%100;
			((AFD_SEND_INFO*)abInBuffer)->AfdFlags = GetRandomAfdFlags();
			((AFD_SEND_INFO*)abInBuffer)->TdiFlags = rand()%10 ? 0 : GetRandom_TdiFlags();

			//
			// this is the array of WSABUF
			//
			LPWSABUF BufferArray = ((AFD_SEND_INFO*)abInBuffer)->BufferArray = 
				rand()%10	? (LPWSABUF)((BYTE*)abInBuffer+sizeof(AFD_SEND_INFO))
							: (LPWSABUF)CIoctl::GetRandomIllegalPointer();

			__try
			{
				//
				// this is where each WSABUF points
				//
				char*  buf = (char*)BufferArray + ((AFD_SEND_INFO*)abInBuffer)->BufferCount*sizeof(WSABUF);
				// following assert is no good, because BufferArray can point to GetRandomIllegalPointer()
				// i can fix the assert, but i just remove it.
				//_ASSERTE((BYTE*)buf - (BYTE*)abInBuffer < SIZEOF_INOUTBUFF);
				ULONG ulMaxBuffSize = SIZEOF_INOUTBUFF - ((BYTE*)buf - (BYTE*)abInBuffer);
				_ASSERTE(0 < ulMaxBuffSize);

				for (ULONG i = 0; i < ((AFD_SEND_INFO*)abInBuffer)->BufferCount; i++)
				{
					(((AFD_SEND_INFO*)abInBuffer)->BufferArray)[i].len = rand()%ulMaxBuffSize;
					//
					// once every 20 times, give wrong len that may cause AV
					//
					if (0 == rand()%20)
					{
						(((AFD_SEND_INFO*)abInBuffer)->BufferArray)[i].len += rand()%100;
					}
					//
					// the buffer will point right after *((AFD_SEND_INFO*)abInBuffer),
					// or to a decommitted buffer
					//
					(((AFD_SEND_INFO*)abInBuffer)->BufferArray)[i].buf = 
						rand()%20	? buf 
									: (char*)CIoctl::GetRandomIllegalPointer();
				}
			}
			__except(1)
			{
				//since i use CIoctl::GetRandomIllegalPointer(), i am likely to get here...
			}
			
			//
			// the inbuff size does not need to include the buffs pointed to!
			//
			//SetInParam(dwInBuff, sizeof(AFD_SEND_INFO)+((AFD_SEND_INFO*)abInBuffer)->BufferCount*sizeof(WSABUF));
			
			// add rand()%20, so that it wiull hold IOCTL_AFD_RECEIVE_DATAGRAM's in buff
			SetInParam(dwInBuff, (rand()%20)+sizeof(AFD_SEND_INFO));

			SetOutParam(abOutBuffer, dwOutBuff, 0);
		}

		break;

	case IOCTL_AFD_SEND_DATAGRAM           :
		{
			//
			// <AFD_SEND_INFO><BufferArray><buffs>
			//      |          |
			//      |-<BufferArray>
			//
			((AFD_SEND_DATAGRAM_INFO*)abInBuffer)->BufferCount = rand()%100;
			((AFD_SEND_DATAGRAM_INFO*)abInBuffer)->AfdFlags = GetRandomAfdFlags();

			//
			// this is the array of WSABUF
			//
			LPWSABUF BufferArray = ((AFD_SEND_DATAGRAM_INFO*)abInBuffer)->BufferArray = 
				rand()%10	? (LPWSABUF)((BYTE*)abInBuffer+sizeof(AFD_SEND_DATAGRAM_INFO))
							: (LPWSABUF)CIoctl::GetRandomIllegalPointer();

			__try
			{
				//
				// this is where each WSABUF points
				//
				char*  buf = (char*)BufferArray + ((AFD_SEND_DATAGRAM_INFO*)abInBuffer)->BufferCount*sizeof(WSABUF);
				_ASSERTE((BYTE*)buf - (BYTE*)abInBuffer < SIZEOF_INOUTBUFF);
				ULONG ulMaxBuffSize = SIZEOF_INOUTBUFF - ((BYTE*)buf - (BYTE*)abInBuffer);
				_ASSERTE(0 < ulMaxBuffSize);

				for (ULONG i = 0; i < ((AFD_SEND_DATAGRAM_INFO*)abInBuffer)->BufferCount; i++)
				{
					(((AFD_SEND_DATAGRAM_INFO*)abInBuffer)->BufferArray)[i].len = rand()%ulMaxBuffSize;
					//
					// once every 50 times, give wrong len that may cause AV
					//
					if (0 == rand()%50)
					{
						(((AFD_SEND_DATAGRAM_INFO*)abInBuffer)->BufferArray)[i].len += rand()%100;
					}
					//
					// the buffer will point right after *((AFD_SEND_DATAGRAM_INFO*)abInBuffer),
					// or to a decommitted buffer
					//
					(((AFD_SEND_DATAGRAM_INFO*)abInBuffer)->BufferArray)[i].buf = 
						rand()%50	? buf 
									: (char*)CIoctl::GetRandomIllegalPointer();
				}
			}
			__except(1)
			{
				//since i use CIoctl::GetRandomIllegalPointer(), i am likely to get here...
			}
			
			SetRandom_TDI_REQUEST(&((AFD_SEND_DATAGRAM_INFO*)abInBuffer)->TdiRequest.Request);
			((AFD_SEND_DATAGRAM_INFO*)abInBuffer)->TdiRequest.SendDatagramInformation = 
				rand()%2	? GetRandom_TDI_CONNECTION_INFORMATION()
							: &((AFD_SEND_DATAGRAM_INFO*)abInBuffer)->TdiConnInfo;
			(void)SetRandom_TDI_CONNECTION_INFORMATION(&((AFD_SEND_DATAGRAM_INFO*)abInBuffer)->TdiConnInfo);

			//
			// once in a while, mess with BufferCount
			//
			if (0 == rand()%50) ((AFD_SEND_DATAGRAM_INFO*)abInBuffer)->BufferCount = rand();

			//
			// the inbuff size does not need to include the buffs pointed to!
			//
			//SetInParam(dwInBuff, sizeof(AFD_SEND_DATAGRAM_INFO)+((AFD_SEND_DATAGRAM_INFO*)abInBuffer)->BufferCount*sizeof(WSABUF));
			SetInParam(dwInBuff, sizeof(AFD_SEND_DATAGRAM_INFO));

			SetOutParam(abOutBuffer, dwOutBuff, 0);
		}

		break;

	case IOCTL_AFD_POLL                    :
		{
			((AFD_POLL_INFO*)abInBuffer)->Timeout = GetRandom_Timeout();
			((AFD_POLL_INFO*)abInBuffer)->NumberOfHandles = rand()%100;
			((AFD_POLL_INFO*)abInBuffer)->Unique = rand()%3;
			for (UINT i = 0; i < ((AFD_POLL_INFO*)abInBuffer)->NumberOfHandles; i++)
			{
				((AFD_POLL_INFO*)abInBuffer)->Handles[i].Handle = GetRandomEventHandle();
				((AFD_POLL_INFO*)abInBuffer)->Handles[i].PollEvents = GetRandom_PollEvents();
				((AFD_POLL_INFO*)abInBuffer)->Handles[i].Status = DWORD_RAND;
				//
				// once in a while, pass a null event and no flags, which is legal
				//
				if (0 == rand()%20)
				{
					((AFD_POLL_INFO*)abInBuffer)->Handles[i].Handle = NULL;
					((AFD_POLL_INFO*)abInBuffer)->Handles[i].PollEvents = 0;
				}

			}

        

			SetInParam(dwInBuff, sizeof(AFD_POLL_INFO)+(((AFD_POLL_INFO*)abInBuffer)->NumberOfHandles*sizeof(AFD_POLL_HANDLE_INFO)));

			SetOutParam(abOutBuffer, dwOutBuff, sizeof(AFD_POLL_INFO)+(((AFD_POLL_INFO*)abInBuffer)->NumberOfHandles*sizeof(AFD_POLL_HANDLE_INFO)));
		}

		break;

	case IOCTL_AFD_PARTIAL_DISCONNECT      :
        ((AFD_PARTIAL_DISCONNECT_INFO*)abInBuffer)->DisconnectMode = GetRandom_DisconnectMode() ;
        ((AFD_PARTIAL_DISCONNECT_INFO*)abInBuffer)->Timeout = GetRandom_Timeout();

        SetInParam(dwInBuff, sizeof(AFD_PARTIAL_DISCONNECT_INFO));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

		break;


	case IOCTL_AFD_GET_ADDRESS             :
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(TDI_ADDRESS_INFO));
		//TODO: get output buffer

		break;

	case IOCTL_AFD_QUERY_RECEIVE_INFO      :
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(AFD_RECEIVE_INFORMATION));
		//AFD_RECEIVE_INFORMATION seems not important enough to remember

		break;

	case IOCTL_AFD_QUERY_HANDLES           :
        *((ULONG*)abInBuffer) = GetRandom_QueryModeFlags() ;

        SetInParam(dwInBuff, sizeof(ULONG));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(AFD_HANDLE_INFO));

		break;

	case IOCTL_AFD_SET_INFORMATION         :
        ((AFD_INFORMATION*)abInBuffer)->InformationType = GetRandom_InformationType();
        *(AFD_GROUP_INFO*)(&((AFD_INFORMATION*)abInBuffer)->Information.LargeInteger.QuadPart) = GetRandom_AFD_GROUP_INFO();

        SetInParam(dwInBuff, sizeof(AFD_INFORMATION));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

		break;

	case IOCTL_AFD_GET_CONTEXT_LENGTH      :
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG));

		break;

	case IOCTL_AFD_GET_CONTEXT             :
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, rand());

		break;

	case IOCTL_AFD_SET_CONTEXT             :
        SetRandom_Context(abInBuffer);

        SetInParam(dwInBuff, rand());

        SetOutParam(abOutBuffer, dwOutBuff, 0);

		break;

	case IOCTL_AFD_SET_CONNECT_DATA        :
	case IOCTL_AFD_SET_CONNECT_OPTIONS     :
	case IOCTL_AFD_SET_DISCONNECT_DATA     :
	case IOCTL_AFD_SET_DISCONNECT_OPTIONS  :
	case IOCTL_AFD_GET_CONNECT_DATA        :
	case IOCTL_AFD_GET_CONNECT_OPTIONS     :
	case IOCTL_AFD_GET_DISCONNECT_DATA     :
	case IOCTL_AFD_GET_DISCONNECT_OPTIONS  :
	case IOCTL_AFD_SIZE_CONNECT_DATA       :
	case IOCTL_AFD_SIZE_CONNECT_OPTIONS    :
	case IOCTL_AFD_SIZE_DISCONNECT_DATA    :
	case IOCTL_AFD_SIZE_DISCONNECT_OPTIONS :
	case IOCTL_AFD_GET_UNACCEPTED_CONNECT_DATA :
#define AFD_FAST_CONNECT_DATA_SIZE 256

        ((AFD_UNACCEPTED_CONNECT_DATA_INFO*)abInBuffer)->Sequence = GetRandom_Sequence();
        ((AFD_UNACCEPTED_CONNECT_DATA_INFO*)abInBuffer)->ConnectDataLength = GetRandom_ConnectDataLength();
        ((AFD_UNACCEPTED_CONNECT_DATA_INFO*)abInBuffer)->LengthOnly = rand()%3;

        SetInParam(dwInBuff, sizeof(AFD_UNACCEPTED_CONNECT_DATA_INFO));

        SetOutParam(abOutBuffer, dwOutBuff, AFD_FAST_CONNECT_DATA_SIZE);

		break;

	case IOCTL_AFD_GET_INFORMATION         :
        ((AFD_INFORMATION*)abInBuffer)->InformationType = GetRandom_InformationType();
        *(AFD_GROUP_INFO*)(&((AFD_INFORMATION*)abInBuffer)->Information.LargeInteger.QuadPart) = GetRandom_AFD_GROUP_INFO();
		
        SetInParam(dwInBuff, (1+rand()%3)*sizeof(AFD_INFORMATION));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(AFD_INFORMATION));

		break;

	case IOCTL_AFD_TRANSMIT_FILE           :
		TryToCreateFile();
        ((AFD_TRANSMIT_FILE_INFO*)abInBuffer)->Offset = GetRandom_Offset();
        ((AFD_TRANSMIT_FILE_INFO*)abInBuffer)->WriteLength = GetRandom_WriteLength();
        ((AFD_TRANSMIT_FILE_INFO*)abInBuffer)->SendPacketLength = GetRandom_SendPacketLength();
        ((AFD_TRANSMIT_FILE_INFO*)abInBuffer)->FileHandle = GetRandom_FileHandle();
        ((AFD_TRANSMIT_FILE_INFO*)abInBuffer)->Head = GetRandom_HeadOrTail(abInBuffer);
        ((AFD_TRANSMIT_FILE_INFO*)abInBuffer)->HeadLength = rand()%4 ? rand()%SIZEOF_INOUTBUFF : 0;
        ((AFD_TRANSMIT_FILE_INFO*)abInBuffer)->Tail = GetRandom_HeadOrTail(abInBuffer);
        ((AFD_TRANSMIT_FILE_INFO*)abInBuffer)->TailLength = rand()%4 ? rand()%SIZEOF_INOUTBUFF : 0;
        ((AFD_TRANSMIT_FILE_INFO*)abInBuffer)->Flags = GetRandom_Flags();

        SetInParam(dwInBuff, sizeof(AFD_TRANSMIT_FILE_INFO));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

		break;

	case IOCTL_AFD_SUPER_ACCEPT            :
        ((AFD_SUPER_ACCEPT_INFO*)abInBuffer)->AcceptHandle = GetRandom_AcceptHandle();
        ((AFD_SUPER_ACCEPT_INFO*)abInBuffer)->ReceiveDataLength = rand()%2 ? rand()%1000 : rand()%10;
        ((AFD_SUPER_ACCEPT_INFO*)abInBuffer)->LocalAddressLength = rand()%2 ? rand()%1000 : rand()%10;
        ((AFD_SUPER_ACCEPT_INFO*)abInBuffer)->RemoteAddressLength = rand()%2 ? rand()%1000 : rand()%10;

        SetInParam(dwInBuff, sizeof(AFD_SUPER_ACCEPT_INFO));

        SetOutParam(
			abOutBuffer, 
			dwOutBuff, 
			rand()%30+sizeof(AFD_SUPER_ACCEPT_INFO)+((AFD_SUPER_ACCEPT_INFO*)abInBuffer)->ReceiveDataLength+((AFD_SUPER_ACCEPT_INFO*)abInBuffer)->LocalAddressLength+((AFD_SUPER_ACCEPT_INFO*)abInBuffer)->RemoteAddressLength
			);

		break;

	case IOCTL_AFD_EVENT_SELECT            :
        ((AFD_EVENT_SELECT_INFO*)abInBuffer)->Event = GetRandomEventHandle();
        ((AFD_EVENT_SELECT_INFO*)abInBuffer)->PollEvents = GetRandom_PollEvents();
		//
		// once in a while, pass a null event and no flags, which is legal
		//
		if (0 == rand()%20)
		{
			((AFD_EVENT_SELECT_INFO*)abInBuffer)->Event = NULL;
			((AFD_EVENT_SELECT_INFO*)abInBuffer)->PollEvents = 0;
		}

        SetInParam(dwInBuff, sizeof(AFD_EVENT_SELECT_INFO));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

		break;

	case IOCTL_AFD_ENUM_NETWORK_EVENTS     :
		//
		// note that the value is the pointer itself, so there's no contents to this buffer!
        abInBuffer = (BYTE*)GetRandomEventHandle();

		//
		// and therefor the size is zero!
		//
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(AFD_ENUM_NETWORK_EVENTS_INFO));
		//i do not really care for the output of this

		break;


	case IOCTL_AFD_DEFER_ACCEPT            :
        ((AFD_DEFER_ACCEPT_INFO*)abInBuffer)->Sequence = GetRandom_Sequence();
        ((AFD_DEFER_ACCEPT_INFO*)abInBuffer)->Reject = rand()%3;

        SetInParam(dwInBuff, sizeof(AFD_DEFER_ACCEPT_INFO));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

		break;

	case IOCTL_AFD_SET_QOS                 :
		{
		// from afddata.c:
static QOS s_AfdDefaultQos =
        {
            {                           // SendingFlowspec
                (ULONG)-1,                  // TokenRate
                (ULONG)-1,                  // TokenBucketSize
                (ULONG)-1,                  // PeakBandwidth
                (ULONG)-1,                  // Latency
                (ULONG)-1,                  // DelayVariation
                SERVICETYPE_BESTEFFORT,     // ServiceType
                (ULONG)-1,                  // MaxSduSize
                (ULONG)-1                   // MinimumPolicedSize
            },

            {                           // SendingFlowspec
                (ULONG)-1,                  // TokenRate
                (ULONG)-1,                  // TokenBucketSize
                (ULONG)-1,                  // PeakBandwidth
                (ULONG)-1,                  // Latency
                (ULONG)-1,                  // DelayVariation
                SERVICETYPE_BESTEFFORT,     // ServiceType
                (ULONG)-1,                  // MaxSduSize
                (ULONG)-1                   // MinimumPolicedSize
            },
        };

			SetRand_Qos(&((AFD_QOS_INFO*)abInBuffer)->Qos);
			((AFD_QOS_INFO*)abInBuffer)->GroupQos = rand()%3;

			SetInParam(dwInBuff, sizeof(AFD_QOS_INFO));

			SetOutParam(abOutBuffer, dwOutBuff, 0);
		}

		break;

	case IOCTL_AFD_GET_QOS                 :
        SetInParam(dwInBuff, 0);

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(AFD_QOS_INFO));

		break;

	case IOCTL_AFD_NO_OPERATION            :
		//BUG 431977: i think this function should be removed from AFD
		/*
        ((xxx*)abInBuffer)->xxx = xxx();

        SetInParam(dwInBuff, sizeof(xxx));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(xxx));
*/
		break;

	case IOCTL_AFD_VALIDATE_GROUP          :
        ((AFD_VALIDATE_GROUP_INFO*)abInBuffer)->GroupID = GetRandom_GroupID();
		SetRandom_TRANSPORT_ADDRESS(this, &((AFD_VALIDATE_GROUP_INFO*)abInBuffer)->RemoteAddress);

		//+rand()%100 'cause AFD_VALIDATE_GROUP_INFO has variable size
        SetInParam(dwInBuff, rand()%100+sizeof(AFD_VALIDATE_GROUP_INFO));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

		break;

	case IOCTL_AFD_ROUTING_INTERFACE_QUERY  :
		SetRandom_TRANSPORT_ADDRESS(this, (TRANSPORT_ADDRESS*)abInBuffer);

        SetInParam(dwInBuff, sizeof(TRANSPORT_ADDRESS));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(TRANSPORT_ADDRESS)+((TRANSPORT_ADDRESS*)abInBuffer)->TAAddressCount*sizeof(TA_ADDRESS)*(rand())%100);
		//TODO: use the out buff

		break;

	case IOCTL_AFD_ROUTING_INTERFACE_CHANGE :
        ((AFD_TRANSPORT_IOCTL_INFO*)abInBuffer)->Handle = rand()%2 ? GetRandomEventHandle() : GetRandomConnectionContext();
        ((AFD_TRANSPORT_IOCTL_INFO*)abInBuffer)->InputBuffer = rand()%2 ? abInBuffer : CIoctl::GetRandomIllegalPointer();
        ((AFD_TRANSPORT_IOCTL_INFO*)abInBuffer)->InputBufferLength = rand();
        ((AFD_TRANSPORT_IOCTL_INFO*)abInBuffer)->IoControlCode = DWORD_RAND;
        ((AFD_TRANSPORT_IOCTL_INFO*)abInBuffer)->AfdFlags = GetRandomAfdFlags();
        ((AFD_TRANSPORT_IOCTL_INFO*)abInBuffer)->PollEvent = GetRandom_PollEvents();

        SetInParam(dwInBuff, sizeof(AFD_TRANSPORT_IOCTL_INFO));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

		break;

	case IOCTL_AFD_ADDRESS_LIST_QUERY       :
        *((USHORT*)abInBuffer) = GetRandom_AddressType();

        SetInParam(dwInBuff, sizeof(USHORT));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(TRANSPORT_ADDRESS));

		break;

	case IOCTL_AFD_ADDRESS_LIST_CHANGE      :
        ((AFD_TRANSPORT_IOCTL_INFO*)abInBuffer)->Handle = rand()%2 ? GetRandomEventHandle() : GetRandomConnectionContext();
        ((AFD_TRANSPORT_IOCTL_INFO*)abInBuffer)->InputBuffer = rand()%2 ? abInBuffer : CIoctl::GetRandomIllegalPointer();
        ((AFD_TRANSPORT_IOCTL_INFO*)abInBuffer)->InputBufferLength = rand();
        ((AFD_TRANSPORT_IOCTL_INFO*)abInBuffer)->IoControlCode = DWORD_RAND;
        ((AFD_TRANSPORT_IOCTL_INFO*)abInBuffer)->AfdFlags = GetRandomAfdFlags();
        ((AFD_TRANSPORT_IOCTL_INFO*)abInBuffer)->PollEvent = GetRandom_PollEvents();

        SetInParam(dwInBuff, sizeof(AFD_TRANSPORT_IOCTL_INFO));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

		break;

	case IOCTL_AFD_JOIN_LEAF                :
        ((AFD_CONNECT_JOIN_INFO*)abInBuffer)->RootEndpoint = GetRandom_RootEndpoint();
        ((AFD_CONNECT_JOIN_INFO*)abInBuffer)->ConnectEndpoint = GetRandom_ConnectEndpoint();
		SetRandom_TRANSPORT_ADDRESS(this, &((AFD_CONNECT_JOIN_INFO*)abInBuffer)->RemoteAddress);

        SetInParam(dwInBuff, sizeof(AFD_CONNECT_JOIN_INFO));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(IO_STATUS_BLOCK));

		break;

	case IOCTL_AFD_TRANSPORT_IOCTL          :
		/*
        ((xxx*)abInBuffer)->xxx = xxx();

        SetInParam(dwInBuff, sizeof(xxx));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(xxx));
*/
		break;


	default: 
		CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
		return;
	}

    m_OL.Offset = rand()%10 ? 0 : DWORD_RAND;
    m_OL.OffsetHigh = rand()%100 ? 0 : DWORD_RAND;
    if (0 == rand()%100)
    {
        if (!ResetEvent(m_OL.hEvent))
        {
            DPF((TEXT("CIoctlSocket::PrepareIOCTLParams(): ResetEvent(m_OL.hEvent) failed with %d\n"), ::GetLastError()));
        }
    }


	if (0 != ::WSAIoctl(
		(SOCKET)m_pDevice->m_hDevice,                                               
		dwIOCTL,                                  
		abInBuffer,                                     
		dwInBuff,                                       
		abOutBuffer,                                    
		dwOutBuff,                                      
		&dwBytesReturned,                              
		&m_OL,                           
		fn  
		))
	{
        //DPF((TEXT(">>>>>>>CIoctlSocket::PrepareIOCTLParams(): WSAIoctl failed with %d\n"), ::WSAGetLastError()));
	}
	else
	{
        //DPF((TEXT("<<<<<<<<CIoctlSocket::PrepareIOCTLParams(): WSAIoctl succeeded\n")));
	}


	
}


BOOL CIoctlSocket::FindValidIOCTLs(CDevice *pDevice)
{
	/*
	AddIOCTL(pDevice, SIO_ASSOCIATE_HANDLE);
	AddIOCTL(pDevice, SIO_ENABLE_CIRCULAR_QUEUEING);
	AddIOCTL(pDevice, SIO_FIND_ROUTE);
	AddIOCTL(pDevice, SIO_FLUSH);
	AddIOCTL(pDevice, SIO_GET_BROADCAST_ADDRESS);
	AddIOCTL(pDevice, SIO_GET_EXTENSION_FUNCTION_POINTER);
	AddIOCTL(pDevice, SIO_GET_QOS);
	AddIOCTL(pDevice, SIO_GET_GROUP_QOS);
	AddIOCTL(pDevice, SIO_MULTIPOINT_LOOPBACK);
	AddIOCTL(pDevice, SIO_MULTICAST_SCOPE);
	AddIOCTL(pDevice, SIO_SET_QOS);
	AddIOCTL(pDevice, SIO_SET_GROUP_QOS);
	AddIOCTL(pDevice, SIO_TRANSLATE_HANDLE);
	AddIOCTL(pDevice, SIO_ROUTING_INTERFACE_QUERY);
	AddIOCTL(pDevice, SIO_ROUTING_INTERFACE_CHANGE);
	AddIOCTL(pDevice, SIO_ADDRESS_LIST_QUERY);
	AddIOCTL(pDevice, SIO_ADDRESS_LIST_CHANGE);
	AddIOCTL(pDevice, SIO_QUERY_TARGET_PNP_HANDLE);
*/
	AddIOCTL(pDevice, IOCTL_AFD_BIND                    );
	AddIOCTL(pDevice, IOCTL_AFD_CONNECT                 );
	AddIOCTL(pDevice, IOCTL_AFD_START_LISTEN            );
	AddIOCTL(pDevice, IOCTL_AFD_WAIT_FOR_LISTEN         );
	AddIOCTL(pDevice, IOCTL_AFD_ACCEPT                  );
	AddIOCTL(pDevice, IOCTL_AFD_RECEIVE                 );
	AddIOCTL(pDevice, IOCTL_AFD_RECEIVE_DATAGRAM        );
	//AddIOCTL(pDevice, IOCTL_AFD_SEND                    );
	AddIOCTL(pDevice, IOCTL_AFD_SEND_DATAGRAM           );
	AddIOCTL(pDevice, IOCTL_AFD_POLL                    );
	AddIOCTL(pDevice, IOCTL_AFD_PARTIAL_DISCONNECT      );
	AddIOCTL(pDevice, IOCTL_AFD_GET_ADDRESS             );
	AddIOCTL(pDevice, IOCTL_AFD_QUERY_RECEIVE_INFO      );
	AddIOCTL(pDevice, IOCTL_AFD_QUERY_HANDLES           );
	AddIOCTL(pDevice, IOCTL_AFD_SET_INFORMATION         );
	AddIOCTL(pDevice, IOCTL_AFD_GET_CONTEXT_LENGTH      );
	AddIOCTL(pDevice, IOCTL_AFD_GET_CONTEXT             );
	AddIOCTL(pDevice, IOCTL_AFD_SET_CONTEXT             );
	AddIOCTL(pDevice, IOCTL_AFD_SET_CONNECT_DATA        );
	AddIOCTL(pDevice, IOCTL_AFD_SET_CONNECT_OPTIONS     );
	AddIOCTL(pDevice, IOCTL_AFD_SET_DISCONNECT_DATA     );
	AddIOCTL(pDevice, IOCTL_AFD_SET_DISCONNECT_OPTIONS  );
	AddIOCTL(pDevice, IOCTL_AFD_GET_CONNECT_DATA        );
	AddIOCTL(pDevice, IOCTL_AFD_GET_CONNECT_OPTIONS     );
	AddIOCTL(pDevice, IOCTL_AFD_GET_DISCONNECT_DATA     );
	AddIOCTL(pDevice, IOCTL_AFD_GET_DISCONNECT_OPTIONS  );
	AddIOCTL(pDevice, IOCTL_AFD_SIZE_CONNECT_DATA       );
	AddIOCTL(pDevice, IOCTL_AFD_SIZE_CONNECT_OPTIONS    );
	AddIOCTL(pDevice, IOCTL_AFD_SIZE_DISCONNECT_DATA    );
	AddIOCTL(pDevice, IOCTL_AFD_SIZE_DISCONNECT_OPTIONS );
	AddIOCTL(pDevice, IOCTL_AFD_GET_INFORMATION         );
	AddIOCTL(pDevice, IOCTL_AFD_TRANSMIT_FILE           );
	AddIOCTL(pDevice, IOCTL_AFD_SUPER_ACCEPT            );
	AddIOCTL(pDevice, IOCTL_AFD_EVENT_SELECT            );
	AddIOCTL(pDevice, IOCTL_AFD_ENUM_NETWORK_EVENTS     );
	AddIOCTL(pDevice, IOCTL_AFD_DEFER_ACCEPT            );
	AddIOCTL(pDevice, IOCTL_AFD_WAIT_FOR_LISTEN_LIFO    );
	AddIOCTL(pDevice, IOCTL_AFD_SET_QOS                 );
	AddIOCTL(pDevice, IOCTL_AFD_GET_QOS                 );
	AddIOCTL(pDevice, IOCTL_AFD_NO_OPERATION            );
	AddIOCTL(pDevice, IOCTL_AFD_VALIDATE_GROUP          );
	AddIOCTL(pDevice, IOCTL_AFD_GET_UNACCEPTED_CONNECT_DATA );

//	AddIOCTL(pDevice, IOCTL_AFD_QUEUE_APC               );
	AddIOCTL(pDevice, IOCTL_AFD_ROUTING_INTERFACE_QUERY  );
	AddIOCTL(pDevice, IOCTL_AFD_ROUTING_INTERFACE_CHANGE );
	AddIOCTL(pDevice, IOCTL_AFD_ADDRESS_LIST_QUERY       );
	AddIOCTL(pDevice, IOCTL_AFD_ADDRESS_LIST_CHANGE      );
	AddIOCTL(pDevice, IOCTL_AFD_JOIN_LEAF                );
	AddIOCTL(pDevice, IOCTL_AFD_TRANSPORT_IOCTL          );

    return TRUE;
}


SOCKET CIoctlSocket::CreateSocket(CDevice *pDevice)
{    
	SOCKET sRetval = INVALID_SOCKET;

	for (int i = 0; i < 1000; i++)
	{
		sRetval = ::WSASocket (
			AF_INET,    
			SOCK_STREAM,    
			IPPROTO_TCP,   
			NULL, //LPWSAPROTOCOL_INFO
			0,
			WSA_FLAG_OVERLAPPED
			);
		if (INVALID_SOCKET == sRetval)
		{
			::Sleep(100);
		}
		else
		{
			return sRetval;
		}
	}

	if (INVALID_SOCKET == sRetval)
	{
		::SetLastError(::WSAGetLastError());
		DPF((TEXT("WSASocket() failed with %d.\n"), ::GetLastError()));
	}

	return sRetval;
}

bool CIoctlSocket::CloseSocket(CDevice *pDevice)
{    
	if (0 != ::closesocket((SOCKET)pDevice->m_hDevice))
	{
		::SetLastError(::WSAGetLastError());
		pDevice->m_hDevice = (HANDLE)INVALID_SOCKET;
		DPF((TEXT("closesocket() failed with %d.\n"), ::GetLastError()));
		return false;
	}

	pDevice->m_hDevice = (HANDLE)INVALID_SOCKET;
	return true;
}

void CIoctlSocket::PrintBindError(DWORD dwLastError)
{
	switch(dwLastError)
	{
	case WSANOTINITIALISED:
		DPF((TEXT("bind() failed with WSANOTINITIALISED.\n")));

		break;

	case WSAENETDOWN:
		DPF((TEXT("bind() failed with WSAENETDOWN.\n")));

		break;
/*
	case WSAEACCESS:
		DPF((TEXT("bind() failed with WSAEACCESS.\n")));

		break;
*/
	case WSAEADDRINUSE:
		DPF((TEXT("bind() failed with WSAEADDRINUSE.\n")));

		break;

	case WSAEADDRNOTAVAIL:
		DPF((TEXT("bind() failed with WSAEADDRNOTAVAIL.\n")));

		break;

	case WSAEFAULT:
		DPF((TEXT("bind() failed with WSAEFAULT.\n")));

		break;

	case WSAEINPROGRESS:
		DPF((TEXT("bind() failed with WSAEINPROGRESS.\n")));

		break;

	case WSAEINVAL:
		DPF((TEXT("bind() failed with WSAEINVAL.\n")));

		break;

	case WSAENOBUFS:
		DPF((TEXT("bind() failed with WSAENOBUFS.\n")));

		break;

	case WSAENOTSOCK:
		DPF((TEXT("bind() failed with WSAENOTSOCK.\n")));

		break;

	default:
		DPF((TEXT("bind() failed with %d.\n"), dwLastError));

	}
}


bool CIoctlSocket::Bind(CDevice *pDevice, bool fIsClientSide)
{
    //
    // try to bind
    //
    SOCKADDR_IN     sinSockAddr; 
    ZERO_STRUCT(sinSockAddr);
    sinSockAddr.sin_family      = AF_INET; 
    sinSockAddr.sin_addr.s_addr = INADDR_ANY; 
    sinSockAddr.sin_port        = fIsClientSide ? 
		0 : //client side: any port
		htons(_ttoi(pDevice->GetDeviceName())); //server side, the port specified as the name of the device
    
	DPF((TEXT("%s: sinSockAddr.sin_port = 0x%08X.\n"), fIsClientSide ? TEXT("client") : TEXT("server"), sinSockAddr.sin_port));

	//
	// BUGBUG: should i loop here, because of fault-injections?
	//
    if (::bind(
            m_sListeningSocket, 
            (const struct sockaddr FAR*)&sinSockAddr, 
            sizeof(SOCKADDR_IN)
            ) == SOCKET_ERROR
       )
    { 
		DWORD dwLastError = ::WSAGetLastError();
		::SetLastError(dwLastError);
		//
		// failed
		//
		PrintBindError(dwLastError);
		DPFLUSH();

		return false;
    }
    else
    {
        //
        // succeeded
        //
		DPF((TEXT("bind() succeeded.\n")));
		DPFLUSH();
		return true;

    }
	_ASSERTE(FALSE);
}


int CIoctlSocket::GetRandomAFType()
{
	if (0 != rand()%10)	return AF_INET; //we usually want that
	if (0 != rand()%10)	return rand()%(AF_MAX+1);// we want that less
	return rand();//this we want much less
}


void CIoctlSocket::TryToCreateFile()
{
	if (!::InterlockedExchange(&m_fFileOpened, TRUE))
	{
		m_hFile = CreateFile(
			TEXT("deviceioctls.exe"),          // pointer to name of the file
			GENERIC_READ,       // access (read-write) mode
			FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,           // share mode
			NULL,                        // pointer to security attributes
			OPEN_ALWAYS,  // how to create
			FILE_FLAG_OVERLAPPED | FILE_FLAG_SEQUENTIAL_SCAN,  // file attributes
			NULL         // handle to file with attributes to copy
			);
		if (INVALID_HANDLE_VALUE == m_hFile)
		{
			DPF((TEXT("CIoctlSocket::CallRandomWin32API(PLACE_HOLDER_TRANSMIT_FILE): CreateFile(deviceioctls.exe) failed with %d\n"), ::GetLastError()));
			::InterlockedExchange(&m_fFileOpened, FALSE);
			//
			// do not break, let the API handle the invalid value
			// break;
			if (rand()%2) m_hFile = NULL;
			if (0 == rand()%10) m_hFile = (HANDLE) rand();
		}
		else
		{
			//m_fFileOpened = true;
		}
	}
	return;
}

HANDLE CIoctlSocket::GetRandom_FileHandle()
{
	if (rand()%2) return (m_hFile);

	if (0 == rand()%50) return m_ahTdiAddressHandle;
	if (0 == rand()%50) return m_ahTdiConnectionHandle;
	if (0 == rand()%50) return m_ahDeviceAfdHandle;
	return ((HANDLE)(rand()%200));
}

PVOID CIoctlSocket::GetRandom_HeadOrTail(BYTE* abValidBuffer)
{
	if (rand()%2) return (abValidBuffer);
	return (CIoctl::GetRandomIllegalPointer());
}


//
// look for a valid random async task  handle, return it, and mark it as invalid, 
// since i asume it will be cancelled by the caller (which may fail to cancel, but i do not care).
// if one is hard to find, return a random one
// algorithm: start with a random index, and then walk until find one
//
HANDLE CIoctlSocket::GetRandomAsyncTaskHandle()
{
	UINT uiRandomStartIndex = rand()%MAX_NUM_OF_ASYNC_TASK_HANDLES;
	HANDLE hRetval = 0;

	//
	// try randomly to find one untill the end of the array
	//
	for (UINT i = uiRandomStartIndex; i < MAX_NUM_OF_ASYNC_TASK_HANDLES; i++)
	{
		if (0 != m_ahAsyncTaskHandles[i])
		{
			hRetval = m_ahAsyncTaskHandles[i];
			//
			// we can context-switch here, so 2 threads get the same handle
			// but this is ok, because i do not care what fails and what succeeds
			//
			m_ahAsyncTaskHandles[i] = 0;
			return hRetval;
		}
	}

	//
	// try randomly to find one untill uiRandomStartIndex
	//
	for (i = 0; i < uiRandomStartIndex; i++)
	{
		if (0 != m_ahAsyncTaskHandles[i])
		{
			hRetval = m_ahAsyncTaskHandles[i];
			//
			// we can context-switch here, so 2 threads get the same handle
			// but this is ok, because i do not care what fails and what succeeds
			//
			m_ahAsyncTaskHandles[i] = 0;
			return hRetval;
		}
	}

	//
	// there are no tasks, so there's nothing to cancel, so just return a random number
	//

	return (HANDLE)rand();
}

//
// look for a free slot for a new task handle. 
// if there is no free slot, cancel one (free it) and return its slot.
// algorithm: start with a random index, and then walk until find one
//
UINT CIoctlSocket::GetFreeRandomAsyncTaskHandleIndex()
{
	UINT uiRandomStartIndex = rand()%MAX_NUM_OF_ASYNC_TASK_HANDLES;
	HANDLE hRetval = 0;

	//
	// try randomly to find one starting with uiRandomStartIndex
	//
	for (UINT i = uiRandomStartIndex; i < MAX_NUM_OF_ASYNC_TASK_HANDLES; i++)
	{
		if (0 == m_ahAsyncTaskHandles[i])
		{
			return i;
		}
	}

	//
	// try randomly to find one ending with uiRandomStartIndex
	//
	for (i = 0; i < uiRandomStartIndex; i++)
	{
		if (0 == m_ahAsyncTaskHandles[i])
		{
			return i;
		}
	}

	//
	// there are no free entries, so cancel an entry and return it
	//
	uiRandomStartIndex = rand()%MAX_NUM_OF_ASYNC_TASK_HANDLES;
	if (0 != WSACancelAsyncRequest(m_ahAsyncTaskHandles[uiRandomStartIndex]))
	{
		//DPF((TEXT("CIoctlSocket::GetFreeRandomAsyncTaskHandleIndex(): WSACancelAsyncRequest() failed with %d.\n"), ::WSAGetLastError()));
	}
	m_ahAsyncTaskHandles[uiRandomStartIndex] = 0;

	return uiRandomStartIndex;
}

char* CIoctlSocket::GetRandomMachineName()
{
	return ::GetRandomMachineName();
}
/*
void PrintIPs()
{
	int i= 196;
	for (int j = 14; j < 257; j++)
	{
		printf("    \"157.58.%d.%d\",\n", i, j);
	}
	i= 197;
	for (j = 0; j < 257; j++)
	{
		printf("    \"157.58.%d.%d\",\n", i, j);
	}
	i= 198;
	for (j = 0; j < 257; j++)
	{
		printf("    \"157.58.%d.%d\",\n", i, j);
	}
	i= 199;
	for (j = 0; j < 254; j++)
	{
		printf("    \"157.58.%d.%d\",\n", i, j);
	}
}
*/

//
// both array values are from my dev's %SystemRoot%\System32\DRIVERS\ETC\protocol file
//
static char *s_aszansiProtocols[] =
{
	"ip",
	"icmp",
	"ggp",
	"tcp",
	"egp",
	"pup",
	"udp",
	"hmp",
	"xns-idp",
	"rdp",
	"rvd",
	"this is a fake protocol"
};
static int s_nProtocols[] =
{
	0,
	1,
	3,
	6,
	8,
	12,
	17,
	20,
	22,
	27,
	66
};

char* CIoctlSocket::GetRandomProtocolName()
{
	return s_aszansiProtocols[rand()%(sizeof(s_aszansiProtocols)/sizeof(s_aszansiProtocols[0]))];
}

int CIoctlSocket::GetRandomProtocolNumber()
{
	if (0 != rand()%20)
	{
		//
		// common case, return a valid protocol name
		//
		return s_nProtocols[rand()%(sizeof(s_nProtocols)/sizeof(s_nProtocols[0]))];
	}

	//
	// least common case - return a random number
	//
	return rand();
}

//
// this array values are from my dev's %SystemRoot%\System32\DRIVERS\ETC\services file
//
static char *s_aszansiServices[] =
{
	"echo",             
	"echo",             
	"discard",          
	"discard",          
	"systat",           
	"systat",           
	"daytime",          
	"daytime",          
	"qotd",             
	"qotd",             
	"chargen",          
	"chargen",          
	"ftp-data",         
	"ftp",              
	"telnet",           
	"smtp",             
	"time",             
	"time",             
	"rlp",              
	"nameserver",       
	"nameserver",       
	"nicname",          
	"domain",           
	"domain",           
	"bootps",           
	"bootpc",           
	"tftp",             
	"gopher",           
	"finger",           
	"http",             
	"kerberos",         
	"kerberos",         
	"hostname",         
	"iso-tsap",         
	"rtelnet",          
	"pop2",             
	"pop3",             
	"sunrpc",           
	"sunrpc",           
	"auth",             
	"uucp-path",        
	"nntp",             
	"ntp",              
	"epmap",            
	"epmap",            
	"netbios-ns",       
	"netbios-ns",       
	"netbios-dgm",      
	"netbios-ssn",      
	"imap",             
	"pcmail-srv",       
	"snmp",             
	"snmptrap",         
	"print-srv",        
	"bgp",              
	"irc",              
	"ipx",              
	"ldap",             
	"https",            
	"https",            
	"microsoft-ds",     
	"microsoft-ds",     
	"kpasswd",          
	"kpasswd",          
	"isakmp",           
	"exec",             
	"biff",             
	"login",            
	"who",              
	"cmd",              
	"syslog",           
	"printer",          
	"talk",             
	"ntalk",            
	"efs",              
	"router",           
	"timed",            
	"tempo",            
	"courier",          
	"conference",       
	"netnews",          
	"netwall",          
	"uucp",             
	"klogin",           
	"kshell",           
	"new-rwho",         
	"remotefs",         
	"rmonitor",         
	"monitor",          
	"ldaps",            
	"doom",             
	"doom",             
	"kerberos-adm",     
	"kerberos-adm",     
	"kerberos-iv",      
	"kpop",             
	"phone",            
	"ms-sql-s",         
	"ms-sql-s",         
	"ms-sql-m",         
	"ms-sql-m",         
	"wins",             
	"wins",             
	"ingreslock",       
	"l2tp",             
	"pptp",             
	"radius",           
	"radacct",          
	"nfsd",             
	"knetd",            
	"man"
};
char* CIoctlSocket::GetRandomServiceName()
{
	return s_aszansiServices[rand()%(sizeof(s_aszansiServices)/sizeof(s_aszansiServices[0]))];
}

//
// TODO: there should be a way of a user altering this list, to suit one's lab
// this can be derived from the machine's array
//
static char *s_aszansiIP[] =
{
    "157.58.196.14",
    "157.58.196.15",
    "157.58.196.16",
    "157.58.196.17",
    "157.58.196.18",
    "157.58.196.19",
    "157.58.196.20",
    "157.58.196.21",
    "157.58.196.22",
    "157.58.196.23",
    "157.58.196.24",
    "157.58.196.25",
    "157.58.196.26",
    "157.58.196.27",
    "157.58.196.28",
    "157.58.196.29",
    "157.58.196.30",
    "157.58.196.31",
    "157.58.196.32",
    "157.58.196.33",
    "157.58.196.34",
    "157.58.196.35",
    "157.58.196.36",
    "157.58.196.37",
    "157.58.196.38",
    "157.58.196.39",
    "157.58.196.40",
    "157.58.196.41",
    "157.58.196.42",
    "157.58.196.43",
    "157.58.196.44",
    "157.58.196.45",
    "157.58.196.46",
    "157.58.196.47",
    "157.58.196.48",
    "157.58.196.49",
    "157.58.196.50",
    "157.58.196.51",
    "157.58.196.52",
    "157.58.196.53",
    "157.58.196.54",
    "157.58.196.55",
    "157.58.196.56",
    "157.58.196.57",
    "157.58.196.58",
    "157.58.196.59",
    "157.58.196.60",
    "157.58.196.61",
    "157.58.196.62",
    "157.58.196.63",
    "157.58.196.64",
    "157.58.196.65",
    "157.58.196.66",
    "157.58.196.67",
    "157.58.196.68",
    "157.58.196.69",
    "157.58.196.70",
    "157.58.196.71",
    "157.58.196.72",
    "157.58.196.73",
    "157.58.196.74",
    "157.58.196.75",
    "157.58.196.76",
    "157.58.196.77",
    "157.58.196.78",
    "157.58.196.79",
    "157.58.196.80",
    "157.58.196.81",
    "157.58.196.82",
    "157.58.196.83",
    "157.58.196.84",
    "157.58.196.85",
    "157.58.196.86",
    "157.58.196.87",
    "157.58.196.88",
    "157.58.196.89",
    "157.58.196.90",
    "157.58.196.91",
    "157.58.196.92",
    "157.58.196.93",
    "157.58.196.94",
    "157.58.196.95",
    "157.58.196.96",
    "157.58.196.97",
    "157.58.196.98",
    "157.58.196.99",
    "157.58.196.100",
    "157.58.196.101",
    "157.58.196.102",
    "157.58.196.103",
    "157.58.196.104",
    "157.58.196.105",
    "157.58.196.106",
    "157.58.196.107",
    "157.58.196.108",
    "157.58.196.109",
    "157.58.196.110",
    "157.58.196.111",
    "157.58.196.112",
    "157.58.196.113",
    "157.58.196.114",
    "157.58.196.115",
    "157.58.196.116",
    "157.58.196.117",
    "157.58.196.118",
    "157.58.196.119",
    "157.58.196.120",
    "157.58.196.121",
    "157.58.196.122",
    "157.58.196.123",
    "157.58.196.124",
    "157.58.196.125",
    "157.58.196.126",
    "157.58.196.127",
    "157.58.196.128",
    "157.58.196.129",
    "157.58.196.130",
    "157.58.196.131",
    "157.58.196.132",
    "157.58.196.133",
    "157.58.196.134",
    "157.58.196.135",
    "157.58.196.136",
    "157.58.196.137",
    "157.58.196.138",
    "157.58.196.139",
    "157.58.196.140",
    "157.58.196.141",
    "157.58.196.142",
    "157.58.196.143",
    "157.58.196.144",
    "157.58.196.145",
    "157.58.196.146",
    "157.58.196.147",
    "157.58.196.148",
    "157.58.196.149",
    "157.58.196.150",
    "157.58.196.151",
    "157.58.196.152",
    "157.58.196.153",
    "157.58.196.154",
    "157.58.196.155",
    "157.58.196.156",
    "157.58.196.157",
    "157.58.196.158",
    "157.58.196.159",
    "157.58.196.160",
    "157.58.196.161",
    "157.58.196.162",
    "157.58.196.163",
    "157.58.196.164",
    "157.58.196.165",
    "157.58.196.166",
    "157.58.196.167",
    "157.58.196.168",
    "157.58.196.169",
    "157.58.196.170",
    "157.58.196.171",
    "157.58.196.172",
    "157.58.196.173",
    "157.58.196.174",
    "157.58.196.175",
    "157.58.196.176",
    "157.58.196.177",
    "157.58.196.178",
    "157.58.196.179",
    "157.58.196.180",
    "157.58.196.181",
    "157.58.196.182",
    "157.58.196.183",
    "157.58.196.184",
    "157.58.196.185",
    "157.58.196.186",
    "157.58.196.187",
    "157.58.196.188",
    "157.58.196.189",
    "157.58.196.190",
    "157.58.196.191",
    "157.58.196.192",
    "157.58.196.193",
    "157.58.196.194",
    "157.58.196.195",
    "157.58.196.196",
    "157.58.196.197",
    "157.58.196.198",
    "157.58.196.199",
    "157.58.196.200",
    "157.58.196.201",
    "157.58.196.202",
    "157.58.196.203",
    "157.58.196.204",
    "157.58.196.205",
    "157.58.196.206",
    "157.58.196.207",
    "157.58.196.208",
    "157.58.196.209",
    "157.58.196.210",
    "157.58.196.211",
    "157.58.196.212",
    "157.58.196.213",
    "157.58.196.214",
    "157.58.196.215",
    "157.58.196.216",
    "157.58.196.217",
    "157.58.196.218",
    "157.58.196.219",
    "157.58.196.220",
    "157.58.196.221",
    "157.58.196.222",
    "157.58.196.223",
    "157.58.196.224",
    "157.58.196.225",
    "157.58.196.226",
    "157.58.196.227",
    "157.58.196.228",
    "157.58.196.229",
    "157.58.196.230",
    "157.58.196.231",
    "157.58.196.232",
    "157.58.196.233",
    "157.58.196.234",
    "157.58.196.235",
    "157.58.196.236",
    "157.58.196.237",
    "157.58.196.238",
    "157.58.196.239",
    "157.58.196.240",
    "157.58.196.241",
    "157.58.196.242",
    "157.58.196.243",
    "157.58.196.244",
    "157.58.196.245",
    "157.58.196.246",
    "157.58.196.247",
    "157.58.196.248",
    "157.58.196.249",
    "157.58.196.250",
    "157.58.196.251",
    "157.58.196.252",
    "157.58.196.253",
    "157.58.196.254",
    "157.58.196.255",
    "157.58.196.256",
    "157.58.197.0",
    "157.58.197.1",
    "157.58.197.2",
    "157.58.197.3",
    "157.58.197.4",
    "157.58.197.5",
    "157.58.197.6",
    "157.58.197.7",
    "157.58.197.8",
    "157.58.197.9",
    "157.58.197.10",
    "157.58.197.11",
    "157.58.197.12",
    "157.58.197.13",
    "157.58.197.14",
    "157.58.197.15",
    "157.58.197.16",
    "157.58.197.17",
    "157.58.197.18",
    "157.58.197.19",
    "157.58.197.20",
    "157.58.197.21",
    "157.58.197.22",
    "157.58.197.23",
    "157.58.197.24",
    "157.58.197.25",
    "157.58.197.26",
    "157.58.197.27",
    "157.58.197.28",
    "157.58.197.29",
    "157.58.197.30",
    "157.58.197.31",
    "157.58.197.32",
    "157.58.197.33",
    "157.58.197.34",
    "157.58.197.35",
    "157.58.197.36",
    "157.58.197.37",
    "157.58.197.38",
    "157.58.197.39",
    "157.58.197.40",
    "157.58.197.41",
    "157.58.197.42",
    "157.58.197.43",
    "157.58.197.44",
    "157.58.197.45",
    "157.58.197.46",
    "157.58.197.47",
    "157.58.197.48",
    "157.58.197.49",
    "157.58.197.50",
    "157.58.197.51",
    "157.58.197.52",
    "157.58.197.53",
    "157.58.197.54",
    "157.58.197.55",
    "157.58.197.56",
    "157.58.197.57",
    "157.58.197.58",
    "157.58.197.59",
    "157.58.197.60",
    "157.58.197.61",
    "157.58.197.62",
    "157.58.197.63",
    "157.58.197.64",
    "157.58.197.65",
    "157.58.197.66",
    "157.58.197.67",
    "157.58.197.68",
    "157.58.197.69",
    "157.58.197.70",
    "157.58.197.71",
    "157.58.197.72",
    "157.58.197.73",
    "157.58.197.74",
    "157.58.197.75",
    "157.58.197.76",
    "157.58.197.77",
    "157.58.197.78",
    "157.58.197.79",
    "157.58.197.80",
    "157.58.197.81",
    "157.58.197.82",
    "157.58.197.83",
    "157.58.197.84",
    "157.58.197.85",
    "157.58.197.86",
    "157.58.197.87",
    "157.58.197.88",
    "157.58.197.89",
    "157.58.197.90",
    "157.58.197.91",
    "157.58.197.92",
    "157.58.197.93",
    "157.58.197.94",
    "157.58.197.95",
    "157.58.197.96",
    "157.58.197.97",
    "157.58.197.98",
    "157.58.197.99",
    "157.58.197.100",
    "157.58.197.101",
    "157.58.197.102",
    "157.58.197.103",
    "157.58.197.104",
    "157.58.197.105",
    "157.58.197.106",
    "157.58.197.107",
    "157.58.197.108",
    "157.58.197.109",
    "157.58.197.110",
    "157.58.197.111",
    "157.58.197.112",
    "157.58.197.113",
    "157.58.197.114",
    "157.58.197.115",
    "157.58.197.116",
    "157.58.197.117",
    "157.58.197.118",
    "157.58.197.119",
    "157.58.197.120",
    "157.58.197.121",
    "157.58.197.122",
    "157.58.197.123",
    "157.58.197.124",
    "157.58.197.125",
    "157.58.197.126",
    "157.58.197.127",
    "157.58.197.128",
    "157.58.197.129",
    "157.58.197.130",
    "157.58.197.131",
    "157.58.197.132",
    "157.58.197.133",
    "157.58.197.134",
    "157.58.197.135",
    "157.58.197.136",
    "157.58.197.137",
    "157.58.197.138",
    "157.58.197.139",
    "157.58.197.140",
    "157.58.197.141",
    "157.58.197.142",
    "157.58.197.143",
    "157.58.197.144",
    "157.58.197.145",
    "157.58.197.146",
    "157.58.197.147",
    "157.58.197.148",
    "157.58.197.149",
    "157.58.197.150",
    "157.58.197.151",
    "157.58.197.152",
    "157.58.197.153",
    "157.58.197.154",
    "157.58.197.155",
    "157.58.197.156",
    "157.58.197.157",
    "157.58.197.158",
    "157.58.197.159",
    "157.58.197.160",
    "157.58.197.161",
    "157.58.197.162",
    "157.58.197.163",
    "157.58.197.164",
    "157.58.197.165",
    "157.58.197.166",
    "157.58.197.167",
    "157.58.197.168",
    "157.58.197.169",
    "157.58.197.170",
    "157.58.197.171",
    "157.58.197.172",
    "157.58.197.173",
    "157.58.197.174",
    "157.58.197.175",
    "157.58.197.176",
    "157.58.197.177",
    "157.58.197.178",
    "157.58.197.179",
    "157.58.197.180",
    "157.58.197.181",
    "157.58.197.182",
    "157.58.197.183",
    "157.58.197.184",
    "157.58.197.185",
    "157.58.197.186",
    "157.58.197.187",
    "157.58.197.188",
    "157.58.197.189",
    "157.58.197.190",
    "157.58.197.191",
    "157.58.197.192",
    "157.58.197.193",
    "157.58.197.194",
    "157.58.197.195",
    "157.58.197.196",
    "157.58.197.197",
    "157.58.197.198",
    "157.58.197.199",
    "157.58.197.200",
    "157.58.197.201",
    "157.58.197.202",
    "157.58.197.203",
    "157.58.197.204",
    "157.58.197.205",
    "157.58.197.206",
    "157.58.197.207",
    "157.58.197.208",
    "157.58.197.209",
    "157.58.197.210",
    "157.58.197.211",
    "157.58.197.212",
    "157.58.197.213",
    "157.58.197.214",
    "157.58.197.215",
    "157.58.197.216",
    "157.58.197.217",
    "157.58.197.218",
    "157.58.197.219",
    "157.58.197.220",
    "157.58.197.221",
    "157.58.197.222",
    "157.58.197.223",
    "157.58.197.224",
    "157.58.197.225",
    "157.58.197.226",
    "157.58.197.227",
    "157.58.197.228",
    "157.58.197.229",
    "157.58.197.230",
    "157.58.197.231",
    "157.58.197.232",
    "157.58.197.233",
    "157.58.197.234",
    "157.58.197.235",
    "157.58.197.236",
    "157.58.197.237",
    "157.58.197.238",
    "157.58.197.239",
    "157.58.197.240",
    "157.58.197.241",
    "157.58.197.242",
    "157.58.197.243",
    "157.58.197.244",
    "157.58.197.245",
    "157.58.197.246",
    "157.58.197.247",
    "157.58.197.248",
    "157.58.197.249",
    "157.58.197.250",
    "157.58.197.251",
    "157.58.197.252",
    "157.58.197.253",
    "157.58.197.254",
    "157.58.197.255",
    "157.58.197.256",
    "157.58.198.0",
    "157.58.198.1",
    "157.58.198.2",
    "157.58.198.3",
    "157.58.198.4",
    "157.58.198.5",
    "157.58.198.6",
    "157.58.198.7",
    "157.58.198.8",
    "157.58.198.9",
    "157.58.198.10",
    "157.58.198.11",
    "157.58.198.12",
    "157.58.198.13",
    "157.58.198.14",
    "157.58.198.15",
    "157.58.198.16",
    "157.58.198.17",
    "157.58.198.18",
    "157.58.198.19",
    "157.58.198.20",
    "157.58.198.21",
    "157.58.198.22",
    "157.58.198.23",
    "157.58.198.24",
    "157.58.198.25",
    "157.58.198.26",
    "157.58.198.27",
    "157.58.198.28",
    "157.58.198.29",
    "157.58.198.30",
    "157.58.198.31",
    "157.58.198.32",
    "157.58.198.33",
    "157.58.198.34",
    "157.58.198.35",
    "157.58.198.36",
    "157.58.198.37",
    "157.58.198.38",
    "157.58.198.39",
    "157.58.198.40",
    "157.58.198.41",
    "157.58.198.42",
    "157.58.198.43",
    "157.58.198.44",
    "157.58.198.45",
    "157.58.198.46",
    "157.58.198.47",
    "157.58.198.48",
    "157.58.198.49",
    "157.58.198.50",
    "157.58.198.51",
    "157.58.198.52",
    "157.58.198.53",
    "157.58.198.54",
    "157.58.198.55",
    "157.58.198.56",
    "157.58.198.57",
    "157.58.198.58",
    "157.58.198.59",
    "157.58.198.60",
    "157.58.198.61",
    "157.58.198.62",
    "157.58.198.63",
    "157.58.198.64",
    "157.58.198.65",
    "157.58.198.66",
    "157.58.198.67",
    "157.58.198.68",
    "157.58.198.69",
    "157.58.198.70",
    "157.58.198.71",
    "157.58.198.72",
    "157.58.198.73",
    "157.58.198.74",
    "157.58.198.75",
    "157.58.198.76",
    "157.58.198.77",
    "157.58.198.78",
    "157.58.198.79",
    "157.58.198.80",
    "157.58.198.81",
    "157.58.198.82",
    "157.58.198.83",
    "157.58.198.84",
    "157.58.198.85",
    "157.58.198.86",
    "157.58.198.87",
    "157.58.198.88",
    "157.58.198.89",
    "157.58.198.90",
    "157.58.198.91",
    "157.58.198.92",
    "157.58.198.93",
    "157.58.198.94",
    "157.58.198.95",
    "157.58.198.96",
    "157.58.198.97",
    "157.58.198.98",
    "157.58.198.99",
    "157.58.198.100",
    "157.58.198.101",
    "157.58.198.102",
    "157.58.198.103",
    "157.58.198.104",
    "157.58.198.105",
    "157.58.198.106",
    "157.58.198.107",
    "157.58.198.108",
    "157.58.198.109",
    "157.58.198.110",
    "157.58.198.111",
    "157.58.198.112",
    "157.58.198.113",
    "157.58.198.114",
    "157.58.198.115",
    "157.58.198.116",
    "157.58.198.117",
    "157.58.198.118",
    "157.58.198.119",
    "157.58.198.120",
    "157.58.198.121",
    "157.58.198.122",
    "157.58.198.123",
    "157.58.198.124",
    "157.58.198.125",
    "157.58.198.126",
    "157.58.198.127",
    "157.58.198.128",
    "157.58.198.129",
    "157.58.198.130",
    "157.58.198.131",
    "157.58.198.132",
    "157.58.198.133",
    "157.58.198.134",
    "157.58.198.135",
    "157.58.198.136",
    "157.58.198.137",
    "157.58.198.138",
    "157.58.198.139",
    "157.58.198.140",
    "157.58.198.141",
    "157.58.198.142",
    "157.58.198.143",
    "157.58.198.144",
    "157.58.198.145",
    "157.58.198.146",
    "157.58.198.147",
    "157.58.198.148",
    "157.58.198.149",
    "157.58.198.150",
    "157.58.198.151",
    "157.58.198.152",
    "157.58.198.153",
    "157.58.198.154",
    "157.58.198.155",
    "157.58.198.156",
    "157.58.198.157",
    "157.58.198.158",
    "157.58.198.159",
    "157.58.198.160",
    "157.58.198.161",
    "157.58.198.162",
    "157.58.198.163",
    "157.58.198.164",
    "157.58.198.165",
    "157.58.198.166",
    "157.58.198.167",
    "157.58.198.168",
    "157.58.198.169",
    "157.58.198.170",
    "157.58.198.171",
    "157.58.198.172",
    "157.58.198.173",
    "157.58.198.174",
    "157.58.198.175",
    "157.58.198.176",
    "157.58.198.177",
    "157.58.198.178",
    "157.58.198.179",
    "157.58.198.180",
    "157.58.198.181",
    "157.58.198.182",
    "157.58.198.183",
    "157.58.198.184",
    "157.58.198.185",
    "157.58.198.186",
    "157.58.198.187",
    "157.58.198.188",
    "157.58.198.189",
    "157.58.198.190",
    "157.58.198.191",
    "157.58.198.192",
    "157.58.198.193",
    "157.58.198.194",
    "157.58.198.195",
    "157.58.198.196",
    "157.58.198.197",
    "157.58.198.198",
    "157.58.198.199",
    "157.58.198.200",
    "157.58.198.201",
    "157.58.198.202",
    "157.58.198.203",
    "157.58.198.204",
    "157.58.198.205",
    "157.58.198.206",
    "157.58.198.207",
    "157.58.198.208",
    "157.58.198.209",
    "157.58.198.210",
    "157.58.198.211",
    "157.58.198.212",
    "157.58.198.213",
    "157.58.198.214",
    "157.58.198.215",
    "157.58.198.216",
    "157.58.198.217",
    "157.58.198.218",
    "157.58.198.219",
    "157.58.198.220",
    "157.58.198.221",
    "157.58.198.222",
    "157.58.198.223",
    "157.58.198.224",
    "157.58.198.225",
    "157.58.198.226",
    "157.58.198.227",
    "157.58.198.228",
    "157.58.198.229",
    "157.58.198.230",
    "157.58.198.231",
    "157.58.198.232",
    "157.58.198.233",
    "157.58.198.234",
    "157.58.198.235",
    "157.58.198.236",
    "157.58.198.237",
    "157.58.198.238",
    "157.58.198.239",
    "157.58.198.240",
    "157.58.198.241",
    "157.58.198.242",
    "157.58.198.243",
    "157.58.198.244",
    "157.58.198.245",
    "157.58.198.246",
    "157.58.198.247",
    "157.58.198.248",
    "157.58.198.249",
    "157.58.198.250",
    "157.58.198.251",
    "157.58.198.252",
    "157.58.198.253",
    "157.58.198.254",
    "157.58.198.255",
    "157.58.198.256",
    "157.58.199.0",
    "157.58.199.1",
    "157.58.199.2",
    "157.58.199.3",
    "157.58.199.4",
    "157.58.199.5",
    "157.58.199.6",
    "157.58.199.7",
    "157.58.199.8",
    "157.58.199.9",
    "157.58.199.10",
    "157.58.199.11",
    "157.58.199.12",
    "157.58.199.13",
    "157.58.199.14",
    "157.58.199.15",
    "157.58.199.16",
    "157.58.199.17",
    "157.58.199.18",
    "157.58.199.19",
    "157.58.199.20",
    "157.58.199.21",
    "157.58.199.22",
    "157.58.199.23",
    "157.58.199.24",
    "157.58.199.25",
    "157.58.199.26",
    "157.58.199.27",
    "157.58.199.28",
    "157.58.199.29",
    "157.58.199.30",
    "157.58.199.31",
    "157.58.199.32",
    "157.58.199.33",
    "157.58.199.34",
    "157.58.199.35",
    "157.58.199.36",
    "157.58.199.37",
    "157.58.199.38",
    "157.58.199.39",
    "157.58.199.40",
    "157.58.199.41",
    "157.58.199.42",
    "157.58.199.43",
    "157.58.199.44",
    "157.58.199.45",
    "157.58.199.46",
    "157.58.199.47",
    "157.58.199.48",
    "157.58.199.49",
    "157.58.199.50",
    "157.58.199.51",
    "157.58.199.52",
    "157.58.199.53",
    "157.58.199.54",
    "157.58.199.55",
    "157.58.199.56",
    "157.58.199.57",
    "157.58.199.58",
    "157.58.199.59",
    "157.58.199.60",
    "157.58.199.61",
    "157.58.199.62",
    "157.58.199.63",
    "157.58.199.64",
    "157.58.199.65",
    "157.58.199.66",
    "157.58.199.67",
    "157.58.199.68",
    "157.58.199.69",
    "157.58.199.70",
    "157.58.199.71",
    "157.58.199.72",
    "157.58.199.73",
    "157.58.199.74",
    "157.58.199.75",
    "157.58.199.76",
    "157.58.199.77",
    "157.58.199.78",
    "157.58.199.79",
    "157.58.199.80",
    "157.58.199.81",
    "157.58.199.82",
    "157.58.199.83",
    "157.58.199.84",
    "157.58.199.85",
    "157.58.199.86",
    "157.58.199.87",
    "157.58.199.88",
    "157.58.199.89",
    "157.58.199.90",
    "157.58.199.91",
    "157.58.199.92",
    "157.58.199.93",
    "157.58.199.94",
    "157.58.199.95",
    "157.58.199.96",
    "157.58.199.97",
    "157.58.199.98",
    "157.58.199.99",
    "157.58.199.100",
    "157.58.199.101",
    "157.58.199.102",
    "157.58.199.103",
    "157.58.199.104",
    "157.58.199.105",
    "157.58.199.106",
    "157.58.199.107",
    "157.58.199.108",
    "157.58.199.109",
    "157.58.199.110",
    "157.58.199.111",
    "157.58.199.112",
    "157.58.199.113",
    "157.58.199.114",
    "157.58.199.115",
    "157.58.199.116",
    "157.58.199.117",
    "157.58.199.118",
    "157.58.199.119",
    "157.58.199.120",
    "157.58.199.121",
    "157.58.199.122",
    "157.58.199.123",
    "157.58.199.124",
    "157.58.199.125",
    "157.58.199.126",
    "157.58.199.127",
    "157.58.199.128",
    "157.58.199.129",
    "157.58.199.130",
    "157.58.199.131",
    "157.58.199.132",
    "157.58.199.133",
    "157.58.199.134",
    "157.58.199.135",
    "157.58.199.136",
    "157.58.199.137",
    "157.58.199.138",
    "157.58.199.139",
    "157.58.199.140",
    "157.58.199.141",
    "157.58.199.142",
    "157.58.199.143",
    "157.58.199.144",
    "157.58.199.145",
    "157.58.199.146",
    "157.58.199.147",
    "157.58.199.148",
    "157.58.199.149",
    "157.58.199.150",
    "157.58.199.151",
    "157.58.199.152",
    "157.58.199.153",
    "157.58.199.154",
    "157.58.199.155",
    "157.58.199.156",
    "157.58.199.157",
    "157.58.199.158",
    "157.58.199.159",
    "157.58.199.160",
    "157.58.199.161",
    "157.58.199.162",
    "157.58.199.163",
    "157.58.199.164",
    "157.58.199.165",
    "157.58.199.166",
    "157.58.199.167",
    "157.58.199.168",
    "157.58.199.169",
    "157.58.199.170",
    "157.58.199.171",
    "157.58.199.172",
    "157.58.199.173",
    "157.58.199.174",
    "157.58.199.175",
    "157.58.199.176",
    "157.58.199.177",
    "157.58.199.178",
    "157.58.199.179",
    "157.58.199.180",
    "157.58.199.181",
    "157.58.199.182",
    "157.58.199.183",
    "157.58.199.184",
    "157.58.199.185",
    "157.58.199.186",
    "157.58.199.187",
    "157.58.199.188",
    "157.58.199.189",
    "157.58.199.190",
    "157.58.199.191",
    "157.58.199.192",
    "157.58.199.193",
    "157.58.199.194",
    "157.58.199.195",
    "157.58.199.196",
    "157.58.199.197",
    "157.58.199.198",
    "157.58.199.199",
    "157.58.199.200",
    "157.58.199.201",
    "157.58.199.202",
    "157.58.199.203",
    "157.58.199.204",
    "157.58.199.205",
    "157.58.199.206",
    "157.58.199.207",
    "157.58.199.208",
    "157.58.199.209",
    "157.58.199.210",
    "157.58.199.211",
    "157.58.199.212",
    "157.58.199.213",
    "157.58.199.214",
    "157.58.199.215",
    "157.58.199.216",
    "157.58.199.217",
    "157.58.199.218",
    "157.58.199.219",
    "157.58.199.220",
    "157.58.199.221",
    "157.58.199.222",
    "157.58.199.223",
    "157.58.199.224",
    "157.58.199.225",
    "157.58.199.226",
    "157.58.199.227",
    "157.58.199.228",
    "157.58.199.229",
    "157.58.199.230",
    "157.58.199.231",
    "157.58.199.232",
    "157.58.199.233",
    "157.58.199.234",
    "157.58.199.235",
    "157.58.199.236",
    "157.58.199.237",
    "157.58.199.238",
    "157.58.199.239",
    "157.58.199.240",
    "157.58.199.241",
    "157.58.199.242",
    "157.58.199.243",
    "157.58.199.244",
    "157.58.199.245",
    "157.58.199.246",
    "157.58.199.247",
    "157.58.199.248",
    "157.58.199.249",
    "157.58.199.250",
    "157.58.199.251",
    "157.58.199.252",
    "157.58.199.253"
};
char* CIoctlSocket::GetRandomIP(DWORD *pdwLen)
{
	_ASSERTE(pdwLen);
	int nRand = rand()%(sizeof(s_aszansiIP)/sizeof(s_aszansiIP[0]));
	*pdwLen = strlen(s_aszansiIP[nRand]);
	return s_aszansiIP[nRand];
}

GROUP CIoctlSocket::GetRandomGroup()
{
	switch(rand()%12)
	{
	case 0: return IPPROTO_IP;
		break;

	case 1: return IPPROTO_ICMP;
		break;

	case 2: return IPPROTO_IGMP;
		break;

	case 3: return IPPROTO_GGP;
		break;

	case 4: return IPPROTO_TCP;
		break;

	case 5: return IPPROTO_PUP;
		break;

	case 6: return IPPROTO_UDP;
		break;

	case 7: return IPPROTO_IDP;
		break;

	case 8: return IPPROTO_ND;
		break;

	case 9: return IPPROTO_RAW;
		break;

	case 10: return IPPROTO_MAX;
		break;

	default: return rand();
	}
}

/*
The dwFlags parameter has three settings: 
TF_DISCONNECT 
Start a transport-level disconnect after all the file data has been queued for transmission. 
TF_REUSE_SOCKET 
Prepare the socket handle to be reused. When the TransmitFile request completes, the socket handle can be passed to the AcceptEx function. It is only valid if TF_DISCONNECT is also specified. 
TF_USE_DEFAULT_WORKER 
Directs the Windows Sockets service provider to use the system's default thread to process long TransmitFile requests. The system default thread can be adjusted using the following registry parameter as a REG_DWORD: 
CurrentControlSet\Services\afd\Parameters\TransmitWorker 

TF_USE_SYSTEM_THREAD 
Directs the Windows Sockets service provider to use system threads to process long TransmitFile requests. 
TF_USE_KERNEL_APC 
Directs the driver to use kernel Asynchronous Procedure Calls (APCs) instead of worker threads to process long TransmitFile requests. Long TransmitFile requests are defined as requests that require more than a single read from the file or a cache; the request therefore depends on the size of the file and the specified length of the send packet. 
Use of TF_USE_KERNEL_APC can deliver significant performance benefits. It is possibile (though unlikely), however, that the thread in which context TransmitFile is initiated is being used for heavy computations; this situation may prevent APCs from launching. Note that the Windows Sockets kernel mode driver uses normal kernel APCs, which launch whenever a thread is in a wait state, which differs from user-mode APCs, which launch whenever a thread is in an alertable wait state initiated in user mode). 

TF_WRITE_BEHIND 
Complete the TransmitFile request immediately, without pending. If this flag is specified and TransmitFile succeeds, then the data has been accepted by the system but not necessarily acknowledged by the remote end. Do not use this setting with the TF_DISCONNECT and TF_REUSE_SOCKET flags. 
*/
DWORD CIoctlSocket::GetRandomTransmitFileFlags()
{
	DWORD dwRet = 0;
	if (0 == rand()%6) dwRet |= TF_DISCONNECT;
	if (0 == rand()%6) dwRet |= TF_REUSE_SOCKET;
	if (0 == rand()%6) dwRet |= TF_USE_DEFAULT_WORKER;
	if (0 == rand()%6) dwRet |= TF_USE_SYSTEM_THREAD;
	if (0 == rand()%6) dwRet |= TF_USE_KERNEL_APC;
	if (0 == rand()%6) dwRet |= TF_WRITE_BEHIND;

	return dwRet;
}


DWORD CIoctlSocket::GetRandomAfdFlags()
{
	if (rand()%10) return AFD_OVERLAPPED;
	if (rand()%2) return AFD_NO_FAST_IO | AFD_OVERLAPPED;
	if (rand()%5) return AFD_NO_FAST_IO;
	if (rand()%5) return 0;
	return DWORD_RAND;
}


void SetRandom_TDI_REQUEST(TDI_REQUEST *pTDI_REQUEST)
{
	pTDI_REQUEST->RequestNotifyObject = GetRandomRequestNotifyObject();
	pTDI_REQUEST->RequestContext = GetRandomRequestContext();
	pTDI_REQUEST->TdiStatus = GetRandomTdiStatus();
	pTDI_REQUEST->Handle.ConnectionContext = GetRandomConnectionContext();
}

PVOID GetRandomRequestNotifyObject()
{
	if (0 == rand()%10) return CIoctl::GetRandomIllegalPointer();
	if (0 == rand()%5) return NULL;
	if (0 == rand()%7) return (PVOID)(0x80000000);
	if (0 == rand()%7) return (PVOID)(0x80000000+rand());
	return (PVOID)DWORD_RAND;
}

PVOID GetRandomRequestContext()
{
	if (0 == rand()%10) return CIoctl::GetRandomIllegalPointer();
	if (0 == rand()%5) return NULL;
	if (0 == rand()%7) return (PVOID)(0x80000000);
	if (0 == rand()%7) return (PVOID)(0x80000000+rand());
	return (PVOID)DWORD_RAND;
}

TDI_STATUS GetRandomTdiStatus()
{
	return DWORD_RAND;
}

/*
    union {
        HANDLE AddressHandle;
        CONNECTION_CONTEXT ConnectionContext;
        HANDLE ControlChannel;
    } Handle;
*/
CONNECTION_CONTEXT GetRandomConnectionContext()
{
	if (0 == rand()%10) return CIoctl::GetRandomIllegalPointer();
	if (0 == rand()%5) return NULL;
	if (0 == rand()%7) return (PVOID)(0x80000000);
	if (0 == rand()%7) return (PVOID)(0x80000000+rand());
	return (PVOID)DWORD_RAND;
}

TDI_CONNECTION_INFORMATION* GetRandom_TDI_CONNECTION_INFORMATION()
{
	static TDI_CONNECTION_INFORMATION tci;
	if (0 == rand()%5) return (TDI_CONNECTION_INFORMATION*)CIoctl::GetRandomIllegalPointer();

	return (SetRandom_TDI_CONNECTION_INFORMATION(&tci));
}

TDI_CONNECTION_INFORMATION*  SetRandom_TDI_CONNECTION_INFORMATION(TDI_CONNECTION_INFORMATION *pTci)
{
	pTci->UserDataLength = rand()%2 ? rand() : (0 - rand());//because it is signed!
	pTci->UserData = CIoctl::GetRandomIllegalPointer();
	pTci->OptionsLength = rand()%2 ? rand() : (0 - rand());//because it is signed!
	pTci->Options = CIoctl::GetRandomIllegalPointer();
	pTci->RemoteAddressLength = rand()%2 ? rand() : (0 - rand());//because it is signed!
	pTci->RemoteAddress = CIoctl::GetRandomIllegalPointer();

	return pTci;
}

LARGE_INTEGER GetRandom_Timeout()
{
	LARGE_INTEGER retval;
	retval.LowPart = rand()%2 ? 0 : rand()%2 ? rand() : DWORD_RAND;
	retval.HighPart = rand()%2 ? 0 : rand()%2 ? rand() : DWORD_RAND;
	return retval;


}

ULONG GetRandom_DisconnectMode()
{
	switch(rand()%7)
	{
	case 0: return AFD_PARTIAL_DISCONNECT_SEND;
	case 1: return AFD_PARTIAL_DISCONNECT_RECEIVE;
	case 2: return AFD_ABORTIVE_DISCONNECT;
	case 3: return AFD_UNCONNECT_DATAGRAM;
	case 4: return 0;
	case 5: return 0xffffffff;
	default: return rand();
	}
}

ULONG GetRandom_QueryModeFlags()
{
	if (rand()%4) return (AFD_QUERY_CONNECTION_HANDLE | AFD_QUERY_ADDRESS_HANDLE);
	if (rand()%2) return (AFD_QUERY_ADDRESS_HANDLE);
	if (rand()%10) return (AFD_QUERY_CONNECTION_HANDLE);
	if (rand()%2) return (0);
	return rand();
}

ULONG GetRandom_InformationType()
{
	switch(rand()%12)
	{
	case 0: return AFD_INLINE_MODE;
	case 1: return AFD_NONBLOCKING_MODE;
	case 2: return AFD_MAX_SEND_SIZE;
	case 3: return AFD_SENDS_PENDING;
	case 4: return AFD_MAX_PATH_SEND_SIZE;
	case 5: return AFD_RECEIVE_WINDOW_SIZE;
	case 6: return AFD_SEND_WINDOW_SIZE;
	case 7: return AFD_CONNECT_TIME;
	case 8: return AFD_CIRCULAR_QUEUEING;
	case 9: return AFD_GROUP_ID_AND_TYPE;
	case 10: return 0;
	default: return rand();
	}
}

void SetRandom_Context(void *pContext)
{
	DWORD dw = SIZEOF_INOUTBUFF;
	CIoctl::FillBufferWithRandomData(pContext, dw);
}

LONG GetRandom_Sequence()
{
	if (0 == rand()%2) return DWORD_RAND;
	if (0 == rand()%2) return 0;
	if (0 == rand()%2) return 0xffffffff;
	if (0 == rand()%2) return 0x7fffffff;
	if (0 == rand()%2) return rand()%1000;
	return rand();
}

ULONG GetRandom_ConnectDataLength()
{
	if (0 == rand()%2) return DWORD_RAND;
	if (0 == rand()%2) return 0;
	if (0 == rand()%2) return 0xffffffff;
	if (0 == rand()%2) return 0x7fffffff;
	if (0 == rand()%2) return rand()%1000;
	return rand();
}

void Add_AFD_GROUP_INFO(AFD_GROUP_INFO *pAFD_GROUP_INFO)
{
	UINT i = rand()%MAX_NUM_OF_REMEMBERED_ITEMS;
	s_aGroupID[i] = pAFD_GROUP_INFO->GroupID;
	s_aGroupType[i] = pAFD_GROUP_INFO->GroupType;
}

AFD_GROUP_INFO GetRandom_AFD_GROUP_INFO()
{
	AFD_GROUP_INFO retval;
	
	if (rand()%2) 
	{
		retval = *(AFD_GROUP_INFO*)(&(GetRandom_Timeout().QuadPart));
		return retval;
	}

	UINT i = rand()%MAX_NUM_OF_REMEMBERED_ITEMS;
	retval.GroupID = s_aGroupID[i];
	retval.GroupType = s_aGroupType[i];
	return retval;
}

LONG GetRandom_GroupID()
{
	if (rand()%10) return s_aGroupID[rand()%MAX_NUM_OF_REMEMBERED_ITEMS];
	if (rand()%2) return (rand()%100);
	if (rand()%2) return 0;
	if (rand()%2) return -1;
	if (rand()%2) return 0xfffffffe;
	return 0x7fffffff;
}


ULONG GetRandom_Flags()
{
	switch(rand()%8)
	{
	case 0: return AFD_TF_DISCONNECT;
	case 1: return AFD_TF_REUSE_SOCKET;
	case 2: return AFD_TF_WRITE_BEHIND;
	case 3: return AFD_TF_USE_DEFAULT_WORKER;
	case 4: return AFD_TF_USE_SYSTEM_THREAD;
	case 5: return AFD_TF_USE_KERNEL_APC;
	case 6: return AFD_TF_WORKER_KIND_MASK;
	default: return rand();
	}
}

LARGE_INTEGER GetRandom_WriteLength()
{
	LARGE_INTEGER retval;
	retval.QuadPart = rand()%2 ? rand() : rand()%2 ? DWORD_RAND : 0;
	return (retval);
}

LARGE_INTEGER GetRandom_Offset()
{
	LARGE_INTEGER retval;
	retval.QuadPart = rand()%2 ? rand() : rand()%2 ? rand()*100 : rand()%2 ? DWORD_RAND : 0;
	return (retval);
}

ULONG GetRandom_SendPacketLength()
{
	return (rand()%2 ? rand() : rand()%2 ? rand()*100 : 0);
}

HANDLE CIoctlSocket::GetRandom_AcceptHandle()
{
	//
	// return some illegal handles or rare occasions
	//
	if (0 == rand()%50) return m_ahTdiAddressHandle;
	if (0 == rand()%50) return m_ahTdiConnectionHandle;
	if (0 == rand()%50) return m_ahDeviceAfdHandle;
	//
	// do not mess with the zero index, because it is my main handle for IOCTelling
	//
	UINT i = 1+rand()%(MAX_NUM_OF_ACCEPTING_SOCKETS-1);
	if (0 == rand()%50) return ((HANDLE)m_asAcceptingSocket[i]);
	
	//
	// close the socket, no matter what, even if it is invalid
	// because i do not want to leak
	//
	SOCKET s = CreateSocket(m_pDevice);
	if (s == INVALID_SOCKET)
	{
		//
		// CreateSocket() failed, so return a random value, legal or not
		//
		if (0 == rand()%2) return (GetRandom_FileHandle());
		return ((HANDLE)m_asAcceptingSocket[i]);
	}

	//
	// we have a socket, lets put it in the array, and close whatever socket we get back
	//
	SOCKET sToClose = (SOCKET)InterlockedExchangePointer(&m_asAcceptingSocket[i], s);

	::closesocket(sToClose);

	return ((HANDLE)s);
}

void Add_AFD_LISTEN_RESPONSE_INFO(CIoctlSocket* pThis, AFD_LISTEN_RESPONSE_INFO* pAFD_LISTEN_RESPONSE_INFO)
{
	pThis->m_aSequence[rand()%MAX_NUM_OF_REMEMBERED_ITEMS] = pAFD_LISTEN_RESPONSE_INFO->Sequence;
	Add_TRANSPORT_ADDRESS(pThis, &pAFD_LISTEN_RESPONSE_INFO->RemoteAddress);
}

void Add_TRANSPORT_ADDRESS(CIoctlSocket* pThis, TRANSPORT_ADDRESS* pTRANSPORT_ADDRESS)
{
	for (LONG iAddresses = 0; iAddresses < pTRANSPORT_ADDRESS->TAAddressCount; iAddresses++)
	{
		Add_TA_ADDRESS(pThis, &pTRANSPORT_ADDRESS->Address[iAddresses]);
	}
}



void SetRandom_TRANSPORT_ADDRESS(CIoctlSocket* pThis, TRANSPORT_ADDRESS *pTRANSPORT_ADDRESS)
{
	pTRANSPORT_ADDRESS->TAAddressCount = rand()%10;
	TA_ADDRESS* pNextTA_ADDRESS = &pTRANSPORT_ADDRESS->Address[0];
	for (LONG i = 0; i < pTRANSPORT_ADDRESS->TAAddressCount; i++)
	{
		SetRandom_TA_ADDRESS(pThis, pNextTA_ADDRESS);
		//
		// be very carefull here, because the length may be bogus, so lets just
		// limit the length in the calculation
		//
		LONG lActualLengthValue = pNextTA_ADDRESS->AddressLength;
		LONG lLengthForCalculation;
		if (0 != lActualLengthValue)
		{
			lLengthForCalculation = (abs(lActualLengthValue))%1000;
		}
		else
		{
			lLengthForCalculation = 0;
		}
		pNextTA_ADDRESS += FIELD_OFFSET(TA_ADDRESS, Address[0]) + lLengthForCalculation;
	}

	//
	// TAAddressCount is of type LONG, so try a negative once in a while
	//
	if (0 == rand()%10) pTRANSPORT_ADDRESS->TAAddressCount = -pTRANSPORT_ADDRESS->TAAddressCount;
	if (0 == rand()%10) pTRANSPORT_ADDRESS->TAAddressCount++;
	if (0 == rand()%10) pTRANSPORT_ADDRESS->TAAddressCount--;
}

void Add_TA_ADDRESS(CIoctlSocket* pThis, TA_ADDRESS *pTA_ADDRESS)
{
	if (pTA_ADDRESS->AddressLength > sizeof(s_apbTA_ADDRESS_Buffers[0])-100);
	{
		DPF((TEXT("Add_TA_ADDRESS(): pTA_ADDRESS->AddressLength=%d, not adding it.\n"), pTA_ADDRESS->AddressLength));
		return;
	}
	UINT i = rand()%MAX_NUM_OF_REMEMBERED_ITEMS;
	*s_apTA_ADDRESS[i] = *pTA_ADDRESS;
	CopyMemory(s_apTA_ADDRESS[i]->Address, pTA_ADDRESS->Address, pTA_ADDRESS->AddressLength); 
}

void SetRandom_TA_ADDRESS(CIoctlSocket* pThis, TA_ADDRESS *pTA_ADDRESS)
{
	UINT i = rand()%MAX_NUM_OF_REMEMBERED_ITEMS;
	*pTA_ADDRESS = *s_apTA_ADDRESS[i];
	CopyMemory(pTA_ADDRESS->Address, s_apTA_ADDRESS[i]->Address, s_apTA_ADDRESS[i]->AddressLength); 
	//
	// once in a while, put my random stuff inside
	//
	if (rand()%10) return;

	if (0 == rand()%2) pTA_ADDRESS->AddressType = GetRandom_AddressType();
	if (0 == rand()%2) 
	{
		pTA_ADDRESS->AddressLength++;
	}
	else
	{
		if (0 == rand()%2)
		{
			pTA_ADDRESS->AddressLength--;
		}
		else
		{
			if (0 == rand()%2) pTA_ADDRESS->AddressLength = 0xffff;
		}
	}

}

USHORT GetRandom_AddressType()
{
	switch(rand()%26)
	{
	case 0: return TDI_ADDRESS_TYPE_UNSPEC;
	case 1: return TDI_ADDRESS_TYPE_UNIX;
	case 2: return TDI_ADDRESS_TYPE_IP;
	case 3: return TDI_ADDRESS_TYPE_IMPLINK;
	case 4: return TDI_ADDRESS_TYPE_PUP;
	case 5: return TDI_ADDRESS_TYPE_CHAOS;
	case 6: return TDI_ADDRESS_TYPE_NS;
	case 7: return TDI_ADDRESS_TYPE_IPX;
	case 8: return TDI_ADDRESS_TYPE_NBS;
	case 9: return TDI_ADDRESS_TYPE_ECMA;
	case 10: return TDI_ADDRESS_TYPE_DATAKIT;
	case 11: return TDI_ADDRESS_TYPE_CCITT;
	case 12: return TDI_ADDRESS_TYPE_SNA;
	case 13: return TDI_ADDRESS_TYPE_DECnet;
	case 14: return TDI_ADDRESS_TYPE_DLI;
	case 15: return TDI_ADDRESS_TYPE_LAT;
	case 16: return TDI_ADDRESS_TYPE_HYLINK;
	case 17: return TDI_ADDRESS_TYPE_APPLETALK;
	case 18: return TDI_ADDRESS_TYPE_NETBIOS;
	case 19: return TDI_ADDRESS_TYPE_8022;
	case 20: return TDI_ADDRESS_TYPE_OSI_TSAP;
	case 21: return TDI_ADDRESS_TYPE_NETONE;
	case 22: return TDI_ADDRESS_TYPE_VNS;
	case 23: return TDI_ADDRESS_TYPE_NETBIOS_EX;
	case 24: return TDI_ADDRESS_TYPE_IP6;
	default: return (rand());
	}
}


HANDLE CIoctlSocket::GetRandomEventHandle()
{
	UINT i = rand()%ARRSIZE(m_ahEvents);
	if (NULL != m_ahEvents[i]) return m_ahEvents[i];

	//
	// lets try to fill this entry, but don't care if i fail.
	//
	m_ahEvents[i] = ::CreateEvent(NULL, TRUE, FALSE, NULL);
	return (m_ahEvents[i]);//an actual event, or NULL
}


ULONG CIoctlSocket::GetRandom_PollEvents()
{
	if (0 == rand()%20) return (DWORD_RAND);

	ULONG lRes = 0;
	if (0 == rand()%20) lRes |= AFD_POLL_RECEIVE;
	if (0 == rand()%20) lRes |= AFD_POLL_RECEIVE_EXPEDITED;
	if (0 == rand()%20) lRes |= AFD_POLL_SEND;
	if (0 == rand()%20) lRes |= AFD_POLL_DISCONNECT;
	if (0 == rand()%20) lRes |= AFD_POLL_ABORT;
	if (0 == rand()%20) lRes |= AFD_POLL_LOCAL_CLOSE;
	if (0 == rand()%20) lRes |= AFD_POLL_CONNECT;
	if (0 == rand()%20) lRes |= AFD_POLL_ACCEPT;
	if (0 == rand()%20) lRes |= AFD_POLL_CONNECT_FAIL;
	if (0 == rand()%20) lRes |= AFD_POLL_QOS;
	if (0 == rand()%20) lRes |= AFD_POLL_GROUP_QOS;
	if (0 == rand()%20) lRes |= AFD_POLL_ROUTING_IF_CHANGE;
	if (0 == rand()%20) lRes |= AFD_POLL_ADDRESS_LIST_CHANGE;
	if (0 == rand()%20) lRes |= AFD_POLL_ALL;

	return lRes;
}

ULONG CIoctlSocket::GetRandom_ShareAccess()
{
	switch(rand()%5)
	{
	case 0: return AFD_NORMALADDRUSE;
	case 1: return AFD_REUSEADDRESS;
	case 2: return AFD_WILDCARDADDRESS;
	case 3: return AFD_EXCLUSIVEADDRUSE;
	default: return rand();
	}
}


ULONG CIoctlSocket::GetRandom_TdiFlags()
{
	ULONG ulRetval = 0;
	if (0 == rand()%100) return 0;
	if (0 == rand()%100) return DWORD_RAND;
	if (0 == rand()%100) return 0xffffffff;
	if (0 == rand()%20) ulRetval |= TDI_RECEIVE_BROADCAST;
	if (0 == rand()%20) ulRetval |= TDI_RECEIVE_MULTICAST;
	if (0 == rand()%20) ulRetval |= TDI_RECEIVE_PARTIAL;
	if (0 == rand()%20) ulRetval |= TDI_RECEIVE_NORMAL;
	if (0 == rand()%20) ulRetval |= TDI_RECEIVE_EXPEDITED;
	if (0 == rand()%20) ulRetval |= TDI_RECEIVE_PEEK;
	if (0 == rand()%20) ulRetval |= TDI_RECEIVE_NO_RESPONSE_EXP;
	if (0 == rand()%20) ulRetval |= TDI_RECEIVE_COPY_LOOKAHEAD;
	if (0 == rand()%20) ulRetval |= TDI_RECEIVE_ENTIRE_MESSAGE;
	if (0 == rand()%20) ulRetval |= TDI_RECEIVE_AT_DISPATCH_LEVEL;

	return ulRetval;
}

void SetRand_Qos(QOS *pQOS)
{
	SetRandom_FLOWSPEC(&pQOS->SendingFlowspec);
	SetRandom_FLOWSPEC(&pQOS->ReceivingFlowspec);
	SetRandom_WSABUF(&pQOS->ProviderSpecific);
}

void SetRandom_FLOWSPEC(FLOWSPEC* pFLOWSPEC)
{
	pFLOWSPEC->TokenRate = rand()%2 ? DWORD_RAND : rand()%2 ? 0 : rand()%2 ? 0xffffffff : rand()%2 ? 0xfffffffe : rand();
	pFLOWSPEC->TokenBucketSize = rand()%2 ? DWORD_RAND : rand()%2 ? 0 : rand()%2 ? 0xffffffff : rand()%2 ? 0xfffffffe : rand();
	pFLOWSPEC->PeakBandwidth = rand()%2 ? DWORD_RAND : rand()%2 ? 0 : rand()%2 ? 0xffffffff : rand()%2 ? 0xfffffffe : rand();
	pFLOWSPEC->Latency = rand()%2 ? DWORD_RAND : rand()%2 ? 0 : rand()%2 ? 0xffffffff : rand()%2 ? 0xfffffffe : rand();
	pFLOWSPEC->DelayVariation = rand()%2 ? DWORD_RAND : rand()%2 ? 0 : rand()%2 ? 0xffffffff : rand()%2 ? 0xfffffffe : rand();
	pFLOWSPEC->ServiceType = rand()%2 ? DWORD_RAND : rand()%2 ? 0 : rand()%2 ? 0xffffffff : rand()%2 ? 0xfffffffe : rand();
	pFLOWSPEC->MaxSduSize = rand()%2 ? DWORD_RAND : rand()%2 ? 0 : rand()%2 ? 0xffffffff : rand()%2 ? 0xfffffffe : rand();
	pFLOWSPEC->MinimumPolicedSize = rand()%2 ? DWORD_RAND : rand()%2 ? 0 : rand()%2 ? 0xffffffff : rand()%2 ? 0xfffffffe : rand();
}

WSABUF* SetRandom_WSABUF(WSABUF* pWSABUF)
{
	pWSABUF->len = rand();
	pWSABUF->buf = (char FAR *)DWORD_RAND;

	return pWSABUF;
}

HANDLE CIoctlSocket::GetRandom_RootEndpoint()
{
	return (rand()%2 ? m_pDevice->m_hDevice : rand()%2 ? (HANDLE)m_sListeningSocket : rand()%2 ? GetRandom_AcceptHandle() : rand()%2 ? GetRandom_FileHandle() : (HANDLE)(CIoctl::GetRandomIllegalPointer()));
}

HANDLE CIoctlSocket::GetRandom_ConnectEndpoint()
{
	return (rand()%2 ? m_pDevice->m_hDevice : rand()%2 ? (HANDLE)m_sListeningSocket : rand()%2 ? GetRandom_AcceptHandle() : rand()%2 ? GetRandom_FileHandle() : (HANDLE)(CIoctl::GetRandomIllegalPointer()));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\socketserverioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*

*/
#define MAX_PORT_NUM (0xFFFF)
//
// must be defined 1st to override winsock1
//
//#include <winsock2.h>


//
// defines for WSASocet() params
//
#define PROTO_TYPE_UNICAST          0 
#define PROTO_TYPE_MCAST            1 
#define PROTOCOL_ID(Type, VendorMajor, VendorMinor, Id) (((Type)<<28)|((VendorMajor)<<24)|((VendorMinor)<<16)|(Id)) 


/*
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
*/
#include "SocketServerIOCTL.h"

static bool s_fVerbose = false;

//
// LPWSAOVERLAPPED_COMPLETION_ROUTINE 
// we do not use it, but we need it defined for the overlapped UDP ::WSARecvFrom()
//
static void __stdcall fn(
    DWORD dwError,
    DWORD cbTransferred,
    LPWSAOVERLAPPED lpOverlapped,
    DWORD dwFlags
    )                                             
{
    UNREFERENCED_PARAMETER(dwError);
    UNREFERENCED_PARAMETER(cbTransferred);
    UNREFERENCED_PARAMETER(lpOverlapped);
    UNREFERENCED_PARAMETER(dwFlags);
    return;
}


CIoctlSocketServer::CIoctlSocketServer(CDevice *pDevice): 
	CIoctlSocket(pDevice)
{
	;
}

CIoctlSocketServer::~CIoctlSocketServer()
{
    ;
}


HANDLE CIoctlSocketServer::CreateDevice(CDevice *pDevice)
{    
	m_sListeningSocket = CreateSocket(pDevice);
	if (INVALID_SOCKET == m_sListeningSocket)
	{
		return INVALID_HANDLE_VALUE;
	}

	if (!Bind(pDevice, SERVER_SIDE))
	{
		//
		// so i did not bind, let's IOCTL (m_sListeningSocket) anyway!
		//
		return (HANDLE)m_sListeningSocket;
		//goto error_exit;
	}

    //
    // listen (on TCP) or WSARecvFrom (on UDP).
    // do not care if I fail.
    //
	//
	// BUGBUG: should i insist on lintening because of fault-injections?
	//
	if (true)//m_fTCP
	{
		if (SOCKET_ERROR == ::listen(m_sListeningSocket, SOMAXCONN))
		{
			DPF((TEXT("listen() failed with %d.\n"), ::WSAGetLastError()));
		}
		else
		{
			DPF((TEXT("listen() SUCCEEDED\n")));
		}
	}
	else//UDP BUGBUG: NIY
	{
		//
		// these must be static, because when we close the socket, the overlapped is aborted
		//
		static char buff[1024];
		static WSABUF wsabuff;
		wsabuff.buf = buff;
		wsabuff.len = sizeof(buff);
		static DWORD dwNumberOfBytesRecvd;
		static WSAOVERLAPPED wsaOverlapped;
		DWORD dwFlags = MSG_PEEK;

		if (SOCKET_ERROR == 
			::WSARecvFrom (
				m_sListeningSocket,                                               
				&wsabuff,                                     
				1,                                    
				&dwNumberOfBytesRecvd,                           
				&dwFlags,                                        
				NULL,//struct sockaddr FAR * lpFrom,                           
				NULL,//LPINT lpFromlen,                                        
				&wsaOverlapped,                           
				fn  
				)
		   )
		{
			if (::WSAGetLastError() != ERROR_IO_PENDING)
			{
				//HOGGERDPF(("CWSASocketHog::CreatePseudoHandle(%d): WSARecvFrom(%d) failed with %d, m_dwOccupiedAddresses=%d.\n", index, wAddress, ::WSAGetLastError(), m_dwOccupiedAddresses));
			}
		}
		else
		{
			//HOGGERDPF(("CWSASocketHog::CreatePseudoHandle(%d): listen(%d) SUCCEEDED instead failing with ERROR_IO_PENDING, m_dwOccupiedAddresses=%d.\n", index, wAddress, ::WSAGetLastError(), m_dwOccupiedAddresses));
		}
	}

	//
	// we may have failed to listen, but since i don't mind failing, i try to accept anyways
	// it is actually an interesting testcase to accept if listen faile
	//
/*
	SOCKET sAccept = ::accept(
		m_sListeningSocket,                   
		NULL, //struct sockaddr FAR *addr,  
		NULL //int FAR *addrlen            
		);
*/
	//
	// TODO: the m_asAcceptingSocket can accept several connections.
	// the code does not support it yet, so only 1 accept is performed
	//
	m_asAcceptingSocket[0] = ::WSAAccept(
		m_sListeningSocket,                   
		NULL, //struct sockaddr FAR *addr,  
		NULL, //int FAR *addrlen            
		NULL, 
		NULL
		);
	if (INVALID_SOCKET == m_asAcceptingSocket[0])
	{
		//
		// return the WSASocket() and not the accept()
		// it may may be interesting to IOCTL this and not that
		//
		return (HANDLE)m_sListeningSocket;
	}
	else
	{
		_ASSERTE(INVALID_HANDLE_VALUE != (HANDLE)m_asAcceptingSocket[0]);
		return (HANDLE)m_asAcceptingSocket[0];
	}

	return (HANDLE)m_asAcceptingSocket[0];
}


BOOL CIoctlSocketServer::CloseDevice(CDevice *pDevice)
{
	::closesocket(m_asAcceptingSocket[0]);
	m_asAcceptingSocket[0] = INVALID_SOCKET;

    return (CloseSocket(pDevice));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\stdoutputioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <windows.h>

#include "NtNativeIOCTL.h"
*/
#include "StdOutputIOCTL.h"

static bool s_fVerbose = false;

void CIoctlStdOutput::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
	;
}

void CIoctlStdOutput::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
    ;//CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
}

HANDLE CIoctlStdOutput::CreateDevice(CDevice *pDevice)
{
//#define STD_OUTPUT_HANDLE      (ULONG)-11
    return (HANDLE)STD_OUTPUT_HANDLE;
}

BOOL CIoctlStdOutput::CloseDevice(CDevice *pDevice)
{
	//
	// i do not want to close anything, since i use the console
	// TODO: i may wish to close, i i add functionality, but now there's no reason
	//
	return TRUE;
}


void CIoctlStdOutput::CallRandomWin32API(LPOVERLAPPED pOL)
{
	//
	// TODO: there must be some intersting APIs here
	//
	return;
}


BOOL CIoctlStdOutput::FindValidIOCTLs(CDevice *pDevice)
{
    AddIOCTL(pDevice, 0);
	return TRUE;

    //return CIoctl::FindValidIOCTLs(pDevice);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\srvioctl.cpp ===
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>

#include "DefaultIOCTL.h"




void CIoctlDefault::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    ;
}

void CIoctlDefault::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
    CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
}


BOOL CIoctlDefault::FindValidIOCTLs(CDevice *pDevice)
{
    return CIoctl::FindValidIOCTLs(pDevice);
}
VOID
RtlInitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitUnicodeString function initializes an NT counted
    unicode string.  The DestinationString is initialized to point to
    the SourceString and the Length and MaximumLength fields of
    DestinationString are initialized to the length of the SourceString,
    which is zero if SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated unicode string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PWSTR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = wcslen( SourceString ) * sizeof( WCHAR );
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));
        }
    else {
        DestinationString->MaximumLength = 0;
        DestinationString->Length = 0;
        }
}

#define SERVER_DEVICE_NAME TEXT("\\Device\\LanmanServer")
void f()
{
	HANDLE hDevice = INVALID_HANDLE_VALUE;

    NTSTATUS status;
    UNICODE_STRING unicodeServerName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;

    //
    // Open the server device.
    //

    RtlInitUnicodeString( &unicodeServerName, SERVER_DEVICE_NAME );

    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeServerName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Opening the server with desired access = SYNCHRONIZE and open
    // options = FILE_SYNCHRONOUS_IO_NONALERT means that we don't have
    // to worry about waiting for the NtFsControlFile to complete--this
    // makes all IO system calls that use this handle synchronous.
    //

    status = NtOpenFile(
                 &hDevice,
                 FILE_ALL_ACCESS & ~SYNCHRONIZE,
                 &objectAttributes,
                 &ioStatusBlock,
                 0,
                 0
                 );

    if ( NT_SUCCESS(status) ) {
        status = ioStatusBlock.Status;
    }

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(INITIALIZATION_ERRORS) {
            SS_PRINT(( "SsOpenServer: NtOpenFile (server device object) "
                          "failed: %X\n", status ));
        }
        return NetpNtStatusToApiStatus( status );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\stdoutputioctl.h ===
#ifndef __STD_OUTPUT_IOCTL_H
#define __STD_OUTPUT_IOCTL_H



class CIoctlStdOutput : public CIoctl
{
public:
    CIoctlStdOutput(CDevice *pDevice): CIoctl(pDevice){;};
    virtual ~CIoctlStdOutput(){;};

	virtual HANDLE CreateDevice(CDevice *pDevice);

	virtual BOOL CloseDevice(CDevice *pDevice);

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

	void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	void PrepareIOCTLParams(
		DWORD& dwIOCTL,
		BYTE *abInBuffer,
		DWORD &dwInBuff,
		BYTE *abOutBuffer,
		DWORD &dwOutBuff
		);

	//
	// for some reason (buffer pageheap?), I get AV in this call, so i override it, and protect it
	//
	virtual BOOL DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		)
	{
		__try
		{
			return ::WriteFile(
				hFile,                    // handle to file to write to
				lpBuffer,                // pointer to data to write to file
				nNumberOfBytesToWrite,     // number of bytes to write
				lpNumberOfBytesWritten,  // pointer to number of bytes written
				lpOverlapped        // pointer to structure for overlapped I/O
				);
		}__except(1)
		{
			SetLastError(::GetExceptionCode());
			return FALSE;
		}
	}
/*
	virtual BOOL DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		)
	{
		return ::ReadFile(
			hFile,                // handle of file to read
			lpBuffer,             // pointer to buffer that receives data
			nNumberOfBytesToRead,  // number of bytes to read
			lpNumberOfBytesRead, // pointer to number of bytes read
			lpOverlapped    // pointer to structure for data
			);
	}
*/
};




#endif //__STD_OUTPUT_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\sysaudioioctl.h ===
#ifndef __SYSAUDIO_IOCTL_H
#define __SYSAUDIO_IOCTL_H

//#include "IOCTL.h"


class CIoctlSysAudio : public CIoctl
{
public:
    CIoctlSysAudio(CDevice *pDevice): CIoctl(pDevice){;};
    virtual ~CIoctlSysAudio(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

};




#endif //__SYSAUDIO_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\tcpipcommon.h ===
#ifndef __TCP_IP_COMMON_H
#define __TCP_IP_COMMON_H

void TcpIpCommon_PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    );

void GetRandomContext(ULONG_PTR *Context/*[CONTEXT_SIZE/sizeof(ULONG_PTR)]*/);
void GetRandomtei_instance(TDIEntityID *pTDIEntityID);
void GetRandomtei_entity(TDIEntityID *pTDIEntityID);
void GetRandomtoi_id(TDIObjectID *pID);
void GetRandomtoi_type(TDIObjectID *pID);
void GetRandomtoi_class(TDIObjectID *pID);
void GetRandomTDIEntityID(TDIEntityID *pTDIEntityID);
void GetRandomTDIObjectID(TDIObjectID *pID);


#endif //__TCP_IP_COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\tcpclientioctl.h ===
#ifndef __TCP_CLIENT_IOCTL_H
#define __TCP_CLIENT_IOCTL_H


//#include "IOCTL.h"
#include "SocketClientIOCTL.h"

#define szANSI_TCP_CLIENT "-TCP-client-"

class CIoctlTCPClient : public CIoctlSocketClient
{
public:
    CIoctlTCPClient(CDevice *pDevice): CIoctlSocketClient(pDevice){;};
    virtual ~CIoctlTCPClient()
	{
		CIoctlSocketClient::CloseDevice(m_pDevice);
	}

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual HANDLE CreateDevice(CDevice *pDevice);

	virtual BOOL CloseDevice(CDevice *pDevice);

	virtual BOOL DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		);

	virtual BOOL DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

	virtual BOOL DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		);
/*
	virtual BOOL DeviceCancelIo(
		HANDLE hFile  // file handle for which to cancel I/O
		);
*/

protected:
	virtual u_short GetServerPort(CDevice *pDevice);
	ULONG GetRandomQueryType();

};




#endif //__TCP_CLIENT_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\tcpioctl.h ===
#ifndef __TCP_IOCTL_H
#define __TCP_IOCTL_H

//#include "NtNativeIOCTL.h"


//class CIoctlTcp : public CIoctl
class CIoctlTcp : public CIoctlNtNative
{
public:
    CIoctlTcp(CDevice *pDevice): CIoctlNtNative(pDevice)
	{
		_ASSERTE(
			(0 == lstrcmpi(TEXT("\\Device\\Tcp"), pDevice->GetDeviceName())) ||
			(0 == lstrcmpi(TEXT("\\Device\\Udp"), pDevice->GetDeviceName())) ||
			(0 == lstrcmpi(TEXT("\\Device\\RawIp"), pDevice->GetDeviceName())) ||
			//or it can be \Device\RawIp\<#>
			(0 == _tcsncicmp(TEXT("\\Device\\RawIp\\"), pDevice->GetDeviceName(), lstrlen(TEXT("\\Device\\RawIp\\"))))
			);
	}
    virtual ~CIoctlTcp(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);
/*

	virtual HANDLE CreateDevice(CDevice *pDevice);

	virtual BOOL CloseDevice(CDevice *pDevice);

	virtual BOOL DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		);

	virtual BOOL DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		);

	virtual BOOL DeviceCancelIo(
		HANDLE hFile  // file handle for which to cancel I/O
		);


	virtual BOOL DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		);
*/

};




#endif //__TCP_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\sysaudioioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*



#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
*/
#include "SysAudioIOCTL.h"

static bool s_fVerbose = false;

/////////////////////////////////////////////////////////////////////
// from nt\private\ntos\dd\wdm\audio\inc\wdmaud.h
/////////////////////////////////////////////////////////////////////

// IOCTL set for WDMAUD

#ifdef UNDER_NT

#include <devioctl.h>
#define WDMAUD_CTL_CODE CTL_CODE

#else

#define FILE_DEVICE_SOUND               0x0000001d

//
// Define the method codes for how buffers are passed for I/O and FS controls
//
#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//
#define FILE_ANY_ACCESS                 0
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

#define WDMAUD_CTL_CODE( DeviceType, Function, Method, Access ) (ULONG)(   \
    ((ULONG)(DeviceType) << 16) | ((ULONG)(Access) << 14) | ((ULONG)(Function) << 2) | (ULONG)(Method) \
)

#endif

#define IOCTL_SOUND_BASE    FILE_DEVICE_SOUND
#define IOCTL_WDMAUD_BASE   0x0000
#define IOCTL_WAVE_BASE     0x0040
#define IOCTL_MIDI_BASE     0x0080
#define IOCTL_MIXER_BASE    0x00C0

#define IOCTL_WDMAUD_INIT                      WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0000, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_ADD_DEVNODE               WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0001, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_REMOVE_DEVNODE            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0002, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_GET_CAPABILITIES          WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0003, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_GET_NUM_DEVS              WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0004, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_OPEN_PIN                  WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0005, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_CLOSE_PIN                 WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0006, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_GET_VOLUME                WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0007, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_SET_VOLUME                WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0008, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_EXIT                      WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0009, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_SET_PREFERRED_DEVICE      WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x000a, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_WAVE_OUT_PAUSE            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0000, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_PLAY             WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0001, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_RESET            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0002, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_BREAKLOOP        WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0003, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_GET_POS          WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0004, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_SET_VOLUME       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0005, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_GET_VOLUME       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0006, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_WRITE_PIN        WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0007, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_WAVE_IN_STOP              WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0010, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_IN_RECORD            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0011, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_IN_RESET             WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0012, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_IN_GET_POS           WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0013, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_IN_READ_PIN          WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0014, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_MIDI_OUT_RESET            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0000, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_OUT_SET_VOLUME       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0001, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_OUT_GET_VOLUME       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0002, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_OUT_WRITE_DATA       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0003, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_OUT_WRITE_LONGDATA   WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0004, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_MIDI_IN_STOP              WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0010, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_IN_RECORD            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0011, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_IN_RESET             WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0012, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_IN_READ_PIN          WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0013, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_MIXER_OPEN                WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0000, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_CLOSE               WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0001, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_GETLINEINFO         WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0002, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_GETLINECONTROLS     WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0003, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_GETCONTROLDETAILS   WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0004, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_SETCONTROLDETAILS   WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0005, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_GETHARDWAREEVENTDATA   WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0006, METHOD_BUFFERED, FILE_WRITE_ACCESS)

/////////////////////////////////////////////////////////////////////
// end of nt\private\ntos\dd\wdm\audio\inc\wdmaud.h
/////////////////////////////////////////////////////////////////////



void CIoctlSysAudio::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    ;
}

void CIoctlSysAudio::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
    CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
}


BOOL CIoctlSysAudio::FindValidIOCTLs(CDevice *pDevice)
{
    BOOL bRet = TRUE;
    DPF((TEXT("CIoctlSysAudio::FindValidIOCTLs() %s is known, will use known IOCTLs\n"), pDevice->GetDeviceName()));

    AddIOCTL(pDevice, IOCTL_WDMAUD_INIT);
    AddIOCTL(pDevice, IOCTL_WDMAUD_ADD_DEVNODE);
    AddIOCTL(pDevice, IOCTL_WDMAUD_REMOVE_DEVNODE);
    AddIOCTL(pDevice, IOCTL_WDMAUD_SET_PREFERRED_DEVICE);
    AddIOCTL(pDevice, IOCTL_WDMAUD_GET_CAPABILITIES);
    AddIOCTL(pDevice, IOCTL_WDMAUD_GET_NUM_DEVS);
    AddIOCTL(pDevice, IOCTL_WDMAUD_OPEN_PIN);
    AddIOCTL(pDevice, IOCTL_WDMAUD_CLOSE_PIN);
    AddIOCTL(pDevice, IOCTL_WDMAUD_GET_VOLUME);
    AddIOCTL(pDevice, IOCTL_WDMAUD_SET_VOLUME);
    AddIOCTL(pDevice, IOCTL_WDMAUD_EXIT);
    AddIOCTL(pDevice, IOCTL_WDMAUD_WAVE_OUT_PAUSE);
    AddIOCTL(pDevice, IOCTL_WDMAUD_WAVE_OUT_PLAY);
    AddIOCTL(pDevice, IOCTL_WDMAUD_WAVE_OUT_RESET);
    AddIOCTL(pDevice, IOCTL_WDMAUD_WAVE_OUT_BREAKLOOP);
    AddIOCTL(pDevice, IOCTL_WDMAUD_WAVE_OUT_GET_POS);
    AddIOCTL(pDevice, IOCTL_WDMAUD_WAVE_OUT_SET_VOLUME);
    AddIOCTL(pDevice, IOCTL_WDMAUD_WAVE_OUT_GET_VOLUME);
    AddIOCTL(pDevice, IOCTL_WDMAUD_WAVE_OUT_WRITE_PIN);
    AddIOCTL(pDevice, IOCTL_WDMAUD_WAVE_IN_STOP);
    AddIOCTL(pDevice, IOCTL_WDMAUD_WAVE_IN_RECORD);
    AddIOCTL(pDevice, IOCTL_WDMAUD_WAVE_IN_RESET);
    AddIOCTL(pDevice, IOCTL_WDMAUD_WAVE_IN_GET_POS);
    AddIOCTL(pDevice, IOCTL_WDMAUD_WAVE_IN_READ_PIN);
    AddIOCTL(pDevice, IOCTL_WDMAUD_MIDI_OUT_RESET);
    AddIOCTL(pDevice, IOCTL_WDMAUD_MIDI_OUT_SET_VOLUME);
    AddIOCTL(pDevice, IOCTL_WDMAUD_MIDI_OUT_GET_VOLUME);
    AddIOCTL(pDevice, IOCTL_WDMAUD_MIDI_OUT_WRITE_DATA);
    AddIOCTL(pDevice, IOCTL_WDMAUD_MIDI_OUT_WRITE_LONGDATA);
    AddIOCTL(pDevice, IOCTL_WDMAUD_MIDI_IN_STOP);
    AddIOCTL(pDevice, IOCTL_WDMAUD_MIDI_IN_RECORD);
    AddIOCTL(pDevice, IOCTL_WDMAUD_MIDI_IN_RESET);
    AddIOCTL(pDevice, IOCTL_WDMAUD_MIDI_IN_READ_PIN);
    AddIOCTL(pDevice, IOCTL_WDMAUD_MIXER_OPEN);
    AddIOCTL(pDevice, IOCTL_WDMAUD_MIXER_CLOSE);
    AddIOCTL(pDevice, IOCTL_WDMAUD_MIXER_GETLINEINFO);
    AddIOCTL(pDevice, IOCTL_WDMAUD_MIXER_GETLINECONTROLS);
    AddIOCTL(pDevice, IOCTL_WDMAUD_MIXER_GETCONTROLDETAILS);
    AddIOCTL(pDevice, IOCTL_WDMAUD_MIXER_SETCONTROLDETAILS);
    AddIOCTL(pDevice, IOCTL_WDMAUD_MIXER_GETHARDWAREEVENTDATA);


    return TRUE;
}




void CIoctlSysAudio::CallRandomWin32API(LPOVERLAPPED pOL)
{
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\tcpclientioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>


#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <winsock2.h>
#include <windows.h>
  */
#include "tdi.h"


#include "afd.h"

#include "TCPClientIOCTL.h"

static bool s_fVerbose = true;

static AFD_HANDLE_INFO s_ahi;

void CIoctlTCPClient::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    ;
}

HANDLE CIoctlTCPClient::CreateDevice(CDevice *pDevice)
{
	if (INVALID_SOCKET == m_sListeningSocket)
	{
		HANDLE h = CIoctlSocketClient::CreateDevice(pDevice);
		if (INVALID_HANDLE_VALUE == h)
		{
			_ASSERT(INVALID_SOCKET == m_sListeningSocket);
			return INVALID_HANDLE_VALUE;
		}
		_ASSERT(INVALID_SOCKET != m_sListeningSocket);
	}

    DWORD dwFlags = AFD_QUERY_ADDRESS_HANDLE|AFD_QUERY_CONNECTION_HANDLE;
	DWORD dwBytesReturned;
	OVERLAPPED Overlapped;
	if (!PrepareOverlappedStructure(&Overlapped))
	{
		return INVALID_HANDLE_VALUE;
	}


	if (! ::DeviceIoControl(
		(HANDLE)m_sListeningSocket,              // handle to a device, file, or directory 
		IOCTL_AFD_QUERY_HANDLES,       // control code of operation to perform
		&dwFlags,           // pointer to buffer to supply input data
		sizeof(dwFlags),         // size, in bytes, of input buffer
		&s_ahi,          // pointer to buffer to receive output data
		sizeof(s_ahi),        // size, in bytes, of output buffer
		&dwBytesReturned,     // pointer to variable to receive byte count
		&Overlapped    // pointer to structure for asynchronous operation
		))
	{
		DWORD dwLastError = ::GetLastError();
		if (ERROR_IO_PENDING == dwLastError)
		{
			if (!::GetOverlappedResult((HANDLE)m_sListeningSocket, &Overlapped, &dwBytesReturned, TRUE))
			{
				DPF((TEXT("CIoctlTCPClient::CreateDevice() GetOverlappedResult(IOCTL_AFD_QUERY_HANDLES) failed with %d\n"), ::GetLastError()));
				return INVALID_HANDLE_VALUE;
			}
		}
		else
		{
			DPF((TEXT("CIoctlTCPClient::CreateDevice() DeviceIoControl(IOCTL_AFD_QUERY_HANDLES) failed with %d\n"), ::GetLastError()));
			return INVALID_HANDLE_VALUE;
		}
	}

	//
	// either the call succeeded, or the OL operation succeeded
	//

	return s_ahi.TdiAddressHandle;
}

BOOL CIoctlTCPClient::CloseDevice(CDevice *pDevice)
{
	_ASSERTE(pDevice->m_hDevice == s_ahi.TdiAddressHandle);
    return ::CloseHandle(pDevice->m_hDevice);;
}

BOOL CIoctlTCPClient::DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		)
{
	return TRUE;
}

BOOL CIoctlTCPClient::DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		)
{
	return TRUE;
}

void CIoctlTCPClient::CallRandomWin32API(LPOVERLAPPED pOL)
{
    return;
}

BOOL CIoctlTCPClient::DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		)
{
	lpOverlapped->Internal = (DWORD)STATUS_PENDING;
	NTSTATUS Status = NtDeviceIoControlFile (
		hDevice, 
		lpOverlapped->hEvent, 
		NULL, 
		NULL,
		(PIO_STATUS_BLOCK)&lpOverlapped->Internal,
		dwIoControlCode,
		lpInBuffer,
		nInBufferSize,
		lpOutBuffer,
		nOutBufferSize
		);
	if (!NT_SUCCESS(Status))
	{
		::SetLastError(Status);
	}
	if (STATUS_PENDING == Status)
	{
		::SetLastError(ERROR_IO_PENDING);
	}
	_tprintf(TEXT("CIoctlTCPSrv::DeviceInputOutputControl() NtDeviceIoControlFile() return 0x%08X\n"), Status);

	return (STATUS_SUCCESS == Status);
}

void CIoctlTCPClient::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
	switch(dwIOCTL)
	{
    case IOCTL_TDI_ACCEPT:
		break;

    case IOCTL_TDI_CONNECT:
		break;

    case IOCTL_TDI_DISCONNECT:
		break;

    case IOCTL_TDI_LISTEN:
		break;

    case IOCTL_TDI_QUERY_INFORMATION:
/*
typedef struct _TDI_REQUEST_QUERY_INFORMATION {
    TDI_REQUEST Request;
    ULONG QueryType;                          // class of information to be queried.
    PTDI_CONNECTION_INFORMATION RequestConnectionInformation;
} TDI_REQUEST_QUERY_INFORMATION, *PTDI_REQUEST_QUERY_INFORMATION;
typedef struct _TDI_REQUEST {
    union {
        HANDLE AddressHandle;
        CONNECTION_CONTEXT ConnectionContext;
        HANDLE ControlChannel;
    } Handle;

    PVOID RequestNotifyObject;
    PVOID RequestContext;
    TDI_STATUS TdiStatus;
} TDI_REQUEST, *PTDI_REQUEST;
*/
        //((PTDI_REQUEST_QUERY_INFORMATION)abInBuffer)->Request = xxx;
        ((PTDI_REQUEST_QUERY_INFORMATION)abInBuffer)->QueryType = GetRandomQueryType();
        //((PTDI_REQUEST_QUERY_INFORMATION)abInBuffer)->RequestConnectionInformation = xxx;

        SetInParam(dwInBuff, 2*sizeof(TDI_REQUEST_QUERY_INFORMATION));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(TDI_PROVIDER_INFO));

        break;

    case IOCTL_TDI_RECEIVE:
		break;

    case IOCTL_TDI_RECEIVE_DATAGRAM:
		break;

    case IOCTL_TDI_SEND:
		break;

    case IOCTL_TDI_SEND_DATAGRAM:
		break;

    case IOCTL_TDI_SET_EVENT_HANDLER:
		break;

    case IOCTL_TDI_SET_INFORMATION:
		break;

    case IOCTL_TDI_ASSOCIATE_ADDRESS:
		break;

    case IOCTL_TDI_DISASSOCIATE_ADDRESS:
		break;

    case IOCTL_TDI_ACTION:
		break;

	default: 
		_tprintf(TEXT("CIoctlTCPClient::PrepareIOCTLParams() 0x%08X is an unexpected IOCTL\n"), dwIOCTL);
		_ASSERTE(FALSE);
		CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
	}
}


BOOL CIoctlTCPClient::FindValidIOCTLs(CDevice *pDevice)
{
	AddIOCTL(pDevice, IOCTL_TDI_ACCEPT          );
	AddIOCTL(pDevice, IOCTL_TDI_CONNECT          );
	AddIOCTL(pDevice, IOCTL_TDI_DISCONNECT          );
	AddIOCTL(pDevice, IOCTL_TDI_LISTEN          );
	AddIOCTL(pDevice, IOCTL_TDI_QUERY_INFORMATION          );
	AddIOCTL(pDevice, IOCTL_TDI_RECEIVE          );
	AddIOCTL(pDevice, IOCTL_TDI_RECEIVE_DATAGRAM          );
	AddIOCTL(pDevice, IOCTL_TDI_SEND          );
	AddIOCTL(pDevice, IOCTL_TDI_SEND_DATAGRAM          );
	AddIOCTL(pDevice, IOCTL_TDI_SET_EVENT_HANDLER          );
	AddIOCTL(pDevice, IOCTL_TDI_SET_INFORMATION          );
	AddIOCTL(pDevice, IOCTL_TDI_ASSOCIATE_ADDRESS          );
	AddIOCTL(pDevice, IOCTL_TDI_DISASSOCIATE_ADDRESS          );
	AddIOCTL(pDevice, IOCTL_TDI_ACTION          );

	return TRUE;
}


//
// server's port is appended to the real "device" name
// example:
// ---UseSymbolicName-TCP-client-1025 = 157.58.196.134
// 1025 is the server's port
// 157.58.196.134 is the server's IP
//
u_short CIoctlTCPClient::GetServerPort(CDevice *pDevice)
{
	u_short retval = 0;
	TCHAR *szServerPort = _tcsstr(_tcsupr(pDevice->GetSymbolicDeviceName()), _tcsupr(TEXT(szANSI_TCP_CLIENT)));
	if (NULL == szServerPort)
	{
		DPF((TEXT("GetServerPort(%s): could not find \"%s\".\n"), pDevice->GetSymbolicDeviceName(), TEXT(szANSI_SOCKET_CLIENT)));
		_ASSERT(FALSE);
		return 0;
	}

	szServerPort += lstrlen(TEXT(szANSI_SOCKET_CLIENT));
	retval = htons(_ttoi(szServerPort));
//	DPF((TEXT("GetServerPort(%s, %s): returning %d=0x%08X.\n"), pDevice->GetSymbolicDeviceName(), szServerPort, retval, retval));
	return retval;
}


ULONG CIoctlTCPClient::GetRandomQueryType()
{
	switch(rand()%14)
	{
	case 0:
		return TDI_QUERY_BROADCAST_ADDRESS;
	case 1:
		return TDI_QUERY_PROVIDER_INFORMATION;
	case 2:
		return TDI_QUERY_PROVIDER_INFO;
	case 3:
		return TDI_QUERY_ADDRESS_INFO;
	case 4:
		return TDI_QUERY_CONNECTION_INFO;
	case 5:
		return TDI_QUERY_PROVIDER_STATISTICS;
	case 6:
		return TDI_QUERY_DATAGRAM_INFO;
	case 7:
		return TDI_QUERY_DATA_LINK_ADDRESS;
	case 8:
		return TDI_QUERY_NETWORK_ADDRESS;
	case 9:
		return TDI_QUERY_MAX_DATAGRAM_INFO;
	case 10:
		return TDI_QUERY_ADAPTER_STATUS;
	case 11:
		return TDI_QUERY_SESSION_STATUS;
	case 12:
		return TDI_QUERY_FIND_NAME;
	case 13:
		return rand();
	}
	_ASSERTE(FALSE);
	return rand();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\tcpioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
*/
#include "ntddtdi.h"
#include "tdi.h"
#include "tdiinfo.h"

//
// Internal TDI IOCTLS
//

#define IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER     _TDI_CONTROL_CODE( 0x80, METHOD_NEITHER )
#define IOCTL_TDI_QUERY_DIRECT_SENDDG_HANDLER   _TDI_CONTROL_CODE( 0x81, METHOD_NEITHER )
#define MIN_USER_PORT   1025        // Minimum value for a wildcard port
#define MAX_USER_PORT   5000        // Maximim value for a user port.

#include "ntddip.h"
#include "ntddtcp.h"
#include "tcpinfo.h"


//#include <windows.h>

#include "TcpIOCTL.h"

#include "TcpIpCommon.h"

static bool s_fVerbose = false;


void CIoctlTcp::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    ;
}

void CIoctlTcp::CallRandomWin32API(LPOVERLAPPED pOL)
{
	//_ASSERTE(FALSE);
    ;
}

void CIoctlTcp::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
	TcpIpCommon_PrepareIOCTLParams(
		dwIOCTL,
		abInBuffer,
		dwInBuff,
		abOutBuffer,
		dwOutBuff
		);
	return;

	switch(dwIOCTL)
	{
	case IOCTL_TCP_QUERY_INFORMATION_EX          :
        GetRandomTDIObjectID(&((PTCP_REQUEST_QUERY_INFORMATION_EX)abInBuffer)->ID);
        GetRandomContext(((PTCP_REQUEST_QUERY_INFORMATION_EX)abInBuffer)->Context);

        SetInParam(dwInBuff, (1+rand()%2)*sizeof(TCP_REQUEST_QUERY_INFORMATION_EX));

        SetOutParam(abOutBuffer, dwOutBuff, rand()%1000);

		break;

	case IOCTL_TCP_SET_INFORMATION_EX          :
	case IOCTL_TCP_WSH_SET_INFORMATION_EX          :
        GetRandomTDIObjectID(&((PTCP_REQUEST_SET_INFORMATION_EX)abInBuffer)->ID);
        ((PTCP_REQUEST_SET_INFORMATION_EX)abInBuffer)->BufferSize = rand()%10 ? rand() : DWORD_RAND;

        SetInParam(dwInBuff, rand());

        SetOutParam(abOutBuffer, dwOutBuff, rand());

		break;

	case IOCTL_TCP_QUERY_SECURITY_FILTER_STATUS          :
        SetInParam(dwInBuff, sizeof(TCP_SECURITY_FILTER_STATUS));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(TCP_SECURITY_FILTER_STATUS));

		break;

	case IOCTL_TCP_SET_SECURITY_FILTER_STATUS          :
        ((PTCP_SECURITY_FILTER_STATUS)abInBuffer)->FilteringEnabled = rand()%2;

        SetInParam(dwInBuff, sizeof(TCP_SECURITY_FILTER_STATUS));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(TCP_SECURITY_FILTER_STATUS));

		break;


	case IOCTL_TCP_ADD_SECURITY_FILTER          :
	case IOCTL_TCP_DELETE_SECURITY_FILTER          :
/*
typedef struct TCPSecurityFilterEntry {
    ulong   tsf_address;        // IP interface address
    ulong   tsf_protocol;       // Transport protocol number
    ulong   tsf_value;          // Transport filter value (e.g. TCP port)
} TCPSecurityFilterEntry;
*/
        ((TCPSecurityFilterEntry*)abInBuffer)->tsf_address = rand()%10 ? 0 : rand();
        ((TCPSecurityFilterEntry*)abInBuffer)->tsf_protocol = rand()%10 ? 0 : rand();
        ((TCPSecurityFilterEntry*)abInBuffer)->tsf_value = rand()%10 ? 0 : rand();

        SetInParam(dwInBuff, sizeof(TCPSecurityFilterEntry));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

		break;

	case IOCTL_TCP_ENUMERATE_SECURITY_FILTER          :
        ((TCPSecurityFilterEntry*)abInBuffer)->tsf_address = rand()%10 ? 0 : rand();
        ((TCPSecurityFilterEntry*)abInBuffer)->tsf_protocol = rand()%10 ? 0 : rand();
        ((TCPSecurityFilterEntry*)abInBuffer)->tsf_value = rand()%10 ? 0 : rand();

        SetInParam(dwInBuff, sizeof(TCPSecurityFilterEntry));

        SetOutParam(abOutBuffer, dwOutBuff, rand()%1000 + sizeof(TCPSecurityFilterEnum));

		break;

	case IOCTL_TCP_RESERVE_PORT_RANGE          :
	case IOCTL_TCP_UNRESERVE_PORT_RANGE          :
        ((PTCP_RESERVE_PORT_RANGE)abInBuffer)->UpperRange = 
			rand()%10 ? MIN_USER_PORT+rand()%(MAX_USER_PORT-MIN_USER_PORT+1) : rand();
        ((PTCP_RESERVE_PORT_RANGE)abInBuffer)->LowerRange = 
			rand()%10 ? MIN_USER_PORT+rand()%(abs(((PTCP_RESERVE_PORT_RANGE)abInBuffer)->UpperRange-MIN_USER_PORT)+1) : rand();

        SetInParam(dwInBuff, sizeof(TCP_RESERVE_PORT_RANGE));

        SetOutParam(abOutBuffer, dwOutBuff, 0);

		break;

	case IOCTL_TCP_BLOCK_PORTS          :
        ((PTCP_BLOCKPORTS_REQUEST)abInBuffer)->ReservePorts = rand()%2;
        ((PTCP_BLOCKPORTS_REQUEST)abInBuffer)->NumberofPorts = rand()%10 ? rand() : DWORD_RAND;

        SetInParam(dwInBuff, sizeof(TCP_BLOCKPORTS_REQUEST));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG));

		break;

	case IOCTL_TCP_FINDTCB          :
        ((PTCP_FINDTCB_REQUEST)abInBuffer)->Src = rand()%10 ? rand() : DWORD_RAND;
        ((PTCP_FINDTCB_REQUEST)abInBuffer)->Dest = rand()%10 ? rand() : DWORD_RAND;
        ((PTCP_FINDTCB_REQUEST)abInBuffer)->DestPort = rand();
        ((PTCP_FINDTCB_REQUEST)abInBuffer)->SrcPort = rand();

        SetInParam(dwInBuff, sizeof(TCP_FINDTCB_REQUEST));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(TCP_FINDTCB_RESPONSE));

		break;

	case IOCTL_TCP_RCVWND          :
        SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG));
		break;
/*
	case IOCTL_TDI_ACCEPT          :
		break;

	case IOCTL_TDI_ACTION          :
		break;

	case IOCTL_TDI_CONNECT          :
		break;

	case IOCTL_TDI_DISCONNECT          :
		break;

	case IOCTL_TDI_LISTEN          :
		break;

	case IOCTL_TDI_QUERY_INFORMATION          :
		break;

	case IOCTL_TDI_RECEIVE          :
		break;

	case IOCTL_TDI_RECEIVE_DATAGRAM          :
		break;

	case IOCTL_TDI_SEND          :
		break;

	case IOCTL_TDI_SEND_DATAGRAM          :
		break;

	case IOCTL_TDI_SET_EVENT_HANDLER          :
		break;

	case IOCTL_TDI_SET_INFORMATION          :
		break;

	case IOCTL_TDI_ASSOCIATE_ADDRESS          :
		break;

	case IOCTL_TDI_DISASSOCIATE_ADDRESS          :
		break;
*/
	case IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER:
        SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG_PTR));
		break;
/*
	case IOCTL_TDI_QUERY_DIRECT_SENDDG_HANDLER:
		break;
*/
	default:
		_tprintf(TEXT("CIoctlTcp::PrepareIOCTLParams() 0x%08X is an unexpected IOCTL\n"), dwIOCTL);
		_ASSERTE(FALSE);
		CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
	}
}


BOOL CIoctlTcp::FindValidIOCTLs(CDevice *pDevice)
{
	AddIOCTL(pDevice, IOCTL_TCP_QUERY_INFORMATION_EX          );
	AddIOCTL(pDevice, IOCTL_TCP_SET_INFORMATION_EX          );
	AddIOCTL(pDevice, IOCTL_TCP_QUERY_SECURITY_FILTER_STATUS          );
	AddIOCTL(pDevice, IOCTL_TCP_SET_SECURITY_FILTER_STATUS          );
	AddIOCTL(pDevice, IOCTL_TCP_ADD_SECURITY_FILTER          );
	AddIOCTL(pDevice, IOCTL_TCP_DELETE_SECURITY_FILTER          );
	AddIOCTL(pDevice, IOCTL_TCP_ENUMERATE_SECURITY_FILTER          );
	AddIOCTL(pDevice, IOCTL_TCP_RESERVE_PORT_RANGE          );
	AddIOCTL(pDevice, IOCTL_TCP_UNRESERVE_PORT_RANGE          );
	AddIOCTL(pDevice, IOCTL_TCP_BLOCK_PORTS          );
	AddIOCTL(pDevice, IOCTL_TCP_WSH_SET_INFORMATION_EX          );
	AddIOCTL(pDevice, IOCTL_TCP_FINDTCB          );
	AddIOCTL(pDevice, IOCTL_TCP_RCVWND          );
/*
	AddIOCTL(pDevice, IOCTL_TDI_ACCEPT          );
	AddIOCTL(pDevice, IOCTL_TDI_ACTION          );
	AddIOCTL(pDevice, IOCTL_TDI_CONNECT          );
	AddIOCTL(pDevice, IOCTL_TDI_DISCONNECT          );
	AddIOCTL(pDevice, IOCTL_TDI_LISTEN          );
	AddIOCTL(pDevice, IOCTL_TDI_QUERY_INFORMATION          );
	AddIOCTL(pDevice, IOCTL_TDI_RECEIVE          );
	AddIOCTL(pDevice, IOCTL_TDI_RECEIVE_DATAGRAM          );
	AddIOCTL(pDevice, IOCTL_TDI_SEND          );
	AddIOCTL(pDevice, IOCTL_TDI_SEND_DATAGRAM          );
	AddIOCTL(pDevice, IOCTL_TDI_SET_EVENT_HANDLER          );
	AddIOCTL(pDevice, IOCTL_TDI_SET_INFORMATION          );
	AddIOCTL(pDevice, IOCTL_TDI_ASSOCIATE_ADDRESS          );
	AddIOCTL(pDevice, IOCTL_TDI_DISASSOCIATE_ADDRESS          );
*/
	AddIOCTL(pDevice, IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER          );
//	AddIOCTL(pDevice, IOCTL_TDI_QUERY_DIRECT_SENDDG_HANDLER          );

    return TRUE;
}

#if 0
HANDLE CIoctlTcp::CreateDevice(CDevice *pDevice)
{
	OBJECT_ATTRIBUTES objectAttributes;
	IO_STATUS_BLOCK iosb;
	UNICODE_STRING string;
	NTSTATUS status;
	HANDLE hDevice;

	RtlInitUnicodeString(&string, L"\\Device\\Tcp");

	InitializeObjectAttributes(
		&objectAttributes,
		&string,
		OBJ_CASE_INSENSITIVE,
		NULL,
		NULL
		);
	status = NtCreateFile(
		&hDevice,
		/*SYNCHRONIZE |*/ GENERIC_EXECUTE,
		&objectAttributes,		
		&iosb,
		NULL,
		FILE_ATTRIBUTE_NORMAL,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		FILE_OPEN_IF,
		0,//FILE_SYNCHRONOUS_IO_NONALERT,
		NULL,
		0
		);
	if (!NT_SUCCESS(status)) {
		::SetLastError(RtlNtStatusToDosError(status));
		DPF((TEXT("CIoctlTcp::CreateDevice() NtCreateFile(\\Device\\Tcp) returned 0x%08X=%d\n"), status, ::GetLastError()));
		return INVALID_HANDLE_VALUE;
	}    

	//_tprintf(TEXT("CIoctlTcp::CreateDevice() NtCreateFile(\\Device\\Tcp) succeeded\n"));
	
	return hDevice;
}

BOOL CIoctlTcp::CloseDevice(CDevice *pDevice)
{
	NTSTATUS status = NtClose(pDevice->m_hDevice);
	if (!NT_SUCCESS(status))
	{
		::SetLastError(RtlNtStatusToDosError(status));
	}
	else
	{
		_ASSERTE(STATUS_SUCCESS == status);
	}
	return (STATUS_SUCCESS == status);
}
/*
BOOL CIoctlTcp::DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		)
{
	_ASSERTE(FALSE);
	return FALSE;
}

BOOL CIoctlTcp::DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		)
{
	_ASSERTE(FALSE);
	return FALSE;
}
*/

BOOL CIoctlTcp::DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		)
{
	lpOverlapped->Internal = (DWORD)STATUS_PENDING;
	NTSTATUS Status = NtDeviceIoControlFile (
		hDevice, 
		lpOverlapped->hEvent, 
		NULL, 
		NULL,
		(PIO_STATUS_BLOCK)&lpOverlapped->Internal,
		dwIoControlCode,
		lpInBuffer,
		nInBufferSize,
		lpOutBuffer,
		nOutBufferSize
		);
	if (!NT_SUCCESS(Status))
	{
		::SetLastError(RtlNtStatusToDosError(Status));
	}
	if (STATUS_PENDING == Status)
	{
		::SetLastError(ERROR_IO_PENDING);
	}
	DPF((TEXT("CIoctlTcp::DeviceInputOutputControl() NtDeviceIoControlFile() returned 0x%08X=%d\n"), Status, ::GetLastError()));

	return (STATUS_SUCCESS == Status);
}


#endif //0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\tcpipcommon.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
*/
#include "ntddtdi.h"
#include "tdi.h"
#include "tdiinfo.h"

//
// Internal TDI IOCTLS
//

#define IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER     _TDI_CONTROL_CODE( 0x80, METHOD_NEITHER )
#define IOCTL_TDI_QUERY_DIRECT_SENDDG_HANDLER   _TDI_CONTROL_CODE( 0x81, METHOD_NEITHER )
#define MIN_USER_PORT   1025        // Minimum value for a wildcard port
#define MAX_USER_PORT   5000        // Maximim value for a user port.

#include "ntddip.h"
#include "ntddtcp.h"
#include "tcpinfo.h"


//#include <windows.h>

//#include "IOCTL.h"

#include "TcpIpCommon.h"


void TcpIpCommon_PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
	switch(dwIOCTL)
	{
	case IOCTL_TCP_QUERY_INFORMATION_EX          :
        GetRandomTDIObjectID(&((PTCP_REQUEST_QUERY_INFORMATION_EX)abInBuffer)->ID);
        GetRandomContext(((PTCP_REQUEST_QUERY_INFORMATION_EX)abInBuffer)->Context);

        CIoctl::SetInParam(dwInBuff, (1+rand()%2)*sizeof(TCP_REQUEST_QUERY_INFORMATION_EX));

        CIoctl::SetOutParam(abOutBuffer, dwOutBuff, rand()%1000);

		break;

	case IOCTL_TCP_SET_INFORMATION_EX          :
	case IOCTL_TCP_WSH_SET_INFORMATION_EX          :
        GetRandomTDIObjectID(&((PTCP_REQUEST_SET_INFORMATION_EX)abInBuffer)->ID);
        ((PTCP_REQUEST_SET_INFORMATION_EX)abInBuffer)->BufferSize = rand()%10 ? rand() : DWORD_RAND;

        CIoctl::SetInParam(dwInBuff, rand());

        CIoctl::SetOutParam(abOutBuffer, dwOutBuff, rand());

		break;

	case IOCTL_TCP_QUERY_SECURITY_FILTER_STATUS          :
        CIoctl::SetInParam(dwInBuff, sizeof(TCP_SECURITY_FILTER_STATUS));

        CIoctl::SetOutParam(abOutBuffer, dwOutBuff, sizeof(TCP_SECURITY_FILTER_STATUS));

		break;

	case IOCTL_TCP_SET_SECURITY_FILTER_STATUS          :
        ((PTCP_SECURITY_FILTER_STATUS)abInBuffer)->FilteringEnabled = rand()%2;

        CIoctl::SetInParam(dwInBuff, sizeof(TCP_SECURITY_FILTER_STATUS));

        CIoctl::SetOutParam(abOutBuffer, dwOutBuff, sizeof(TCP_SECURITY_FILTER_STATUS));

		break;


	case IOCTL_TCP_ADD_SECURITY_FILTER          :
	case IOCTL_TCP_DELETE_SECURITY_FILTER          :
/*
typedef struct TCPSecurityFilterEntry {
    ulong   tsf_address;        // IP interface address
    ulong   tsf_protocol;       // Transport protocol number
    ulong   tsf_value;          // Transport filter value (e.g. TCP port)
} TCPSecurityFilterEntry;
*/
        ((TCPSecurityFilterEntry*)abInBuffer)->tsf_address = rand()%10 ? 0 : rand();
        ((TCPSecurityFilterEntry*)abInBuffer)->tsf_protocol = rand()%10 ? 0 : rand();
        ((TCPSecurityFilterEntry*)abInBuffer)->tsf_value = rand()%10 ? 0 : rand();

        CIoctl::SetInParam(dwInBuff, sizeof(TCPSecurityFilterEntry));

        CIoctl::SetOutParam(abOutBuffer, dwOutBuff, 0);

		break;

	case IOCTL_TCP_ENUMERATE_SECURITY_FILTER          :
        ((TCPSecurityFilterEntry*)abInBuffer)->tsf_address = rand()%10 ? 0 : rand();
        ((TCPSecurityFilterEntry*)abInBuffer)->tsf_protocol = rand()%10 ? 0 : rand();
        ((TCPSecurityFilterEntry*)abInBuffer)->tsf_value = rand()%10 ? 0 : rand();

        CIoctl::SetInParam(dwInBuff, sizeof(TCPSecurityFilterEntry));

        CIoctl::SetOutParam(abOutBuffer, dwOutBuff, rand()%1000 + sizeof(TCPSecurityFilterEnum));

		break;

	case IOCTL_TCP_RESERVE_PORT_RANGE          :
	case IOCTL_TCP_UNRESERVE_PORT_RANGE          :
        ((PTCP_RESERVE_PORT_RANGE)abInBuffer)->UpperRange = 
			rand()%10 ? MIN_USER_PORT+rand()%(MAX_USER_PORT-MIN_USER_PORT+1) : rand();
        ((PTCP_RESERVE_PORT_RANGE)abInBuffer)->LowerRange = 
			rand()%10 ? MIN_USER_PORT+rand()%(abs(((PTCP_RESERVE_PORT_RANGE)abInBuffer)->UpperRange-MIN_USER_PORT)+1) : rand();

        CIoctl::SetInParam(dwInBuff, sizeof(TCP_RESERVE_PORT_RANGE));

        CIoctl::SetOutParam(abOutBuffer, dwOutBuff, 0);

		break;

	case IOCTL_TCP_BLOCK_PORTS          :
        ((PTCP_BLOCKPORTS_REQUEST)abInBuffer)->ReservePorts = rand()%2;
        ((PTCP_BLOCKPORTS_REQUEST)abInBuffer)->NumberofPorts = rand()%10 ? rand() : DWORD_RAND;

        CIoctl::SetInParam(dwInBuff, sizeof(TCP_BLOCKPORTS_REQUEST));

        CIoctl::SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG));

		break;

	case IOCTL_TCP_FINDTCB          :
        ((PTCP_FINDTCB_REQUEST)abInBuffer)->Src = rand()%10 ? rand() : DWORD_RAND;
        ((PTCP_FINDTCB_REQUEST)abInBuffer)->Dest = rand()%10 ? rand() : DWORD_RAND;
        ((PTCP_FINDTCB_REQUEST)abInBuffer)->DestPort = rand();
        ((PTCP_FINDTCB_REQUEST)abInBuffer)->SrcPort = rand();

        CIoctl::SetInParam(dwInBuff, sizeof(TCP_FINDTCB_REQUEST));

        CIoctl::SetOutParam(abOutBuffer, dwOutBuff, sizeof(TCP_FINDTCB_RESPONSE));

		break;

	case IOCTL_TCP_RCVWND          :
        CIoctl::SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG));
		break;
/*
	case IOCTL_TDI_ACCEPT          :
		break;

	case IOCTL_TDI_ACTION          :
		break;

	case IOCTL_TDI_CONNECT          :
		break;

	case IOCTL_TDI_DISCONNECT          :
		break;

	case IOCTL_TDI_LISTEN          :
		break;

	case IOCTL_TDI_QUERY_INFORMATION          :
		break;

	case IOCTL_TDI_RECEIVE          :
		break;

	case IOCTL_TDI_RECEIVE_DATAGRAM          :
		break;

	case IOCTL_TDI_SEND          :
		break;

	case IOCTL_TDI_SEND_DATAGRAM          :
		break;

	case IOCTL_TDI_SET_EVENT_HANDLER          :
		break;

	case IOCTL_TDI_SET_INFORMATION          :
		break;

	case IOCTL_TDI_ASSOCIATE_ADDRESS          :
		break;

	case IOCTL_TDI_DISASSOCIATE_ADDRESS          :
		break;
*/
	case IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER:
        CIoctl::SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG_PTR));
		break;
/*
	case IOCTL_TDI_QUERY_DIRECT_SENDDG_HANDLER:
		break;
*/
	default:
		_tprintf(TEXT("CIoctlTcp::PrepareIOCTLParams() 0x%08X is an unexpected IOCTL\n"), dwIOCTL);
		_ASSERTE(FALSE);
		//CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
	}
}


void GetRandomTDIObjectID(TDIObjectID *pID)
{
	GetRandomTDIEntityID(&pID->toi_entity);
	GetRandomtoi_class(pID);
	GetRandomtoi_type(pID);
	GetRandomtoi_id(pID);

}


void GetRandomTDIEntityID(TDIEntityID *pTDIEntityID)
{
	GetRandomtei_entity(pTDIEntityID);
	GetRandomtei_instance(pTDIEntityID);

}


void GetRandomtoi_class(TDIObjectID *pID)
{
	switch(rand()%4)
	{
	case 0:
		pID->toi_class = INFO_CLASS_GENERIC;
		break;
	case 1:
		pID->toi_class = INFO_CLASS_PROTOCOL;
		break;
	case 2:
		pID->toi_class = INFO_CLASS_IMPLEMENTATION;
		break;
	case 3:
		pID->toi_class = rand();
		break;

	default:
		;
		_ASSERTE(FALSE);
	}
}


void GetRandomtoi_type(TDIObjectID *pID)
{
	switch(rand()%4)
	{
	case 0:
		pID->toi_type = INFO_TYPE_PROVIDER;
		break;
	case 1:
		pID->toi_type = INFO_TYPE_ADDRESS_OBJECT;
		break;
	case 2:
		pID->toi_type = INFO_TYPE_CONNECTION;
		break;
	case 3:
		pID->toi_type = rand();
		break;

	default:
		;
		_ASSERTE(FALSE);
	}
}


void GetRandomtoi_id(TDIObjectID *pID)
{
	switch(rand()%14)
	{
	case 0:
		pID->toi_id = ENTITY_TYPE_ID;
		break;
	case 1:
		pID->toi_id = UDP_MIB_STAT_ID;
		break;
	case 2:
		pID->toi_id = TCP_MIB_STAT_ID;
		break;
	case 3:
		pID->toi_id = UDP_MIB_TABLE_ID;
		break;
	case 4:
		pID->toi_id = TCP_MIB_TABLE_ID;
		break;
	case 5:
		pID->toi_id = TCP_SOCKET_ATMARK;
		break;
	case 6:
		pID->toi_id = TCP_SOCKET_WINDOW;
		break;
	case 7:
		pID->toi_id = TCP_SOCKET_TOS;
		break;
	case 8:
		pID->toi_id = TCP_SOCKET_KEEPALIVE_VALS;
		break;
	case 9:
		pID->toi_id = TCP_SOCKET_NODELAY;
		break;
	case 10:
		pID->toi_id = TCP_SOCKET_KEEPALIVE;
		break;
	case 11:
		pID->toi_id = TCP_SOCKET_BSDURGENT;
		break;
	case 12:
		pID->toi_id = TCP_SOCKET_OOBINLINE;
		break;
	case 13:
		pID->toi_id = rand();
		break;

	default:
		;
		_ASSERTE(FALSE);
	}
}


void GetRandomtei_entity(TDIEntityID *pTDIEntityID)
{
	switch(rand()%10)
	{
	case 0:
		pTDIEntityID->tei_instance = GENERIC_ENTITY;
		break;
	case 1:
		pTDIEntityID->tei_instance = CO_TL_ENTITY;
		break;
	case 2:
		pTDIEntityID->tei_instance = CL_TL_ENTITY;
		break;
	case 3:
		pTDIEntityID->tei_instance = ER_ENTITY;
		break;
	case 4:
		pTDIEntityID->tei_instance = CO_NL_ENTITY;
		break;
	case 5:
		pTDIEntityID->tei_instance = CL_NL_ENTITY;
		break;
	case 6:
		pTDIEntityID->tei_instance = AT_ENTITY;
		break;
	case 7:
		pTDIEntityID->tei_instance = IF_ENTITY;
		break;
	case 8:
		pTDIEntityID->tei_instance = INVALID_ENTITY_INSTANCE;
		break;
	case 9:
		pTDIEntityID->tei_instance = rand();
		break;
	}
}

void GetRandomtei_instance(TDIEntityID *pTDIEntityID)
{
	if(rand()%10) pTDIEntityID->tei_entity = 0;//TL_INSTANCE;
	else pTDIEntityID->tei_entity = rand();
}



void GetRandomContext(ULONG_PTR *Context/*[CONTEXT_SIZE/sizeof(ULONG_PTR)]*/)
{
	DWORD dwSize = CONTEXT_SIZE;
	if (rand()%10) ZeroMemory(Context, CONTEXT_SIZE);
	else CIoctl::FillBufferWithRandomData(Context, dwSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\tdiioctl.h ===
#ifndef __TDI_IOCTL_H
#define __TDI_IOCTL_H

//#include "IOCTL.h"


class CIoctlTdi : public CIoctl
{
public:
    CIoctlTdi(CDevice *pDevice): 
	  CIoctl(pDevice),
	  m_ListenningSocket(INVALID_SOCKET),
	  m_ConnectingSocket(INVALID_SOCKET),
	  m_hAcceptingThread(NULL)
	  {;}
    virtual ~CIoctlTdi()
	{
		if (NULL != m_hAcceptingThread)
		{
			::TerminateThread(m_hAcceptingThread, -1);
			m_hAcceptingThread = NULL;
		}
	}

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual HANDLE CreateDevice(CDevice *pDevice);

	virtual BOOL CloseDevice(CDevice *pDevice);
/*
	virtual BOOL DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		);

	virtual BOOL DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		);

	virtual BOOL DeviceCancelIo(
		HANDLE hFile  // file handle for which to cancel I/O
		);

*/
	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

	virtual BOOL DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		);

private:
	SOCKET m_ListenningSocket;
	SOCKET m_ConnectingSocket;
	HANDLE m_hAcceptingThread;
	static DWORD WINAPI AcceptingThread (LPVOID pVoid);
	HANDLE m_hTdiConnectionHandle;
	HANDLE m_hTdiAddressHandle;


};




#endif //__TDI_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\uncioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*



#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
*/
#include "UNCIOCTL.h"

static bool s_fVerbose = false;

void CIoctlUNC::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    ;
}

void CIoctlUNC::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
    CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
}


BOOL CIoctlUNC::FindValidIOCTLs(CDevice *pDevice)
{
    for (DWORD dw = 0x90000; dw < 0xa0000; dw++)
    {
        AddIOCTL(pDevice, dw);
    }

    AddIOCTL(pDevice, 0x001403b4);

    return TRUE;
}



void CIoctlUNC::CallRandomWin32API(LPOVERLAPPED pOL)
{
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\tcpsrvioctl.h ===
#ifndef __TCP_SRV_IOCTL_H
#define __TCP_SRV_IOCTL_H

//#include "IOCTL.h"
#include "SocketServerIOCTL.h"


class CIoctlTCPSrv : public CIoctlSocketServer
{
public:
    CIoctlTCPSrv(CDevice *pDevice): CIoctlSocketServer(pDevice){;};
    virtual ~CIoctlTCPSrv()
	{
		CIoctlSocketServer::CloseDevice(m_pDevice);
	}

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual HANDLE CreateDevice(CDevice *pDevice);

	virtual BOOL CloseDevice(CDevice *pDevice);

	virtual BOOL DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		);

	virtual BOOL DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

	virtual BOOL DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		);
/*
	virtual BOOL DeviceCancelIo(
		HANDLE hFile  // file handle for which to cancel I/O
		);
*/

	static ULONG GetRandomQueryType();

};




#endif //__TCP_SRV_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\tcpsrvioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>


#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <winsock2.h>
#include <windows.h>
*/
#include "ntddtdi.h"
#include "tdi.h"


#include "afd.h"

#include "TCPSRVIOCTL.h"

static bool s_fVerbose = true;

void CIoctlTCPSrv::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    ;
}

HANDLE CIoctlTCPSrv::CreateDevice(CDevice *pDevice)
{
	if (INVALID_SOCKET == m_asAcceptingSocket[0])
	{
		HANDLE h = CIoctlSocketServer::CreateDevice(pDevice);
		if (INVALID_HANDLE_VALUE == h)
		{
			_ASSERT(INVALID_SOCKET == m_asAcceptingSocket[0]);
			return INVALID_HANDLE_VALUE;
		}
		_ASSERT(INVALID_SOCKET != m_asAcceptingSocket[0]);
	}

	AFD_HANDLE_INFO ahi;
    DWORD dwFlags = AFD_QUERY_ADDRESS_HANDLE|AFD_QUERY_CONNECTION_HANDLE;
	DWORD dwBytesReturned;
	OVERLAPPED Overlapped;
	if (!PrepareOverlappedStructure(&Overlapped))
	{
		return INVALID_HANDLE_VALUE;
	}

	if (! ::DeviceIoControl(
		(HANDLE)m_asAcceptingSocket[0],              // handle to a device, file, or directory 
		IOCTL_AFD_QUERY_HANDLES,       // control code of operation to perform
		&dwFlags,           // pointer to buffer to supply input data
		sizeof(dwFlags),         // size, in bytes, of input buffer
		&ahi,          // pointer to buffer to receive output data
		sizeof(ahi),        // size, in bytes, of output buffer
		&dwBytesReturned,     // pointer to variable to receive byte count
		&Overlapped    // pointer to structure for asynchronous operation
		))
	{
		DWORD dwLastError = ::GetLastError();
		if (ERROR_IO_PENDING == dwLastError)
		{
			if (!::GetOverlappedResult((HANDLE)m_asAcceptingSocket[0], &Overlapped, &dwBytesReturned, TRUE))
			{
				DPF((TEXT("CIoctlTCPSrv::CreateDevice() GetOverlappedResult(IOCTL_AFD_QUERY_HANDLES) failed with %d\n"), ::GetLastError()));
				return INVALID_HANDLE_VALUE;
			}
		}
		else
		{
			DPF((TEXT("CIoctlTCPSrv::CreateDevice() DeviceIoControl(IOCTL_AFD_QUERY_HANDLES) failed with %d\n"), ::GetLastError()));
			return INVALID_HANDLE_VALUE;
		}
	}

	//
	// either the call succeeded, or the OL operation succeeded
	//

	return ahi.TdiAddressHandle;
}

BOOL CIoctlTCPSrv::CloseDevice(CDevice *pDevice)
{
    return ::CloseHandle(pDevice->m_hDevice);;
}

BOOL CIoctlTCPSrv::DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		)
{
	return TRUE;
}

BOOL CIoctlTCPSrv::DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		)
{
	return TRUE;
}

void CIoctlTCPSrv::CallRandomWin32API(LPOVERLAPPED pOL)
{
    return;
}

BOOL CIoctlTCPSrv::DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		)
{
	lpOverlapped->Internal = (DWORD)STATUS_PENDING;
	NTSTATUS Status = NtDeviceIoControlFile (
		hDevice, 
		lpOverlapped->hEvent, 
		NULL, 
		NULL,
		(PIO_STATUS_BLOCK)&lpOverlapped->Internal,
		dwIoControlCode,
		lpInBuffer,
		nInBufferSize,
		lpOutBuffer,
		nOutBufferSize
		);
	if (!NT_SUCCESS(Status))
	{
		::SetLastError(Status);
	}
	if (STATUS_PENDING == Status)
	{
		::SetLastError(ERROR_IO_PENDING);
	}
	_tprintf(TEXT("CIoctlTCPSrv::DeviceInputOutputControl() NtDeviceIoControlFile() return 0x%08X\n"), Status);

	return (STATUS_SUCCESS == Status);
}

void CIoctlTCPSrv::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
	switch(dwIOCTL)
	{
    case IOCTL_TDI_ACCEPT:
		break;

    case IOCTL_TDI_CONNECT:
		break;

    case IOCTL_TDI_DISCONNECT:
		break;

    case IOCTL_TDI_LISTEN:
		break;

    case IOCTL_TDI_QUERY_INFORMATION:
/*
typedef struct _TDI_REQUEST_QUERY_INFORMATION {
    TDI_REQUEST Request;
    ULONG QueryType;                          // class of information to be queried.
    PTDI_CONNECTION_INFORMATION RequestConnectionInformation;
} TDI_REQUEST_QUERY_INFORMATION, *PTDI_REQUEST_QUERY_INFORMATION;
typedef struct _TDI_REQUEST {
    union {
        HANDLE AddressHandle;
        CONNECTION_CONTEXT ConnectionContext;
        HANDLE ControlChannel;
    } Handle;

    PVOID RequestNotifyObject;
    PVOID RequestContext;
    TDI_STATUS TdiStatus;
} TDI_REQUEST, *PTDI_REQUEST;
*/
        //((PTDI_REQUEST_QUERY_INFORMATION)abInBuffer)->Request = xxx;
        ((PTDI_REQUEST_QUERY_INFORMATION)abInBuffer)->QueryType = GetRandomQueryType();
        //((PTDI_REQUEST_QUERY_INFORMATION)abInBuffer)->RequestConnectionInformation = xxx;

        SetInParam(dwInBuff, sizeof(TDI_REQUEST_QUERY_INFORMATION));

        SetOutParam(abOutBuffer, dwOutBuff, sizeof(TDI_PROVIDER_INFO));

        break;

    case IOCTL_TDI_RECEIVE:
		break;

    case IOCTL_TDI_RECEIVE_DATAGRAM:
		break;

    case IOCTL_TDI_SEND:
		break;

    case IOCTL_TDI_SEND_DATAGRAM:
		break;

    case IOCTL_TDI_SET_EVENT_HANDLER:
		break;

    case IOCTL_TDI_SET_INFORMATION:
		break;

    case IOCTL_TDI_ASSOCIATE_ADDRESS:
		break;

    case IOCTL_TDI_DISASSOCIATE_ADDRESS:
		break;

    case IOCTL_TDI_ACTION:
		break;

	default: 
		_tprintf(TEXT("CIoctlTCPSrv::PrepareIOCTLParams() 0x%08X is an unexpected IOCTL\n"), dwIOCTL);
		_ASSERTE(FALSE);
		CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
	}
}


BOOL CIoctlTCPSrv::FindValidIOCTLs(CDevice *pDevice)
{
	AddIOCTL(pDevice, IOCTL_TDI_ACCEPT          );
	AddIOCTL(pDevice, IOCTL_TDI_CONNECT          );
	AddIOCTL(pDevice, IOCTL_TDI_DISCONNECT          );
	AddIOCTL(pDevice, IOCTL_TDI_LISTEN          );
	AddIOCTL(pDevice, IOCTL_TDI_QUERY_INFORMATION          );
	AddIOCTL(pDevice, IOCTL_TDI_RECEIVE          );
	AddIOCTL(pDevice, IOCTL_TDI_RECEIVE_DATAGRAM          );
	AddIOCTL(pDevice, IOCTL_TDI_SEND          );
	AddIOCTL(pDevice, IOCTL_TDI_SEND_DATAGRAM          );
	AddIOCTL(pDevice, IOCTL_TDI_SET_EVENT_HANDLER          );
	AddIOCTL(pDevice, IOCTL_TDI_SET_INFORMATION          );
	AddIOCTL(pDevice, IOCTL_TDI_ASSOCIATE_ADDRESS          );
	AddIOCTL(pDevice, IOCTL_TDI_DISASSOCIATE_ADDRESS          );
	AddIOCTL(pDevice, IOCTL_TDI_ACTION          );

	return TRUE;
}

ULONG CIoctlTCPSrv::GetRandomQueryType()
{
	switch(rand()%14)
	{
	case 0:
		return TDI_QUERY_BROADCAST_ADDRESS;
	case 1:
		return TDI_QUERY_PROVIDER_INFORMATION;
	case 2:
		return TDI_QUERY_PROVIDER_INFO;
	case 3:
		return TDI_QUERY_ADDRESS_INFO;
	case 4:
		return TDI_QUERY_CONNECTION_INFO;
	case 5:
		return TDI_QUERY_PROVIDER_STATISTICS;
	case 6:
		return TDI_QUERY_DATAGRAM_INFO;
	case 7:
		return TDI_QUERY_DATA_LINK_ADDRESS;
	case 8:
		return TDI_QUERY_NETWORK_ADDRESS;
	case 9:
		return TDI_QUERY_MAX_DATAGRAM_INFO;
	case 10:
		return TDI_QUERY_ADAPTER_STATUS;
	case 11:
		return TDI_QUERY_SESSION_STATUS;
	case 12:
		return TDI_QUERY_FIND_NAME;
	case 13:
		return rand();
	}
	_ASSERTE(FALSE);
	return rand();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\uncioctl.h ===
#ifndef __UNC_IOCTL_H
#define __UNC_IOCTL_H

//#include "IOCTL.h"


class CIoctlUNC : public CIoctl
{
public:
    CIoctlUNC(CDevice *pDevice): CIoctl(pDevice){;};
    virtual ~CIoctlUNC(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

    virtual void CallRandomWin32API(OVERLAPPED *pOL);
};




#endif //__UNC_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\tdiioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <crtdbg.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
*/
#include "ntddtdi.h"
#include "tdi.h"
#include "tdiinfo.h"

//
// Internal TDI IOCTLS
//

#define IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER     _TDI_CONTROL_CODE( 0x80, METHOD_NEITHER )
#define IOCTL_TDI_QUERY_DIRECT_SENDDG_HANDLER   _TDI_CONTROL_CODE( 0x81, METHOD_NEITHER )
#define MIN_USER_PORT   1025        // Minimum value for a wildcard port
#define MAX_USER_PORT   5000        // Maximim value for a user port.

#include "ntddip.h"
#include "ntddtcp.h"
#include "tcpinfo.h"

//#include <winsock2.h>
#include "afd.h"

//#include <windows.h>

#include "TdiIOCTL.h"
#include "TCPSRVIOCTL.h"

#include "TcpIpCommon.h"

static bool s_fVerbose = false;


void CIoctlTdi::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    ;
}

HANDLE CIoctlTdi::CreateDevice(CDevice *pDevice)
{
	WSADATA wsadata;
	WORD version;
	int istatus;
	struct sockaddr_in sockaddr;
	BOOL opt=TRUE;
	HANDLE Event = NULL;
	NTSTATUS status;
	AFD_HANDLE_INFO ahi;
	ULONG flags;
	char buf[10] = {0};
	DWORD id;
	IO_STATUS_BLOCK iosb;
	ULONG sc=0;
	TDI_REQUEST_RECEIVE trr;
	char name[255];
	HOSTENT *host;
	struct in_addr localaddr;
	int t;
	struct sockaddr_in laddr;

	_ASSERTE(m_ListenningSocket == INVALID_SOCKET);
	_ASSERTE(m_ConnectingSocket == INVALID_SOCKET);

	version = MAKEWORD (2, 0);
	istatus = ::WSAStartup (version, &wsadata);
	if (istatus != 0) 
	{
		DPF((TEXT("CIoctlTdi::CreateDevice() WSAStartup() failed with 0x%08X!\n"), istatus));
		return INVALID_HANDLE_VALUE;
	}

	status = gethostname (name, sizeof (name));
	if (status != 0) 
	{
		DPF((TEXT("CIoctlTdi::CreateDevice() gethostname failed %d\n"), WSAGetLastError ()));
		return INVALID_HANDLE_VALUE;
	}

	host = gethostbyname (name);  
	if (!host) 
	{
		DPF((TEXT("CIoctlTdi::CreateDevice() gethostbyname failed %d\n"), WSAGetLastError ()));
		return INVALID_HANDLE_VALUE;
	}

	localaddr = *(struct in_addr *) host->h_addr_list[0];
	m_ListenningSocket = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (m_ListenningSocket == INVALID_SOCKET) 
	{
		DPF((TEXT("CIoctlTdi::CreateDevice() socket failed %d\n"), WSAGetLastError ()));
		return INVALID_HANDLE_VALUE;
	}

	memset (&sockaddr, 0, sizeof (sockaddr));
	sockaddr.sin_family = AF_INET;
	sockaddr.sin_port = htons (0);
	sockaddr.sin_addr = localaddr;

	status = bind (m_ListenningSocket, (struct sockaddr *) &sockaddr, sizeof (sockaddr));
	if (status != 0) 
	{
		DPF((TEXT("CIoctlTdi::CreateDevice() bind failed %d\n"), WSAGetLastError ()));
		goto ErrorExit;
	}

	status = listen (m_ListenningSocket, 10);
	if (status != 0) 
	{
		DPF((TEXT("CIoctlTdi::CreateDevice() listen failed %d\n"), WSAGetLastError ()));
		goto ErrorExit;
	}

	t = sizeof (laddr);
	status = getsockname (m_ListenningSocket, (struct sockaddr *) &laddr, &t);
	if (status != 0) 
	{
		DPF((TEXT("CIoctlTdi::CreateDevice() getsockname failed %d\n"), WSAGetLastError ()));
		goto ErrorExit;
	}

	printf ("Listen socket on port %d address %s\n",
		   ntohs (laddr.sin_port), inet_ntoa (laddr.sin_addr));

/*
	closethread = CreateThread (NULL, 0, do_close, NULL, 0, &id);
	if (!closethread) {
	  printf ("CreateThread failed %d\n", GetLastError ());
	  exit (EXIT_FAILURE);
	}
*/

	//
	// if thread was created, not need fore another one.
	// i do not terminate the thread if this method fails, because
	// i want better chances for success under low memory
	//
	if (NULL == m_hAcceptingThread)
	{
		m_hAcceptingThread = CreateThread (NULL, 0, AcceptingThread, this, 0, &id);
		if (!m_hAcceptingThread) 
		{
			DPF((TEXT("CIoctlTdi::CreateDevice() CreateThread(m_hAcceptingThread) failed %d\n"), GetLastError ()));
			goto ErrorExit;
		}
	}

	m_ConnectingSocket = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (m_ConnectingSocket == INVALID_SOCKET) 
	{
		DPF((TEXT("CIoctlTdi::CreateDevice() socket failed %d\n"), WSAGetLastError ()));
		goto ErrorExit;
	}
	status = connect (m_ConnectingSocket, (struct sockaddr *) &laddr, sizeof (laddr));
	if (status != 0) 
	{
		DPF((TEXT("CIoctlTdi::CreateDevice() connect failed %d\n"), WSAGetLastError ()));
		goto ErrorExit;
	}

	Event = CreateEvent (NULL, FALSE, FALSE, NULL);
	if (Event == NULL) 
	{
		DPF((TEXT("CIoctlTdi::CreateDevice() CreateEvent failed %d\n"), GetLastError ()));
		goto ErrorExit;
	}

	flags = AFD_QUERY_ADDRESS_HANDLE|AFD_QUERY_CONNECTION_HANDLE;
	status = NtDeviceIoControlFile (
		(HANDLE) m_ConnectingSocket, 
		Event, 
		NULL, 
		NULL,
		&iosb,
		IOCTL_AFD_QUERY_HANDLES,
		&flags,
		sizeof (flags),
		&ahi,
		sizeof (ahi)
		);
	if (status == STATUS_PENDING) 
	{
		DPF((TEXT("CIoctlTdi::CreateDevice() Waiting for event\n")));
		if (WaitForSingleObject (Event, INFINITE) != WAIT_OBJECT_0) 
		{
			DPF((TEXT("CIoctlTdi::CreateDevice() WaitForSingleObject failed %d\n"), GetLastError ()));
			goto ErrorExit;
		}
		status = iosb.Status;
	}
	if (!NT_SUCCESS (status)) 
	{
		DPF((TEXT("CIoctlTdi::CreateDevice() NtDeviceIoControlFile failed %x\n"), status));
		goto ErrorExit;
	}
	_ASSERTE(NULL != Event);
	if (!CloseHandle(Event))
	{
		DPF((TEXT("CIoctlTdi::CreateDevice() CloseHandle(Event) failed %d\n"), GetLastError ()));
	}

	m_hTdiConnectionHandle = ahi.TdiConnectionHandle;
	m_hTdiAddressHandle = ahi.TdiAddressHandle;

	return ahi.TdiConnectionHandle;

ErrorExit:
	if (NULL != Event)
	{
		if (!CloseHandle(Event))
		{
			DPF((TEXT("CIoctlTdi::CreateDevice() CloseHandle(Event) failed %d\n"), GetLastError ()));
		}
	}

	if (INVALID_SOCKET != m_ListenningSocket)
	{
		if (0 != closesocket(m_ListenningSocket))
		{
			DPF((TEXT("CIoctlTdi::CreateDevice() closesocket(m_ListenningSocket) failed %d\n"), WSAGetLastError ()));
		}
		m_ListenningSocket = INVALID_SOCKET;
	}
	if (INVALID_SOCKET != m_ConnectingSocket)
	{
		if (0 != closesocket(m_ConnectingSocket))
		{
			DPF((TEXT("CIoctlTdi::CreateDevice() closesocket(m_ConnectingSocket) failed %d\n"), WSAGetLastError ()));
		}
		m_ConnectingSocket = INVALID_SOCKET;
	}

	return INVALID_HANDLE_VALUE;
}

BOOL CIoctlTdi::CloseDevice(CDevice *pDevice)
{
	if (INVALID_SOCKET != m_ListenningSocket)
	{
		if (0 != closesocket(m_ListenningSocket))
		{
			DPF((TEXT("CIoctlTdi::CloseDevice() closesocket(m_ListenningSocket) failed %d\n"), WSAGetLastError ()));
		}
		m_ListenningSocket = INVALID_SOCKET;
	}
	if (INVALID_SOCKET != m_ConnectingSocket)
	{
		if (0 != closesocket(m_ConnectingSocket))
		{
			DPF((TEXT("CIoctlTdi::CloseDevice() closesocket(m_ConnectingSocket) failed %d\n"), WSAGetLastError ()));
		}
		m_ConnectingSocket = INVALID_SOCKET;
	}
	return (STATUS_SUCCESS == NtClose(pDevice->m_hDevice));
}
/*
BOOL CIoctlTdi::DeviceWriteFile(
		HANDLE hFile,                    // handle to file to write to
		LPCVOID lpBuffer,                // pointer to data to write to file
		DWORD nNumberOfBytesToWrite,     // number of bytes to write
		LPDWORD lpNumberOfBytesWritten,  // pointer to number of bytes written
		LPOVERLAPPED lpOverlapped        // pointer to structure for overlapped I/O
		)
{
	_ASSERTE(FALSE);
	return FALSE;
}

BOOL CIoctlTdi::DeviceReadFile(
		HANDLE hFile,                // handle of file to read
		LPVOID lpBuffer,             // pointer to buffer that receives data
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // pointer to number of bytes read
		LPOVERLAPPED lpOverlapped    // pointer to structure for data
		)
{
	_ASSERTE(FALSE);
	return FALSE;
}
*/
void CIoctlTdi::CallRandomWin32API(LPOVERLAPPED pOL)
{
	//_ASSERTE(FALSE);
    ;
}

BOOL CIoctlTdi::DeviceInputOutputControl(
		HANDLE hDevice,              // handle to a device, file, or directory 
		DWORD dwIoControlCode,       // control code of operation to perform
		LPVOID lpInBuffer,           // pointer to buffer to supply input data
		DWORD nInBufferSize,         // size, in bytes, of input buffer
		LPVOID lpOutBuffer,          // pointer to buffer to receive output data
		DWORD nOutBufferSize,        // size, in bytes, of output buffer
		LPDWORD lpBytesReturned,     // pointer to variable to receive byte count
		LPOVERLAPPED lpOverlapped    // pointer to structure for asynchronous operation
		)
{
	/*
	TDI_REQUEST_RECEIVE trr;
	char buf[10] = {0};
	lpOverlapped->Internal = (DWORD)STATUS_PENDING;
	NTSTATUS Status = NtDeviceIoControlFile (
		hDevice, 
		lpOverlapped->hEvent, 
		NULL, 
		NULL,
		(PIO_STATUS_BLOCK)&lpOverlapped->Internal,
		IOCTL_TDI_RECEIVE,
		&trr,
		sizeof (trr),
		buf,
		sizeof (buf)
		);
	if (!NT_SUCCESS(Status))
	{
		::SetLastError(RtlNtStatusToDosError(Status));
	}
	if (STATUS_PENDING == Status)
	{
		::SetLastError(ERROR_IO_PENDING);
	}
	DPF((TEXT("CIoctlTdi::DeviceInputOutputControl() NtDeviceIoControlFile(IOCTL_TDI_RECEIVE) returned 0x%08X=%d\n"), Status, ::GetLastError()));

	return (STATUS_SUCCESS == Status);
	*/
	///*
	HANDLE hDeviceAccordingToIOCTL = NULL;
	switch(dwIoControlCode)
	{
		//
		// lets handle the TCP IOCTLs first
		//
		case IOCTL_TCP_QUERY_INFORMATION_EX          :
		case IOCTL_TCP_SET_INFORMATION_EX          :
		case IOCTL_TCP_WSH_SET_INFORMATION_EX          :
		case IOCTL_TCP_QUERY_SECURITY_FILTER_STATUS          :
		case IOCTL_TCP_SET_SECURITY_FILTER_STATUS          :
		case IOCTL_TCP_ADD_SECURITY_FILTER          :
		case IOCTL_TCP_DELETE_SECURITY_FILTER          :
		case IOCTL_TCP_ENUMERATE_SECURITY_FILTER          :
		case IOCTL_TCP_RESERVE_PORT_RANGE          :
		case IOCTL_TCP_UNRESERVE_PORT_RANGE          :
		case IOCTL_TCP_BLOCK_PORTS          :
		case IOCTL_TCP_FINDTCB          :
		case IOCTL_TCP_RCVWND          :
			hDeviceAccordingToIOCTL = m_hTdiAddressHandle;
			break;

		default: //TDI IOCTLs
			hDeviceAccordingToIOCTL = hDevice;
	}

	lpOverlapped->Internal = (DWORD)STATUS_PENDING;
	NTSTATUS Status = NtDeviceIoControlFile (
		hDeviceAccordingToIOCTL, 
		lpOverlapped->hEvent, 
		NULL, 
		NULL,
		(PIO_STATUS_BLOCK)&lpOverlapped->Internal,
		dwIoControlCode,
		lpInBuffer,
		nInBufferSize,
		lpOutBuffer,
		nOutBufferSize
		);
	if (!NT_SUCCESS(Status))
	{
		::SetLastError(RtlNtStatusToDosError(Status));
	}
	if (STATUS_PENDING == Status)
	{
		//
		// i must do this, because that's how the caller knows that the operation is pending,
		// and if it is, he may wish to wait for it to finish
		//
		::SetLastError(ERROR_IO_PENDING);
	}
	//DPF((TEXT("CIoctlTdi::DeviceInputOutputControl() NtDeviceIoControlFile() returned 0x%08X=%d\n"), Status, ::GetLastError()));

	return (STATUS_SUCCESS == Status);
	//*/
}


void CIoctlTdi::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
	switch(dwIOCTL)
	{
		//
		// lets handle the TCP IOCTLs first
		//
	case IOCTL_TCP_QUERY_INFORMATION_EX          :
	case IOCTL_TCP_SET_INFORMATION_EX          :
	case IOCTL_TCP_WSH_SET_INFORMATION_EX          :
	case IOCTL_TCP_QUERY_SECURITY_FILTER_STATUS          :
	case IOCTL_TCP_SET_SECURITY_FILTER_STATUS          :
	case IOCTL_TCP_ADD_SECURITY_FILTER          :
	case IOCTL_TCP_DELETE_SECURITY_FILTER          :
	case IOCTL_TCP_ENUMERATE_SECURITY_FILTER          :
	case IOCTL_TCP_RESERVE_PORT_RANGE          :
	case IOCTL_TCP_UNRESERVE_PORT_RANGE          :
	case IOCTL_TCP_BLOCK_PORTS          :
	case IOCTL_TCP_FINDTCB          :
	case IOCTL_TCP_RCVWND          :
		TcpIpCommon_PrepareIOCTLParams(
			dwIOCTL,
			abInBuffer,
			dwInBuff,
			abOutBuffer,
			dwOutBuff
			);
		return;

		break;

	case IOCTL_TDI_ACCEPT          :
		break;

	case IOCTL_TDI_ACTION          :
		break;

	case IOCTL_TDI_CONNECT          :
		break;

	case IOCTL_TDI_DISCONNECT          :
		break;

	case IOCTL_TDI_LISTEN          :
		break;

	case IOCTL_TDI_QUERY_INFORMATION          :
/*
typedef struct _TDI_REQUEST_QUERY_INFORMATION {
    TDI_REQUEST Request;
    ULONG QueryType;                          // class of information to be queried.
    PTDI_CONNECTION_INFORMATION RequestConnectionInformation;
} TDI_REQUEST_QUERY_INFORMATION, *PTDI_REQUEST_QUERY_INFORMATION;
typedef struct _TDI_REQUEST {
    union {
        HANDLE AddressHandle;
        CONNECTION_CONTEXT ConnectionContext;
        HANDLE ControlChannel;
    } Handle;

    PVOID RequestNotifyObject;
    PVOID RequestContext;
    TDI_STATUS TdiStatus;
} TDI_REQUEST, *PTDI_REQUEST;
*/
        //((PTDI_REQUEST_QUERY_INFORMATION)abInBuffer)->Request = xxx;
        ((PTDI_REQUEST_QUERY_INFORMATION)abInBuffer)->QueryType = CIoctlTCPSrv::GetRandomQueryType();
        //((PTDI_REQUEST_QUERY_INFORMATION)abInBuffer)->RequestConnectionInformation = xxx;

        SetInParam(dwInBuff, sizeof(TDI_REQUEST_QUERY_INFORMATION));

        SetOutParam(abOutBuffer, dwOutBuff, (rand()%5)*sizeof(TDI_PROVIDER_INFO));

        break;

	case IOCTL_TDI_RECEIVE          :
		//TODO: randomize ALL members of this struct
        ((PTDI_REQUEST_RECEIVE)abInBuffer)->ReceiveFlags = 0;
        SetInParam(dwInBuff, sizeof(TDI_REQUEST_RECEIVE));

        SetOutParam(abOutBuffer, dwOutBuff, rand());

        break;

	case IOCTL_TDI_RECEIVE_DATAGRAM          :
		break;

	case IOCTL_TDI_SEND          :
		//TODO: randomize ALL members of this struct
        ((PTDI_REQUEST_SEND)abInBuffer)->SendFlags = rand()%2 ? 0 : rand()%2 ? rand() : DWORD_RAND;
        SetInParam(dwInBuff, sizeof(TDI_REQUEST_SEND));

        SetOutParam(abOutBuffer, dwOutBuff, rand());

        break;

	case IOCTL_TDI_SEND_DATAGRAM          :
		break;

	case IOCTL_TDI_SET_EVENT_HANDLER          :
		break;

	case IOCTL_TDI_SET_INFORMATION          :
		//TODO: randomize ALL members of this struct
        //((PTDI_REQUEST_SET_INFORMATION)abInBuffer)->xxx = rand()%2 ? 0 : rand()%2 ? rand() : DWORD_RAND;
        SetInParam(dwInBuff, sizeof(TDI_REQUEST_SET_INFORMATION));

        SetOutParam(abOutBuffer, dwOutBuff, rand());

        break;

	case IOCTL_TDI_ASSOCIATE_ADDRESS          :
		//TODO: randomize ALL members of this struct
        //((PTDI_REQUEST_ASSOCIATE_ADDRESS)abInBuffer)->xxx = rand()%2 ? 0 : rand()%2 ? rand() : DWORD_RAND;
        SetInParam(dwInBuff, sizeof(TDI_REQUEST_ASSOCIATE_ADDRESS));

        SetOutParam(abOutBuffer, dwOutBuff, rand());

        break;

	case IOCTL_TDI_DISASSOCIATE_ADDRESS          :
		break;

	case IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER:
        SetOutParam(abOutBuffer, dwOutBuff, sizeof(ULONG_PTR));
		break;

	case IOCTL_TDI_QUERY_DIRECT_SENDDG_HANDLER:
		break;

	default:
		_tprintf(TEXT("CIoctlTdi::PrepareIOCTLParams() 0x%08X is an unexpected IOCTL\n"), dwIOCTL);
		_ASSERTE(FALSE);
		CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
	}
}


BOOL CIoctlTdi::FindValidIOCTLs(CDevice *pDevice)
{
	//
	// TCP IOCTLS
	//
	AddIOCTL(pDevice, IOCTL_TCP_QUERY_INFORMATION_EX          );
	AddIOCTL(pDevice, IOCTL_TCP_SET_INFORMATION_EX          );
	AddIOCTL(pDevice, IOCTL_TCP_QUERY_SECURITY_FILTER_STATUS          );
	AddIOCTL(pDevice, IOCTL_TCP_SET_SECURITY_FILTER_STATUS          );
	AddIOCTL(pDevice, IOCTL_TCP_ADD_SECURITY_FILTER          );
	AddIOCTL(pDevice, IOCTL_TCP_DELETE_SECURITY_FILTER          );
	AddIOCTL(pDevice, IOCTL_TCP_ENUMERATE_SECURITY_FILTER          );
	AddIOCTL(pDevice, IOCTL_TCP_RESERVE_PORT_RANGE          );
	AddIOCTL(pDevice, IOCTL_TCP_UNRESERVE_PORT_RANGE          );
	AddIOCTL(pDevice, IOCTL_TCP_BLOCK_PORTS          );
	AddIOCTL(pDevice, IOCTL_TCP_WSH_SET_INFORMATION_EX          );
	AddIOCTL(pDevice, IOCTL_TCP_FINDTCB          );
	AddIOCTL(pDevice, IOCTL_TCP_RCVWND          );

	//
	// TDI IOCTLS
	//
	AddIOCTL(pDevice, IOCTL_TDI_ACCEPT          );
	AddIOCTL(pDevice, IOCTL_TDI_ACTION          );
	AddIOCTL(pDevice, IOCTL_TDI_CONNECT          );
	AddIOCTL(pDevice, IOCTL_TDI_DISCONNECT          );
	AddIOCTL(pDevice, IOCTL_TDI_LISTEN          );
	AddIOCTL(pDevice, IOCTL_TDI_QUERY_INFORMATION          );
//	AddIOCTL(pDevice, IOCTL_TDI_RECEIVE          );
	AddIOCTL(pDevice, IOCTL_TDI_RECEIVE_DATAGRAM          );
	AddIOCTL(pDevice, IOCTL_TDI_SEND          );
	AddIOCTL(pDevice, IOCTL_TDI_SEND_DATAGRAM          );
	AddIOCTL(pDevice, IOCTL_TDI_SET_EVENT_HANDLER          );
	AddIOCTL(pDevice, IOCTL_TDI_SET_INFORMATION          );
	AddIOCTL(pDevice, IOCTL_TDI_ASSOCIATE_ADDRESS          );
	AddIOCTL(pDevice, IOCTL_TDI_DISASSOCIATE_ADDRESS          );
	AddIOCTL(pDevice, IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER          );
	AddIOCTL(pDevice, IOCTL_TDI_QUERY_DIRECT_SENDDG_HANDLER          );

    return TRUE;
}



DWORD WINAPI CIoctlTdi::AcceptingThread (LPVOID pVoid)
{
   SOCKET s;
   struct sockaddr_in sockaddr;
   int l;
   int status;
   DWORD retlen;
   CHAR buf[100];

   CIoctlTdi *pThis = (CIoctlTdi*)pVoid;

   while (1) {
      l = sizeof (sockaddr);
      s = accept (pThis->m_ListenningSocket, (struct sockaddr *) &sockaddr, &l);
      if (s == INVALID_SOCKET) {
         if (INVALID_SOCKET == pThis->m_ListenningSocket)
		 {
			 //
			 // the socket was closed, let keep polling
			 //
			 ::Sleep(10);
			 continue;
		 }
		 else
		 {
			 DPF( (TEXT("Socket failed %d\n"), WSAGetLastError ()) );
		 }
      }
      while (1) {
         l = recv (s, buf, sizeof (buf), 0);
         if (l == 0) {
            break;
         }
         if (l == SOCKET_ERROR) {
            DPF( (TEXT("recv failed %d\n"), WSAGetLastError ()) );
            continue;
         }
      }
      closesocket (s);
   }
   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\trnsbufr.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    trnsbufr.h

Abstract:

Note:
    This file is compiled in Kernel Mode and User Mode.

Author:

    Doron Juster  (DoronJ)   30-apr-96

Revision History:
--*/

#ifndef __TRNSBUFR_H
#define __TRNSBUFR_H

#ifndef _TRANSFER_BUFFER_DEFINED
#define _TRANSFER_BUFFER_DEFINED

#ifdef __midl
cpp_quote("#pragma pack(push, 1)")
cpp_quote("#ifndef __cplusplus")
cpp_quote("#ifndef _TRANSFER_BUFFER_DEFINED")
cpp_quote("#define _TRANSFER_BUFFER_DEFINED")
#else
#pragma pack(push, 1)
#endif // __midl

enum TRANSFER_TYPE {
    CACTB_SEND = 0,
    CACTB_RECEIVE,
    CACTB_CREATECURSOR,
};

//---------------------------------------------------------
//
//  struct CACTransferBuffer
//
//  NOTE:   This structure should NOT contain virtual
//          functions. They are not RPC-able.
//
//---------------------------------------------------------

struct CACTransferBuffer {

#ifndef __midl
public:
    CACTransferBuffer(TRANSFER_TYPE tt);
#endif // __midl

    ULONG uTransferType;

#ifdef __midl
    [switch_is(uTransferType)]
#endif // __midl

    union {

#ifdef __midl
        [case(CACTB_SEND)]
#endif // __midl
        struct {
            //
            //  MQSendMessage parameters
            //
            struct QUEUE_FORMAT* pAdminQueueFormat;
            struct QUEUE_FORMAT* pResponseQueueFormat;
        } Send;

#ifdef __midl
        [case(CACTB_RECEIVE)]
#endif // __midl
        struct {
            //
            //  MQReceiveMessage parameters
            //

            ULONG RequestTimeout;
            ULONG Action;
            ULONG Asynchronous;
#ifdef __midl
            ULONG Cursor;
#else
            HANDLE Cursor;
#endif // __midl

            //
            // Important note:
            // In the following xxxFormatName properties, the value
            // "ulxxxFormatNameLen" is the size of the buffer on input.
            // This value MUST NOT be changed by the driver or QM. This
            // value tell the RPC run-time how many bytes to transfer
            // across process/machine boundaries.
            // The value "pulxxxFormatNameLenProp" is the property passed
            // by caller. This value IS changed and returned to caller to
            // indicate the length of the string.
            //
            ULONG   ulResponseFormatNameLen ;
#ifdef __midl
            [size_is(,ulResponseFormatNameLen)]
#endif // __midl
            WCHAR** ppResponseFormatName;
            ULONG*  pulResponseFormatNameLenProp;

            ULONG   ulAdminFormatNameLen ;
#ifdef __midl
            [size_is(,ulAdminFormatNameLen)]
#endif // __midl
            WCHAR** ppAdminFormatName;
            ULONG*  pulAdminFormatNameLenProp;

            ULONG   ulDestFormatNameLen;
#ifdef __midl
            [size_is(,ulDestFormatNameLen)]
#endif // __midl
            WCHAR** ppDestFormatName;
            ULONG*  pulDestFormatNameLenProp;

            ULONG   ulOrderingFormatNameLen;
#ifdef __midl
            [size_is(,ulOrderingFormatNameLen)]
#endif // __midl
            WCHAR** ppOrderingFormatName;
            ULONG*  pulOrderingFormatNameLenProp;
        } Receive;

#ifdef __midl
        [case(CACTB_CREATECURSOR)]
#endif
        struct {
            //
            //  MQCreateCursor parameters
            //
#ifdef __midl
            ULONG hCursor;
#else
            HANDLE hCursor;
#endif
            ULONG srv_hACQueue;
            ULONG cli_pQMQueue;
        } CreateCursor;
    };

    //
    //  Message properties pointers
    //
    USHORT* pClass;
    OBJECTID** ppMessageID;

#ifdef __midl
        //
        //  BUGBUG: 20 must match PROPID_M_CORRELATIONID_SIZE
        //
        [size_is(,20), length_is(,20)]
#endif // __midl
    UCHAR** ppCorrelationID;

    ULONG* pSentTime;
    ULONG* pArrivedTime;
    UCHAR* pPriority;
    UCHAR* pDelivery;
    UCHAR* pAcknowledge;
    UCHAR* pAuditing;
    ULONG* pApplicationTag;

#ifdef __midl
        [size_is(,ulAllocBodyBufferInBytes),
         length_is(,ulBodyBufferSizeInBytes)]
#endif // __midl
    UCHAR** ppBody;
    ULONG ulBodyBufferSizeInBytes;
    ULONG ulAllocBodyBufferInBytes;
    ULONG* pBodySize;

#ifdef __midl
        //
        //  don't use [string] for *ppTitle, it is not
        //  initialized for RPC, thus we say how much to marshul.
        //
        [size_is(,ulTitleBufferSizeInWCHARs),
         length_is(,ulTitleBufferSizeInWCHARs)]
#endif // __midl
    WCHAR** ppTitle;
    ULONG   ulTitleBufferSizeInWCHARs;
    ULONG*  pulTitleBufferSizeInWCHARs;

    ULONG ulAbsoluteTimeToQueue;
    ULONG* pulRelativeTimeToQueue;

    ULONG ulRelativeTimeToLive;
    ULONG* pulRelativeTimeToLive;

    UCHAR* pTrace;
    ULONG* pulSenderIDType;

#ifdef __midl
        [size_is(,uSenderIDLen)]
#endif // __midl
    UCHAR** ppSenderID;
    ULONG* pulSenderIDLenProp;

    ULONG* pulPrivLevel;
    ULONG  ulAuthLevel;
    UCHAR* pAuthenticated;
    ULONG* pulHashAlg;
    ULONG* pulEncryptAlg;

#ifdef __midl
        [size_is(,ulSenderCertLen)]
#endif // __midl
    UCHAR** ppSenderCert;
    ULONG ulSenderCertLen;
    ULONG* pulSenderCertLenProp;

#ifdef __midl
        [size_is(,ulProvNameLen)]
#endif // __midl
    WCHAR** ppwcsProvName;
    ULONG   ulProvNameLen;
    ULONG*  pulProvNameLenProp;

    ULONG*  pulProvType;
    BOOL    fDefaultProvider;

#ifdef __midl
        [size_is(,ulSymmKeysSize)]
#endif // __midl
    UCHAR** ppSymmKeys;
    ULONG   ulSymmKeysSize;
    ULONG*  pulSymmKeysSizeProp;

    UCHAR bEncrypted;
    UCHAR bAuthenticated;
    USHORT uSenderIDLen;

#ifdef __midl
        [size_is(,ulSignatureSize)]
#endif // __midl
    UCHAR** ppSignature;
    ULONG   ulSignatureSize;
    ULONG*  pulSignatureSizeProp;

    GUID** ppSrcQMID;

    XACTUOW* pUow;

#ifdef __midl
        [size_is(,ulMsgExtensionBufferInBytes),
         length_is(,ulMsgExtensionBufferInBytes)]
#endif // __midl
    UCHAR** ppMsgExtension;
    ULONG ulMsgExtensionBufferInBytes;
    ULONG* pMsgExtensionSize;
    GUID** ppConnectorType;
    ULONG* pulBodyType;
    ULONG* pulVersion;
};

#ifdef __cplusplus

inline CACTransferBuffer::CACTransferBuffer(TRANSFER_TYPE tt)
{
    memset(this, 0, sizeof(CACTransferBuffer));
    uTransferType = tt;
}

#endif // __cplusplus


#ifdef __midl
cpp_quote("#endif // _TRANSFER_BUFFER_DEFINED")
cpp_quote("#endif // __cplusplus")
cpp_quote("#pragma pack(pop)")
#else
#pragma pack(pop)
#endif // __midl

#endif // _TRANSFER_BUFFER_DEFINED

#endif //  __TRNSBUFR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\vdmioctl.h ===
#ifndef __VDM_IOCTL_H
#define __VDM_IOCTL_H

//#include "IOCTL.h"


class CIoctlVDM : public CIoctl
{
public:
    CIoctlVDM(CDevice *pDevice): CIoctl(pDevice){;};
    virtual ~CIoctlVDM(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

    virtual void CallRandomWin32API(OVERLAPPED *pOL);
};




#endif //__VDM_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\xactdefs.h ===
// We don't want include transaction files here; so redefining what we need
// BUGBUG: not too good - better to use the same definitions
#ifndef __transact_h__
#ifndef __xactdefs_h__
#define __xactdefs_h__
typedef struct  BOID
    {
    unsigned char rgb[ 16 ];
    }   BOID;

typedef BOID XACTUOW;
#endif
#endif

//class CTransaction;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\wmidatadeviceioctl.h ===
#ifndef __WMIDATADEVICE_IOCTL_H
#define __WMIDATADEVICE_IOCTL_H

//#include "IOCTL.h"


class CIoctlWmiDataDevice : public CIoctl
{
public:
    CIoctlWmiDataDevice(CDevice *pDevice): CIoctl(pDevice){;};
    virtual ~CIoctlWmiDataDevice(){;};

    virtual void PrepareIOCTLParams(
        DWORD& dwIOCTL, 
        BYTE *abInBuffer,
        DWORD &dwInBuff,
        BYTE *abOutBuffer,
        DWORD &dwOutBuff
        );

    virtual BOOL FindValidIOCTLs(CDevice *pDevice);

    virtual void UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL);

	virtual void CallRandomWin32API(LPOVERLAPPED pOL);

};




#endif //__WMIDATADEVICE_IOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\vdmioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*



#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
*/
#include "VDMIOCTL.h"

static bool s_fVerbose = false;

////////////////////////////////////////////////////////
// from #include <ntddvdm.h>
////////////////////////////////////////////////////////

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//
//
#define IOCTL_VDM_BASE		FILE_DEVICE_VDM

//
// 32 VDDs. Each VDD has possible 127 private ioctl code
// These values are based on the fact that there are 12 bits reserved
// for function id in each IOCTL code.
//
#define IOCTL_VDM_GROUP_MASK	0xF80
#define IOCTL_VDM_GROUP_SIZE	127

#define IOCTL_VDM_PARALLEL_GROUP    0

#define IOCTL_VDM_PARALLEL_BASE IOCTL_VDM_BASE + IOCTL_VDM_PARALLEL_GROUP * IOCTL_VDM_GROUP_SIZE
#define IOCTL_VDM_PAR_WRITE_DATA_PORT	CTL_CODE(IOCTL_VDM_PARALLEL_BASE, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VDM_PAR_WRITE_CONTROL_PORT CTL_CODE(IOCTL_VDM_PARALLEL_BASE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VDM_PAR_READ_STATUS_PORT CTL_CODE(IOCTL_VDM_PARALLEL_BASE, 3, METHOD_BUFFERED, FILE_ANY_ACCESS)

////////////////////////////////////////////////////////
// end of #include <ntddvdm.h>
////////////////////////////////////////////////////////

void CIoctlVDM::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    ;
}

void CIoctlVDM::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
    CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
}


BOOL CIoctlVDM::FindValidIOCTLs(CDevice *pDevice)
{
    //AddIOCTL(pDevice, IOCTL_VDM_PARALLEL_BASE);
    AddIOCTL(pDevice, IOCTL_VDM_PAR_WRITE_DATA_PORT);
    AddIOCTL(pDevice, IOCTL_VDM_PAR_WRITE_CONTROL_PORT);
    AddIOCTL(pDevice, IOCTL_VDM_PAR_READ_STATUS_PORT);

    return TRUE;
}



void CIoctlVDM::CallRandomWin32API(LPOVERLAPPED pOL)
{
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\deviceioctls\wmidatadeviceioctl.cpp ===
#include "DeviceIOCTLS.pch"
#pragma hdrstop
/*



#include <windows.h>
#include <winnt.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
*/
static bool s_fVerbose = false;


///////////////////////////////////////////////////////////////////////
 #include <wmistr.h>
 #include <wmiumkm.h>
///////////////////////////////////////////////////////////////////////
//
// This structure is used in IOCTL_WMI_TRANSLATE_FILE_HANDLE
/*
typedef struct _WMIFHTOINSTANCENAME
{
    union
    {
        IN HANDLE FileHandle;      // File handle whose instance name is needed
        OUT ULONG SizeNeeded;      // If incoming buffer too small then this
                                   // returns with number bytes needed.
    };
    OUT USHORT InstanceNameLength; // Length of instance name in bytes
    OUT WCHAR InstanceNameBase[1];  // Instance name in unicode
} WMIFHTOINSTANCENAME, *PWMIFHTOINSTANCENAME;

typedef struct _WMIVERSIONINFO
{
    ULONG32 Version;
} WMIVERSIONINFO, *PWMIVERSIONINFO;

//
// This is used in IOCTL_WMI_GET_ALL_REGISTRANT to report the list of
// registered KM data providers to the WMI service
typedef struct _KMREGINFO
{
    OUT ULONG_PTR ProviderId;	// Provider Id (or device object pointer)
    OUT ULONG Flags;		// REGENTRY_FLAG_*
} KMREGINFO, *PKMREGINFO;
#define REGENTRY_FLAG_NEWREGINFO 0x00000004   // Entry has new registration info
#define REGENTRY_FLAG_UPDREGINFO 0x00000008   // Entry has updated registration info

typedef struct _WMIOPENGUIDBLOCK
{
    IN POBJECT_ATTRIBUTES ObjectAttributes;
    IN ACCESS_MASK DesiredAccess;

// BUGBUG: IA64
    OUT HANDLE Handle;
} WMIOPENGUIDBLOCK, *PWMIOPENGUIDBLOCK;

typedef struct _WMICHECKGUIDACCESS
{
    GUID Guid;
    ACCESS_MASK DesiredAccess;
} WMICHECKGUIDACCESS, *PWMICHECKGUIDACCESS;


typedef enum
{
    WmiReadNotifications = 64,
    WmiGetNextRegistrant = 65,
#ifndef MEMPHIS	    
    WmiOpenGuid = 66,
#endif	    
    WmiNotifyUser = 67,
    WmiGetAllRegistrant = 68,
    WmiGenerateEvent = 69,

    WmiTranslateFileHandle = 71,
    WmiGetVersion = 73,
    WmiCheckAccess = 74
} WMISERVICECODES;

typedef enum
{
    WmiStartLoggerCode = 32,
    WmiStopLoggerCode = 33,
    WmiQueryLoggerCode = 34,
    WmiTraceEventCode = 35,
    WmiUpdateLoggerCode = 36
} WMITRACECODE;

typedef enum tagWMIACTIONCODE
{
    WmiGetAllData = 0,
    WmiGetSingleInstance = 1,
    WmiChangeSingleInstance = 2,
    WmiChangeSingleItem = 3,
    WmiEnableEvents = 4,
    WmiDisableEvents  = 5,
    WmiEnableCollection = 6,
    WmiDisableCollection = 7,
    WmiRegisterInfo = 8,
    WmiExecuteMethodCall = 9,
    WmiSetTraceNotify = 10
} WMIACTIONCODE;



#define IOCTL_WMI_READ_NOTIFICATIONS \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiReadNotifications, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This IOCTL will return with the next set of unprocessed registration info
// BufferIn - Not used
// BufferOut - Buffer to return registration information
#define IOCTL_WMI_GET_NEXT_REGISTRANT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetNextRegistrant, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This IOCTL will return a handle to a guid
// BufferIn - WMIOPENGUIDBLOCK
// BufferOut - WMIOPENGUIDBLOCK
#define IOCTL_WMI_OPEN_GUID \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiOpenGuid, METHOD_BUFFERED, FILE_READ_ACCESS)

// This IOCTL will perform a query for all data items of a data block
// BufferIn - Incoming WNODE describing query. This gets filled in by driver
#define IOCTL_WMI_QUERY_ALL_DATA \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetAllData, METHOD_BUFFERED, FILE_READ_ACCESS)

// This IOCTL will query for a single instance
// BufferIn - Incoming WNODE describing query. This gets filled in by driver
#define IOCTL_WMI_QUERY_SINGLE_INSTANCE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetSingleInstance, METHOD_BUFFERED, FILE_READ_ACCESS)

// This IOCTL will set a single instance
// BufferIn - Incoming WNODE describing set.
#define IOCTL_WMI_SET_SINGLE_INSTANCE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiChangeSingleInstance, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will set a single item
// BufferIn - Incoming WNODE describing set.
#define IOCTL_WMI_SET_SINGLE_ITEM \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiChangeSingleItem, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will enable an event
// BufferIn - Incoming WNODE event item to enable
#define IOCTL_WMI_ENABLE_EVENT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiEnableEvents, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will disable an event
// BufferIn - Incoming WNODE event item to disable
#define IOCTL_WMI_DISABLE_EVENT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiDisableEvents, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will enable collection
// BufferIn - Incoming WNODE describing what to enable for collection
#define IOCTL_WMI_ENABLE_COLLECTION \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiEnableCollection, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will disable collection
// BufferIn - Incoming WNODE describing what to disable for collection
#define IOCTL_WMI_DISABLE_COLLECTION \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiDisableCollection, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will return the registration information for a specific provider
// BufferIn - Provider handle
// BufferOut - Buffer to return WMI information
#define IOCTL_WMI_GET_REGINFO \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiRegisterInfo, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will execute a method on a device
// BufferIn - WNODE_METHOD_ITEM
// BufferOut - WNODE_METHOD_ITEM
#define IOCTL_WMI_EXECUTE_METHOD \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiExecuteMethodCall, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will cause a registration notification to be generated
// BufferIn - Not used
// BufferOut - Not used
#define IOCTL_WMI_NOTIFY_USER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiNotifyUser, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This IOCTL will return with the all registration info
// BufferIn - Not used
// BufferOut - Buffer to return all registration information
#define IOCTL_WMI_GET_ALL_REGISTRANT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetAllRegistrant, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This IOCTL will cause certain data providers to generate events
// BufferIn - WnodeEventItem to use in firing event
// BufferOut - Not Used
#define IOCTL_WMI_GENERATE_EVENT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGenerateEvent, METHOD_BUFFERED, FILE_WRITE_ACCESS)


// This IOCTL will translate a File Object into a device object
// BufferIn - pointer to incoming WMIFILETODEVICE structure
// BufferOut - outgoing WMIFILETODEVICE structure
#define IOCTL_WMI_TRANSLATE_FILE_HANDLE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiTranslateFileHandle, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This IOCTL will check if the caller has desired access to the guid
// BufferIn - WMIOPENGUIDBLOCK
// BufferOut - WMIOPENGUIDBLOCK
#define IOCTL_WMI_CHECK_ACCESS \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiCheckAccess, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This IOCTL will determine the version of WMI
// BufferIn - Not used
// BufferOut - WMIVERSIONINFO
#define IOCTL_WMI_GET_VERSION \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetVersion, METHOD_BUFFERED, FILE_READ_ACCESS)


//
// This IOCTL will start an instance of a logger
// BufferIn - Logger configuration information
// BufferOut - Updated logger information when logger is started
#define IOCTL_WMI_START_LOGGER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiStartLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will stop an instance of a logger
// BufferIn - Logger information structure with Handle set
// BufferOut - Updated logger information when logger is stopped
#define IOCTL_WMI_STOP_LOGGER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiStopLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will update an existing logger attributes
// BufferIn - Logger information structure with Handle set
// BufferOut - Updated logger information
#define IOCTL_WMI_UPDATE_LOGGER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiUpdateLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will query a logger for its information
// BufferIn - Logger information structure with Handle set
// BufferOut - Updated logger information
#define IOCTL_WMI_QUERY_LOGGER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiQueryLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will synchronize a trace record to the logger
// BufferIn - Trace record, with handle set
// BufferOut - Not used
#define IOCTL_WMI_TRACE_EVENT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiTraceEventCode, METHOD_NEITHER, FILE_WRITE_ACCESS)
///////////////////////////////////////////////////////////////////////
// end of #include <wmiumkm.h>
///////////////////////////////////////////////////////////////////////
*/

#include "WmiDataDEviceIOCTL.h"




void CIoctlWmiDataDevice::UseOutBuff(DWORD dwIOCTL, BYTE *abOutBuffer, DWORD dwOutBuff, OVERLAPPED *pOL)
{
    ;
}

BOOL CIoctlWmiDataDevice::FindValidIOCTLs(CDevice *pDevice)
{
    BOOL bRet = TRUE;
    DPF((TEXT("FindValidIOCTLs() %s is known, will use known IOCTLs\n"), pDevice->GetDeviceName()));

    AddIOCTL(pDevice, IOCTL_WMI_READ_NOTIFICATIONS    );
    AddIOCTL(pDevice, IOCTL_WMI_GET_NEXT_REGISTRANT    );
    AddIOCTL(pDevice, IOCTL_WMI_OPEN_GUID    );
    AddIOCTL(pDevice, IOCTL_WMI_QUERY_ALL_DATA    );
    AddIOCTL(pDevice, IOCTL_WMI_QUERY_SINGLE_INSTANCE    );
    AddIOCTL(pDevice, IOCTL_WMI_SET_SINGLE_INSTANCE    );
    AddIOCTL(pDevice, IOCTL_WMI_SET_SINGLE_ITEM    );
    AddIOCTL(pDevice, IOCTL_WMI_ENABLE_EVENT    );
    AddIOCTL(pDevice, IOCTL_WMI_DISABLE_EVENT    );
    AddIOCTL(pDevice, IOCTL_WMI_ENABLE_COLLECTION    );
    AddIOCTL(pDevice, IOCTL_WMI_DISABLE_COLLECTION    );
    AddIOCTL(pDevice, IOCTL_WMI_GET_REGINFO    );
    AddIOCTL(pDevice, IOCTL_WMI_EXECUTE_METHOD    );
    AddIOCTL(pDevice, IOCTL_WMI_NOTIFY_USER    );
    AddIOCTL(pDevice, IOCTL_WMI_GET_ALL_REGISTRANT    );
    AddIOCTL(pDevice, IOCTL_WMI_GENERATE_EVENT    );
    AddIOCTL(pDevice, IOCTL_WMI_TRANSLATE_FILE_HANDLE    );
    AddIOCTL(pDevice, IOCTL_WMI_CHECK_ACCESS    );
    AddIOCTL(pDevice, IOCTL_WMI_GET_VERSION    );
    AddIOCTL(pDevice, IOCTL_WMI_START_LOGGER    );
    AddIOCTL(pDevice, IOCTL_WMI_STOP_LOGGER    );
    AddIOCTL(pDevice, IOCTL_WMI_UPDATE_LOGGER    );
    AddIOCTL(pDevice, IOCTL_WMI_QUERY_LOGGER    );
    AddIOCTL(pDevice, IOCTL_WMI_TRACE_EVENT    );

    return TRUE;
}






void static SetRandomWnodeHeader(struct _WNODE_HEADER *pWnodeHeader)
{
    pWnodeHeader->BufferSize = rand()%10 ? sizeof(WNODE_HEADER) : (sizeof(WNODE_HEADER) + (rand()%9) -4);
    pWnodeHeader->ProviderId = rand();
    pWnodeHeader->Version = rand();
    pWnodeHeader->Linkage = rand();
    pWnodeHeader->KernelHandle = (HANDLE)CIoctl::GetRandomIllegalPointer();
    pWnodeHeader->Guid.Data1 = DWORD_RAND;
    pWnodeHeader->Guid.Data2 = rand();
    pWnodeHeader->Guid.Data3 = rand();
    pWnodeHeader->Guid.Data4[0] = rand();
    pWnodeHeader->Guid.Data4[1] = rand();
    pWnodeHeader->Guid.Data4[2] = rand();
    pWnodeHeader->Guid.Data4[3] = rand();
    pWnodeHeader->ClientContext = rand()%2 ? DWORD_RAND : (ULONG)CIoctl::GetRandomIllegalPointer();
    pWnodeHeader->Flags = 0;
	if (0 == rand()%10) pWnodeHeader->Flags |= WNODE_FLAG_ALL_DATA;
	if (0 == rand()%10) pWnodeHeader->Flags |= WNODE_FLAG_SINGLE_INSTANCE;
	if (0 == rand()%10) pWnodeHeader->Flags |= WNODE_FLAG_SINGLE_ITEM;
	if (0 == rand()%10) pWnodeHeader->Flags |= WNODE_FLAG_EVENT_ITEM;
	if (0 == rand()%10) pWnodeHeader->Flags |= WNODE_FLAG_FIXED_INSTANCE_SIZE;
	if (0 == rand()%10) pWnodeHeader->Flags |= WNODE_FLAG_TOO_SMALL;
	if (0 == rand()%10) pWnodeHeader->Flags |= WNODE_FLAG_INSTANCES_SAME;
	if (0 == rand()%10) pWnodeHeader->Flags |= WNODE_FLAG_STATIC_INSTANCE_NAMES;
	if (0 == rand()%10) pWnodeHeader->Flags |= WNODE_FLAG_INTERNAL;
	if (0 == rand()%10) pWnodeHeader->Flags |= WNODE_FLAG_USE_TIMESTAMP;
	if (0 == rand()%10) pWnodeHeader->Flags |= WNODE_FLAG_EVENT_REFERENCE;
	if (0 == rand()%10) pWnodeHeader->Flags |= WNODE_FLAG_ANSI_INSTANCENAMES;
	if (0 == rand()%10) pWnodeHeader->Flags |= WNODE_FLAG_METHOD_ITEM;
	if (0 == rand()%10) pWnodeHeader->Flags |= WNODE_FLAG_PDO_INSTANCE_NAMES;
	if (0 == rand()%10) pWnodeHeader->Flags |= WNODE_FLAG_TRACED_GUID;
	if (0 == rand()%10) pWnodeHeader->Flags |= WNODE_FLAG_LOG_WNODE;
	if (0 == rand()%10) pWnodeHeader->Flags |= WNODE_FLAG_USE_GUID_PTR;
	if (0 == rand()%10) pWnodeHeader->Flags |= WNODE_FLAG_USE_MOF_PTR;
	if (0 == rand()%10) pWnodeHeader->Flags |= WNODE_FLAG_INTERNAL2;
	if (0 == rand()%10) pWnodeHeader->Flags |= WNODE_FLAG_SEVERITY_MASK;
}

void CIoctlWmiDataDevice::PrepareIOCTLParams(
    DWORD& dwIOCTL,
    BYTE *abInBuffer,
    DWORD &dwInBuff,
    BYTE *abOutBuffer,
    DWORD &dwOutBuff
    )
{
	switch(dwIOCTL)
	{
	case IOCTL_WMI_READ_NOTIFICATIONS:
		SetOutParam(abOutBuffer, dwOutBuff, sizeof(WNODE_TOO_SMALL));
		break;

	case IOCTL_WMI_GET_ALL_REGISTRANT:
		SetOutParam(abOutBuffer, dwOutBuff, SIZEOF_INOUTBUFF);
		break;

    case IOCTL_WMI_DISABLE_EVENT:
    case IOCTL_WMI_ENABLE_EVENT:
    case IOCTL_WMI_ENABLE_COLLECTION:
    case IOCTL_WMI_DISABLE_COLLECTION:
        ((PWNODE_HEADER)abInBuffer)->BufferSize = (sizeof(WNODE_HEADER)*(1+rand()))%SIZEOF_INOUTBUFF;
		dwInBuff = rand()%10 ? ((PWNODE_HEADER)abInBuffer)->BufferSize : rand()%SIZEOF_INOUTBUFF;
		
		break;

	case IOCTL_WMI_GET_REGINFO:
		SetOutParam(abOutBuffer, dwOutBuff, sizeof(WNODE_TOO_SMALL));
		dwInBuff = rand()%10 ? sizeof(KMREGINFO) : (sizeof(KMREGINFO)-1);
        ((PKMREGINFO)abInBuffer)->Flags = 0;
		if (0 == rand()%3) ((PKMREGINFO)abInBuffer)->Flags |= REGENTRY_FLAG_NEWREGINFO;
		if (0 == rand()%3) ((PKMREGINFO)abInBuffer)->Flags |= REGENTRY_FLAG_UPDREGINFO;
		break;

	case IOCTL_WMI_OPEN_GUID:
		SetOutParam(abOutBuffer, dwOutBuff, sizeof(WMIOPENGUIDBLOCK));
		dwInBuff = rand()%10 ? sizeof(WMIOPENGUIDBLOCK) : (sizeof(WMIOPENGUIDBLOCK)-1);
		break;

	case IOCTL_WMI_CHECK_ACCESS:
		SetOutParam(abOutBuffer, dwOutBuff, sizeof(WMICHECKGUIDACCESS));
		dwInBuff = rand()%10 ? sizeof(WMICHECKGUIDACCESS) : (sizeof(WMICHECKGUIDACCESS)-1);
		break;

	case IOCTL_WMI_QUERY_ALL_DATA:
		SetOutParam(abOutBuffer, dwOutBuff, (1+rand()%10)*sizeof(WNODE_TOO_SMALL));
		break;

	case IOCTL_WMI_QUERY_SINGLE_INSTANCE:
		SetOutParam(abOutBuffer, dwOutBuff, (1+rand()%10)*sizeof(WNODE_TOO_SMALL));
		break;

	case IOCTL_WMI_SET_SINGLE_INSTANCE:
	case IOCTL_WMI_SET_SINGLE_ITEM:
		SetRandomWnodeHeader(&((PWNODE_SINGLE_INSTANCE)abInBuffer)->WnodeHeader);

        ((PWNODE_SINGLE_INSTANCE)abInBuffer)->OffsetInstanceName = rand()%100;
        ((PWNODE_SINGLE_INSTANCE)abInBuffer)->InstanceIndex = rand()%100;
        ((PWNODE_SINGLE_INSTANCE)abInBuffer)->DataBlockOffset = rand()%100;
        ((PWNODE_SINGLE_INSTANCE)abInBuffer)->SizeDataBlock = rand()%1000;
		
		break;

	case IOCTL_WMI_EXECUTE_METHOD:
		SetRandomWnodeHeader(&((PWNODE_METHOD_ITEM)abInBuffer)->WnodeHeader);
        ((PWNODE_METHOD_ITEM)abInBuffer)->OffsetInstanceName = rand()%100;
        ((PWNODE_METHOD_ITEM)abInBuffer)->InstanceIndex = rand()%100;
        ((PWNODE_METHOD_ITEM)abInBuffer)->MethodId = rand()%100;
        ((PWNODE_METHOD_ITEM)abInBuffer)->DataBlockOffset = rand()%100;
        ((PWNODE_METHOD_ITEM)abInBuffer)->SizeDataBlock = rand()%1000;

		break;

	case IOCTL_WMI_TRANSLATE_FILE_HANDLE:
		dwInBuff = rand()%10 ? FIELD_OFFSET(WMIFHTOINSTANCENAME, InstanceNameBase) : rand()%100;
		break;

	case IOCTL_WMI_GET_VERSION:
		SetOutParam(abOutBuffer, dwOutBuff, sizeof(WMIVERSIONINFO));
		break;

	case IOCTL_WMI_START_LOGGER:
	case IOCTL_WMI_STOP_LOGGER:
	case IOCTL_WMI_QUERY_LOGGER:
	case IOCTL_WMI_UPDATE_LOGGER:
		SetOutParam(abOutBuffer, dwOutBuff, (1+rand()%10)*sizeof(WMICHECKGUIDACCESS));
		dwInBuff = rand()%10 ? (1+rand()%10)*sizeof(WMICHECKGUIDACCESS) : rand()%100;
		break;

	case IOCTL_WMI_TRACE_EVENT:
		dwInBuff = rand()%10 ? (1+rand()%10)*sizeof(WNODE_HEADER) : rand()%100;
		break;


	default: 
		CIoctl::PrepareIOCTLParams(dwIOCTL, abInBuffer, dwInBuff, abOutBuffer, dwOutBuff);
	}
    
}



void CIoctlWmiDataDevice::CallRandomWin32API(LPOVERLAPPED pOL)
{
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\dtm\dispatchperformer\dllmaintmplt.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    DllMainTmplt.cpp

Abstract:

    Template DLL main module, including the performer and terminator functions
    needed by the DTM agent.
    Although it's a template, I reccommend to use this file as is, and implemet
    all the other exports in other files.

    You may wish to change DllMain() to call DisableThreadLibraryCalls()
    on DLL_PROCESS_ATTACH.

Author:

    Micky Snir (MickyS) 13-Apr-1999

--*/
#include <windows.h>
#include <stdio.h>
#include "..\DispatchPerformer\DispatchPerformer.h"

//
// needed for passing it into the DispathPerformer DLL, so that it will be able
// to GetProcAddress() this DLLs exports
//
static HINSTANCE s_hThisDll = NULL;

extern "C"
{

DLL_EXPORT  
long _cdecl 
performer(
    long        task_id,
    long        action_id,
    const char  *szCommandLine,
    char        *outvars,
    char        *szReturnError
    )

/*++

Function Description:

    This is the required function by the DTM agent.

Parameters:

   task_id - Task number, a unique number that is assigned to each execution 
     of a DTM program

   action_id - A number that is assigned to each execution line in a DTM
     program.
   
   szCommandLine - A string of parameters that is passed to the DLL from the 
       DTM script.

Return value:

    DTM_TASK_STATUS_SUCCESS - if expected success matches the raw success.
    
    DTM_TASK_STATUS_WARNING - if there was an error, but you want the script to
      continue running.
    
    DTM_TASK_STATUS_FAILED - if expected success does not matche the raw 
      success or a parsing error or an exception occurred.

--*/

{
    return DispatchPerformer(
            s_hThisDll,
            task_id,
            action_id,
            szCommandLine,
            outvars,
            szReturnError
            );
}


DLL_EXPORT  
long _cdecl 
terminate(
	long		task_id,
	long		action_id,
	const char* params,
	char        *outvars,
	char        *szReturnError
     )

/*++

Function Description:

     terminate is called when an error occured and the script should abort. The performer() function
     is running at the same time in another thread, it is up to the DLL to abort the performer.
     NOTE: We discourage you no to use the TerminateThread API for stopping the performer function
           because you may halt the entire DTM agent.

Parameters:

   same as performer

Return value:

    same as performer

--*/

{
    return DispatchTerminate(
            s_hThisDll,
            task_id,
            action_id,
            params,
            outvars,
            szReturnError
            );
}



BOOL WINAPI 
DllMain(
    HINSTANCE hDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )

/*++

    FUNCTION:    DllMain
    
    INPUTS:      hDLL       - handle of DLL
                 dwReason   - indicates why DLL called
                 lpReserved - reserved
                 Note that the return value is used only when
                 dwReason = DLL_PROCESS_ATTACH.
                 Normally the function would return TRUE if DLL initial-
                 ization succeeded, or FALSE it it failed.

--*/

{
	UNREFERENCED_PARAMETER(lpReserved);

	switch (dwReason)
	{
	case DLL_PROCESS_ATTACH:
		s_hThisDll = hDLL;

		//
		// DLL is attaching to the address space of the current process.
		//
        //DisableThreadLibraryCalls(s_hThisDll);
	  break;

	case DLL_THREAD_ATTACH:
		//
		// A new thread is being created in the current process.
		//
		break;

	case DLL_THREAD_DETACH:
		//
		// A thread is exiting cleanly.
		//

		break;
	case DLL_PROCESS_DETACH:
		//
		// The calling process is detaching the DLL from its address space.
		//

		break;

	default:
		return FALSE;
	}//switch (dwReason)
    
	return TRUE;
}



}//extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\dtm\dispatchperformer\dispatchperformer.h ===
#ifndef __DISPATCH_PERFORMER_H
#define __DISPATCH_PERFORMER_H

//
// exact copies from the old DTM header
// I do not use all of them, but I may want to in the future.
//
const long DTM_TASK_STATUS_LOADING = 1;
const long DTM_TASK_STATUS_RUNNING = 2;
const long DTM_TASK_STATUS_SUCCESS = 3;
const long DTM_TASK_STATUS_WARNING = 4;
const long DTM_TASK_STATUS_FAILED = 5;
const long DTM_TASK_STATUS_RT_FAILED = 6;
const long DTM_TASK_STATUS_KILLED = 7;
const long DTM_TASK_STATUS_LAST = 8;


//INVALID_EXPECTED_SUCCESS must equal the error return of atoi() !!!
#define nINVALID_EXPECTED_SUCCESS    (0)
#define nEXPECT_DONT_CARE            (2)
#define nEXPECT_SUCCESS              (1)
#define nEXPECT_FAILURE              (-1)

#define MAX_RETURN_STRING_LENGTH (1024)

//
// max length of the fuction name that appears inside the szCommandLine string
// parameter of the performer function
//
#define nMAX_FUNCTION_NAME (64)


#define DLL_EXPORT _declspec(dllexport)
#define DLL_IMPORT _declspec(dllimport)

#ifdef __EXPORT_DISPATCH_PERFORMER
#define DISPATCH_PERFORMER_METHOD DLL_EXPORT
#else
#define DISPATCH_PERFORMER_METHOD DLL_IMPORT
#endif //__EXPORT_DISPATCH_PERFORMER

//
// this is the needed type of the functions exported by the DLL
// that uses of this DLL
//
typedef BOOL (*DISPATCHED_FUNCTION)( char*, char*, char*);


#ifdef __cplusplus
extern "C"
{
#endif

DISPATCH_PERFORMER_METHOD  
long _cdecl 
DispatchPerformer(
    HINSTANCE   hPerformerDll,
    long        task_id,
    long        action_id,
    const char  *szCommandLine,
    char        *outvars,
    char        *szReturnError
    );

DISPATCH_PERFORMER_METHOD  
long _cdecl 
DispatchTerminate(
    HINSTANCE   hPerformerDll,
    long        task_id,
    long        action_id,
    const char  *szCommandLine,
    char        *outvars,
    char        *szReturnError
    );

DISPATCH_PERFORMER_METHOD  
BOOL 
DispSetTerminateTimeout(
    char * szCommand,
    char *szOut,
    char *szErr
    );

DISPATCH_PERFORMER_METHOD  
BOOL  
DispGetConcurrentActionCount(
    const char  *szParams,
    char        *szReturnValue,
    char        *szReturnError
    );

DISPATCH_PERFORMER_METHOD  
void
SafeSprintf(
    size_t nToModifyMaxLen,
    char *szToModify,
    const char *szFormatString,
    ...
    );

#ifdef __cplusplus
} //of extern "C"
#endif

#endif //__DISPATCH_PERFORMER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\dtm\snifftest\internaltest.cpp ===
#include <windows.h>

#include "..\DispatchPerformer\DispatchPerformer.h"


extern "C"
{



////////////////////////////////////////////////////////////////////////
// next 4 functions are for testing purposes, please leave them be
////////////////////////////////////////////////////////////////////////
DLL_EXPORT  
BOOL
xxx(char *in, char *out, char *err)
{
    SafeSprintf(
        MAX_RETURN_STRING_LENGTH,
        out,
        "%s, xxx() out: %s",
        out, 
        in
        );
    
    SafeSprintf(
        MAX_RETURN_STRING_LENGTH,
        err,
        "%s, xxx() out: %s",
        err, 
        in
        );
    
        return TRUE;
}

DLL_EXPORT  
BOOL
yyy(char *in, char *out, char *err)
{
    SafeSprintf(
        MAX_RETURN_STRING_LENGTH,
        out,
        "%s, yyy() out: %s",
        out, 
        in
        );
    
    SafeSprintf(
        MAX_RETURN_STRING_LENGTH,
        err,
        "%s, yyy() out: %s",
        err, 
        in
        );
    
        return FALSE;
}

DLL_EXPORT  
BOOL
zzz(char *in, char *out, char *err)
{
    SafeSprintf(
        MAX_RETURN_STRING_LENGTH,
        out,
        "%s, zzz() out: %s",
        out, 
        in
        );
    
    SafeSprintf(
        MAX_RETURN_STRING_LENGTH,
        err,
        "%s, zzz() out: %s",
        err, 
        in
        );
    
        return TRUE;
}


DLL_EXPORT  
BOOL 
SetTerminateTimeout(
    char * szCommand,
    char *szOut,
    char *szErr
    )
{
    return DispSetTerminateTimeout(szCommand, szOut, szErr);
}


////////////////////////////////////////////////////////////////////////
// END OF: next 4 functions are for testing purposes, please leave them be
////////////////////////////////////////////////////////////////////////


}//extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\dtm\dispatchperformer\dispatchperformer.cpp ===
/*
    This module is a wrapper DLL that helps writing DTM - performer DLLs.
    It implements some utility functions, but mostly it implements the
    functionality of the performer() and terminate() functions.
    An example of usage of this DLL is the SniffTest DLL.

    A DTM performer DLL will want to use this DLL if it wants to export only 
    functions like this:
        typedef BOOL (*DISPATCHED_FUNCTION)( char*, char*, char*);
    where the params are the command, return string and return error of the 
    performer() interface, and the format of the command is:
    <expected success> <time to sleep before executing> <function name>
    note that:
    - <expected success> values are defined in "DispatchPerformer.h"
    - <time to sleep before executing> is in milliseconds
    - <function name> is the name of the exported function of type DISPATCHED_FUNCTION

*/

#include <windows.h>
#include <crtdbg.h>
#include <stdio.h>



#define __EXPORT_DISPATCH_PERFORMER
#include "DispatchPerformer.h"

//
// counts the number of performer threads currently running.
// I need it in order to know if threads that I don't know of
// are still running.
//
static long s_lConcurrentActionCount = 0;

static DWORD s_dwTerminateTimeout = (60*1000);

///////////////////////////////////////////////////
// static methods declarations
///////////////////////////////////////////////////
BOOL 
_GetNextTokenAndTheRestOfParams(
    const char * szCommand,
    char *szNextToken,
    int nTokenMaxLen,
    char ** pt_szRestOfParams
    );

BOOL
_GetPerformerCount(
    const char  *szParams,
    char        *szReturnValue,
    char        *szReturnError
    );

void _IncrementActionCount();
void _DecrementActionCount();

long _WaitForActionCountToDropToZero(DWORD dwTimeout);

DWORD _GetDiffTickCount(DWORD dwPreviousTickCount);

#define SET_STRING_TO_EMPTY(sz) sz[0] = '\0';

extern "C"
{

///////////////////////////////////////////////////
// 
///////////////////////////////////////////////////
/*
    Parameters: same as performer, but also the handle to the performer DLL.
    This function parses the command to 
    <expected success> <time to sleep before executing> <function name> <rest params>
    sleeps accordingly, gets the proc address of <function name> and calls it.
    according to <expected success> and the result of the call, 
    a DTM_TASK_STATUS_XXX is returned
*/
DLL_EXPORT
long _cdecl 
DispatchPerformer(
    HINSTANCE   hPerformerDll,
    long        task_id,
    long        action_id,
    const char  *szCommandLine,
    char        *outvars,
    char        *szReturnError
    )
{
    DWORD dwFirstTickCount = GetTickCount();
    char szTimeToSleepBeforeExecutingTheAction[16];
    int nTimeToSleepBeforeExecutingTheAction;
    char szFunctionName[nMAX_FUNCTION_NAME] = "";
    char *szParams;
    char *szRestOfCommandLine;
    char szExpectedSuccess[16];
    int nExpectedSuccess = nEXPECT_SUCCESS;
    BOOL fDispatchedFunctionRetval = TRUE;
    long lRealSuccess = DTM_TASK_STATUS_SUCCESS;
    long lRetval = DTM_TASK_STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(task_id);
	UNREFERENCED_PARAMETER(action_id);

    _try 
    {
        //
        // count the number of concurrent performer threads.
        // must be decremented when we leave this function
        //
        _IncrementActionCount();

        SET_STRING_TO_EMPTY(outvars);
        SET_STRING_TO_EMPTY(szReturnError);

        //
        // szCommandLine always starts with the expected success of the function.
        // so get it.
        //
        if (!_GetNextTokenAndTheRestOfParams
                (
                szCommandLine,
                szExpectedSuccess,
                sizeof(szExpectedSuccess),
                &szRestOfCommandLine
                ))
        {
	        SafeSprintf(
                MAX_RETURN_STRING_LENGTH,
                szReturnError,
                "%s. performer(%s): nExpectedSuccess not found! ",
                szReturnError,
                szCommandLine
                );
            lRealSuccess = DTM_TASK_STATUS_FAILED;
            goto out;
        }

        nExpectedSuccess = atoi(szExpectedSuccess);

        //
        // check validity of nExpectedSuccess 
        //
        if (nExpectedSuccess == nINVALID_EXPECTED_SUCCESS)
        {
	        SafeSprintf(
                MAX_RETURN_STRING_LENGTH,
                szReturnError,
                "%s. performer(%s): illegal successExpected value! ",
                szReturnError,
                szCommandLine
                );
            lRealSuccess = DTM_TASK_STATUS_FAILED;
            goto out;
        }

        //
        // now get the time to sleep before executing the action
        //
        if (!_GetNextTokenAndTheRestOfParams
                (
                (const char*)szRestOfCommandLine,
                szTimeToSleepBeforeExecutingTheAction,
                sizeof(szTimeToSleepBeforeExecutingTheAction),
                &szRestOfCommandLine
                ))
        {
	        SafeSprintf(
                MAX_RETURN_STRING_LENGTH,
                szReturnError,
                "%s. performer(%s): nTimeToSleepBeforeExecutingTheAction not found! ",
                szReturnError,
                szCommandLine
                );
            lRealSuccess = DTM_TASK_STATUS_FAILED;
            goto out;
        }

        nTimeToSleepBeforeExecutingTheAction = atoi(szTimeToSleepBeforeExecutingTheAction);

        //
        // now get the function to be call, and it's parameters.
        //
        if (!_GetNextTokenAndTheRestOfParams
                (
                (const char*)szRestOfCommandLine,
                szFunctionName,
                sizeof(szFunctionName),
                &szParams
                ))
        {
	        SafeSprintf(
                MAX_RETURN_STRING_LENGTH,
                szReturnError,
                "%s. performer(%s): function not found! ",
                szReturnError,
                szCommandLine
                );
            lRealSuccess = DTM_TASK_STATUS_FAILED;
            goto out;
        }

        //
        // find the function and call it.
        // if not found, fail.
        //

        DISPATCHED_FUNCTION fnPerformerFunction = (DISPATCHED_FUNCTION)GetProcAddress(hPerformerDll, szFunctionName);
        if (NULL != fnPerformerFunction)
        {
            //
            // Sleep(nTimeToSleepBeforeExecutingTheAction(==0) is a bad idea because it may take several milli!
            //
            if (nTimeToSleepBeforeExecutingTheAction != 0)
            {
                Sleep(nTimeToSleepBeforeExecutingTheAction);
            }

            fDispatchedFunctionRetval = fnPerformerFunction(szParams, outvars, szReturnError);

            SafeSprintf(
                MAX_RETURN_STRING_LENGTH,
                outvars,
                "%s, took %u msecs",
                outvars,
                _GetDiffTickCount(dwFirstTickCount)
                );
        }
        else
        {
	        SafeSprintf(
                MAX_RETURN_STRING_LENGTH,
                szReturnError,
                "%s. performer(%s): unknown function description<%s>!",
                szReturnError,
                szCommandLine,
                szFunctionName
                );
            lRealSuccess = DTM_TASK_STATUS_FAILED;
            goto out;
        }

    }//_try
    _except (1)
    {
	    SafeSprintf(
            MAX_RETURN_STRING_LENGTH,
            szReturnError,
            "%s. performer(%s): Exception(0x%08X)!",
            szReturnError,
            szCommandLine,
            GetExceptionCode()
            );
	    //ControlledMessageBox(NULL,szReturnError, "DtmScale.dll",MB_OK);
        lRealSuccess = DTM_TASK_STATUS_FAILED;
    }

out:

    //
    // now we have to decide what return value will be returned
    // according to lRealSuccess, fDispatchedFunctionRetval (returned from the function call)
    // and nExpectedSuccess
    //

    if (lRealSuccess == DTM_TASK_STATUS_FAILED)
    {
        //
        // a major error occurred (parsing failed, etc.)
        // so we don't even care if we extected to fail
        // fail anyway.
        //
        lRetval = DTM_TASK_STATUS_FAILED;
        goto ret;
    }


    if ((nExpectedSuccess == nEXPECT_DONT_CARE))
    {
        //
        // no unexpected error, so we always succeed
        //
        lRetval = DTM_TASK_STATUS_SUCCESS;
        goto ret;
    }

    if ((fDispatchedFunctionRetval == TRUE) && (nExpectedSuccess == nEXPECT_FAILURE))
    {
        //
        // we expected to fail, but succeeded
        //
        lRetval = DTM_TASK_STATUS_FAILED;
        goto ret;
    }

    if ((fDispatchedFunctionRetval == FALSE) && (nExpectedSuccess == nEXPECT_SUCCESS))
    {
        //
        // we expected to succeed, but failed
        //
        lRetval = DTM_TASK_STATUS_FAILED;
        goto ret;
    }

    //
    // we got what we expected
    //
    lRetval = DTM_TASK_STATUS_SUCCESS;

ret:

    _DecrementActionCount();

	return lRetval;
}


DLL_EXPORT  
BOOL 
DispSetTerminateTimeout(
    char * szCommand,
    char *szOut,
    char *szErr
    )
{
    DWORD dwWantedTerminateTimeout;

    dwWantedTerminateTimeout = atoi(szCommand);
    if (0 >= (int)dwWantedTerminateTimeout)
    {
	    SafeSprintf(
            MAX_RETURN_STRING_LENGTH,
            szErr,
            "%s. illegal TerminateTimeout value - %d. Must be greater than 0.",
            szErr,
            dwWantedTerminateTimeout
            );
        return FALSE;
    }

    s_dwTerminateTimeout = dwWantedTerminateTimeout;
    return TRUE;
}


DLL_EXPORT
long _cdecl 
DispatchTerminate(
    HINSTANCE   hPerformerDll,
    long        task_id,
    long        action_id,
    const char  *szCommandLine,
    char        *outvars,
    char        *szReturnError
    )
{
	UNREFERENCED_PARAMETER(task_id);
	UNREFERENCED_PARAMETER(action_id);
	UNREFERENCED_PARAMETER(szCommandLine);

	return _WaitForActionCountToDropToZero(s_dwTerminateTimeout);
}

} //of extern "C"

///////////////////////////////////////////////////
// static methods implementations
///////////////////////////////////////////////////
static
void _IncrementActionCount()
{
    InterlockedIncrement(&s_lConcurrentActionCount);
}
static
void _DecrementActionCount()
{
    long l = InterlockedDecrement(&s_lConcurrentActionCount);
    _ASSERTE(l >= 0);
}

//
// will wait at least (!!!) dwTimeout milliseconds
// I try to be a little smart here, by polling seconds, then tenth...
//
static
long _WaitForActionCountToDropToZero(DWORD dwTimeout)
{
    DWORD dwSeconds = dwTimeout/1000;
    DWORD dwTenthSeconds = (dwTimeout - dwSeconds*1000)/100;
    DWORD dwHundredthSeconds = (dwTimeout - dwSeconds*1000 - dwTenthSeconds*100)/10;
    DWORD dwMilliSeconds = (dwTimeout - dwSeconds*1000 - dwTenthSeconds*100 - dwHundredthSeconds*10);

    while(dwSeconds--)
    {
        if (0 == s_lConcurrentActionCount)
        {
            return DTM_TASK_STATUS_SUCCESS;
        }
        Sleep(1000);
    }
    
    while(dwTenthSeconds--)
    {
        if (0 == s_lConcurrentActionCount)
        {
            return DTM_TASK_STATUS_SUCCESS;
        }
        Sleep(100);
    }
    
    while(dwHundredthSeconds--)
    {
        if (0 == s_lConcurrentActionCount)
        {
            return DTM_TASK_STATUS_SUCCESS;
        }
        Sleep(10);
    }
    
    while(dwMilliSeconds--)
    {
        if (0 == s_lConcurrentActionCount)
        {
            return DTM_TASK_STATUS_SUCCESS;
        }
        Sleep(1);
    }
    
    if (0 == s_lConcurrentActionCount)
    {
        return DTM_TASK_STATUS_SUCCESS;
    }
    else
    {
        return DTM_TASK_STATUS_FAILED;
    }
}

DISPATCH_PERFORMER_METHOD  
BOOL  
DispGetConcurrentActionCount(
    const char  *szParams,
    char        *szReturnValue,
    char        *szReturnError
    )

/*++

Function Description:

     This function returns the number of perfomer threads.

Parameters:
    szReturnError (output): a string stating the number of performers.

    szParams - not used

    szReturnValue - not used

--*/

{
    UNREFERENCED_PARAMETER(szParams);
    UNREFERENCED_PARAMETER(szReturnValue);

    SafeSprintf(
        MAX_RETURN_STRING_LENGTH,
        szReturnValue,
        "%s. Performer Count: %d",
        szReturnValue,
        s_lConcurrentActionCount
        );

    return TRUE;
}

DISPATCH_PERFORMER_METHOD  
void
SafeSprintf(
    size_t nToModifyMaxLen,
    char *szToModify,
    const char *szFormatString,
    ...
    )

/*++

Function Description:

    performs sprintf in a safer way.
    the modified string is never overflowed.
    In case of a safe overflow, put "@..." at the end of the string.

Parameters:

    nToModifyMaxLen (input) : szToModify's len.

    szToModify (input/output) : string to sprintf into.

    szFormatString (input) : format string.

Return value:

    none.
    
--*/

{
    va_list args;

    _ASSERTE(strlen(szToModify) <= (size_t)nToModifyMaxLen);

    //
    // format the big string.
    //
    va_start(args, szFormatString);
    if (-1 == _vsnprintf(szToModify,nToModifyMaxLen-1,szFormatString,args))
    {
        //
        // oveflow - mark with @...
        //
        strcpy(&szToModify[nToModifyMaxLen-5], "@...");
        szToModify[nToModifyMaxLen-1] = '\0';
    }
    va_end(args);
}


static
BOOL 
_GetNextTokenAndTheRestOfParams(
    const char * szCommand,
    char * szNextToken,
    int nTokenMaxLen,
    char ** pt_szRestOfParams
    )

/*++

Function Description:

     This function is used to extract the function name from the param
     parameter of the performer, after the expected success was extracted.
     copies the 1st token from szCommand to szNextToken and makes
     *pt_szRestOfParams point to the rest of szCommand.
     szNextToken is already allocated.
     pt_szRestOfParams is only a pointer into szCommand.

Parameters:

  szCommand (input): includes a function name and optional parameters after it.
    e.g. "DoSomething Param1 Param2"

  szNextToken (output): copies the 1st token from szCommand is copied into
    szNextToken

  pt_szRestOfParams (output): points right after the function name.
Return value:

    TRUE if the 1st token is found.
    FALSE if not.

--*/

{
    int charIter;

    //
    // ignore leading spaces before function name
    //
    while(*szCommand == ' ') szCommand++;

    //
    // copy 1st token untill the space/terminator.
    //
    charIter = 0;
    while((szCommand[charIter] != ' ') &&
          (szCommand[charIter] != '\0'))
    {
        szNextToken[charIter] = szCommand[charIter];
        charIter++;
        if (charIter >= nTokenMaxLen)
        {
            return FALSE;
        }
    }

    if (charIter == 0)
    {
        //
        // no function name was found
        //
        return FALSE;
    }

    _ASSERTE((charIter < nTokenMaxLen) && (charIter > 0));
    //
    // terminate the string
    //
    szNextToken[charIter] = '\0';

    //
    // set szCommand to point to space/terminator after function name
    //
    szCommand += charIter;

    //
    // ignore leading spaces before function parameters
    //
    while(*szCommand == ' ') szCommand++;

    *pt_szRestOfParams = (char *)szCommand;

    return TRUE;
}



DWORD _GetDiffTickCount(DWORD dwPreviousTickCount)
{
    DWORD dwCurrentTickCount = GetTickCount();
    if (dwCurrentTickCount < dwPreviousTickCount)
    {
        return (0xFFFFFFFF - dwPreviousTickCount + 1 + dwCurrentTickCount);
    }
    else
    {
        return (dwCurrentTickCount - dwPreviousTickCount);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\dtm\dispatchperformer\test\main.c ===
#include <windows.h>
#include <stdio.h>
#include <crtdbg.h>
#include "..\DispatchPerformer.h"

typedef long (*PERFORMER_FUNCTION)( long, long, const char  *, char*, char*);

/*
#define nINVALID_EXPECTED_SUCCESS    (0)
#define nEXPECT_DONT_CARE            (2)
#define nEXPECT_SUCCESS              (1)
#define nEXPECT_FAILURE              (-1)
*/
int main()
{
    long l;
    char out[MAX_RETURN_STRING_LENGTH];
    char err[MAX_RETURN_STRING_LENGTH];
    HMODULE hSniffTest = LoadLibrary("SniffTest.dll");
    PERFORMER_FUNCTION fnPerformer = (PERFORMER_FUNCTION)GetProcAddress(hSniffTest, "performer");
    PERFORMER_FUNCTION fnTerminate = (PERFORMER_FUNCTION)GetProcAddress(hSniffTest, "terminate");
    _ASSERTE(hSniffTest);
    _ASSERTE(fnPerformer);
    _ASSERTE(fnTerminate);

    l = fnPerformer(1,1,"1 1000 xxx", out, err);
    if (DTM_TASK_STATUS_SUCCESS != l)
    {
        printf("ERROR: the call \"1 1000 xxx\" retunred %d instead DTM_TASK_STATUS_SUCCESS(%d)\n", l, DTM_TASK_STATUS_SUCCESS);
        printf("  out=%s\n", out);
        printf("  err=%s\n", err);
    }
    else
    {
        printf("the call \"1 1000 xxx\" retunred DTM_TASK_STATUS_SUCCESS as expected\n");
        printf("  out=%s\n", out);
        printf("  err=%s\n", err);
    }

    l = fnPerformer(1,1,"1 5000 yyy", out, err);
    if (DTM_TASK_STATUS_FAILED != l)
    {
        printf("ERROR: the call \"1 5000 yyy\" retunred %d instead DTM_TASK_STATUS_FAILED(%d)\n", l, DTM_TASK_STATUS_FAILED);
        printf("  out=%s\n", out);
        printf("  err=%s\n", err);
    }
    else
    {
        printf("the call \"1 5000 yyy\" retunred DTM_TASK_STATUS_FAILED as expected\n");
        printf("  out=%s\n", out);
        printf("  err=%s\n", err);
    }

    l = fnPerformer(1,1,"-1 9999  zzz", out, err);
    if (DTM_TASK_STATUS_FAILED != l)
    {
        printf("ERROR: the call \"-1 9999 zzz\" retunred %d instead DTM_TASK_STATUS_FAILED(%d)\n", l, DTM_TASK_STATUS_FAILED);
        printf("  out=%s\n", out);
        printf("  err=%s\n", err);
    }
    else
    {
        printf("the call \"-1 9999 zzz\" retunred DTM_TASK_STATUS_SUCCESS as expected\n");
        printf("  out=%s\n", out);
        printf("  err=%s\n", err);
    }

    //
    // without params, so we expect failure
    //
    l = fnPerformer(1,1,"1 0  SetTerminateTimeout", out, err);
    if (DTM_TASK_STATUS_FAILED != l)
    {
        printf("ERROR: the call \"1 9999 SetTerminateTimeout\" retunred %d instead DTM_TASK_STATUS_FAILED(%d)\n", l, DTM_TASK_STATUS_FAILED);
        printf("  out=%s\n", out);
        printf("  err=%s\n", err);
    }
    else
    {
        printf("the call \"1 9999 SetTerminateTimeout\" retunred DTM_TASK_STATUS_FAILED as expected\n");
        printf("  out=%s\n", out);
        printf("  err=%s\n", err);
    }

    //
    // 0 param is illegal, so we expect failure
    //
    l = fnPerformer(1,1,"1 0  SetTerminateTimeout 0", out, err);
    if (DTM_TASK_STATUS_FAILED != l)
    {
        printf("ERROR: the call \"1 9999 SetTerminateTimeout 0\" retunred %d instead DTM_TASK_STATUS_FAILED(%d)\n", l, DTM_TASK_STATUS_FAILED);
        printf("  out=%s\n", out);
        printf("  err=%s\n", err);
    }
    else
    {
        printf("the call \"1 9999 SetTerminateTimeout 0\" retunred DTM_TASK_STATUS_FAILED as expected\n");
        printf("  out=%s\n", out);
        printf("  err=%s\n", err);
    }

    l = fnPerformer(1,1,"1 0  SetTerminateTimeout 12345", out, err);
    if (DTM_TASK_STATUS_SUCCESS != l)
    {
        printf("ERROR: the call \"1 9999 SetTerminateTimeout 12345\" retunred %d instead DTM_TASK_STATUS_SUCCESS(%d)\n", l, DTM_TASK_STATUS_SUCCESS);
        printf("  out=%s\n", out);
        printf("  err=%s\n", err);
    }
    else
    {
        printf("the call \"1 9999 SetTerminateTimeout 12345\" retunred DTM_TASK_STATUS_SUCCESS as expected\n");
        printf("  out=%s\n", out);
        printf("  err=%s\n", err);
    }

    l = fnTerminate(1,1,"1 0  SetTerminateTimeout 12345", out, err);
    if (DTM_TASK_STATUS_SUCCESS != l)
    {
        printf("ERROR: the call \"1 9999 SetTerminateTimeout 12345\" retunred %d instead DTM_TASK_STATUS_SUCCESS(%d)\n", l, DTM_TASK_STATUS_SUCCESS);
        printf("  out=%s\n", out);
        printf("  err=%s\n", err);
    }
    else
    {
        printf("the call \"1 9999 SetTerminateTimeout 12345\" retunred DTM_TASK_STATUS_SUCCESS as expected\n");
        printf("  out=%s\n", out);
        printf("  err=%s\n", err);
    }



    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\faxclntbvt\bvt.h ===
//
//
// Filename:	bvt.h
// Author:		Sigalit Bar (sigalitb)
// Date:		30-Dec-98
//
//

#ifndef _BVT_H_
#define _BVT_H_

#include <windows.h>
#include "winfax.h"
#include <TCHAR.H>
#include "crtdbg.h"

#include "..\Log\log.h"
#include "..\VerifyTiffFiles\dirtiffcmp.h"


#ifdef __cplusplus
extern "C" {
#endif

#define BVT_DOC_FILE	TEXT("file.doc")
#define BVT_XLS_FILE	TEXT("file.xls")
#define BVT_PPT_FILE	TEXT("file.ppt")

#define BVT_ARCHIVE_DIR TEXT("C:\\CometBVT\\FaxBVT\\Faxes\\SentFaxes")
#define BVT_REMOTE_ARCHIVE_DIR TEXT("rootc\\CometBVT\\FaxBVT\\Faxes\\SentFaxes")
#define DEFAULT_REFFERENCE_DIR  TEXT("C:\\CometBVT\\FaxBVT\\Faxes\\Reference")
#define BVT_MIN_PORTS	2

extern LPTSTR g_szSentDir;

#define DEV_TSID	TEXT("Comet dev")
#define DEV_CSID	TEXT("Comet dev")

#define MY_FPF_NONE			0

#define MAX_LOOP_COUNT      (60*60*1000)

//
// TestSuiteSetup:
//	Initializes logger and changes the Fax server configuration
//	for the tests.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber1	IN parameter
//					Phone number of first device installed on server.
//					Will be set up as sending device.
//
//	szFaxNumber2	IN parameter
//					Phone number of second device installed on server.
//					Will be set up as receiving device.
//
//	szDocument		IN parameter
//					Filename of document to be used in tests.
//					The function only prints this string to logger (for debugging).
//
//	szCoverPage		IN parameter
//					Filename of cover page to be used in tests.
//					The function only prints this string to logger (for debugging).
//
//	szReceiveDir	IN parameter
//					Name of "received faxes" directory to be used in tests.
//					The function only prints this string to logger (for debugging).
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestSuiteSetup(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber1,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage,
	LPCTSTR		/* IN */	szReceiveDir
);

//
// TestCase1:
//	Send a fax + CP.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber2	IN parameter
//					Phone number to send fax to.
//
//	szDocument		IN parameter
//					Filename of document to send.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase1(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
);

//
// TestCase2:
//	Send just a CP.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber2	IN parameter
//					Phone number to send fax to.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase2(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szCoverPage
);

//
// TestCase3:
//	Send a fax with no CP.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber2	IN parameter
//					Phone number to send fax to.
//
//	szDocument		IN parameter
//					Filename of document to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase3(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szDocument
);

//
// TestCase4:
//	Send a broadcast (3 times the same recipient) with cover pages.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber2	IN parameter
//					Phone number to send faxes to.
//
//	szDocument		IN parameter
//					Filename of document to send.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase4(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
);

//
// TestCase5:
//	Send a broadcast of only CPs (3 times the same recipient).
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber2	IN parameter
//					Phone number to send faxes to.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase5(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szCoverPage
);

//
// TestCase6:
//	Send a broadcast without CPs (3 times the same recipient).
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber2	IN parameter
//					Phone number to send faxes to.
//
//	szDocument		IN parameter
//					Filename of document to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase6(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szDocument
);

//
// TestCase7:
//	Send a fax (*.doc file = BVT_DOC_FILE) + CP.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber2	IN parameter
//					Phone number to send fax to.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase7(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szCoverPage
);

//
// TestCase8:
//	Send a fax (*.ppt file = BVT_PPT_FILE) + CP.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber2	IN parameter
//					Phone number to send fax to.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase8(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szCoverPage
);

//
// TestCase9:
//	Send a fax (*.xls file = BVT_XLS_FILE) + CP.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber2	IN parameter
//					Phone number to send fax to.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase9(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szCoverPage
);

//
// TestCase10:
//  Compare all received faxes (*.tif files) in directory szReceiveDir 
//  with the refference (*.tif) files in szRefferenceDir
//
// Parameters:
//	szReceive           IN parameter.
//					    Name of directory at which all (BVT) received faxes are stored.
//  
//	szRefferenceDir	    IN parameter
//					    Name of directory at which all refference files are stored.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase10(
    LPTSTR     /* IN */    szReceiveDir,
    LPTSTR     /* IN */    szRefferenceDir
    );

//
// TestCase11:
//  Compare all (archived) sent faxes (*.tif files) in directory szSentDir 
//  with the refference (*.tif) files in szRefferenceDir
//
// Parameters:
//	szSentDir           IN parameter.
//					    Name of directory at which all (BVT) sent faxes are stored.
//  
//	szRefferenceDir	    IN parameter
//					    Name of directory at which all refference files are stored.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase11(
    LPTSTR     /* IN */    szSentDir,
    LPTSTR     /* IN */    szRefferenceDir
    );

//
// TestSuiteShutdown:
//	Perform test suite cleanup (close logger).
//
// Return Value:
//	TRUE if successful, FALSE otherwise.
//
BOOL WINAPIV TestSuiteShutdown(void);


#ifdef __cplusplus
}
#endif 

#endif //_BVT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\faxclntbvt\bvt.cpp ===
//
//
// Filename:	bvt.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		30-Dec-98
//
//

#include "bvt.h"

// Forward declerations:

//
// SetupPort:
//	Private module function used to set port configuration.
//  See end of file.
// 
static BOOL SetupPort(
	HANDLE			/* IN */	hFaxSvc,
	PFAX_PORT_INFO	/* IN */	pPortInfo,
	DWORD			/* IN */	dwFlags,
	LPCTSTR			/* IN */	szTsid,
	LPCTSTR			/* IN */	szCsid
	);

//
// SendRegularFax: 
//	Private module function used to send a fax
//  See end of file.
//
static BOOL SendRegularFax(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
);

//
// PollJobAndVerify: 
//	Private module function used to poll job status
//  See end of file.
//
static BOOL PollJobAndVerify(
    HANDLE /* IN */ hFaxSvc, 
    DWORD /* IN */ dwJobId
);

//
// SendBroadcastFax: 
//	Private module function used to send a broadcast (3 * same recipient)
//  See end of file.
//
static BOOL SendBroadcastFax(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
);


//
// TestSuiteSetup:
//	Initializes logger and changes the Fax server configuration
//	for the tests.
//
BOOL WINAPIV TestSuiteSetup(
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber1,
	LPCTSTR		szFaxNumber2,
	LPCTSTR		szDocument,
	LPCTSTR		szCoverPage,
    LPCTSTR     szReceiveDir
    )
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber1);
	_ASSERTE(NULL != szFaxNumber2);
	_ASSERTE(NULL != szDocument);
	_ASSERTE(NULL != szCoverPage);
	_ASSERTE(NULL != szReceiveDir);

	BOOL fRetVal = FALSE;
	HANDLE hFaxSvc = NULL;
	int nPortIndex = 0;
	DWORD dwNumFaxPorts = 0;
	PFAX_CONFIGURATION pFaxSvcConfig = NULL;
	PFAX_PORT_INFO	pFaxPortsConfig = NULL;

	//
	// Init logger
	//
	if (!::lgInitializeLogger())
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgInitializeLogger failed with GetLastError()=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	//
	// Begin test suite (logger)
	//
	if(!::lgBeginSuite(TEXT("BVT suite")))
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgBeginSuite failed with GetLastError()=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	// log command line params using elle logger
	::lgLogDetail(
		LOG_X,
		1,
		TEXT("CometBVT params:\n\tszServerName=%s\n\tszFaxNumber1=%s\n\tszFaxNumber2=%s\n\tszDocument=%s\n\tszCoverPage=%s\n\tszReceiveDir=%s\n"),
		szServerName,
		szFaxNumber1,
		szFaxNumber2,
		szDocument,
		szCoverPage,
        szReceiveDir
		);

    //
    // Setup directories
    //

    // TO DO: empty the "received faxes" dir and the "sent faxes" dir

	//
	// Setup fax service
	//
	if (!FaxConnectFaxServer(szServerName,&hFaxSvc))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\nFaxConnectFaxServer(%s) failed with GetLastError()=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			szServerName,
			::GetLastError()
			);
        goto ExitFunc;
	}

	//
	// Setup Service configuration
	//

	// Retrieve the fax service configuration
    if (!FaxGetConfiguration(hFaxSvc, &pFaxSvcConfig)) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxGetConfiguration returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }
	//check that FaxGetConfiguration allocated
	_ASSERTE(pFaxSvcConfig);

	pFaxSvcConfig->Retries = 0;
	pFaxSvcConfig->PauseServerQueue = FALSE;
	pFaxSvcConfig->ArchiveOutgoingFaxes = TRUE;
	pFaxSvcConfig->ArchiveDirectory = BVT_ARCHIVE_DIR;//TO DO: from ini file
	pFaxSvcConfig->Branding = FALSE;  //so that we'll be able to compare to reference files

    // Set our global archive dir var
    g_szSentDir = ::_tcsdup(pFaxSvcConfig->ArchiveDirectory);
    if (NULL == g_szSentDir)
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d tcsdup failed with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }

	// Set the fax service configuration
    if (!FaxSetConfiguration(hFaxSvc, pFaxSvcConfig)) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxSetConfiguration returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }

	//
	// Setup the two ports
	//

    // Retrieve the fax ports configuration
    if (!FaxEnumPorts(hFaxSvc, &pFaxPortsConfig, &dwNumFaxPorts)) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxEnumPorts returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }
	_ASSERTE(pFaxPortsConfig);

	// make sure we have at least TEST_MIN_PORTS ports for test
	if (BVT_MIN_PORTS > dwNumFaxPorts)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\n dwNumFaxPorts(=%d) < TEST_MIN_PORTS(=%d)\n"),
			TEXT(__FILE__),
			__LINE__,
			dwNumFaxPorts,
			BVT_MIN_PORTS
			);
        goto ExitFunc;
	}
	else
	{
		::lgLogDetail(
			LOG_X, 
			1,
			TEXT("FILE:%s LINE:%d\ndwNumFaxPorts=%d\nTEST_MIN_PORTS=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			dwNumFaxPorts,
			BVT_MIN_PORTS
			);
	}
	// we know there are at least 2 (==TEST_MIN_PORTS) devices

	// Set 1st device as Send only (note pFaxPortsConfig array is 0 based)
	if (FALSE == SetupPort(
					hFaxSvc, 
					&pFaxPortsConfig[0], 
					FPF_SEND, 
					szFaxNumber1, 
					szFaxNumber1
					)
		)
	{
		goto ExitFunc;
	}

	// Set 2nd device as Receive only (note pFaxPortsConfig array is 0 based)
	if (FALSE == SetupPort(
					hFaxSvc, 
					&pFaxPortsConfig[1], 
					FPF_RECEIVE, 
					szFaxNumber2, 
					szFaxNumber2
					)
		)
	{
		goto ExitFunc;
	}

	// set all other devices as Receive=No and Send=No
	// NOTE: nPortIndex is 0 based
	for (nPortIndex = 2; nPortIndex < dwNumFaxPorts; nPortIndex++)
	{
		if (FALSE == SetupPort(
						hFaxSvc, 
						&pFaxPortsConfig[nPortIndex], 
						MY_FPF_NONE, 
						DEV_TSID, 
						DEV_CSID
						)
			)
		{
			goto ExitFunc;
		}
	}

	fRetVal = TRUE;

ExitFunc:
	::FaxFreeBuffer(pFaxPortsConfig);
	::FaxFreeBuffer(pFaxSvcConfig);
	if (FALSE == ::FaxClose(hFaxSvc))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\nFaxClose returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
	}
	return(fRetVal);
}


//
// TestCase1:
//	Send a fax + CP.
//
BOOL TestCase1(
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber2,
	LPCTSTR		szDocument,
	LPCTSTR		szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber2);
	_ASSERTE(NULL != szDocument);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;

	::lgBeginCase(
		1,
		TEXT("TC#1: Send a fax + CP")
		);

	fRetVal = SendRegularFax(szServerName, szFaxNumber2, szDocument, szCoverPage);

	::lgEndCase();
	return(fRetVal);
}

//
// TestCase2:
//	Send just a CP.
//
BOOL TestCase2(	
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber2,
	LPCTSTR		szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber2);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;

	::lgBeginCase(
		1,
		TEXT("TC#2: Send just a CP")
		);

	fRetVal = SendRegularFax(szServerName, szFaxNumber2, NULL, szCoverPage);

	::lgEndCase();
	return(fRetVal);
}

//
// TestCase3:
//	Send a fax with no CP.
//
BOOL TestCase3(
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber2,
	LPCTSTR		szDocument
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber2);
	_ASSERTE(NULL != szDocument);

	BOOL fRetVal = FALSE;

	::lgBeginCase(
		1,
		TEXT("TC#3: Send a fax with no CP")
		);

	fRetVal = SendRegularFax(szServerName, szFaxNumber2, szDocument, NULL);

	::lgEndCase();
	return(fRetVal);
}

//
// TestCase4:
//	Send a broadcast (3 times the same recipient) with cover pages.
//
BOOL TestCase4(
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber2,
	LPCTSTR		szDocument,
	LPCTSTR		szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber2);
	_ASSERTE(NULL != szDocument);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;

	::lgBeginCase(
		1,
		TEXT("TC#4: Send a broadcast")
		);

    fRetVal = SendBroadcastFax(szServerName, szFaxNumber2, szDocument, szCoverPage);

	::lgEndCase();
	return(fRetVal);
}

//
// TestCase5:
//	Send a broadcast of only CPs (3 times the same recipient).
//
BOOL TestCase5(
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber2,
	LPCTSTR		szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber2);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;

	::lgBeginCase(
		1,
		TEXT("TC#5: Send a broadcast of only CPs")
		);

    fRetVal = SendBroadcastFax(szServerName, szFaxNumber2, NULL, szCoverPage);

	::lgEndCase();
	return(fRetVal);
}


//
// TestCase6:
//	Send a broadcast without CPs (3 times the same recipient).
//
BOOL TestCase6(
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber2,
	LPCTSTR		szDocument
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber2);
	_ASSERTE(NULL != szDocument);

	BOOL fRetVal = FALSE;

	::lgBeginCase(
		1,
		TEXT("TC#6: Send a broadcast without CPs")
		);

    fRetVal = SendBroadcastFax(szServerName, szFaxNumber2, szDocument, NULL);

	::lgEndCase();
	return(fRetVal);
}

//
// TestCase7:
//	Send a fax (*.doc file = BVT_DOC_FILE) + CP.
//
BOOL TestCase7(
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber2,
	LPCTSTR		szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber2);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;

	::lgBeginCase(
		1,
		TEXT("TC#7: Send a fax (*.doc file) + CP")
		);

	fRetVal = SendRegularFax(szServerName, szFaxNumber2, BVT_DOC_FILE, szCoverPage);

	::lgEndCase();
	return(fRetVal);
}

//
// TestCase8:
//	Send a fax (*.ppt file = BVT_PPT_FILE) + CP.
//
BOOL TestCase8(
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber2,
	LPCTSTR		szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber2);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;

	::lgBeginCase(
		1,
		TEXT("TC#8: Send a fax (*.ppt file) + CP")
		);

	fRetVal = SendRegularFax(szServerName, szFaxNumber2, BVT_PPT_FILE, szCoverPage);

	::lgEndCase();
	return(fRetVal);
}

//
// TestCase9:
//	Send a fax (*.xls file = BVT_XLS_FILE) + CP.
//
BOOL TestCase9(
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber2,
	LPCTSTR		szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber2);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;

	::lgBeginCase(
		1,
		TEXT("TC#9: Send a fax (*.xls file) + CP")
		);

	fRetVal = SendRegularFax(szServerName, szFaxNumber2, BVT_XLS_FILE, szCoverPage);

	::lgEndCase();
	return(fRetVal);
}

//
// TestCase10:
//  Compare all received faxes (*.tif files) in directory szDir 
//  with the refference (*.tif) files in szRefferenceDir
//
BOOL TestCase10(
    LPTSTR     /* IN */    szReceiveDir,
    LPTSTR     /* IN */    szRefferenceDir
    )
{
	_ASSERTE(NULL != szReceiveDir);
	_ASSERTE(NULL != szRefferenceDir);

	BOOL fRetVal = FALSE;

	::lgBeginCase(
		1,
		TEXT("TC#10: Compare RECEIVED Files To Refference Files")
		);

    // sleep a little - to allow for routing of last sent file.
    ::lgLogDetail(
        LOG_X,
        4,
        TEXT("Sleeping for 20 sec (to allow for routing of last received file)\n")
        );
    Sleep(20000);

    if (FALSE == DirToDirTiffCompare(szReceiveDir, szRefferenceDir, FALSE))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("DirToDirTiffCompare(%s , %s) failed\n"),
            szReceiveDir,
            szRefferenceDir
            );
        goto ExitFunc;
    }

    fRetVal = TRUE;

ExitFunc:
	::lgEndCase();
	return(fRetVal);
}

//
// TestCase11:
//  Compare all archived (sent) faxes (*.tif files) in directory szDir 
//  with the refference (*.tif) files in szRefferenceDir
//
BOOL TestCase11(
    LPTSTR     /* IN */    szServerName,
    LPTSTR     /* IN */    szRefferenceDir
    )
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szRefferenceDir);

	BOOL fRetVal = FALSE;
    LPTSTR szRemoteSentDir = NULL;
    int iLen = 0;

	::lgBeginCase(
		1,
		TEXT("TC#11: Compare (archived) SENT Files To Refference Files - with skip first line")
		);

    // Set szRemoteSentDir to the archive dir on the server
    iLen = ::_tcslen(szServerName) + ::_tcslen(BVT_REMOTE_ARCHIVE_DIR) + 3 + 1; //+3 to allow for added '\'s
    szRemoteSentDir = new TCHAR[iLen];
    if (NULL == szRemoteSentDir)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\nnew failed with error=%d\n"),
			TEXT(__FILE__),
			__LINE__,
            szRemoteSentDir,
            szRefferenceDir,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    szRemoteSentDir[iLen - 1] = NULL;

    ::_stprintf(szRemoteSentDir,TEXT("\\\\%s\\%s"),szServerName,BVT_REMOTE_ARCHIVE_DIR);
    
	_ASSERTE(iLen > ::_tcslen(szRemoteSentDir));

    // Compare archive dir to reference dir    
    if (FALSE == DirToDirTiffCompare(szRemoteSentDir, szRefferenceDir, TRUE))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\nDirToDirTiffCompare(%s , %s) failed\n"),
			TEXT(__FILE__),
			__LINE__,
            szRemoteSentDir,
            szRefferenceDir
            );
        goto ExitFunc;
    }

    fRetVal = TRUE;

ExitFunc:
	::lgEndCase();
	return(fRetVal);
}


//
// TestSuiteShutdown:
//	Perform test suite cleanup (close logger).
//
BOOL TestSuiteShutdown(void)
{
	BOOL fRetVal = TRUE;

	//
	// End test suite (logger)
	//
	if (!::lgEndSuite())
	{
		//
		//this is not possible since API always returns TRUE
		//but to be on the safe side
		//
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgEndSuite returned FALSE\n"),
			TEXT(__FILE__),
			__LINE__
			);
		fRetVal = FALSE;
	}

	//
	// Close the Logger
	//
	if (!::lgCloseLogger())
	{
		//this is not possible since API always returns TRUE
		//but to be on the safe side
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgCloseLogger returned FALSE\n"),
			TEXT(__FILE__),
			__LINE__
			);
		fRetVal = FALSE;
	}

	return(fRetVal);
}


//
// SetupPort:
//	Private module function, used to set port configuration.
// 
// Parameters:
//	hFaxSvc			IN parameter.
//					A handle to the Fax service.
//
//	pPortInfo		IN parameter.
//					A pointer to the original port configuration, as returned 
//					from a call to FaxGetPort or FaxEnumPorts.
//
//	dwFlags			IN parameter.
//					Bit flags that specify the new capabilities of the fax port.
//					See FAX_PORT_INFO for more information.
//
//	szTsid			IN parameter.
//					A string that specifies the new transmitting station identifier.
//
//	szCsid			IN parameter.
//					A string that specifies the new called station identifier.
//
// Return Value:
//	TRUE if successful, FALSE otherwise.
//
static BOOL SetupPort(
	HANDLE			/* IN */	hFaxSvc,
	PFAX_PORT_INFO	/* IN */	pPortInfo,
	DWORD			/* IN */	dwFlags,
	LPCTSTR			/* IN */	szTsid,
	LPCTSTR			/* IN */	szCsid
	)
{
	BOOL fRetVal = FALSE;
	HANDLE hPort = NULL;

	// check in params
	_ASSERTE(NULL != hFaxSvc);
	_ASSERTE(NULL != pPortInfo);
	_ASSERTE(NULL != szTsid);
	_ASSERTE(NULL != szCsid);

	// Set pPortInfo as required
	pPortInfo->Flags = dwFlags;
	pPortInfo->Tsid  = szTsid;
	pPortInfo->Csid  = szCsid;

	// get the device Id
	DWORD dwDeviceId = pPortInfo->DeviceId;

	// open the port for configuration
	if(!FaxOpenPort(hFaxSvc, dwDeviceId, PORT_OPEN_MODIFY, &hPort))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxOpenPort returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	// set the device configuration
	if(!FaxSetPort(hPort, pPortInfo))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxSetPort returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	fRetVal = TRUE;

ExitFunc:
	if (FALSE == ::FaxClose(hPort))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxClose returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
	}
	return(fRetVal);
}

//
// SendRegularFax:
//	Sends a fax.
//
// NOTE: This function is private to this module, it is not exported.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to use.
//  
//	szFaxNumber2	IN parameter
//					Phone number to send fax to.
//
//	szDocument		IN parameter
//					Filename of document to send.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
static BOOL SendRegularFax(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber);

	BOOL				fRetVal = FALSE;
	HANDLE				hFaxSvc = NULL;
    FAX_JOB_PARAM       FaxJobParams;
	FAX_COVERPAGE_INFO	CPInfo;
	PFAX_COVERPAGE_INFO	pCPInfo = NULL;
	DWORD				dwJobId = 0;
	DWORD				dwErr = 0;
    PFAX_JOB_ENTRY      pJobEntry = NULL;

	if (FALSE == ::FaxConnectFaxServer(szServerName, &hFaxSvc))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\n FaxConnectFaxServer failed with err=%d"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

    //
	// queue the send job
	//
	
	// Initialize the FAX_JOB_PARAM struct
    ZeroMemory(&FaxJobParams, sizeof(FAX_JOB_PARAM));

    // Set the FAX_JOB_PARAM struct
    FaxJobParams.SizeOfStruct = sizeof(FAX_JOB_PARAM);
    FaxJobParams.RecipientNumber = szFaxNumber;
    FaxJobParams.RecipientName = szFaxNumber;
    FaxJobParams.ScheduleAction = JSA_NOW;	//send fax immediately

	// Initialize the FAX_COVERPAGE_INFO struct
	ZeroMemory(&CPInfo, sizeof(FAX_COVERPAGE_INFO));
	if (NULL != szCoverPage)
	{
		// Set the FAX_COVERPAGE_INFO struct
		CPInfo.SizeOfStruct = sizeof(FAX_COVERPAGE_INFO);
		CPInfo.CoverPageName = szCoverPage;
		CPInfo.Note = TEXT("NOTE1\nNOTE2\nNOTE3\nNOTE4");
		CPInfo.Subject = TEXT("SUBJECT");	
        pCPInfo = &CPInfo;
	}

    if (FALSE == ::FaxSendDocument(hFaxSvc, szDocument, &FaxJobParams, pCPInfo, &dwJobId)) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\nFaxSendDocument returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
    }

    //
    // Poll the queued job status 
    //  this is because we can't use the io comp port from the client machine
    //

    if (FALSE == ::PollJobAndVerify(hFaxSvc, dwJobId))
    {
		goto ExitFunc;
    }

	fRetVal = TRUE;

ExitFunc:
	return(fRetVal);
}

BOOL PollJobAndVerify(HANDLE /* IN */ hFaxSvc, DWORD /* IN */ dwJobId)
{
    // get job repeatedly and verify its states make sense
    // should be QUEUED-DIALING-SENDING*X-COMPLETED

	_ASSERTE(NULL != hFaxSvc);

	BOOL				fRetVal = FALSE;
    PFAX_JOB_ENTRY      pJobEntry = NULL;
    DWORD               dwStatus = 0;
    DWORD               dwLastStatus = 0; //there is no such status code
    UINT                uLoopCount = 0;
    DWORD               dwErr = 0;

    fRetVal = TRUE;

    while(TRUE)
    {
        if (FALSE == ::FaxGetJob(hFaxSvc, dwJobId, &pJobEntry))
        {
            dwErr = ::GetLastError();
            //TO DO: document better
            if (((FPS_COMPLETED == dwLastStatus) || (FPS_AVAILABLE == dwLastStatus)) &&
                (ERROR_INVALID_PARAMETER == dwErr))
            {
                //this is ok, job was probably completed and was removed from queue
                fRetVal = TRUE;
                goto ExitFunc;
            }
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d\nFaxGetJob returned FALSE with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    dwErr
			    );
		    goto ExitFunc;
        }

        _ASSERTE(NULL != pJobEntry);

        dwStatus = pJobEntry->Status;

        //TO DO: better documentation
        //TO DO: log every goto ExitFunc (dwLastStatus and dwStatus)
        switch (dwStatus)
        {
        case FPS_INITIALIZING:
            if (0 == dwLastStatus)
            {
                //first time that we get FPS_INITIALIZING
	            ::lgLogDetail(
		            LOG_X,
                    1, 
		            TEXT("FILE:%s LINE:%d\n JobId %d has dwStatus=FPS_INITIALIZING\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwJobId
		            );
            }
            if ((FPS_INITIALIZING != dwLastStatus) &&
                (0 != dwLastStatus))
            {
                goto ExitFunc;
            }
            dwLastStatus = FPS_INITIALIZING;
            break;

        case FPS_DIALING:
            if ((FPS_INITIALIZING == dwLastStatus) ||
                (0 == dwLastStatus))
            {
                //first time that we get FPS_DIALING
	            ::lgLogDetail(
		            LOG_X,
                    1, 
		            TEXT("FILE:%s LINE:%d\n JobId %d has dwStatus=FPS_DIALING\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwJobId
		            );
            }
            if ((FPS_DIALING != dwLastStatus) &&
                (FPS_INITIALIZING != dwLastStatus) &&
                (0!= dwLastStatus))
            {
                goto ExitFunc;
            }
            dwLastStatus = FPS_DIALING;
            break;

        case FPS_SENDING:
            if (FPS_DIALING == dwLastStatus)
            {
                //first time that we get FPS_SENDING
	            ::lgLogDetail(
		            LOG_X,
                    1, 
		            TEXT("FILE:%s LINE:%d\n JobId %d has dwStatus=FPS_SENDING\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwJobId
		            );
            }
            if ((FPS_DIALING != dwLastStatus) &&
                (FPS_SENDING != dwLastStatus))
            {
                goto ExitFunc;
            }
            dwLastStatus = FPS_SENDING;
            break;

        case FPS_COMPLETED:
            if (FPS_SENDING == dwLastStatus)
            {
                //first time that we get FPS_COMPLETED
	            ::lgLogDetail(
		            LOG_X,
                    1, 
		            TEXT("FILE:%s LINE:%d\n JobId %d has dwStatus=FPS_COMPLETED\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwJobId
		            );
            }
            if ((FPS_SENDING != dwLastStatus) &&
                (FPS_COMPLETED != dwLastStatus))
            {
                goto ExitFunc;
            }
            dwLastStatus = FPS_COMPLETED;
            break;

        case FPS_AVAILABLE:
            if (FPS_COMPLETED == dwLastStatus)
            {
                //first time that we get FPS_AVAILABLE
	            ::lgLogDetail(
		            LOG_X,
                    1, 
		            TEXT("FILE:%s LINE:%d\n JobId %d has dwStatus=FPS_AVAILABLE\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwJobId
		            );
            }
            if ((FPS_COMPLETED != dwLastStatus) &&
                (FPS_AVAILABLE != dwLastStatus))
            {
                goto ExitFunc;
            }
            dwLastStatus = FPS_AVAILABLE;
            break;

        case 0:
            //WORKAROUND
            // since pJobEntry->Status is initialized to 0 and is set only 
            // a bit after the job state is set to JS_INPROGRESS
            if ((JS_INPROGRESS == pJobEntry->QueueStatus) ||
                (JS_PENDING == pJobEntry->QueueStatus))
            {
                //ok
                /*
	            ::lgLogDetail(
		            LOG_X,
                    9, 
		            TEXT("FILE:%s LINE:%d\n JobId %d is in state %d (dwStatus=%d)\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwJobId,
                    pJobEntry->QueueStatus,
		            dwStatus
		            );
                 */
            }
            else
            {
	            ::lgLogError(
		            LOG_SEV_1,
		            TEXT("FILE:%s LINE:%d\n JobId %d is in state %d (dwStatus=%d)\n"),
		            TEXT(__FILE__),
		            __LINE__,
                    dwJobId,
                    pJobEntry->QueueStatus,
		            dwStatus
		            );
                goto ExitFunc;
            }
            break;

        default:
	        ::lgLogError(
		        LOG_SEV_1,
		        TEXT("FILE:%s LINE:%d\n JobId %d has dwStatus=%d\n"),
		        TEXT(__FILE__),
		        __LINE__,
                dwJobId,
		        dwStatus
		        );
            goto ExitFunc;
            break;
        }

        //TO DO:
        //Sleep must be short so that we will not miss the required device status to succeed
        Sleep(1);
        // make sure we will break from while
        uLoopCount++;
        if (MAX_LOOP_COUNT < uLoopCount)
        {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d\nMAX_LOOP_COUNT > uLoopCount\n"),
			    TEXT(__FILE__),
			    __LINE__
			    );
            goto ExitFunc;
        }

    } // of while()

ExitFunc:
	return(fRetVal);
}


static BOOL SendBroadcastFax(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
)
{
    //for now NO SUPPORT
    _ASSERTE(FALSE);
    //TO DO: setlasterror
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\faxsrvrbvtpdll\suite.h ===
//
// Filename:    suite.h
// Author:      Sigalit Bar (sigalitb)
// Date:        22-Apr-99
//

#ifndef __SUITE__H__
#define __SUITE__H__


#include "..\CometBVT\bvt.h"


BOOL
MainFunc(
	INT   argc,
    TCHAR  *argvT[]
);




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\faxclntbvt\main.cpp ===
//
//
// Filename:	main.cpp
// Author:		Sigalit Bar
// Date:		30-dec-98
//
//


#include "bvt.h"

#define HELP_SWITCH_1        TEXT("/?")
#define HELP_SWITCH_2        TEXT("/H")
#define HELP_SWITCH_3        TEXT("-?")
#define HELP_SWITCH_4        TEXT("-H")

#define MAX_ARGS	7 //including exe name

#define ARGUMENT_IS_SERVER_NAME		1
#define ARGUMENT_IS_FAX_NUMBER1		2
#define ARGUMENT_IS_FAX_NUMBER2		3
#define ARGUMENT_IS_DOC				4
#define ARGUMENT_IS_CP				5
#define ARGUMENT_IS_RECEIVE_DIR		6

//
// global pointer to process heap
//
HANDLE g_hMainHeap = NULL;

//
// global pointer to sent archive dir (local on server)
//
LPTSTR g_szSentDir = NULL; //receives a value in TestSuiteSetup()


//
// UsageInfo:
//	Outputs application's proper usage and exits process.
//
void
UsageInfo(void)
{
	::_tprintf(TEXT("FaxClntBVT for Comet Fax\n\n"));
	::_tprintf(TEXT("FaxClntBVT server_name fax_number1 fax_number2 document cover_page receive_dir\n"));
	::_tprintf(TEXT("    server_name   the name of the fax server (without the \\\\)\n"));
	::_tprintf(TEXT("    fax_number1   the fax number of the 1st device on server\n"));
	::_tprintf(TEXT("    fax_number2   the fax number of the 2nd device on server\n"));
	::_tprintf(TEXT("    document      the full path of the document to send\n"));
	::_tprintf(TEXT("    cover_page    the full path to the cover page to send\n"));
	::_tprintf(TEXT("    receive_dir   the full path to the receive directory of receiving device\n"));
	::_tprintf(TEXT("\n"));
	exit(0);
}


//
// ParseCmdLineParams:
//	Parses the command line parameters, saves a copy of them,
//	and converts from MBCS to UNICODE if necessary.
//
// Parameters:
//	argc				IN parameter.
//						command line number of arguments.
//	argvA[]				IN parameter.
//						command line args (in MBCS).
//	pszServerName		OUT parameter.
//						Pointer to string to copy 1st argument to.
//						Represents the name of fax server to use.
//	pszFaxNumber1		OUT parameter.
//						Pointer to string to copy 2nd argument to.
//						Represents the fax number of 1st device on the
//						above fax server.
//	pszFaxNumber2		OUT parameter.
//						Pointer to string to copy 3rd argument to.
//						Represents the fax number of 2nd device on the
//						above fax server.
//	pszDocument			OUT parameter.
//						Pointer to string to copy 4th argument to.
//						Represents the name of document to use with tests.
//	pszCoverPage		OUT parameter.
//						Pointer to string to copy 5th argument to.
//						Represents the name of the cover page to use
//						with tests.
//
// Return Value:
//	TRUE on success and FALSE on failure.
//
//
BOOL 
ParseCmdLineParams(
	const INT	/* IN */	argc,
	CHAR *		/* IN */	argvA[],
	LPTSTR*		/* OUT */	pszServerName,
	LPTSTR*		/* OUT */	pszFaxNumber1,
	LPTSTR*		/* OUT */	pszFaxNumber2,
	LPTSTR*		/* OUT */	pszDocument,
	LPTSTR*		/* OUT */	pszCoverPage,
    LPTSTR*		/* OUT */	pszReceiveDir
    )
{
	_ASSERTE(pszServerName);
	_ASSERTE(pszDocument);
	_ASSERTE(pszFaxNumber1);
	_ASSERTE(pszFaxNumber2);
	_ASSERTE(pszCoverPage);
	_ASSERTE(pszReceiveDir);

	DWORD	dwArgLoopIndex;
	DWORD	dwArgSize;
	LPTSTR	aszParam[MAX_ARGS];

	//
	// Check number of parameters
	//
	if ( ( argc != MAX_ARGS ) && ( argc != 2 ) )  
	{
		::_tprintf(TEXT("\nInvalid invokation of BVT.exe\n\n"));
		::_tprintf(TEXT("BVT.exe Help:\n"));
		::UsageInfo(); //UsageInfo() exits process.
	}

	//
	// Initialize awcsParam[]
	//
	for (dwArgLoopIndex = 0; dwArgLoopIndex < MAX_ARGS; dwArgLoopIndex++)
	{
		aszParam[dwArgLoopIndex] = NULL;
	}

	//
	// Loop on arguments in argvA[]
	//
    for (dwArgLoopIndex = 1; dwArgLoopIndex < (DWORD) argc; dwArgLoopIndex++) 
	{
		//
        // Determine the memory required for the parameter
		//
        dwArgSize = (::lstrlenA(argvA[dwArgLoopIndex]) + 1) * sizeof(TCHAR);

		//
        // Allocate the memory for the parameter
		//
		_ASSERTE(g_hMainHeap);
        aszParam[dwArgLoopIndex] = (TCHAR*)::HeapAlloc(
			g_hMainHeap, 
			HEAP_ZERO_MEMORY, 
			dwArgSize
			);
		if(NULL == aszParam[dwArgLoopIndex])
		{
			::_tprintf(TEXT("FILE:%s LINE:%d\n HeapAlloc returned NULL\n"),
				TEXT(__FILE__),
				__LINE__
				);
			goto ExitFuncFail;
		}

		//
		// Copy content of argument from argvA[index] to new allocation
		//
#ifdef _UNICODE
		// argvA[] is a CHAR*, so it needs to be converted to a WCHAR* ifdef UNICODE
        // Convert awcsParam
		if (!::MultiByteToWideChar(
			CP_ACP, 
			0, 
			argvA[dwArgLoopIndex], 
			-1, 
			aszParam[dwArgLoopIndex], 
			(::lstrlenA(argvA[dwArgLoopIndex]) + 1) * sizeof(WCHAR))
			)
		{
			::_tprintf(
				TEXT("FILE:%s LINE:%d\n MultiByteToWideChar failed With GetLastError()=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError()
				);
			goto ExitFuncFail;
		}
#else //_MBCS
		::strcpy(aszParam[dwArgLoopIndex],argvA[dwArgLoopIndex]);
		if (strcmp(aszParam[dwArgLoopIndex],argvA[dwArgLoopIndex]))
		{
			::_tprintf(
				TEXT("FILE:%s LINE:%d\n string copy or compare failed\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError()
				);
			goto ExitFuncFail;
		}
#endif
		//
		// Check for help switch
		//
		// If this is the second argument, it may be one of several help switches defined.
		// A help switch can appear only as the second argument.
        if (2 == argc)
		{
			if (! (!::lstrcmpi(HELP_SWITCH_1, aszParam[dwArgLoopIndex])) || 
				  (!::lstrcmpi(HELP_SWITCH_2, aszParam[dwArgLoopIndex])) || 
				  (!::lstrcmpi(HELP_SWITCH_3, aszParam[dwArgLoopIndex])) || 
				  (!::lstrcmpi(HELP_SWITCH_4, aszParam[dwArgLoopIndex]))
				) 
			{
				::_tprintf(TEXT("Invalid invokation of BVT.exe\n\n"));
			}
			::UsageInfo(); //UsageInfo() exits the process.
		}

		//
		// Treat each argument accordingly
		//
		switch (dwArgLoopIndex)
		{
		case ARGUMENT_IS_SERVER_NAME:
			//server_name param
			(*pszServerName) = aszParam[dwArgLoopIndex];
			break;

		case ARGUMENT_IS_FAX_NUMBER1:
			//fax_number1 param
			(*pszFaxNumber1) = aszParam[dwArgLoopIndex];
			break;

		case ARGUMENT_IS_FAX_NUMBER2:
			//fax_number2 param
			(*pszFaxNumber2) = aszParam[dwArgLoopIndex];
			break;

		case ARGUMENT_IS_DOC:
			//document param
			(*pszDocument) = aszParam[dwArgLoopIndex];
			break;

		case ARGUMENT_IS_CP:
			//cover_page param
			(*pszCoverPage) = aszParam[dwArgLoopIndex];
			break;

        case ARGUMENT_IS_RECEIVE_DIR:
			//cover_page param
			(*pszReceiveDir) = aszParam[dwArgLoopIndex];
            break;

		default:
			_ASSERTE(FALSE);
			return FALSE;
		}// switch (dwIndex)

	}//for (dwIndex = 1; dwIndex < (DWORD) argc; dwIndex++)


	//If all is well then we do NOT free 
	//pszServerName, pszFaxNumber1, pszFaxNumber2, pszDocument and pszCoverPage,
	//since these allocations were the purpose of the function.
	return(TRUE);

ExitFuncFail:

	//
	// Free allocations
	//
	DWORD i;
	//0 to MAX_ARGS is ok, since that is aszParam array size and we NULLed all of it first
	for (i=0; i<MAX_ARGS; i++) 
	{
		if (NULL == aszParam[i]) continue;
		if (FALSE == ::HeapFree(g_hMainHeap, 0, aszParam[i]))
		{
			::_tprintf(TEXT("FILE:%s LINE:%d loop#%d\nHeapFree returned FALSE with GetLastError()=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				i,
				::GetLastError()
				);
			return(FALSE);
		}
	}

	//
	//reset OUT parameters
	//
	(*pszServerName) = NULL;
	(*pszFaxNumber1) = NULL;
	(*pszFaxNumber2) = NULL;
	(*pszDocument) = NULL;
	(*pszCoverPage) = NULL;
	(*pszReceiveDir) = NULL;

	return(FALSE);
}




//
// main body of application.
//
int __cdecl
main(
	INT   argc,
    CHAR  *argvA[]
)
{
	int nReturnValue = 1; //"default" return value is to indicate error

	LPTSTR szServerName = NULL;
	LPTSTR szFaxNumber1 = NULL;
	LPTSTR szFaxNumber2 = NULL;
	LPTSTR szDocument = NULL;
	LPTSTR szCoverPage = NULL;
	LPTSTR szReceiveDir = NULL;
    LPTSTR szRefferenceDir = DEFAULT_REFFERENCE_DIR;

	//
	// Set g_hMainHeap to process heap
	//
	g_hMainHeap = NULL;
	g_hMainHeap = ::GetProcessHeap();
	if(NULL == g_hMainHeap)
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nGetProcessHeap returned NULL with GetLastError()=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	//
	// Parse the command line
	//
	if (!::ParseCmdLineParams(
			argc,
			argvA,
			&szServerName,
			&szFaxNumber1,
			&szFaxNumber2,
			&szDocument,
			&szCoverPage,
            &szReceiveDir
			)
		)
	{
		goto ExitFunc;
	}

	//
	// "Debug" printing of the command line parameters after parsing
	//
#ifdef _DEBUG
	::_tprintf(
		TEXT("DEBUG DEBUG DEBUG\nServer=%s\nFaxNumber1=%s\nFaxNumber2=%s\nDocument=%s\nCoverPage=%s\nReceiveDir=%s\n"),
		szServerName,
		szFaxNumber1,
		szFaxNumber2,
		szDocument,
		szCoverPage,
        szReceiveDir
		);
#endif


	if (!TestSuiteSetup(
			szServerName,
			szFaxNumber1,
			szFaxNumber2,
			szDocument,
			szCoverPage,
            szReceiveDir
			)
		)
	{
		goto ExitFunc;
	}


    //Send a fax + CP
	TestCase1(			
		szServerName,
		szFaxNumber2,
		szDocument,
		szCoverPage
		);

/*  FAILS (Comet 599) */
	//Send just a CP
	TestCase2(			
		szServerName,
		szFaxNumber2,
		szCoverPage
		);


	//Send a fax with no CP
	TestCase3(			
		szServerName,
		szFaxNumber2,
		szDocument
		);

/* for now - no client broadcast support 
	//Send a broadcast (3 * same recipient)
	TestCase4(			
		szServerName,
		szFaxNumber2,
		szDocument,
		szCoverPage
		);
*/

/*  FAILS (Comet 599) - bug#???????
	//Send a broadcast of only CPs (3 * same recipient)
	TestCase5(			
		szServerName,
		szFaxNumber2,
		szCoverPage
		);
*/

/*  FAILS (Comet 599) - NTBugs bug#246133
	//Send a broadcast without CPs (3 * same recipient)
	TestCase6(			
		szServerName,
		szFaxNumber2,
		szDocument
		);
*/

	//Send a fax (*.doc file) + CP
	TestCase7(			
		szServerName,
		szFaxNumber2,
		szCoverPage
		);

	//Send a fax (*.ppt file) + CP
	TestCase8(			
		szServerName,
		szFaxNumber2,
		szCoverPage
		);

	//Send a fax (*.xls file) + CP
	TestCase9(			
		szServerName,
		szFaxNumber2,
		szCoverPage
		);

    //Compare all "received faxes" in directory szReceiveDir
    //with the files in szRefferenceDir
    TestCase10(
        szReceiveDir,
        szRefferenceDir
        );

/*  FAILS (Comet 613) - first line tiff bug??? */
    //Compare all (archived) "sent faxes" in directory szSentDir
    //with the files in szRefferenceDir
    // NOTE - TestCase11 here is DIFFERENT from server bvt TestCase11
    TestCase11(
        szServerName,
        szRefferenceDir
        );


ExitFunc:
	TestSuiteShutdown();

	// free command line params
    if (szServerName) 
	{
        HeapFree(g_hMainHeap, 0, szServerName);
    }
    if (szFaxNumber1) 
	{
        HeapFree(g_hMainHeap, 0, szFaxNumber1);
    }
    if (szFaxNumber2) 
	{
        HeapFree(g_hMainHeap, 0, szFaxNumber2);
    }
    if (szDocument) 
	{
        HeapFree(g_hMainHeap, 0, szDocument);
    }
    if (szCoverPage) 
	{
        HeapFree(g_hMainHeap, 0, szCoverPage);
    }
    if (szReceiveDir) 
	{
        HeapFree(g_hMainHeap, 0, szReceiveDir);
    }

	return(nReturnValue);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\faxsrvrbvtpdll\faxsrvrbvt.cpp ===
#include <windows.h>
#include <tchar.h>
#include <crtdbg.h>

#include "..\DispatchPerformer\DispatchPerformer.h"

#include "suite.h"


#ifndef UNICODE
#error Must be compiled with UNICODE
#endif

#ifdef _MBCS
#error Must be compiled with UNICODE
#endif

extern "C"
{



////////////////////////////////////////////////////////////////////////
// next 4 functions are for testing purposes, please leave them be
////////////////////////////////////////////////////////////////////////
DLL_EXPORT  
BOOL
FaxSrvrSuite(char *in, char *out, char *err)
{
    BOOL fRetVal = FALSE;

    //
    // break-up in string into argc and argv
    //

    _ASSERTE(NULL != in);
    _ASSERTE(NULL != out);
    _ASSERTE(NULL != err);

    LPWSTR* argvW = NULL;
    LPWSTR* argvW2 = NULL;
    int     argc = 0;
    int     i = 0;

    // convert in string from char to WCHAR

    DWORD   dwInStrSize = (::lstrlenA(in) + 1) * sizeof(WCHAR);
    WCHAR*  szIn = NULL;

    szIn = (WCHAR*) malloc(dwInStrSize);
	if(NULL == szIn)
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nmalloc failed with err=0x%8X\n"),
			TEXT(__FILE__),
			__LINE__,
            ::GetLastError()
			);
		goto ExitFuncFail;
	}
    ZeroMemory(szIn, dwInStrSize);

	if (FALSE == ::MultiByteToWideChar(
		                        CP_ACP, 
		                        0, 
		                        in, 
		                        -1, 
		                        szIn, 
		                        dwInStrSize
		                        )
       )
	{
		::_tprintf(
			TEXT("FILE:%s LINE:%d\nMultiByteToWideChar failed With err=0x%8X\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFuncFail;
	}

    // parse string to argv and argc
    argvW = ::CommandLineToArgvW(szIn, &argc);
    if (NULL == argvW)
    {
		::_tprintf(
			TEXT("FILE:%s LINE:%d\nCommandLineToArgvW failed With err=0x%8X\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFuncFail;
    }

    // create argvW2 where app name is first arg and other args follow
    argvW2 = (LPWSTR*) malloc ((argc+1) * sizeof(WCHAR*));
    if (NULL == argvW2)
    {
		::_tprintf(
			TEXT("FILE:%s LINE:%d\nmalloc failed With err=0x%8X\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFuncFail;
    }

    // first arg
    argvW2[0] = L"FaxSrvrBvt"; 

    //other args 
    for( i=0; i < argc; i++)
    {
        argvW2[i+1] = argvW[i]; 
    }


    //
    // call MainFunc(argc, argv)
    //

    if (FALSE == ::MainFunc((argc+1), argvW2))
    {
        SafeSprintf(
            MAX_RETURN_STRING_LENGTH,
            err,
            "MainFunc returned FALSE"
            );
        goto ExitFuncFail;
    }
    else
    {
        SafeSprintf(
            MAX_RETURN_STRING_LENGTH,
            out,
            "MainFunc returned TRUE"
            );
    }

    fRetVal = TRUE;

ExitFuncFail:    
    ::LocalFree(argvW);    //frees each of argvW[0..argc-1] and argvW itself
    free(argvW2);       //no need to free argvW2[0] since it is a literal
    free(szIn);
    return (fRetVal);
}

DLL_EXPORT  
BOOL 
SetTerminateTimeout(
    char * szCommand,
    char *szOut,
    char *szErr
    )
{
    return DispSetTerminateTimeout(szCommand, szOut, szErr);
}



}//extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\faxsrvrbvtpdll\suite.cpp ===
//
//
// Filename:	suite.cpp
// Author:		Sigalit Bar
// Date:		22-Apr-99
//
//


#include "suite.h"

#define HELP_SWITCH_1        TEXT("/?")
#define HELP_SWITCH_2        TEXT("/H")
#define HELP_SWITCH_3        TEXT("-?")
#define HELP_SWITCH_4        TEXT("-H")

#define MAX_ARGS	9 //including exe name

#define ARGUMENT_IS_SERVER_NAME		1
#define ARGUMENT_IS_FAX_NUMBER1		2
#define ARGUMENT_IS_FAX_NUMBER2		3
#define ARGUMENT_IS_DOC				4
#define ARGUMENT_IS_CP				5
#define ARGUMENT_IS_RECEIVE_DIR		6
#define ARGUMENT_IS_SENT_DIR		7
#define ARGUMENT_IS_REFERENCE_DIR   8


//
// global pointer to process heap
//
HANDLE g_hMainHeap = NULL;


//
// UsageInfo:
//	Outputs application's proper usage and exits process.
//
void
UsageInfo(LPCTSTR szExeName)
{
	::_tprintf(TEXT("%s for Comet Fax\n\n"), szExeName);
	::_tprintf(TEXT("%s server_name fax_number1 fax_number2 document cover_page receive_dir sent_dir reference_dir\n"), szExeName);
	::_tprintf(TEXT("    server_name   the name of the fax server (without the \\\\)\n"));
	::_tprintf(TEXT("    fax_number1   the fax number of the 1st device on server\n"));
	::_tprintf(TEXT("    fax_number2   the fax number of the 2nd device on server\n"));
	::_tprintf(TEXT("    document      the full path of the document to send\n"));
	::_tprintf(TEXT("    cover_page    the full path to the cover page to send\n"));
	::_tprintf(TEXT("    receive_dir   the full path to the receive directory of receiving device\n"));
	::_tprintf(TEXT("    sent_dir      the full path to the sent archive directory\n"));
	::_tprintf(TEXT("    referance_dir the full path to the reference directory\n"));
	::_tprintf(TEXT("\n"));
}


//
// ParseCmdLineParams:
//	Parses the command line parameters, saves a copy of them,
//	and converts from MBCS to UNICODE if necessary.
//
// Parameters:
//	argc				IN parameter.
//						command line number of arguments.
//	argvT[]				IN parameter.
//						command line args (in MBCS).
//	pszServerName		OUT parameter.
//						Pointer to string to copy 1st argument to.
//						Represents the name of fax server to use.
//	pszFaxNumber1		OUT parameter.
//						Pointer to string to copy 2nd argument to.
//						Represents the fax number of 1st device on the
//						above fax server.
//	pszFaxNumber2		OUT parameter.
//						Pointer to string to copy 3rd argument to.
//						Represents the fax number of 2nd device on the
//						above fax server.
//	pszDocument			OUT parameter.
//						Pointer to string to copy 4th argument to.
//						Represents the name of document to use with tests.
//	pszCoverPage		OUT parameter.
//						Pointer to string to copy 5th argument to.
//						Represents the name of the cover page to use
//						with tests.
//	pszReceiveDir		OUT parameter.
//						Pointer to string to copy 6th argument to.
//						Represents the name of directory to route received 
//						faxes to.
//	pszSentDir		    OUT parameter.
//						Pointer to string to copy 7th argument to.
//						Represents the name of directory to store (archive)  
//						sent faxes in.
//	pszReferenceDir		OUT parameter.
//						Pointer to string to copy 8th argument to.
//						Represents the name of directory containing reference  
//						faxes.
//
// Return Value:
//	TRUE on success and FALSE on failure.
//
//
BOOL 
ParseCmdLineParams(
	const INT	/* IN */	argc,
	TCHAR *		/* IN */	argvT[],
	LPTSTR*		/* OUT */	pszServerName,
	LPTSTR*		/* OUT */	pszFaxNumber1,
	LPTSTR*		/* OUT */	pszFaxNumber2,
	LPTSTR*		/* OUT */	pszDocument,
	LPTSTR*		/* OUT */	pszCoverPage,
    LPTSTR*		/* OUT */	pszReceiveDir,
    LPTSTR*		/* OUT */	pszSentDir,
    LPTSTR*		/* OUT */	pszReferenceDir
    )
{
	_ASSERTE(pszServerName);
	_ASSERTE(pszDocument);
	_ASSERTE(pszFaxNumber1);
	_ASSERTE(pszFaxNumber2);
	_ASSERTE(pszCoverPage);
	_ASSERTE(pszReceiveDir);
	_ASSERTE(pszSentDir);
	_ASSERTE(pszReferenceDir);

	DWORD	dwArgLoopIndex;

	//
	// Check number of parameters
	//
	if ( ( argc != MAX_ARGS ) && ( argc != 2 ) )  
	{
		::_tprintf(TEXT("\nInvalid invocation of %s\n\n"), argvT[0]);
		::_tprintf(TEXT("%s Help:\n"), argvT[0]);
		::UsageInfo(argvT[0]); 
         goto ExitFuncFail;
	}

	//
	// Loop on arguments in argvA[]
	//
    for (dwArgLoopIndex = 1; dwArgLoopIndex < (DWORD) argc; dwArgLoopIndex++) 
	{
		//
		// Check for help switch
		//
		// If this is the second argument, it may be one of several help switches defined.
		// A help switch can appear only as the second argument.
        if (2 == argc)
		{
			if (! (!::lstrcmpi(HELP_SWITCH_1, argvT[dwArgLoopIndex])) || 
				  (!::lstrcmpi(HELP_SWITCH_2, argvT[dwArgLoopIndex])) || 
				  (!::lstrcmpi(HELP_SWITCH_3, argvT[dwArgLoopIndex])) || 
				  (!::lstrcmpi(HELP_SWITCH_4, argvT[dwArgLoopIndex]))
				) 
			{
				::_tprintf(TEXT("Invalid invocation of %s\n\n"), argvT[0]);
			}
			::UsageInfo(argvT[0]); 
            goto ExitFuncFail;
		}

		//
		// Treat each argument accordingly
		//
		switch (dwArgLoopIndex)
		{
		case ARGUMENT_IS_SERVER_NAME:
			//server_name param
			(*pszServerName) = argvT[dwArgLoopIndex];
			break;

		case ARGUMENT_IS_FAX_NUMBER1:
			//fax_number1 param
			(*pszFaxNumber1) = argvT[dwArgLoopIndex];
			break;

		case ARGUMENT_IS_FAX_NUMBER2:
			//fax_number2 param
			(*pszFaxNumber2) = argvT[dwArgLoopIndex];
			break;

		case ARGUMENT_IS_DOC:
			//document param
			(*pszDocument) = argvT[dwArgLoopIndex];
			break;

		case ARGUMENT_IS_CP:
			//cover_page param
			(*pszCoverPage) = argvT[dwArgLoopIndex];
			break;

        case ARGUMENT_IS_RECEIVE_DIR:
			//cover_page param
			(*pszReceiveDir) = argvT[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_SENT_DIR:
			//cover_page param
			(*pszSentDir) = argvT[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_REFERENCE_DIR:
			//cover_page param
			(*pszReferenceDir) = argvT[dwArgLoopIndex];
            break;

		default:
			_ASSERTE(FALSE);
			return FALSE;
		}// switch (dwIndex)

	}//for (dwIndex = 1; dwIndex < (DWORD) argc; dwIndex++)


	return(TRUE);

ExitFuncFail:

	//
	//reset OUT parameters
	//
	(*pszServerName) = NULL;
	(*pszFaxNumber1) = NULL;
	(*pszFaxNumber2) = NULL;
	(*pszDocument) = NULL;
	(*pszCoverPage) = NULL;
	(*pszReceiveDir) = NULL;
	(*pszSentDir) = NULL;
	(*pszReferenceDir) = NULL;

	return(FALSE);
}




//
// main body of application.
//
BOOL
MainFunc(
	INT   argc,
    TCHAR  *argvT[]
)
{
	BOOL fReturnValue = TRUE; 

	LPTSTR szServerName = NULL;
	LPTSTR szFaxNumber1 = NULL;
	LPTSTR szFaxNumber2 = NULL;
	LPTSTR szDocument = NULL;
	LPTSTR szCoverPage = NULL;
	LPTSTR szReceiveDir = NULL;
    LPTSTR szSentDir = NULL;
    LPTSTR szReferenceDir = NULL;

	//
	// Set g_hMainHeap to process heap
	//
	g_hMainHeap = NULL;
	g_hMainHeap = ::GetProcessHeap();
	if(NULL == g_hMainHeap)
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nGetProcessHeap returned NULL with GetLastError()=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        fReturnValue = FALSE;
		goto ExitFunc;
	}

	//
	// Parse the command line
	//
	if (!::ParseCmdLineParams(
			argc,
			argvT,
			&szServerName,
			&szFaxNumber1,
			&szFaxNumber2,
			&szDocument,
			&szCoverPage,
            &szReceiveDir,
            &szSentDir,
            &szReferenceDir
			)
		)
	{
        fReturnValue = FALSE;
		goto ExitFunc;
	}

	//
	// "Debug" printing of the command line parameters after parsing
	//
#ifdef _DEBUG
	::_tprintf(
		TEXT("DEBUG\nServer=%s\nFaxNumber1=%s\nFaxNumber2=%s\nDocument=%s\nCoverPage=%s\nReceiveDir=%s\nszSentDir=%s\nszReferenceDir=%s\n"),
		szServerName,
		szFaxNumber1,
		szFaxNumber2,
		szDocument,
		szCoverPage,
        szReceiveDir,
        szSentDir,
        szReferenceDir
		);
#endif


	if (!TestSuiteSetup(
			szServerName,
			szFaxNumber1,
			szFaxNumber2,
			szDocument,
			szCoverPage,
            szReceiveDir,
            szSentDir,
            szReferenceDir
			)
		)
	{
        fReturnValue = FALSE;
		goto ExitFunc;
	}


    //Send a fax + CP
	if (FALSE == TestCase1(			
		                szServerName,
		                szFaxNumber2,
		                szDocument,
		                szCoverPage
		                )
       )
    {
        fReturnValue = FALSE;
    }


/*  FAILS (Comet 599) */
	//Send just a CP
	if (FALSE == TestCase2(			
		                szServerName,
		                szFaxNumber2,
		                szCoverPage
		                )
       )
    {
        fReturnValue = FALSE;
    }


	//Send a fax with no CP
	if (FALSE == TestCase3(			
		                szServerName,
		                szFaxNumber2,
		                szDocument
		                )
       )
    {
        fReturnValue = FALSE;
    }

    //Send a broadcast (3 * same recipient)
    // ** invoke broadcast tests for SERVER ONLY **
    if (TRUE == g_fFaxServer)
    {
	    if (FALSE == TestCase4(			
		                    szServerName,
		                    szFaxNumber2,
		                    szDocument,
		                    szCoverPage
		                    )
            )
        {
            fReturnValue = FALSE;
        }
    }


/*  FAILS (Comet 599) - bug#??????? 
	//Send a broadcast of only CPs (3 * same recipient)
    // ** invoke broadcast tests for SERVER ONLY **
    if (TRUE == g_fFaxServer)
    {
	    if (FALSE == TestCase5(			
		                    szServerName,
		                    szFaxNumber2,
		                    szCoverPage
		                    )
            )
        {
            fReturnValue = FALSE;
        }
    }
*/

/*  FAILS (Comet 599) - NTBugs bug#246133
	//Send a broadcast without CPs (3 * same recipient)
    // ** invoke broadcast tests for SERVER ONLY **
    if (TRUE == g_fFaxServer)
    {
	    if (FALSE == TestCase6(			
		                    szServerName,
		                    szFaxNumber2,
		                    szDocument
		                    )
            )
        {
            fReturnValue = FALSE;
        }
    }
*/

	//Send a fax (*.doc file) + CP
	if (FALSE == TestCase7(			
		                szServerName,
		                szFaxNumber2,
		                szCoverPage
		                )
        )
    {
        fReturnValue = FALSE;
    }

	//Send a fax (*.ppt file) + CP
	if (FALSE == TestCase8(			
		                szServerName,
		                szFaxNumber2,
		                szCoverPage
		                )
        )
    {
        fReturnValue = FALSE;
    }

	//Send a fax (*.xls file) + CP
	if (FALSE == TestCase9(			
		                szServerName,
		                szFaxNumber2,
		                szCoverPage
		                )
        )
    {
        fReturnValue = FALSE;
    }


    //Compare all "received faxes" in directory szReceiveDir
    //with the files in szReferenceDir
    if (FALSE == TestCase10(
                        szReceiveDir,
                        szReferenceDir
                        )
        )
    {
        fReturnValue = FALSE;
    }

/*  FAILS (Comet 613) - first line tiff bug??? */
    //Compare all (archived) "sent faxes" in directory szSentDir
    //with the files in szReferenceDir
    if (FALSE == TestCase11(
                        szSentDir,
                        szReferenceDir
                        )
        )
    {
        fReturnValue = FALSE;
    }


ExitFunc:
	TestSuiteShutdown();

	return(fReturnValue);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\nt5fxs\nt5fxs.cpp ===
// NT5Fxs.cpp : Defines the entry point for the DLL application.
//

#include <windows.h>
#include <TCHAR.H>
#include <crtdbg.h>

#define _WINFAX_
#include <winfax.h>


//
// This DLL exports all the extended fax apis.
// It has the entry points of fxsapi.dll minus those of the legacy winfax.dll
//
// Every API fails with ERROR_CALL_NOT_IMPLEMENTED.
//
// This DLL is intended to simplify compiling test applications
// that have settings for both the Legacy winfax.h and the new winfax.h.
// Such applications can include the new (extended) winfax.h
// and link with either 
//	1. the new fxsapi.dll
//	or
//	2. the legacy winfax.dll and this NT5Fxs.dll (that implements the "missing" APIs)
//
// See CometBvt.dsp as an example
//

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
 	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		break;
	case DLL_PROCESS_DETACH:
		break;
	}
   return TRUE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnumPortsExA (
    IN  HANDLE              hFaxHandle,
    OUT PFAX_PORT_INFO_EXA *ppPorts,
    OUT LPDWORD             lpdwNumPorts
)
{
	_ASSERTE(FALSE);
	::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnumPortsExW (
    IN  HANDLE              hFaxHandle,
    OUT PFAX_PORT_INFO_EXW *ppPorts,
    OUT LPDWORD             lpdwNumPorts
)
{
	_ASSERTE(FALSE);
	::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetArchiveConfigurationA (
    IN HANDLE                       hFaxHandle,
    IN FAX_ENUM_MESSAGE_FOLDER      Folder,
    IN CONST PFAX_ARCHIVE_CONFIGA   pArchiveCfg
)
{
	_ASSERTE(FALSE);
	::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetArchiveConfigurationW (
    IN HANDLE                       hFaxHandle,
    IN FAX_ENUM_MESSAGE_FOLDER      Folder,
    IN CONST PFAX_ARCHIVE_CONFIGW   pArchiveCfg
)
{
	_ASSERTE(FALSE);
	::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetArchiveConfigurationA (
    IN  HANDLE                   hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder,
    OUT PFAX_ARCHIVE_CONFIGA    *ppArchiveCfg
)
{
	_ASSERTE(FALSE);
	::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetArchiveConfigurationW (
    IN  HANDLE                   hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder,
    OUT PFAX_ARCHIVE_CONFIGW    *ppArchiveCfg
)
{
	_ASSERTE(FALSE);
	::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetQueue (
    IN HANDLE       hFaxHandle,
    IN CONST DWORD  dwQueueStates
)
{
	_ASSERTE(FALSE);
	::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetOutboxConfiguration (
    IN  HANDLE              hFaxHandle,
    OUT PFAX_OUTBOX_CONFIG *ppOutboxCfg
)
{
	_ASSERTE(FALSE);
	::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetOutboxConfiguration (
    IN HANDLE                    hFaxHandle,
    IN CONST PFAX_OUTBOX_CONFIG  pOutboxCfg
)
{
	_ASSERTE(FALSE);
	::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetPortExA (
    IN  HANDLE              hFaxHandle,
    IN  DWORD               dwDeviceId,
    IN  PFAX_PORT_INFO_EXA  pPortInfo
)
{
	_ASSERTE(FALSE);
	::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetPortExW (
    IN  HANDLE              hFaxHandle,
    IN  DWORD               dwDeviceId,
    IN  PFAX_PORT_INFO_EXW  pPortInfo
)
{
	_ASSERTE(FALSE);
	::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	return FALSE;
}

WINFAXAPI
BOOL
WINAPI FaxEnumJobsExA (
    IN  HANDLE              hFaxHandle,
    IN  DWORD               dwJobTypes,
    OUT PFAX_JOB_ENTRY_EXA *ppJobEntries,
    OUT LPDWORD             lpdwJobs
)
{
	_ASSERTE(FALSE);
	::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	return FALSE;
}

WINFAXAPI
BOOL
WINAPI FaxEnumJobsExW (
    IN  HANDLE              hFaxHandle,
    IN  DWORD               dwJobTypes,
    OUT PFAX_JOB_ENTRY_EXW *ppJobEntries,
    OUT LPDWORD             lpdwJobs
)
{
	_ASSERTE(FALSE);
	::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetParentJobId
(
        IN      HANDLE hFaxHandle,
        IN      DWORD dwRecipientId,
        OUT     LPDWORD lpdwParentId
)
{
	_ASSERTE(FALSE);
	::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetJobExA (
    IN  HANDLE              hFaxHandle,
    IN  DWORDLONG           dwlMessageID,
    OUT PFAX_JOB_ENTRY_EXA *ppJobEntry
)
{
	_ASSERTE(FALSE);
	::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetJobExW (
    IN  HANDLE              hFaxHandle,
    IN  DWORDLONG           dwlMessageID,
    OUT PFAX_JOB_ENTRY_EXW *ppJobEntry
)
{
	_ASSERTE(FALSE);
	::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	return FALSE;
}

BOOL WINAPI FaxSendDocumentExA
(
        IN      HANDLE                          hFaxHandle,
        IN      LPCSTR                        lpctstrFileName,
        IN      LPCFAX_COVERPAGE_INFO_EXA       lpcCoverPageInfo,
        IN      LPCFAX_PERSONAL_PROFILEA        lpcSenderProfile,
        IN      DWORD                           dwNumRecipients,
        IN      LPCFAX_PERSONAL_PROFILEA        lpcRecipientList,
        IN      LPCFAX_JOB_PARAM_EXA            lpJobParams,
        OUT     PDWORDLONG                      lpdwlMessageId,
        OUT     PDWORDLONG                      lpdwlRecipientMessageIds
)
{
	_ASSERTE(FALSE);
	::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	return FALSE;
}

BOOL WINAPI FaxSendDocumentExW
(
        IN      HANDLE                          hFaxHandle,
        IN      LPCWSTR                        lpctstrFileName,
        IN      LPCFAX_COVERPAGE_INFO_EXW       lpcCoverPageInfo,
        IN      LPCFAX_PERSONAL_PROFILEW        lpcSenderProfile,
        IN      DWORD                           dwNumRecipients,
        IN      LPCFAX_PERSONAL_PROFILEW        lpcRecipientList,
        IN      LPCFAX_JOB_PARAM_EXW            lpJobParams,
        OUT     PDWORDLONG                      lpdwlMessageId,
        OUT     PDWORDLONG                      lpdwlRecipientMessageIds
)
{
	_ASSERTE(FALSE);
	::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxRegisterForServerEvents (
        IN  HANDLE      hFaxHandle,
        IN  DWORD       dwEventTypes,
        IN  HANDLE      hCompletionPort,
        IN  DWORD       dwCompletionKey,
        IN  HWND        hWnd,
        IN  DWORD       dwMessage,
        OUT LPHANDLE    lphEvent
)
{
	_ASSERTE(FALSE);
	::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxUnregisterForServerEvents (
        IN  HANDLE      hEvent
)
{
	_ASSERTE(FALSE);
	::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\faxsrvrbvtpdll\faxsrvrbvttest\main.c ===
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
#include "..\..\DispatchPerformer\DispatchPerformer.h"

typedef long (*PERFORMER_FUNCTION)( long, long, const char  *, char*, char*);

/*
#define nINVALID_EXPECTED_SUCCESS    (0)
#define nEXPECT_DONT_CARE            (2)
#define nEXPECT_SUCCESS              (1)
#define nEXPECT_FAILURE              (-1)
*/
int main(
	INT   argc,
    CHAR  *argvA[]
)
{
    long l;
    char out[MAX_RETURN_STRING_LENGTH];
    char err[MAX_RETURN_STRING_LENGTH];
    LPTSTR  tszCommandLine = NULL;
    DWORD   dwCommandLineLength = 0;
    DWORD   dwExeNameLength = 0;
    CHAR*   aszIn = NULL;

    HMODULE hFaxSrvrBvtPDLL = LoadLibrary("FaxSrvrBvtPDLL.dll");
    PERFORMER_FUNCTION fnPerformer = (PERFORMER_FUNCTION)GetProcAddress(hFaxSrvrBvtPDLL, "performer");
    PERFORMER_FUNCTION fnTerminate = (PERFORMER_FUNCTION)GetProcAddress(hFaxSrvrBvtPDLL, "terminate");
    _ASSERTE(hFaxSrvrBvtPDLL);
    _ASSERTE(fnPerformer);
    _ASSERTE(fnTerminate);

    //
    tszCommandLine = GetCommandLine();
    if (NULL == tszCommandLine)
    {
        printf(
            "[ERROR] File:%s Line:%d\nGetCommandLine() failed with ec=0x%08\n",
			__FILE__,
			__LINE__,
            GetLastError()
            );
        goto ExitFuncFail;
    }
    dwCommandLineLength = _tcslen(tszCommandLine);
    _ASSERTE(0 != dwCommandLineLength);

    _ASSERTE(argvA[0]);
    dwExeNameLength = strlen(argvA[0]);
    _ASSERTE(0 != dwExeNameLength);

    // alloc string to give to fnPerformer
    // length is dwCommandLineLength+20+1 to allow for "1 1000 FaxSrvrSuite " and NULL
    aszIn = (CHAR*) malloc ((dwCommandLineLength+20+1)*sizeof(CHAR));
    if (NULL == aszIn)
    {
        printf(
            "[ERROR] File:%s Line:%d\nmalloc failed with ec=0x%08\n",
			__FILE__,
			__LINE__,
            GetLastError()
            );
        goto ExitFuncFail;
    }
    ZeroMemory(aszIn,(dwCommandLineLength+20+1)*sizeof(CHAR));
    // place "1 1000 " at start of string
    strncpy(aszIn, "1 1000 FaxSrvrSuite ", 20);

#ifdef _UNICODE
    // since fnPerformer needs char string we convert tszCommandLine
    // into aszIn[20]
	if (FALSE == WideCharToMultiByte(
		                        CP_ACP, 
		                        0, 
		                        &tszCommandLine[dwExeNameLength+1], 
		                        -1, 
		                        &aszIn[20], 
		                        dwCommandLineLength
		                        )
       )
	{
		::printf(
			"[ERROR] File:%s Line:%d\nWideCharToMultiByte failed With err=0x%8X\n",
			__FILE__,
			__LINE__,
			GetLastError()
			);
		goto ExitFuncFail;
	}

#else
    // we copy 
    strncpy(&aszIn[20], &tszCommandLine[dwExeNameLength+1], dwCommandLineLength);
#endif

    printf(
        "[DETAIL] File:%s Line:%d\ncalling fnPerformer with input string\n\"%s\"\n",
			__FILE__,
			__LINE__,
            aszIn
        );

//    l = fnPerformer(1,1,"1 1000 FaxSrvrSuite sigalitb2 5090 7180 test.tif c:\\cometbvt\\faxbvt\\subnote.cov c:\\cometbvt\\faxbvt\\faxes\\7180Receive c:\\cometbvt\\faxbvt\\faxes\\SentFaxes c:\\cometbvt\\faxbvt\\faxes\\Reference", out, err);
    l = fnPerformer(1,1,aszIn, out, err);
    if (DTM_TASK_STATUS_SUCCESS != l)
    {
        printf("\nERROR: the call \"1 1000 FaxSrvrSuite ...\" retunred %d instead of DTM_TASK_STATUS_SUCCESS(%d)\n", l, DTM_TASK_STATUS_SUCCESS);
        printf("  out=%s\n", out);
        printf("  err=%s\n", err);
    }
    else
    {
        printf("\nSUCCESS: the call \"1 1000 FaxSrvrSuite ...\" retunred DTM_TASK_STATUS_SUCCESS as expected\n");
        printf("\n  out=%s\n", out);
        printf("\n  err=%s\n", err);
    }

/*
    l = fnTerminate(1,1,"1 0  SetTerminateTimeout 12345", out, err);
    if (DTM_TASK_STATUS_SUCCESS != l)
    {
        printf("ERROR: the call \"1 9999 SetTerminateTimeout 12345\" retunred %d instead DTM_TASK_STATUS_SUCCESS(%d)\n", l, DTM_TASK_STATUS_SUCCESS);
        printf("  out=%s\n", out);
        printf("  err=%s\n", err);
    }
    else
    {
        printf("the call \"1 9999 SetTerminateTimeout 12345\" retunred DTM_TASK_STATUS_SUCCESS as expected\n");
        printf("  out=%s\n", out);
        printf("  err=%s\n", err);
    }
*/


    return 0;

ExitFuncFail:
    // free allocs
    free(tszCommandLine);
    return(1); // fail
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\mscrash\main.cpp ===
#include <stdio.h>
#include <time.h>
#include <tchar.h>
#include <crtdbg.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"



#include <windows.h>

//#include "ntuser.h"
#ifndef W32KAPI
#define W32KAPI  DECLSPEC_ADDRSAFE
#endif

W32KAPI
BOOL
NtUserLockWorkStation(
    VOID);


extern __declspec(thread) ULONG g_tlsRandomSeed;
void TlsSrand();
bool SkipKnownBuggyNtSystemCalls(DWORD dwTrap);
bool SkipKnownBuggyUserSystemCalls(DWORD dwTrap);

static bool s_fVerbose = false;
#define DPF(x) if (s_fVerbose) _tprintf x

DWORD WINAPI BufferAllocAndFreeThread(LPVOID pVoid);
DWORD WINAPI BufferContentsChangeThread(LPVOID pVoid);
//DWORD WINAPI DecommittedBufferContentsChangeThread(LPVOID pVoid);
DWORD WINAPI Interrupt2EThread(LPVOID pVoid);

#define NUM_OF_ALLOC_AND_FREE_BUFFS (64)
#define SIZEOF_INOUTBUFF (RAND_MAX-1)
#define NUM_OF_INT_2E_THREADS (20)
#define NUM_OF_NT_USER_THREADS (20)

//
// arrays of pointer to NtCurrentTeb() and NtCurrentPeb(), that i intend to corrupt
//
PTEB g_pTEB_MakeRandomNtUserCalls[NUM_OF_NT_USER_THREADS] = {0};
PPEB g_pPEB = NULL;
PTEB g_pTEB_Interrupt2EThread[NUM_OF_INT_2E_THREADS] = {0};

BYTE * sm_aCommitDecommitBuffs[NUM_OF_ALLOC_AND_FREE_BUFFS];
BYTE * sm_aCommittedBuffsAddress[NUM_OF_ALLOC_AND_FREE_BUFFS];
DWORD sm_adwAllocatedSize[NUM_OF_ALLOC_AND_FREE_BUFFS];

#define ALLOC_BUFF_SIZE (1024*1024)
BYTE sm_abBuff[ALLOC_BUFF_SIZE];

int Random();

HANDLE TryHardToCreateThread(LPTHREAD_START_ROUTINE lpStartAddress, LPVOID pvParan = NULL)
{
	HANDLE hThread;
	DWORD dwThreadId;
	for (UINT iTry = 0; iTry < 100; iTry++)
	{
		hThread = ::CreateThread(
			NULL,
			4*1024,      // hope this stack is enough for eveything, because in low mem we may run out of stack
			lpStartAddress,                          // pointer to thread function
			pvParan,     // argument for new thread
			0,
			&dwThreadId     // times to try
			);
		if (NULL != hThread)
		{
			return hThread;
		}
		DPF((TEXT("T")));
		::Sleep(10);
	}

	_ASSERTE(NULL == hThread);
	DPF((
		TEXT("Start(): CreateThread() failed with %d\n"),
		GetLastError()
		));
	return NULL;
}

HWINSTA NtUserMakeRandomSystemCall( 
	DWORD dw1,
	DWORD dw2,
	DWORD dw3,
	DWORD dw4,
	DWORD dw5,
	DWORD dw6,
	DWORD dw7,
	DWORD dw8,
	DWORD dw9,
	DWORD dw10,
	DWORD dw11,
	DWORD dw12,
	DWORD dw13,
	DWORD dw14,
	DWORD dw15,
	DWORD dw16,
	DWORD dwTrap
	)
{
	HWINSTA hWinsta;
	//
	// although the trap code is passed in, i will use the same paramteres 
	// for other random traps
	//
	for (UINT iter = 0; iter < 1000; iter++)
	{
		if (SkipKnownBuggyUserSystemCalls(dwTrap)) continue;

		__asm
		{
			mov     eax,dwTrap
			lea     edx,[esp+0x4]
			int     0x2e
			mov		hWinsta, eax
		}
		dwTrap = 0x1100+rand()%0x100;
	}

	return hWinsta;
}
#define DWORD_RAND \
	(rand()%10 ? RtlRandom(&g_tlsRandomSeed) : \
	rand()%10 ? ((rand()<<17) | (rand()<<2) | (rand()%4)) : \
	rand()%2 ? rand() : \
	rand()%2 ? (MAXULONG-rand()) : \
	rand()%2 ? MAXULONG : \
	rand()%2 ? MINLONG : \
	rand()%2 ? MAXLONG : \
	0)
#define ULONGLONGDWORD_RAND ((ULONGLONG)DWORD_RAND)
#define QUAD_RAND ((0 == rand()%10) ? (ULONGLONGDWORD_RAND | (ULONGLONGDWORD_RAND<<32)) : rand()%4 ? ULONGLONGDWORD_RAND : rand()%2 ? (0xFFFFFFFFFFFFFFFFi64-ULONGLONGDWORD_RAND) : rand()%2 ? (MAXLONGLONG - ULONGLONGDWORD_RAND) : (MAXLONGLONG + ULONGLONGDWORD_RAND))

DWORD WINAPI MakeRandomNtUserCalls(PVOID pvIndex)
{
	g_pTEB_MakeRandomNtUserCalls[(UINT)pvIndex] = NtCurrentTeb();
	DWORD dwThreadId = GetCurrentThreadId();
	__try
	{
		bool fException;
		TlsSrand();
		DWORD dwTrap;
		HWINSTA h;
		for (;;)
		{
			if (0 == rand() && 0 == rand()%1000)
			{
				DPF((TEXT("Before terminating process\n")));
				if (!::TerminateProcess(GetCurrentProcess(), 0))
				{
					DPF((TEXT("TerminateProcess() failed with %d\n"), GetLastError()));
				}
			}
			dwTrap = 0x1100+rand()%0x100;
			fException = false;
			__try
			{
				h = NtUserMakeRandomSystemCall( 
					Random(),//1
					Random(),//2
					Random(),//3
					Random(),//4
					Random(),//5
					Random(),//6
					Random(),//7
					Random(),//8
					Random(),//9
					Random(),//10
					Random(),//11
					Random(),//12
					Random(),//13
					Random(),//14
					Random(),//15
					Random(),//16
					dwTrap
					);
			}__except(1)
			{
				fException = true;
				DPF((TEXT("NtUserMakeRandomSystemCall() - GetExceptionCode = 0x%08X\n"), GetExceptionCode()));
			}
			if (!fException) DPF((TEXT("NtUserMakeRandomSystemCall () - Thread(%d): %d - SUCCEEDED!, nRes=0x%08X\n"), dwThreadId, dwTrap, h));
		}
		_ASSERTE(FALSE);
	}__except(1)
	{
		//
		// this is expected, because i do total random stuff
		//
		return 0;
	}
	_ASSERTE(FALSE);
	return 0;
}

DWORD WINAPI SelfTerminateThread(PVOID pv)
{
	DWORD dwSleepBeforeTerminate = (DWORD)pv;
	_tprintf(TEXT("Sleeping %d msecs before terminating self\n"), dwSleepBeforeTerminate);
	::Sleep(dwSleepBeforeTerminate);

	_tprintf(TEXT("Before terminating self\n"));
	TerminateProcess(GetCurrentProcess(), 0);
	_ASSERTE(FALSE);
	return 0;
}

int main(int argc, char* argv[])
{
	//
	// get it now, because later TEBs get corrupted, and we get PEB from TEB
	//
	g_pPEB = NtCurrentPeb();

	s_fVerbose = false;
	if (argc >= 3)
	{
		//
		// 3rd param must be the verbose param
		//
		if ( (TEXT('v') != argv[2][1]) && (TEXT('V') != argv[2][1]) )
		{
			_tprintf(TEXT("Usage: %s <msecs to sleep before terminating self> [-v]\n"), argv[0]);
			exit(-1);
		}
		s_fVerbose = true;
	}

	if (argc < 2)
	{
		_tprintf(TEXT("Usage: %s <msecs to sleep before terminating self> [-v]\n"), argv[0]);
		exit(-1);
	}

	ZeroMemory(g_pTEB_MakeRandomNtUserCalls, sizeof(g_pTEB_MakeRandomNtUserCalls));
	ZeroMemory(g_pTEB_Interrupt2EThread, sizeof(g_pTEB_Interrupt2EThread));

	TlsSrand();
	DWORD dwMilliSecondsBeforeTerminatingSelf = atoi(argv[1]);
	HANDLE hSelfTerminateThread = TryHardToCreateThread(SelfTerminateThread, (PVOID)dwMilliSecondsBeforeTerminatingSelf);
	if (NULL == hSelfTerminateThread)
	{
		_tprintf(TEXT("TryHardToCreateThread(SelfTerminateThread) failed, exiting\n"));
		exit(-1);
	}

	DWORD dwFirstTickCount = ::GetTickCount();
	
	HANDLE ahNtUserThread[NUM_OF_NT_USER_THREADS];
	DWORD dwSleepBeforeTerminateThreads;
	UINT uiThread;
	
	HANDLE hBufferAllocAndFreeThread;
	HANDLE hBufferContentsChangeThread;
	//HANDLE hDecommittedBufferContentsChangeThread;

	_tprintf(TEXT("Before TryHardToCreateThread(BufferAllocAndFreeThread)\n"));
	hBufferAllocAndFreeThread = TryHardToCreateThread(BufferAllocAndFreeThread);
	if (NULL == hBufferAllocAndFreeThread)
	{
		return -1;
	}
	_tprintf(TEXT("Before TryHardToCreateThread(BufferContentsChangeThread)\n"));
	hBufferContentsChangeThread = TryHardToCreateThread(BufferContentsChangeThread);
	if (NULL == hBufferContentsChangeThread)
	{
		return -1;
	}
	HANDLE hInt2EThreads[NUM_OF_INT_2E_THREADS];
	ZeroMemory(hInt2EThreads, sizeof(hInt2EThreads));
//goto non_nt_use_system_calls;
	__try
	{
		for (;;)
		{
			DPF((TEXT("Before creating MakeRandomNtUserCalls threads\n")));
			for (uiThread = 0; uiThread< NUM_OF_NT_USER_THREADS; uiThread++)
			{
				ahNtUserThread[uiThread] = TryHardToCreateThread(MakeRandomNtUserCalls, (LPVOID)uiThread);
				if (NULL == ahNtUserThread[uiThread])
				{
					DPF((TEXT("CreateThread(MakeRandomNtUserCalls) failed with %d\n"), GetLastError()));
				}
			}

			DPF((TEXT("Before creating Interrupt2EThread threads\n")));
			for (UINT iThread = 0; iThread < NUM_OF_INT_2E_THREADS; iThread++)
			{
				hInt2EThreads[iThread] = TryHardToCreateThread(Interrupt2EThread, (LPVOID)iThread);
				if (NULL == hInt2EThreads[iThread])
				{
					DPF((TEXT("CreateThread(Interrupt2EThread) failed with %d\n"), GetLastError()));
				}
			}
			dwSleepBeforeTerminateThreads = ::RtlRandom(&g_tlsRandomSeed)%10000;
			DPF((TEXT("Sleeping %d before terminating threads\n"), dwSleepBeforeTerminateThreads));
			::Sleep(dwSleepBeforeTerminateThreads);
			DPF((TEXT("Before terminating threads\n")));
			for (uiThread = 0; uiThread< NUM_OF_NT_USER_THREADS; uiThread++)
			{
				if (ahNtUserThread[uiThread])
				{
					DPF((TEXT("Before TerminateThread(ahNtUserThread[%d]\n"), uiThread));
					::TerminateThread(ahNtUserThread[uiThread], 0);
					::CloseHandle(ahNtUserThread[uiThread]);
					ahNtUserThread[uiThread] = NULL;
				}
			}
			for (iThread = 0; iThread < NUM_OF_INT_2E_THREADS; iThread++)
			{
				if (NULL != hInt2EThreads[iThread])
				{
					DPF((TEXT("Before TerminateThread(hInt2EThreads[%d]\n"), iThread));
					::TerminateThread(hInt2EThreads[iThread], -1);
					::CloseHandle(hInt2EThreads[iThread]);
					hInt2EThreads[iThread] = NULL;
				}
			}

			//
			// in case i randomly suspended it
			//
			::ResumeThread(hSelfTerminateThread);
			DWORD dwCurrentTickCount = ::GetTickCount();
			if (dwCurrentTickCount >= dwFirstTickCount)
			{
				if (dwCurrentTickCount-dwFirstTickCount >= dwMilliSecondsBeforeTerminatingSelf)
				{
					//
					// in case hSelfTerminateThread was randomly closed
					//
					_tprintf(TEXT("Before TerminateProcess(GetCurrentProcess(), 0)\n"));
					TerminateProcess(GetCurrentProcess(), 0);
				}
			}
			else
			{
				if (0xFFFFFFFF-dwFirstTickCount+dwCurrentTickCount >= dwMilliSecondsBeforeTerminatingSelf)
				{
					//
					// in case hSelfTerminateThread was randomly closed
					//
					_tprintf(TEXT("Before TerminateProcess(GetCurrentProcess(), 0)\n"));
					TerminateProcess(GetCurrentProcess(), 0);
				}
			}
		}
	}__except(1)
	{
		//
		// this is expected, because i do total random stuff
		//
		TerminateProcess(GetCurrentProcess(), 0);
	}
	_ASSERTE(FALSE);
	//
	// this is the NtUser stuff.
	// remark it if you want the rest to run
	//
	/*
	hDecommittedBufferContentsChangeThread = TryHardToCreateThread(DecommittedBufferContentsChangeThread);
	if (NULL == hDecommittedBufferContentsChangeThread)
	{
		return -1;
	}
*/
non_nt_use_system_calls:

	//
	// forever, create INT 2E threads, and terminate them when all are areated
	//
	while(true)
	{
		for (UINT iThread = 0; iThread < NUM_OF_INT_2E_THREADS; iThread++)
		{
			DPF((TEXT("Before TryHardToCreateThread(Interrupt2EThread)\n")));
			hInt2EThreads[iThread] = TryHardToCreateThread(Interrupt2EThread, (LPVOID)iThread);
			// do not care if TryHardToCreateThread failed
		}
		::Sleep(::RtlRandom(&g_tlsRandomSeed)%10000);
		for (iThread = 0; iThread < NUM_OF_INT_2E_THREADS; iThread++)
		{
			if (NULL != hInt2EThreads[iThread])
			{
				DPF((TEXT("Before TerminateThread(hInt2EThreads[%d]\n"), iThread));
				::TerminateThread(hInt2EThreads[iThread], -1);
				::CloseHandle(hInt2EThreads[iThread]);
				hInt2EThreads[iThread] = NULL;
			}
		}
		//
		// in case i randomly suspended it
		//
		::ResumeThread(hSelfTerminateThread);
		DWORD dwCurrentTickCount = ::GetTickCount();
		if (dwCurrentTickCount >= dwFirstTickCount)
		{
			if (dwCurrentTickCount-dwFirstTickCount >= dwMilliSecondsBeforeTerminatingSelf)
			{
				//
				// in case hSelfTerminateThread was randomly closed
				//
				_tprintf(TEXT("Before TerminateProcess(GetCurrentProcess(), 0)\n"));
				TerminateProcess(GetCurrentProcess(), 0);
			}
		}
		else
		{
			if (0xFFFFFFFF-dwFirstTickCount+dwCurrentTickCount >= dwMilliSecondsBeforeTerminatingSelf)
			{
				//
				// in case hSelfTerminateThread was randomly closed
				//
				_tprintf(TEXT("Before TerminateProcess(GetCurrentProcess(), 0)\n"));
				TerminateProcess(GetCurrentProcess(), 0);
			}
		}
	}
	_ASSERTE(FALSE);
}

bool SkipKnownBuggyUserSystemCalls(DWORD dwTrap)
{
	//PBYTE pNtUserLockWorkStation = (PBYTE)NtUserLockWorkStation;
	//if (*((WORD*)(&pNtUserLockWorkStation[1])) == dwTrap)
	if (
		(0x11c3 == dwTrap) || // of free nt
		(0x11c1 == dwTrap) // on checked nt

		)
	{
		//
		// bug # 119220
		// bug # 120351
		//
		/*
USER32!NtUserLockWorkStation:
77e5f4a0 b8b9110000       mov     eax,0x11b9
77e5f4a5 8d542404         lea     edx,[esp+0x4]
77e5f4a9 cd2e             int     2e
77e5f4ab c3               ret
*/
		return true;
	}

	return false;
}
bool SkipKnownBuggyNtSystemCalls(DWORD dwTrap)
{
	///*
	PBYTE pNtOpenKey = (PBYTE)NtOpenKey;
	PBYTE pNtCreateKey = (PBYTE)NtCreateKey;
	if (pNtOpenKey[1] == dwTrap || 
		pNtCreateKey[1] == dwTrap
		)
	{
		//
		// bug # 119220
		// bug # 120351
		//
		return true;
	}
		//*/

	return false;
}

DWORD MakeRandomSystemCall( 
	DWORD dw1,
	DWORD dw2,
	DWORD dw3,
	DWORD dw4,
	DWORD dw5,
	DWORD dw6,
	DWORD dw7,
	DWORD dw8,
	DWORD dw9,
	DWORD dw10,
	DWORD dw11,
	DWORD dw12,
	DWORD dw13,
	DWORD dw14,
	DWORD dw15,
	DWORD dwTrap
	)
{
	DWORD status;
	//
	// although the trap code is passed in, i will use the same paramteres 
	// for other random traps
	//
	for (UINT iter = 0; iter < 1000; iter++)
	{
		__asm
		{
			mov     eax,dwTrap
			int     0x2e
			mov		status, eax
		}
retry_new_system_number:
		dwTrap = rand()%250;
		if (SkipKnownBuggyNtSystemCalls(dwTrap)) goto retry_new_system_number;
	}

	return status;
}

DWORD WINAPI Interrupt2EThread(LPVOID pvIndex)
{
	g_pTEB_Interrupt2EThread[(UINT)pvIndex] = NtCurrentTeb();
	DWORD dwThreadId = GetCurrentThreadId();
	TlsSrand();
	int dwTrap;
	int nRandom1;
	int nRandom2;
	int nRandom3;
	int nRandom4;
	int nRandom5;
	int nRandom6;
	int nRandom7;
	int nRandom8;
	int nRandom9;
	int nRandom10;
	int nRandom11;
	int nRandom12;
	int nRandom13;
	int nRandom14;
	int nRandom15;
	bool fException;
	DWORD dwRet;
	for(;;)
	{
		nRandom1 = Random();
		nRandom2 = Random();
		nRandom3 = Random();
		nRandom4 = Random();
		nRandom5 = Random();
		nRandom6 = Random();
		nRandom7 = Random();
		nRandom8 = Random();
		nRandom9 = Random();
		nRandom10 = Random();
		nRandom11 = Random();
		nRandom12 = Random();
		nRandom13 = Random();
		nRandom14 = Random();
		nRandom15 = Random();

		fException = false;
		dwTrap = rand()%250;
		if (SkipKnownBuggyNtSystemCalls(dwTrap)) continue;

		DPF((TEXT("m")));
		__try
		{
			dwRet = MakeRandomSystemCall( 
				nRandom1,
				nRandom2,
				nRandom3,
				nRandom4,
				nRandom5,
				nRandom6,
				nRandom7,
				nRandom8,
				nRandom9,
				nRandom10,
				nRandom11,
				nRandom12,
				nRandom13,
				nRandom14,
				nRandom15,
				dwTrap
				);
		}__except(1)
		{
			fException = true;
			DPF((TEXT("MakeRandomSystemCall() - GetExceptionCode = 0x%08X\n"), GetExceptionCode()));
		}
		if (!fException)
		{
			DPF((TEXT("s")));
			DPF((TEXT("MakeRandomSystemCall () - Thread(%d): %d - SUCCEEDED!, nRes=0x%08X\n"), dwThreadId, dwTrap, dwRet));
		}
		else
		{
			DPF((TEXT("e")));
		}

/*
		for (UINT iter = 0; iter < 1000; iter++)
		{
			b = rand()%250;

			fException = false;
			__try
			{
				__asm
				{
					push nRandom0;
					push nRandom1;
					push nRandom2;
					push nRandom3;
					push nRandom4;
					push nRandom5;
					push nRandom6;
					push nRandom7;
					push nRandom8;
					push nRandom9;
					//mov esp, 1;
					mov eax, b;
					int 0x2e;
					mov nRes, eax;
					pop eax;
					pop eax;
					pop eax;
					pop eax;
					pop eax;
					pop eax;
					pop eax;
					pop eax;
					pop eax;
					pop eax;
				}
			}__except(1)
			{
				fException = true;
				DPF((TEXT("Thread(%d): %d - exception 0x%08X\n"), dwThreadId, b, GetExceptionCode()));
			}
			if (!fException) DPF((TEXT("Thread(%d): %d - OK!, nRes=0x%08X\n"), dwThreadId, b, nRes));
		}
*/
		if (RtlRandom(&g_tlsRandomSeed) < 100000) 
		{
			DPF((TEXT("Interrupt2EThread() Before terminating this thread\n")));
			TerminateThread(::GetCurrentThread(), 0);
		}
	}

	return 0;
}



//
// this thread allocated and free buffers, that from time to time will be used by
// the DeviceThread for WriteFile, ReadFile and DeviceIoControl.
// the purpose is to call these APIs with valid buffers, that will get invalidated
// during the call, and to see that the driver handles this correctly,
// and does not crash the system.
// from time to time, the buffer passed to these APIs will already be invalid,
// in this case i hope the API will not AV, but rather return the appropriate status
// PROBLEM: output buffer that was freed, may have been allocated by another thread,
//   so when the operation completes, the not valid output buffer may be written, 
//   and thus currupting my own data structures!
//   Therefor, output buffer must be allocated from a know commited area!
// this thread never dies
//
DWORD WINAPI BufferAllocAndFreeThread(LPVOID pVoid)
{
	static long s_fAlreadyRunning = FALSE;

	TlsSrand();

	//
	// since this threads allocated to a static member array,
	// i do not want more than one thread messing with it
	//
	if (::InterlockedExchange(&s_fAlreadyRunning, TRUE))
	{
		_ASSERTE(false);
		return -1;
	}

	//
	// reserve a region, so all allocation will be from this region.
	// this way, since all allocations (at least today) put NULL in the region param,
	// i hope that no one will use these addresses, this way when the IO manager writes into an
	// output buffer, it will not trash other components memory
	//
	// also try to commit, so that we start with a 'full' array
	//
	for (int i = 0; i < NUM_OF_ALLOC_AND_FREE_BUFFS; i++)
	{
		sm_aCommittedBuffsAddress[i] = (BYTE*)::VirtualAlloc(
			NULL,// region to reserve or commit
			SIZEOF_INOUTBUFF * NUM_OF_ALLOC_AND_FREE_BUFFS,// size of region
			MEM_RESERVE,// type of allocation
			PAGE_EXECUTE_READWRITE// type of access protection
			);
//DPF((TEXT("VirtualAlloc(MEM_RESERVE) returned 0x%08X\n"), sm_aCommittedBuffsAddress[i]));
		_ASSERTE(sm_aCommittedBuffsAddress[i]);
		//
		// BUGBUG: what to do if i cannot reserve?
		//

		//
		// start by trying to allocate all the buffers
		//
		sm_adwAllocatedSize[i] = SIZEOF_INOUTBUFF;
		if (NULL == (sm_aCommitDecommitBuffs[i] = (BYTE*)::VirtualAlloc(
				sm_aCommittedBuffsAddress[i],// region to reserve or commit
				sm_adwAllocatedSize[i],// size of region
				MEM_COMMIT,// type of allocation
				PAGE_EXECUTE_READWRITE// type of access protection
				)))
		{
			//
			// mark as not allocated
			//
			sm_adwAllocatedSize[i] = 0;
		}
	}

	for(;;)
	{
		int i = rand()%NUM_OF_ALLOC_AND_FREE_BUFFS;
		//for (int i = 0; i < NUM_OF_ALLOC_AND_FREE_BUFFS; i++)
		{
			//
			// free the whole buffer
			// please note that it might already have been freed, so i am freeing dead zone
			//
			if (sm_adwAllocatedSize[i] != 0)
			{
				if (0 == rand()%100)
				{
					if (::VirtualFree(sm_aCommitDecommitBuffs[i], sm_adwAllocatedSize[i], MEM_DECOMMIT))
					{
						//
						// mark as freed
						//
						sm_adwAllocatedSize[i] = 0;

						//
						// do NOT set to NULL, becuae that's exactly what i want to achive:
						// i want the driver to use an invalid pointer!
						//
						// do NOT do this: sm_aCommitDecommitBuffs[i] = NULL;

						//
						// however, i do not wnat to immediately allocate, because i want the driver to 
						// have the chance to hit freed memory, so i will randomly allocate this buffer
						//
						//if (rand()%2) continue;
					}
					else
					{
						//
						// memory may be locked by the device driver
						//
DPF((TEXT("VirtualFree() failed with %d.\n"), ::GetLastError()));
					}
				}
				else
				{
					//
					// i did not free, so i do not allocate in order not to leak
					//
					continue;
				}
			}

			_ASSERTE(0 == sm_adwAllocatedSize[i]);

			for (;;)
			{
				DWORD dwAllocationType = MEM_COMMIT;
				if (0 == rand()%10) dwAllocationType |= MEM_PHYSICAL;
				if (0 == rand()%10) dwAllocationType |= MEM_RESET;
				if (0 == rand()%10) dwAllocationType |= MEM_TOP_DOWN;

				DWORD dwAccessAndProtection = 0;
				if (0 == rand()%10) dwAccessAndProtection |= PAGE_READONLY;
				if (0 == rand()%10) dwAccessAndProtection |= PAGE_READWRITE;
				if (0 == rand()%10) dwAccessAndProtection |= PAGE_EXECUTE;
				if (0 == rand()%10) dwAccessAndProtection |= PAGE_EXECUTE_READ;
				if (0 == rand()%10) dwAccessAndProtection |= PAGE_EXECUTE_READWRITE;
				if (0 == rand()%10) dwAccessAndProtection |= PAGE_GUARD;
				if (0 == rand()%10) dwAccessAndProtection |= PAGE_NOACCESS;
				if (0 == rand()%10) dwAccessAndProtection |= PAGE_NOCACHE;

				sm_adwAllocatedSize[i] = SIZEOF_INOUTBUFF;

				sm_aCommitDecommitBuffs[i] = (BYTE*)::VirtualAlloc(
					sm_aCommittedBuffsAddress[i],// region to reserve or commit
					sm_adwAllocatedSize[i],// size of region
					dwAllocationType,// type of allocation
					dwAccessAndProtection// type of access protection
					);
				if (NULL != sm_aCommitDecommitBuffs[i]) 
				{
					_ASSERTE(sm_aCommitDecommitBuffs[i] >= sm_aCommittedBuffsAddress[i]);
					//BUGBUG: not 64 bit compliant
					_ASSERTE(sm_aCommitDecommitBuffs[i] < (void*)((DWORD)sm_aCommittedBuffsAddress[i] + (SIZEOF_INOUTBUFF * NUM_OF_ALLOC_AND_FREE_BUFFS) - sm_adwAllocatedSize[i]));
//DPF((TEXT("VirtualAlloc() succeeded\n")));

					//
					// we allocated.
					// once in a while, put garbage in the buffer
					if (0 == rand()%50)
					{
						//
						// i may have allocated it without write permission, or a guard page etc.
						// so just try, if fail, i don't care
						//
						__try
						{
							for (DWORD dwIter = 0; dwIter < sm_adwAllocatedSize[i]; dwIter++)
							{
								((BYTE*)sm_aCommitDecommitBuffs[i])[dwIter] = rand()%2 ? 0 : rand()%2 ? 1 : rand()%2 ? -1 : rand();
							}
						}__except(1)
						{
							;
						}
					} else if (0 == rand()%100)
					{
						//
						// i may have allocated it without write permission, or a guard page etc.
						// so just try, if fail, i don't care
						//
						__try
						{
							for (DWORD dwIter = 0; dwIter < sm_adwAllocatedSize[i]; dwIter++)
							{
								ZeroMemory(sm_aCommitDecommitBuffs[i], SIZEOF_INOUTBUFF);
							}
						}__except(1)
						{
							;
						}
					}
					
					//
					// since this thread goes in a tight loop, i think this is the place 
					// to give up the CPU a bit.
					//
					::Sleep(0);
					break;
				}
				else
				{
					//
					// mark as not allocated
					//
					sm_adwAllocatedSize[i] = 0;
					//
					// allocation failed, either becaue of fault injection, or because we ran out of memory,
					// and i hope that not because i leaked.
					// this is also a good place to give up the CPU
					//
//DPF((TEXT("VirtualAlloc() FAILED with %d\n"), ::GetLastError()));
					::Sleep(100);
				}
			}//for (;;)

		}//for (int i = 0; i < NUM_OF_ALLOC_AND_FREE_BUFFS; i++)
	}//for(;;)

	_ASSERTE(FALSE);
	return -1;
}


DWORD WINAPI BufferContentsChangeThread(LPVOID pVoid)
{
	TlsSrand();
	__try
	{
		while(true)
		{
			//
			// change contents to one of the buffers
			//
			if (rand()%2) sm_abBuff[(rand() | (rand()<<15))%ALLOC_BUFF_SIZE] = rand();
			else ((int*)sm_abBuff)[((rand() | (rand()<<15))%ALLOC_BUFF_SIZE)/sizeof(int)] = Random();
			if (0 == rand()%1000) ZeroMemory(sm_abBuff, ALLOC_BUFF_SIZE);
			if (0 == rand()%100) ::Sleep(0);
			//
			// corrupt one of the TEBs, and maybe the PEB
			//
			if (0 == rand()%10000)
			{
				if (rand()%2)
				{
					//
					// 1 byte corruption
					//
					__try
					{
						((PBYTE)g_pTEB_MakeRandomNtUserCalls[rand()%NUM_OF_NT_USER_THREADS])[rand()%sizeof(TEB)] = rand();
					}__except(1)
					{
						//
						// it may be NULL, or just plain invalid after the thread dies
						//
						NOTHING;
					}
					__try
					{
						((PBYTE)g_pTEB_MakeRandomNtUserCalls[rand()%NUM_OF_NT_USER_THREADS])[rand()%sizeof(TEB)] = rand();
					}__except(1)
					{
						//
						// it may be NULL, or just plain invalid after the thread dies
						//
						NOTHING;
					}

					if (0 == rand()%10)
					{
						__try
						{
							((PBYTE)g_pPEB)[rand()%sizeof(PEB)] = rand();
						}__except(1)
						{
							_ASSERTE(FALSE);
						}
					}
				}
				else
				{
					//
					// rand() num of bytes corruption
					//
					__try
					{
						for (UINT uiCount = rand()%sizeof(TEB); uiCount>0; uiCount--)
						{
							((PBYTE)g_pTEB_MakeRandomNtUserCalls[rand()%NUM_OF_NT_USER_THREADS])[rand()%sizeof(TEB)] = rand();
						}
					}__except(1)
					{
						//
						// it may be NULL, or just plain invalid after the thread dies
						//
						NOTHING;
					}
					__try
					{
						for (UINT uiCount = rand()%sizeof(TEB); uiCount>0; uiCount--)
						{
							((PBYTE)g_pTEB_Interrupt2EThread[rand()%NUM_OF_INT_2E_THREADS])[rand()%sizeof(TEB)] = rand();
						}
					}__except(1)
					{
						//
						// it may be NULL, or just plain invalid after the thread dies
						//
						NOTHING;
					}

					if (0 == rand()%10)
					{
						__try
						{
							for (UINT uiCount = rand()%sizeof(TEB); uiCount>0; uiCount--)
							{
								((PBYTE)g_pPEB)[rand()%sizeof(PEB)] = rand();
							}
						}__except(1)
						{
							_ASSERTE(FALSE);
						}
					}
				}

			}
		}
	}__except(1)
	{
		_ASSERTE(FALSE);
	}
	return 0;
}
/*
DWORD WINAPI DecommittedBufferContentsChangeThread(LPVOID pVoid)
{
	while(true)
	{
		__try
		{
			sm_aCommitDecommitBuffs[rand()%NUM_OF_ALLOC_AND_FREE_BUFFS][rand()%SIZEOF_INOUTBUFF] = rand();
			if (0 == rand()%1000) ZeroMemory(sm_aCommitDecommitBuffs[rand()%NUM_OF_ALLOC_AND_FREE_BUFFS], SIZEOF_INOUTBUFF);
		}__except(1)
		{
			;//nothing
		}
		if (0 == rand()%100) ::Sleep(0);
	}
	return 0;
}
*/

__declspec(thread) ULONG g_tlsRandomSeed = 0;

int Random()
{
	if (rand()%2) return DWORD_RAND;
	if (rand()%2) return (int)(sm_aCommittedBuffsAddress[rand()%NUM_OF_ALLOC_AND_FREE_BUFFS]);
	if (rand()%2) return (int)(sm_abBuff+((rand()|(rand()<<15)|(rand()<<30))%ALLOC_BUFF_SIZE));
	if (rand()%2) return (rand()|(rand()<<15)|(rand()<<30));
	if (rand()%2) return -rand();
	if (rand()%2) return 0;
	if (rand()%2) return 1;
	return -1;
}


void TlsSrand()
{
	//
	// for the normal rand() calls
	//
	srand(time(NULL)*GetCurrentThreadId()*GetCurrentProcessId());

	//
	// for RtlRandom() calls
	//
    LARGE_INTEGER PerformanceCounter;

    PerformanceCounter.LowPart = time(NULL)*GetCurrentThreadId()*GetCurrentProcessId();

    NtQueryPerformanceCounter (
        &PerformanceCounter,
        NULL);

    g_tlsRandomSeed = PerformanceCounter.LowPart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\rendercpapi\main.cpp ===
//
//
// Filename:	main.cpp
// Author:		Sigalit Bar
// Date:		30-dec-98
//
//

#pragma warning(disable :4786)
#include <iniutils.h>

#include <testruntimeerr.h>
#include <tstring.h>

#include "testutils.h"
#include "bvt.h"


//
// main body of application.
//
int __cdecl
main(
	INT   argc,
    CHAR  *argvA[]
)
{
	int nReturnValue = 0; //to indicate success

    TCHAR** argvT = NULL;
    WCHAR** argvW = NULL;
    LPWSTR  szCmdLine = NULL;
    INT     argc2 = 0;
	LPTSTR	szFullPathToIniFile				= NULL;
	std::vector<LONG>	lVectorOfTestCasesToRun;

    //
    // get a TSTR command line
    //
#ifdef UNICODE

    // Unicode //
    szCmdLine = ::GetCommandLineW();
    if (NULL == szCmdLine)
    {
        ::_tprintf(TEXT("[main] GetCommandLineW failed with err=0x%08X\n"), ::GetLastError());
        _ASSERTE(FALSE);
        nReturnValue = 1; //to indicate err
        goto Exit;
    }
    argvW = ::CommandLineToArgvW(szCmdLine, &argc2);
    if (NULL == argvW)
    {
        ::_tprintf(TEXT("[main] CommandLineToArgvW failed with err=0x%08X\n"), ::GetLastError());
        _ASSERTE(FALSE);
        nReturnValue = 1; //to indicate err
        goto Exit;
    }
    if (argc != argc2)
    {
        ::_tprintf(TEXT("[main] argc(%d) != argc2(%d)\n"), argc, argc2);
        _ASSERTE(FALSE);
        nReturnValue = 1; //to indicate err
        goto Exit;
    }
    argvT = argvW;

#else

    // Ansi //
    argvT = argvA;

#endif

	//
	// Parse the command line
	//
	if (S_OK != GetCommandLineParams(
									argc, 
									argvT, 
									&szFullPathToIniFile
									)
		)
	{
	    nReturnValue = 1; // to indicate failure
		goto Exit;
	}
	_ASSERTE(szFullPathToIniFile);

	//
	// "Debug" printing of the command line parameters after parsing
	//
#ifdef _DEBUG
	::_tprintf(
		TEXT("DEBUG\nszFullPathToIniFile=%s\n"),
		szFullPathToIniFile
		);
#endif


	try
	{
		g_tstrFullPathToIniFile.assign(szFullPathToIniFile);

		//
		// Get the test cases to run
		//
		tstring tstrSectionName(TEXT("TestCases"));

		lVectorOfTestCasesToRun = GetVectorOfTestCasesToRunFromIniFile(
														g_tstrFullPathToIniFile, 
														tstrSectionName
														);
	}
	catch(exception ex)
	{
		::lgLogError(
			LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\n[main: before test suite setup]Got an STL exception (%S)\n"),
			TEXT(__FILE__),
			__LINE__,
            ex.what()
			);
		goto Exit;
	}

	if (!TestSuiteSetup())
	{
	    nReturnValue = 1; // to indicate failure
		goto Exit;
	}

	try
	{
		std::vector<LONG>::const_iterator it;
		for (it = lVectorOfTestCasesToRun.begin(); it != lVectorOfTestCasesToRun.end(); it++)
		{
			LONG lCurrentTestCase = (*it);
			::_tprintf(TEXT("Executing TestCase%d ...\n"), lCurrentTestCase);
			if (S_OK != runTestCase(lCurrentTestCase))
			{
				::_tprintf(TEXT("\tTestCase%d ***FAILED***\n"), lCurrentTestCase);
				nReturnValue = 1; //to indicate err
			}
			else
			{
				::_tprintf(TEXT("\tTestCase%d SUCCEEDED\n"), lCurrentTestCase);
			}
		}
	}
	catch(exception ex)
	{
		::lgLogError(
			LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\n[main]Got an STL exception (%S)\n"),
			TEXT(__FILE__),
			__LINE__,
            ex.what()
			);
		goto Exit;
	}


Exit:

    TestSuiteShutdown();
    
    //
    // free allocs
    //
    LocalFree(argvW);
    LocalFree(szCmdLine); // TO DO: ? do we need to free this ?
	free(szFullPathToIniFile);

    //
    // log exit code to console
    //
    ::_tprintf(TEXT("\n[main] Exiting with %d\n"), nReturnValue);
    if (1 == nReturnValue) 
    {
        ::_tprintf(TEXT("\n"));
        ::_tprintf(TEXT("******  ERROR  ******\n"));
        ::_tprintf(TEXT("****** FAILURE ******\n"));
        ::_tprintf(TEXT("\n"));
    }
    if (0 == nReturnValue) 
    {
        ::_tprintf(TEXT("\n"));
        ::_tprintf(TEXT("******   OK    ******\n"));
        ::_tprintf(TEXT("****** SUCCESS ******\n"));
        ::_tprintf(TEXT("\n"));
    }

    return(nReturnValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\rendercpapi\bvt.cpp ===
//
//
// Filename:	bvt.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		30-Dec-98
//
//

#include "bvt.h"
#include "testutils.h"
#include "..\VerifyTiffFiles\dirtiffcmp.h"

#ifdef __cplusplus
extern "C" {
#endif


//
// Array of pointers to test cases.
// The "runTestCase" (exported) function uses
// this array to activate the n'th test case
// of the module.
//
//IMPORTANT: If you wish to base your test case DLL
//			 implementation on this module, or if
//			 you intend to add test case functions
//			 to this file,
//			 MAKE SURE that all test case functions
//           are listed in this array (by name).
//			 The order of functions within the array
//			 determines their "serial number".
//
PTR_TO_TEST_CASE_FUNC gTestCaseFuncArray[] = 
{ 
    TestSuiteSetup, 
    TestCase1,  
    TestCase2,  
    TestCase3,  
    TestCase4,  
    TestCase5,
	TestCase6,
	TestCase7,
	TestCase8,
	TestCase9,
	TestCase10,
	TestCase11,
	TestCase12,
	TestCase13,
	TestCase14,
	TestCase15,
	TestCase16,
	TestCase17,
	TestCase18,
	TestCase19,
	TestCase20,
	TestCase21,
	TestCase22,
	TestCase23,
	TestCase24,
	TestCase25,
	TestCase26,
	TestCase27,
	TestCase28,
	TestCase29,
	TestCase30,
	TestCase31,
	TestCase32,
	TestCase33,
	TestCase34,
	TestCase35,
	TestCase36,
	TestCase37,
	TestCase38,
	TestCase39,
	TestCase40,
	TestCase41,
	TestCase42,
	TestCase43,
    TestSuiteShutdown 
};
DWORD   g_dwTestCaseFuncArraySize = (sizeof(gTestCaseFuncArray)/sizeof(gTestCaseFuncArray[0]));



FSPI_COVERPAGE_INFO     g_CoverPageInfo = {0};
FSPI_PERSONAL_PROFILE   g_RecipientProfile = {0};
FSPI_PERSONAL_PROFILE   g_SenderProfile = {0};
BOOL                    g_CheckSpecificHrValues = TRUE;
SYSTEMTIME				g_tmSentTime = {0};
FSPI_BRAND_INFO			g_BrandingInfo = {0};

//
// DoesFileExist
//
BOOL DoesFileExist(LPCTSTR lpctstrFilename)
{
	BOOL fRetVal = FALSE;

    _ASSERTE(NULL != lpctstrFilename);
    _ASSERTE(_T('\0') != lpctstrFilename[0]);

	DWORD dwFileAttributes = ::GetFileAttributes(lpctstrFilename);
	if(-1 == dwFileAttributes)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d [DoesFileExist]\nGetFileAttributes(%s) failed with ec=0x%08X"),
			TEXT(__FILE__),
			__LINE__,
			lpctstrFilename,
			::GetLastError()
			);
		goto ExitFunc;
	}

	fRetVal = TRUE;

ExitFunc:
	return(fRetVal);
}

//
// ResetGlobalStructs:
//
void ResetGlobalStructs( void )
{
    // set CoverPageInfo to default values
    g_CoverPageInfo.dwSizeOfStruct = sizeof(FSPI_COVERPAGE_INFO);
    g_CoverPageInfo.dwCoverPageFormat = FSPI_COVER_PAGE_FMT_COV;
    g_CoverPageInfo.lpwstrCoverPageFileName = ALL_FIELDS_CP;
    g_CoverPageInfo.dwNumberOfPages = 555;
    g_CoverPageInfo.lpwstrNote = L"note\nnote\note";
    g_CoverPageInfo.lpwstrSubject= L"subject";

    // set Sender profile to default values
    g_SenderProfile.dwSizeOfStruct = sizeof(FSPI_PERSONAL_PROFILE);
    g_SenderProfile.lpwstrName = L"Sender Name";
    g_SenderProfile.lpwstrFaxNumber = L"Sender Fax Number";
    g_SenderProfile.lpwstrCompany = L"Sender Company";
    g_SenderProfile.lpwstrStreetAddress = L"Sender Street Address";
    g_SenderProfile.lpwstrCity = L"Sender City";
    g_SenderProfile.lpwstrState = L"Sender State";
    g_SenderProfile.lpwstrZip = L"Sender Zip";
    g_SenderProfile.lpwstrCountry = L"Sender County";
    g_SenderProfile.lpwstrTitle = L"Sender Title";
    g_SenderProfile.lpwstrDepartment = L"Sender Department";
    g_SenderProfile.lpwstrOfficeLocation = L"Sender Office Location";
    g_SenderProfile.lpwstrHomePhone = L"Sender Home Phone";
    g_SenderProfile.lpwstrOfficePhone = L"Sender Office Phone";
    g_SenderProfile.lpwstrEmail = L"Sender EMail";
    //g_SenderProfile.lpwstrInternetMail = L"Sender International Mail";
    g_SenderProfile.lpwstrBillingCode = L"Sender Billing Code";

    // set Recipient profile to default values
    g_RecipientProfile.dwSizeOfStruct = sizeof(FSPI_PERSONAL_PROFILE);
    g_RecipientProfile.lpwstrName = L"Recipient Name";
    g_RecipientProfile.lpwstrFaxNumber = L"Recipient Fax Number";
    g_RecipientProfile.lpwstrCompany = L"Recipient Company";
    g_RecipientProfile.lpwstrStreetAddress = L"Recipient Street Address";
    g_RecipientProfile.lpwstrCity = L"Recipient City";
    g_RecipientProfile.lpwstrState = L"Recipient State";
    g_RecipientProfile.lpwstrZip = L"Recipient Zip";
    g_RecipientProfile.lpwstrCountry = L"Recipient County";
    g_RecipientProfile.lpwstrTitle = L"Recipient Title";
    g_RecipientProfile.lpwstrDepartment = L"Recipient Department";
    g_RecipientProfile.lpwstrOfficeLocation = L"Recipient Office Location";
    g_RecipientProfile.lpwstrHomePhone = L"Recipient Home Phone";
    g_RecipientProfile.lpwstrOfficePhone = L"Recipient Office Phone";
    g_RecipientProfile.lpwstrEmail = L"Recipient EMail";
    //g_RecipientProfile.lpwstrInternetMail = L"Recipient International Mail";
    g_RecipientProfile.lpwstrBillingCode = L"Recipient Billing Code";

	// set time to send info to default values
    g_tmSentTime.wYear = 2000;
    g_tmSentTime.wMonth = 1;
    g_tmSentTime.wDayOfWeek = 2;
    g_tmSentTime.wDay = 26;
    g_tmSentTime.wHour = 12;
    g_tmSentTime.wMinute = 24;
    g_tmSentTime.wSecond = 9;
    g_tmSentTime.wMilliseconds = 55;

	// set branding info to default values
    g_BrandingInfo.dwSizeOfStruct = sizeof(FSPI_BRAND_INFO);
    g_BrandingInfo.lptstrSenderTsid = L"{Branding Sender Tsid}";
    g_BrandingInfo.lptstrRecipientPhoneNumber = L"{Branding Recipient Phone Number}";
    g_BrandingInfo.lptstrSenderCompany = L"{Branding Sender Company}";
    g_BrandingInfo.tmDateTime = g_tmSentTime;

}

//
// SetGlobalStructsToLongStrings:
//
void SetGlobalStructsToLongStrings( void )
{
    // set CoverPageInfo to default values
    g_CoverPageInfo.dwSizeOfStruct = sizeof(FSPI_COVERPAGE_INFO);
    g_CoverPageInfo.dwCoverPageFormat = FSPI_COVER_PAGE_FMT_COV;
    g_CoverPageInfo.lpwstrCoverPageFileName = ALL_FIELDS_CP;
    g_CoverPageInfo.dwNumberOfPages = 555;
    g_CoverPageInfo.lpwstrNote = L"very very very very very very very very very very very very long note\nvery very very very very very very very very very very very long note\nvery very very very very very very very very very very very long note";
    g_CoverPageInfo.lpwstrSubject= L"very very very very very very very very very very very very long subject";

    // set Sender profile to default values
    g_SenderProfile.dwSizeOfStruct = sizeof(FSPI_PERSONAL_PROFILE);
    g_SenderProfile.lpwstrName = L"very very very very very very very very very very very very long Sender Name";
    g_SenderProfile.lpwstrFaxNumber = L"very very very very very very very very very very very very long Sender Fax Number";
    g_SenderProfile.lpwstrCompany = L"very very very very very very very very very very very very long Sender Company";
    g_SenderProfile.lpwstrStreetAddress = L"very very very very very very very very very very very very long Sender Street Address";
    g_SenderProfile.lpwstrCity = L"very very very very very very very very very very very very long Sender City";
    g_SenderProfile.lpwstrState = L"very very very very very very very very very very very very long Sender State";
    g_SenderProfile.lpwstrZip = L"very very very very very very very very very very very very long Sender Zip";
    g_SenderProfile.lpwstrCountry = L"very very very very very very very very very very very very long Sender County";
    g_SenderProfile.lpwstrTitle = L"very very very very very very very very very very very very long Sender Title";
    g_SenderProfile.lpwstrDepartment = L"very very very very very very very very very very very very long Sender Department";
    g_SenderProfile.lpwstrOfficeLocation = L"very very very very very very very very very very very very long Sender Office Location";
    g_SenderProfile.lpwstrHomePhone = L"very very very very very very very very very very very very long Sender Home Phone";
    g_SenderProfile.lpwstrOfficePhone = L"very very very very very very very very very very very very long Sender Office Phone";
    g_SenderProfile.lpwstrEmail = L"very very very very very very very very very very very very long Sender EMail";
    //g_SenderProfile.lpwstrInternetMail = L"very very very very very very very very very very very very long Sender International Mail";
    g_SenderProfile.lpwstrBillingCode = L"very very very very very very very very very very very very long Sender Billing Code";

    // set Recipient profile to default values
    g_RecipientProfile.dwSizeOfStruct = sizeof(FSPI_PERSONAL_PROFILE);
    g_RecipientProfile.lpwstrName = L"very very very very very very very very very very very very long Recipient Name";
    g_RecipientProfile.lpwstrFaxNumber = L"very very very very very very very very very very very very long Recipient Fax Number";
    g_RecipientProfile.lpwstrCompany = L"very very very very very very very very very very very very long Recipient Company";
    g_RecipientProfile.lpwstrStreetAddress = L"very very very very very very very very very very very very long Recipient Street Address";
    g_RecipientProfile.lpwstrCity = L"very very very very very very very very very very very very long Recipient City";
    g_RecipientProfile.lpwstrState = L"very very very very very very very very very very very very long Recipient State";
    g_RecipientProfile.lpwstrZip = L"very very very very very very very very very very very very long Recipient Zip";
    g_RecipientProfile.lpwstrCountry = L"very very very very very very very very very very very very long Recipient County";
    g_RecipientProfile.lpwstrTitle = L"very very very very very very very very very very very very long Recipient Title";
    g_RecipientProfile.lpwstrDepartment = L"very very very very very very very very very very very very long Recipient Department";
    g_RecipientProfile.lpwstrOfficeLocation = L"very very very very very very very very very very very very long Recipient Office Location";
    g_RecipientProfile.lpwstrHomePhone = L"very very very very very very very very very very very very long Recipient Home Phone";
    g_RecipientProfile.lpwstrOfficePhone = L"very very very very very very very very very very very very long Recipient Office Phone";
    g_RecipientProfile.lpwstrEmail = L"very very very very very very very very very very very very long Recipient EMail";
    //g_RecipientProfile.lpwstrInternetMail = L"very very very very very very very very very very very very long Recipient International Mail";
    g_RecipientProfile.lpwstrBillingCode = L"very very very very very very very very very very very very long Recipient Billing Code";

	// set time to send info to default values
    g_tmSentTime.wYear = 2000;
    g_tmSentTime.wMonth = 1;
    g_tmSentTime.wDayOfWeek = 2;
    g_tmSentTime.wDay = 26;
    g_tmSentTime.wHour = 12;
    g_tmSentTime.wMinute = 24;
    g_tmSentTime.wSecond = 9;
    g_tmSentTime.wMilliseconds = 55;

	// set branding info to default values
    g_BrandingInfo.dwSizeOfStruct = sizeof(FSPI_BRAND_INFO);
    g_BrandingInfo.lptstrSenderTsid = L"{very very very very very very very very very very very very long Branding Sender Tsid}";
    g_BrandingInfo.lptstrRecipientPhoneNumber = L"{very very very very very very very very very very very very long Branding Recipient Phone Number}";
    g_BrandingInfo.lptstrSenderCompany = L"{very very very very very very very very very very very very long Branding Sender Company}";
    g_BrandingInfo.tmDateTime = g_tmSentTime;

}

//
// TestSuiteSetup:
//
BOOL TestSuiteSetup(void)
{

	BOOL				fRetVal = FALSE;
	CFilenameVector*	pTargetCpDirFileVec = NULL;
	UINT uSize = 0;
	UINT i = 0;

	//
	// Init logger
	//
	if (!::lgInitializeLogger())
	{
		::_tprintf(TEXT("FILE:%s LINE:%d [TestSuiteSetup]\nlgInitializeLogger failed with GetLastError()=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	//
	// Begin test suite (logger)
	//
	if(!::lgBeginSuite(TEXT("FaxRenderCoverPage() API test suite")))
	{
		::_tprintf(TEXT("FILE:%s LINE:%d [TestSuiteSetup]\nlgBeginSuite failed with GetLastError()=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	//
	// Delete any previous target tif files
	//
	if (FALSE == ::GetTiffFilesOfDir(TARGET_CP_DIR, &pTargetCpDirFileVec))
	{
		goto ExitFunc;
	}
	// first make sure all files are not readonly (some tests create such files)
	uSize = pTargetCpDirFileVec->size();
	for (i = 0; i < uSize; i++)
	{
		if (FALSE == ::SetFileAttributes(pTargetCpDirFileVec->at(i), FILE_ATTRIBUTE_NORMAL))
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("FILE:%s LINE:%d [TestSuiteSetup]\nSetFileAttributes(%s) failed with ec=0x%08X"),
				TEXT(__FILE__),
				__LINE__,
				pTargetCpDirFileVec->at(i),
				::GetLastError()
				);
			goto ExitFunc;
		}
	}
	// delete
	if (FALSE == ::DeleteVectorFiles(pTargetCpDirFileVec))
	{
		goto ExitFunc;
	}


    ResetGlobalStructs();
    g_CheckSpecificHrValues = TRUE;

	//
	// make sure the cover page files we use in tests exist
	//
	if (FALSE == ::DoesFileExist(g_CoverPageInfo.lpwstrCoverPageFileName))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d [TestSuiteSetup]\nInternal Error: Cover Page file (%s) for tests does not exist"),
			TEXT(__FILE__),
			__LINE__,
			g_CoverPageInfo.lpwstrCoverPageFileName
			);
		goto ExitFunc;
	}

	if (FALSE == ::DoesFileExist(NO_SUBJECT_NO_NOTE_CP))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d [TestSuiteSetup]\nInternal Error: Cover Page file (%s) used for tests does not exist"),
			TEXT(__FILE__),
			__LINE__,
			NO_SUBJECT_NO_NOTE_CP
			);
		goto ExitFunc;
	}

	//
	// make sure the body files we use in tests exist
	//
	if (FALSE == ::DoesFileExist(NO_COMPRESSION_BODY_TIF))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d [TestSuiteSetup]\nInternal Error: Body file (%s) for tests does not exist"),
			TEXT(__FILE__),
			__LINE__,
			NO_COMPRESSION_BODY_TIF
			);
		goto ExitFunc;
	}

	if (FALSE == ::DoesFileExist(MH_COMPRESSION_BODY_TIF))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d [TestSuiteSetup]\nInternal Error: Body file (%s) for tests does not exist"),
			TEXT(__FILE__),
			__LINE__,
			MH_COMPRESSION_BODY_TIF
			);
		goto ExitFunc;
	}

	if (FALSE == ::DoesFileExist(TEST_BODY_TIF))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d [TestSuiteSetup]\nInternal Error: Body file (%s) for tests does not exist"),
			TEXT(__FILE__),
			__LINE__,
			TEST_BODY_TIF
			);
		goto ExitFunc;
	}

	if (FALSE == ::DoesFileExist(GOOD_TEST_BODY_TIF))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d [TestSuiteSetup]\nInternal Error: Body file (%s) for tests does not exist"),
			TEXT(__FILE__),
			__LINE__,
			GOOD_TEST_BODY_TIF
			);
		goto ExitFunc;
	}

	//
	// make sure other files we use in tests exist
	//
	if (FALSE == ::DoesFileExist(NON_COV_TEXT_FILE_TXT_EXT))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d [TestSuiteSetup]\nInternal Error: File (%s) used for tests does not exist"),
			TEXT(__FILE__),
			__LINE__,
			NON_COV_TEXT_FILE_TXT_EXT
			);
		goto ExitFunc;
	}

	if (FALSE == ::DoesFileExist(NON_COV_TEXT_FILE_COV_EXT))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d [TestSuiteSetup]\nInternal Error: File (%s) used for tests does not exist"),
			TEXT(__FILE__),
			__LINE__,
			NON_COV_TEXT_FILE_COV_EXT
			);
		goto ExitFunc;
	}

	if (FALSE == ::DoesFileExist(NON_TIF_TEXT_FILE_TXT_EXT))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d [TestSuiteSetup]\nInternal Error: File (%s) used for tests does not exist"),
			TEXT(__FILE__),
			__LINE__,
			NON_TIF_TEXT_FILE_TXT_EXT
			);
		goto ExitFunc;
	}

	if (FALSE == ::DoesFileExist(NON_TIF_TEXT_FILE_TIF_EXT))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d [TestSuiteSetup]\nInternal Error: File (%s) used for tests does not exist"),
			TEXT(__FILE__),
			__LINE__,
			NON_TIF_TEXT_FILE_TIF_EXT
			);
		goto ExitFunc;
	}

	fRetVal = TRUE;

ExitFunc:
	return(fRetVal);
}

//
// TestCaseBrand:
//
BOOL TestCaseBrand(
	IN  LPCTSTR				szFilenameToBrand,
	IN	LPCFSPI_BRAND_INFO	lpcBrandingInfo,
    IN  HRESULT             hrExpected,
    IN  BOOL                fCheckSpecificHrValue
	)
{

	BOOL fRetVal = FALSE;
    BOOL fExpectingFailure = FALSE;
    HRESULT hr = E_FAIL;

    // do test //
    hr = FaxBrandDocument(
                    szFilenameToBrand,
                    lpcBrandingInfo
                    );

    // check results //

    // expecting hrExpected
    fExpectingFailure = FAILED(hrExpected);

    if(fExpectingFailure)
    {
        if (FAILED(hr))
        {
            ::lgLogDetail(
                        LOG_X,
                        1,
                        TEXT("FaxBrandDocument returned failed hr as expected\n")
                        );
            if (fCheckSpecificHrValue)
            {
                if (hrExpected != hr)
                {
                    ::lgLogError(
                            LOG_SEV_1,
                            TEXT("FaxBrandDocument returned hr=0x%08X instead of hrExpected=0x%08X\n"),
                            hr,
                            hrExpected
                            );
                    fRetVal = FALSE;
                    goto ExitFunc;
                }
                ::lgLogDetail(
                            LOG_X,
                            1,
                            TEXT("FaxBrandDocument returned hr=0x%08X as expected\n"),
                            hrExpected
                            );
            }
            fRetVal = TRUE;
            goto ExitFunc;
        }
        else
        {
            // err - API succeeded when it should have failed
            ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FaxBrandDocument succeeded when it should have failed with hrExpected=0x%08X\n"),
                    hrExpected
					);
            fRetVal = FALSE;
            goto ExitFunc;
        }
    }
    else
    {
        // expecting success
        if (SUCCEEDED(hr))
        {
            ::lgLogDetail(
                        LOG_X,
                        1,
                        TEXT("FaxBrandDocument returned successfull hr as expected\n")
                        );
            fRetVal = TRUE;
            goto ExitFunc;
        }
        // err - API failed when it should have succeeded
        ::lgLogError(
                LOG_SEV_1,
                TEXT("FaxBrandDocument failed with hr=0x%08X when it should have succeeded\n"),
                hr
                );
        fRetVal = FALSE;
    }

ExitFunc:
	return(fRetVal);
}


//
// TestCase:
//
BOOL TestCase(
    IN  LPCTSTR                     szRenderedCoverpageFilename,
    IN  LPCFSPI_COVERPAGE_INFO      pCoverPageInfo,
    IN  LPCFSPI_PERSONAL_PROFILE    pRecipientProfile,
    IN  LPCFSPI_PERSONAL_PROFILE    pSenderProfile,
	IN	SYSTEMTIME					tmSentTime,
	IN	LPCTSTR						lpctstrBodyTiff,
    IN  HRESULT                     hrExpected,
    IN  BOOL                        fCheckSpecificHrValue
)
{

	BOOL fRetVal = FALSE;
    BOOL fExpectingFailure = FALSE;
    HRESULT hr = E_FAIL;

    // do test //
    hr = FaxRenderCoverPage(
                    szRenderedCoverpageFilename,
                    pCoverPageInfo,
                    pRecipientProfile,
                    pSenderProfile,
					tmSentTime,
					lpctstrBodyTiff
                    );

    // check results //

    // expecting hrExpected
    fExpectingFailure = FAILED(hrExpected);

    if(fExpectingFailure)
    {
        if (FAILED(hr))
        {
            ::lgLogDetail(
                        LOG_X,
                        1,
                        TEXT("FaxRenderCoverPage returned failed hr as expected\n")
                        );
            if (fCheckSpecificHrValue)
            {
                if (hrExpected != hr)
                {
                    ::lgLogError(
                            LOG_SEV_1,
                            TEXT("FaxRenderCoverPage returned hr=0x%08X instead of hrExpected=0x%08X\n"),
                            hr,
                            hrExpected
                            );
                    fRetVal = FALSE;
                    goto ExitFunc;
                }
                ::lgLogDetail(
                            LOG_X,
                            1,
                            TEXT("FaxRenderCoverPage returned hr=0x%08X as expected\n"),
                            hrExpected
                            );
            }
            fRetVal = TRUE;
            goto ExitFunc;
        }
        else
        {
            // err - API succeeded when it should have failed
            ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FaxRenderCoverPage succeeded when it should have failed with hrExpected=0x%08X\n"),
                    hrExpected
					);
            fRetVal = FALSE;
            goto ExitFunc;
        }
    }
    else
    {
        // expecting success
        if (SUCCEEDED(hr))
        {
            ::lgLogDetail(
                        LOG_X,
                        1,
                        TEXT("FaxRenderCoverPage returned successfull hr as expected\n")
                        );
            fRetVal = TRUE;
            goto ExitFunc;
        }
        // err - API failed when it should have succeeded
        ::lgLogError(
                LOG_SEV_1,
                TEXT("FaxRenderCoverPage failed with hr=0x%08X when it should have succeeded\n"),
                hr
                );
        fRetVal = FALSE;
    }

ExitFunc:
	return(fRetVal);
}


//
// TestCase1:
//
BOOL TestCase1( void )
{
    BOOL fRetVal = FALSE;

    ::lgBeginCase(
		1,
		TEXT("TC#1: FaxRenderCoverPage: NULL Target Filename\n")
		);

    ResetGlobalStructs();

	//
	// make sure cover page file exists
	//
    _ASSERTE(NULL != g_CoverPageInfo.lpwstrCoverPageFileName);
	if (FALSE == ::DoesFileExist(g_CoverPageInfo.lpwstrCoverPageFileName))
	{
		goto ExitFunc;
	}

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s and no body file to NULL target file\n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName
		);

    fRetVal = TestCase(
                    NULL, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile,
					g_tmSentTime,
					NULL,
                    HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER), //FSPI_E_INVALID_PARAM1,
                    g_CheckSpecificHrValues
                    );

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}

//
// TestCase2:
//
BOOL TestCase2(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_2;

    ::lgBeginCase(
		2,
		TEXT("TC#2: FaxRenderCoverPage: non-existent Target Filename\n")
		);

    ResetGlobalStructs();

	//
	// make sure target file does *not* exist
	//
    if (FALSE == ::DeleteFile(szRenderedCoverpageFilename))
    {
        ec = ::GetLastError();
        if ((ERROR_FILE_NOT_FOUND != ec) && (ERROR_PATH_NOT_FOUND != ec))
        {
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE(%s) LINE(%d):\nDeleteFile(%s) failed with err=0x%8X\n"),
			    TEXT(__FILE__),
			    __LINE__,
                szRenderedCoverpageFilename,
                ec
			    );
            _ASSERTE(FALSE);
			goto ExitFunc;
        }
    }
    else
    {
		::lgLogDetail(
			LOG_X,
			4,
			TEXT("FILE(%s) LINE(%d):\ndeleted file %s\n"),
			TEXT(__FILE__),
			__LINE__,
            szRenderedCoverpageFilename
			);
    }

	//
	// make sure cover page file exists
	//
    _ASSERTE(NULL != g_CoverPageInfo.lpwstrCoverPageFileName);
	if (FALSE == ::DoesFileExist(g_CoverPageInfo.lpwstrCoverPageFileName))
	{
		goto ExitFunc;
	}

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s and no body file to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					NULL,
                    FSPI_S_OK,
                    g_CheckSpecificHrValues
                    );

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}

//
// TestCase3:
//
BOOL TestCase3(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_3;

    ::lgBeginCase(
		3,
		TEXT("TC#3: FaxRenderCoverPage: existent Target Filename\n")
		);

    ResetGlobalStructs();

	//
	// make sure target file exists
	//
    if (FALSE == ::CopyFile(DUMMY_CP_FILENAME, szRenderedCoverpageFilename, FALSE))
    {
        ec = ::GetLastError();
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\nCopyFile(%s, %s, FALSE) failed with err=0x%8X\n"),
			TEXT(__FILE__),
			__LINE__,
            DUMMY_CP_FILENAME,
            szRenderedCoverpageFilename,
            ec
			);
        _ASSERTE(FALSE);
		goto ExitFunc;
    }
    else
    {
		::lgLogDetail(
			LOG_X,
			4,
			TEXT("FILE(%s) LINE(%d):\ncopied file %s to %s\n"),
			TEXT(__FILE__),
			__LINE__,
            DUMMY_CP_FILENAME,
            szRenderedCoverpageFilename
			);
    }

	//
	// make sure cover page file exists
	//
    _ASSERTE(NULL != g_CoverPageInfo.lpwstrCoverPageFileName);
	if (FALSE == ::DoesFileExist(g_CoverPageInfo.lpwstrCoverPageFileName))
	{
		goto ExitFunc;
	}

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s and no body file to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					NULL,
                    FSPI_S_OK,
                    g_CheckSpecificHrValues
                    );

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}

//
// TestCase4:
//
BOOL TestCase4(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_4;
	DWORD dwFileAttributes = 0;

    ::lgBeginCase(
		4,
		TEXT("TC#4: FaxRenderCoverPage: existent Target Filename (lpctstrTargetFile) with read only access\n")
		);

    ResetGlobalStructs();


	//
	// make sure target file exists
	//
    if (FALSE == ::CopyFile(DUMMY_CP_FILENAME, szRenderedCoverpageFilename, FALSE))
    {
        ec = ::GetLastError();
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\nCopyFile(%s, %s, FALSE) failed with err=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
            DUMMY_CP_FILENAME,
            szRenderedCoverpageFilename,
            ec
			);
        _ASSERTE(FALSE);
		goto ExitFunc;
    }
    else
    {
		::lgLogDetail(
			LOG_X,
			4,
			TEXT("FILE(%s) LINE(%d):\ncopied file %s to %s\n"),
			TEXT(__FILE__),
			__LINE__,
            DUMMY_CP_FILENAME,
            szRenderedCoverpageFilename
			);
    }

	//
	// get the target file attributes
	//
	dwFileAttributes = ::GetFileAttributes(szRenderedCoverpageFilename);
	if(-1 == dwFileAttributes)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d [TestCase4_]\nGetFileAttributes(%s) failed with ec=0x%08X"),
			TEXT(__FILE__),
			__LINE__,
			szRenderedCoverpageFilename,
			::GetLastError()
			);
		goto ExitFunc;
	}

	//
	// set the target file to read only
	//
	dwFileAttributes = dwFileAttributes | FILE_ATTRIBUTE_READONLY;
	if (FALSE == ::SetFileAttributes(szRenderedCoverpageFilename, dwFileAttributes))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d [TestCase4_]\nSetFileAttributes(%s) failed with ec=0x%08X"),
			TEXT(__FILE__),
			__LINE__,
			szRenderedCoverpageFilename,
			::GetLastError()
			);
		goto ExitFunc;
	}
	
	//
	// make sure cover page file exists
	//
    _ASSERTE(NULL != g_CoverPageInfo.lpwstrCoverPageFileName);
	if (FALSE == ::DoesFileExist(g_CoverPageInfo.lpwstrCoverPageFileName))
	{
		goto ExitFunc;
	}

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s and no body file to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					NULL,
                    FSPI_E_CAN_NOT_WRITE_FILE,
                    g_CheckSpecificHrValues
                    );

	//
	// set the target file back to NOT read only
	//
	dwFileAttributes = dwFileAttributes & ~FILE_ATTRIBUTE_READONLY;
	if (FALSE == ::SetFileAttributes(szRenderedCoverpageFilename, dwFileAttributes))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d [TestCase4_]\nSetFileAttributes(%s) failed with ec=0x%08X"),
			TEXT(__FILE__),
			__LINE__,
			szRenderedCoverpageFilename,
			::GetLastError()
			);
		goto ExitFunc;
	}

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}

//
// TestCase5:
//
BOOL TestCase5(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_5;

    ::lgBeginCase(
		5,
		TEXT("TC#5: FaxRenderCoverPage: NULL sender and recipient profiles (no body file)\n")
		);

    ResetGlobalStructs();

	//
	// make sure cover page file exists
	//
    _ASSERTE(NULL != g_CoverPageInfo.lpwstrCoverPageFileName);
	if (FALSE == ::DoesFileExist(g_CoverPageInfo.lpwstrCoverPageFileName))
	{
		goto ExitFunc;
	}

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s and no body file to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    NULL, 
                    NULL, 
					g_tmSentTime,
					NULL,
                    FSPI_S_OK,
                    g_CheckSpecificHrValues
                    );

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}


BOOL TestCase6(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_6;
	FSPI_PERSONAL_PROFILE SenderProfile = {0};
	FSPI_PERSONAL_PROFILE RecipientProfile = {0};

    ::lgBeginCase(
		6,
		TEXT("TC#6: FaxRenderCoverPage: sender and recipient profiles (lpRecipientProfile, lpSenderProfile) with NULL struct members (with body file)\n")
		);

    ResetGlobalStructs();
	SenderProfile.dwSizeOfStruct = sizeof(FSPI_PERSONAL_PROFILE);
	RecipientProfile.dwSizeOfStruct = sizeof(FSPI_PERSONAL_PROFILE);

	//
	// make sure cover page file exists
	//
    _ASSERTE(NULL != g_CoverPageInfo.lpwstrCoverPageFileName);
	if (FALSE == ::DoesFileExist(g_CoverPageInfo.lpwstrCoverPageFileName))
	{
		goto ExitFunc;
	}

	//
	// make sure body file exists
	//
	if (FALSE == ::DoesFileExist(TEST_BODY_TIF))
	{
		goto ExitFunc;
	}


    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s with body file %s to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
		TEST_BODY_TIF,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &RecipientProfile, 
                    &SenderProfile, 
					g_tmSentTime,
					TEST_BODY_TIF,
                    FSPI_S_OK,
                    g_CheckSpecificHrValues
                    );

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase7(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_7;

    ::lgBeginCase(
		7,
		TEXT("TC#7: FaxRenderCoverPage: sender and recipient profiles (lpRecipientProfile, lpSenderProfile) with very long string struct members (with body)\n")
		);

    SetGlobalStructsToLongStrings();

	//
	// make sure cover page file exists
	//
    _ASSERTE(NULL != g_CoverPageInfo.lpwstrCoverPageFileName);
	if (FALSE == ::DoesFileExist(g_CoverPageInfo.lpwstrCoverPageFileName))
	{
		goto ExitFunc;
	}

	//
	// make sure body file exists
	//
	if (FALSE == ::DoesFileExist(TEST_BODY_TIF))
	{
		goto ExitFunc;
	}

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s with body file %s to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
		TEST_BODY_TIF,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					TEST_BODY_TIF,
                    FSPI_S_OK,
                    g_CheckSpecificHrValues
                    );

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase8(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_8;

    ::lgBeginCase(
		8,
		TEXT("TC#8: FaxRenderCoverPage: sender and recipient profiles (lpRecipientProfile, lpSenderProfile) with invalid dwSizeOfStruct\n")
		);

    ResetGlobalStructs();
	g_RecipientProfile.dwSizeOfStruct = 0;
	g_SenderProfile.dwSizeOfStruct = 0;

	//
	// make sure cover page file exists
	//
    _ASSERTE(NULL != g_CoverPageInfo.lpwstrCoverPageFileName);
	if (FALSE == ::DoesFileExist(g_CoverPageInfo.lpwstrCoverPageFileName))
	{
		goto ExitFunc;
	}

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s with no body file to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					NULL,
                    HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER), //FSPI_E_INVALID_PARAMETER,
                    g_CheckSpecificHrValues
                    );

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}

//
// TestCase9:
//
BOOL TestCase9(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_9;

    ::lgBeginCase(
		9,
		TEXT("TC#9: FaxRenderCoverPage: non-existent CP filename\n")
		);

    ResetGlobalStructs();

	//
	// make sure that NO_SUCH_CP doesn't exist
	//
    if (FALSE == ::DeleteFile(NO_SUCH_CP))
    {
        ec = ::GetLastError();
        if ((ERROR_FILE_NOT_FOUND != ec) && (ERROR_PATH_NOT_FOUND != ec))
        {
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE(%s) LINE(%d):\nDeleteFile(%s) failed with err=0x%8X\n"),
			    TEXT(__FILE__),
			    __LINE__,
                NO_SUCH_CP,
                ec
			    );
            _ASSERTE(FALSE);
			goto ExitFunc;
        }
    }
    else
    {
		::lgLogDetail(
			LOG_X,
			4,
			TEXT("FILE(%s) LINE(%d):\ndeleted file %s\n"),
			TEXT(__FILE__),
			__LINE__,
            NO_SUCH_CP
			);
    }

    g_CoverPageInfo.lpwstrCoverPageFileName = ::wcsdup(NO_SUCH_CP);
    if (NULL == g_CoverPageInfo.lpwstrCoverPageFileName)
    {
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\nwcsdup failed with err=0x%8X\n"),
			TEXT(__FILE__),
			__LINE__,
            ::GetLastError()
			);
        _ASSERTE(FALSE);
		goto ExitFunc;
    }

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					TEST_BODY_TIF,
                    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND), 
                    g_CheckSpecificHrValues
                    );

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}


BOOL TestCase10(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_10;

    ::lgBeginCase(
		10,
		TEXT("TC#10: FaxRenderCoverPage: invalid lpCoverPageInfo.dwSizeOfStruct\n")
		);

    ResetGlobalStructs();
	g_CoverPageInfo.dwSizeOfStruct = 0;

	//
	// make sure cover page file exists
	//
    _ASSERTE(NULL != g_CoverPageInfo.lpwstrCoverPageFileName);
	if (FALSE == ::DoesFileExist(g_CoverPageInfo.lpwstrCoverPageFileName))
	{
		goto ExitFunc;
	}

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s with no body file to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					NULL,
                    HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER), //FSPI_E_INVALID_PARAMETER,
                    g_CheckSpecificHrValues
                    );

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase11(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_11;

    ::lgBeginCase(
		11,
		TEXT("TC#11: FaxRenderCoverPage: invalid lpCoverPageInfo.dwCoverPageFormat\n")
		);

    ResetGlobalStructs();
	g_CoverPageInfo.dwCoverPageFormat = FSPI_COVER_PAGE_FMT_COV + 1;

	//
	// make sure cover page file exists
	//
    _ASSERTE(NULL != g_CoverPageInfo.lpwstrCoverPageFileName);
	if (FALSE == ::DoesFileExist(g_CoverPageInfo.lpwstrCoverPageFileName))
	{
		goto ExitFunc;
	}

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s with no body file to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					NULL,
                    HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER), //FSPI_E_INVALID_PARAMETER,
                    g_CheckSpecificHrValues
                    );

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase12(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_12;

    ::lgBeginCase(
		12,
		TEXT("TC#12: FaxRenderCoverPage: NULL lpCoverPageInfo\n")
		);

    ResetGlobalStructs();

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render lpCoverPageInfo=NULL with no body file to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    NULL, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					NULL,
                    HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER), //FSPI_E_INVALID_PARAMETER,
                    g_CheckSpecificHrValues
                    );

	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase13(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_13;

    ::lgBeginCase(
		13,
		TEXT("TC#13: FaxRenderCoverPage: NULL lpCoverPageInfo.lpwstrCoverPageFileName\n")
		);

    ResetGlobalStructs();
	g_CoverPageInfo.lpwstrCoverPageFileName = NULL;

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s with no body file to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					NULL,
                    HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER), //FSPI_E_INVALID_PARAMETER,
                    g_CheckSpecificHrValues
                    );

	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase14(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_14;

    ::lgBeginCase(
		14,
		TEXT("TC#14: FaxRenderCoverPage: existent lpCoverPageInfo.lpwstrCoverPageFileName that isn't a *.cov file (e.g. NonCovTxtFile.txt)\n")
		);

    ResetGlobalStructs();
	g_CoverPageInfo.lpwstrCoverPageFileName = NON_COV_TEXT_FILE_TXT_EXT;

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s with no body file to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					NULL,
                    HRESULT_FROM_WIN32(ERROR_BAD_FORMAT), 
                    g_CheckSpecificHrValues
                    );

	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase15(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_15;

    ::lgBeginCase(
		15,
		TEXT("TC#15: FaxRenderCoverPage: existent lpCoverPageInfo.lpwstrCoverPageFileName that isn't a *.cov file but has a *.cov extension (e.g. NonCovTxtFile.cov)\n")
		);

    ResetGlobalStructs();
	g_CoverPageInfo.lpwstrCoverPageFileName = NON_COV_TEXT_FILE_COV_EXT;

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s with no body file to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					NULL,
                    HRESULT_FROM_WIN32(ERROR_BAD_FORMAT), 
                    g_CheckSpecificHrValues
                    );

	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase16(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_16;

    ::lgBeginCase(
		16,
		TEXT("TC#16: FaxRenderCoverPage:  lpCoverPageInfo.dwNumberOfPages=0\n")
		);

    ResetGlobalStructs();
	g_CoverPageInfo.dwNumberOfPages = 0;

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s with no body file to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					NULL,
                    FSPI_S_OK,
                    g_CheckSpecificHrValues
                    );

	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase17(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_17;

    ::lgBeginCase(
		17,
		TEXT("TC#17: FaxRenderCoverPage: lpCoverPageInfo.dwNumberOfPages=MAXDWORD\n")
		);

    ResetGlobalStructs();
	g_CoverPageInfo.dwNumberOfPages = MAXDWORD;

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s with no body file to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					NULL,
                    FSPI_S_OK,
                    g_CheckSpecificHrValues
                    );

	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase18(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_18;

    ::lgBeginCase(
		18,
		TEXT("TC#18: FaxRenderCoverPage:lpCoverPageInfo.lpwstrNote=NULL and lpCoverPageInfo.lpwstrSubject!=NULL with cover page that has both\n")
		);

    ResetGlobalStructs();
	g_CoverPageInfo.lpwstrNote = NULL;

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s with no body file to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					NULL,
                    FSPI_S_OK,
                    g_CheckSpecificHrValues
                    );

	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase19(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_19;

    ::lgBeginCase(
		19,
		TEXT("TC#19: FaxRenderCoverPage:lpCoverPageInfo.lpwstrNote!=NULL and lpCoverPageInfo.lpwstrSubject=NULL with cover page that has both\n")
		);

    ResetGlobalStructs();
	g_CoverPageInfo.lpwstrSubject = NULL;

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s with no body file to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					NULL,
                    FSPI_S_OK,
                    g_CheckSpecificHrValues
                    );

	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase20(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_20;

    ::lgBeginCase(
		20,
		TEXT("TC#20: FaxRenderCoverPage:lpCoverPageInfo.lpwstrNote=NULL and lpCoverPageInfo.lpwstrSubject=NULL with cover page that has both\n")
		);

    ResetGlobalStructs();
	g_CoverPageInfo.lpwstrNote = NULL;
	g_CoverPageInfo.lpwstrSubject = NULL;

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s with no body file to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					NULL,
                    FSPI_S_OK,
                    g_CheckSpecificHrValues
                    );

	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase21(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_21;

    ::lgBeginCase(
		21,
		TEXT("TC#21: FaxRenderCoverPage: lpCoverPageInfo.lpwstrNote!=NULL and lpCoverPageInfo.lpwstrSubject!=NULL with cover page that has neither\n")
		);

    ResetGlobalStructs();
	g_CoverPageInfo.lpwstrCoverPageFileName = NO_SUBJECT_NO_NOTE_CP;

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s with no body file to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					NULL,
                    FSPI_S_OK,
                    g_CheckSpecificHrValues
                    );

	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase22(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_22;
	SYSTEMTIME tmSentTime = {0};

    ::lgBeginCase(
		22,
		TEXT("TC#22: FaxRenderCoverPage: tmSentTime = {0}\n")
		);

    ResetGlobalStructs();

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s with no body file to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					tmSentTime,
					NULL,
                    HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER), 
                    g_CheckSpecificHrValues
                    );

	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase23(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_23;

    ::lgBeginCase(
		23,
		TEXT("TC#23: FaxRenderCoverPage: lpctstrBodyTiff = NULL\n")
		);

    ResetGlobalStructs();

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s with NULL body file to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					NULL,
                    FSPI_S_OK,
                    g_CheckSpecificHrValues
                    );

	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase24(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_24;

    ::lgBeginCase(
		24,
		TEXT("TC#24: FaxRenderCoverPage: non-existent lpctstrBodyTiff != NULL\n")
		);

    ResetGlobalStructs();

	//
	// make sure body file does *not* exist
	//
    if (FALSE == ::DeleteFile(NON_EXISTENT_BODY_FILENAME))
    {
        ec = ::GetLastError();
        if ((ERROR_FILE_NOT_FOUND != ec) && (ERROR_PATH_NOT_FOUND != ec))
        {
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE(%s) LINE(%d):\nDeleteFile(%s) failed with err=0x%8X\n"),
			    TEXT(__FILE__),
			    __LINE__,
                NON_EXISTENT_BODY_FILENAME,
                ec
			    );
            _ASSERTE(FALSE);
			goto ExitFunc;
        }
    }
    else
    {
		::lgLogDetail(
			LOG_X,
			4,
			TEXT("FILE(%s) LINE(%d):\ndeleted file %s\n"),
			TEXT(__FILE__),
			__LINE__,
            NON_EXISTENT_BODY_FILENAME
			);
    }

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s with body file %s to file %s\n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
		NON_EXISTENT_BODY_FILENAME,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					NON_EXISTENT_BODY_FILENAME,
                    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND), 
                    g_CheckSpecificHrValues
                    );

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase25(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_25;

    ::lgBeginCase(
		25,
		TEXT("TC#25: FaxRenderCoverPage: existent lpctstrBodyTiff that isn't a TIFF file (e.g. NonTiffTxtFile.txt)\n")
		);

    ResetGlobalStructs();

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s with body file %s to file %s\n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
		NON_TIF_TEXT_FILE_TXT_EXT,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					NON_TIF_TEXT_FILE_TXT_EXT,
                    HRESULT_FROM_WIN32(ERROR_BAD_FORMAT), 
                    g_CheckSpecificHrValues
                    );

	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase26(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_26;

    ::lgBeginCase(
		26,
		TEXT("TC#26: FaxRenderCoverPage: existent lpctstrBodyTiff that isn't a TIFF file but has a TIF extension (e.g. NonTiffTxtFile.tif)\n")
		);

    ResetGlobalStructs();

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s with body file %s to file %s\n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
		NON_TIF_TEXT_FILE_TIF_EXT,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					NON_TIF_TEXT_FILE_TIF_EXT,
                    HRESULT_FROM_WIN32(ERROR_BAD_FORMAT), 
                    g_CheckSpecificHrValues
                    );

	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase27(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_27;

    ::lgBeginCase(
		27,
		TEXT("TC#27: FaxRenderCoverPage: good test case without merge (lpctstrBodyTiff = NULL)\n")
		);

    ResetGlobalStructs();

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s with no body file to file %s\n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					NULL,
                    FSPI_S_OK, 
                    g_CheckSpecificHrValues
                    );

	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase28(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_28;

    ::lgBeginCase(
		28,
		TEXT("TC#28: FaxRenderCoverPage: good test case with merge (existent non-compressed lpctstrBodyTiff)\n")
		);

    ResetGlobalStructs();

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s with body file %s to file %s\n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
		NO_COMPRESSION_BODY_TIF,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					NO_COMPRESSION_BODY_TIF,
                    FSPI_S_OK, 
                    g_CheckSpecificHrValues
                    );

	::lgEndCase();
    return(fRetVal);
}

/////////////////////////////////////////////////////////////////////////////
//
// FaxBrandDocument test cases
//
/////////////////////////////////////////////////////////////////////////////

BOOL TestCase29(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;

    ::lgBeginCase(
		29,
		TEXT("TC#29: FaxRenderCoverPage: non-existent filename (lpctstrFie)\n")
		);

    ResetGlobalStructs();

	//
	// make sure body file does *not* exist
	//
    if (FALSE == ::DeleteFile(NON_EXISTENT_BODY_FILENAME))
    {
        ec = ::GetLastError();
        if ((ERROR_FILE_NOT_FOUND != ec) && (ERROR_PATH_NOT_FOUND != ec))
        {
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE(%s) LINE(%d):\nDeleteFile(%s) failed with err=0x%8X\n"),
			    TEXT(__FILE__),
			    __LINE__,
                NON_EXISTENT_BODY_FILENAME,
                ec
			    );
            _ASSERTE(FALSE);
			goto ExitFunc;
        }
    }
    else
    {
		::lgLogDetail(
			LOG_X,
			4,
			TEXT("FILE(%s) LINE(%d):\ndeleted file %s\n"),
			TEXT(__FILE__),
			__LINE__,
            NON_EXISTENT_BODY_FILENAME
			);
    }

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to brand body file %s\n"),
		TEXT(__FILE__),
		__LINE__,
        NON_EXISTENT_BODY_FILENAME
		);

	fRetVal = TestCaseBrand(
					NON_EXISTENT_BODY_FILENAME,
					&g_BrandingInfo,
					HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND), 
					g_CheckSpecificHrValues
					);

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase30(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;

    ::lgBeginCase(
		30,
		TEXT("TC#30: FaxBrandDocument: NULL filename (lpctstrFie)\n")
		);

    ResetGlobalStructs();

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to brand NULL body file \n"),
		TEXT(__FILE__),
		__LINE__
		);

	fRetVal = TestCaseBrand(
					NULL,
					&g_BrandingInfo,
					HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER), 
					g_CheckSpecificHrValues
					);

	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase31(void)
{
    BOOL	fRetVal = FALSE;
    DWORD	ec = S_OK;
	LPCTSTR szBrandedFilename = TARGET_BRAND_FILENAME_31;
	DWORD	dwFileAttributes = 0;

    ::lgBeginCase(
		31,
		TEXT("TC#31: FaxBrandDocument: existent read-only filename (lpctstrFie)\n")
		);

    ResetGlobalStructs();

	//
	// make sure body file exists
	//
    if (FALSE == ::CopyFile(GOOD_TEST_BODY_TIF, szBrandedFilename, FALSE))
    {
        ec = ::GetLastError();
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\nCopyFile(%s, %s, FALSE) failed with err=0x%8X\n"),
			TEXT(__FILE__),
			__LINE__,
            GOOD_TEST_BODY_TIF,
            szBrandedFilename,
            ec
			);
        _ASSERTE(FALSE);
		goto ExitFunc;
    }
    else
    {
		::lgLogDetail(
			LOG_X,
			4,
			TEXT("FILE(%s) LINE(%d):\ncopied file %s to %s\n"),
			TEXT(__FILE__),
			__LINE__,
            GOOD_TEST_BODY_TIF,
            szBrandedFilename
			);
    }

	//
	// get the target file attributes
	//
	dwFileAttributes = ::GetFileAttributes(szBrandedFilename);
	if(-1 == dwFileAttributes)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\nGetFileAttributes(%s) failed with ec=0x%08X"),
			TEXT(__FILE__),
			__LINE__,
			szBrandedFilename,
			::GetLastError()
			);
		_ASSERTE(FALSE);
		goto ExitFunc;
	}

	//
	// set the target file to read only
	//
	dwFileAttributes = dwFileAttributes | FILE_ATTRIBUTE_READONLY;
	if (FALSE == ::SetFileAttributes(szBrandedFilename, dwFileAttributes))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\nSetFileAttributes(%s) failed with ec=0x%08X"),
			TEXT(__FILE__),
			__LINE__,
			szBrandedFilename,
			::GetLastError()
			);
		_ASSERTE(FALSE);
		goto ExitFunc;
	}
	
    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to brand body file %s\n"),
		TEXT(__FILE__),
		__LINE__,
        szBrandedFilename
		);

	fRetVal = TestCaseBrand(
					szBrandedFilename,
					&g_BrandingInfo,
					HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED), 
					g_CheckSpecificHrValues
					);

	//
	// set the target file back to NOT read only
	//
	dwFileAttributes = dwFileAttributes & ~FILE_ATTRIBUTE_READONLY;
	if (FALSE == ::SetFileAttributes(szBrandedFilename, dwFileAttributes))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\nSetFileAttributes(%s) failed with ec=0x%08X"),
			TEXT(__FILE__),
			__LINE__,
			szBrandedFilename,
			::GetLastError()
			);
		_ASSERTE(FALSE);
		goto ExitFunc;
	}

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase32(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szBrandedFilename = TARGET_BRAND_FILENAME_32;

    ::lgBeginCase(
		32,
		TEXT("TC#32: FaxBrandDocument: existent filename (lpctstrFie)\n")
		);

    ResetGlobalStructs();

	//
	// make sure body file exists
	//
    if (FALSE == ::CopyFile(GOOD_TEST_BODY_TIF, szBrandedFilename, FALSE))
    {
        ec = ::GetLastError();
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\nCopyFile(%s, %s, FALSE) failed with err=0x%8X\n"),
			TEXT(__FILE__),
			__LINE__,
            GOOD_TEST_BODY_TIF,
            szBrandedFilename,
            ec
			);
        _ASSERTE(FALSE);
		goto ExitFunc;
    }
    else
    {
		::lgLogDetail(
			LOG_X,
			4,
			TEXT("FILE(%s) LINE(%d):\ncopied file %s to %s\n"),
			TEXT(__FILE__),
			__LINE__,
            GOOD_TEST_BODY_TIF,
            szBrandedFilename
			);
    }

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to brand body file %s\n"),
		TEXT(__FILE__),
		__LINE__,
        szBrandedFilename
		);

	fRetVal = TestCaseBrand(
					szBrandedFilename,
					&g_BrandingInfo,
			        FSPI_S_OK,
					g_CheckSpecificHrValues
					);

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase33(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szBrandedFilename = TARGET_BRAND_FILENAME_33;

    ::lgBeginCase(
		33,
		TEXT("TC#33: FaxBrandDocument: NULL lpcBrandInfo\n")
		);

    ResetGlobalStructs();

	//
	// make sure body file exists
	//
    if (FALSE == ::CopyFile(GOOD_TEST_BODY_TIF, szBrandedFilename, FALSE))
    {
        ec = ::GetLastError();
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\nCopyFile(%s, %s, FALSE) failed with err=0x%8X\n"),
			TEXT(__FILE__),
			__LINE__,
            GOOD_TEST_BODY_TIF,
            szBrandedFilename,
            ec
			);
        _ASSERTE(FALSE);
		goto ExitFunc;
    }
    else
    {
		::lgLogDetail(
			LOG_X,
			4,
			TEXT("FILE(%s) LINE(%d):\ncopied file %s to %s\n"),
			TEXT(__FILE__),
			__LINE__,
            GOOD_TEST_BODY_TIF,
            szBrandedFilename
			);
    }

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to brand body file %s\n"),
		TEXT(__FILE__),
		__LINE__,
        szBrandedFilename
		);

	fRetVal = TestCaseBrand(
					szBrandedFilename,
					NULL,
					HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER), 
					g_CheckSpecificHrValues
					);

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase34(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szBrandedFilename = TARGET_BRAND_FILENAME_34;

    ::lgBeginCase(
		34,
		TEXT("TC#34: FaxBrandDocument: lpcBrandInfo with invalid dwSizeOfStruct\n")
		);

    ResetGlobalStructs();
	g_BrandingInfo.dwSizeOfStruct = 0;

	//
	// make sure body file exists
	//
    if (FALSE == ::CopyFile(GOOD_TEST_BODY_TIF, szBrandedFilename, FALSE))
    {
        ec = ::GetLastError();
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\nCopyFile(%s, %s, FALSE) failed with err=0x%8X\n"),
			TEXT(__FILE__),
			__LINE__,
            GOOD_TEST_BODY_TIF,
            szBrandedFilename,
            ec
			);
        _ASSERTE(FALSE);
		goto ExitFunc;
    }
    else
    {
		::lgLogDetail(
			LOG_X,
			4,
			TEXT("FILE(%s) LINE(%d):\ncopied file %s to %s\n"),
			TEXT(__FILE__),
			__LINE__,
            GOOD_TEST_BODY_TIF,
            szBrandedFilename
			);
    }

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to brand body file %s\n"),
		TEXT(__FILE__),
		__LINE__,
        szBrandedFilename
		);

	fRetVal = TestCaseBrand(
					szBrandedFilename,
					&g_BrandingInfo,
					HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER), 
					g_CheckSpecificHrValues
					);

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase35(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szBrandedFilename = TARGET_BRAND_FILENAME_35;

    ::lgBeginCase(
		35,
		TEXT("TC#35: FaxBrandDocument: lpcBrandInfo with NULL string members\n")
		);

    ResetGlobalStructs();
	g_BrandingInfo.lptstrSenderTsid = NULL;
	g_BrandingInfo.lptstrRecipientPhoneNumber = NULL;
	g_BrandingInfo.lptstrSenderCompany = NULL;

	//
	// make sure body file exists
	//
    if (FALSE == ::CopyFile(GOOD_TEST_BODY_TIF, szBrandedFilename, FALSE))
    {
        ec = ::GetLastError();
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\nCopyFile(%s, %s, FALSE) failed with err=0x%8X\n"),
			TEXT(__FILE__),
			__LINE__,
            GOOD_TEST_BODY_TIF,
            szBrandedFilename,
            ec
			);
        _ASSERTE(FALSE);
		goto ExitFunc;
    }
    else
    {
		::lgLogDetail(
			LOG_X,
			4,
			TEXT("FILE(%s) LINE(%d):\ncopied file %s to %s\n"),
			TEXT(__FILE__),
			__LINE__,
            GOOD_TEST_BODY_TIF,
            szBrandedFilename
			);
    }

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to brand body file %s\n"),
		TEXT(__FILE__),
		__LINE__,
        szBrandedFilename
		);

	fRetVal = TestCaseBrand(
					szBrandedFilename,
					&g_BrandingInfo,
					FSPI_S_OK, 
					g_CheckSpecificHrValues
					);

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase36(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szBrandedFilename = TARGET_BRAND_FILENAME_36;

    ::lgBeginCase(
		36,
		TEXT("TC#36: FaxBrandDocument: lpcBrandInfo with very long string members\n")
		);

    SetGlobalStructsToLongStrings();

	//
	// make sure body file exists
	//
    if (FALSE == ::CopyFile(GOOD_TEST_BODY_TIF, szBrandedFilename, FALSE))
    {
        ec = ::GetLastError();
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\nCopyFile(%s, %s, FALSE) failed with err=0x%8X\n"),
			TEXT(__FILE__),
			__LINE__,
            GOOD_TEST_BODY_TIF,
            szBrandedFilename,
            ec
			);
        _ASSERTE(FALSE);
		goto ExitFunc;
    }
    else
    {
		::lgLogDetail(
			LOG_X,
			4,
			TEXT("FILE(%s) LINE(%d):\ncopied file %s to %s\n"),
			TEXT(__FILE__),
			__LINE__,
            GOOD_TEST_BODY_TIF,
            szBrandedFilename
			);
    }

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to brand body file %s\n"),
		TEXT(__FILE__),
		__LINE__,
        szBrandedFilename
		);

	fRetVal = TestCaseBrand(
					szBrandedFilename,
					&g_BrandingInfo,
					FSPI_S_OK, 
					g_CheckSpecificHrValues
					);

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase37(void)
{
    BOOL		fRetVal = FALSE;
    DWORD		ec = S_OK;
	LPCTSTR		szBrandedFilename = TARGET_BRAND_FILENAME_37;
	SYSTEMTIME	tmZeroDateTime = {0};

    ::lgBeginCase(
		37,
		TEXT("TC#37: FaxBrandDocument: lpcBrandInfo.tmDateTime={0}\n")
		);

    ResetGlobalStructs();
	g_BrandingInfo.tmDateTime = tmZeroDateTime;

	//
	// make sure body file exists
	//
    if (FALSE == ::CopyFile(GOOD_TEST_BODY_TIF, szBrandedFilename, FALSE))
    {
        ec = ::GetLastError();
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\nCopyFile(%s, %s, FALSE) failed with err=0x%8X\n"),
			TEXT(__FILE__),
			__LINE__,
            GOOD_TEST_BODY_TIF,
            szBrandedFilename,
            ec
			);
        _ASSERTE(FALSE);
		goto ExitFunc;
    }
    else
    {
		::lgLogDetail(
			LOG_X,
			4,
			TEXT("FILE(%s) LINE(%d):\ncopied file %s to %s\n"),
			TEXT(__FILE__),
			__LINE__,
            GOOD_TEST_BODY_TIF,
            szBrandedFilename
			);
    }

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to brand body file %s\n"),
		TEXT(__FILE__),
		__LINE__,
        szBrandedFilename
		);

	fRetVal = TestCaseBrand(
					szBrandedFilename,
					&g_BrandingInfo,
					HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER), 
					g_CheckSpecificHrValues
					);

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase38(void)
{
    BOOL fRetVal = FALSE;
    DWORD ec = S_OK;
	LPCTSTR szBrandedFilename = TARGET_BRAND_FILENAME_38;

    ::lgBeginCase(
		38,
		TEXT("TC#38: FaxBrandDocument: existent filename (lpctstrFie) that is a TIF in MH compression\n")
		);

    ResetGlobalStructs();

	//
	// make sure body file exists
	//
    if (FALSE == ::CopyFile(MH_COMPRESSION_BODY_TIF, szBrandedFilename, FALSE))
    {
        ec = ::GetLastError();
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\nCopyFile(%s, %s, FALSE) failed with err=0x%8X\n"),
			TEXT(__FILE__),
			__LINE__,
            MH_COMPRESSION_BODY_TIF,
            szBrandedFilename,
            ec
			);
        _ASSERTE(FALSE);
		goto ExitFunc;
    }
    else
    {
		::lgLogDetail(
			LOG_X,
			4,
			TEXT("FILE(%s) LINE(%d):\ncopied file %s to %s\n"),
			TEXT(__FILE__),
			__LINE__,
            MH_COMPRESSION_BODY_TIF,
            szBrandedFilename
			);
    }

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to brand body file %s\n"),
		TEXT(__FILE__),
		__LINE__,
        szBrandedFilename
		);

	fRetVal = TestCaseBrand(
					szBrandedFilename,
					&g_BrandingInfo,
					FSPI_S_OK, 
					g_CheckSpecificHrValues
					);

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase39(void)
{
    BOOL fRetVal = FALSE;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_39;
	LPCTSTR szBrandedFilename = TARGET_BRAND_FILENAME_39;
    DWORD ec = S_OK;

    ::lgBeginCase(
		39,
		TEXT("TC#39: FaxRenderCoverPage: FaxBrandDocument: merge cp and body to non-existant Target Filename then brand\n")
		);

    ResetGlobalStructs();

    if (FALSE == ::DeleteFile(szRenderedCoverpageFilename))
    {
        ec = ::GetLastError();
        if ((ERROR_FILE_NOT_FOUND != ec) && (ERROR_PATH_NOT_FOUND != ec))
        {
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE(%s) LINE(%d):\nDeleteFile(%s) failed with err=0x%8X\n"),
			    TEXT(__FILE__),
			    __LINE__,
                szRenderedCoverpageFilename,
                ec
			    );
            _ASSERTE(FALSE);
			goto ExitFunc;
        }
    }
    else
    {
		::lgLogDetail(
			LOG_X,
			4,
			TEXT("FILE(%s) LINE(%d):\ndeleted file %s\n"),
			TEXT(__FILE__),
			__LINE__,
            szRenderedCoverpageFilename
			);
    }

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s and body file %s to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
		GOOD_TEST_BODY_TIF,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					GOOD_TEST_BODY_TIF,
                    FSPI_S_OK,
                    g_CheckSpecificHrValues
                    );

	if (FALSE == fRetVal)
	{
		goto ExitFunc;
	}

	//
	// make a copy of szRenderedCoverpageFilename
	// so we can later compare both the rendered result file
	// and the branded result file to our reference files
	//
    if (FALSE == ::CopyFile(szRenderedCoverpageFilename, szBrandedFilename, FALSE))
    {
        ec = ::GetLastError();
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\nCopyFile(%s, %s, FALSE) failed with err=0x%8X\n"),
			TEXT(__FILE__),
			__LINE__,
            szRenderedCoverpageFilename,
            szBrandedFilename,
            ec
			);
        _ASSERTE(FALSE);
		goto ExitFunc;
    }
    else
    {
		::lgLogDetail(
			LOG_X,
			4,
			TEXT("FILE(%s) LINE(%d):\ncopied file %s to %s\n"),
			TEXT(__FILE__),
			__LINE__,
            szRenderedCoverpageFilename,
            szBrandedFilename
			);
    }

	::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to brand file %s \n"),
		TEXT(__FILE__),
		__LINE__,
		szBrandedFilename
		);

	fRetVal = TestCaseBrand(
						szBrandedFilename,
						&g_BrandingInfo,
			            FSPI_S_OK,
						g_CheckSpecificHrValues
						);

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase40(void)
{
    BOOL fRetVal = FALSE;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_40;
	LPCTSTR szBrandedFilename = TARGET_BRAND_FILENAME_40;
    DWORD ec = S_OK;

    ::lgBeginCase(
		40,
		TEXT("TC#40: FaxRenderCoverPage: FaxBrandDocument: invoke FaxRenderCoverPage with all good params (with merge of a non-compressed TIF file with width>1728 pix) and then invoke FaxBrandDocument on the result.\n")
		);

    ResetGlobalStructs();

    if (FALSE == ::DeleteFile(szRenderedCoverpageFilename))
    {
        ec = ::GetLastError();
        if ((ERROR_FILE_NOT_FOUND != ec) && (ERROR_PATH_NOT_FOUND != ec))
        {
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE(%s) LINE(%d):\nDeleteFile(%s) failed with err=0x%8X\n"),
			    TEXT(__FILE__),
			    __LINE__,
                szRenderedCoverpageFilename,
                ec
			    );
            _ASSERTE(FALSE);
			goto ExitFunc;
        }
    }
    else
    {
		::lgLogDetail(
			LOG_X,
			4,
			TEXT("FILE(%s) LINE(%d):\ndeleted file %s\n"),
			TEXT(__FILE__),
			__LINE__,
            szRenderedCoverpageFilename
			);
    }

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s and body file %s to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
		NO_COMPRESSION_BODY_TIF,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					NO_COMPRESSION_BODY_TIF,
                    FSPI_S_OK,
                    g_CheckSpecificHrValues
                    );

	if (FALSE == fRetVal)
	{
		goto ExitFunc;
	}

	//
	// make a copy of szRenderedCoverpageFilename
	// so we can later compare both the rendered result file
	// and the branded result file to our reference files
	//
    if (FALSE == ::CopyFile(szRenderedCoverpageFilename, szBrandedFilename, FALSE))
    {
        ec = ::GetLastError();
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\nCopyFile(%s, %s, FALSE) failed with err=0x%8X\n"),
			TEXT(__FILE__),
			__LINE__,
            szRenderedCoverpageFilename,
            szBrandedFilename,
            ec
			);
        _ASSERTE(FALSE);
		goto ExitFunc;
    }
    else
    {
		::lgLogDetail(
			LOG_X,
			4,
			TEXT("FILE(%s) LINE(%d):\ncopied file %s to %s\n"),
			TEXT(__FILE__),
			__LINE__,
            szRenderedCoverpageFilename,
            szBrandedFilename
			);
    }

	::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to brand file %s \n"),
		TEXT(__FILE__),
		__LINE__,
		szBrandedFilename
		);

	fRetVal = TestCaseBrand(
						szBrandedFilename,
						&g_BrandingInfo,
			            FSPI_S_OK,
						g_CheckSpecificHrValues
						);

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase41(void)
{
    BOOL fRetVal = FALSE;
	LPCTSTR szRenderedCoverpageFilename = TARGET_CP_FILENAME_41;
	LPCTSTR szBrandedFilename = TARGET_BRAND_FILENAME_41;
    DWORD ec = S_OK;

    ::lgBeginCase(
		41,
		TEXT("TC#41: FaxRenderCoverPage: FaxBrandDocument: invoke FaxRenderCoverPage with all good params (with merge of an MH compressed TIF file) and then invoke FaxBrandDocument on the result.\n")
		);

    ResetGlobalStructs();

    if (FALSE == ::DeleteFile(szRenderedCoverpageFilename))
    {
        ec = ::GetLastError();
        if ((ERROR_FILE_NOT_FOUND != ec) && (ERROR_PATH_NOT_FOUND != ec))
        {
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE(%s) LINE(%d):\nDeleteFile(%s) failed with err=0x%8X\n"),
			    TEXT(__FILE__),
			    __LINE__,
                szRenderedCoverpageFilename,
                ec
			    );
            _ASSERTE(FALSE);
			goto ExitFunc;
        }
    }
    else
    {
		::lgLogDetail(
			LOG_X,
			4,
			TEXT("FILE(%s) LINE(%d):\ndeleted file %s\n"),
			TEXT(__FILE__),
			__LINE__,
            szRenderedCoverpageFilename
			);
    }

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to render cp %s and body file %s to file %s \n"),
		TEXT(__FILE__),
		__LINE__,
        g_CoverPageInfo.lpwstrCoverPageFileName,
		MH_COMPRESSION_BODY_TIF,
        szRenderedCoverpageFilename
		);

    fRetVal = TestCase(
                    szRenderedCoverpageFilename, 
                    &g_CoverPageInfo, 
                    &g_RecipientProfile, 
                    &g_SenderProfile, 
					g_tmSentTime,
					MH_COMPRESSION_BODY_TIF,
                    FSPI_S_OK,
                    g_CheckSpecificHrValues
                    );

	if (FALSE == fRetVal)
	{
		goto ExitFunc;
	}

	//
	// make a copy of szRenderedCoverpageFilename
	// so we can later compare both the rendered result file
	// and the branded result file to our reference files
	//
    if (FALSE == ::CopyFile(szRenderedCoverpageFilename, szBrandedFilename, FALSE))
    {
        ec = ::GetLastError();
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\nCopyFile(%s, %s, FALSE) failed with err=0x%8X\n"),
			TEXT(__FILE__),
			__LINE__,
            szRenderedCoverpageFilename,
            szBrandedFilename,
            ec
			);
        _ASSERTE(FALSE);
		goto ExitFunc;
    }
    else
    {
		::lgLogDetail(
			LOG_X,
			4,
			TEXT("FILE(%s) LINE(%d):\ncopied file %s to %s\n"),
			TEXT(__FILE__),
			__LINE__,
            szRenderedCoverpageFilename,
            szBrandedFilename
			);
    }

	::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nAttempting to brand file %s \n"),
		TEXT(__FILE__),
		__LINE__,
		szBrandedFilename
		);

	fRetVal = TestCaseBrand(
						szBrandedFilename,
						&g_BrandingInfo,
			            FSPI_S_OK,
						g_CheckSpecificHrValues
						);

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase42(void)
{
    BOOL fRetVal = FALSE;

    ::lgBeginCase(
		42,
		TEXT("TC#42: Compare result files to reference files\n")
		);

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nComparing result files at %s dir to refernece files at %s dir\n"),
		TEXT(__FILE__),
		__LINE__,
        TARGET_CP_DIR,
		REFERENCE_DIR
		);

    if (FALSE == ::DirToDirTiffCompare(TARGET_CP_DIR, REFERENCE_DIR, FALSE))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE(%s) LINE(%d):\nDirToDirTiffCompare(%s , %s) failed\n"),
			TEXT(__FILE__),
			__LINE__,
            TARGET_CP_DIR,
            REFERENCE_DIR
            );
        goto ExitFunc;
    }

    fRetVal = TRUE;

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}

BOOL TestCase43(void)
{
    BOOL fRetVal = FALSE;
	CFilenameVector* pTmpFilesVec = NULL;

    ::lgBeginCase(
		43,
		TEXT("TC#43: Verify there are no leftover *.ti$ files\n")
		);

    ::lgLogDetail(
		LOG_X,
		4,
		TEXT("FILE(%s) LINE(%d):\nLooking for leftover %s files at %s dir\n"),
		TEXT(__FILE__),
		__LINE__,
        TMP_FILE_EXT,
		TARGET_CP_DIR
		);

    if (FALSE == ::GetFilesOfDir(TARGET_CP_DIR, TMP_FILE_EXT, &pTmpFilesVec))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE(%s) LINE(%d):\nGetFilesOfDir(dir=%s , ext=%s) failed\n"),
			TEXT(__FILE__),
			__LINE__,
            TARGET_CP_DIR,
			TMP_FILE_EXT
            );
        goto ExitFunc;
    }

	if (FALSE == ::IsEmpty(pTmpFilesVec))
	{
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE(%s) LINE(%d):\nFound left over %s files in dir %s\n"),
			TEXT(__FILE__),
			__LINE__,
			TMP_FILE_EXT,
			TARGET_CP_DIR
            );
		::PrintVector(pTmpFilesVec);
        goto ExitFunc;
	}

    fRetVal = TRUE;

ExitFunc:
	::lgEndCase();
    return(fRetVal);
}


//
// TestSuiteShutdown:
//	Perform test suite cleanup (close logger).
//
BOOL TestSuiteShutdown(void)
{
	BOOL fRetVal = TRUE;

	//
	// End test suite (logger)
	//
	if (!::lgEndSuite())
	{
		//
		//this is not possible since API always returns TRUE
		//but to be on the safe side
		//
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgEndSuite returned FALSE\n"),
			TEXT(__FILE__),
			__LINE__
			);
		fRetVal = FALSE;
	}

	//
	// Close the Logger
	//
	if (!::lgCloseLogger())
	{
		//this is not possible since API always returns TRUE
		//but to be on the safe side
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgCloseLogger returned FALSE\n"),
			TEXT(__FILE__),
			__LINE__
			);
		fRetVal = FALSE;
	}

	return(fRetVal);
}


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\racetrmntthrdproc\main.cpp ===
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>

//#define DPF(x) _tprintf x
#define DPF(x) 

#define SIZEOF_INOUTBUFF (RAND_MAX-1)

#define NUM_OF_THREADS 100
HANDLE g_ahThreads[NUM_OF_THREADS];

HANDLE g_hMailSlot;

DWORD WINAPI ThreadTerminatingThread(LPVOID pVoid);

DWORD WINAPI LookupAccountNameThread(LPVOID pVoid)
{
	DWORD dwCurrentThreadID = ::GetCurrentThreadId();

	static TCHAR *s_szAccountNames[] = 
	{
		TEXT("Administrator"),
		TEXT("Guest"),
		TEXT("TsInternetUser"),
		TEXT("TERMINAL SERVER USER"),
		TEXT("SYSTEM"),
		TEXT("SERVICE"),
		TEXT("NETWORK"),
		TEXT("INTERACTIVE"),
		TEXT("DIALUP"),
		//TEXT("CREATOR"),LookupAccountName() takes too long
		//TEXT("GROUP"),LookupAccountName() takes too long
		TEXT("CREATOR OWNER"),
		TEXT("BATCH"),
		TEXT("ANONYMOUS LOGON"),
		TEXT("Authenticated Users"),
		TEXT("Everyone")
	};

	for(;;)
	{
		DWORD cbNeededSid = 28;
		TCHAR *szAccountName = s_szAccountNames[rand()%(sizeof(s_szAccountNames)/sizeof(*s_szAccountNames))];
		DWORD cbSid = SIZEOF_INOUTBUFF-sizeof(ULONG);
		cbNeededSid = 0;
		BYTE abBuff[1024];
		PSID pSid = (PSID)abBuff;
		TCHAR szDomainName[128];
		DWORD cbDomainName = sizeof(szDomainName);
		SID_NAME_USE sidNameUse;
		DWORD dwBefore = ::GetTickCount();
		if (!::LookupAccountName(
				NULL,   // system name - local machine
				szAccountName,  // account name
				pSid,               // security identifier
				&cbNeededSid,          // size of security identifier
				szDomainName,      // domain name
				&cbDomainName,   // size of domain name
				&sidNameUse     // SID-type indicator
				))
		{
			//DPF((TEXT("%d - CIoctlFile::PrepareIOCTLParams() LookupAccountName(%s) failed with %d, cbNeededSid=%d\n"), ::GetTickCount()-dwBefore, szAccountName, ::GetLastError(), cbNeededSid));
		}
		else
		{
			DPF((TEXT("%d - CIoctlFile::PrepareIOCTLParams() LookupAccountName(%s) succeeded, szDomainName=%s\n"), ::GetTickCount()-dwBefore, szAccountName, szDomainName));
			_ASSERTE(FALSE);
		}
		_ASSERTE(cbNeededSid <= cbSid);
		if (!::LookupAccountName(
				NULL,   // system name - local machine
				szAccountName,  // account name
				pSid,               // security identifier
				&cbSid,          // size of security identifier
				szDomainName,      // domain name
				&cbDomainName,   // size of domain name
				&sidNameUse     // SID-type indicator
				))
		{
			//DPF((TEXT("%d - CIoctlFile::PrepareIOCTLParams() LookupAccountName(%s) failed with %d\n"), ::GetTickCount()-dwBefore, szAccountName, ::GetLastError()));
		}
		else
		{
			//DPF((TEXT("%d - CIoctlFile::PrepareIOCTLParams() LookupAccountName(%s) succeeded, szDomainName=%s\n"), ::GetTickCount()-dwBefore, szAccountName, szDomainName));
		}
	}

	return 0;
}

DWORD WINAPI SuicideThread(LPVOID pVoid)
{
	DWORD dwToSleep = (DWORD)pVoid;
	DPF((TEXT("SuicideThread() will sleep %d milli.\n"), dwToSleep));
	::Sleep(dwToSleep);
	DPF((TEXT("SuicideThread() before TerminateProcess().\n")));
	if(!::TerminateProcess(::GetCurrentProcess(), -1))
	{
		DPF((TEXT("SelfTerminatingThread() - TerminateProcess() failed with %d.\n"),::GetLastError()));
	}
	return -1;
}

int main(int argc, char* argvA[])
{
	LPTSTR *szArgv;
#ifdef UNICODE
	szArgv = CommandLineToArgvW( GetCommandLine(), &argc );
    if (NULL == szArgv)
    {
        DPF((TEXT("CommandLineToArgvW() failed with %d\n"), GetLastError()));
        exit(-1);
    }
#else
	szArgv = argvA;
#endif

	int nMilliSecondsBeforeSuicide;
	if (argc > 1)
	{
		nMilliSecondsBeforeSuicide = _ttoi(szArgv[1]);
	}
	else
	{
		DPF((TEXT("Usage: %s <nMilliSecondsBeforeSuicide>\n"), szArgv[0]));
		exit(-1);
	}

	DWORD dwThreadId;
	HANDLE hThread;
	DPF((TEXT("main() before CreateThread(SuicideThread).\n")));
	if (NULL == (hThread = ::CreateThread(
			NULL,                          // pointer to thread security attributes
			0,      // initial thread stack size, in bytes
			SuicideThread,                          // pointer to thread function
			(PVOID)nMilliSecondsBeforeSuicide, // argument for new thread
			0,  // creation flags
			&dwThreadId      // pointer to returned thread identifier
			)))
	{
		DPF((TEXT("CreateThread(LookupAccountNameThread) FAILED with %d\n"), GetLastError()));
		exit(-1);
	}
	::CloseHandle(hThread);

	ZeroMemory(g_ahThreads, sizeof(g_ahThreads));

	DPF((TEXT("main() before CreateThread(ThreadTerminatingThread).\n")));
	if (NULL == (hThread = ::CreateThread(
			NULL,                          // pointer to thread security attributes
			0,      // initial thread stack size, in bytes
			ThreadTerminatingThread,                          // pointer to thread function
			0, // argument for new thread
			0,  // creation flags
			&dwThreadId      // pointer to returned thread identifier
			)))
	{
		DPF((TEXT("CreateThread(LookupAccountNameThread) FAILED with %d\n"), GetLastError()));
		exit(-1);
	}
	::CloseHandle(hThread);

	DPF((TEXT("main() before infinite CreateThread(LookupAccountNameThread).\n")));
	for(;;)
	{
		for (int iThread = 0; iThread < NUM_OF_THREADS; iThread++)
		{
			//
			// i do not want to leak threads, not their handles, so terminate and close
			//
			::TerminateThread(g_ahThreads[iThread], -1);
			::CloseHandle(g_ahThreads[iThread]);

			DPF((TEXT("main() before CreateThread(%d).\n"), iThread));
			if (NULL == (g_ahThreads[iThread] = ::CreateThread(
					NULL,                          // pointer to thread security attributes
					0,      // initial thread stack size, in bytes
					LookupAccountNameThread,                          // pointer to thread function
					0, // argument for new thread
					0,  // creation flags
					&dwThreadId      // pointer to returned thread identifier
					)))
			{
				DPF((TEXT("CreateThread(LookupAccountNameThread) FAILED with %d\n"), GetLastError()));
				//exit(-1);
			}
		}
	}
	
	_ASSERTE(FALSE);
	return 0;
}

DWORD WINAPI ThreadTerminatingThread(LPVOID pVoid)
{
	for(;;)
	{
		int nRandomThread = rand()%NUM_OF_THREADS;
		//for (int iThread = 0; iThread < NUM_OF_THREADS; iThread++)
		{
			DPF((TEXT("ThreadTerminatingThread(%d) before TerminateThread().\n"), nRandomThread));
			::TerminateThread(g_ahThreads[nRandomThread], -1);
			::CloseHandle(g_ahThreads[nRandomThread]);
			//if (rand()%2) ::Sleep(0);
		}
	}
	return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\rendercpapi\bvt.h ===
//
//
// Filename:	bvt.h
// Author:		Sigalit Bar (sigalitb)
// Date:		30-Dec-98
//
//

#ifndef _BVT_H_
#define _BVT_H_

#include <windows.h>
#include <winfax.h>
#include <TCHAR.H>
#include <crtdbg.h>

#include <faxdev.h> 
#include <efsputil.h> 

#include <log.h>

#define  TARGET_CP_DIR			TEXT("D:\\RenderCpApi\\tifs")
#define  REFERENCE_DIR			TEXT("D:\\RenderCpApi\\Reference")
#define  TARGET_CP_FILENAME_1	TEXT("D:\\RenderCpApi\\tifs\\Rendered1.tif")
#define  TARGET_CP_FILENAME_2   TEXT("D:\\RenderCpApi\\tifs\\Rendered2.tif")
#define  TARGET_CP_FILENAME_3   TEXT("D:\\RenderCpApi\\tifs\\Rendered3.tif")
#define  TARGET_CP_FILENAME_4   TEXT("D:\\RenderCpApi\\tifs\\Rendered4.tif")
#define  TARGET_CP_FILENAME_5   TEXT("D:\\RenderCpApi\\tifs\\Rendered5.tif")
#define  TARGET_CP_FILENAME_6   TEXT("D:\\RenderCpApi\\tifs\\Rendered6.tif")
#define  TARGET_CP_FILENAME_7   TEXT("D:\\RenderCpApi\\tifs\\Rendered7.tif")
#define  TARGET_CP_FILENAME_8   TEXT("D:\\RenderCpApi\\tifs\\Rendered8.tif")
#define  TARGET_CP_FILENAME_9   TEXT("D:\\RenderCpApi\\tifs\\Rendered9.tif")
#define  TARGET_CP_FILENAME_10   TEXT("D:\\RenderCpApi\\tifs\\Rendered10.tif")
#define  TARGET_CP_FILENAME_11   TEXT("D:\\RenderCpApi\\tifs\\Rendered11.tif")
#define  TARGET_CP_FILENAME_12   TEXT("D:\\RenderCpApi\\tifs\\Rendered12.tif")
#define  TARGET_CP_FILENAME_13   TEXT("D:\\RenderCpApi\\tifs\\Rendered13.tif")
#define  TARGET_CP_FILENAME_14   TEXT("D:\\RenderCpApi\\tifs\\Rendered14.tif")
#define  TARGET_CP_FILENAME_15   TEXT("D:\\RenderCpApi\\tifs\\Rendered15.tif")
#define  TARGET_CP_FILENAME_16   TEXT("D:\\RenderCpApi\\tifs\\Rendered16.tif")
#define  TARGET_CP_FILENAME_17   TEXT("D:\\RenderCpApi\\tifs\\Rendered17.tif")
#define  TARGET_CP_FILENAME_18   TEXT("D:\\RenderCpApi\\tifs\\Rendered18.tif")
#define  TARGET_CP_FILENAME_19   TEXT("D:\\RenderCpApi\\tifs\\Rendered19.tif")
#define  TARGET_CP_FILENAME_20   TEXT("D:\\RenderCpApi\\tifs\\Rendered20.tif")
#define  TARGET_CP_FILENAME_21   TEXT("D:\\RenderCpApi\\tifs\\Rendered21.tif")
#define  TARGET_CP_FILENAME_22   TEXT("D:\\RenderCpApi\\tifs\\Rendered22.tif")
#define  TARGET_CP_FILENAME_23   TEXT("D:\\RenderCpApi\\tifs\\Rendered23.tif")
#define  TARGET_CP_FILENAME_24   TEXT("D:\\RenderCpApi\\tifs\\Rendered24.tif")
#define  TARGET_CP_FILENAME_25   TEXT("D:\\RenderCpApi\\tifs\\Rendered25.tif")
#define  TARGET_CP_FILENAME_26   TEXT("D:\\RenderCpApi\\tifs\\Rendered26.tif")
#define  TARGET_CP_FILENAME_27   TEXT("D:\\RenderCpApi\\tifs\\Rendered27.tif")
#define  TARGET_CP_FILENAME_28   TEXT("D:\\RenderCpApi\\tifs\\Rendered28.tif")

#define  TARGET_CP_FILENAME_39   TEXT("D:\\RenderCpApi\\tifs\\Rendered39.tif")
#define  TARGET_CP_FILENAME_40   TEXT("D:\\RenderCpApi\\tifs\\Rendered40.tif")
#define  TARGET_CP_FILENAME_41   TEXT("D:\\RenderCpApi\\tifs\\Rendered41.tif")

#define  TARGET_BRAND_FILENAME_29		TEXT("D:\\RenderCpApi\\tifs\\Branded29.tif")
#define  TARGET_BRAND_FILENAME_30		TEXT("D:\\RenderCpApi\\tifs\\Branded30.tif")
#define  TARGET_BRAND_FILENAME_31		TEXT("D:\\RenderCpApi\\tifs\\Branded31.tif")
#define  TARGET_BRAND_FILENAME_32		TEXT("D:\\RenderCpApi\\tifs\\Branded32.tif")
#define  TARGET_BRAND_FILENAME_33		TEXT("D:\\RenderCpApi\\tifs\\Branded33.tif")
#define  TARGET_BRAND_FILENAME_34		TEXT("D:\\RenderCpApi\\tifs\\Branded34.tif")
#define  TARGET_BRAND_FILENAME_35		TEXT("D:\\RenderCpApi\\tifs\\Branded35.tif")
#define  TARGET_BRAND_FILENAME_36		TEXT("D:\\RenderCpApi\\tifs\\Branded36.tif")
#define  TARGET_BRAND_FILENAME_37		TEXT("D:\\RenderCpApi\\tifs\\Branded37.tif")
#define  TARGET_BRAND_FILENAME_38		TEXT("D:\\RenderCpApi\\tifs\\Branded38.tif")
#define  TARGET_BRAND_FILENAME_39		TEXT("D:\\RenderCpApi\\tifs\\Branded39.tif")
#define  TARGET_BRAND_FILENAME_40		TEXT("D:\\RenderCpApi\\tifs\\Branded40.tif")
#define  TARGET_BRAND_FILENAME_41		TEXT("D:\\RenderCpApi\\tifs\\Branded41.tif")

#define  TEST_BODY_TIF					TEXT("D:\\RenderCpApi\\TestBody.tif")
#define  GOOD_TEST_BODY_TIF				TEXT("D:\\RenderCpApi\\GoodTestBody.tif")
#define  GOOD_FAX_BODY_TIF				TEXT("D:\\RenderCpApi\\GoodFaxBody.tif")
#define	 NO_COMPRESSION_BODY_TIF		TEXT("D:\\RenderCpApi\\NoCompBody.tif")
#define	 MH_COMPRESSION_BODY_TIF		TEXT("D:\\RenderCpApi\\MHCompBody.tif")
#define  NON_EXISTENT_BODY_FILENAME		TEXT("D:\\RenderCpApi\\NonExistBody.tif")
#define	 NON_COV_TEXT_FILE_TXT_EXT		TEXT("D:\\RenderCpApi\\NonCovTextFile.txt")
#define	 NON_COV_TEXT_FILE_COV_EXT		TEXT("D:\\RenderCpApi\\NonCovTextFile.cov")
#define	 NON_TIF_TEXT_FILE_TXT_EXT		TEXT("D:\\RenderCpApi\\NonTifTextFile.txt")
#define	 NON_TIF_TEXT_FILE_TIF_EXT		TEXT("D:\\RenderCpApi\\NonTifTextFile.tif")

#define  DUMMY_CP_FILENAME			TEXT("D:\\RenderCpApi\\DummyCP.tif")
#define  ALL_FIELDS_CP				TEXT("D:\\RenderCpApi\\AllFields.cov")
#define  NO_SUBJECT_NO_NOTE_CP		TEXT("D:\\RenderCpApi\\NoSubNoNote.cov")
#define  NO_SUCH_CP					TEXT("D:\\RenderCpApi\\NoSuchCP.cov")

#define  TMP_FILE_EXT				TEXT("ti$")

#ifdef __cplusplus
extern "C" {
#endif


//
// ResetGlobalStructs:
//  resets g_CoverPageInfo, g_RecipientProfile, g_SenderProfile and g_BrandingInfo
//  to default values.
//
void ResetGlobalStructs( void );

//
// SetGlobalStructsToLongStrings:
//  Sets g_CoverPageInfo, g_RecipientProfile, g_SenderProfile and g_BrandingInfo
//  string members to long strings.
//
void SetGlobalStructsToLongStrings( void );


/////////////////////////////////////////////////////////////////////////////
//
// FaxRenderCoverPage test cases
//
/////////////////////////////////////////////////////////////////////////////

//
// TestCase1:
//	Invoke FaxRenderCoverPage() API with NULL TargetCpFile.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase1(void);

//
// TestCase2:
//	Invoke FaxRenderCoverPage() API with non-existent TargetCpFile.
//  Test will first delete szRenderedCoverpageFilename and only then
//  it will invoke API.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase2(void);

//
// TestCase3:
//	Invoke FaxRenderCoverPage() API with existent TargetCpFile.
//  Test will first copy TEST_TIF to szRenderedCoverpageFilename and 
//  only then it will invoke API.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase3(void);

//
// TestCase4:
//	Invoke FaxRenderCoverPage() API with existent Target Filename (lpctstrTargetFile) 
//	with read only access
//  
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase4(void);

//
// TestCase5:
//	Invoke FaxRenderCoverPage() API with NULL pRecipientProfile and pSenderProfile.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase5(void);

//
// TestCase6:
//	Invoke FaxRenderCoverPage() API with non-existent TargetCpFile.
//  Test will first delete szRenderedCoverpageFilename and only then
//  it will invoke API.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase6(void);

//
// TestCase7:
//	Invoke FaxRenderCoverPage() API with sender and recipient profiles 
//	(lpRecipientProfile, lpSenderProfile) with very long string struct members 
//	(and with body file)
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase7(void);

//
// TestCase8:
//	Invoke FaxRenderCoverPage() API with sender and recipient profiles 
//	(lpRecipientProfile, lpSenderProfile) with invalid dwSizeOfStruct
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase8(void);

//
// TestCase9:
//	Invoke FaxRenderCoverPage() API with non-existent 
//  pCoverPageInfo->lpwstrCoverPageFileName.
//  
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase9(void);


//
// TestCase10:
//	Invoke FaxRenderCoverPage() API with invalid lpCoverPageInfo.dwSizeOfStruct
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase10(void);

//
// TestCase11:
//	Invoke FaxRenderCoverPage() API with invalid lpCoverPageInfo.dwCoverPageFormat
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase11(void);

//
// TestCase12:
//	Invoke FaxRenderCoverPage() API with NULL lpCoverPageInfo
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase12(void);

//
// TestCase13:
//	Invoke FaxRenderCoverPage() API with NULL lpCoverPageInfo.lpwstrCoverPageFileName
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase13(void);

//
// TestCase14:
//	Invoke FaxRenderCoverPage() API with existent lpCoverPageInfo.lpwstrCoverPageFileName 
//	that isn't a *.cov file (e.g. NonCovTxtFile.txt)
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase14(void);

//
// TestCase15:
//	Invoke FaxRenderCoverPage() API with existent lpCoverPageInfo.lpwstrCoverPageFileName 
//	that isn't a *.cov file but has a *.cov extension (e.g. NonCovTxtFile.cov)
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase15(void);

//
// TestCase16:
//	Invoke FaxRenderCoverPage() API with lpCoverPageInfo.dwNumberOfPages = 0
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase16(void);

//
// TestCase17:
//	Invoke FaxRenderCoverPage() API with lpCoverPageInfo.dwNumberOfPages = MAXDWORD
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase17(void);

//
// TestCase18:
//	Invoke FaxRenderCoverPage() API with lpCoverPageInfo.lpwstrNote = NULL 
//	and lpCoverPageInfo.lpwstrSubject != NULL with cover page that has both
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase18(void);

//
// TestCase19:
//	Invoke FaxRenderCoverPage() API with lpCoverPageInfo.lpwstrNote != NULL 
//	and lpCoverPageInfo.lpwstrSubject = NULL with cover page that has both
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase19(void);

//
// TestCase20:
//	Invoke FaxRenderCoverPage() API with lpCoverPageInfo.lpwstrNote = NULL 
//	and lpCoverPageInfo.lpwstrSubject = NULL with cover page that has both
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase20(void);

//
// TestCase21:
//	Invoke FaxRenderCoverPage() API with lpCoverPageInfo.lpwstrNote != NULL 
//	and lpCoverPageInfo.lpwstrSubject != NULL with cover page that has neither
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase21(void);

//
// TestCase22:
//	Invoke FaxRenderCoverPage() API with tmSentTime = {0} 
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase22(void);

//
// TestCase23:
//	Invoke FaxRenderCoverPage() API with lpctstrBodyTiff = NULL 
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase23(void);

//
// TestCase24:
//	Invoke FaxRenderCoverPage() API with non-existent lpctstrBodyTiff != NULL
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase24(void);

//
// TestCase25:
//	Invoke FaxRenderCoverPage() API with existent lpctstrBodyTiff that 
//	isn't a TIFF file (e.g. NonTiffTxtFile.txt)
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase25(void);

//
// TestCase26:
//	Invoke FaxRenderCoverPage() API with existent lpctstrBodyTiff that 
//	isn't a TIFF file but has a TIF extension (e.g. NonTiffTxtFile.tif)
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase26(void);

//
// TestCase27:
//	Invoke FaxRenderCoverPage() API with all valid parameters with lpctstrBodyTiff = NULL
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase27(void);

//
// TestCase27:
//	Invoke FaxRenderCoverPage() API with all valid parameters with 
//	existent non-compressed lpctstrBodyTiff
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase28(void);


/////////////////////////////////////////////////////////////////////////////
//
// FaxBrandDocument test cases
//
/////////////////////////////////////////////////////////////////////////////

//
// TestCase29:
//	Invoke FaxBrandDocument with non-existent filename (lpctstrFie)
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase29(void);

//
// TestCase30:
//	Invoke FaxBrandDocument with NULL filename (lpctstrFie)
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase30(void);

//
// TestCase31:
//	Invoke FaxBrandDocument with existent read-only filename (lpctstrFie)
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase31(void);

//
// TestCase32:
//	Invoke FaxBrandDocument with existent filename (lpctstrFie)
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase32(void);

//
// TestCase33:
//	Invoke FaxBrandDocument with NULL lpcBrandInfo
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase33(void);

//
// TestCase34:
//	Invoke FaxBrandDocument with lpcBrandInfo with invalid dwSizeOfStruct
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase34(void);

// TestCase35:
//	Invoke FaxBrandDocument with lpcBrandInfo with NULL string members
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase35(void);

//
// TestCase36:
//	Invoke FaxBrandDocument with lpcBrandInfo with very long string members
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase36(void);

//
// TestCase37:
//	Invoke FaxBrandDocument with lpcBrandInfo with an all zero tmDateTime member
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase37(void);

//
// TestCase38:
//	Invoke FaxBrandDocument with existent filename (lpctstrFie) that is a TIF in MR or MH compression
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase38(void);



/////////////////////////////////////////////////////////////////////////////
//
// FaxRenderCoverPage and FaxBrandDocument test cases
//
/////////////////////////////////////////////////////////////////////////////

//
// TestCase39:
//	Invoke FaxBrandDocument with all valid params (with merge) and then 
//	invoke FaxBrandDocument with all valid params on the result.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase39(void);

//
// TestCase40:
//	Invoke FaxBrandDocument with all valid params (with merge of a non-compressed TIF file
//	with width > 1728 pixels) and then invoke FaxBrandDocument with all valid params on the result.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase40(void);

//
// TestCase41:
//	Invoke FaxBrandDocument with all valid params (with merge of an MH compressed TIF file)
//	and then invoke FaxBrandDocument with all valid params on the result.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase41(void);

//
// TestCase42:
//	Compare FaxRenderCoverPage and FaxBrandDocument result files with reference files
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase42(void);

//
// TestCase43:
//	Make sure there are no left over *.ti$ files in the target directory
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase43(void);


//
// TestSuiteSetup:
//	Initializes logger.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestSuiteSetup(void);

//
// TestCase:
//	Invoke FaxRenderCoverPage() API.
//
// Parameters:
//	szRenderedCoverpageFilename	    IN parameter.
//					                The fully qualified path to a file where the 
//                                  resulting TIFF file will be placed.
//  
//	pCoverPageInfo	                IN parameter
//					                contains information regarding the cover page 
//                                  to be rendered.
//
//	pRecipientProfile		        IN parameter
//					                contains information regarding the recipient 
//                                  for whom this cover page is intended.
//
//	pSenderProfile		            IN parameter
//					                contains information regarding the sender of the fax.
//
//	tmSentTime						IN parameter
//					                contains information regarding the time to send the fax.
//
//	lpctstrBodyTiff		            IN parameter
//					                The full path to the body tiff file to be merged.
//
//  hrExpected                      IN parameter
//                                  the HRESULT value we expect the API to return.
//
//  fCheckSpecificHrValue           IN parameter
//                                  indicates whether to check the HRESULT that API 
//                                  returned against the hrExpected, or not.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCase(
    IN  LPCTSTR                     szRenderedCoverpageFilename,
    IN  LPCFSPI_COVERPAGE_INFO      pCoverPageInfo,
    IN  LPCFSPI_PERSONAL_PROFILE    pRecipientProfile,
    IN  LPCFSPI_PERSONAL_PROFILE    pSenderProfile,
	IN	SYSTEMTIME					tmSentTime,
	IN	LPCTSTR						lpctstrBodyTiff,
    IN  HRESULT                     hrExpected,
    IN  BOOL                        fCheckSpecificHrValue
);


//
// TestCaseBrand:
//	Invoke FaxBrandDocument() API.
//
//	szFilenameToBrand	            IN parameter
//					                The full path to the file to be branded,
//									that will be passed to the FaxBrandDocument API.
//
//	lpcBrandingInfo					IN parameter
//					                Pointer to the FSPI_BRAND_INFO that will be passed
//									to the FaxBrandDocument API.
//
//  hrExpected                      IN parameter
//                                  the HRESULT value we expect the API to return.
//
//  fCheckSpecificHrValue           IN parameter
//                                  indicates whether to check the HRESULT that API 
//                                  returned against the hrExpected, or not.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL TestCaseBrand(
	IN  LPCTSTR				szFilenameToBrand,
	IN	LPCFSPI_BRAND_INFO	lpcBrandingInfo,
    IN  HRESULT             hrExpected,
    IN  BOOL                fCheckSpecificHrValue
	);

//
// TestSuiteShutdown:
//	Perform test suite cleanup (close logger).
//
// Return Value:
//	TRUE if successful, FALSE otherwise.
//
BOOL TestSuiteShutdown(void);


#ifdef __cplusplus
}
#endif 

#endif //_BVT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\setupinstalltest\filepath.cpp ===
//
//
// filepath.cpp
//
//

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include "filepath.h"


LPTSTR FilePath (LPCTSTR szFileName)
{
	// Handle to file object to check the ini file's existence.
	HFILE		hFile = NULL;

	// File information structure.
	OFSTRUCT	*pofFile = NULL;

	// Return string - path to file (if found) or NULL.
	LPTSTR		szReturnPath = NULL;
	DWORD		dwReturnPathLength = 0;

	// Ansi file name string.
	char*		szFileNameA = NULL;
	DWORD		dwFileNameALength = 0;
	

	pofFile = (OFSTRUCT*)::malloc (sizeof (OFSTRUCT));
	if (NULL == pofFile)
	{
		::_tprintf (TEXT ("[FilePath] Memory allocation problem - file information structure OFSTRUCT.\n"));
		goto Exit;
	}
	//
	// OpenFile uses Ansi strings and returns the path as an ansi string through
	// the OFSTRUCT. Therefore for UNICODE mode several translations must be
	// made.
	//

#ifdef UNICODE

	// Error codes returned by translation functions.
	DWORD		dwErrorCode;

	//
	// The first translation - translating the wide-character file name string
	// to an Ansi string.
	// First call - get the buffer size (in bytes) needed for the translation of
	// the file name.
	//
	dwErrorCode = ::WideCharToMultiByte (CP_THREAD_ACP,		// Current thread's ANSI code page.
									   0,					// No Flags.
									   szFileName,
									   -1,					// NULL-terminated string.
									   szFileNameA,
									   0,
									   NULL,
									   NULL);

	if (0 == dwErrorCode)	// An error occurred.
	{
		::_tprintf (TEXT ("[FilePath] WideCharToMultiByte first call - failed to return buffer size needed for translation, error 0x%08X.\n"), ::GetLastError ());
        goto Exit;
	}

	//
	// Allocate buffer:
	//
	dwFileNameALength = dwErrorCode;
	szFileNameA = (char*)::malloc (dwFileNameALength);
	if (NULL == szFileNameA)	// Error during allocation
	{
		::_tprintf (TEXT ("[FilePath] Failed to allocate buffer for Ansi ini file name string.\n"));
		goto Exit;
	}

	//
	// Second call - translate the file name to Ansi.
	//
	dwErrorCode = ::WideCharToMultiByte (CP_THREAD_ACP,		// Current thread's ANSI code page.
									   0,					// No Flags.
									   szFileName,
									   -1,					// NULL-terminated string.
									   szFileNameA,
									   dwFileNameALength,
									   NULL,
									   NULL);
	if (0 == dwErrorCode)	// An error occurred.
	{
		::_tprintf (TEXT ("[FilePath] WideCharToMultiByte second call - failed to translate file name, error 0x%08X.\n"), ::GetLastError ());
        goto Exit;
	}

#else	// Ansi mode

	//
	// When in Ansi mode, copy the file name string. This way szFileNameA always
	// contains the Ansi file name string.
	//
	dwFileNameALength = ::_tcslen (szFileName) + 1;
	szFileNameA = (char*)::malloc (dwFileNameALength);
	if (NULL == szFileNameA)	// Error during allocation
	{
		::_tprintf (TEXT ("[FilePath] Failed to allocate buffer to copy ini file name string.\n"));
		goto Exit;
	}
	::_tcscpy (szFileNameA, szFileName);

#endif	// UNICODE
	//
	// szFileNameA holds the Ansi file name string.
	//

	//
	// Calling OpenFile with OF_EXIST only checks the existence of the file, and
	// immediately closes the handle, while keeping its value.
	//
	hFile = ::OpenFile (szFileNameA, pofFile, OF_EXIST);
	if (HFILE_ERROR == hFile)	// Failure - file probably wasn't found.
	{
        ::_tprintf (TEXT ("[FilePath] OpenFile failed to open the file, error 0x%08X.\n"), ::GetLastError ());
		::_tprintf (TEXT ("           Make sure you give the correct path to the ini file.\n"));
        goto Exit;
	}

	//
	// File exists (OpenFile closes handle to file immediately, since it just
	// checks its existence). Get full path to file through ofFile. ofFile holds
	// an Ansi string of the full path to the file. In Unicode mode this must be
	// translated back to a wide-character string (the path might differ from
	// the original file name since it might contain the full path to the
	// current directory).
	//

#ifdef UNICODE
	//
	// First call - get the buffer size (in wchar characters) needed for the
	// translation of the file path to wide-character.
	//
	dwErrorCode = ::MultiByteToWideChar (CP_THREAD_ACP,			// Current thread's ANSI code page.
										 MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
										 pofFile->szPathName,
										 -1,
										 NULL,
										 0);

	if (0 == dwErrorCode)	// An error occurred.
	{
		::_tprintf (TEXT ("[FilePath] MultiByteToWideChar first call - failed to return buffer size needed for translation, error 0x%08X.\n"), ::GetLastError ());
        goto Exit;
	}

	//
	// Allocate buffer:
	//
	dwReturnPathLength = dwErrorCode;
	szReturnPath = (wchar_t*)::malloc (sizeof (wchar_t) * dwReturnPathLength);
	if (NULL == szReturnPath)	// Error during allocation
	{
		::_tprintf (TEXT ("[FilePath] Failed to allocate buffer for Unicode file path string.\n"));
		goto Exit;
	}

	//
	// Second call - translate the file path to Unicode
	//
	dwErrorCode = ::MultiByteToWideChar (CP_THREAD_ACP,			// Current thread's ANSI code page.
										 MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
										 pofFile->szPathName,
										 -1,
										 szReturnPath,
										 dwReturnPathLength);

	if (0 == dwErrorCode)	// An error occurred.
	{
		::_tprintf (TEXT ("[FilePath] MultiByteToWideChar second call - failed to translate file path, error 0x%08X.\n"), ::GetLastError ());
        goto Exit;
	}

#else	// Ansi mode

	//
	// szReturnPath must still hold a copy of the full path.
	//
	dwReturnPathLength = ::_tcslen (pofFile->szPathName) + 1;
	szReturnPath = (char*)::malloc (sizeof (char) * dwReturnPathLength);
	if (NULL == szReturnPath)	// Error during allocation
	{
		::_tprintf (TEXT ("[FilePath] Failed to allocate buffer for Ansi file path string.\n"));
		goto Exit;
	}
	::_tcscpy (szReturnPath, pofFile->szPathName);

#endif	// UNICODE


Exit:
	
	if (NULL != szFileNameA)	// Free Ansi file name string.
	{
		::free (szFileNameA);
	}
	if (NULL != pofFile)		// Free file info structure.
	{
		::free (pofFile);
	}

	return (szReturnPath);		// Return path (or NULL) to caller.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\setupinstalltest\errorcodelog.cpp ===
//
//
// Filename:	errorcodelog.cpp
//
//

#include "logger.h"

// Const used for increasing the message buffer's size.
#define MESSAGE_INCREMENT 100


void __cdecl lgLogCode (
	const DWORD dwSeverity,	// used by the original logger functions
	const DWORD dwCode,		// the code to be searched for and logged
	LPCTSTR FILE,			// the file from where the function was called
	const DWORD LINE		// the line of the call inside the file 
	)
{
	// Result of the message string retrieval.
	int		iMessageResult;

	// Buffer which holds the error message related to the logged code.
	DWORD	dwMessageBufferSize = 0;
	LPTSTR	szMessageBuffer = NULL;

	//
	// Any code besides ERROR_SUCCESS is considered an error code, and logged as
	// an error. ERROR_SUCCESS is only a "detail" logged in the logger.
	//
	if (ERROR_SUCCESS == dwCode)
	{
		::lgLogDetail (0, 1, TEXT ("CODE %d - Success"), dwCode);
		goto ExitFunc;
	}

	//
	// FormatMessage returns the length of the message string written in the
	// buffer. Any error during the process of this function is indicated by an
	// empty buffer, and therefore a return value of 0.
	// If the buffer was not large enough a larger buffer is allocated and the
	// function is called again. Any other error code stops the process, and an
	// error message is logged with the code, but instead of its message, an
	// indication of the error is written.
	//
	dwMessageBufferSize = MESSAGE_INCREMENT;
	do
	{
		szMessageBuffer = (LPTSTR)::malloc (sizeof (TCHAR) * dwMessageBufferSize);
		if (NULL == szMessageBuffer)	// unable to allocate buffer -
		{								// message cannot be retrieved
			::lgLogError (dwSeverity, TEXT ("FILE: %s LINE: %d\n ERROR %d - (Unable to allocate message buffer, information unavailable)"), FILE, LINE, dwCode);
			goto ExitFunc;
		}
		iMessageResult = ::FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwCode, 0, szMessageBuffer, dwMessageBufferSize, NULL);
		if (0 == iMessageResult)
		{
			if (ERROR_INSUFFICIENT_BUFFER == ::GetLastError ())
			{	// The buffer's size must be increased.
				::free (szMessageBuffer);
				dwMessageBufferSize += MESSAGE_INCREMENT;
			}
			else	// An error occurred while retrieving the message. The error is
			{		// not directly linked to the buffer size.
				::lgLogError (dwSeverity, TEXT ("FILE: %s LINE: %d\n ERROR %d - (An error occurred, unable to retrieve information)"), FILE, LINE, dwCode);
				goto ExitFunc;
			}
		}
	} while (0 == iMessageResult);

	//
	// The error message was successfully retrieved.
	//
	::lgLogError (dwSeverity, TEXT ("FILE: %s LINE: %d\n ERROR %d - %s"), FILE, LINE, dwCode, szMessageBuffer);

ExitFunc:
	if (NULL != szMessageBuffer)
	{
		::free (szMessageBuffer);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\rendercpapi\testutils.cpp ===
//
//
// Filename:	testutils.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		10-Jan-2000
//
//

#include "testutils.h"

tstring			g_tstrFullPathToIniFile;

void 
UsageInfo(
    INT     argc, 
    TCHAR*   argvT[]
)
{
    _ASSERTE(0 < argc);
    _ASSERTE(NULL != argvT);
    _ASSERTE(NULL != argvT[0]);
    ::_tprintf(TEXT("\n"));
    ::_tprintf(TEXT("Usage Info for %s:\n"), argvT[0]);
    ::_tprintf(TEXT("%s full_path_to_ini_file\n"));
    ::_tprintf(TEXT("\n"));
    ::_tprintf(TEXT("Where -\n"));
    ::_tprintf(TEXT("full_path_to_ini_file      is the full path to the suite's ini file.\n"));
    ::_tprintf(TEXT("                           see test suite readme.txt for ini file format.\n"));
    ::_tprintf(TEXT("\n\n"));
}


HRESULT 
GetCommandLineParams(
    INT     argc, 
    TCHAR*  argvT[], 
    LPTSTR* pszFullPathToIniFile
)
{
    HRESULT hrRetVal = E_UNEXPECTED;
    DWORD   dwLoopIndex = 0;
    LPTSTR  tszCurrentArg = NULL;
    LPTSTR  tszTmpFullPathToIniFile = NULL;

    //
    // check params
    //
    _ASSERTE(0 < argc);
    _ASSERTE(NULL != argvT);
    _ASSERTE(NULL != argvT[0]);
    // for now we have exactly one parameter
	if ( argc != 2 )   
	{
		::_tprintf(TEXT("\nInvalid invocation of %s\n"), argvT[0]);
		::UsageInfo(argc, argvT); 
        goto ExitFunc;
	}
    if (NULL == pszFullPathToIniFile)
    {
        ::_tprintf(TEXT("[GetCommandLineParams] got pszFullPathToIniFile==NULL\n"));
        _ASSERTE(FALSE);
        goto ExitFunc;
    }

	//
	// Loop on arguments in argvA[]
	//
    // for now argc==2 so just one arg
    for (dwLoopIndex = 1; dwLoopIndex < (DWORD) argc; dwLoopIndex++) 
	{
        tszCurrentArg = argvT[dwLoopIndex];
        if (NULL == tszCurrentArg)
        {
            ::_tprintf(TEXT("[GetCommandLineParams] got argvT[%d]==NULL\n"), dwLoopIndex);
            _ASSERTE(FALSE);
            goto ExitFunc;
        }
        if ('\0' == tszCurrentArg[0])
        {
            ::_tprintf(TEXT("[GetCommandLineParams] got argvT[%d]==\"\"\n"), dwLoopIndex);
            _ASSERTE(FALSE);
            goto ExitFunc;
        }

        // check for help switch
		if ((!::_tcsicmp(HELP_SWITCH_1, tszCurrentArg)) || 
			(!::_tcsicmp(HELP_SWITCH_2, tszCurrentArg)) || 
			(!::_tcsicmp(HELP_SWITCH_3, tszCurrentArg)) || 
			(!::_tcsicmp(HELP_SWITCH_4, tszCurrentArg))
		   )
        {
            // found help switch
		    ::UsageInfo(argc, argvT); 
            goto ExitFunc;
        }

		//
		// Treat each argument accordingly
		//
        // for now we only have one
		switch (dwLoopIndex)
		{
		case ARGUMENT_IS_INI_FILENAME_NAME:
            tszTmpFullPathToIniFile = ::_tcsdup(tszCurrentArg);
            if (NULL == tszTmpFullPathToIniFile)
            {
                ::_tprintf(TEXT("[GetCommandLineParams] _tcsdup failed with err=0x%08X\n"), ::GetLastError());
                goto ExitFunc;
            }
			break;

		default:
			_ASSERTE(FALSE);
			return FALSE;
		}// switch (dwIndex)
    }

    //
    // set out param
    //
    (*pszFullPathToIniFile) = tszTmpFullPathToIniFile;
    hrRetVal = S_OK;

ExitFunc:
    if (S_OK != hrRetVal)
    {
        free(tszTmpFullPathToIniFile);
    }
    return(hrRetVal);
}

//
// NOTE: this func throws STL exceptions
//
std::vector<LONG> GetLongVectorFromStrVector ( 
	IN const std::vector<tstring> tstrVector
	)
{
	std::vector<LONG> lVector;
	std::vector<tstring>::const_iterator it;
	for (it = tstrVector.begin() ; it != tstrVector.end() ; it++)
	{
		LPTSTR szCurrent = const_cast<TCHAR*>((*it).c_str());
		_ASSERTE(szCurrent);
		LONG lCurrent = ::_tcstol(szCurrent, NULL, 10);
		if (0 == lCurrent)
		{
			// error
			THROW_TEST_RUN_TIME_WIN32(ERROR_GEN_FAILURE, TEXT(""));		
		}
		else if (LONG_MAX == lCurrent)
		{
			// error
			THROW_TEST_RUN_TIME_WIN32(ERROR_BUFFER_OVERFLOW, TEXT("LONG_MAX"));		
		}
		else if (LONG_MIN == lCurrent)
		{
			// error
			THROW_TEST_RUN_TIME_WIN32(ERROR_BUFFER_OVERFLOW, TEXT("LONG_MIN"));		
		}
		// ok
		lVector.push_back(lCurrent);
	}
	return(lVector);
}

std::vector<LONG> GetVectorOfTestCasesToRunFromIniFile(
	IN const tstring& tstrIniFile,
	IN const tstring& tstrSectionName
	)
{
	std::vector<tstring> tstrVectorOfTestCasesToRun;
	std::vector<LONG> lVectorOfTestCasesToRun;

	tstrVectorOfTestCasesToRun = INI_GetSectionList(g_tstrFullPathToIniFile, tstrSectionName);
	lVectorOfTestCasesToRun = GetLongVectorFromStrVector(tstrVectorOfTestCasesToRun);
	return(lVectorOfTestCasesToRun);
}

//
// testCaseExists
//
BOOL testCaseExists(DWORD number)
{
	DWORD numOfFuncsInArray = 0;

	if (number <= 0) return(FALSE);

	if (number > g_dwTestCaseFuncArraySize) return(FALSE);
	else return(TRUE);
}

//
// runTestCase
//
HRESULT runTestCase(DWORD number, void* pVoid)
{
	PTR_TO_TEST_CASE_FUNC funcToRun = NULL;
	BOOL fFuncRetVal = FALSE;
	HRESULT returnValue = E_UNEXPECTED;

	if (!testCaseExists(number)) 
		{
            ::lgLogError(LOG_SEV_1, TEXT("no such test case (TC#%d).\n"),number);
            _ASSERTE(FALSE);
    		return(E_UNEXPECTED);
		}
	funcToRun = gTestCaseFuncArray[number];
	fFuncRetVal = (funcToRun());
	if (TRUE == fFuncRetVal)
	{
		returnValue = S_OK;
	}
	else
	{
		returnValue = E_FAIL;
	}
	return(returnValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\setupinstalltest\api_substitute.cpp ===
//
//
// api_substitute.cpp
//
//

#include "api_substitute.h"
#include <shlobj.h>

//
// s_acvCSIDLvalues associates between a CSIDL string and its value.
//
static const CSIDLVAL s_acvCSIDLvalues[] = {
	{TEXT ("CSIDL_ADMINTOOLS"),					CSIDL_ADMINTOOLS			 },
	{TEXT ("CSIDL_ALTSTARTUP"),					CSIDL_ALTSTARTUP			 },
	{TEXT ("CSIDL_APPDATA"),					CSIDL_APPDATA				 },
	{TEXT ("CSIDL_BITBUCKET"),					CSIDL_BITBUCKET				 },
	{TEXT ("CSIDL_COMMON_ADMINTOOLS"),			CSIDL_COMMON_ADMINTOOLS		 },
	{TEXT ("CSIDL_COMMON_ALTSTARTUP"),			CSIDL_COMMON_ALTSTARTUP		 },
	{TEXT ("CSIDL_COMMON_APPDATA"),				CSIDL_COMMON_APPDATA		 },
	{TEXT ("CSIDL_COMMON_DESKTOPDIRECTORY"),	CSIDL_COMMON_DESKTOPDIRECTORY},
	{TEXT ("CSIDL_COMMON_DOCUMENTS"),			CSIDL_COMMON_DOCUMENTS		 },
	{TEXT ("CSIDL_COMMON_FAVORITES"),			CSIDL_COMMON_FAVORITES		 },
	{TEXT ("CSIDL_COMMON_PROGRAMS"),			CSIDL_COMMON_PROGRAMS		 },
	{TEXT ("CSIDL_COMMON_STARTMENU"),			CSIDL_COMMON_STARTMENU		 },
	{TEXT ("CSIDL_COMMON_STARTUP"),				CSIDL_COMMON_STARTUP		 },
	{TEXT ("CSIDL_COMMON_TEMPLATES"),			CSIDL_COMMON_TEMPLATES		 },
	{TEXT ("CSIDL_CONTROLS"),					CSIDL_CONTROLS				 },
	{TEXT ("CSIDL_COOKIES"),					CSIDL_COOKIES				 },
	{TEXT ("CSIDL_DESKTOP"),					CSIDL_DESKTOP				 },
	{TEXT ("CSIDL_DESKTOPDIRECTORY"),			CSIDL_DESKTOPDIRECTORY		 },
	{TEXT ("CSIDL_DRIVES"),						CSIDL_DRIVES				 },
	{TEXT ("CSIDL_FAVORITES"),					CSIDL_FAVORITES				 },
	{TEXT ("CSIDL_FONTS"),						CSIDL_FONTS					 },
	{TEXT ("CSIDL_HISTORY"),					CSIDL_HISTORY				 },
	{TEXT ("CSIDL_INTERNET"),					CSIDL_INTERNET				 },
	{TEXT ("CSIDL_INTERNET_CACHE"),				CSIDL_INTERNET_CACHE		 },
	{TEXT ("CSIDL_LOCAL_APPDATA"),				CSIDL_LOCAL_APPDATA			 },
	{TEXT ("CSIDL_MYPICTURES"),					CSIDL_MYPICTURES			 },
	{TEXT ("CSIDL_NETHOOD"),					CSIDL_NETHOOD				 },
	{TEXT ("CSIDL_NETHOOD "),					CSIDL_NETHOOD				 },
	{TEXT ("CSIDL_NETWORK"),					CSIDL_NETWORK				 },
	{TEXT ("CSIDL_PERSONAL"),					CSIDL_PERSONAL				 },
	{TEXT ("CSIDL_PRINTERS"),					CSIDL_PRINTERS				 },
	{TEXT ("CSIDL_PRINTHOOD"),					CSIDL_PRINTHOOD				 },
	{TEXT ("CSIDL_PROFILE"),					CSIDL_PROFILE				 },
	{TEXT ("CSIDL_PROGRAM_FILES"),				CSIDL_PROGRAM_FILES			 },
	{TEXT ("CSIDL_PROGRAM_FILES_COMMON"),		CSIDL_PROGRAM_FILES_COMMON	 },
	{TEXT ("CSIDL_PROGRAM_FILES_COMMONX86"),	CSIDL_PROGRAM_FILES_COMMONX86},
	{TEXT ("CSIDL_PROGRAM_FILESX86"),			CSIDL_PROGRAM_FILESX86	 	 },
	{TEXT ("CSIDL_PROGRAMS"),					CSIDL_PROGRAMS				 },
	{TEXT ("CSIDL_RECENT"),						CSIDL_RECENT				 },
	{TEXT ("CSIDL_SENDTO"),						CSIDL_SENDTO				 },
	{TEXT ("CSIDL_STARTMENU"),					CSIDL_STARTMENU				 },
	{TEXT ("CSIDL_STARTUP"),					CSIDL_STARTUP				 },
	{TEXT ("CSIDL_SYSTEM"),						CSIDL_SYSTEM				 },
	{TEXT ("CSIDL_SYSTEMX86"),					CSIDL_SYSTEMX86				 },
	{TEXT ("CSIDL_TEMPLATES"),					CSIDL_TEMPLATES				 },
	{TEXT ("CSIDL_WINDOWS"),					CSIDL_WINDOWS				 },
	{EMPTY_NAME,								ILLEGAL_CSIDL_VALUE			 }
};


DWORD ExpandAllStrings (
	LPCTSTR	pcSource,			// string to expand
	LPTSTR&	szExpandedString	// expanded result
	)
{
	DWORD	dwReturnValue = MAXDWORD;

	// Length of expanded string.
	DWORD	dwFullStringLength = 0;

	// A copy of pcSource (so it can be changed).
	LPTSTR	szSourceCopy = NULL;

	// Variables used in case the string starts with a CSIDL value name:
	// - pointer to the CSIDL sub-string prefix.
	LPTSTR	pcSourceCSIDL = NULL;
	// - CSIDL value
	int		iCSIDLvalue;
	// - the rest of the string (not containing the CSIDL prefix)
	LPTSTR	szSourceRest = NULL;

	// Variable used to check expansion function call results.
	DWORD	dwExpandedResult;

	// Check var - used for buffer reallocation routines.
	LPTSTR	pcChange = NULL;
	
	// The buffer used to expand environment strings:
	DWORD	dwExpandedStringBufferSize = 0;
	LPTSTR	szExpandedStringBuffer = NULL;
	
	//
	// Expand the string.
	//
	// Two possibilities exist:
	// 1.	The pcSource string begins with a CSIDL value. This is replaced with
	//		a path (full or with environment variables) by the function
	//		SHGetSpecialFolderPath.
	// 2.	The pcSource string is already an expanded string or includes
	//		environment variables. Such strings are expanded by function
	//		ExpandEnvironmentStrings.
	//
	// Before taking the second step of expansion (ExpandEnvironmentStrings),
	// szSourceCopy will hold a valid string (with or without environment
	// variables) with no CSIDL value name, to help simplify the procedure.
	//

	//
	// Copy the pcSource string for manipulation.
	//
	szSourceCopy = (LPTSTR)::malloc (sizeof (TCHAR) * (::_tcslen (pcSource) + 1));
	if (NULL == szSourceCopy)
	{
		dwReturnValue = ERROR_NOT_ENOUGH_MEMORY;
		goto Exit;
	}
	::_tcscpy (szSourceCopy, pcSource);

	//
	// Expand CSIDL value name prefix.
	//
	if ((0 > ::_tcscmp (TEXT ("CSIDL"), szSourceCopy)) && (0 < ::_tcscmp (TEXT ("CSIDM"), szSourceCopy)))
	{	//
		// The string starts with a CSIDL prefix, which is probably a CSIDL
		// value name.
		//
		pcSourceCSIDL = ::_tcstok (szSourceCopy, TEXT ("\\"));	// get the token starting
																// with the prefix CSIDL

		iCSIDLvalue = FindItemByName<CSIDLVAL> (s_acvCSIDLvalues, pcSourceCSIDL).iValue;
		if (ILLEGAL_CSIDL_VALUE == iCSIDLvalue)
		{	//
			// pcSource does not contain a valid CSIDL string, so continue as if
			// it's just part of the string. Recopy pcSource and continue to the
			// second expansion stage.
			//
			::_tcscpy (szSourceCopy, pcSource);
		}
		else
		{
			//
			// Copy the rest of the string to another variable for later use.
			//
			if (::_tcslen (pcSourceCSIDL) < ::_tcslen (pcSource))
			{
				szSourceRest = (LPTSTR)::malloc (sizeof (TCHAR) * (::_tcslen (pcSource) - ::_tcslen (pcSourceCSIDL) + 1));
				if (NULL == szSourceRest)
				{
					dwReturnValue = ERROR_NOT_ENOUGH_MEMORY;
					goto Exit;
				}
				::_tcscpy (szSourceRest, (pcSource + ::_tcslen (pcSourceCSIDL)));
			}
			else	// The string contains only the CSIDL value name.
			{
				szSourceRest = (LPTSTR)::malloc (sizeof (TCHAR) * 1);
				if (NULL == szSourceRest)
				{
					dwReturnValue = ERROR_NOT_ENOUGH_MEMORY;
					goto Exit;
				}
				::_tcscpy (szSourceRest, TEXT (""));
			}

			//
			// szSourceCopy does no longer need to hold the data, since the CSIDL
			// prefix is represented now by a number and the remaining of the
			// string has been copied.
			//
			::free (szSourceCopy);
			pcSourceCSIDL = NULL; // Remember - the CSIDL sub-string does no longer exist!
	
			//
			// Expand CSIDL string to a valid path (which might include environment
			// vars).
			//
			szSourceCopy = (LPTSTR)::malloc (sizeof (TCHAR) * MAX_PATH);
			//
			// Note:
			// A MAX_PATH-sized buffer is among the specifications of the function
			// SHGetSpecialFolderPath.
			//
			if (NULL == szSourceCopy)
			{
				dwReturnValue = ERROR_NOT_ENOUGH_MEMORY;
				goto Exit;
			}
			dwExpandedResult = SHGetSpecialFolderPath (NULL, szSourceCopy, iCSIDLvalue, FALSE);
			if (FALSE == dwExpandedResult)
			{
				dwReturnValue = ERROR_FILE_NOT_FOUND;
				goto Exit;
			}

			//
			// Concatenate the rest of the string to the string which was
			// previously represented by the CSIDL value name.
			//
			//						  CSIDL substitute			  rest of string
			dwFullStringLength = ::_tcslen (szSourceCopy) + ::_tcslen (szSourceRest) + 1;
			if (MAX_PATH < dwFullStringLength)
			{
				pcChange = (LPTSTR)::realloc (szSourceCopy, (sizeof (TCHAR) * dwFullStringLength));
				if (NULL == pcChange)
				{
					dwReturnValue = ERROR_NOT_ENOUGH_MEMORY;
					goto Exit;
				}
				szSourceCopy = pcChange;	// in case the block's location has changed
			}
			::_tcscat (szSourceCopy, szSourceRest);
		}
	}
		
	//
	// Now szSourceCopy holds a string which perhaps contains environment vars.
	// Such a string must be expanded before sending it back to the caller.
	//
	// Since dwExpandedResult returns the number of characters it's written (or
	// needs) in the expanded string buffer, if the number is larger than the
	// buffer previously allocated, the buffer must be re-allocated using the
	// size specified by dwExpandedStringSize.
	// The size of the buffer needed is expected to be more or less the size of
	// the string to be expanded, which is szSourceCopy.
	//
	// Note:
	// The reason an extra character is allocated (+ 1 is the default choice,
	// for the ending NULL character) is a bug in the api function
	// ExpandEnvironmentStrings which makes it request an extra (unneeded) char
	// in a Multibyte environment. This is a workaround to avoid unnecessary
	// reallocation of the expanded string buffer for the extra character.
	//
	dwExpandedStringBufferSize = ::_tcslen (szSourceCopy) + 2;
	szExpandedStringBuffer = (LPTSTR)::malloc (sizeof (TCHAR) * dwExpandedStringBufferSize);
	if (NULL == szExpandedStringBuffer)
	{
		dwReturnValue = ERROR_NOT_ENOUGH_MEMORY;
		goto Exit;
	}
	dwExpandedResult = ::ExpandEnvironmentStrings (szSourceCopy, szExpandedStringBuffer, dwExpandedStringBufferSize);
	if (dwExpandedResult > dwExpandedStringBufferSize)
	{	// expanded string is larger than expected
		dwExpandedStringBufferSize = dwExpandedResult;
		pcChange = (LPTSTR)::realloc (szExpandedStringBuffer, (sizeof (TCHAR) * dwExpandedStringBufferSize));
		if (NULL == pcChange)
		{
			dwReturnValue = ERROR_NOT_ENOUGH_MEMORY;
			goto Exit;
		}
		szExpandedStringBuffer = pcChange;	// in case the block's location has changed
		dwExpandedResult = ::ExpandEnvironmentStrings (szSourceCopy, szExpandedStringBuffer, dwExpandedStringBufferSize);
		if (dwExpandedResult > dwExpandedStringBufferSize)
		{
			dwReturnValue = ERROR_INVALID_PARAMETER;
			goto Exit;
		}
	}
	dwReturnValue = ERROR_SUCCESS;	// expansion process has completed successfully

Exit:
	if (ERROR_SUCCESS == dwReturnValue)
	{
		szExpandedString = szExpandedStringBuffer;	// return string to caller (*note in .h file)
	}
	else
	{
		if (NULL != szExpandedStringBuffer)
		{
			::free (szExpandedStringBuffer);			// string is not returned, therefore it's freed
		}
		szExpandedString = NULL;
	}

	if (NULL != szSourceCopy)						// free rest of memory allocated
	{
		::free (szSourceCopy);
	}

	if (NULL != szSourceRest)
	{
		::free (szSourceRest);
	}

	return (dwReturnValue);
}


DWORD SearchForPath (
	LPCTSTR	pcPath,			// search path
	LPCTSTR	pcFileName,		// file / directory name
	LPTSTR&	szFullPath		// full path buffer of found file / directory
	)
{
	DWORD	dwReturnValue = ERROR_FILE_NOT_FOUND;

	// Length of final path.
	DWORD	dwFullPathLength = 0;

	// Buffer for path retrieved by the api search function.
	DWORD	dwFileFullPathBufferSize = 0;
	LPTSTR	szFileFullPathBuffer = NULL;

	// Variables used to get the search path expansion.
	DWORD	dwExpandResult;
	LPTSTR	szExpandedPath = NULL;

	// Check var - used for buffer reallocation routines.
	LPTSTR	pcChange = NULL;						
	// Mini buffer - used to avoid unnecessary memory allocation.
	TCHAR	cMinimalBuffer;							
	
	//
	// Expand the file path string.
	// The expansion is done by the new version of ExpandEnvironmentStrings
	// defined above.
	//
	dwExpandResult = ExpandAllStrings (pcPath, szExpandedPath);
	if (ERROR_SUCCESS != dwExpandResult)
	{
		dwReturnValue = dwExpandResult;
		goto Exit;
	}

	//
	// Function SearchPath is called first only with the minimum valid buffer. It
	// returns a positive number indicating the size of the buffer needed to
	// retrieve the full path to the file (including the null character).
	//
	// If zero is returned, the last error code is retrieved and sent back to
	// the caller (in most cases it will indicate the file was not found).
	//		Otherwise, another call with an allocated buffer of the correct size
	// retrieves the full path. This path is later compared to the path sent by
	// the caller (after expansion).
	//
	dwFileFullPathBufferSize = ::SearchPath (szExpandedPath, pcFileName, NULL, 1, &cMinimalBuffer, NULL);

	if (0 == dwFileFullPathBufferSize)
	{
		dwReturnValue = ::GetLastError ();
		goto Exit;
	}

	//
	// Before allocating more memory to compare the file's full path with the
	// path sent by the caller, the paths' lengths are compared. If they are not
	// equal then the paths won't be, either.
	// The extra 2 characters of the concatenated string are for the terminating
	// null character and the backslash between the file (directory) name and
	// its path.
	//

	// szExpandedPath - holds the search path sent by the caller after all the
	// necessary expansions.
	dwFullPathLength = ::_tcslen (szExpandedPath) + 1 +	// backslash
					   ::_tcslen (pcFileName) + 1;		// NULL
	if (dwFileFullPathBufferSize != dwFullPathLength)
	{	 // The location specified by the caller is not where the file was found.
		dwReturnValue = ERROR_FILE_NOT_FOUND;
		goto Exit;
	}

	//
	// Prepare buffer to retrieve the path found by the api function.
	//
	szFileFullPathBuffer = (LPTSTR)::malloc (sizeof (TCHAR) * dwFileFullPathBufferSize);
	if (NULL == szFileFullPathBuffer)
	{
		dwReturnValue = ERROR_NOT_ENOUGH_MEMORY;
		goto Exit;
	}

	//
	// Retrieving the full path string:
	//
	dwReturnValue = ::SearchPath (szExpandedPath, pcFileName, NULL, dwFileFullPathBufferSize, szFileFullPathBuffer, NULL);
	if (0 == dwReturnValue) // check that no error occurred
	{
		dwReturnValue = ::GetLastError ();
		goto Exit;
	}

	//
	// Concatenate all strings sent by the caller.
	// This will then be compared to the string retrieved by SearchPath.
	//
	if (::_tcslen (szExpandedPath) < dwFullPathLength)
	{
		pcChange = (LPTSTR)::realloc (szExpandedPath, (sizeof (TCHAR) * dwFullPathLength));
		if (NULL == pcChange)
		{
			dwReturnValue = ERROR_NOT_ENOUGH_MEMORY;
			goto Exit;
		}
		szExpandedPath = pcChange;
	}
	::_tcscat (szExpandedPath, TEXT ("\\"));	// extra backslash
	::_tcscat (szExpandedPath, pcFileName);		// file name

	//
	// Compare strings:
	//
	if (0 == ::_tcscmp (szExpandedPath, szFileFullPathBuffer))
	{
		dwReturnValue = ERROR_SUCCESS;		// strings are identical
	}
	else
	{
		dwReturnValue = ERROR_FILE_NOT_FOUND;
	}

Exit:
	if (ERROR_SUCCESS == dwReturnValue)
	{
		szFullPath = szFileFullPathBuffer;	// return string to caller (*note in .h file)
	}
	else
	{
		if (NULL != szFileFullPathBuffer)
		{
			::free (szFileFullPathBuffer);	// string is not returned, therefore it's freed
		}
		szFullPath = NULL;
	}
	if (NULL != szExpandedPath)				// free rest of memory allocated
	{
		::free (szExpandedPath);
	}

	return (dwReturnValue);
}


long DeleteRegKeyRecursively (
	HKEY hParentKey,			// handle to parent key
	LPCTSTR szCurrentKeyName	// name of key to be deleted
	)
{
	long		lReturnValue = ERROR_FILE_NOT_FOUND;
	long		lEnumResult;

	// Handle to the current key, which is to be deleted.
	HKEY		hCurrentKey = NULL;

	// The name of the sub-key currently deleted.
	LPTSTR		szName = NULL;
	DWORD		dwNameBufferSize = 50;
	DWORD		dwNameLength;			// returned by registry functions

	// File write time structure is needed for key enumeration.
	FILETIME	ftSubKey;


	//
	// Stage 1:
	// Check that the key to be deleted actually exists. If it doesn't exist, it
	// is as though its deletion was successful.
	//
	lEnumResult = ::RegOpenKeyEx (hParentKey, szCurrentKeyName, 0, KEY_ALL_ACCESS, &hCurrentKey);
	if (ERROR_FILE_NOT_FOUND == lEnumResult)
	{	// key does not exist - success
		lReturnValue = ERROR_SUCCESS;
		goto Exit;
	}

	if (ERROR_SUCCESS != lEnumResult)
	{	// an error occurred during existence checking
		lReturnValue = lEnumResult;
		goto Exit;
	}

	//
	// Stage 2:
	// Delete all remaining registry values held by key.
	//
	szName = (LPTSTR)::malloc (sizeof (TCHAR) * dwNameBufferSize);
	if (NULL == szName)
	{
		lReturnValue = ERROR_NOT_ENOUGH_MEMORY;
		goto Exit;
	}

	do
	{
		dwNameLength = dwNameBufferSize;
		lEnumResult = ::RegEnumValue (hCurrentKey, 0, szName, &dwNameLength, NULL, NULL, NULL, NULL);
		switch (lEnumResult)
		{
		case ERROR_MORE_DATA :	// The value name is longer than expected,
			{					// increase buffer size.
				dwNameBufferSize *= 2;
				::free (szName);
				szName = (LPTSTR)::malloc (sizeof (TCHAR) * dwNameBufferSize);
				if (NULL == szName)
				{
					lReturnValue = ERROR_NOT_ENOUGH_MEMORY;
					goto Exit;
				}
				lEnumResult = ERROR_SUCCESS;
				break;
			}

		case ERROR_SUCCESS :	// A value exists under the current key, delete
			{					// it.
				lEnumResult = ::RegDeleteValue (hCurrentKey, szName);
				break;
			}
		}
	} while (ERROR_SUCCESS == lEnumResult);

	if (ERROR_NO_MORE_ITEMS != lEnumResult)
	{	// an error occurred, maybe some of the values were not deleted
		lReturnValue = lEnumResult;
		goto Exit;
	}

	//
	// Stage 3:
	// Recursively delete all current key's sub-keys.
	//
	do
	{
		dwNameLength = dwNameBufferSize;
		lEnumResult = ::RegEnumKeyEx (hCurrentKey, 0, szName, &dwNameLength, NULL, NULL, NULL, &ftSubKey);
		switch (lEnumResult)
		{
		case ERROR_MORE_DATA :	// The value name is longer than expected,
			{					// increase buffer size.
				dwNameBufferSize *= 2;
				::free (szName);
				szName = (LPTSTR)::malloc (sizeof (TCHAR) * dwNameBufferSize);
				if (NULL == szName)
				{
					lReturnValue = ERROR_NOT_ENOUGH_MEMORY;
					goto Exit;
				}
				lEnumResult = ERROR_SUCCESS;
				break;
			}

		case ERROR_SUCCESS :	// A value exists under the current key, delete
			{					// it.
				lEnumResult = DeleteRegKeyRecursively (hCurrentKey, szName);
				break;
			}
		}
	} while (ERROR_SUCCESS == lEnumResult);

	if (ERROR_NO_MORE_ITEMS != lEnumResult)
	{	// an error occurred, maybe some of the values were not deleted
		lReturnValue = lEnumResult;
		goto Exit;
	}
	else
	{	// All items were removed. Delete the remaining empty key.
		::RegCloseKey (hCurrentKey);
		hCurrentKey = NULL;
		lReturnValue = ::RegDeleteKey (hParentKey, szCurrentKeyName);
	}

Exit:

	if (NULL != hCurrentKey)
	{
		::RegCloseKey (hCurrentKey);
	}

	if (NULL != szName)
	{
		::free (szName);
	}

	return (lReturnValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\setupinstalltest\logger.h ===
//
//
// Filename:	logger.h
//
//

#ifndef __LOGGER_H
#define __LOGGER_H

#include <windows.h>
#include <log.h>


//
// lgLogCode:
// Logs an error in the Elle logger according to the error code sent to it,
// along with the file name and line from which it was sent.
//------------------------------------------------------------------------------
// Parameters:
// [IN] dwSeverity -	severity of message logged (logger specific).
// [IN] dwCode -		the error code
// [IN] FILE -			name of file from which the function was called
// [IN] LINE -			line number of call in the file
//------------------------------------------------------------------------------
// Note:
// Passing error code ERROR_SUCCESS (0) to the function indicates no error
// occurred, and a "detail" log is made (lgLogDetail) of a success.
//
void __cdecl lgLogCode (
	const DWORD dwSeverity,	// used by the original logger functions
	const DWORD dwCode,		// the code to be searched for and logged
	LPCTSTR FILE,			// the file from where the function was called
	const DWORD LINE		// the line of the call inside the file 
	);

#endif // __LOGGER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\setupinstalltest\filepath.h ===
//
//
// filepath.h
//
//

//
// FilePath:
// Function returns the full path string to the file whose name is specified, if
// the file is found.
// The function works with relative paths and full paths. If just a file name is 
// specified, this indicates to the function that the file is expected in the
// current directory.
//------------------------------------------------------------------------------
// Parameters:
//
// [IN] szFileName -		the path name (with full or relative path).
//------------------------------------------------------------------------------
// Return value:
// A TCHAR null-terminated full path string to the file if it was found, or
// NULL.
//------------------------------------------------------------------------------
// Note:
// If an error occurs during the execution of the function, a message is printed
// to the console to indicate what the nature of the error is and if the user
// should re-check the file name given to the application.
//

LPTSTR FilePath (LPCTSTR szFileName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\setupinstalltest\api_substitute.h ===
//
//
// api_substitute.h
//
//

//
// Substitutions for api functions
//

//
// *Note:
//------------------------------------------------------------------------------
// The functions are called with a referenced parameter which might recieve a
// string to return to the caller. Though the memory needed for the string is
// allocated by the functions, it is THE CALLER'S RESPONSIBILITY to free the
// memory after it is no longer used.
//

#ifndef __API_SUBSTITUTE_H
#define __API_SUBSTITUTE_H

#include <windows.h>
#include <tchar.h>


#define EMPTY_NAME TEXT			("")

//
// CSIDLVAL -	used to associate a CSIDL value with its name.
//
struct CSIDLVAL{
	LPTSTR szName;
	int iValue;
};

#define ILLEGAL_CSIDL_VALUE		(-1)


//
// FindItemByName:
// A template function - find a record in an array, specified by its szName
// field.
//------------------------------------------------------------------------------
// Parameters:
// [IN]	 aT -		an array of records of structure T. The last record is
//					expected to be a flag record, holding the EMPTY_NAME string
//					in the szName field.
// [IN]  szName -	a null terminated string which is expected to appear in the
//					szName field of one of the records in the array aT.
//------------------------------------------------------------------------------
// Return Value:
// The record whose szName field equals the szName string, or the last record
// (holding the EMPTY_STRING in its szName field).
//
template <class T> T FindItemByName (
	const T* aT,	// array of records
	LPCTSTR szName	// name (key) of record searched for
	)
{
	for (UINT i = 0 ; (0 != ::_tcscmp (EMPTY_NAME, aT[i].szName)) ; i++)
	{
		if (0 == ::_tcscmp (aT[i].szName, szName))
		{
			break;
		}
	}
	return (aT[i]);
}

//
// SearchForPath:
// Searches for a file or directory in a specific place in the local file
// system. This is a strict version of the api function SearchPath, and
// permits a broader range of path formats than SearchPath.
//
// This function is more strict in the sense that if the file or directory does
// not appear in the exact place of search, a "file doesn't exist" notification
// is returned (SearchPath considers partial paths OK). If the file was found,
// its full path is returned along with a "success" notification, without the
// need to call it again because of insufficient buffer size.
//
// It permits a broader range of path formats than SearchPath since it can deal
// with environment strings and CSIDL value names.
//------------------------------------------------------------------------------
// Note!
// The function is called with a referenced parameter which might receive a
// path string to return to the caller. Though the memory needed for the string
// is allocated in the function, it is THE CALLER'S RESPONSIBILITY to free the
// memory after it is no longer used.
//------------------------------------------------------------------------------
// Parameters:
// [IN]  pcPath -		The path to the directory holding the file, in one of
//						the formats explained below.
//
// [IN]  pcFileName -	The file / directory name.
//
//
// [OUT] szFullPath -	The pointer which will hold the file's full path, should
//						it be found.
//------------------------------------------------------------------------------
// Return Value:
// One of the Win32 error codes, according to the results of the search and the
// comparison of the path found by SearchPath and the path specified by the
// caller. If the file / directory was found, szFullPath will point to an
// allocated buffer holding the full path, which must be freed by the caller.
//==============================================================================
// Formats:
//
// 1.	pcPath formats:
//		The pcPath parameter must hold a string of one of the following formats:
//		<root path>
//		<root path>[\<sub path>]*
//
//		The format of <root path> can be one of the following:
//		1. A CSIDL value name, such as "CSIDL_PROFILE".
//		2. A drive name, such as "D:\".
//		3. An environment variable, such as "%windir%"
//
//		The format of <sub path> is one of the following:
//		1. A directory's name (according to the rules of directory names in the
//		   local system).
//		2. An environment variable.
//
//		Example:
//		The following three pcPath formats are valid and equal in their meaning:
//		1. CSIDL_WINDOWS\system32
//		2. D:\WINNT\system32
//		3. %windir%\system32
//------------------------------------------------------------------------------
// 2.	pcFileName format:
//		Any valid directory or file name (the file name includes its extension,
//		if it has one)											.
//
//		Examples:
//		If file Mydocument.doc is the file searched for, pcFileName will hold
//		"Mydocument.doc".
//
//		If directory "My Documents" is searched for, then pcFileName will hold
//		"My Documents".
//
DWORD SearchForPath (
	LPCTSTR	pcPath,			// search path
	LPCTSTR	pcFileName,		// file / directory name
	LPTSTR&	szFullPath		// full path buffer of found file / directory
	);

//
// ExpandAllStrings:
// Expand a string which might start with a CSIDL value name, or include
// environment variables.
// This is a broadening of the api function ExpandEnvironmentStrings, which also
// avoids the need to recall it because of buffer size issues.
//------------------------------------------------------------------------------
// Note!
// The function is called with a referenced parameter which might receive a
// string to return to the caller. Though the memory needed for the string is
// allocated by the function, it is THE CALLER'S RESPONSIBILITY to free the
// memory after it is no longer used.
//------------------------------------------------------------------------------
// Parameters:
// [IN]  pcSource -		The string to be expanded in one of the formats
//						explained below.
//
// [OUT] szFullPath -	The pointer which will hold the expanded string.
//------------------------------------------------------------------------------
// Return Value:
// One of the Win32 error codes, according to the results of the expansion
// function calls. If an error ocurred, the referenced pointer will return NULL.
//==============================================================================
// pcSource formats:
//		The pcSource parameter must hold a string of one of the following
//		formats:
//		<CSIDL value name>
//		<CSIDL value name>\<non-empty string>
//		<string not starting with a CSIDL value name>
//
//		Example:
//		The following three pcSource formats are valid:
//		1. CSIDL_WINDOWS
//		2. CSIDL_WINDOWS\system32
//		3. D:\WINNT\system32
//
DWORD ExpandAllStrings (
	LPCTSTR	pcSource,			// string to expand
	LPTSTR&	szExpandedString	// expanded result
	);

//
// DeleteRegKeyRecursively:
// This function deletes a registry key, even if it is not empty, by recursively
// deleting its sub-keys and deleting its values first.
//------------------------------------------------------------------------------
// Parameters:
// [IN]  hParentKey -		a handle to the parent of the key to be deleted.
//
// [OUT] szCurrentKeyName -	the key name.
//------------------------------------------------------------------------------
// Return Value:
// One of the Win32 error codes, according to the results of the deletion
// process.
//
long DeleteRegKeyRecursively (
	HKEY hParentKey,			// handle to parent key
	LPCTSTR szCurrentKeyName	// name of key to be deleted
	);

#endif // __API_SUBSTITUTE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\rendercpapi\testutils.h ===
//
//
// Filename:	testutils.h
// Author:		Sigalit Bar (sigalitb)
// Date:		10-Jan-2000
//
//




#ifndef __TEST_UTILS_H__
#define __TEST_UTILS_H__

#pragma warning(disable :4786)
#include <iniutils.h>
#include <testruntimeerr.h>
#include <tstring.h>

#include <windows.h>
#include <crtdbg.h>
#include <TCHAR.H>

#include <log.h>


#define HELP_SWITCH_1        TEXT("/?")
#define HELP_SWITCH_2        TEXT("/H")
#define HELP_SWITCH_3        TEXT("-?")
#define HELP_SWITCH_4        TEXT("-H")

#define ARGUMENT_IS_INI_FILENAME_NAME   1


//
// Define pointer to test case function
//
#ifdef _PTR_TO_TEST_CASE_FUNC_
#error redefinition of _PTR_TO_TEST_CASE_FUNC_
#else _PTR_TO_TEST_CASE_FUNC_
#define _PTR_TO_TEST_CASE_FUNC_
typedef BOOL (*PTR_TO_TEST_CASE_FUNC)( void ); 
#endif


extern tstring	g_tstrFullPathToIniFile;

//
// Array of pointers to test cases.
// The "runTestCase" (exported) function uses
// this array to activate the n'th test case
// of the module.
//
//IMPORTANT: If you wish to base your test case DLL
//			 implementation on this module, or if
//			 you intend to add test case functions
//			 to this file,
//			 MAKE SURE that all test case functions
//           are listed in this array (by name).
//			 The order of functions within the array
//			 determines their "serial number".
//
extern PTR_TO_TEST_CASE_FUNC    gTestCaseFuncArray[];
extern DWORD                    g_dwTestCaseFuncArraySize;

#define NO_SUCH_TEST_CASE_INDEX (g_dwTestCaseFuncArraySize+1)


//
//
//
void 
UsageInfo(
    INT     argc, 
    TCHAR*   argvT[]
);

//
//
//
HRESULT 
GetCommandLineParams(
    INT     argc, 
    TCHAR*  argvT[], 
    LPTSTR* pszFullPathToTestIniFile
);

//
//
//
std::vector<LONG> GetVectorOfTestCasesToRunFromIniFile(
	IN const tstring& tstrIniFile,
	IN const tstring& tstrSectionName
	);

//
//
//
std::vector<LONG> GetLongVectorFromStrVector ( 
	IN const std::vector<tstring> tstrVector
	);

//
//
//
BOOL testCaseExists(DWORD number);

//
// Runs the "number"th test case in the DLL,
// with parameters "pVoid".
// Returns the return value of that test case.
// Note: if there are less than "number" test
//       cases in the DLL, this function returns
//		 TEST_CASE_FAILURE.
//
HRESULT runTestCase(DWORD number, void* pVoid = NULL);




#endif //__TEST_UTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\setupinstalltest\main.cpp ===
//
//
// Filename:	main.cpp
//
//

#include "suite_functions.h"
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
#include <shellapi.h>
#include "filepath.h"

#pragma warning (disable : 4127)


//
// UsageInfo:
// Outputs the application's proper parameter passing and usage and exits
// the process.
//
void UsageInfo (LPCTSTR szExeName)
{
	::_tprintf (TEXT ("\nChecks for existence of files, directories, registry keys and values in the local system, specified in the given initialization file.\n\n"));
	::_tprintf (TEXT ("Command line:\n  %s source [/N | /D]\n\n"), szExeName);
	::_tprintf (TEXT ("  source	Specifies the path (full or relative) to the initialization file containing the entries.\n"));
	::_tprintf (TEXT ("  /N		Confirm non-existence of entries.\n"));
	::_tprintf (TEXT ("  /D		Delete all entries.\n"));
	::_tprintf (TEXT ("\n\nExamples:\n\n"));
	::_tprintf (TEXT ("   %s Entries.ini\n\n"), szExeName);
	::_tprintf (TEXT ("=> Tests if the entries in the Entries.ini file exist in the local system.\n\n\n\n"));
	::_tprintf (TEXT ("   %s Entries.ini /N\n\n"), szExeName);
	::_tprintf (TEXT ("=> Tests if all the entries in the Entries.ini file do not exist in the local system.\n\n\n\n"));
	::_tprintf (TEXT ("   %s Entries.ini /D\n\n"), szExeName);
	::_tprintf (TEXT ("=> Deletes any existing entry in the Entries.ini file from the local system.\n"));
	::_tprintf (TEXT ("   Reports if the local system has been successfully cleaned at the end of the process.\n\n\n\n"));
	::_tprintf (TEXT ("For more information read the Readme.doc file.\n\n"));
}


int __cdecl main (
	int argc,
	char *argvA[]
	)
{
	// The path of the ini file holding the test items.
	LPTSTR		szIniFilePath = NULL;
//	DWORD		dwIniFilePathLength = 0;

	// Indication if the test is successful when the items are found, or when
	// they don't exist.
	bool		fExistenceOfItems = true;

	// Indicates if to delete "unwanted" entries (an entry that should not have
	// been found - fExistenceOfItems == false).
	bool		fDeleteExistingEntries = false;

	// Function return value: 0 indicates success.
	int			iReturnValue = 1;

	// Variables for manipulating the command line parameters.
	wchar_t*	szCmdLine = NULL;
	TCHAR**		argvT = NULL; // generic-type command line parameter array
	wchar_t**	argvW = NULL; // wide-char parameter array (for translation only)
	int			argc2 = 0;	  // used for translation only


	//
	// Part 1:
	// Parse the command line parameters:
	// arg no. 1 -	the path to the initialization file holding the test entries.
	// arg no. 2 -	indicates if the test application is to check the
	//				non-existence of the items written in the ini file, or to
	//				delete any existing entries.
	//
	// The parsing is done after the data is obtained in the right format for
	// the local machine: Unicode or Ansi.
	//

#ifdef UNICODE	//	Unicode  //

	//
	// Variable used only with Ansi:
	//
	UNREFERENCED_PARAMETER(argvA);

    szCmdLine = ::GetCommandLineW ();	// get command line string in Unicode
    if (NULL == szCmdLine)
    {
		iReturnValue = 1;				// failure
        ::_tprintf (TEXT ("[main] GetCommandLineW failed with error 0x%08X.\n"), ::GetLastError ());
        goto ExitFunc;
    }
	// change parameters to unicode format
    argvW = ::CommandLineToArgvW (szCmdLine, &argc2);
    if (NULL == argvW)					// an error occurred during function call
    {
		iReturnValue = 1;				// failure
        ::_tprintf (TEXT ("[main] CommandLineToArgvW failed with error 0x%08X.\n"), ::GetLastError ());
        goto ExitFunc;
    }
    if (argc != argc2)					// number of arguments doesn't match
    {
		iReturnValue = 1;				// failure
        ::_tprintf(TEXT ("[main] argc (%d) != argc2 (%d).\n"), argc, argc2);
		argvW = (wchar_t**)::GlobalFree (argvW);
        _ASSERTE (argc == argc2);
		if (NULL != argvW)
		{
			::_tprintf (TEXT ("[main] memory held by argvW could not be freed, error 0x%08X.\n"), ::GetLastError ());
		}
        goto ExitFunc;
    }
    argvT = argvW;

#else	//	Ansi  //
	
	//
	// Variables used only with Unicode:
	//
	UNREFERENCED_PARAMETER(argvW);
	UNREFERENCED_PARAMETER(szCmdLine);
	UNREFERENCED_PARAMETER(argc2);


    argvT = argvA;

#endif	//	Unicode  / Ansi
	//
	// argvT now holds pointers to the command line parameters in the correct
	// format, while argc indicates the number of these parameters.
	//

	//
	// Part 2:
	// Check the parameters and continue accordingly.
	//
	if ((2 > argc) ||	// no ini file is specified, or flag specified is not "/D", "/d","/N" or "/n"
		((3 == argc) && (0 != ::_tcscmp (argvT[2], TEXT ("/N"))) && (0 != ::_tcscmp (argvT[2], TEXT ("/n"))) && (0 != ::_tcscmp (argvT[2], TEXT ("/D"))) && (0 != ::_tcscmp (argvT[2], TEXT ("/d")))) ||
		(3 < argc))
	{					// give user information about the application and abort
		UsageInfo (argvT[0]);
		exit (0);
	}

	//
	// Check that the ini file exists and retrieve its exact location. The
	// command line parameter is expected to contain the full path to the file
	// or the path relative to the current directory.
	// The buffer needed to hold the full path is allocated by function FilePath
	// and freed at the end of this function, when it is no longer needed.
	// If the file isn't found an error message is printed along with
	// suggestions for the user, and the application is exited.
	//
	szIniFilePath = FilePath (argvT[1]);
	if (NULL == szIniFilePath)
	{
		exit (0);	// Failure (FilePath already printed error message)/
	}

	if (3 == argc)
	{
		fExistenceOfItems = false;	// entries are not expected in the system
		if ((0 == ::_tcscmp (argvT[2], TEXT ("/D"))) || (0 == ::_tcscmp (argvT[2], TEXT ("/d"))))
		{	// request to delete existing entries
			fDeleteExistingEntries = true;
		}
	}

	if (!TestSuiteSetup ())
	{
		iReturnValue = 1;	// failure
		goto ExitFunc;
	}

	//
	// Part 3:
	// Test case procedures are called sequentially. Each procedure returns the
	// state of the local system, for example if entries were checked for
	// existence and were all found, the return value is true.
	//
	iReturnValue = 0;	// All initializations were OK, now iReturnValue will
						// indicate the local system's state after the test.

    if (!FilesTests (szIniFilePath, fExistenceOfItems, fDeleteExistingEntries))
	{
		iReturnValue = 1;	// Indicates failure
	}

	if (!DirectoriesTests (szIniFilePath, fExistenceOfItems, fDeleteExistingEntries))
	{
		iReturnValue = 1;	// Indicates failure
	}

	if (!RegistryValuesTests (szIniFilePath, fExistenceOfItems, fDeleteExistingEntries))
	{
		iReturnValue = 1;	// Indicates failure
	}
	

	if (!RegistryKeysTests (szIniFilePath, fExistenceOfItems, fDeleteExistingEntries))
	{
		iReturnValue = 1;	// Indicates failure
	}



	if (fExistenceOfItems)	// test was after setup
	{
		if (0 == iReturnValue)
		{
			::lgLogDetail (0, 0, TEXT ("\n\n\nSetup was completed successfully.\n\n\n"));
		}
		else
		{
			::lgLogDetail (0, 1, TEXT ("\n\n\nSetup failure - items are missing.\n\n\n"));
		}
	}
	else	// request was to check the non-existence of items
	{
		if (fDeleteExistingEntries)	// request made to clean the system (ensure
		{							// the non-existence of the items)
			if (0 == iReturnValue)
			{
				::lgLogDetail (0, 0, TEXT ("\n\n\nLocal system successfully cleaned.\n\n\n"));
			}
			else
			{
				::lgLogDetail (0, 1, TEXT ("\n\n\nFailure cleaning system.\nPlease check log for details.\n\n\n"));
			}
		}
		else						// request was JUST to check non-existance (after
		{							// an uninstall procedure)
			if (0 == iReturnValue)
			{
				::lgLogDetail (0, 0, TEXT ("\n\n\nUninstall process completed successfully.\nLocal system is clean.\n\n\n"));
			}
			else
			{
				::lgLogDetail (0, 1, TEXT ("\n\n\nUninstall process failed to clean system.\nPlease run the test application again with the \"/D\" flag to clean the system.\n\n\n"));
			}
		}
	}

ExitFunc:
	if (NULL != szIniFilePath)
	{
		::free (szIniFilePath);
	}

	TestSuiteShutdown();

	return (iReturnValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\setupinstalltest\regvaltest.h ===
//
//
// Filename:	regvaltest.h
//
//

#ifndef __REGVALTEST_H
#define __REGVALTEST_H

#include <windows.h>

//
// Error codes for the RegCheckValue* functions declared below.
// There exists no overlapping of these codes and the Win32 error codes.
//
// value data exists and equals the entry
#define VALUE_DATA_SUCCESS		ERROR_SUCCESS

// value's data different from entry
#define VALUE_DATA_MISMATCH		MAXDWORD

// value's data type did not match the required type
#define VALUE_TYPE_MISMATCH		(MAXDWORD - 1)

// value doesn't exist in the registry
#define VALUE_NOT_FOUND			ERROR_FILE_NOT_FOUND

// memory allocation during testing of value
#define VALUE_MEMORY_ERROR		(MAXDWORD - 3)

// an error exists in the data passed from the ini file
#define VALUE_INI_DATA_ERROR	(MAXDWORD - 4)


//
// RegCheckValueREG_DWORD:
// Checks the existence of the value whose name is passed to it, and the
// equality of the data it holds and the entry passed to the function.
// The value is expected to hold data of type REG_DWORD.
//------------------------------------------------------------------------------
// Parameters:
// [IN] szValueName -		the value's name.
//
// [IN] hSubKey -			a handle pointing to the registry key under which
//							the value is expected to be.
// [IN] dwIniValueData -	the data the value is expected to hold.
//------------------------------------------------------------------------------
// Return Value:
// One of the error codes defined above or one of the Win32 error codes,
// according to the outcome of the test.
//
DWORD RegCheckValueREG_DWORD (
	LPCTSTR szValueName,		// value name
	const HKEY hSubKey,			// sub key which is supposed to contain the value
	const DWORD dwIniValueData	// data which is supposed to be held by the value
	);

//
// RegCheckValueREG_SZ:
// Checks the existence of the value whose name is passed to it, and the
// equivalence of the string it holds and the string passed to the function.
// The value is expected to hold data of type REG_SZ.
// Note that the data might have to be expanded, both from the ini file and the
// registry.
//------------------------------------------------------------------------------
// Parameters:
// [IN] szValueName -		the value's name.
//
// [IN] hSubKey -			a handle pointing to the registry key under which
//							the value is expected to be.
// [IN] pcIniValueData -	the string the value is expected to hold.
//------------------------------------------------------------------------------
// Return Value:
// One of the error codes defined above or one of the Win32 error codes,
// according to the outcome of the test.
//
DWORD RegCheckValueREG_SZ (
	LPCTSTR szValueName,	// value name
	const HKEY hSubKey,		// sub key which is supposed to contain the value
	LPCTSTR pcIniValueData	// data which is supposed to be held by the value
	);

//
// RegCheckValueREG_EXPAND_SZ:
// Checks the existence of the value whose name is passed to it, and the
// equality of the expansion of the string it holds and the expansion of the
// string passed to the function.
// The value is expected to hold data of type REG_EXPAND_SZ.
//------------------------------------------------------------------------------
// Parameters:
// [IN] szValueName -		the value's name.
//
// [IN] hSubKey -			a handle pointing to the registry key under which
//							the value is expected to be.
// [IN] pcIniValueData -	the string the value data is expected to equal after
//							expansion.
//------------------------------------------------------------------------------
// Return Value:
// One of the error codes defined above or one of the Win32 error codes,
// according to the outcome of the test.
//
DWORD RegCheckValueREG_EXPAND_SZ (
	LPCTSTR szValueName,	// value name
	const HKEY hSubKey,		// sub key which is supposed to contain the value
	LPCTSTR pcIniValueData	// data which is supposed to be held by the value
	);

//
// RegCheckValueREG_MULTI_SZ:
// Checks the existence of the value whose name is passed to it, and the
// equality of the expansion of the string it holds and the expansion of the
// string passed to the function.
// The value is expected to hold data of type REG_MULTI_SZ, which means several
// sub-strings are held by the value, separated by nulls. Note that the
// sub-strings in the ini file are separated by spaces.
//------------------------------------------------------------------------------
// Parameters:
// [IN] szValueName -		the value's name.
//
// [IN] hSubKey -			a handle pointing to the registry key under which
//							the value is expected to be.
// [IN] pcIniValueData -	the string the value data is expected to equal after
//							expansion and chang of spaces into NULLs.
//------------------------------------------------------------------------------
// Return Value:
// One of the error codes defined above or one of the Win32 error codes,
// according to the outcome of the test.
//
DWORD RegCheckValueREG_MULTI_SZ (
	LPCTSTR szValueName,	// value name
	const HKEY hSubKey,		// sub key which is supposed to contain the value
	LPCTSTR pcIniValueData	// data which is supposed to be held by the value
	);

//
// RegCheckValueREG_BINARY:
// Checks the existence of the value whose name is passed to it, and the
// equality of the data it holds and the data represented by the string passed
// to the function.
// The value is expected to hold data of type REG_BINARY, which means the data
// is a series of bytes.
//------------------------------------------------------------------------------
// Parameters:
// [IN] szValueName -		the value's name.
//
// [IN] hSubKey -			a handle pointing to the registry key under which
//							the value is expected to be.
// [IN] pcIniValueData -	the string representing the data that the registry
//							value is expected to contain.
//------------------------------------------------------------------------------
// Return Value:
// One of the error codes defined above or one of the Win32 error codes,
// according to the outcome of the test.
//
DWORD RegCheckValueREG_BINARY (
	LPCTSTR szValueName,	// value name
	const HKEY hSubKey,		// sub key which is supposed to contain the value
	LPCTSTR pcIniValueData	// data which is supposed to be held by the value
	);

#endif // __REGVALTEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\setupinstalltest\suite_functions.h ===
//
//
// Filename:	suite_functions.h
//
//

#ifndef __SUITE_FUNCTIONS_H
#define __SUITE_FUNCTIONS_H

#include <windows.h>
#include "logger.h"

#define FILES			TEXT("Files")
#define DIRECTORIES		TEXT("Directories")
#define REGISTRY_KEYS	TEXT("Registry Keys")
#define REGISTRY_VALUES	TEXT("Registry Values")

// Indication of failure reading data from ini file - used by the testcases
// functions.
#define SECTION_DATA_FAILURE	MAXDWORD

typedef bool (*TestCaseFunctionType)(LPCTSTR, const bool, const bool);


//
// TestSuiteSetup:
// Initializes logger.
//------------------------------------------------------------------------------
// Return values:
// TRUE if successful, otherwise FALSE.
//
bool __cdecl TestSuiteSetup (void);

//
// FilesTests:
// Checks the (non)existence of all the file entries in the input initialization
// file. Deletes unwanted entries if indicated by the input parameters.
//------------------------------------------------------------------------------
// Parameters:
// [IN] szIniFilePath -				the path to the initialization file, as read
//									from the command line
//
// [IN] fCheckExistence -			indicates if existence is considered as
//									success, or rather non-existence.
//
// [IN] fDeleteExistingEntries -	if non-existence is considered success, this
//									parameter indicates if the existing entries
//									should be deleted
//------------------------------------------------------------------------------
// Return Value:
// The state of the local system according to the section:
// 1. If the items were expected to be found and were all found, return value is
//    true.
// 2. If the items were not expected to be found and none were found, the return
//	  value is true.
// 3. If a request was made to delete the items and they were all either deleted
//	  successfully or were not found in the first place, return value is true.
// For all other cases the return value is false.
//
bool FilesTests (
	LPCTSTR szIniFilePath,
	const bool fCheckExistence,
	const bool fDeleteExistingEntries
	);

//
// DirectoriesTests:
// Checks the (non)existence of all the directory entries in the input
// initialization file. Deletes unwanted entries if indicated by the input
// parameters.
//------------------------------------------------------------------------------
// Parameters:
// [IN] szIniFilePath -				the path to the initialization file, as read
//									from the command line
//
// [IN] fCheckExistence -			indicates if existence is considered as
//									success, or rather non-existence.
//
// [IN] fDeleteExistingEntries -	if non-existence is considered success, this
//									parameter indicates if the existing entries
//									should be deleted
//------------------------------------------------------------------------------
// Return Value:
// The state of the local system according to the section:
// 1. If the items were expected to be found and were all found, return value is
//    true.
// 2. If the items were not expected to be found and none were found, the return
//	  value is true.
// 3. If a request was made to delete the items and they were all either deleted
//	  successfully (along with their descendants) or were not found in the first
//	  place, return value is true.
// For all other cases the return value is false.
//
bool DirectoriesTests (
	LPCTSTR szIniFilePath,
	const bool fCheckExistence,
	const bool fDeleteExistingEntries
	);

//
// RegistryValuesTests:
// Checks the (non)existence of all the registry value entries in the input
// initialization file. Deletes unwanted entries if indicated by the input
// parameters.
//------------------------------------------------------------------------------
// Parameters:
// [IN] szIniFilePath -				the path to the initialization file, as read
//									from the command line
//
// [IN] fCheckExistence -			indicates if existence is considered as
//									success, or rather non-existence.
//
// [IN] fDeleteExistingEntries -	if non-existence is considered success, this
//									parameter indicates if the existing entries
//									should be deleted
//------------------------------------------------------------------------------
// Return Value:
// The state of the local system according to the section:
// 1. If the items were expected to be found and were all found, return value is
//    true.
// 2. If the items were not expected to be found and none were found, the return
//	  value is true.
// 3. If a request was made to delete the items and they were all either deleted
//	  successfully or were not found in the first place, return value is true.
// For all other cases the return value is false.
//
bool RegistryValuesTests (
	LPCTSTR szIniFilePath,
	const bool fCheckExistence,
	const bool fDeleteExistingEntries
	);

//
// RegistryKeysTests:
// Checks the (non)existence of all the registry key entries in the input
// initialization file. Deletes unwanted entries if indicated by the input
// parameters.
//------------------------------------------------------------------------------
// Parameters:
// [IN] szIniFilePath -				the path to the initialization file, as read
//									from the command line
//
// [IN] fCheckExistence -			indicates if existence is considered as
//									success, or rather non-existence.
//
// [IN] fDeleteExistingEntries -	if non-existence is considered success, this
//									parameter indicates if the existing entries
//									should be deleted
//------------------------------------------------------------------------------
// Return Value:
// The state of the local system according to the section:
// 1. If the items were expected to be found and were all found, return value is
//    true.
// 2. If the items were not expected to be found and none were found, the return
//	  value is true.
// 3. If a request was made to delete the items and they were all either deleted
//	  successfully (along with their descendants) or were not found in the first
//	  place, return value is true.
// For all other cases the return value is false.
//
bool RegistryKeysTests (
	LPCTSTR szIniFilePath,
	const bool fCheckExistence,
	const bool fDeleteExistingEntries
	);

//
// TestSuiteShutdown:
// Perform test suite cleanup (close logger).
//------------------------------------------------------------------------------
// Return Value:
// TRUE if successful, FALSE otherwise.
//
bool __cdecl TestSuiteShutdown (void);

#endif // __SUITE_FUNCTIONS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\setupinstalltest\regvaltest.cpp ===
//
//
// Filename:	regvaltest.cpp
//
//

#include "regvaltest.h"
#include "api_substitute.h"
#include <tchar.h>
#include <crtdbg.h>
#include <winbase.h>

// Const used for increasing the size of the buffer holding data read from the
// registry.
#define REG_DATA_INCREMENT	100
#pragma warning (disable : 4127)  

DWORD RegCheckValueREG_DWORD (
	LPCTSTR szValueName,		// value name
	const HKEY hSubKey,			// sub key which is supposed to contain the value
	const DWORD dwIniValueData	// data which is supposed to be held by the value
	)
{
	// Variables holding information about the data from registry value:
	DWORD	dwRegValueType;					// data type
	DWORD	dwRegValueData;					// value data
	DWORD	dwRegDataSize = sizeof (DWORD);	// (expected) data size

	DWORD	dwReturnValue;
	
	//
	// A call to RegQueryValueEx checks existence and copies the value if it
	// exists under the key indicated by handle hSubKey.
	//
	dwReturnValue = ::RegQueryValueEx (hSubKey, szValueName, NULL, &dwRegValueType, (LPBYTE)&dwRegValueData, &dwRegDataSize);
	
	//
	// If the value exists, its data type and value is checked.
	//
	if (ERROR_SUCCESS == dwReturnValue)	// check existence
	{
		if (REG_DWORD == dwRegValueType)	// check type
		{
			if (dwIniValueData == dwRegValueData)	// check data
			{
				return (VALUE_DATA_SUCCESS);
			}
			else
			{
				return (VALUE_DATA_MISMATCH);
			}
		}
		else
		{
			return (VALUE_TYPE_MISMATCH);
		}
	}

	//
	// Otherwise the error code is checked.
	// First possibility:
	// If the registry holds more data than a DWORD variable can store, the data
	// can't be of type REG_DWORD.
	//
	if (ERROR_MORE_DATA == dwReturnValue)
	{
		return (VALUE_TYPE_MISMATCH);
	}
	
	//
	// Second possibility:
	// The value was not found.
	//
	if (ERROR_FILE_NOT_FOUND == dwReturnValue)
	{
		return (VALUE_NOT_FOUND);
	}

	//
	// Last possibility:
	// An unknown error occurred. The error code is returned.
	//
	return (dwReturnValue);
}

//
// RegCheckValueREG_X_SZ:
// Checks the existence of the value whose name is passed to it, and the
// equivalence of the string it holds and the string passed to the function.
// The equality of the data type is checked also, and should be either REG_SZ,
// REG_EXPAND_SZ or REG_MULTI_SZ (other types are not string types).
// Note that the data might have to be expanded, both from the ini file and the
// registry, to rid of CSIDL value names and environment variables.
// MULTI_SZ data from ini file is changed - all commas are changed into NULLS to
// fit the description of the multi_sz strings in the registry.
//------------------------------------------------------------------------------
// Parameters:
// [IN] szValueName -		the value's name.
//
// [IN] hSubKey -			a handle pointing to the registry key under which
//							the value is expected to be.
// [IN] pcIniValueData -	the string the value is expected to hold.
//
// [IN] dwData_Type -		the data type of the value.
//------------------------------------------------------------------------------
// Return Value:
// One of the error codes defined in the *.h file or one of the Win32 error
// codes, according to the outcome of the test.
//
DWORD RegCheckValueREG_X_SZ (
	LPCTSTR szValueName,	// value name
	const HKEY hSubKey,		// sub key which is supposed to contain the value
	LPCTSTR pcIniValueData,	// data which is supposed to be held by the value
	const DWORD dwData_Type	// registry data type (either REG_SZ or REG_EXPAND_SZ)
	)
{
	// Variables holding information about the data from registry value:
	DWORD	dwRegValueType;					// data type
	LPTSTR	szRegValueData = NULL;			// value data
	DWORD	dwRegDataSize;					// (expected) data size

	DWORD	dwReturnValue;

	// Buffer used to hold the expanded value data from the ini file:
	LPTSTR	szIniExpandedValueData = NULL;

	// Buffer used to hold the expanded value data from the registry:
	LPTSTR	szRegExpandedValueData = NULL;

	// Variable used to change MULTI_SZ strings:
	LPTSTR	pcChange = NULL;

	//
	// The value string written in the ini file can include CSIDL values or
	// environment variables. For this reason first the token held by
	// pcIniValueData is expanded into a string which does not contain such
	// sub-strings.
	//
	dwReturnValue = ExpandAllStrings (pcIniValueData, szIniExpandedValueData);
	if (ERROR_SUCCESS != dwReturnValue)
	{	// An error occurred during expansion.
		goto Exit;
	}

	//
	// A buffer is allocated to retrieve the data held in the registry. Since
	// the data is expected to be similar to szIniExpandedValueData, a buffer
	// of the same size is expected to be sufficient to hold that data.
	// If such a buffer cannot be allocated, the data can't be retrieved from
	// the registry.
	//

	// size in bytes
	dwRegDataSize = (::_tcsclen (szIniExpandedValueData) + 1) * sizeof (TCHAR);
	szRegValueData = (LPTSTR)::malloc (dwRegDataSize);
	
	if (NULL == szRegValueData)
	{
		dwReturnValue = VALUE_MEMORY_ERROR;
		goto Exit;
	}
	//
	// If the registry value does not contain any data, RegQueryValueEx doesn't
	// touch the buffer just allocated. This leaves the buffer uninitialized,
	// which is not a valid situation if it's supposed to be compared to the
	// data sent by the caller. to avoid this, the buffer is always initialized
	// to contain the empty string.
	//
	::_tcscpy (szRegValueData, TEXT (""));
	
	//
	// A call to RegQueryValueEx checks if the value exists under the key
	// indicated by handle hSubKey.
	// The possible return values are:
	// 1. ERROR_SUCCESS	-	indicating the value exists and its data was
	//						successfully retrieved.
	// 2. ERROR_MORE_DATA -	indicating a larger buffer is needed to retrieve
	//						the data held in the registry. The buffer is
	//						reallocated with increasing size, until its size is
	//						sufficient to hold the data from the registry.
	// 3. other values -	an unknown error occurred.
	//
	dwReturnValue = ::RegQueryValueEx (hSubKey, szValueName, NULL, & dwRegValueType, (LPBYTE)szRegValueData, &dwRegDataSize);

	//
	// Case #2:
	// The data string in the registry is larger, reallocate the buffer.
	//
	while (ERROR_MORE_DATA == dwReturnValue)
	{
		::free (szRegValueData);
		dwRegDataSize += (REG_DATA_INCREMENT * sizeof (TCHAR));
		szRegValueData = (LPTSTR)::malloc (dwRegDataSize);
		if (NULL == szRegValueData)
		{
			dwReturnValue = VALUE_MEMORY_ERROR;
			goto Exit;
		}
		::_tcscpy (szRegValueData, TEXT (""));	// Very unlikely that no data
												// exists, but this doesn't hurt.
		dwReturnValue = ::RegQueryValueEx (hSubKey, szValueName, NULL, & dwRegValueType, (LPBYTE)szRegValueData, &dwRegDataSize);
	}

	//
	// Case #3:
	// An error occurred which is not related to the buffer size, the comparison
	// test can't be completed. The return value of the call to RegQueryValueEx
	// is returned as a notification of an error.
	//
	if (ERROR_SUCCESS != dwReturnValue)
	{
		goto Exit;
	}

	//
	// Case #1:
	// At this point the data has been successfully retrieved from the registry,
	// and it must be expanded. Afterwards its type and value must be compared
	// to the ini file data after expansion.
	//
	dwReturnValue = ExpandAllStrings (szRegValueData, szRegExpandedValueData);
	if (ERROR_SUCCESS != dwReturnValue)
	{	// An error occurred during expansion.
		goto Exit;
	}

	// Type comparison:
	//
	if (dwData_Type != dwRegValueType)
	{
		dwReturnValue = VALUE_TYPE_MISMATCH;
		goto Exit;
	}
	
	// Data comparison:

	//
	// For REG_MULTI_SZ type data the ini string must be changed - all spaces
	// are converted into NULLs. This is done with the help of _tcstok which
	// searches for tokens separated by a given character. The function changes
	// each such character into NULL while it searches along the string;
	//
	if (dwData_Type == REG_MULTI_SZ)
	{
		pcChange = ::_tcstok (szIniExpandedValueData, TEXT ("+"));
		for (; pcChange != NULL ; pcChange = ::_tcstok (NULL, TEXT ("+")));
	}
	//
	// Now szIniExpandedValueData holds sub-strings separated by NULL characters
	// instead of spaces.
	//

	if (0 == ::_tcscmp (szIniExpandedValueData, szRegExpandedValueData))
	{
		dwReturnValue = VALUE_DATA_SUCCESS;
		goto Exit;
	}

	// Data was not identical:
	//
	dwReturnValue = VALUE_DATA_MISMATCH;

Exit:
	if (NULL != szRegValueData)
	{
		::free (szRegValueData);
	}
	if (NULL != szIniExpandedValueData)
	{
		::free (szIniExpandedValueData);
	}
	if (NULL != szRegExpandedValueData)
	{
		::free (szRegExpandedValueData);
	}

	return (dwReturnValue);
}

DWORD RegCheckValueREG_BINARY (
	LPCTSTR szValueName,		// value name
	const HKEY hSubKey,			// sub key which is supposed to contain the value
	LPCTSTR pcIniValueData	// data which is supposed to be held by the value
	)
{
	DWORD	dwRegValueType;			// data type of value in registry
	DWORD	dwRegDataSize;			// size of data in registry
	LPBYTE	pbRegValueData = NULL;	// registry data buffer

	DWORD	dwReturnValue = VALUE_NOT_FOUND;

	// Copy of the ini data string.
	LPTSTR	pcIniValueDataCopy = NULL;

	// Ini data buffer - for converted data.
	LPBYTE	pbIniValueData = NULL;
	DWORD	dwIniValueDataSize;

	// Token pointer used in conversion of string to bytes.
	LPTSTR	pcToken;

	// Place in byte buffer(s).
	ULONG	ulPlace;

	// Converted sub-string of a hexadecimal display.
	ULONG	ulIntegerNumber;

	// Variable used with string-to-int conversion function.
	LPTSTR	pcEndOfNum;

	//
	// A buffer is needed to be allocated to convert the string passed from the
	// ini file into byte values. Each two hexadecimal digit characters is
	// converted into a single byte. Since each such couple is separated by
	// commas, each three characters in the string represent one byte. The
	// string does not end with a comma, therefore an extra '1' for an ending
	// comma is used in the calculation of the buffer size.
	//

	//
	// Check that the string's length is as expected for strings of the
	// structure explained above.
	//
	_ASSERTE (2 == (::_tcsclen (pcIniValueData) % 3));
	dwIniValueDataSize = (::_tcsclen (pcIniValueData) + 1) / 3;
	pbIniValueData = (LPBYTE)::malloc (dwIniValueDataSize);
	if (NULL == pbIniValueData)
	{
		dwReturnValue = VALUE_MEMORY_ERROR;
		goto Exit;
	}

	//
	// The string must be changed to enable the conversion. To avoid changing
	// the original string, it is copied into a new buffer of the same size.
	//
	pcIniValueDataCopy = (LPTSTR)::malloc (sizeof (TCHAR) * (::_tcslen (pcIniValueData) + 1));
	if (NULL == pcIniValueDataCopy)
	{
		dwReturnValue = VALUE_MEMORY_ERROR;
		goto Exit;
	}
	::_tcscpy (pcIniValueDataCopy, pcIniValueData);

	//
	// Initialize ini data buffer:
	//
	ZeroMemory (pbIniValueData, dwIniValueDataSize);

	//
	// The conversion is done in the following manner:
	// 1.	The string is checked for the first comma. The sub-string up to the
	//		comma is pointed to by pcToken, and the comma is changed into a null
	//		character.
	// 2.	The sub-string, which is expected to have only hexadecimal digit
	//		characters, is converted into an integer.
	// 3.	If the conversion is successful (no non-hexadecimal chars were found
	//		etc.) the lower byte is copied to the first byte in the buffer. This
	//		conversion is valid by cast in the Visual C environment.
	// 4.	This process is repeated until the end of the string is reached (or
	//		the end of the buffer is reached, which means an error exists in the
	//		ini string).
	//

	// 1. Take token:
	pcToken = ::_tcstok (pcIniValueDataCopy, TEXT (","));
	ulPlace = 0;
	while (NULL != pcToken)
	{
		//
		// If the token is larger than two characters, the string in the ini
		// file is not of the correct structure.
		// If the current token is not null, but the buffer has been filled, an
		// error exists in the ini value data string and the conversion cannot
		// be completed.
		//
		if ((2 != ::_tcslen (pcToken)) || (dwIniValueDataSize <= ulPlace))
		{
			dwReturnValue = VALUE_INI_DATA_ERROR;
			goto Exit;
		}

		// 2. Convert:
		ulIntegerNumber = ::_tcstoul (pcToken, &pcEndOfNum, 16);
		if ((NULL != pcEndOfNum) && (TEXT ('\0') == *pcEndOfNum))
		{	//
			// The token did not include non-hexadecimal chars and ended with a
			// NULL character.
			//

			// 3. Take lower byte:
			pbIniValueData[ulPlace++] = (char)ulIntegerNumber;

			// 1. Take next token:
			pcToken = ::_tcstok (NULL, TEXT (","));
		}
		else
		{
			//
			// The sub-string was not a valid hexadecimal number. This means an
			// error exists in the ini file data.
			//
			dwReturnValue = VALUE_INI_DATA_ERROR;
			goto Exit;
		}
	}

	//
	// Allocate a buffer of the same size to retrieve the registry data. Since
	// the data is expected to be identical to that recorded in the ini file, a
	// buffer of the same size is expected to be large enough to hold the data
	// from the registry.
	//
	dwRegDataSize = dwIniValueDataSize;
	pbRegValueData = (LPBYTE)::malloc (dwRegDataSize);
	if (NULL == pbRegValueData)
	{
		dwReturnValue = VALUE_MEMORY_ERROR;
		goto Exit;
	}
	
	//
	// Initialize registry data buffer:
	//
	ZeroMemory (pbRegValueData, dwRegDataSize);

	//
	// Retrieve data from registry:
	//
	dwReturnValue = ::RegQueryValueEx (hSubKey, szValueName, NULL, &dwRegValueType, pbRegValueData, &dwRegDataSize);

	if (ERROR_SUCCESS != dwReturnValue)
	{
		//
		// An error occurred during data retrieval. End test.
		//
		goto Exit;
	}

	//
	// Compare the two buffers: if they are equal then the test returns a
	// success value, else the test returns a "data mismatch" value.
	//
	if (0 == ::memcmp (pbIniValueData, pbRegValueData, dwIniValueDataSize))
	{
		dwReturnValue = ERROR_SUCCESS;
	}
	else
	{
		dwReturnValue = VALUE_DATA_MISMATCH;
	}

Exit:
	//
	// Free all allocated memory:
	//
	if (NULL != pbRegValueData)
	{
		::free (pbRegValueData);
	}
	if (NULL != pbIniValueData)
	{
		::free (pbIniValueData);
	}
	if (NULL != pcIniValueDataCopy)
	{
		::free (pcIniValueDataCopy);
	}

	return (dwReturnValue);
}

DWORD RegCheckValueREG_EXPAND_SZ (
	LPCTSTR szValueName,	// value name
	const HKEY hSubKey,		// sub key which is supposed to contain the value
	LPCTSTR pcIniValueData	// data which is supposed to be held by the value
	)
{
	return (RegCheckValueREG_X_SZ (szValueName, hSubKey, pcIniValueData, REG_EXPAND_SZ));
}


DWORD RegCheckValueREG_SZ (
	LPCTSTR szValueName,	// value name
	const HKEY hSubKey,		// sub key which is supposed to contain the value
	LPCTSTR pcIniValueData	// data which is supposed to be held by the value
	)
{
	return (RegCheckValueREG_X_SZ (szValueName, hSubKey, pcIniValueData, REG_SZ));
}


DWORD RegCheckValueREG_MULTI_SZ (
	LPCTSTR szValueName,	// value name
	const HKEY hSubKey,		// sub key which is supposed to contain the value
	LPCTSTR pcIniValueData	// data which is supposed to be held by the value
	)
{
	return (RegCheckValueREG_X_SZ (szValueName, hSubKey, pcIniValueData, REG_MULTI_SZ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\setupinstalltest\tcs.cpp ===
//
//
// Filename:	suite_functions.cpp
//
// Contains functions for each possible test case of the Setup / Uninstall Test
// Suite.
//

#include "tcs.h"
#include <tchar.h>
#include "regvaltest.h"
#include "logger.h"
#include <shlwapi.h>
#include "api_substitute.h"


//
// s_ahkHKEYvalues associates between a root key name and its predefined handle.
//
static const KEYDATA s_ahkHKEYvalues[] = {
	{TEXT ("HKEY_CLASSES_ROOT"),				HKEY_CLASSES_ROOT		},
	{TEXT ("HKEY_CURRENT_CONFIG"),				HKEY_CURRENT_CONFIG		},
	{TEXT ("HKEY_CURRENT_USER"),				HKEY_CURRENT_USER		},
	{TEXT ("HKEY_LOCAL_MACHINE"),				HKEY_LOCAL_MACHINE		},
	{TEXT ("HKEY_USERS"),						HKEY_USERS				},
	{TEXT ("HKEY_PERFORMANCE_DATA"),			HKEY_PERFORMANCE_DATA	},
	{EMPTY_NAME,								ILLEGAL_REG_HKEY_VALUE	}
};

//
// s_atdREG_TYPEvalues associates between each registry data type name and the code
// signifying it.
//
static const TYPEDATA s_atdREG_TYPEvalues[] = {
	{TEXT ("REG_BINARY"),						REG_BINARY						},
	{TEXT ("REG_RESOURCE_REQUIREMENTS_LIST"),	REG_RESOURCE_REQUIREMENTS_LIST	},
	{TEXT ("REG_DWORD"),						REG_DWORD						},
	{TEXT ("REG_DWORD_LITTLE_ENDIAN"),			REG_DWORD_LITTLE_ENDIAN			},
	{TEXT ("REG_DWORD_BIG_ENDIAN"),				REG_DWORD_BIG_ENDIAN			},
	{TEXT ("REG_EXPAND_SZ"),					REG_EXPAND_SZ					},
	{TEXT ("REG_LINK"),							REG_LINK						},
	{TEXT ("REG_MULTI_SZ"),						REG_MULTI_SZ					},
	{TEXT ("REG_NONE"),							REG_NONE						},
	{TEXT ("REG_RESOURCE_LIST"),				REG_RESOURCE_LIST				},
	{TEXT ("REG_SZ"),							REG_SZ							},
	{EMPTY_NAME,								ILLEGAL_REG_TYPE_VALUE			}
};


bool DirectoryTestCase (
	LPCTSTR szIniDataLine,
	const bool fCheckForItem,
	const bool fDeleteIfExists
	)
{
	// Copy of ini data passed to function.
	DWORD	dwDataBufferSize;
	LPTSTR	szDataBuffer = NULL;

	// Pointers to tokens:
	LPTSTR	pcDirectoryPath = NULL;	// points to the directory path token
	LPTSTR	pcDirectoryName = NULL;	// points to the directory name token
	
	// buffer which will include full path to directory
	LPTSTR	szDirectoryPathBuffer = NULL;

	DWORD	dwResult;				// function error codes concerning the directory
	bool	fReturnValue = false;	// function return value

	// The following variables are used only by the deletion process.
	DWORD	dwFromStringLength = 0;
	LPTSTR	szFromString = NULL;

	// The following structure is used to force delete a directory's descendants
	// (files and directories). It is used only when the directory exists, and a
	// request has been made to delete it (fCheckForItem == false AND
	// fDeleteIfExists == true).
	SHFILEOPSTRUCT	foInformation;

	//
	// Copy the data passed to the function to avoid changing it:
	//
	dwDataBufferSize = ::_tcslen (szIniDataLine) + 1;
	szDataBuffer = (LPTSTR)::malloc (sizeof (TCHAR) * dwDataBufferSize);
	if (NULL == szDataBuffer)
	{
		::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Unable to copy test case data."), TEXT (__FILE__), __LINE__);
		fReturnValue = false;
		goto Exit;
	}
	::_tcscpy (szDataBuffer, szIniDataLine);

	//
	// First all the tokens are parsed from the data line.
	// The first token is the path to the directory:
	//
	pcDirectoryPath = ::_tcstok (szDataBuffer, TEXT ("="));

	if (TEXT ('\0') == pcDirectoryPath)
	{
		::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Missing directory path in ini file."), TEXT (__FILE__), __LINE__);
		fReturnValue = false;
		goto Exit;
	}

	//
	// The second token is the directory name:
	//
	pcDirectoryName = ::_tcstok (NULL, TEXT ("\n"));
	if (TEXT ('\0') == pcDirectoryName)
	{
		::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Missing directory name in ini file."), TEXT (__FILE__), __LINE__);
		fReturnValue = false;
		goto Exit;
	}

	//
	// Check existence of directory in the exact specified location:
	//
	dwResult = SearchForPath (pcDirectoryPath, pcDirectoryName, szDirectoryPathBuffer);

	//
	// Compare search result with expected result:
	//
	if (fDeleteIfExists)	// Request was to delete / confirm deletion of the entry.
	{
		if (ERROR_FILE_NOT_FOUND == dwResult)	// Entry was already deleted.
		{
			fReturnValue = true;
			::lgLogDetail (0, 1, TEXT ("FILE: %s LINE: %d\n Directory %s\\%s was deleted."), TEXT (__FILE__), __LINE__, pcDirectoryPath, pcDirectoryName);
			goto Exit;
		}
		if (ERROR_SUCCESS == dwResult)	// Entry still exists in local system -
		{								// attempt to delete it along with its
										// descendants.

			// Initialize the SHFILEOPSTRUCT structure:
			// 1.	The path pFrom is initialized to hold szDirectoryPathBuffer
			//		and ends with an additional NULL character.
			dwFromStringLength = ::_tcslen (szDirectoryPathBuffer) + 2;	// two ending NULLs
			
			szFromString = (LPTSTR)::malloc (sizeof (TCHAR) * dwFromStringLength);

			if (NULL != szFromString)
			{
				::_tcscpy (szFromString, szDirectoryPathBuffer);
				szFromString[dwFromStringLength - 1] = TEXT ('\0');	// the extra NULL
				foInformation.pFrom = szFromString;
			}
			else // problem allocating buffer, can't force delete directory and descendants
			{
				fReturnValue = false;	// unable to delete existing entry
				::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Memory allocation problems. Could not delete directory %s."), TEXT (__FILE__), __LINE__, szDirectoryPathBuffer);
				goto Exit;
			}
			
			// 2.	Initialize all other structure fields:
			foInformation.hwnd = NULL;			// no window is related to the function call
			foInformation.wFunc = FO_DELETE;	// operation is "delete"

			// The rest of the fields are initialized to defaults:
			foInformation.pTo = NULL;
			foInformation.fFlags = FOF_NOCONFIRMATION + FOF_NOERRORUI + FOF_SILENT;
			foInformation.fAnyOperationsAborted = FALSE;
			foInformation.hNameMappings = NULL;
			foInformation.lpszProgressTitle = TEXT ("");
			
			// 3.	Call the operation function:
			if (0 == ::SHFileOperation (&foInformation))
			{	// Success deleting directory and its descendants.
				fReturnValue = true;
				::lgLogDetail (0, 1, TEXT ("FILE: %s LINE: %d\n Directory %s was deleted."), TEXT (__FILE__), __LINE__, szDirectoryPathBuffer);
				goto Exit;
			}
			else	// couldn't delete directory
			{
				fReturnValue = false;
				::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Unable to delete directory %s and some of its descendants."), TEXT (__FILE__), __LINE__, szDirectoryPathBuffer);
				goto Exit;
			}
		}

		//
		// An error occurred during search for the directory. A directory which
		// wasn't found cannot be deleted.
		//
		fReturnValue = false;
		lgLogCode (1, dwResult, TEXT (__FILE__), __LINE__);
		::lgLogError (1, TEXT ("FILE: %s LINE: %d\n State of directory %s\\%s unknown."), TEXT (__FILE__), __LINE__, pcDirectoryPath, pcDirectoryName);
	}	// End of processing delete requests.


	if (ERROR_SUCCESS == dwResult)	// Item was found in local system.
	{
		if (fCheckForItem)	// Item was expected to be found - good!
		{
			fReturnValue = true;
			::lgLogDetail (0, 1, TEXT ("FILE: %s LINE: %d\n Directory %s was found, as expected."), TEXT (__FILE__), __LINE__, szDirectoryPathBuffer);
			goto Exit;
		}
		else				// Item was not expected to be found - bad.
		{
			fReturnValue = false;
			::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Directory %s was unexpectedly found."), TEXT (__FILE__), __LINE__, szDirectoryPathBuffer);
			goto Exit;
		}
	}

	if (ERROR_FILE_NOT_FOUND == dwResult)	// Item was not found in local system.
	{
		if (fCheckForItem)	// Item was expected to be found - bad.
		{
			fReturnValue = false;
			::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Directory %s was not found, was expected under %s."), TEXT (__FILE__), __LINE__, pcDirectoryName, pcDirectoryPath);
			goto Exit;
		}
		else				// Item was not expected to be found - good!
		{
			fReturnValue = true;
			::lgLogDetail (0, 1, TEXT ("FILE: %s LINE: %d\n Directory %s\\%s was not found, as expected."), TEXT (__FILE__), __LINE__, pcDirectoryName, pcDirectoryPath);
			goto Exit;
		}
	}

	//
	// An error occurred during search for the directory. (The request was to
	// check (non) existence only, no deletion.)
	//
	fReturnValue = false;
	lgLogCode (1, dwResult, TEXT (__FILE__), __LINE__);
	::lgLogError (1, TEXT ("FILE: %s LINE: %d\n State of directory %s\\%s unknown."), TEXT (__FILE__), __LINE__, pcDirectoryPath, pcDirectoryName);

Exit:
	//
	// Free the memory allocated for foInformation.pFrom (the path with the wild
	// card) to help delete the directory's descendants:
	//
	if (NULL != szFromString)
	{
		::free (szFromString);
	}

	//
	// Delete other buffers allocated:
	//
	if (NULL != szDataBuffer)
	{
		::free (szDataBuffer);
	}

	if (NULL != szDirectoryPathBuffer)
	{
		::free (szDirectoryPathBuffer);
	}
	return (fReturnValue);
}


bool FileTestCase (
	LPCTSTR szIniDataLine,
	const bool fCheckForItem,
	const bool fDeleteIfExists
	)
{
	// Copy of ini data passed to function.
	DWORD	dwDataBufferSize;
	LPTSTR	szDataBuffer = NULL;

	// Pointers to tokens:
	LPTSTR	pcFilePath = NULL;		// points to the file path token
	LPTSTR	pcFileName = NULL;		// points to the file name token

	// Buffer which will hold full path to file:
	LPTSTR	szFilePathBuffer = NULL;

	// function error codes concerning the file
	DWORD	dwResult;

	bool	fReturnValue = false;

	//
	// Copy the data passed to the function to avoid changing it:
	//
	dwDataBufferSize = ::_tcslen (szIniDataLine) + 1;
	szDataBuffer = (LPTSTR)::malloc (sizeof (TCHAR) * dwDataBufferSize);
	if (NULL == szDataBuffer)
	{
		::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Unable to copy test case data."), TEXT (__FILE__), __LINE__);
		fReturnValue = false;
		goto Exit;
	}
	::_tcscpy (szDataBuffer, szIniDataLine);

	//
	// First all the tokens are parsed from the data line.
	// The first token is the path to the file:
	//
	pcFilePath = ::_tcstok (szDataBuffer, TEXT ("="));

	if (TEXT ('\0') == pcFilePath)
	{
		::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Missing file path in ini file."), TEXT (__FILE__), __LINE__);
		fReturnValue = false;
		goto Exit;
	}

	//
	// The second token is the filename:
	//
	pcFileName = ::_tcstok (NULL, TEXT ("\n"));
	if (TEXT ('\0') == pcFileName)
	{
		::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Missing file name in ini file."), TEXT (__FILE__), __LINE__);
		fReturnValue = false;
		goto Exit;
	}
	
	//
	// Check existence of file in the exact specified place:
	//
	dwResult = SearchForPath (pcFilePath, pcFileName, szFilePathBuffer);

	//
	// Compare search result with expected result:
	//
	if (fDeleteIfExists)	// Request was to delete / confirm deletion of the entry.
	{
		if (ERROR_FILE_NOT_FOUND == dwResult)	// Entry was already deleted.
		{
			fReturnValue = true;
			::lgLogDetail (0, 1, TEXT ("FILE: %s LINE: %d\n File %s\\%s was deleted."), TEXT (__FILE__), __LINE__, pcFilePath, pcFileName);
			goto Exit;
		}
		if (ERROR_SUCCESS == dwResult)	// Entry still exists in local system -
		{								// attempt to delete it.

			if (0 != ::DeleteFile (szFilePathBuffer))
			{	// Success deleting the file.
				fReturnValue = true;
				::lgLogDetail (0, 1, TEXT ("FILE: %s LINE: %d\n File %s was deleted."), TEXT (__FILE__), __LINE__, szFilePathBuffer);
				goto Exit;
			}
			else
			{	// Failure deleting the file.
				fReturnValue = false;
				lgLogCode (1, ::GetLastError (), TEXT (__FILE__), __LINE__);
				::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Unable to delete file %s."), TEXT (__FILE__), __LINE__, szFilePathBuffer);
				goto Exit;
			}
		}

		//
		// An error occurred during search for the file. An entry which wasn't
		// found cannot be deleted.
		//
		fReturnValue = false;
		lgLogCode (1, dwResult, TEXT (__FILE__), __LINE__);
		::lgLogError (1, TEXT ("FILE: %s LINE: %d\n State of file %s\\%s unknown."), TEXT (__FILE__), __LINE__, pcFilePath, pcFileName);
	}	// End of processing delete requests.


	if (ERROR_SUCCESS == dwResult)	// Item was found in local system.
	{
		if (fCheckForItem)	// Item was expected to be found - good!
		{
			fReturnValue = true;
			::lgLogDetail (0, 1, TEXT ("FILE: %s LINE: %d\n File %s was found, as expected."), TEXT (__FILE__), __LINE__, szFilePathBuffer);
			goto Exit;
		}
		else				// Item was not expected to be found - bad.
		{
			fReturnValue = false;
			::lgLogError (1, TEXT ("FILE: %s LINE: %d\n File %s was unexpectedly found."), TEXT (__FILE__), __LINE__, szFilePathBuffer);
			goto Exit;
		}
	}

	if (ERROR_FILE_NOT_FOUND == dwResult)	// Item was not found in local system.
	{
		if (fCheckForItem)	// Item was expected to be found - bad.
		{
			fReturnValue = false;
			::lgLogError (1, TEXT ("FILE: %s LINE: %d\n File %s was not found, was expected under %s."), TEXT (__FILE__), __LINE__, pcFileName, pcFilePath);
			goto Exit;
		}
		else				// Item was not expected to be found - good!
		{
			fReturnValue = true;
			::lgLogDetail (0, 1, TEXT ("FILE: %s LINE: %d\n File %s\\%s was not found, as expected."), TEXT (__FILE__), __LINE__, pcFileName, pcFilePath);
			goto Exit;
		}
	}

	//
	// An error occurred during search for the file. (The request was to check
	// (non) existence only, no deletion.)
	//
	fReturnValue = false;
	lgLogCode (1, dwResult, TEXT (__FILE__), __LINE__);
	::lgLogError (1, TEXT ("FILE: %s LINE: %d\n State of file %s\\%s unknown."), TEXT (__FILE__), __LINE__, pcFilePath, pcFileName);

Exit:
	if (NULL != szDataBuffer)
	{
		::free (szDataBuffer);
	}
	if (NULL != szFilePathBuffer)
	{
		::free (szFilePathBuffer);
	}

	return (fReturnValue);
}


bool RegistryKeyTestCase (
	LPCTSTR szIniDataLine,
	const bool fCheckForItem,
	const bool fDeleteIfExists
	)
{
	// Copy of ini data passed to function.
	DWORD	dwDataBufferSize;
	LPTSTR	szDataBuffer = NULL;

	// Pointers to tokens:
	LPTSTR	pcRootKeyName = NULL;	// points to the key path's root key token
	LPTSTR	pcSubKeyName = NULL;	// points to the key's sub-path token

	// Handles to registry keys:
	HKEY	hRootKey;				// holds handle to the root key
	HKEY	hSubKey;				// holds handle to the key itself

	// function error codes concerning registry
	DWORD	dwResult;

	bool	fReturnValue = false;
	
	//
	// Copy the data passed to the function to avoid changing it:
	//
	dwDataBufferSize = ::_tcslen (szIniDataLine) + 1;
	szDataBuffer = (LPTSTR)::malloc (sizeof (TCHAR) * dwDataBufferSize);
	if (NULL == szDataBuffer)
	{
		::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Unable to copy test case data."), TEXT (__FILE__), __LINE__);
		fReturnValue = false;
		goto Exit;
	}
	::_tcscpy (szDataBuffer, szIniDataLine);

	//
	// The first token is the desired key's root key name.
	//
	pcRootKeyName = ::_tcstok (szDataBuffer, TEXT ("\\"));

	//
	// The validity of the token is checked - if no predefined handle is
	// associated with it, the token is not a valid root key name, and the test
	// fails.
		
	hRootKey = FindItemByName<KEYDATA> (s_ahkHKEYvalues, pcRootKeyName).hKey;
	if (NULL == hRootKey)
	{
		::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Root key name invalid: %s."), TEXT (__FILE__), __LINE__, pcRootKeyName);
		fReturnValue = false;
		goto Exit;
	}
	
	//
	// The next token is the sub-path to the desired key, including the key's
	// name.
	// Any key name is valid, including an empty string (in which case the
	// reference is to the root key).
	//
	pcSubKeyName = ::_tcstok (NULL, TEXT ("\n"));

	//
	// The next step is to check the key's existence.
	// Any result besides ERROR_SUCCESS and ERROR_FILE_NOT_FOUND are treated as
	// an unrecoverable error, causing an error to be logged.
	// Error codes ERROR_SUCCESS and ERROR_FILE_NOT_FOUND are compared to the
	// fCheckForItem variable and are logged accordingly.
	//
	dwResult = ::RegOpenKeyEx (hRootKey, pcSubKeyName, 0, KEY_ALL_ACCESS, &hSubKey);
	
	//
	// Close handle to registry and compare results with the expected result:
	//
	if (ERROR_SUCCESS == dwResult)
	{
		::RegCloseKey (hSubKey);
	}

	if (fDeleteIfExists)	// Request was to delete / confirm deletion of the entry.
	{
		if (ERROR_FILE_NOT_FOUND == dwResult)	// Entry was already deleted.
		{
			fReturnValue = true;
			::lgLogDetail (0, 1, TEXT ("FILE: %s LINE: %d\n Registry key %s\\%s was deleted."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName);
			goto Exit;
		}
		if (ERROR_SUCCESS == dwResult)	// Entry still exists in local registry -
		{								// attempt to delete it along with its
										// descendants.
			dwResult = DeleteRegKeyRecursively (hRootKey, pcSubKeyName);
			if (ERROR_SUCCESS == dwResult)
			{	// Success deleting registry key and its descendants
				fReturnValue = true;
				::lgLogDetail (0, 1, TEXT ("FILE: %s LINE: %d\n Registry key %s\\%s was deleted."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName);
				goto Exit;
			}
			else
			{	// Failure deleting registry key or some of its descendants
				fReturnValue = false;
				lgLogCode (1, dwResult, TEXT (__FILE__), __LINE__);
				::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Unable to delete registry key %s\\%s or some of its descendants."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName);
				goto Exit;
			}
		}

		//
		// An error occurred during search for the registry key. An entry which
		// wasn't found cannot be deleted.
		//
		fReturnValue = false;
		lgLogCode (1, dwResult, TEXT (__FILE__), __LINE__);
		::lgLogError (1, TEXT ("FILE: %s LINE: %d\n State of registry key %s\\%s unknown."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName);
	}	// End of processing delete requests.


	if (ERROR_SUCCESS == dwResult)	// Item was found in local registry.
	{
		if (fCheckForItem)	// Item was expected to be found - good!
		{
			fReturnValue = true;
			::lgLogDetail (0, 1, TEXT ("FILE: %s LINE: %d\n Registry key %s\\%s was found, as expected."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName);
			goto Exit;
		}
		else				// Item was not expected to be found - bad.
		{
			fReturnValue = false;
			::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Registry key %s\\%s was unexpectedly found."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName);
			goto Exit;
		}
	}

	if (ERROR_FILE_NOT_FOUND == dwResult)	// Item was not found in local system.
	{
		if (fCheckForItem)	// Item was expected to be found - bad.
		{
			fReturnValue = false;
			::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Registry key %s was not found, was expected under root key %s."), TEXT (__FILE__), __LINE__, pcSubKeyName, pcRootKeyName);
			goto Exit;
		}
		else				// Item was not expected to be found - good!
		{
			fReturnValue = true;
			::lgLogDetail (0, 1, TEXT ("FILE: %s LINE: %d\n Registry key %s\\%s was not found, as expected."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName);
			goto Exit;
		}
	}

	//
	// An error occurred during search for the registry key. (The request was to
	// check (non) existence only, no deletion.)
	//
	fReturnValue = false;
	lgLogCode (1, dwResult, TEXT (__FILE__), __LINE__);
	::lgLogError (1, TEXT ("FILE: %s LINE: %d\n State of registry key %s\\%s unknown."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName);

Exit:
	if (NULL != szDataBuffer)
	{
		::free (szDataBuffer);
	}

	return (fReturnValue);
}


bool RegistryValueTestCase (
	LPCTSTR szIniDataLine,
	const bool fCheckForItem,
	const bool fDeleteIfExists
	)
{
	// Copy of ini data passed to function.
	DWORD	dwDataBufferSize;
	LPTSTR	szDataBuffer = NULL;

	// Token pointers:
	LPTSTR	pcRootKeyName = NULL;	// points to the root key token
	LPTSTR	pcSubKeyName = NULL;	// points to the key's sub-path token
	LPTSTR	pcValueName = NULL;		// points to the value's name token
	LPTSTR	pcValueTypeName = NULL; // points to the value's data type token
	LPTSTR	pcValueData = NULL;		// points to the value's data token

	// Registry key handles:
	HKEY	hRootKey;				// holds handle to the root key
	HKEY	hSubKey;				// holds handle to the key itself

	// Function error codes concerning registry.
	DWORD	dwResult;
	
	DWORD	dwValueType;			// The code of the value's data type
	DWORD	dwValueDwordData;		// Holds data specifically of type REG_DWORD
	LPTSTR	pcEndOfNum = NULL;		// Used to convert string to number
	
	bool	fReturnValue = false;
	
	//
	// Copy the data passed to the function to avoid changing it:
	//
	dwDataBufferSize = ::_tcslen (szIniDataLine) + 1;
	szDataBuffer = (LPTSTR)::malloc (sizeof (TCHAR) * dwDataBufferSize);
	if (NULL == szDataBuffer)
	{
		::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Unable to copy test case data."), TEXT (__FILE__), __LINE__);
		fReturnValue = false;
		goto Exit;
	}
	::_tcscpy (szDataBuffer, szIniDataLine);

	//
	// The first token is the desired value's root key name.
	//
	pcRootKeyName = ::_tcstok (szDataBuffer, TEXT ("\\"));

	//
	// The validity of the token is checked - if no predefined handle is
	// associated with it, the token is not a valid root key name, and the test
	// fails.
	//
	hRootKey = FindItemByName<KEYDATA> (s_ahkHKEYvalues, pcRootKeyName).hKey;
	if (NULL == hRootKey)
	{
		::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Root key name invalid: %s."), TEXT (__FILE__), __LINE__, pcRootKeyName);
		fReturnValue = false;
		goto Exit;
	}

	//
	// The next token is the sub-path to the key which is expected to hold the
	// value searched for.
	// Any key name is valid except for the empty string (in which case the
	// reference is apparently to the root key).
	//
	pcSubKeyName = ::_tcstok (NULL, TEXT ("="));

	//
	// The next token is the value's name.
	// If the value name is missing, the test is terminated after sending an
	// error message to the logger.
	//
	pcValueName = ::_tcstok (NULL, TEXT ("\""));
	if (TEXT ('\0') == pcValueName)
	{
		::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Missing value name in ini file."), TEXT (__FILE__), __LINE__);
		fReturnValue = false;
		goto Exit;
	}

	//
	// Reference to default values: the string "@" indicates the entry is of the
	// default value.
	//
	if (0 == ::_tcscmp (TEXT ("@"), pcValueName))
	{
		pcValueName = NULL;
	}

	//
	// The next token is the value's data type:
	// A missing data type terminates the test after a message is sent to the
	// logger.
	//
	pcValueTypeName = ::_tcstok (NULL, TEXT ("\""));
	if (TEXT ('\0') == pcValueTypeName)
	{
		::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Missing value data type in ini file."), TEXT (__FILE__), __LINE__);
		fReturnValue = false;
		goto Exit;
	}
	
	//
	// The data type is checked - if it's not a valid registry data type name,
	// an error message is sent to the logger and the test is terminated.
	//
	dwValueType = FindItemByName<TYPEDATA> (s_atdREG_TYPEvalues, pcValueTypeName).lTypeCode;
	if (MAXDWORD == dwValueType)
	{
		::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Unknown data type: %s."), TEXT (__FILE__), __LINE__, pcValueTypeName);
		fReturnValue = false;
		goto Exit;
	}

	//
	// The last token is the data itself, which is a string. If the string is
	// empty (NULL is returned), then a valid empty string must be pointed to.
	//
	pcValueData = ::_tcstok (NULL, TEXT ("\n"));
	if (TEXT ('\0') == pcValueData)
	{
		pcValueData = (LPTSTR)::malloc (sizeof (TCHAR) * 1);
		if (NULL == pcValueData)
		{
			::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Memory allocation problem while allocating empty data string."), TEXT (__FILE__), __LINE__);
			fReturnValue = false;
			goto Exit;
		}
		::_tcscpy (pcValueData, TEXT (""));
	}

	//
	// The next step is to check the existence of the registry key holding the
	// value.
	// Any result besides ERROR_SUCCESS and ERROR_FILE_NOT_FOUND are treated as
	// an unrecoverable error, causing an error to be logged.
	// Error codes ERROR_SUCCESS and ERROR_FILE_NOT_FOUND are compared to the
	// fCheckForItem variable and are dealt with accordingly.
	//
	dwResult = ::RegOpenKeyEx (hRootKey, pcSubKeyName, 0, KEY_ALL_ACCESS, &hSubKey);
	
	//
	// Case #1: the registry key expected to hold the value is missing.
	//
	if (ERROR_FILE_NOT_FOUND == dwResult)
	{
		if (fDeleteIfExists)	// Request was to delete the entry.
		{
			fReturnValue = true;
			::lgLogDetail (0, 1, TEXT ("FILE: %s LINE: %d\n Registry value %s\\%s\\%s was deleted."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName, pcValueName);
			goto Exit;
		}
		if (!fCheckForItem)		// Item was not expected to be found.
		{
			fReturnValue = true;
			::lgLogDetail (0, 1, TEXT ("FILE: %s LINE: %d\n Registry value %s\\%s\\%s was not found, as expected."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName, pcValueName);
			goto Exit;
		}

		// Item was expected to be found - error.
		::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Registry value %s was not found, expected under %s\\%s."), TEXT (__FILE__), __LINE__, pcValueName, pcRootKeyName, pcSubKeyName);
		fReturnValue = true;
		goto Exit;
	}

	//
	// Case #2: an error other than missing key occurred during search in
	// registry. This is considered an error, no matter if the value was
	// expected to exist or not.
	//
	if (ERROR_SUCCESS != dwResult)
	{
		fReturnValue = false;
		lgLogCode (1, dwResult, TEXT (__FILE__), __LINE__);
		::lgLogError (1, TEXT ("FILE: %s LINE: %d\n State of registry value %s\\%s\\%s unknown."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName, pcValueName);
	}

	//
	// Case #3: the key which is supposed to hold the value exists, and
	// hSubKey returns as a handle to it.
	//
	// The final step is to check:
	// 1. the value exists in the specified location in the registry
	// 2. the value holds data of the type specified in the ini file
	// 3. the value's data is identical to the data specified in the ini
	//	  file
	//
	switch (dwValueType)
	{
	case REG_DWORD :		// Data is a hexadecimal number:
		{
		//
		// The string from the ini file is transformed into a decimal number. If
		// the data string cannot be fully transformed into a decimal number,
		// the data in the file is incorrect. Otherwise, the data is sent to a
		// function which checks the three things mentioned above:
		// value existence, value data type and data equality.
		//
			dwValueDwordData = ::_tcstoul (pcValueData, &pcEndOfNum, 16);
			if ((NULL != pcEndOfNum) && (TEXT ('\0') == *pcEndOfNum))
			{
				// These checks indicate the string was not a valid
				// representation of a hexadecimal number.
				dwResult = RegCheckValueREG_DWORD (pcValueName, hSubKey, dwValueDwordData);
			}
			else	// string from ini file was not a number
			{
				dwResult = VALUE_TYPE_MISMATCH;
			}
			break;
		}
	
	case REG_BINARY :
		{ 
			dwResult = RegCheckValueREG_BINARY (pcValueName, hSubKey, pcValueData);
			break;
		}

	case REG_SZ :			// Data is a string:
		{ 
			dwResult = RegCheckValueREG_SZ (pcValueName, hSubKey, pcValueData);
			break;
		}
		
	case REG_EXPAND_SZ :	// Data is a string, possibly with need to be expanded.
		{
		//
		// The value data and ini file data are checked for equivalence rather
		// than equality, since they might differ but their expansions may not.
		//
			dwResult = RegCheckValueREG_EXPAND_SZ (pcValueName, hSubKey, pcValueData);
			break;
		}
		
	case REG_MULTI_SZ :		// Data is a multi-string: sub-strings separated by
		{					// characters in the registry and spaces in the ini file.
		//
		// The value data and ini file data are checked for equivalence rather
		// than equality, since they might differ but their expansions may not.
		//
			dwResult = RegCheckValueREG_MULTI_SZ (pcValueName, hSubKey, pcValueData);
			break;
		}
		//
		// All the other data types have yet to be implemented.
		//
	default :
		{
			::lgLogError (0, TEXT ("FILE: %s LINE: %d\n Unsupported registry data type: %s"), TEXT (__FILE__), __LINE__, pcValueTypeName);
			fReturnValue = false;
			goto CloseKey;
		}
	}

	//
	// Messages and errors are logged according to the results and expected
	// results.
	//
	if (fDeleteIfExists)	// Request was to delete / confirm deletion of the entry.
	{
		if (VALUE_NOT_FOUND == dwResult)	// Entry was already deleted.
		{
			fReturnValue = true;
			::lgLogDetail (0, 1, TEXT ("FILE: %s LINE: %d\n Registry value %s\\%s\\%s was deleted."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName, pcValueName);
			goto CloseKey;
		}
		if (VALUE_DATA_SUCCESS == dwResult)	// Entry still exists in registry -
		{									// attempt to delete it.
			dwResult = ::RegDeleteValue (hSubKey, pcValueName);
			if (ERROR_SUCCESS == dwResult)
			{	// Success deleting the value.
				fReturnValue = true;
				::lgLogDetail (0, 1, TEXT ("FILE: %s LINE: %d\n Registry value %s\\%s\\%s was deleted."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName, pcValueName);
				goto CloseKey;
			}
			else
			{	// Failure deleting the registry value.
				fReturnValue = false;
				lgLogCode (1, ::GetLastError (), TEXT (__FILE__), __LINE__);
				::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Unable to delete registry value %s\\%s\\%s."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName, pcValueName);
				goto CloseKey;
			}
		}
		if (VALUE_MEMORY_ERROR == dwResult)
		{		// Failure checking if value exists due to memory allocation problems.
			fReturnValue = false;
			::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Memory allocation problems occurred during search for value."), TEXT (__FILE__), __LINE__);
			::lgLogError (1, TEXT ("FILE: %s LINE: %d\n State of registry value %s\\%s\\%s unknown."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName, pcValueName);
			goto CloseKey;
		}
		if ((VALUE_DATA_MISMATCH == dwResult) || (VALUE_TYPE_MISMATCH == dwResult))
		{		// Value exists, but is not the same as the entry specifications
				// passed to the function.
			fReturnValue = false;
			if (VALUE_DATA_MISMATCH == dwResult)
			{
				::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Value %s\\%s\\%s exists in registry, holds different data from entry."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName, pcValueName);
			}
			else
			{
				::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Value %s\\%s\\%s exists in registry, holds data of different type from entry."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName, pcValueName);
			}
			::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Not deleting value %s\\%s\\%s."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName, pcValueName);
			goto CloseKey;
		}

		//
		// An error occurred during search for the value. An entry which wasn't
		// found cannot be deleted.
		//
		fReturnValue = false;
		lgLogCode (1, dwResult, TEXT (__FILE__), __LINE__);
		::lgLogError (1, TEXT ("FILE: %s LINE: %d\n State of registry value %s\\%s\\%s unknown."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName, pcValueName);
	}	// End of processing delete requests.

	if (VALUE_DATA_SUCCESS == dwResult)	// Item was found in local registry.
	{
		if (fCheckForItem)	// Item was expected to be found - good!
		{
			fReturnValue = true;
			::lgLogDetail (0, 1, TEXT ("FILE: %s LINE: %d\n Registry value %s\\%s\\%s was found, as expected."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName, pcValueName);
			goto CloseKey;
		}
		else				// Item was not expected to be found - bad.
		{
			fReturnValue = false;
			::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Registry value %s\\%s\\%s was unexpectedly found."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName, pcValueName);
			goto CloseKey;
		}
	}

	if (VALUE_NOT_FOUND == dwResult)	// Item was not found in local registry.
	{
		if (fCheckForItem)	// Item was expected to be found - bad.
		{
			fReturnValue = false;
			::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Registry value %s was not found, was expected under %s\\%s."), TEXT (__FILE__), __LINE__, pcValueName, pcRootKeyName, pcSubKeyName);
			goto CloseKey;
		}
		else				// Item was not expected to be found - good!
		{
			fReturnValue = true;
			::lgLogDetail (0, 1, TEXT ("FILE: %s LINE: %d\n Registry value %s\\%s\\%s was not found, as expected."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName, pcValueName);
			goto CloseKey;
		}
	}

	if (VALUE_MEMORY_ERROR == dwResult)	// Memory allocation problems.
	{
		fReturnValue = false;
		::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Memory allocation problems occurred during search for value."), TEXT (__FILE__), __LINE__);
		::lgLogError (1, TEXT ("FILE: %s LINE: %d\n State of registry value %s\\%s\\%s unknown."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName, pcValueName);
		goto CloseKey;
	}

	if ((VALUE_DATA_MISMATCH == dwResult) || (VALUE_TYPE_MISMATCH == dwResult))
	{	// Value exists, but is not the same as the entry specifications passed
		// to the function. This will be considered as "value doesn't exist".
		if (fCheckForItem)	// Error - real value wasn't found.
		{
			fReturnValue = false;
			if (VALUE_DATA_MISMATCH == dwResult)
			{
				::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Value %s\\%s\\%s exists in registry, holds different data from entry."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName, pcValueName);
			}
			else
			{
				::lgLogError (1, TEXT ("FILE: %s LINE: %d\n Value %s\\%s\\%s exists in registry, holds data of different type from entry."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName, pcValueName);
			}
			goto CloseKey;
		}
		else	// Value was not expected to be found - OK.
		{
			fReturnValue = true;
			if (VALUE_DATA_MISMATCH == dwResult)
			{
				::lgLogDetail (0, 1, TEXT ("FILE: %s LINE: %d\n CAUTION! Value %s\\%s\\%s exists in registry, holds different data from entry."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName, pcValueName);
			}
			else
			{
				::lgLogDetail (0, 1, TEXT ("FILE: %s LINE: %d\n CAUTION! Value %s\\%s\\%s exists in registry, holds data of different type from entry."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName, pcValueName);
			}
			goto CloseKey;
		}
	}

	//
	// An error occurred during search for the file. (The request was to check
	// (non) existence only, no deletion.)
	//
	fReturnValue = false;
	lgLogCode (1, dwResult, TEXT (__FILE__), __LINE__);
	::lgLogError (1, TEXT ("FILE: %s LINE: %d\n State of registry value %s\\%s\\%s unknown."), TEXT (__FILE__), __LINE__, pcRootKeyName, pcSubKeyName, pcValueName);

CloseKey:
	::RegCloseKey (hSubKey);

Exit:
	if (0 == ::_tcscmp (pcValueData, TEXT ("")))
	{
		::free (pcValueData);
	}
	if (NULL != szDataBuffer)
	{
		::free (szDataBuffer);
	}
	

	return (fReturnValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\xxxunusedxxx\setupinstalltest\suite_functions.cpp ===
//
//
// Filename:	suite_functions.cpp
//
//

#include "suite_functions.h"
#include "tcs.h"
#include <tchar.h>
#include <stdio.h>

// Const used for incrementing the section data buffer's size.
#define SECTION_DATA_INCREMENT 100


bool __cdecl TestSuiteSetup (void)
{
	bool fReturnValue = false;

	//
	// Initialize logger:
	//
	if (!::lgInitializeLogger ())
	{
		::_tprintf (TEXT ("lgInitializeLogger failed with GetLastError ()=%d"), ::GetLastError ());
		goto ExitFunc;
	}

	//
	// Initialize test suite:
	//
	if(!::lgBeginSuite (TEXT ("Install / Uninstall test suite")))
	{
		::_tprintf (TEXT ("lgBeginSuite failed with GetLastError ()=%d"), ::GetLastError ());
		goto ExitFunc;
	}

	fReturnValue = true;

ExitFunc:
	return (fReturnValue);
}


//
// SingleSectionTestCases:
// Reads  a specific section's data from an ini file and performs tests for each
// entry in the section, according to boolean parameters.
//------------------------------------------------------------------------------
// Parameters:
// [IN] szIniFilePath -				the path to the initialization file, as read
//									from the command line.
//
// [IN] fCheckExistence -			indicates if the test is to check the
//									existence of the items in the section, or
//									their non-existence.
// [IN] fDeleteExistingEntries -	indicates if existing items should be
//									deleted. Overrided if:
//													(fCheckExistence == true).
// [IN] szSectionName -				the section from which the items are to be
//									read.
//
// [IN] fnSectionTestCaseFunction -	a function address to be used for the
//									testing of the individual items.
//------------------------------------------------------------------------------
// Return Value:
// The number of items that failed the test completely, which is one of the
// following:
// 1. The entry wasn't found where it should have been (fCheckExistence == true)
// 2. The entry was found where it shouldn't have been, while no request for its
//    deletion was made
// 3. The entry was found where it shouldn't have been, and its deletion was not
//    possible.
//
bool SingleSectionTestCases (
	LPCTSTR szIniFilePath,
	const bool fCheckExistence,
	const bool fDeleteExistingEntries,
	LPCTSTR szSectionName,
	TestCaseFunctionType fnSectionTestCaseFunction
	)
{
	// Error codes from function calls
	DWORD	dwResult;

	// Buffer holding all the data in the specified section.
	DWORD	dwIniSectionDataBufferSize;
	LPTSTR	szIniSectionDataBuffer = NULL;

	// Pointer to the beginning of a line in the section.
	LPTSTR	pcSingleCaseData;

	// The current case - one line of the section.
	UINT	uiIniKeyDataStringSize;
	// Case number - for use with logger
	DWORD	dwCaseNum = 0;

	// The number of items which completely failed the test (according to the
	// boolean parameters).
	UINT	uiFailedTest = 0;

	// The next buffer is needed to truncate the strings sent to the logger,
	// since the logger can accept only 1024 CHARs. Any longer strings prevent
	// the logger from writing a "begin log" line.
	//  The end of the string depends on the type of characters used
	// (ansi / unicode).
	LPTSTR	pcTruncatedString;
	UINT	uiTruncatedStringEnd;

	// The next variable is used to override fDeleteExistingEntries, to avoid
	// the mistake of checking for existence and deleting (deleting is done only
	// if the non-existence test is requested).
	bool	fLocalDeleteEntries = fDeleteExistingEntries;

	//
	// Initializing truncated string buffer for future use:
	//
	pcTruncatedString = (LPTSTR)::malloc (sizeof (char) * 1024);
	if (NULL == pcTruncatedString)
	{
		::lgLogError (0, TEXT ("FILE: %s LINE: %d\n Cannot allocate buffer for the test case description.\nTerminating test."), TEXT (__FILE__), __LINE__);
		uiFailedTest = 1; // indicates failure
		goto ExitFunc;
	}
	uiTruncatedStringEnd = ((1024 * sizeof (char)) / sizeof (TCHAR)) - 1;

	//
	// First check that a request to test existence was not made together with
	// a request for deletion:
	//
	if (fCheckExistence && fDeleteExistingEntries)
	{
		fLocalDeleteEntries = false;	// Override fDeleteExistingEntries request.
		::lgLogDetail (1, 1, TEXT ("FILE: %s LINE: %d\n Request was made to check for existence of entries. Overriding request for deleting items."), TEXT (__FILE__), __LINE__);
	}

	//
	// An unsuccessful allocation of the section data's buffer prevents any
	// checks regarding the validity of the system concerning the data written
	// in the ini file. There is no reason to continue running.
	//
	dwIniSectionDataBufferSize = SECTION_DATA_INCREMENT;
	szIniSectionDataBuffer = (LPTSTR)::malloc (sizeof (TCHAR) * dwIniSectionDataBufferSize);
	if (NULL == szIniSectionDataBuffer)
	{
		::lgLogError (0, TEXT ("FILE: %s LINE: %d\n Cannot allocate buffer for the data in section %s of file %s\nTerminating test."), TEXT (__FILE__), __LINE__, szSectionName, szIniFilePath);
		uiFailedTest = 1; // indicates failure
		goto ExitFunc;
	}
	
	//
	// Read data from the relevant section:
	//
	dwResult = ::GetPrivateProfileSection (szSectionName, szIniSectionDataBuffer, dwIniSectionDataBufferSize, szIniFilePath);

	//
	// If the buffer used to hold the data isn't large enough, the return value
	// of function GetPrivateProfileSection is the current size of the buffer
	// (as implied by dwIniSectionDataBufferSize) minus 2.
	// The function is called repeatedly with increasing sizes of buffers,
	// until a successful call is made.
	//
	while (dwResult == (dwIniSectionDataBufferSize - 2))
	{
		::free (szIniSectionDataBuffer);
		dwIniSectionDataBufferSize += SECTION_DATA_INCREMENT;
		szIniSectionDataBuffer = (LPTSTR)::malloc (sizeof (TCHAR) * dwIniSectionDataBufferSize);
		if (NULL == szIniSectionDataBuffer)
		{
			::lgLogError (0, TEXT ("FILE: %s LINE: %d\n Cannot allocate buffer for the data in section %s of file %s\nTerminating test."), TEXT (__FILE__), __LINE__, szSectionName, szIniFilePath);
			uiFailedTest = 1;	// failure to allocate buffer terminates function
			goto ExitFunc;
		}
		dwResult = ::GetPrivateProfileSection (szSectionName, szIniSectionDataBuffer, dwIniSectionDataBufferSize, szIniFilePath);
	}
	
	//
	// The next pointer will point to the beginning of the allocated buffer,
	// while szIniSectionDataBuffer runs along the buffer to retrieve the data
	// it holds line after line.
	//
	pcSingleCaseData = szIniSectionDataBuffer;

	//
	// Section lines are read one by one, each treated as a separate test case.
	// Each line is sent to the function which deals with a single test case
	// (fnSectionTestCaseFunction). After the test results are logged by that
	// function, the test case is closed, and the loop continues to the next
	// line / test case.
	//
	while (TEXT ('\0') != *pcSingleCaseData)
	{	// (end of section data is marked by an additional NULL character)
		
		//
		// Increase test case number:
		//
		dwCaseNum++;	
		
		//
		// Truncate case description string:
		//
		::_tcsncpy (pcTruncatedString, pcSingleCaseData, uiTruncatedStringEnd);
		pcTruncatedString[uiTruncatedStringEnd] = TEXT ('\0');
			
		//
		// Begin test case:
		//
		::lgBeginCase (dwCaseNum, pcTruncatedString);

		//
		// Initialize char counter (used to point to the next line):
		//
		uiIniKeyDataStringSize = ::_tcsclen (pcSingleCaseData) + 1;
	
		//
		// Call the single test case function for the new test case (section
		// line).
		//
		if (!fnSectionTestCaseFunction (pcSingleCaseData, fCheckExistence, fDeleteExistingEntries))
		{	// failed test case
			uiFailedTest++;
		}

		//
		// End test case:
		//
		::lgEndCase ();

		//
		// Continue to next line in section:
		//
		pcSingleCaseData += uiIniKeyDataStringSize;
	}
	
ExitFunc:
	//
	// Free the section data buffer:
	//
	if (NULL != szIniSectionDataBuffer)
	{
		::free (szIniSectionDataBuffer);
	}
if (NULL != pcTruncatedString)
{
	::free (pcTruncatedString);
}

	if ( 0 < uiFailedTest)
	{
		return (false);	// failure during test (either several items did not pass
	}					// the test or the section data could not be read)
	else
	{
		return (true);	// all items are in their correct place according to the
	}					// test specifications
}


bool FilesTests (
	LPCTSTR szIniFilePath,
	const bool fCheckExistence,
	const bool fDeleteExistingEntries
	)
{
	::lgLogDetail (0, 1, TEXT ("Files tests.\n============================="));
	return (SingleSectionTestCases (szIniFilePath, fCheckExistence, fDeleteExistingEntries, FILES, FileTestCase));
}


bool DirectoriesTests (
	LPCTSTR szIniFilePath,
	const bool fCheckExistence,
	const bool fDeleteExistingEntries
	)
{
	::lgLogDetail (0, 1, TEXT ("Directories tests.\n==================================="));
	return (SingleSectionTestCases (szIniFilePath, fCheckExistence, fDeleteExistingEntries, DIRECTORIES, DirectoryTestCase));
}


bool RegistryValuesTests (
	LPCTSTR szIniFilePath,
	const bool fCheckExistence,
	const bool fDeleteExistingEntries
	)
{
	::lgLogDetail (0, 1, TEXT ("Registry values tests.\n======================================="));
	return (SingleSectionTestCases (szIniFilePath, fCheckExistence, fDeleteExistingEntries, REGISTRY_VALUES, RegistryValueTestCase));
}


bool RegistryKeysTests (
	LPCTSTR szIniFilePath,
	const bool fCheckExistence,
	const bool fDeleteExistingEntries
	)
{
	::lgLogDetail (0, 1, TEXT ("Registry keys tests.\n====================================="));
	return (SingleSectionTestCases (szIniFilePath, fCheckExistence, fDeleteExistingEntries, REGISTRY_KEYS, RegistryKeyTestCase));
}


bool __cdecl TestSuiteShutdown (void)
{
	bool fReturnValue = false;

	// End test suite (logger)
	if (!::lgEndSuite())
	{
		//this is not possible since API always returns true
		//but to be on the safe side
		::_tprintf (TEXT ("lgEndSuite returned false"));
		goto ExitFunc;
	}

	// Close the Logger
	if (!::lgCloseLogger())
	{
		//this is not possible since API always returns true
		//but to be on the safe side
		::_tprintf (TEXT ("lgCloseLogger returned false"));
		goto ExitFunc;
	}

	// Success closing the logger
	fReturnValue = true;
ExitFunc:
	return	(fReturnValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\tiff\src\test.c ===
#include "tifflibp.h"
#pragma hdrstop

#include "tifflib.h"


int __cdecl wmain( int argc, WCHAR *argv[])
{
    MS_TAG_INFO MsTagInfo = {0};


    HeapInitialize(NULL,NULL,NULL,0);
    FaxTiffInitialize();

    if (argv[2]) {
        MsTagInfo.RecipName = argv[2];
    }
    if (argv[3]) {
        MsTagInfo.RecipNumber = argv[3];
    }
    if (argv[4]) {
        MsTagInfo.SenderName = argv[4];
    }
    if (argv[5]) {
        MsTagInfo.Routing = argv[5];
    }
    if (argv[6]) {
        MsTagInfo.CallerId = argv[6];
    }
    if (argv[7]) {
        MsTagInfo.Csid = argv[7];
    }
    if (argv[8]) {
        MsTagInfo.Tsid = argv[8];
    }

    TiffAddMsTags( argv[1], &MsTagInfo );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\tiff\src\encode.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    encode.c

Abstract:

    This file contains functions for encoding (compressing)
    uncompressed 1 bit per pel data into a TIFF data
    stream.  The supported compression algorithms are
    as follows:

        o  Uncompressed (raw)
        o  One dimensional - MH or Modified Huffman
        o  Two dimensional - MR or Modified Read

Environment:

        WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "tifflibp.h"
#pragma hdrstop




#if TIFFDBG
VOID
PrintRunInfo(
    INT     Mode,
    INT     Run,
    INT     BitLen,
    WORD    Code
    )

/*++

Routine Description:

    Prints run information to standard out.  This
    function is available only if TIFFDBG is TRUE.

Arguments:

    Mode    - Encoding mode: vertical, horizontal, pass, or raw
    Run     - Run length
    BitLen  - Number of bits
    Code    - The actual bits

Return Value:

    None.

--*/

{
    TCHAR BitBuf[16];
    INT i;
    WORD j;


    _tprintf( TEXT("\t") );

    if (Mode) {
        switch( Mode ) {
            case 1:
                _tprintf( TEXT("pass mode ") );
                break;

            case 2:
                _tprintf( TEXT("vertical mode run=%d, "), Run );
                break;

            case 3:
                _tprintf( TEXT("horizontal mode ") );
                break;
        }
    } else {
        _tprintf( TEXT("run=%d, bitlen=%d, "), Run, BitLen );
    }

    j = Code << (16 - BitLen);

    for (i=0; i<BitLen; i++,j<<=1) {
        if (j & 0x8000) {
            BitBuf[i] = TEXT('1');
        } else {
            BitBuf[i] = TEXT('0');
        }
    }
    BitBuf[i] = 0;

    _tprintf( TEXT("value=%04x, bits=%s\n"), Code << (16 - BitLen), BitBuf );
}
#endif


VOID
OutputEOL(
    PTIFF_INSTANCE_DATA TiffInstance,
    BOOL                OneDimensional
    )

/*++

Routine Description:

    Output EOL code at the beginning of each scanline

Arguments:

    TiffInstance    - Pointer to the TIFF instance data
    OneDimensional  - TRUE for MH encoding

Return Value:

    None.

--*/

{
    DWORD   length, code;

    //
    // EOL code word always ends on a byte boundary
    //
    code = EOL_CODE;
    length = EOL_LENGTH + ((TiffInstance->bitcnt - EOL_LENGTH) & 7);
    OutputBits( TiffInstance, (WORD) length, (WORD) code );

    //
    // When using MR encoding, append a 1 or 0 depending whether
    // we're the line should be MH or MR encoded.
    //
    if (TiffInstance->CompressionType == TIFF_COMPRESSION_MR) {
        OutputBits( TiffInstance, (WORD) 1, (WORD) (OneDimensional ? 1 : 0) );
    }
}


VOID
OutputRun(
    PTIFF_INSTANCE_DATA TiffInstance,
    INT                 run,
    PCODETABLE          pCodeTable
    )

/*++

Routine Description:

    Output a single run (black or white) using the specified code table

Arguments:

    TiffInstance    - Pointer to the TIFF instance data
    run             - Specifies the length of the run
    pCodeTable      - Specifies the code table to use

Return Value:

    None.

--*/

{
    PCODETABLE  pTableEntry;

    //
    // Use make-up code word for 2560 for any runs of at least 2624 pixels
    // This is currently not necessary for us since our scanlines always
    // have 1728 pixels.
    //

    while (run >= 2624) {

        pTableEntry = pCodeTable + (63 + (2560 >> 6));
        OutputBits( TiffInstance, pTableEntry->length, pTableEntry->code );
#if TIFFDBG
        PrintRunInfo( 0, run, pTableEntry->length, pTableEntry->code );
#endif
        run -= 2560;
    }

    //
    // Use appropriate make-up code word if the run is longer than 63 pixels
    //

    if (run >= 64) {

        pTableEntry = pCodeTable + (63 + (run >> 6));
        OutputBits( TiffInstance, pTableEntry->length, pTableEntry->code );
#if TIFFDBG
        PrintRunInfo( 0, run, pTableEntry->length, pTableEntry->code );
#endif
        run &= 0x3f;
    }

    //
    // Output terminating code word
    //

    OutputBits( TiffInstance, pCodeTable[run].length, pCodeTable[run].code );
#if TIFFDBG
        PrintRunInfo( 0, run, pCodeTable[run].length, pCodeTable[run].code );
#endif
}


BOOL
EncodeFaxDataNoCompression(
    PTIFF_INSTANCE_DATA TiffInstance,
    PBYTE               plinebuf,
    INT                 lineWidth
    )

/*++

Routine Description:

    Encodes a single line of TIFF data using no compression.
    This is basically raw data.

Arguments:

    TiffInstance    - Pointer to the TIFF instance data
    plinebuf        - Pointer to the input data
    lineWidth       - Width of the line in pixels

Return Value:

    TRUE for success, FALSE for failure

--*/

{
    DWORD               Bytes;


#if TIFFDBG
    _tprintf( TEXT("encoding(raw) line #%d\n"), TiffInstance->Lines );
#endif

    WriteFile(
        TiffInstance->hFile,
        plinebuf,
        lineWidth / 8,
        &Bytes,
        NULL
        );

    TiffInstance->Bytes += Bytes;

    return TRUE;
}


BOOL
EncodeFaxDataMhCompression(
    PTIFF_INSTANCE_DATA TiffInstance,
    PBYTE               plinebuf,
    INT                 lineWidth
    )

/*++

Routine Description:

    Encodes a single line of TIFF data using 1 dimensional
    TIFF compression.

Arguments:

    TiffInstance    - Pointer to the TIFF instance data
    plinebuf        - Pointer to the input data
    lineWidth       - Width of the line in pixels

Return Value:

    TRUE for success, FALSE for failure

--*/

{
    INT     bitIndex, run, runLength;


#if TIFFDBG
    _tprintf( TEXT("encoding line #%d\n"), TiffInstance->Lines );
#endif

    bitIndex = 0;
    runLength = 0;

    OutputEOL( TiffInstance, TRUE );

    while (TRUE) {

        //
        // Code white run
        //

        run = FindWhiteRun( plinebuf, bitIndex, lineWidth );
        runLength += run;
        OutputRun( TiffInstance, run, WhiteRunCodes );

        if ((bitIndex += run) >= lineWidth)
            break;

        //
        // Code black run
        //

        run = FindBlackRun(plinebuf, bitIndex, lineWidth);
        runLength += run;
        OutputRun( TiffInstance, run, BlackRunCodes );

        if ((bitIndex += run) >= lineWidth)
            break;
    }

    CopyMemory( TiffInstance->RefLine, plinebuf, lineWidth/8 );

    return TRUE;
}


BOOL
EncodeFaxDataMmrCompression(
    PTIFF_INSTANCE_DATA TiffInstance,
    PBYTE               plinebuf,
    INT                 lineWidth
    )

/*++

Routine Description:

    Encodes a single line of TIFF data using 2 dimensional
    TIFF compression.

Arguments:

    TiffInstance    - Pointer to the TIFF instance data
    plinebuf        - Pointer to the input data
    lineWidth       - Width of the line in pixels

Return Value:

    TRUE for success, FALSE for failure

--*/

{
    INT a0, a1, a2, b1, b2, distance;
    LPBYTE prefline;


#if TIFFDBG
    _tprintf( TEXT("encoding line #%d\n"), TiffInstance->Lines );
#endif

    OutputEOL( TiffInstance, FALSE );

    //
    // Use 2-dimensional encoding scheme
    //

    prefline = TiffInstance->RefLine;
    a0 = 0;
    a1 = GetBit( plinebuf, 0) ? 0 : NextChangingElement(plinebuf, 0, lineWidth, 0 );
    b1 = GetBit( prefline, 0) ? 0 : NextChangingElement(prefline, 0, lineWidth, 0 );

    while (TRUE) {

        b2 = (b1 >= lineWidth) ? lineWidth :
                NextChangingElement( prefline, b1, lineWidth, GetBit(prefline, b1 ));

        if (b2 < a1) {

            //
            // Pass mode
            //

            OutputBits( TiffInstance, PASSCODE_LENGTH, PASSCODE );
#if TIFFDBG
            PrintRunInfo( 1, 0, PASSCODE_LENGTH, PASSCODE );
            _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif
            a0 = b2;

        } else if ((distance = a1 - b1) <= 3 && distance >= -3) {

            //
            // Vertical mode
            //

            OutputBits( TiffInstance, VertCodes[distance+3].length, VertCodes[distance+3].code );
#if TIFFDBG
            PrintRunInfo( 2, a1-a0, VertCodes[distance+3].length, VertCodes[distance+3].code );
            _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif
            a0 = a1;

        } else {

            //
            // Horizontal mode
            //

            a2 = (a1 >= lineWidth) ? lineWidth :
                    NextChangingElement( plinebuf, a1, lineWidth, GetBit( plinebuf, a1 ) );

            OutputBits( TiffInstance, HORZCODE_LENGTH, HORZCODE );
#if TIFFDBG
            PrintRunInfo( 3, 0, HORZCODE_LENGTH, HORZCODE );
            _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif

            if (a1 != 0 && GetBit( plinebuf, a0 )) {

                OutputRun( TiffInstance, a1-a0, BlackRunCodes );
                OutputRun( TiffInstance, a2-a1, WhiteRunCodes );

            } else {

                OutputRun( TiffInstance, a1-a0, WhiteRunCodes );
                OutputRun( TiffInstance, a2-a1, BlackRunCodes );
            }

            a0 = a2;
        }

        if (a0 >= lineWidth) {
            break;
        }

        a1 = NextChangingElement( plinebuf, a0, lineWidth, GetBit( plinebuf, a0 ) );
        b1 = NextChangingElement( prefline, a0, lineWidth, !GetBit( plinebuf, a0 ) );
        b1 = NextChangingElement( prefline, b1, lineWidth, GetBit( plinebuf, a0 ) );
    }


    CopyMemory( TiffInstance->RefLine, plinebuf, TiffInstance->BytesPerLine );

    return TRUE;
}


BOOL
EncodeFaxData(
    PTIFF_INSTANCE_DATA TiffInstance,
    PBYTE               plinebuf,
    INT                 lineWidth,
    DWORD               CompressionType
    )

/*++

Routine Description:

    Encodes a single line of TIFF data using the specified
    compression method.

Arguments:

    TiffInstance    - Pointer to the TIFF instance data
    plinebuf        - Pointer to the input data
    lineWidth       - Width of the line in pixels
    CompressionType - Requested compression method

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    switch( CompressionType ) {
        case TIFF_COMPRESSION_NONE:
            return EncodeFaxDataNoCompression( TiffInstance, plinebuf, lineWidth );

        case TIFF_COMPRESSION_MH:
            return EncodeFaxDataMhCompression( TiffInstance, plinebuf, lineWidth );

        case TIFF_COMPRESSION_MR:
            if (!TiffInstance->Lines) {
                return EncodeFaxDataMhCompression( TiffInstance, plinebuf, lineWidth );
            }
            return EncodeFaxDataMmrCompression( TiffInstance, plinebuf, lineWidth );
    }

    return FALSE;
}


BOOL
EncodeFaxPageMmrCompression(
    PTIFF_INSTANCE_DATA TiffInstance,
    PBYTE               plinebuf,
    INT                 lineWidth,
    DWORD               ImageHeight,
    DWORD               *DestSize
    )

/*++

Routine Description:

    Encodes a page of TIFF data using 2 dimensional
    TIFF compression.

Arguments:

    TiffInstance    - Pointer to the TIFF instance data
    plinebuf        - Pointer to the input data
    lineWidth       - Width of the line in pixels

Return Value:

    TRUE for success, FALSE for failure

--*/

{
    INT a0, a1, a2, b1, b2, distance;
    LPBYTE prefline;
    BYTE pZeroline[1728/8];
    DWORD Lines=0;
    LPBYTE StartBitbuf = TiffInstance->bitbuf;


    // set first all white reference line

    prefline = pZeroline;

    ZeroMemory( pZeroline, sizeof(pZeroline) );

    // loop til end

    do {


        //
        // Use 2-dimensional encoding scheme
        //


        a0 = 0;
        a1 = GetBit( plinebuf, 0) ? 0 : NextChangingElement(plinebuf, 0, lineWidth, 0 );
        b1 = GetBit( prefline, 0) ? 0 : NextChangingElement(prefline, 0, lineWidth, 0 );

        while (TRUE) {

            b2 = (b1 >= lineWidth) ? lineWidth :
                    NextChangingElement( prefline, b1, lineWidth, GetBit(prefline, b1 ));

            if (b2 < a1) {

                //
                // Pass mode
                //

                OutputBits( TiffInstance, PASSCODE_LENGTH, PASSCODE );
#if TIFFDBG
                PrintRunInfo( 1, 0, PASSCODE_LENGTH, PASSCODE );
                _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif
                a0 = b2;

            } else if ((distance = a1 - b1) <= 3 && distance >= -3) {

                //
                // Vertical mode
                //

                OutputBits( TiffInstance, VertCodes[distance+3].length, VertCodes[distance+3].code );
#if TIFFDBG
                PrintRunInfo( 2, a1-a0, VertCodes[distance+3].length, VertCodes[distance+3].code );
                _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif
                a0 = a1;

            } else {

                //
                // Horizontal mode
                //

                a2 = (a1 >= lineWidth) ? lineWidth :
                        NextChangingElement( plinebuf, a1, lineWidth, GetBit( plinebuf, a1 ) );

                OutputBits( TiffInstance, HORZCODE_LENGTH, HORZCODE );
#if TIFFDBG
                PrintRunInfo( 3, 0, HORZCODE_LENGTH, HORZCODE );
                _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif

                if (a1 != 0 && GetBit( plinebuf, a0 )) {

                    OutputRun( TiffInstance, a1-a0, BlackRunCodes );
                    OutputRun( TiffInstance, a2-a1, WhiteRunCodes );

                } else {

                    OutputRun( TiffInstance, a1-a0, WhiteRunCodes );
                    OutputRun( TiffInstance, a2-a1, BlackRunCodes );
                }

                a0 = a2;
            }

            if (a0 >= lineWidth) {
                Lines++;
                break;
            }

            a1 = NextChangingElement( plinebuf, a0, lineWidth, GetBit( plinebuf, a0 ) );
            b1 = NextChangingElement( prefline, a0, lineWidth, !GetBit( plinebuf, a0 ) );
            b1 = NextChangingElement( prefline, b1, lineWidth, GetBit( plinebuf, a0 ) );
        }

        prefline = plinebuf;
        plinebuf += TiffInstance->BytesPerLine;

    } while (Lines < ImageHeight);

    OutputEOL( TiffInstance, FALSE );

    *DestSize = (DWORD)(TiffInstance->bitbuf - StartBitbuf);
    TiffInstance->Lines = Lines;

    return TRUE;
}





BOOL
EncodeMmrBranding(
    PBYTE               pBrandBits,
    LPDWORD             pMmrBrandBits,
    INT                 BrandHeight,
    INT                 BrandWidth,
    DWORD              *DwordsOut,
    DWORD              *BitsOut
    )

/*++

Routine Description:

   Encode an MMR branding from uncompressed branding bits.
   I don't have enough time to write an optimized
   Uncompressed -> MMR convertor, so the compromise is
   to use the existing Uncompressed Decoder (fast enough)
   and use the optimized MMR Encoder.
   Since we only convert few lines for Branding, it's OK.

--*/

{
    INT         a0, a1, a2, b1, b2, distance;
    LPBYTE      prefline = NULL,pMemAlloc = NULL;
    INT         Lines = 0;
    LPDWORD     lpdwOut = pMmrBrandBits;
    BYTE        BitOut = 0;


    // set first all white reference line
    pMemAlloc  = VirtualAlloc(   NULL,
                                BrandWidth/8,
                                MEM_COMMIT,
                                PAGE_READWRITE );
    if (pMemAlloc == NULL) 
    {
        return FALSE;
    }

    ZeroMemory(pMemAlloc , BrandWidth/8);

    prefline = pMemAlloc;

    // loop til all lines done

    do {

        a0 = 0;
        a1 = GetBit( pBrandBits, 0) ? 0 : NextChangingElement(pBrandBits, 0, BrandWidth, 0 );
        b1 = GetBit( prefline, 0) ? 0 : NextChangingElement(prefline, 0, BrandWidth, 0 );

        while (TRUE) {

            b2 = (b1 >= BrandWidth) ? BrandWidth :
                    NextChangingElement( prefline, b1, BrandWidth, GetBit(prefline, b1 ));

            if (b2 < a1) {

                //
                // Pass mode
                //

                //OutputBits( TiffInstance, PASSCODE_LENGTH, PASSCODE );
                (*lpdwOut) += ( ((DWORD) (PASSCODE_REVERSED)) << BitOut);
                if ( (BitOut = BitOut + PASSCODE_LENGTH ) > 31 ) {
                    BitOut -= 32;
                    *(++lpdwOut) = ( (DWORD) (PASSCODE_REVERSED) ) >> (PASSCODE_LENGTH - BitOut);
                }


#if TIFFDBG
                PrintRunInfo( 1, 0, PASSCODE_LENGTH, PASSCODE );
                _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif
                a0 = b2;

            } else if ((distance = a1 - b1) <= 3 && distance >= -3) {

                //
                // Vertical mode
                //

                // OutputBits( TiffInstance, VertCodes[distance+3].length, VertCodes[distance+3].code );
                (*lpdwOut) += ( ( (DWORD) VertCodesReversed[distance+3].code) << BitOut);
                if ( (BitOut = BitOut + VertCodesReversed[distance+3].length ) > 31 ) {
                    BitOut -= 32;
                    *(++lpdwOut) = ( (DWORD) (VertCodesReversed[distance+3].code) ) >> (VertCodesReversed[distance+3].length - BitOut);
                }

#if TIFFDBG
                PrintRunInfo( 2, a1-a0, VertCodes[distance+3].length, VertCodes[distance+3].code );
                _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif
                a0 = a1;

            } else {

                //
                // Horizontal mode
                //

                a2 = (a1 >= BrandWidth) ? BrandWidth :
                        NextChangingElement( pBrandBits, a1, BrandWidth, GetBit( pBrandBits, a1 ) );

                // OutputBits( TiffInstance, HORZCODE_LENGTH, HORZCODE );
                (*lpdwOut) += ( ((DWORD) (HORZCODE_REVERSED)) << BitOut);
                if ( (BitOut = BitOut + HORZCODE_LENGTH ) > 31 ) {
                    BitOut -= 32;
                    *(++lpdwOut) = ( (DWORD) (HORZCODE_REVERSED) ) >> (HORZCODE_LENGTH - BitOut);
                }



#if TIFFDBG
                PrintRunInfo( 3, 0, HORZCODE_LENGTH, HORZCODE );
                _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif

                if (a1 != 0 && GetBit( pBrandBits, a0 )) {

                    //OutputRun( TiffInstance, a1-a0, BlackRunCodes );
                    //OutputRun( TiffInstance, a2-a1, WhiteRunCodes );
                    OutputRunFastReversed(a1-a0, BLACK, &lpdwOut, &BitOut);
                    OutputRunFastReversed(a2-a1, WHITE, &lpdwOut, &BitOut);

                } else {

                    //OutputRun( TiffInstance, a1-a0, WhiteRunCodes );
                    //OutputRun( TiffInstance, a2-a1, BlackRunCodes );
                    OutputRunFastReversed(a1-a0, WHITE, &lpdwOut, &BitOut);
                    OutputRunFastReversed(a2-a1, BLACK, &lpdwOut, &BitOut);

                }

                a0 = a2;
            }

            if (a0 >= BrandWidth) {
                Lines++;
                break;
            }

            a1 = NextChangingElement( pBrandBits, a0, BrandWidth, GetBit( pBrandBits, a0 ) );
            b1 = NextChangingElement( prefline, a0, BrandWidth, !GetBit( pBrandBits, a0 ) );
            b1 = NextChangingElement( prefline, b1, BrandWidth, GetBit( pBrandBits, a0 ) );
        }

        prefline = pBrandBits;
        pBrandBits += (BrandWidth / 8);

    } while (Lines < BrandHeight);

    *DwordsOut = (DWORD)(lpdwOut - pMmrBrandBits);
    *BitsOut  = BitOut;

    if (!VirtualFree(pMemAlloc,0,MEM_RELEASE))
    {
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\tiff\src\decode.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    decode.c

Abstract:

    This file contains functions for decoding (de-compressing)
    compressed 1 bit per pel data from a TIFF data
    stream.  The supported compression algorithms are
    as follows:

        o  Uncompressed (raw)
        o  One dimensional - MH or Modified Huffman
        o  Two dimensional - MR or Modified Read

Environment:

        WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "tifflibp.h"
#pragma hdrstop



BOOL
DecodeUnCompressedFaxData(
    PTIFF_INSTANCE_DATA TiffInstance,
    LPBYTE              OutputBuffer,
    BOOL                SingleLineBuffer,
    DWORD               PadLength
    )

/*++

Routine Description:

    Decode a single page of uncompressed TIFF data.

Arguments:

    TiffInstance    - Pointer to the TIFF instance data
    OutputBuffer    - Output buffer where the uncompressed data
                      is written.  This buffer must be allocated
                      by the caller and must be large enough for
                      a single page of data.

Return Value:

    NONE

--*/

{
    __try {

        FillMemory( OutputBuffer, TiffInstance->ImageHeight * (TiffInstance->ImageWidth / 8), WHITE );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        return FALSE;

    }

    TiffInstance->Lines = TiffInstance->StripDataSize / (TiffInstance->ImageWidth / 8);
    CopyMemory( OutputBuffer, TiffInstance->StripData, TiffInstance->StripDataSize );

    return TRUE;
}


BOOL
DecodeMHFaxData(
    PTIFF_INSTANCE_DATA TiffInstance,
    LPBYTE              OutputBuffer,
    BOOL                SingleLineBuffer,
    DWORD               PadLength
    )

/*++

Routine Description:

    Decode a single page of 1 dimensionaly compressed
    TIFF data.

Arguments:

    TiffInstance    - Pointer to the TIFF instance data
    OutputBuffer    - Output buffer where the uncompressed data
                      is written.  This buffer must be allocated
                      by the caller and must be large enough for
                      a single page of data.

Return Value:

    NONE

--*/

{
    DWORD               i;
    DWORD               j;
    BYTE                octet;
    PDECODE_TREE        Tree;
    INT                 code;
    PBYTE               plinebuf;
    DWORD               lineWidth;
    DWORD               Lines;
    DWORD               EolCount;
    DWORD               BadFaxLines;
    BOOL                LastLineBad;


    //
    // initialization
    //

    if (!SingleLineBuffer) {

        __try {

            FillMemory( OutputBuffer, TiffInstance->ImageHeight * (TiffInstance->ImageWidth / 8), WHITE );

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            return FALSE;

        }

    }

    Tree = WhiteDecodeTree;
    code = 0;
    Lines = 0;
    EolCount = 1;
    BadFaxLines = 0;
    LastLineBad = FALSE;
    TiffInstance->Color = 0;
    TiffInstance->RunLength = 0;
    TiffInstance->bitdata = 0;
    TiffInstance->bitcnt = DWORDBITS;
    TiffInstance->bitbuf = OutputBuffer;
    TiffInstance->StartGood = 0;
    TiffInstance->EndGood = 0;
    plinebuf = TiffInstance->StripData;
    lineWidth = TiffInstance->ImageWidth;


    for (i=0; i<TiffInstance->StripDataSize; i++) {
        if (plinebuf[i] == 0) {
            break;
        }
    }

    //
    // loop thru each byte in the file
    //

    for (; i<TiffInstance->StripDataSize; i++) 
    {
        octet = plinebuf[i];
#ifdef RDEBUG
	if (2147 == i)
        {
            DebugBreak ();
        }
#endif
        //
        // loop thru each bit in the byte
        //
        for (j=0; j<8; j++,octet<<=1) 
        {
            if (code == DECODEEOL) 
            {
                if (!(octet&0x80)) 
                {
                    //
                    // here we skip all bits until we hit a 1 bit
                    // this happens when the first octet in a line
                    // is all zeroes and we detect that we are
                    // searching for an EOL
                    //
                    continue;
                }

                if (TiffInstance->RunLength && TiffInstance->RunLength != lineWidth) {

                    if (TiffInstance->RunLength < lineWidth) {
                        TiffInstance->Color = 0;
                        OutputCodeBits( TiffInstance, lineWidth - TiffInstance->RunLength );
                    }

                    if (LastLineBad) {

                        BadFaxLines += 1;

                    } else {

                        if (BadFaxLines > TiffInstance->BadFaxLines) {
                            TiffInstance->BadFaxLines = BadFaxLines;
                        }
                        BadFaxLines = 1;
                        LastLineBad = TRUE;

                    }

                } else {

                    LastLineBad = FALSE;

                }

                if (!TiffInstance->StartGood) {
                    TiffInstance->StartGood = i - 1;
                }

                //
                // we hit the eol marker
                //
                Tree = WhiteDecodeTree;
                TiffInstance->Color = 0;
                code = 0;

                if (SingleLineBuffer) {
                    TiffInstance->bitbuf = OutputBuffer;
                }

                if (TiffInstance->RunLength) {

                    FlushLine(TiffInstance,PadLength);
                    TiffInstance->RunLength = 0;
                    Lines += 1;
                    EolCount = 1;

                } else {

                    //
                    // the eol count is maintained to that
                    // an rtc sequence is detected.
                    //

                    EolCount += 1;

                    if (EolCount == 6) {

                        //
                        // this is an rtc sequence, so any
                        // data that follows in the file
                        // is garbage.
                        //

                        goto good_exit;

                    }

                }

                continue;
            }

            code = ((octet&0x80)>>7) ? Tree[code].Right : Tree[code].Left;

            if (code == BADRUN) {
                return FALSE;
            }

            if (code < 1) {

                code = (-code);

                OutputCodeBits( TiffInstance, code );

                if (code < 64) {
                    //
                    // terminating code
                    //
                    TiffInstance->Color = !TiffInstance->Color;
                    Tree = TiffInstance->Color ? BlackDecodeTree : WhiteDecodeTree;
                }
                code = 0;
            }

        }
    }

good_exit:

    TiffInstance->EndGood = i;
    if (BadFaxLines > TiffInstance->BadFaxLines) {
        TiffInstance->BadFaxLines = BadFaxLines;
    }

    FlushBits( TiffInstance );
    TiffInstance->Lines = Lines;

    return TRUE;
}


BOOL
DecodeMRFaxData(
    PTIFF_INSTANCE_DATA TiffInstance,
    LPBYTE              OutputBuffer,
    BOOL                SingleLineBuffer,
    DWORD               PadLength
    )

/*++

Routine Description:

    Decode a single page of 2 dimensionaly compressed
    TIFF data.

Arguments:

    TiffInstance    - Pointer to the TIFF instance data
    OutputBuffer    - Output buffer where the uncompressed data
                      is written.  This buffer must be allocated
                      by the caller and must be large enough for
                      a single page of data.

Return Value:

    NONE

--*/

{
    DWORD               i;
    DWORD               j;
    BYTE                octet;
    PDECODE_TREE        Tree;
    INT                 code;
    LPBYTE              prefline;
    LPBYTE              pcurrline;
    DWORD               HorzRuns;
    BOOL                OneDimensional;
    DWORD               a0;
    DWORD               a1;
    DWORD               b1;
    DWORD               b2;
    PBYTE               plinebuf;
    DWORD               lineWidth;
    DWORD               Lines;
    DWORD               EolCount;
    DWORD               BadFaxLines;
    BOOL                LastLineBad;


    //
    // initialization
    //

    if (!SingleLineBuffer) {

        __try {

            FillMemory( OutputBuffer, TiffInstance->ImageHeight * (TiffInstance->ImageWidth / 8), WHITE );

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            return FALSE;

        }

    }

    Tree = WhiteDecodeTree;
    code = 0;
    HorzRuns = 0;
    EolCount = 1;
    BadFaxLines = 0;
    LastLineBad = FALSE;
    TiffInstance->Color = 0;
    TiffInstance->RunLength = 0;
    TiffInstance->bitdata = 0;
    TiffInstance->bitcnt = DWORDBITS;
    TiffInstance->bitbuf = OutputBuffer;
    OneDimensional = TRUE;
    plinebuf = TiffInstance->StripData;
    lineWidth = TiffInstance->ImageWidth;
    pcurrline = OutputBuffer;
    prefline = OutputBuffer;
    a0 = 0;
    a1 = 0;
    b1 = 0;
    b2 = 0;
    Lines = 0;


    //
    // loop thru each byte in the file
    //

    for (j=0; j<TiffInstance->StripDataSize; j++) {


        octet = *plinebuf++;

        //
        // loop thru each bit in the byte
        //

        for (i=0; i<8; i++,octet<<=1) {

            if (code == DECODEEOL2) {

                //
                // we hit the final eol marker
                //

                if (TiffInstance->RunLength && TiffInstance->RunLength != lineWidth) {

                    if (TiffInstance->RunLength < lineWidth) {
                        TiffInstance->Color = 0;
                        OutputCodeBits( TiffInstance, lineWidth - TiffInstance->RunLength );
                    }

                    if (LastLineBad) {

                        BadFaxLines += 1;

                    } else {

                        if (BadFaxLines > TiffInstance->BadFaxLines) {
                            TiffInstance->BadFaxLines = BadFaxLines;
                        }
                        BadFaxLines = 1;
                        LastLineBad = TRUE;

                    }

                } else {

                    LastLineBad = FALSE;

                }

                if (!TiffInstance->StartGood) {
                    TiffInstance->StartGood = i - 1;
                }

                //
                // set the decoding tree
                //

                OneDimensional = (octet & 0x80) == 0x80;
                Tree = OneDimensional ? WhiteDecodeTree : TwoDecodeTree;

                //
                // reset the control variables
                //

                TiffInstance->Color = 0;
                code = 0;
                a0 = 0;
                a1 = 0;
                b1 = 0;
                b2 = 0;

                //
                // if there is a non-zero runlength then
                // spaw the reference & current line pointers
                // and count this line.  the runlength can be
                // zero when there is just an empty eol in
                // the stream.
                //

                if (SingleLineBuffer) {
                    TiffInstance->bitbuf = OutputBuffer;
                }

                if (TiffInstance->RunLength) {
                    TiffInstance->RunLength = 0;
                    Lines += 1;
                    prefline = pcurrline;
                    pcurrline = TiffInstance->bitbuf;

                } else {

                    //
                    // the eol count is maintained to that
                    // an rtc sequence is detected.
                    //

                    EolCount += 1;

                    if (EolCount == 6) {

                        //
                        // this is an rtc sequence, so any
                        // data that follows in the file
                        // is garbage.
                        //

                        goto good_exit;

                    }

                }

                continue;
            }

            if (code == DECODEEOL) {

                if (!(octet&0x80)) {
                    //
                    // here we skip all bits until we hit a 1 bit
                    // this happens when the first octet in a line
                    // is all zeroes and we detect that we are
                    // searching for an EOL
                    //
                    continue;
                }

                //
                // this forces the code to pickup the next
                // bit in the stream, which tells whether
                // the next line is encoded in MH or MR compression
                //
                code = DECODEEOL2;
                continue;

            }

            if (code == BADRUN) {

                code = 0;
                continue;

            }

            code = ((octet&0x80)>>7) ? Tree[code].Right : Tree[code].Left;

            b1 = NextChangingElement( prefline, a0, lineWidth, !TiffInstance->Color );
            b1 = NextChangingElement( prefline, b1, lineWidth,  TiffInstance->Color );

            b2 = NextChangingElement( prefline, b1, lineWidth, GetBit(prefline, b1 ) );

            if (OneDimensional) {

                if (code < 1) {

                    code = (-code);

                    OutputCodeBits( TiffInstance, code );

                    //
                    // the affect of this is to accumulate the runlengths
                    // into a0, causing a0 to be placed on a2 when horizontal
                    // mode is completed/
                    //

                    a0 += code;

                    if (code < 64) {

                        //
                        // terminating code
                        //
                        TiffInstance->Color = !TiffInstance->Color;
                        Tree = TiffInstance->Color ? BlackDecodeTree : WhiteDecodeTree;

                        if (HorzRuns) {

                            HorzRuns -= 1;

                            if (!HorzRuns) {

                                Tree = TwoDecodeTree;
                                OneDimensional = FALSE;

                            }

                        }

                    }

                    code = 0;

                }

                continue;

            }

            if (code == HORZMODE) {

                //
                // horizontal mode occurs when b1-a1 greater than 3
                //

                code= 0;
                HorzRuns = 2;
                OneDimensional = TRUE;
                Tree = TiffInstance->Color ? BlackDecodeTree : WhiteDecodeTree;

            } else if (code == PASSMODE) {

                //
                // pass mode occurs when the position of b2 lies
                // to the left of a1, but a1 cannot be equal to b2.
                //

                code = b2 - a0;
                OutputCodeBits( TiffInstance, code );
                code = 0;
                a0 = b2;

            } else if (code >= VTMODE3N && code <= VTMODE3P) {

                //
                // vertical mode occurs when b1-a1 <= 3
                //

                a1 = b1 - (VTMODE0 - code);
                code = a1 - a0;

                OutputCodeBits( TiffInstance, code );

                code = 0;
                a0 = a1;

                TiffInstance->Color = !TiffInstance->Color;

            }


        }
    }

good_exit:

    TiffInstance->EndGood = i;
    if (BadFaxLines > TiffInstance->BadFaxLines) {
        TiffInstance->BadFaxLines = BadFaxLines;
    }

    FlushBits( TiffInstance );
    TiffInstance->Lines = Lines;

    return TRUE;
}


BOOL
DecodeMMRFaxData(
    PTIFF_INSTANCE_DATA TiffInstance,
    LPBYTE              OutputBuffer,
    BOOL                SingleLineBuffer,
    DWORD               PadLength
    )

/*++

Routine Description:

    Decode a single page of 2 dimensionaly compressed
    TIFF data.

Arguments:

    TiffInstance    - Pointer to the TIFF instance data
    OutputBuffer    - Output buffer where the uncompressed data
                      is written.  This buffer must be allocated
                      by the caller and must be large enough for
                      a single page of data.

Return Value:

    NONE

--*/

{
    DWORD               i;
    DWORD               j;
    BYTE                octet;
    PDECODE_TREE        Tree;
    INT                 code;
    LPBYTE              prefline;
    LPBYTE              pcurrline;
    DWORD               HorzRuns;
    BOOL