const byte XONLINE_MSG_PROP_TYPE_I1                    = 2;   // The property value points to 8-bits of data
        public const byte XONLINE_MSG_PROP_TYPE_I2                    = 3;   // The property value points to 16-bits of data
        public const byte XONLINE_MSG_PROP_TYPE_I4                    = 4;   // The property value points to 32-bits of data
        public const byte XONLINE_MSG_PROP_TYPE_I8                    = 5;   // The property value points to 64-bits of data
        public const byte XONLINE_MSG_PROP_TYPE_STRING                = 6;   // The property value points to a NULL-terminated wide character string
        public const byte XONLINE_MSG_PROP_TYPE_FILETIME              = 7;   // The property value points to a time value
        public const byte XONLINE_MSG_PROP_TYPE_BINARY                = 8;   // The property value points to a binary blob that fits in the message details
        public const byte XONLINE_MSG_PROP_TYPE_ATTACHMENT            = 9;   // The property value points to a binary blob (or directory path, depending on attachment flags) that will be uploaded to storage during XOnlineMessageSend
        public const byte XONLINE_MSG_PROP_TYPE_BOOL                  = 10;  // The property value points to a boolean value (1=TRUE, 0=FALSE)
        public const byte XONLINE_MSG_PROP_TYPE_STRING_ID             = 11;  // The property value contains a string ID whose text can be requested from the string service

        //
        // Attachment Flags
        //
        public const uint XONLINE_MSG_ATTACHMENT_FLAG_NON_EXPORTABLE  = 0x00000001; // This attachment should not be visible when the message is displayed on the web
        public const uint XONLINE_MSG_ATTACHMENT_FLAG_DIRECTORY       = 0x00000002; // The property value points to an ANSI path string to a local directory that will be uploaded to storage, instead of a binary blob
        public const uint XONLINE_MSG_ATTACHMENT_FLAGS_RESERVED       = 0xFFFFFFFC; // Flags reserved for future use

        //
        // Message Property Tags
        // Property tags occupy a word where the upper byte indicates the property's data type, and 
        // the lower byte indicates a unique identifier for the property.  Property identifiers only
        // need to be unique within a given message type.
        //
        public static ushort XONLINE_MSG_PROP_TAG( byte type, byte id ) { return (ushort)( type << 8 | id ); }
        public static byte XOnlineMessageGetPropId( ushort tag )      { return (byte)( tag & 0xFF ); }
        public static byte XOnlineMessageGetPropType( ushort tag )    { return (byte)( tag >> 8 ); }

        //
        // Message Property IDs 
        // Property IDs should adhere to the following ranges:
        //
        // Range           Purpose
        // 0x00-0x7F       Reserved for use by titles
        // 0x80-0xBF       Reserved for use by Microsoft for non-global properties
        // 0xC0-0xFF       Reserved for use by Microsoft for properties that span all message types
        public const byte XONLINE_MSG_PROP_ID_BUILTIN                 = 0x80; // Used for properties defined by Microsoft
        public const byte XONLINE_MSG_PROP_ID_GLOBAL                  = 0x40; // Used for properties that can span all message types

        //
        // Message IDs
        //
        public const uint XONLINE_MSG_ID_SEND_FAILED                  = 0x80000000; // NOTE: This high bit must not be used so that send can use it to return failed HRESULTs
        public const uint XONLINE_MSG_ID_SYSTEM_MESSAGE               = 0x40000000; // A message sent by the Live service or a publisher
        public const uint XONLINE_MSG_ID_TRANSIENT_MESSAGE            = 0x20000000; // A special type of message that goes away when the sender goes offline
        public const uint XONLINE_MSG_ID_BASE_MASK                    = 0x00FFFFFF;
        public const uint XONLINE_MSG_ID_RESERVED_MASK                = 0x1F000000;

        public static bool IsMsgTransient( uint msgid )               { return 0 != ( msgid & XONLINE_MSG_ID_TRANSIENT_MESSAGE ); }

        //
        // Message Types
        //
        // A message type establishes the purpose of the message and the properties that 
        // are required for a message of that type.
        // NOTE: xpnconfig expects these to stay fairly sequential.
        //
        public const byte XONLINE_MSG_TYPE_TITLE_CUSTOM               = 1;  // context: title defined;    required props: title defined
        public const byte XONLINE_MSG_TYPE_FRIEND_REQUEST             = 2;  // context: 0;                required props: none
        public const byte XONLINE_MSG_TYPE_GAME_INVITE                = 3;  // context: see msg flags;    required props: XONLINE_MSG_PROP_SESSION_ID for Xbox, XONLINE_MSG_PROP_SESSION_DESCRIPTION, XONLINE_MSG_PROP_SESSION_HOST_XNADDR, XONLINE_MSG_PROP_SESSION_HOST_KEY in addition for Xenon.
        public const byte XONLINE_MSG_TYPE_TEAM_RECRUIT               = 4;  // context: inviting team ID; required props: none
        public const byte XONLINE_MSG_TYPE_COMP_REMINDER              = 5;  // context: comp event ID;    required props: XONLINE_MSG_PROP_COMP_NAME, XONLINE_MSG_PROP_COMP_EVENT_START
        public const byte XONLINE_MSG_TYPE_COMP_REQUEST               = 6;  // context: comp event ID;    required props: XONLINE_MSG_PROP_COMP_NAME, XONLINE_MSG_PROP_COMP_START, XONLINE_MSG_PROP_COMP_REG_CLOSE
        public const byte XONLINE_MSG_TYPE_LIVE_MESSAGE               = 7;  // context: 0                 required props: XONLINE_MSG_PROP_SYSTEM_TEXT
        public const byte XONLINE_MSG_TYPE_PERSONAL_MESSAGE           = 8;  // context: 0                 required props: XONLINE_MSG_PROP_TEXT, XONLINE_MSG_PROP_VOICE_DATA.
        public const byte XONLINE_MSG_TYPE_VIDEO_MESSAGE              = 9;  // context: 0                 required props: XONLINE_MSG_PROP_TEXT, XONLINE_MSG_PROP_VIDEO_DATA
        public const byte XONLINE_MSG_TYPE_QUICK_CHAT_INVITE          = 10; // context: 0
        public const byte XONLINE_MSG_TYPE_VIDEO_CHAT_INVITE          = 11; // context: 0
        public const byte XONLINE_MSG_TYPE_PARTY_CHAT_INVITE          = 12; // context: 0

        public static bool IsNotifyMsgType( byte type )               { return ( type == XONLINE_MSG_TYPE_GAME_INVITE ); }


        //
        // Global property tags, allowed in any message type
        //
        public const ushort XONLINE_MSG_PROP_VOICE_DATA               = ( XONLINE_MSG_PROP_TYPE_ATTACHMENT << 8 ) | ( XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 1 );
        public const ushort XONLINE_MSG_PROP_VOICE_DATA_CODEC         = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 2 ); 
        public const ushort XONLINE_MSG_PROP_VOICE_DATA_DURATION      = ( XONLINE_MSG_PROP_TYPE_I4 << 8 )         | ( XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 3 ); 
        public const ushort XONLINE_MSG_PROP_TEXT                     = ( XONLINE_MSG_PROP_TYPE_STRING << 8 )     | ( XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 4 );
        public const ushort XONLINE_MSG_PROP_TEXT_LANGUAGE            = ( XONLINE_MSG_PROP_TYPE_I4 << 8 )         | ( XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 5 );
        public const ushort XONLINE_MSG_PROP_PHOTO_DATA               = ( XONLINE_MSG_PROP_TYPE_ATTACHMENT << 8 ) | ( XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 6 );
        public const ushort XONLINE_MSG_PROP_PHOTO_DATA_CODEC         = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_GLOBAL | XONLINE_MSG_PROP_ID_BUILTIN | 7 ); 
        public const ushort XONLINE_MAX_SUBJECT_SIZE                  = 20;

        //
        //Video Message Properties
        //
        public const ushort XONLINE_MSG_PROP_VIDEO_FRAME_DATA         = ( XONLINE_MSG_PROP_TYPE_ATTACHMENT << 8 ) | ( XONLINE_MSG_PROP_ID_BUILTIN | 1 );
        public const ushort XONLINE_MSG_PROP_VIDEO_FRAME_CODEC        = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 2 );          //This defines the First Frame of the Video as JPG, BMPetc if we wanted to show the First Frame of the Video in the HUD.
        public const ushort XONLINE_MSG_PROP_VIDEO_DATA               = ( XONLINE_MSG_PROP_TYPE_ATTACHMENT << 8 ) | ( XONLINE_MSG_PROP_ID_BUILTIN | 3 );
        public const ushort XONLINE_MSG_PROP_VIDEO_DATA_CODEC         = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 4 );
        public const ushort XONLINE_MSG_PROP_VIDEO_DATA_DURATION      = ( XONLINE_MSG_PROP_TYPE_I4 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 5 );

        //
        // Invite message properties
        //
        public const ushort XONLINE_MSG_PROP_SESSION_ID               = ( XONLINE_MSG_PROP_TYPE_I8 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 1 );
        public const ushort XONLINE_MSG_PROP_SESSION_DESCRIPTION      = ( XONLINE_MSG_PROP_TYPE_STRING<< 8 )      | ( XONLINE_MSG_PROP_ID_BUILTIN | 2 );
        public const ushort XONLINE_MSG_PROP_SESSION_HOST_XNADDR      = ( XONLINE_MSG_PROP_TYPE_I8<< 8 )          | ( XONLINE_MSG_PROP_ID_BUILTIN | 3 );
        public const ushort XONLINE_MSG_PROP_SESSION_HOST_KEY         = ( XONLINE_MSG_PROP_TYPE_I8<< 8 )          | ( XONLINE_MSG_PROP_ID_BUILTIN | 4 );

        //
        // Custom message properties
        //
        public const ushort XONLINE_MSG_PROP_GAME_MESSAGE             = ( XONLINE_MSG_PROP_TYPE_STRING << 8 )     | ( XONLINE_MSG_PROP_ID_BUILTIN | 1 );
        public const ushort XONLINE_MSG_PROP_PLAYER_MESSAGE           = ( XONLINE_MSG_PROP_TYPE_STRING << 8 )     | ( XONLINE_MSG_PROP_ID_BUILTIN | 2 );
        public const ushort XONLINE_MSG_PROP_CUSTOM_ACTIONS           = ( XONLINE_MSG_PROP_TYPE_BINARY << 8 )     | ( XONLINE_MSG_PROP_ID_BUILTIN | 3 );
        public const ushort XONLINE_MSG_PROP_CUSTOM_PAYLOAD           = ( XONLINE_MSG_PROP_TYPE_BINARY << 8 )     | ( XONLINE_MSG_PROP_ID_BUILTIN | 4 );

        //
        // Live system message properties
        //
        public const ushort XONLINE_MSG_PROP_SYSTEM_TEXT              = ( XONLINE_MSG_PROP_TYPE_STRING_ID << 8 )  | ( XONLINE_MSG_PROP_ID_BUILTIN | 1 );
        public const ushort XONLINE_MSG_PROP_LINK_TO                  = ( XONLINE_MSG_PROP_TYPE_I4 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 2 );

        //
        // Competitions message properties
        //
        public const ushort XONLINE_MSG_PROP_COMP_DATASET             = ( XONLINE_MSG_PROP_TYPE_I4 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x1 );
        public const ushort XONLINE_MSG_PROP_COMP_NAME                = ( XONLINE_MSG_PROP_TYPE_STRING << 8 )     | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x2 );
        public const ushort XONLINE_MSG_PROP_COMP_START               = ( XONLINE_MSG_PROP_TYPE_FILETIME << 8 )   | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x3 );
        public const ushort XONLINE_MSG_PROP_COMP_ROUND               = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x4 );
        public const ushort XONLINE_MSG_PROP_COMP_OPPONENT            = ( XONLINE_MSG_PROP_TYPE_STRING_ID << 8 )  | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x5 );
        public const ushort XONLINE_MSG_PROP_COMP_ADMIN               = ( XONLINE_MSG_PROP_TYPE_I8 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x6 );
        public const ushort XONLINE_MSG_PROP_COMP_REG_CLOSE           = ( XONLINE_MSG_PROP_TYPE_FILETIME << 8 )   | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x7 );
        public const ushort XONLINE_MSG_PROP_COMP_PRIVATE_SLOTS       = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x8 );
        public const ushort XONLINE_MSG_PROP_COMP_PUBLIC_SLOTS        = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x9 );
        public const ushort XONLINE_MSG_PROP_COMP_UNITS               = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0xA );
        public const ushort XONLINE_MSG_PROP_COMP_INTERVAL            = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0xB );
        public const ushort XONLINE_MSG_PROP_COMP_DAYMASK             = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0xC );
        public const ushort XONLINE_MSG_PROP_COMP_DESCRIPTION         = ( XONLINE_MSG_PROP_TYPE_STRING << 8 )     | ( XONLINE_MSG_PROP_ID_BUILTIN | 0xD );
        public const ushort XONLINE_MSG_PROP_COMP_URL                 = ( XONLINE_MSG_PROP_TYPE_STRING << 8 )     | ( XONLINE_MSG_PROP_ID_BUILTIN | 0xE );
        public const ushort XONLINE_MSG_PROP_COMP_EVENT_ID            = ( XONLINE_MSG_PROP_TYPE_I8 << 8 )         | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x10 );
        public const ushort XONLINE_MSG_PROP_COMP_EVENT_START         = ( XONLINE_MSG_PROP_TYPE_FILETIME << 8 )   | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x11 );

        //
        // Client Types
        //
        // XONLINE_MSG_TYPE_LIVE_MESSAGE may use the qwSenderContext
        //  to specify specific clients that should suppress the message 
        //  or refer the user to xbox.com to consume the message
        //
        public const byte XONLINE_MSG_CLIENT_XBOXCOM                  = 0x0000000000000001;
        public const byte XONLINE_MSG_CLIENT_XBOX360                  = 0x0000000000000002;
        public const byte XONLINE_MSG_CLIENT_ZUNE                     = 0x0000000000000004;
        public const byte XONLINE_MSG_CLIENT_PANORAMA                 = 0x0000000000000008;

        //
        // LinkTo Destinations
        //
        // XONLINE_MSG_TYPE_LIVE_MESSAGE has an optional property
        //  to specify a link to an abstract platform client destination that will allow
        //  the user to take action on the message. 
        //
        public const byte XONLINE_MSG_LINKTO_ACCOUNT_MANAGEMENT       = 0x00000001;

        //
        // Voice Codec types (values for XONLINE_MSG_PROP_VOICE_DATA_CODEC)
        //
        public const ushort XONLINE_PROP_VOICE_DATA_CODEC_WMAVOICE_V90      = 1;
        public const ushort XONLINE_PROP_VOICE_DATA_CODEC_SASE3200          = 2;

        //
        // Photo Encoding types (values for XONLINE_MSG_PROP_PHOTO_DATA_CODEC)
        //
        public const ushort XONLINE_PROP_PHOTO_DATA_CODEC_PNG      = 1;
        
        //
        //Personal Message Properties
        //None beyond the text and voice stuff above:
        //
         
        //
        //Quick Chat Invite Properties.
        //
        public const ushort XONLINE_HUD_MSG_PROP_VOICECHAT_PORT       = ( XONLINE_MSG_PROP_TYPE_I2 << 8 )           | ( XONLINE_MSG_PROP_ID_BUILTIN | 0x1 );
        
         
        //
        // Definitions that are internal only, in MSINTERNAL sections of xonline.x
        //

        public const uint XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN         = 64;

        // Valid values that can be passed in the dwFlags member of DeleteMessageMsg
        public const uint XMSG_DELETE_MESSAGE_FLAG_BLOCK_SENDER       = 0x00000001;

        // Valid values that can be found in the dwFlags member of UserTitleData
        public const uint XMSG_USER_TITLE_FLAG_ACCEPT_MARKETING       = 0x00000001;

        // Valid values that can be passed in the dwFlags member of DeleteSystemMessageMsg
        public const uint XMSG_DELETE_SYSTEM_MESSAGE_FLAG_REVOKE_ALL  = 0x00000001;

        // Utility functions for converting message time values
        public static DateTime MsgTimeToDateTime( uint mt )
        {
            return DateTime.FromFileTimeUtc( (long)( ( (ulong) mt * 10000000 ) + 0x01C2B128BA2B4000 ) );
        }
        public static uint DateTimeToMsgTime( DateTime dt )
        {
            return (uint)( ( dt.ToFileTimeUtc() - 0x01C2B128BA2B4000 ) / 10000000 );
        }

        // RevokeMessageEx flags
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_BLOCK_SENDER    = 0x00000001;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_ID          = 0x00000002;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER      = 0x00000004;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_CONTEXT     = 0x00000008;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_PROP        = 0x00000010;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE        = 0x00000020;
        public const uint XMSG_REVOKE_MESSAGE_EX_FLAGS_RESERVED       = 0xFFFFFFC0;
        
        // Message Notifications (Internal)
        public const uint XONLINE_MSG_NOTIFICATION_FLAG_SAME_TITLE         = 0x000001;
        public const uint XONLINE_MSG_NOTIFICATION_FLAG_SAME_PUBLISHER     = 0x000002;
        public const uint XONLINE_MSG_NOTIFICATION_FLAG_INVITE_FROM_FRIEND = 0x000004;
        public const uint XONLINE_MSG_NOTIFICATION_FLAG_HAS_VOICE          = 0x000008;
        public const uint XONLINE_MSG_NOTIFICATION_FLAG_HAS_TEXT           = 0x000010;
        public const uint XONLINE_MSG_NOTIFICATION_FLAG_ALT_TITLE          = 0x000020;
        public const uint XONLINE_MSG_NOTIFICATION_FLAG_TITLE_RESERVED     = 0xFF0000;
        public const uint XONLINE_MSG_NOTIFICATION_FLAG_RESERVED           = 0x00FFC0;

    }; // end definitions


    public class MessagingXrlObject : XRLObject2
    {
        public override string Xrl
        {
            get
            {
                return "/xpnfront/xmessaging.srf";
            }
        }
    }
    //
    // Structure Representing a single message property. 
    //  Maps to XMSG_PROPERTY in xonline.x
    //  
    public class MessageProperty : WireData
    {
        public ushort           wPropTag;           // This property's unique identifier

        // The following 3 fields are part of the unnamed union
        //  in _XMSG_PROPERTY
        public ushort           wPropOffset;        // The offset from the start of rgbData of this property's data
        // public ushort        wData;              // For type XONLINE_MSG_PROP_TYPE_I2 this contains the actual data
        // public byte          bData;              // For type XONLINE_MSG_PROP_TYPE_I1 and XONLINE_MSG_PROP_TYPE_BOOL this contains the actual data

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(wPropTag);
            binaryWriter.Write(wPropOffset);
        }
    };

    
    //
    // Structure Representing the entire message details. 
    //  Maps to XMSG_DETAILS in xonline.x
    //  
    public class MessageDetails : WireData
    {
        public ushort           wPropCount;
        public ushort           cbData;
              
        [WireInfo(SizeParam="wPropCount")]
        public MessageProperty[]  rgProperties;     // Property descriptors
        
        [WireInfo(SizeParam="cbData")]
        public byte []          rgbData;            // Property data

        public override int Size()
        {
            // pDetails->cbData + sizeof( XMSG_DETAILS ) + ( pDetails->wPropCount * sizeof( XMSG_PROPERTY ) )
            return cbData + 4 + ( wPropCount * 4 );
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup the array sizes
            wPropCount = rgProperties == null ? (ushort)0 : (ushort)rgProperties.Length;
            cbData = rgbData == null ? (ushort)0 : (ushort)rgbData.Length;

            binaryWriter.Write(wPropCount);
            binaryWriter.Write(cbData);
            for (int i = 0; i < wPropCount; ++i)
            {
                rgProperties[i].WriteStream(binaryWriter);
            }
            if (rgbData != null && cbData > 0)
            {
                binaryWriter.Write(rgbData);
            }
        }
    };


    //
    // Structure Representing a binary property.
    //  Maps to XMSG_PROPERTY_BINARY in xonline.x
    //  
    public class MessageBinaryProperty : WireData
    {
        public ushort           cbData;

        [WireInfo(SizeParam="cbData")]
        public byte []          rgbData;            // Property data
    };


    //
    // Structure Representing a binary property.
    //  Maps to XMSG_PROPERTY_STRING in xonline.x
    //  
    public class MessageStringProperty : WireData
    {
        public ushort           cbString;

        [WireInfo(SizeParam="cbString", NullTerminate=true)]
        public string           szString;           // Property data
    };


    //
    // Structure Representing an attachment property. 
    //  Maps to XMSG_PROPERTY_ATTACHMENT in xonline.x
    //  
    public class MessageAttachmentProperty : WireData
    {
        public uint             cbAttach;
        public uint             dwAttachFlags;
        public uint             cbAttachUrl;
        
        [WireInfo(SizeParam="cbAttachUrl", NullTerminate=true)]
        public string           szAttachUrl;     
    };


    //
    // Structure Representing summary message data
    //  maps to Q_MESSAGE_SUMMARY in xonline.x
    //  
    public class MessageSummary : WireData
    {
        public ulong            qwSenderID;
        public ulong            qwSenderContext;
        public uint             mtSentTime;
        public uint             dwMessageID;
        public uint             dwMessageFlags;
        public uint             dwSenderTitleID;
        public ushort           wExpireMinutes;       // An offset in minutes from the sent time
        public ushort           cbDetails;
        public byte             bMessageType;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE - 1)]
        public string           szSenderName;

        public static int StaticSize()
        {
            // sizeof( Q_MESSAGE_SUMMARY )
            return 52;
        }
    };


    //
    // Structure Representing summary message data
    //  maps to Q_MESSAGE_SUMMARY_2 in xonline.x
    //  
    public class MessageSummary2 : WireData
    {
        public ulong            qwSenderID;
        public ulong            qwSenderContext;
        public uint             mtSentTime;
        public uint             dwMessageID;
        public uint             dwMessageFlags;
        public uint             dwSenderTitleID;
        public ushort           wExpireMinutes;       // An offset in minutes from the sent time
        public ushort           cbDetails;
        public byte             bMessageType;
        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE - 1)]
        public string           szSenderName;

        [WireInfo(ArraySize=MsgDefs.XONLINE_MAX_SUBJECT_SIZE * 2)]
        public byte[]           rgbSubject;

        public string szSubject
        {
            get
            {
                int iMaxIndex = 0;
                for (int i = 0; i < rgbSubject.Length; i += 2)
                {
                    if (rgbSubject[i] == 0 && rgbSubject[i+1] == 0)
                    {
                        iMaxIndex = i;
                        break;
                    }
                }

                return new System.Text.UnicodeEncoding().GetString(rgbSubject, 0, iMaxIndex);
            }

            set
            { 
                string szText = value;
                if (szText.Length >= MsgDefs.XONLINE_MAX_SUBJECT_SIZE)
                {
                    szText = szText.Substring(0, MsgDefs.XONLINE_MAX_SUBJECT_SIZE - 1);
                }

                byte[] rgbData = (new System.Text.UnicodeEncoding()).GetBytes(szText);

                rgbSubject = new byte[MsgDefs.XONLINE_MAX_SUBJECT_SIZE * 2];
                for (int i = 0; i < rgbSubject.Length; i++)
                {
                    if (i < rgbData.Length)
                    {
                        rgbSubject[i] = rgbData[i];
                    }
                    else
                    {
                        rgbSubject[i] = 0;
                    }
                }
            }
        }

        public static int StaticSize()
        {
            // sizeof( Q_MESSAGE_SUMMARY )
            return 52 + (MsgDefs.XONLINE_MAX_SUBJECT_SIZE * 2);
        }
    };


    //
    // Structure Representing a request to enumerate messages on behalf of a user
    //  maps to Q_ENUM_MESSAGES_MSG in xonline.x
    //  
    public class EnumerateMessagesMsg : MessagingXrlObject
    {
        public EnumerateMessagesMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_MESSAGES,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;

        public override int Size()
        {
            // sizeof( Q_ENUM_MESSAGES_MSG )
            return 40;
        }        
    }

    //
    // Structure Representing the reply to an EnumerateMessages message
    //  maps to Q_ENUM_MESSAGES_REPLY_MSG in xonline.x
    //  
    public class EnumerateMessagesReply : XRLObject2
    {
        public EnumerateMessagesReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_MESSAGES_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public ushort           cMessages;

        [WireInfo(SizeParam="cMessages")]        
        public MessageSummary[]  rgMessages = null;

        public override int Size()
        {
            // sizeof( Q_ENUM_MESSAGES_REPLY_MSG ) + cMessages * sizeof( Q_MESSAGE_SUMMARY )
            return 38 + ( cMessages * MessageSummary.StaticSize() );
        }        
    }


    //
    // Structure Representing a request to enumerate messages on behalf of a user
    //  maps to Q_ENUM_MESSAGES_2_MSG in xonline.x
    //  
    public class EnumerateMessages2Msg : MessagingXrlObject
    {
        public EnumerateMessages2Msg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_MESSAGES_2,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;

        public override int Size()
        {
            // sizeof( Q_ENUM_MESSAGES_2_MSG )
            return 40;
        }        
    }

    //
    // Structure Representing the reply to an EnumerateMessages message
    //  maps to Q_ENUM_MESSAGES_REPLY_MSG in xonline.x
    //  
    public class EnumerateMessages2Reply : XRLObject2
    {
        public EnumerateMessages2Reply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_MESSAGES_2_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public ushort           cMessages;

        [WireInfo(SizeParam="cMessages")]        
        public MessageSummary2[]  rgMessages = null;

        public override int Size()
        {
            // sizeof( Q_ENUM_MESSAGES_2_REPLY_MSG ) + cMessages * sizeof( Q_ENUM_MESSAGE_2_REPLY )
            return 38 + ( cMessages * MessageSummary2.StaticSize() );
        }        
    }


    //
    // Structure Representing the reply for the MessageSummary of a particular message
    //  maps to Q_MESSAGE_SUMMARY_MSG in xonline.x
    //  
    public class MessageSummaryMsg : XRLObject2
    {
        public MessageSummaryMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_SUMMARY,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwMessageID;  

        public override int Size()
        {
            // sizeof( Q_MESSAGE_SUMMARY_MSG )
            return 44;
        }        
    };

    //
    // Structure Representing a request for the MessageSummary of a particular message
    //  maps to Q_MESSAGE_SUMMARY_REPLY_MSG in xonline.x
    //  
    public class MessageSummaryReply : XRLObject2
    {
        public MessageSummaryReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_SUMMARY_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        [WireInfo(Serialize=false)]
        public MessageSummary   summary;

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );
            if( HResult.Succeeded( hr ) )
            {
                summary = new MessageSummary();
                summary.ReadStream( binaryReader );
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            base.WriteStream( binaryWriter );
            if( HResult.Succeeded( hr ) )
            {
                summary.WriteStream( binaryWriter );
            }
        }

        public override int Size()
        {
            ushort cbSummary = 0;
            if( HResult.Succeeded( hr ) )
            {
                cbSummary = (ushort) MessageSummary.StaticSize();
            }

            // sizeof( part of Q_MESSAGE_SUMMARY_REPLY_MSG ) + sizeof( Q_MESSAGE_SUMMARY )
            return 36 + cbSummary;
        }        
    };


    //
    // Structure Representing the reply for the MessageSummary2 of a particular message
    //  maps to Q_MESSAGE_SUMMARY_2_MSG in xonline.x
    //  
    public class MessageSummary2Msg : XRLObject2
    {
        public MessageSummary2Msg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_SUMMARY_2,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwMessageID;  

        public override int Size()
        {
            // sizeof( Q_MESSAGE_SUMMARY_2_MSG )
            return 44;
        }        
    };

    //
    // Structure Representing a request for the MessageSummary2 of a particular message
    //  maps to Q_MESSAGE_SUMMARY_REPLY_MSG in xonline.x
    //  
    public class MessageSummary2Reply : XRLObject2
    {
        public MessageSummary2Reply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_SUMMARY_2_REPLY, this);
        }

        public BaseHeader       header;
        public HResult          hr;
        [WireInfo(Serialize=false)]
        public MessageSummary2  summary;

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            summary = new MessageSummary2();
            summary.ReadStream( binaryReader );

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            base.WriteStream( binaryWriter );
            if( HResult.Succeeded( hr ) )
            {
                summary.WriteStream( binaryWriter );
            }
            else 
            {
                // If there is a failure, write an empty summary.  This emulates the behavior of the INH's Switchboard::SendEmptyReply() function.
                MessageSummary2 emptySummary = new MessageSummary2();
                emptySummary.WriteStream( binaryWriter );
            }
        }

        public override int Size()
        {
            // sizeof( part of Q_MESSAGE_SUMMARY_REPLY_2_MSG ) + sizeof( Q_MESSAGE_SUMMARY_2 )
            return 36 + MessageSummary2.StaticSize();
        }        
    };


    //
    // Structure Representing a request for the MessageDetails of a particular message
    //  maps to Q_MESSAGE_DETAILS_MSG in xonline.x
    //  
    public class MessageDetailsMsg : MessagingXrlObject
    {
        public MessageDetailsMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_DETAILS,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwMessageID;    
        public uint             dwSetFlags;
        public uint             dwUnsetFlags;

        public override int Size()
        {
            // sizeof( Q_MESSAGE_DETAILS_MSG )
            return 52;
        }
    };

    //
    // Structure Representing the reply or the MessageDetails of a particular message
    //  maps to Q_MESSAGE_DETAILS_REPLY_MSG in xonline.x
    //  
    public class MessageDetailsReply : XRLObject2
    {
        public MessageDetailsReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_DETAILS_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        [WireInfo(Serialize=false)]
        public MessageSummary   summary;
        [WireInfo(Serialize=false)]
        public MessageDetails   details;

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            summary = new MessageSummary();
            summary.ReadStream( binaryReader );

            if( HResult.Succeeded( hr ) )
            {
                if( 0 != summary.cbDetails )
                {
                    details = new MessageDetails();
                    details.ReadStream( binaryReader );
                }
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            base.WriteStream( binaryWriter );

            if( HResult.Succeeded( hr ) )
            {
                summary.WriteStream( binaryWriter );

                if( 0 != summary.cbDetails )
                {
                    details.WriteStream( binaryWriter );
                }
            }
            else 
            {
                // If there is a failure, write an empty summary.  This emulates the behavior of the INH's Switchboard::SendEmptyReply() function.
                MessageSummary emptySummary = new MessageSummary();
                emptySummary.WriteStream( binaryWriter );
            }
        }

        public override int Size()
        {
            // sizeof( part of Q_MESSAGE_SUMMARY_REPLY_MSG ) + sizeof( Q_MESSAGE_SUMMARY ) + cbDetails
            return 36 + MessageSummary.StaticSize() + summary.cbDetails;
        }        
    };


    //
    // Structure Representing a request to delete a particular message
    //  maps to Q_DELETE_MESSAGE_MSG in xonline.x
    //  
    public class DeleteMessageMsg : XRLObject2
    {
        public DeleteMessageMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_DELETE_MESSAGE,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwMessageID;    
        public uint             dwFlags;

        public override int Size()
        {
            // sizeof( Q_DELETE_MESSAGE_MSG )
            return 48;
        }        
    };

    //
    // Structure Representing the reply to a DeleteMessage message
    //  maps to Q_DELETE_MESSAGE_REPLY_MSG in xonline.x
    //  
    public class DeleteMessageReply : XRLObject2
    {
        public DeleteMessageReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_DELETE_MESSAGE_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;

        public override int Size()
        {
            // sizeof( Q_DELETE_MESSAGE_REPLY_MSG )
            return 36;
        }        
    };


    //
    // Structure Representing the result of a message send to a specific PUID
    //  maps to Q_RECIPIENT_RESULT in xonline.x
    //  
    public class RecipientResult: WireData
    {
        public ulong            qwUserID;
        public uint             dwMessageID; // If the send failed, this is the error code, if it succeeded this is the message ID

        public static int StaticSize()
        {
            // sizeof( Q_RECIPIENT_RESULT )
            return 12;
        }        
    };  


    //
    // Structure Representing a request to send a message in the messaging service
    //  maps to Q_SEND_MESSAGE_MSG in xonline.x
    //  
    public class SendMessageMsg: XRLObject2
    {
        public SendMessageMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_SEND_MESSAGE,this);
        }

        public BaseHeader       header;
        public ulong            qwSenderID;
        public ulong            qwSenderContext;
        public uint             dwMessageFlags;
        public uint             dwSenderTitleID;
        public ushort           wExpireMinutes;       // An offset in minutes from the sent time
        public ushort           cbDetails;
        public ushort           cRecipients;
        public byte             bMessageType;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE - 1)]
        public string           szSenderName;

        [WireInfo(SizeParam="cRecipients")]
        public ulong []         qwRecipientIDs;

        [WireInfo(Serialize=false)]
        public MessageDetails   details;           // If there are details, they go afterwards

        public override int Size()
        {
            // sizeof( Q_SEND_MESSAGE_MSG ) + ( cRecipients * sizeof( ULONGLONG ) ) + cbDetails
            return 78 + ( cRecipients * 8 ) + cbDetails;
        }        

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            if( 0 != cbDetails )
            {
                details = new MessageDetails();
                details.ReadStream( binaryReader );
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            base.WriteStream( binaryWriter );

            if( 0 != cbDetails )
            {
                details.WriteStream( binaryWriter );
            }
        }
    };
    
    
    //
    // Structure Representing a complete SendMessage response message
    //  maps to Q_SEND_MESSAGE_REPLY_MSG in xonline.x
    //  
    public class SendMessageReply: XRLObject2
    {   
        public SendMessageReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_SEND_MESSAGE_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public ushort           cRecipients;
        
        [WireInfo(SizeParam="cRecipients")]
        public RecipientResult [] recipients;            

        public override int Size()
        {
            // sizeof( Q_SEND_MESSAGE_REPLY_MSG ) + cRecipients * sizeof( Q_RECIPIENT_RESULT )
            return 38 + ( cRecipients * RecipientResult.StaticSize() );
        }        
    }    


    //
    // Structure Representing a request to revoke a particular message
    //  maps to Q_REVOKE_MESSAGE_MSG in xonline.x
    //  
    public class RevokeMessageMsg : XRLObject2
    {
        public RevokeMessageMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_REVOKE_MESSAGE,this);
        }

        public BaseHeader       header;
        public ulong            qwSenderID;
        public ulong            qwSenderContext;
        public ushort           cRecipients;
        public byte             bMessageType;
        
        [WireInfo(SizeParam="cRecipients")]
        public RecipientResult[] rgRecipients;            

        public override int Size()
        {
            // sizeof( Q_REVOKE_MESSAGE_MSG ) + cRecipients * sizeof( Q_RECIPIENT_RESULT )
            return 51 + ( cRecipients * RecipientResult.StaticSize() );
        }        
    };


    //
    // Structure Representing a request to revoke a particular message
    //  maps to Q_REVOKE_MESSAGE_EX_MSG in xonline.x
    //  
    public class RevokeMessageExMsg : XRLObject2
    {
        public RevokeMessageExMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_REVOKE_MESSAGE_EX,this);
        }

        public BaseHeader       header;
        public ulong            qwSenderID;
        public ulong            qwSenderContext;
        public uint             dwFlags;
        public ushort           wPropTag;
        public ushort           cRecipients;
        public ushort           cbProp;
        public byte             bMessageType;
        
        [WireInfo(SizeParam="cRecipients")]
        public RecipientResult[] rgRecipients;            

        [WireInfo(SizeParam="cbProp")]
        public byte[]           rgbProp;

        public override int Size()
        {
            // sizeof( Q_REVOKE_MESSAGE_EX_MSG ) + cRecipients * sizeof( Q_RECIPIENT_RESULT ) + cbProp
            return 59 + ( cRecipients * RecipientResult.StaticSize() ) + cbProp;
        }        
    };


    //
    // Structure Representing the reply to a RevokeMessage message
    //  maps to Q_REVOKE_MESSAGE_REPLY_MSG in xonline.x
    //  
    public class RevokeMessageReply : XRLObject2
    {
        public RevokeMessageReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_REVOKE_MESSAGE_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;

        public override int Size()
        {
            // sizeof( Q_REVOKE_MESSAGE_REPLY_MSG )
            return 36;
        }        
    };


    //
    // Structure Representing a request to delete a particular message
    //  maps to Q_DELETE_TITLE_MSG in xonline.x
    //  
    public class DeleteTitleMsg : XRLObject2
    {
        public DeleteTitleMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_DELETE_TITLE,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;    

        public override int Size()
        {
            // sizeof( Q_DELETE_TITLE_MSG )
            return 44;
        }        
    };

    //
    // Structure Representing the reply to a DeleteMessage message
    //  maps to Q_DELETE_TITLE_REPLY_MSG in xonline.x
    //  
    public class DeleteTitleReply : XRLObject2
    {
        public DeleteTitleReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_DELETE_TITLE_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;

        public override int Size()
        {
            // sizeof( Q_DELETE_TITLE_REPLY_MSG )
            return 36;
        }        
    };


    //
    // Structure Representing a request to enumerate titles for a user
    //  maps to Q_ENUM_TITLES_MSG in xonline.x
    //  
    public class EnumerateTitlesMsg : XRLObject2
    {
        public EnumerateTitlesMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_TITLES,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;

        public override int Size()
        {
            // sizeof( Q_ENUM_TITLES_MSG )
            return 40;
        }        
    };

    //
    // Structure Representing a user-owned title
    //  maps to Q_USER_TITLE in xonline.x
    //  
    public class UserTitleData : WireData
    {
        public uint             dwTitleID;
        public DateTime         dtLastLogon;
        public uint             dwFlags;

        public static int StaticSize()
        {
            // sizeof( Q_USER_TITLE )
            return 16;
        }   
    };

    //
    // Structure Representing the reply to an EnumerateTitles message
    //  maps to Q_ENUM_TITLES_REPLY_MSG in xonline.x
    //  
    public class EnumerateTitlesReply : XRLObject2
    {
        public EnumerateTitlesReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_TITLES_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public ushort           cTitles;    
    
        [WireInfo(SizeParam="cTitles")]
        public UserTitleData[]  rgTitles;

        public override int Size()
        {
            // sizeof( Q_ENUM_TITLES_REPLY_MSG ) + cTitles * sizeof( Q_USER_TITLE )
            return 38 + ( cTitles + UserTitleData.StaticSize() );
        }   
    };


    //
    // Structure Representing a request to set/unset flags on a particular message
    //  maps to Q_MESSAGE_FLAGS_MSG in xonline.x
    //  
    public class MessageFlagsMsg : XRLObject2
    {
        public MessageFlagsMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_FLAGS,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwMessageID;
        public uint             dwSetFlags;
        public uint             dwUnsetFlags;

        public override int Size()
        {
            // sizeof( Q_MESSAGE_FLAGS_MSG )
            return 52;
        }   
    };

    //
    // Structure Representing the reply to a MessageFlags message
    //  maps to Q_MESSAGE_FLAGS_REPLY_MSG in xonline.x
    //  
    public class MessageFlagsReply : XRLObject2
    {
        public MessageFlagsReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_MESSAGE_FLAGS_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;

        public override int Size()
        {
            // sizeof( Q_MESSAGE_FLAGS_REPLY_MSG )
            return 36;
        }   
    };


    //
    // Structure Representing summary system message data
    //  maps to Q_SYSTEM_MESSAGE_SUMMARY in xonline.x
    //  
    public class SystemMessageSummary : WireData
    {
        public uint             dwTitleID;

        public ulong            qwSenderContext;
        public DateTime         dtSentTime;
        public uint             dwRegion;
        public uint             dwMessageID;
        public uint             dwMessageFlags;
        public ushort           wExpireMinutes;       // An offset in minutes from the sent time
        public ushort           cbDetails;
        public byte             bMessageType;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE - 1)]
        public string           szSenderName;

        [WireInfo(ArraySize=(int)MsgDefs.XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN)]
        public string           szDescription;

        public static int StaticSize()
        {
            // sizeof( Q_SYSTEM_MESSAGE_SUMMARY )
            return 116;
        }   
    };


    //
    // Structure Representing a request to enumerate system messages on behalf of a title
    //  maps to Q_ENUM_SYSTEM_MESSAGES_MSG in xonline.x
    //  
    public class EnumerateSystemMessagesMsg : XRLObject2
    {
        public EnumerateSystemMessagesMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_SYSTEM_MESSAGES,this);
        }

        public BaseHeader       header;
        public uint             dwTitleID;

        public override int Size()
        {
            // sizeof( Q_ENUM_SYSTEM_MESSAGES_MSG )
            return 36;
        }   
    }

    //
    // Structure Representing the reply to an EnumerateSystemMessages message
    //  maps to Q_ENUM_SYSTEM_MESSAGES_REPLY_MSG in xonline.x
    //  
    public class EnumerateSystemMessagesReply : XRLObject2
    {
        public EnumerateSystemMessagesReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_ENUM_SYSTEM_MESSAGES_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public ushort           cMessages;

        [WireInfo(SizeParam="cMessages")]        
        public SystemMessageSummary[]  rgMessages = null;

        public override int Size()
        {
            // sizeof( Q_ENUM_SYSTEM_MESSAGES_REPLY_MSG ) + cMessages * sizeof( Q_SYSTEM_MESSAGE_SUMMARY )
            return 38 + ( cMessages * SystemMessageSummary.StaticSize() );
        }   
    }


    //
    // Structure Representing a request for the message details of a system message
    //  maps to Q_SYSTEM_MESSAGE_DETAILS_MSG in xonline.x
    //  
    public class SystemMessageDetailsMsg : XRLObject2
    {
        public SystemMessageDetailsMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_SYSTEM_MESSAGE_DETAILS,this);
        }

        public BaseHeader       header;
        public uint             dwTitleID;
        public uint             dwMessageID;

        public override int Size()
        {
            // sizeof( Q_SYSTEM_MESSAGE_DETAILS_MSG )
            return 40;
        }   
    };

    //
    // Structure Representing the reply to a SystemMessageDetails message
    //  maps to Q_SYSTEM_MESSAGE_DETAILS_REPLY_MSG in xonline.x
    //  
    public class SystemMessageDetailsReply : XRLObject2
    {
        public SystemMessageDetailsReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_SYSTEM_MESSAGE_DETAILS_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public SystemMessageSummary   summary;
        [WireInfo(Serialize=false)]
        public MessageDetails   details;

        public override int Size()
        {
            // sizeof( part of Q_SYSTEM_MESSAGE_DETAILS_REPLY_MSG ) + sizeof( Q_SYSTEM_MESSAGE_SUMMARY ) + cbDetails
            return 36 + SystemMessageSummary.StaticSize() + summary.cbDetails;
        }

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            if( 0 != summary.cbDetails )
            {
                details = new MessageDetails();
                details.ReadStream( binaryReader );
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            base.WriteStream( binaryWriter );

            if( 0 != summary.cbDetails )
            {
                details.WriteStream( binaryWriter );
            }
        }
    };


    // 
    // Structure Representing a request to delete a particular system message
    //  maps to Q_DELETE_SYSTEM_MESSAGE_MSG in xonline.x
    //  
    public class DeleteSystemMessageMsg : XRLObject2
    {
        public DeleteSystemMessageMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_DELETE_SYSTEM_MESSAGE,this);
        }

        public BaseHeader       header;
        public uint             dwTitleID;
        public uint             dwMessageID;
        public uint             dwFlags;

        public override int Size()
        {
            // sizeof( Q_DELETE_SYSTEM_MESSAGE_MSG )
            return 44;
        }   
    };

    //
    // Structure Representing the reply to a DeleteSystemMessage message
    //  maps to Q_DELETE_SYSTEM_MESSAGE_REPLY_MSG in xonline.x
    //  
    public class DeleteSystemMessageReply : XRLObject2
    {
        public DeleteSystemMessageReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_DELETE_SYSTEM_MESSAGE_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;

        public override int Size()
        {
            // sizeof( Q_DELETE_SYSTEM_MESSAGE_REPLY_MSG )
            return 36;
        }   
    };


    //
    // Structure Representing a request to send a system message in the messaging service
    //  maps to Q_SEND_SYSTEM_MESSAGE_MSG in xonline.x
    //  
    public class SendSystemMessageMsg: XRLObject2
    {
        public SendSystemMessageMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_SEND_SYSTEM_MESSAGE,this);
        }

        public BaseHeader       header;
        public uint             dwTitleID;
        public ulong            qwSenderContext;
        public DateTime         dtSentTime;
        public uint             dwRegion;
        public uint             dwMessageFlags;
        public ushort           wExpireMinutes;       // An offset in minutes from the sent time
        public ushort           cbDetails;
        public byte             bMessageType;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE - 1)]
        public string           szSenderName;

        [WireInfo(ArraySize=(int)MsgDefs.XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN)]
        public string           szDescription;

        [WireInfo(Serialize=false)]
        public MessageDetails   details;           // If there are details, they go afterwards

        public override int Size()
        {
            // sizeof( Q_SEND_SYSTEM_MESSAGE_MSG ) + cbDetails
            return 144 + cbDetails;
        }        

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            if( 0 != cbDetails )
            {
                details = new MessageDetails();
                details.ReadStream( binaryReader );
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            base.WriteStream( binaryWriter );

            if( 0 != cbDetails )
            {
                details.WriteStream( binaryWriter );
            }
        }
    };
    
    
    //
    // Structure Representing a complete SendSystemMessage response message
    //  maps to Q_SEND_SYSTEM_MESSAGE_REPLY_MSG in xonline.x
    //  
    public class SendSystemMessageReply: XRLObject2
    {   
        public SendSystemMessageReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_SEND_SYSTEM_MESSAGE_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public uint             dwMessageID;

        public override int Size()
        {
            // sizeof( Q_SEND_SYSTEM_MESSAGE_REPLY_MSG )
            return 40;
        }   
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\matchprot.cs ===
//
// MatchProt.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Matchmaking Service Integration
// Xbox Online Service
//

using System;
using System.Collections;
using System.IO;
using System.Text;
using System.Net;

using xonline.common.mgmt;
using xonline.common.service;

[assembly: XomAreaDefinition(XomAreaName.MatchProxy)]

namespace xonline.common.protocol 
{
    //
    // Matchmaking definitions
    //
    public class MatchDefs
    {
        // this http header is used by stress to direct the match front door at a presence
        // emulator instead of the presence vip.
        public const string AlternatePresenceDestinationHeaderName = "AlternatePresenceDestination";

        public const uint X_MAX_STRING_ATTRIBUTE_LEN                  = 400;
        public const uint X_MAX_BLOB_ATTRIBUTE_LEN                    = 800;

        public const uint X_ATTRIBUTE_SCOPE_MASK                      = 0x80000000;
        public const uint X_ATTRIBUTE_SCOPE_GLOBAL                    = 0x80000000;
        public const uint X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC            = 0x00000000;

        // These are the datatypes that were supported in Xbox 1 matchmaking.
        // In Xenon, the match Attributes sent on the wire are actually Xenon
        // Properties and Contexts. Xenon Property and Context ids use the 
        // X_ATTRIBUTE_XENON_DATATYPE_XXX definitions in the next section, not
        // these definitions.
        //
        // We've chosen to extend this Xbox 1 wiredata object instead of
        // creating a similar but new wiredata object for Xenon. To retain
        // compatibility with both Xbox and Xenon clients, Xenon clients
        // will encode the integer, float, datetime, and context attributes as
        // X_ATTRIBUTE_DATATYPE_INTEGER, and use 64 bits on the wire for
        // all of them. The Xenon client will flag String properties with
        // X_ATTRIBUTE_DATATYPE_STRING before putting them on the wire, so
        // they are processed correctly by these wiredata classes.
        // X_ATTRIBUTE_DATATYPE_BLOB properties are not supported in Xenon.
        //
        // The attribute and parameter names in the generated sql code for Xenon
        // titles will not have this xbox 1 "match" datatype information, so the
        // names in the database match the ids in the xlast file. Therefore the front
        // door will mask out these bits before generating attribute or parameter names
        // for xenon titles.
        public const uint X_ATTRIBUTE_DATATYPE_MASK                   = 0x00F00000;
        public const uint X_ATTRIBUTE_DATATYPE_INTEGER                = 0x00000000;
        public const uint X_ATTRIBUTE_DATATYPE_STRING                 = 0x00100000;
        public const uint X_ATTRIBUTE_DATATYPE_BLOB                   = 0x00200000;
        public const uint X_ATTRIBUTE_DATATYPE_NULL                   = 0x00F00000;

        // see comment above on the usage of these datatypes by xenon titles
        public const uint X_ATTRIBUTE_XENON_DATATYPE_MASK                = 0x70000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_CONTEXT             = 0x00000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_UINT32              = 0x10000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_UINT64              = 0x20000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_FLOAT64             = 0x30000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_UNICODE             = 0x40000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_FLOAT32             = 0x50000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_BINARY              = 0x60000000;
        public const uint X_ATTRIBUTE_XENON_DATATYPE_DATETIME            = 0x70000000;

        public const uint X_ATTRIBUTE_ID_MASK                         = 0x0000FFFF;

        // These are not used in the wire protocol. They were defined for use
        // by xmltosql, and are now deprecated.
        public const uint X_ATTRIBUTE_TYPE_MASK                       = 0x0F000000;
        public const uint X_ATTRIBUTE_TYPE_SESSION                    = 0x00000000;
        public const uint X_ATTRIBUTE_TYPE_PARAM                      = 0x02000000;
        public const uint X_ATTRIBUTE_TYPE_BUILTIN                    = 0x03000000;
        public const uint X_ATTRIBUTE_TYPE_CONSTANT                   = 0x05000000;

        public const uint X_ATTRIBUTE_RESERVED                        = ~( X_ATTRIBUTE_SCOPE_MASK       |
                                                                           X_ATTRIBUTE_DATATYPE_MASK    |
                                                                           X_ATTRIBUTE_XENON_DATATYPE_MASK |
                                                                           X_ATTRIBUTE_TYPE_MASK        |
                                                                           X_ATTRIBUTE_ID_MASK );
        // Xbox 1 global attributes
        public const uint X_ATTRIBUTE_XBOX1_SESSION_ID = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000001;
        public const uint X_ATTRIBUTE_XBOX1_PUB_AVAIL = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000002;
        public const uint X_ATTRIBUTE_XBOX1_PRIV_AVAIL = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000003;
        public const uint X_ATTRIBUTE_XBOX1_PUB_CURR = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000004;
        public const uint X_ATTRIBUTE_XBOX1_PRIV_CURR = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000005;
        public const uint X_ATTRIBUTE_XBOX1_DISTANCE = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000006;
        public const uint X_ATTRIBUTE_XBOX1_APPROX_DISTANCE = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000007;
        public const uint X_ATTRIBUTE_XBOX1_NUM_ATTRS = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_INTEGER
                                                            | 0x00000011;
        public const uint X_ATTRIBUTE_XBOX1_HOST_ADDR = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_BLOB
                                                            | 0x00000012;
        public const uint X_ATTRIBUTE_XBOX1_SESSION_KEY = X_ATTRIBUTE_SCOPE_GLOBAL
                                                            | X_ATTRIBUTE_TYPE_BUILTIN
                                                            | X_ATTRIBUTE_DATATYPE_BLOB
                                                            | 0x00000013;

        //
        // These are special, system defined attributes ids used for non-title
        // specific contexts and properties, and/or special query parameters
        //
        // All of these ids contain this flag, so they will not conflict with
        // title defined contexts and properties generated by xlast.
        //
        // These are also used by the 360 console.
        //
        public const uint X_ATTRIBUTE_SYSTEM_FLAG = 0x00008000;

        //
        // Game type context is either ranked or standard
        //
        public const uint X_ATTRIBUTE_GAME_TYPE = X_ATTRIBUTE_XENON_DATATYPE_CONTEXT
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xA;

        //
        // Game mode context is defined by the game
        //
        public const uint X_ATTRIBUTE_GAME_MODE = X_ATTRIBUTE_XENON_DATATYPE_CONTEXT
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xB;


        //
        // The attribute id used to pass the session id to the system FindById stored proc
        //
        public const uint X_ATTRIBUTE_SESSION_ID = X_ATTRIBUTE_XENON_DATATYPE_UINT64
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x3;

        //
        // Imported from client tree:
        //
        // Several XLAST files have these defines, and XLAST's gameconfig.h defines
        // them.  They seem to be unused now but the should not be reused lest we
        // risk breaking existing titles.
        //
        public const uint X_ATTRIBUTE_MAX_PUBLIC_SLOTS = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x4;
        public const uint X_ATTRIBUTE_MAX_PRIVATE_SLOTS = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x5;
        public const uint X_ATTRIBUTE_OPEN_PUBLIC_SLOTS = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x6;
        public const uint X_ATTRIBUTE_OPEN_PRIVATE_SLOTS = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x7;
        public const uint X_ATTRIBUTE_FILLED_PUBLIC_SLOTS = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x8;
        public const uint X_ATTRIBUTE_FILLED_PRIVATE_SLOTS = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x9;

        //
        // Client properties used to write to skill leaderboards 
        // (not consumed by match backend)
        //
        public const uint X_ATTRIBUTE_RELATIVE_SCORE = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xA;

        public const uint X_ATTRIBUTE_SESSION_TEAM = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xB;

 

        //
        // Client properties written at the session level to override TrueSkill parameters
        // (not consumed by match backend)
        //
        public const uint X_ATTRIBUTE_PLAYER_PARTIAL_PLAY_PERCENTAGE = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xC;
        public const uint X_ATTRIBUTE_PLAYER_SKILL_UPDATE_WEIGHTING_FACTOR = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xD;
        public const uint X_ATTRIBUTE_SESSION_SKILL_BETA = X_ATTRIBUTE_XENON_DATATYPE_FLOAT64
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xE;
        public const uint X_ATTRIBUTE_SESSION_SKILL_TAU = X_ATTRIBUTE_XENON_DATATYPE_FLOAT64
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0xF;
        public const uint X_ATTRIBUTE_SESSION_SKILL_DRAW_PROBABILITY =  X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x10;

        //
        // Attachment size is written to a leaderboard when the entry qualifies for
        // a gamerclip.  The rating can be retrieved via XUserEstimateRankForRating.
        // (not consumed by match backend)
        //
        public const uint X_ATTRIBUTE_ATTACHMENT_SIZE = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x11;

        //
        // Attribute passed as parameter to session findbyid list
        //
        public const uint X_ATTRIBUTE_SESSION_ID_LIST = X_ATTRIBUTE_XENON_DATATYPE_BINARY
                                                 | X_ATTRIBUTE_DATATYPE_BLOB
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x12;

        // 
        // Gamer properties
        //
        public const uint X_ATTRIBUTE_GAMER_ZONE = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x101;
        public const uint X_ATTRIBUTE_GAMER_COUNTRY = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x102;
        public const uint X_ATTRIBUTE_GAMER_LANGUAGE = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x103;
        public const uint X_ATTRIBUTE_GAMER_RATING = X_ATTRIBUTE_XENON_DATATYPE_FLOAT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x104;
        public const uint X_ATTRIBUTE_GAMER_MU = X_ATTRIBUTE_XENON_DATATYPE_FLOAT64
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x105;
        public const uint X_ATTRIBUTE_GAMER_SIGMA = X_ATTRIBUTE_XENON_DATATYPE_FLOAT64
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x106;
        public const uint X_ATTRIBUTE_GAMER_PUID = X_ATTRIBUTE_XENON_DATATYPE_UINT64
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x107;
        public const uint X_ATTRIBUTE_AFFILIATE_VALUE = X_ATTRIBUTE_XENON_DATATYPE_UINT64
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x108;
        public const uint X_ATTRIBUTE_GAMER_HOSTNAME = X_ATTRIBUTE_XENON_DATATYPE_UNICODE
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x109;
        public const uint X_ATTRIBUTE_SESSION_SCORE = X_ATTRIBUTE_XENON_DATATYPE_FLOAT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x10A;
        
        // why did platform type/lock start over at 0x201?  We don't know.  Maybe these aren't "gamer properties"?
        public const uint X_ATTRIBUTE_PLATFORM_TYPE = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x201;
        public const uint X_ATTRIBUTE_PLATFORM_LOCK = X_ATTRIBUTE_XENON_DATATYPE_UINT32
                                                 | X_ATTRIBUTE_SYSTEM_FLAG
                                                 | 0x202;


        // list of system attributes that may have weights associated with them, when used 
        // as parameters to a weighted search query.  
        public static uint[] rgWeightablePlatformAttrs = 
        {
            X_ATTRIBUTE_GAMER_ZONE,
            X_ATTRIBUTE_GAMER_COUNTRY,
            X_ATTRIBUTE_GAMER_LANGUAGE,
            X_ATTRIBUTE_GAMER_RATING,
            X_ATTRIBUTE_GAMER_MU,
            X_ATTRIBUTE_GAMER_SIGMA
        };

        // Game type context values
        public const uint X_ATTRIBUTE_GAME_TYPE_RANKED = 0;
        public const uint X_ATTRIBUTE_GAME_TYPE_STANDARD = 1;

        // maximum and default values for legacy xbox 1 titles
        public const uint XMATCH_SCHEMA_MAX_TITLE_QUERIES           = 30;
        public const uint XMATCH_SCHEMA_MAX_CONSTS                  = 50;
        public const uint XMATCH_SCHEMA_MAX_QUERY_NAME_LEN          = 32;
        public const uint XMATCH_SCHEMA_MAX_ATTR_NAME_LEN           = 28;
        public const uint XMATCH_SCHEMA_MAX_CONST_NAME_LEN          = 28;
        public const uint XMATCH_SCHEMA_MAX_PARAM_NAME_LEN          = 24;
        public const uint XMATCH_SCHEMA_MAX_QUERY_FILTERS           = 20;
        public const uint XMATCH_SCHEMA_MAX_QUERY_SORTOPS           = 20;
        public const uint XMATCH_SCHEMA_MAX_QUERY_RETURNS           = 40;

        public const uint XMATCH_SCHEMA_DEFAULT_SESSION_EXPIRATION  = 86400;
        public const uint XMATCH_SCHEMA_DEFAULT_MAX_QUERY_RESULTS   = 25;
        public const uint XMATCH_SCHEMA_DEFAULT_MAX_CONSTS          = 50;

        // default values for the social match attributes
        public const uint X_ATTRIBUTE_GAMER_ZONE_DEFAULT            = 1;
        public const uint X_ATTRIBUTE_GAMER_COUNTRY_DEFAULT         = 103;
        public const uint X_ATTRIBUTE_GAMER_LANGUAGE_DEFAULT        = 1;
        public const float X_ATTRIBUTE_GAMER_RATING_DEFAULT         = 58.72f;
        public const double X_ATTRIBUTE_GAMER_MU_DEFAULT            = 3.0d;
        public const double X_ATTRIBUTE_GAMER_SIGMA_DEFAULT         = 1.0d;

        // NOTE: Changing these values impacts both the client and the server.

        // Built-in attributes should not account against X_MATCH_MAX_TITLE_SCHEMA_ATTRS
        // this constant should be adjusted when adding new built-in schema attributes
        public const uint X_MATCH_NUM_BUILTIN_SCHEMA_ATTRS            = 12;
        public const uint X_MATCH_MAX_TITLE_SCHEMA_ATTRS              = 50;
        public const uint X_MATCH_MAX_TOTAL_SCHEMA_ATTRS              = X_MATCH_NUM_BUILTIN_SCHEMA_ATTRS + X_MATCH_MAX_TITLE_SCHEMA_ATTRS;

        public const uint X_MATCH_MAX_QUERY_PARAMS                    = X_MATCH_MAX_TOTAL_SCHEMA_ATTRS;
        public const uint X_MATCH_MAX_WEIGHTED_QUERY_PARAMS_PER_REQ   = 20; 
        public const uint X_MATCH_MAX_QUERY_RESULTS                   = 50;
        public const uint X_MATCH_MAX_ATTRIBUTE_DATA                  = 4096;
        public const uint X_MATCH_MAX_SESSION_LIST_IDS                = 100;

        // NOTES ON PARAMS:

        // X_MATCH_MAX_QUERY_PARAMS is used to express both the max number of params you can declare 
        // for a matchmaking query (in XLAST) and the max number you can pass in one request for that query

        // X_MATCH_MAX_WEIGHTED_PARAMS_PER_REQUEST is the max number of weighted params that can be passed 
        // in a single request for a single query.  This plus the number of non-weighted params will need 
        // to add up to <= X_MATCH_MAX_QUERY_PARAMS

        // both of the above constants have the complication that they include system-defined params and
        // title-defined params.  Right now, there are 12 system-defined params (NUM_BUILTIN_SCHEMA_ATTRS)
        // which we have to assume are always used.  The practical max # of title defined params is 50, 
        // because that's how many attributes they can declare (MAX_TITLE_SCHEMA_ATTRS) and you can't have 
        // a param without a corresponding attr.  12+50 = 62... we have a 

        // Values for MatchSearch.wFlags
        public const ushort XONLINE_MATCH_SEARCH_FLAG_NAT_TYPE_MASK    = 0x0003; // Contains the NAT type of the calling client, one of XONLINE_NAT_xxx
        public const ushort XONLINE_MATCH_SEARCH_FLAG_WEIGHTEDSORT     = 0x4000; // Indicates that the client wants weighted sort semantics for match search results.
        public const ushort XONLINE_MATCH_SEARCH_FLAG_NO_CACHE         = 0x8000; // Don't use the session cache for this search
        public const ushort XONLINE_MATCH_SEARCH_FLAGS_RESERVED        = unchecked((ushort)
                                                                         ~(XONLINE_MATCH_SEARCH_FLAG_NAT_TYPE_MASK |
                                                                          XONLINE_MATCH_SEARCH_FLAG_WEIGHTEDSORT |
                                                                          XONLINE_MATCH_SEARCH_FLAG_NO_CACHE));

        // Lengths of byte arrays used by Match protocols
        public const uint X_MATCH_KEY_EXCHANGE_KEY_LEN                = 16;
        public const uint X_MATCH_HOST_ADDRESS_LEN                    = 36;

        // XNKID definitions
        public const byte XNET_XNKID_MASK                             = 0xF0;    // Mask of flag bits in first byte of XNKID
        public const byte XNET_XNKID_NAT_MASK                         = 0x30;    // Mask of NAT bits for Match create in first byte of XNKID
        public const byte XNET_XNKID_DBINDEX_MASK                     = 0x0F;    // Mask of DB index the session is on for Match-created XNKIDs
        public const byte XNET_XNKID_SYSTEM_LINK                      = 0x00;    // Peer to peer system link session
        public const byte XNET_XNKID_ONLINE_PEER                      = 0x80;    // Peer to peer online session
        public const byte XNET_XNKID_ONLINE_SERVER                    = 0xC0;    // Client to server online session
        public const byte XNET_XNKID_ONLINE_TITLESERVER               = 0xE0;    // Client to title server online session

        // XNKID helper functions
        //
        //  The high four bits of xnkid are flags:
        //
        //  |0|0|x|x| = system link XNKID, xbox hosted
        //  |1|0|x|x| = online XNKID, xbox hosted
        //  |1|1|0|x| = online XNKID, pc server hosted
        //  |1|1|1|x| = online XNKID, title server (note: we should never get this as they should look like xbox hosted)
        //
        // NOTE: In a Matchmaking create call, the lower 2 bits of the high nibble are the NAT type for xbox hosted games
        // (which due to a legacy bug often get sent up looking like system link).
        //
        public static bool XNetXnKidIsSystemLink( ulong xnkid )        { return XNetXnKidGetServerType( xnkid ) == XNET_XNKID_SYSTEM_LINK; }
        public static bool XNetXnKidIsOnlinePeer( ulong xnkid )        { return XNetXnKidGetServerType( xnkid ) == XNET_XNKID_ONLINE_PEER; }
        public static bool XNetXnKidIsOnlineServer( ulong xnkid )      { return XNetXnKidGetServerType( xnkid ) == XNET_XNKID_ONLINE_SERVER; }
        public static bool XNetXnKidIsOnlineTitleServer( ulong xnkid ) { return XNetXnKidGetServerType( xnkid ) == XNET_XNKID_ONLINE_TITLESERVER; }
        public static byte XNetXnKidGetServerType( ulong xnkid )       
        { 
            if( ( xnkid & 0xC0 ) == 0xC0 )
            {
                return (byte)( xnkid & 0xE0 );
            }
            return (byte)( xnkid & 0xC0 );
        }
        public static byte XNetXnKidGetNatType( ulong xnkid ) 
        { 
            if( XNetXnKidIsSystemLink( xnkid ) ||
                XNetXnKidIsOnlinePeer( xnkid ) )
            {
                return (byte)( ( xnkid & XNET_XNKID_NAT_MASK ) >> 4 );
            }
            return 0;
        }
        public static byte XNetXnKidGetDatabaseIndex( ulong xnkid )    { return (byte)( xnkid & XNET_XNKID_DBINDEX_MASK ); }

        // NAT types
        public const byte XONLINE_NAT_UNKNOWN                         = 0;
        public const byte XONLINE_NAT_OPEN                            = 1;
        public const byte XONLINE_NAT_MODERATE                        = 2;
        public const byte XONLINE_NAT_STRICT                          = 3;

        // Default proc Ids used by legacy xbox 1 title config
        public const uint XMATCH_QUERY_TYPE_NORMAL                    = 0;
        public const uint XMATCH_QUERY_TYPE_FINDFROMID                = 1;
        public const uint XMATCH_QUERY_TYPE_AGGREGATE                 = 2;
        public const uint XMATCH_QUERY_TYPE_INVALID                   = 0xffffffff;

        // Filter operations Ids for legacy xbox 1 title config
        public const uint XMATCH_FILTEROP_EQUALS                      = 0;
        public const uint XMATCH_FILTEROP_NOTEQUALS                   = 1;
        public const uint XMATCH_FILTEROP_LESSEQUAL                   = 2;
        public const uint XMATCH_FILTEROP_GREATEREQUAL                = 3;
        public const uint XMATCH_FILTEROP_LESS                        = 4;
        public const uint XMATCH_FILTEROP_GREATER                     = 5;
        public const uint XMATCH_FILTEROP_INVALID                     = 0xffffffff;

        // Sort types for legacy xbox 1 title config
        public const uint XMATCH_SORTOP_ASCENDING                     = 0;
        public const uint XMATCH_SORTOP_DESCENDING                    = 1;
        public const uint XMATCH_SORTOP_NEAR                          = 2;
        public const uint XMATCH_SORTOP_FAR                           = 3;
        public const uint XMATCH_SORTOP_INVALID                       = 0xffffffff;

        // Return types for legacy xbox 1 title config 
        public const uint XMATCH_RETURN_TYPE_NORMAL                   = 0;
        public const uint XMATCH_RETURN_TYPE_AVERAGE                  = 1;
        public const uint XMATCH_RETURN_TYPE_SUM                      = 2;
        public const uint XMATCH_RETURN_TYPE_MINIMUM                  = 3;
        public const uint XMATCH_RETURN_TYPE_MAXIMUM                  = 4;
        public const uint XMATCH_RETURN_TYPE_COUNT                    = 5;
        public const uint XMATCH_RETURN_TYPE_INVALID                  = 0xffffffff;
        
        // Reserved title search sproc indices
        public const uint X_SSINDEX_GET_SESSION                       = 0xFFFFFFFF; // special sproc to retrieve session by session id
        public const uint X_SSINDEX_GET_SESSION_ATTRIBUTES            = 0xFFFFFFFE; // special sproc to retrieve session by session id with attributes
        public const uint X_SSINDEX_GET_SESSION_LIST                  = 0xFFFFFFFD; // special sproc to retrieve a list of sessions by id
        public const uint XMATCH_QUERYID_FLAG_SUMMARY_QUERY           = 0x80000000; // special flag on summary queries so front door can recognize them for caching
        public const uint XMATCH_QUERYID_FLAG_RESERVED                = 0x7FFF0000;

        // Some limitations on game type and mode
        public const uint XMATCH_MAX_GAMETYPE                         = 0x02;
        public const uint XMATCH_MAX_GAMEMODE                         = 0x3e;

        // Some helper functions to make code using the flags defined
        // above more readable.
        public static bool IsAttributeGlobal(uint attributeId)
        {
            return (attributeId & X_ATTRIBUTE_SCOPE_MASK)
                == X_ATTRIBUTE_SCOPE_GLOBAL;
        }

        public static bool IsAttributeTitleSpecific(uint attributeId)
        {
            return (attributeId & X_ATTRIBUTE_SCOPE_MASK)
                == X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC;
        }

        public static bool IsAttributeIdValid(uint attributeId)
        {
            return (attributeId & X_ATTRIBUTE_RESERVED) == 0;
        }

        public static bool IsAttributeTypeConst(uint attributeId)
        {
            return (attributeId & X_ATTRIBUTE_TYPE_CONSTANT) 
                == X_ATTRIBUTE_TYPE_CONSTANT;
        }

        public static bool IsSystemAttribute(uint attributeId)
        {
            return (attributeId & X_ATTRIBUTE_SYSTEM_FLAG) 
                == X_ATTRIBUTE_SYSTEM_FLAG;
        }

        public static uint AttributeDatatype(uint attributeId)
        {
            return attributeId & X_ATTRIBUTE_DATATYPE_MASK;
        }

        public static uint AttributeXenonDatatype(uint attributeId)
        {
            return attributeId & X_ATTRIBUTE_XENON_DATATYPE_MASK;
        }

        public static uint AttributeType(uint attributeId)
        {
            return attributeId & X_ATTRIBUTE_TYPE_MASK;
        }

        public static bool IsAttributeTypeSession(uint attributeId)
        {
            return AttributeType(attributeId) == X_ATTRIBUTE_TYPE_SESSION;
        }

        public static bool IsAttributeTypeParam(uint attributeId)
        {
            return AttributeType(attributeId) == X_ATTRIBUTE_TYPE_PARAM;
        }

        // this is only used by xbox 1.  360 "builtin" attributes are called "system" attributes,  
        // and you should use IsSystemAttribute() to determine if your attr is one of those.
        public static bool IsAttributeTypeBuiltin(uint attributeId)
        {
            return AttributeType(attributeId) == X_ATTRIBUTE_TYPE_BUILTIN;
        }

        public static bool IsAttributeDatatypeInt(uint attributeId)
        {
            return AttributeDatatype(attributeId) == X_ATTRIBUTE_DATATYPE_INTEGER;
        }

        public static bool IsAttributeDatatypeString(uint attributeId)
        {
            return AttributeDatatype(attributeId) == X_ATTRIBUTE_DATATYPE_STRING;
        }

        public static bool IsAttributeDatatypeBlob(uint attributeId)
        {
            return AttributeDatatype(attributeId) == X_ATTRIBUTE_DATATYPE_BLOB;
        }

        public static bool IsAttributeDatatypeNull(uint attributeId)
        {
            return AttributeDatatype(attributeId) == X_ATTRIBUTE_DATATYPE_NULL;
        }

        public static bool IsSearchSystemFindByIdQuery(uint procedureIndex)
        {
            return (procedureIndex == X_SSINDEX_GET_SESSION) || (procedureIndex == X_SSINDEX_GET_SESSION_ATTRIBUTES) || (procedureIndex == X_SSINDEX_GET_SESSION_LIST);
        }

        public static bool IsSearchSummaryQuery(uint procedureIndex)
        {
            if (IsSearchSystemFindByIdQuery(procedureIndex))
            {
                // This is a system FindById query, therefore it is not a
                // summary query
                return false;
            }
            if ((XMATCH_QUERYID_FLAG_SUMMARY_QUERY & procedureIndex) != 0)
            {
                // the XMATCH_QUERYID_FLAG_SUMMARY_QUERY flag is set,
                // so this is a summary query
                return true;
            }
            return false;
        }

        public static bool IsSummaryQuery(uint procedureIndex)
        {
            return ((XMATCH_QUERYID_FLAG_SUMMARY_QUERY & procedureIndex) != 0);
        }

        public static bool IsValidQueryProcId(uint procedureIndex)
        {
            return (0 == (XMATCH_QUERYID_FLAG_RESERVED & procedureIndex));
        }

        public static byte SearchFlagsNatType(ushort flags)
        {
            return (byte)(flags & XONLINE_MATCH_SEARCH_FLAG_NAT_TYPE_MASK);
        }

        public static bool AreSearchFlagsValid(ushort flags)
        {
            return (MatchDefs.XONLINE_MATCH_SEARCH_FLAGS_RESERVED & flags) == 0;
        }

        public static bool IsSearchFlagNoCacheSet(ushort flags)
        {
            return (MatchDefs.XONLINE_MATCH_SEARCH_FLAG_NO_CACHE & flags) != 0;
        }

        public static bool IsWeightedSortFlagSet(ushort flags)
        {
            return (MatchDefs.XONLINE_MATCH_SEARCH_FLAG_WEIGHTEDSORT & flags) != 0;
        }

        public static uint GetQueryTypeFromString(string strQueryType)
        {
            uint uiQueryType;
            switch(strQueryType.ToUpper())
            {
                default:
                    uiQueryType = XMATCH_QUERY_TYPE_INVALID;
                    break;
                case "NORMAL":
                    uiQueryType = XMATCH_QUERY_TYPE_NORMAL;
                    break;
                case "FINDFROMID":
                    uiQueryType = XMATCH_QUERY_TYPE_FINDFROMID;
                    break;
                case "AGGREGATE":
                    uiQueryType = XMATCH_QUERY_TYPE_AGGREGATE;
                    break;
            }

            return uiQueryType;
        }

        public static uint GetFilterOpFromString(string strFilterOp)
        {
            uint uiFilterOp;

            switch(strFilterOp)
            {
                default:
                    uiFilterOp = XMATCH_FILTEROP_INVALID;
                    break;
                case "==":
                    uiFilterOp = XMATCH_FILTEROP_EQUALS;
                    break;
                case "!=":
                    uiFilterOp = XMATCH_FILTEROP_NOTEQUALS;
                    break;
                case "<=":
                    uiFilterOp = XMATCH_FILTEROP_LESSEQUAL;
                    break;
                case ">=":
                    uiFilterOp = XMATCH_FILTEROP_GREATEREQUAL;
                    break;
                case "<":
                    uiFilterOp = XMATCH_FILTEROP_LESS;
                    break;
                case ">":
                    uiFilterOp = XMATCH_FILTEROP_GREATER;
                    break;
            }

            return uiFilterOp;
        }

        public static uint GetSortOpFromString(string strSortType)
        {
            uint uiSortType;

            switch(strSortType.ToUpper())
            {
                default:
                    uiSortType = XMATCH_SORTOP_INVALID;
                    break;
                case "ASCENDING":
                    uiSortType = XMATCH_SORTOP_ASCENDING;
                    break;
                case "DESCENDING":
                    uiSortType = XMATCH_SORTOP_DESCENDING;
                    break;
                case "NEAR":
                    uiSortType = XMATCH_SORTOP_NEAR;
                    break;
                case "FAR":
                    uiSortType = XMATCH_SORTOP_FAR;
                    break;
            }

            return uiSortType;
        }

        public static uint GetReturnTypeFromString(string strReturnType)
        {
            uint uiReturnType;

            switch(strReturnType.ToUpper())
            {
                default:
                    uiReturnType = XMATCH_RETURN_TYPE_INVALID;
                    break;
                case "NORMAL":
                    uiReturnType = XMATCH_RETURN_TYPE_NORMAL;
                    break;
                case "AVERAGE":
                    uiReturnType = XMATCH_RETURN_TYPE_AVERAGE;
                    break;
                case "SUM":
                    uiReturnType = XMATCH_RETURN_TYPE_SUM;
                    break;
                case "MINIMUM":
                    uiReturnType = XMATCH_RETURN_TYPE_MINIMUM;
                    break;
                case "MAXIMUM":
                    uiReturnType = XMATCH_RETURN_TYPE_MAXIMUM;
                    break;
                case "COUNT":
                    uiReturnType = XMATCH_RETURN_TYPE_COUNT;
                    break;
            }

            return uiReturnType;
        }

        public static byte[] SessionIdListToBytes(ulong []rgqwSessionIds)
        {
            return SessionIdListToBytes(rgqwSessionIds, false);
        }

        public static byte[] SessionIdListToBytes(ulong []rgqwSessionIds, bool swapBytes)
        {
            byte[] rgbSessionIds = new byte[rgqwSessionIds.Length * 8];
            BinaryWriter writer = new BinaryWriter(new MemoryStream(rgbSessionIds));

            // This is when creating the varbinary on SQL server so the conversion operators work
            // correctly
            if(swapBytes)
            {
                foreach(ulong qwSessionId in rgqwSessionIds)
                {
                    long l = IPAddress.HostToNetworkOrder((long)qwSessionId);
                    writer.Write(l);
                }
            }
            else
            {
                foreach(ulong qwSessionId in rgqwSessionIds)
                {
                    writer.Write((ulong)qwSessionId);
                }
            }

            return rgbSessionIds;
        }

        public static ulong[] SessionIdListFromBytes(byte []rgbSessionIds)
        {
            if(0 != (rgbSessionIds.Length & 0x3))
            {
                throw new ArgumentException("MatchDefs.SessionIdListFromBytes: Binary data was not a multiple of 8 bytes");
            }

            BinaryReader reader = new BinaryReader(new MemoryStream(rgbSessionIds));

            int cIds = rgbSessionIds.Length >> 3;
            ulong []rgqwSessionIds = new ulong[cIds];

            for(int i = 0; i < cIds; ++i)
            {
                rgqwSessionIds[i] = reader.ReadUInt64();
            }

            return rgqwSessionIds;
        }


        // ----------------------------------------------------------------------
        // GetGameTypeFromSessionId - retrieves the game type encoded into a session id
        // ----------------------------------------------------------------------
        public static byte GetGameTypeFromSessionId(ulong sessionId)
        {
            // the GameType is the lowest 2 bits of the third nibble from the bottom.
            // TODOTHEOM: modify either this function or GetGameType(from attributes) so that
            // they handle the fact that Xbox1 titles current set FF in the type/mode nibbles
            // of the sessionid.  (also applies to GetGameMode)
            // (xbox 1 titles don't have type/mode, so they should return 0 and 0.
            return (byte)((sessionId & 0x0300) >> 8);
        }


        // ----------------------------------------------------------------------
        // GetGameTypeFromSessionId - retrieves the game type encoded into a session id
        // ----------------------------------------------------------------------
        public static byte GetGameModeFromSessionId(ulong sessionId)
        {
            // the game mode is the 4th nibble from the bottom, plus the highest 2 bits
            // of the third nibble from the bottom.  (6 bits total)
            return (byte)((sessionId & 0xFF00) >> 10);
        }

        public static uint GetBucketIdFromSessionId(ulong qwSessionId)
        {
            byte bType = GetGameTypeFromSessionId(qwSessionId);
            byte bMode = GetGameModeFromSessionId(qwSessionId);
            byte bRRId = XNetXnKidGetDatabaseIndex(qwSessionId);
            return (uint)((bType << 16) | (bMode << 8) | bRRId);
        }
        
    }

    public class XNADDR : WireData
    {
        [WireInfo(HexString=true)]
        public uint                 ina;
        [WireInfo(HexString=true)]
        public uint                 inaOnline;
        public ushort               wPortOnline;
        [WireInfo(ArraySize=6)]
        public byte[]               abEnet;
        public SGADDR               sgaddr; // defined in sgprot.cs

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            // Allocate members the user has not set explicitly
            if( null == abEnet )
            {
                abEnet = new byte[ 6 ];
            }
            if( null == sgaddr )
            {
                sgaddr = new SGADDR();
            }

            binaryWriter.Write(ina);
            binaryWriter.Write(inaOnline);
            binaryWriter.Write(wPortOnline);
            binaryWriter.Write(abEnet);
            sgaddr.WriteStream(binaryWriter);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                ina = (uint)binaryReader.ReadInt32();
                inaOnline = (uint)binaryReader.ReadInt32();
                wPortOnline = (ushort)binaryReader.ReadInt16();
                abEnet = new byte[6];
                binaryReader.Read(abEnet, 0, 6);
                sgaddr = new SGADDR();
                sgaddr.ReadStream(binaryReader);
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_9, 
                    "Reached end of stream trying to read XNADDR", e);
            }
            return this;
        }

        public XNADDR Copy()
        {
            XNADDR xnaddr = new XNADDR();
            xnaddr.ina                  = ina;
            xnaddr.inaOnline            = inaOnline;
            xnaddr.wPortOnline          = wPortOnline;
            xnaddr.abEnet               = new byte[6];
            Array.Copy(abEnet, xnaddr.abEnet, 6);

            xnaddr.sgaddr = new SGADDR();
            xnaddr.sgaddr.inaSg         = sgaddr.inaSg;
            xnaddr.sgaddr.dwSpiSg       = sgaddr.dwSpiSg;
            xnaddr.sgaddr.qwXboxId      = sgaddr.qwXboxId; 
            xnaddr.sgaddr.abReserved    = sgaddr.abReserved;

            return xnaddr;
        }
    }

    // Structure representing a Matchmaking attribute
    //
    public class MatchAttribute : WireData
    {
        [WireInfo(HexString=true)]
        public uint             dwAttributeId;

        // Only one of the next 3 will be present, depending on the type of dwAttributeId

        [WireInfo(Serialize=false, HexString=true)]
        public ulong            qwValue;

        [WireInfo(Serialize=false)]
        public string           strValue;

        [WireInfo(Serialize=false)]
        public byte[]           rgbValue;


        public MatchAttribute()
        {
        }

        public MatchAttribute(uint dwAttributeId, ulong qwValue)
        {
            this.dwAttributeId  = dwAttributeId;
            this.qwValue        = qwValue;
        }

        public MatchAttribute(uint dwAttributeId, double d)
        {
            this.dwAttributeId = dwAttributeId;
            FromDouble(d);
        }

        public MatchAttribute(uint dwAttributeId, float f)
        {
            this.dwAttributeId = dwAttributeId;
            FromSingle(f);
        }

        public MatchAttribute(uint dwAttributeId, string strValue)
        {
            this.dwAttributeId  = dwAttributeId;
            this.strValue       = strValue;
        }

        public MatchAttribute(uint dwAttributeId, byte []rgbValue)
        {
            this.dwAttributeId  = dwAttributeId;
            this.rgbValue       = rgbValue;
        }

        public virtual uint GetSize()
        {
            switch( dwAttributeId & MatchDefs.X_ATTRIBUTE_DATATYPE_MASK )
            {
            case MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER:
                return 4 + 8;
            case MatchDefs.X_ATTRIBUTE_DATATYPE_STRING:
                return 4 + 2 + (uint) Encoding.UTF8.GetByteCount( strValue ) + 1; // Add a null terminator to the length
            case MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB:
                return 4 + 2 + (uint) rgbValue.Length;
            case MatchDefs.X_ATTRIBUTE_DATATYPE_NULL:
                return 4;
            default:
                throw new XRLException( HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID, XEvent.Id.XMATCHFD_WARN_GEN, "MatchAttribute: Unknown attribute type=" + dwAttributeId.ToString() );
            }
        }

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            try
            {
                dwAttributeId = (uint)binaryReader.ReadInt32();

                switch( dwAttributeId & MatchDefs.X_ATTRIBUTE_DATATYPE_MASK )
                {
                case MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER:
                    qwValue = binaryReader.ReadUInt64();
                    break;
                case MatchDefs.X_ATTRIBUTE_DATATYPE_STRING:
                    ushort cbString = binaryReader.ReadUInt16();
                    if( 0 == cbString )
                    {
                        throw new XRLException( HResult.XONLINE_E_MATCH_INVALID_STRING, XEvent.Id.XMATCHFD_WARN_GEN_1, "MatchAttribute: String attribute size is zero" );
                    }
                    else
                    if( MatchDefs.X_MAX_STRING_ATTRIBUTE_LEN + 1 < cbString )
                    {
                        throw new XRLException( HResult.XONLINE_E_MATCH_STRING_TOO_LONG, XEvent.Id.COMMON_CODE_46, "MatchAttribute: String attribute exceeds max length (" + cbString.ToString() + " > " + ( MatchDefs.X_MAX_STRING_ATTRIBUTE_LEN + 1 ).ToString() + ")" );
                    }
                    strValue = Encoding.UTF8.GetString( binaryReader.ReadBytes( cbString - 1 ) ); // Remove the null terminator
                    if( 0 != binaryReader.ReadByte() ) // Consume the null terminator
                    {
                        throw new XRLException( HResult.XONLINE_E_MATCH_INVALID_STRING, XEvent.Id.XMATCHFD_WARN_GEN_2, "MatchAttribute: String attribute is not null terminated" );
                    }
                    break;
                case MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB:
                    ushort cb = binaryReader.ReadUInt16();
                    if( MatchDefs.X_MAX_BLOB_ATTRIBUTE_LEN < cb )
                    {
                        throw new XRLException( HResult.XONLINE_E_MATCH_BLOB_TOO_LONG, XEvent.Id.COMMON_CODE_48, "MatchAttribute: Blob attribute exceeds max length (" + cb.ToString() + " > " + MatchDefs.X_MAX_BLOB_ATTRIBUTE_LEN.ToString() + ")" );
                    }
                    rgbValue = binaryReader.ReadBytes( cb );
                    break;
                case MatchDefs.X_ATTRIBUTE_DATATYPE_NULL:
                    break;
                default:
                    throw new XRLException( HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID, XEvent.Id.XMATCHFD_WARN_GEN_3, "MatchAttribute: Unknown attribute type=" + dwAttributeId.ToString() );
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_10, 
                    "Reached end of stream trying to read MatchAttribute", e);
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            binaryWriter.Write(dwAttributeId);

            switch( dwAttributeId & MatchDefs.X_ATTRIBUTE_DATATYPE_MASK )
            {
            case MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER:
                binaryWriter.Write( qwValue );
                break;
            case MatchDefs.X_ATTRIBUTE_DATATYPE_STRING:
                byte[] rgbString = Encoding.UTF8.GetBytes( strValue );
                binaryWriter.Write( (ushort)( rgbString.Length + 1 ) ); // Add a null terminator to the length
                if(rgbString.Length > 0)
                {
                    binaryWriter.Write( rgbString );
                }
                binaryWriter.Write( (byte) 0 ); // Add a null terminator
                break;
            case MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB:
                binaryWriter.Write( (ushort) rgbValue.Length );
                if(rgbValue.Length > 0)
                {
                    binaryWriter.Write( rgbValue );
                }
                break;
            case MatchDefs.X_ATTRIBUTE_DATATYPE_NULL:
                break;
            default:
                throw new XRLException( HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID, XEvent.Id.XMATCHFD_WARN_GEN_4, "MatchAttribute: Unknown attribute type=" + dwAttributeId.ToString() );
            }
        }

        public double ToDouble()
        {
            double d = BitConverter.Int64BitsToDouble((long)qwValue);
            return d;
        }

        public float ToSingle()
        {
            float f = BitConverter.ToSingle(BitConverter.GetBytes(qwValue), 0);
            return f;
        }

        public void FromDouble(double d)
        {
           qwValue = (ulong)BitConverter.DoubleToInt64Bits(d);
        }

        public void FromSingle(float f)
        {
            qwValue = (ulong)(uint)BitConverter.ToInt32(BitConverter.GetBytes(f), 0);
        }
    }



    public class MatchAttributeWeighted : MatchAttribute
    {
        // has all the standard attribute fields, plus a weight
        // the weight should come first off the wire -- readstream controls this ordering
        public float             fltWeight = 0;

       public MatchAttributeWeighted()
        {
        }

        public MatchAttributeWeighted(uint dwAttributeId, ulong qwValue, float fltWeight)
        {
            this.dwAttributeId  = dwAttributeId;
            this.qwValue        = qwValue;
            this.fltWeight = fltWeight;
        }

        public MatchAttributeWeighted(uint dwAttributeId, double d, float fltWeight)
        {
            this.dwAttributeId = dwAttributeId;
            FromDouble(d);
            this.fltWeight = fltWeight;
        }

        public MatchAttributeWeighted(uint dwAttributeId, float f, float fltWeight)
        {
            this.dwAttributeId = dwAttributeId;
            FromSingle(f);
            this.fltWeight = fltWeight;
        }

        public MatchAttributeWeighted(uint dwAttributeId, string strValue, float fltWeight)
        {
            this.dwAttributeId  = dwAttributeId;
            this.strValue       = strValue;
            this.fltWeight = fltWeight;
        }

        public MatchAttributeWeighted(uint dwAttributeId, byte []rgbValue, float fltWeight)
        {
            this.dwAttributeId  = dwAttributeId;
            this.rgbValue       = rgbValue;
            this.fltWeight = fltWeight;
        }

        public override uint GetSize()
        {
            switch( dwAttributeId & MatchDefs.X_ATTRIBUTE_DATATYPE_MASK )
            {
            case MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER:
                return 4 + 8 + 4; // ID + VALUE + WEIGHT
            case MatchDefs.X_ATTRIBUTE_DATATYPE_STRING:
                return 4 + 2 + (uint) Encoding.UTF8.GetByteCount( strValue ) + 1 + 4; // +1 is for null terminator to the length
            case MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB:
                return 4 + 2 + (uint) rgbValue.Length; // ID + 2? + byte array + WEIGHT
            case MatchDefs.X_ATTRIBUTE_DATATYPE_NULL:
                return 4 + 4; // ID + WEIGHT
            default:
                throw new XRLException( HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID, XEvent.Id.XMATCHFD_WARN_GEN, "MatchAttributeWeighted: Unknown attribute type=" + dwAttributeId.ToString() );
            }
        }

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            try
            {
                this.fltWeight = binaryReader.ReadSingle();
                base.ReadStream(binaryReader);
                return this;
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_10, 
                    "Reached end of stream trying to read MatchAttributeWeighted", e);
            }
        }
        
        public override void WriteStream( BinaryWriter binaryWriter )
        {
            // noone should ever writestream on a weighted attribute
            System.Diagnostics.Debug.Assert(false,"WriteStream not supported for MatchAttributeWeighted.  If you're sending data back to the client, use a non-weighted attr instead.");
            throw new NotSupportedException("WriteStream not supported for MatchAttributeWeighted.  If you're sending data back to the client, use a non-weighted attr instead.");
        }

        public float GetWeight()
        {
            return fltWeight;
        }
    }



    // Structure representing a Matchmaking search result
    //  maps to XMATCH_SEARCHRESULT in xonline.x
    //
    // NOTE: SearchResult's are padded to a 4-byte boundary
    //
    public class SearchResult : WireData
    {
        public uint             dwResultLength;
        [WireInfo(HexString=true)]
        public ulong            qwSessionId;
        public XNADDR           HostAddress;

        [WireInfo(ArraySize=16)]
        public byte[]           rgbKeyExchangeKey;

        public uint             dwPublicOpen;
        public uint             dwPrivateOpen;
        public uint             dwPublicFilled;
        public uint             dwPrivateFilled;
        public uint             dwNumAttributes;

        [WireInfo(SizeParam="dwNumAttributes")]
        public uint[]           rgdwAttrOffsets;

        [WireInfo(SizeParam="dwNumAttributes")]
        public MatchAttribute[] rgAttributes;

        [WireInfo(Serialize=false)]
        public uint             rgbPaddingLen;
        public byte[]           rgbPadding;

        [WireInfo(Serialize=false)]
        public int              attributeIndexOfAffiliateValue = -1;

        [WireInfo(Serialize=false)]
        public int           attributeIndexOfScore = -1;

        [WireInfo(Serialize=false)]
        public int              attributeIndexOfMu = -1;

        [WireInfo(Serialize=false)]
        public int              attributeIndexOfSigma = -1;

        [WireInfo(Serialize=false)]
        public double           drawProbability = -1;

        public void SetDrawProbability(double searcherMu, double searcherSigma)
        {
            if (-1 != attributeIndexOfMu && -1 != attributeIndexOfSigma)
            {
                double resultMu = rgAttributes[attributeIndexOfMu].ToDouble();
                double resultSimga = rgAttributes[attributeIndexOfSigma].ToDouble();

                drawProbability = Math.Exp(
                    -( 
                        ((resultMu - searcherMu) * (resultMu - searcherMu)) +
                        (resultSimga * resultSimga) +
                        (searcherSigma * searcherSigma)
                    ));
            }
        }

        public uint GetBaseSize() { return 84; }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(dwResultLength);
            binaryWriter.Write(qwSessionId);
            HostAddress.WriteStream(binaryWriter);
            binaryWriter.Write(rgbKeyExchangeKey);
            binaryWriter.Write(dwPublicOpen);
            binaryWriter.Write(dwPrivateOpen);
            binaryWriter.Write(dwPublicFilled);
            binaryWriter.Write(dwPrivateFilled);
            binaryWriter.Write(dwNumAttributes);
            for (int i = 0; i < dwNumAttributes; ++i)
            {
                binaryWriter.Write(rgdwAttrOffsets[i]);
            }
            for (int i = 0; i < dwNumAttributes; ++i)
            {
                rgAttributes[i].WriteStream(binaryWriter);
            }
            if (rgbPadding != null)
            {
                binaryWriter.Write(rgbPadding);
            }
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            int padding;
            int start = (int)binaryReader.BaseStream.Position;

            // Invoke WireData functionality
            base.ReadStream(binaryReader);

            // Spool any padding bytes
            padding = (int)dwResultLength - ((int)binaryReader.BaseStream.Position - start);
            binaryReader.ReadBytes(padding);

            return this;
        }
    }

    public class SearchResultDrawProbabilityComparer : IComparer
    {
        public int Compare(object lhs, object rhs)
        {
            SearchResult lhsSearchResult = lhs as SearchResult;
            SearchResult rhsSearchResult = rhs as SearchResult;

            if (null == lhsSearchResult || null == rhsSearchResult)
            {
                throw new ApplicationException("SearchResultDrawProbabilityComparer comparer got a non SearchResult object.");
            }

            // Results should be ordered descending so reverse the usual semantics
            double compare = rhsSearchResult.drawProbability - lhsSearchResult.drawProbability;
            int result = 0;

            if (compare < 0.0)
                result = -1;
            else if (compare > 0.0)
                result = 1;
            else
                result = 0;

            return(result);
        }
    }   // class SearchResultDrawProbabilityComparer


    public class SearchResultScoreComparer : IComparer
    {
        public int Compare(object lhs, object rhs)
        {
            SearchResult lhsSearchResult = lhs as SearchResult;
            SearchResult rhsSearchResult = rhs as SearchResult;

            if (null == lhsSearchResult || null == rhsSearchResult)
            {
                throw new ApplicationException("SearchResultScoreComparer comparer got a non SearchResult object.");
            }

            // Results should be ordered ascending (lower score is better)
            float compare = lhsSearchResult.rgAttributes[lhsSearchResult.attributeIndexOfScore].ToSingle() - rhsSearchResult.rgAttributes[rhsSearchResult.attributeIndexOfScore].ToSingle();
            int result = 0;

            if (compare < 0.0)
                result = -1;
            else if (compare > 0.0)
                result = 1;
            else
                result = 0;

            return(result);
        }
    }   // class SearchResultScoreComparer



    // Structure representing a request to create or update a session
    //  maps to XMATCH_SESSION in xonline.x
    //
    public class MatchSessionMsg : XRLObject2
    {
        public uint             dwMessageLength;
        [WireInfo(HexString=true)]
        public ulong            qwSessionId;
        [WireInfo(HexString=true)]
        public uint             dwTitleId;
        public XNADDR           HostAddress;
        public uint             dwPublicOpen;
        public uint             dwPrivateOpen;
        public uint             dwPublicFilled;
        public uint             dwPrivateFilled;
        public uint             dwNumAttributes;

        [WireInfo(SizeParam="dwNumAttributes")]
        public uint[]           rgdwAttrOffsets;

        [WireInfo(SizeParam="dwNumAttributes")]
        public MatchAttribute[] rgAttributes;

        public override string Xrl { get { return "/xmatch/xmatchhost.srf"; } }
        public uint GetBaseSize() { return 72; }

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            try
            {
                // Log the input buffer
                Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, "WireData Binary Input: ");
                Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, LogBinary(binaryReader.BaseStream));

                dwMessageLength     = binaryReader.ReadUInt32();
                qwSessionId         = binaryReader.ReadUInt64();
                dwTitleId           = binaryReader.ReadUInt32();
                HostAddress         = new XNADDR();
                HostAddress.ReadStream(binaryReader);
                dwPublicOpen        = binaryReader.ReadUInt32();
                dwPrivateOpen       = binaryReader.ReadUInt32();
                dwPublicFilled      = binaryReader.ReadUInt32();
                dwPrivateFilled     = binaryReader.ReadUInt32();
                dwNumAttributes     = binaryReader.ReadUInt32();
                if(dwNumAttributes > MatchDefs.X_MATCH_MAX_TOTAL_SCHEMA_ATTRS)
                {
                    throw new XRLException(
                            HResult.XONLINE_E_MATCH_TOO_MANY_ATTR,
                            XEvent.Id.MATCH_HACK_SESSION_NUM_ATTR,
                            String.Format("MatchSessionMsg.ReadStream: too many attributes {0} > {1}",
                                dwNumAttributes,
                                MatchDefs.X_MATCH_MAX_TOTAL_SCHEMA_ATTRS)
                            );
                }

                rgdwAttrOffsets = new uint[dwNumAttributes];
                for (int i = 0; i < dwNumAttributes; ++i)
                {
                    rgdwAttrOffsets[i] = (uint)binaryReader.ReadInt32();
                }
                rgAttributes = new MatchAttribute[dwNumAttributes];
                for (int i = 0; i < dwNumAttributes; ++i)
                {
                    rgAttributes[i] = new MatchAttribute();
                    rgAttributes[i].ReadStream(binaryReader);
                }

                // Log text representation
                Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, "WireData Text Input: ");
                Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, LogText());

            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.MATCH_HACK_SESSION_END_OF_STREAM, 
                    "Reached end of stream trying to read MatchSessionMsg", e);
            }
            return this;
        }
    }

    // Structure representing a reply to a session creation request
    //  maps to XMATCH_SESSION_INFO in xonline.x
    //
    public class MatchSessionReply : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong            qwSessionId;

        [WireInfo(ArraySize=16)]
        public byte[]           rgbKeyExchangeKey;

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(qwSessionId);
            binaryWriter.Write(rgbKeyExchangeKey);
        }
    }

    // Structure representing a request to delete a session
    //  maps to XMATCH_SESSION_DELETE in xonline.x
    // 
    public class MatchDeleteMsg : XRLObject2
    {
        public uint             dwMessageLength;
        [WireInfo(HexString=true)]
        public ulong            qwSessionId;
        [WireInfo(HexString=true)]
        public uint             dwTitleId;

        public override string Xrl { get { return "/xmatch/xmatchhostdelete.srf"; } }
        public uint GetBaseSize() { return 16; }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                // Log the input buffer
                Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, "WireData Binary Input: ");
                Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, LogBinary(binaryReader.BaseStream));

                dwMessageLength = (uint)binaryReader.ReadInt32();
                qwSessionId = (ulong)binaryReader.ReadInt64();
                dwTitleId = (uint)binaryReader.ReadInt32();

                // Log text representation
                Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, "WireData Text Input: ");
                Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, LogText());
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_12, 
                    "Reached end of stream trying to read MatchDeleteMsg", e);
            }
            return this;
        }
    }

    // Structure representing a search request
    //  maps to XMATCH_SEARCH in xonline.x
    //
    public class MatchSearchMsg : XRLObject2
    {
        public uint             dwMessageLength;
        [WireInfo(HexString=true)]
        public uint             dwTitleId;
        [WireInfo(HexString=true)]
        public uint             dwProcedureIndex;
        public XNADDR           ClientAddress;
        public ushort           wNumUsers;
        [WireInfo(HexString=true)]
        public ushort           wFlags;
        public uint             dwNumParameters;

        [WireInfo(SizeParam="dwNumParameters")]
        public uint[]           rgdwParamOffsets;

        [WireInfo(SizeParam="dwNumParameters")]
        public MatchAttribute[] rgParameters;

        // Spring09 introduces the notion of per-parameter weighting, to allow titles
        // more control over search result ordering.
        [WireInfo(MinSchemaVersion="5.3")]
        public uint             dwNumWeightedParameters = 0;

        [WireInfo(SizeParam="dwNumWeightedParameters", MinSchemaVersion="5.3")]
        public uint[]           rgdwWeightedParamOffsets;

        [WireInfo(SizeParam="dwNumWeightedParameters", MinSchemaVersion="5.3")]
        public MatchAttributeWeighted[] rgWeightedParameters;


        public override string Xrl { get { return "/xmatch/xmatchclient.srf"; } }
        public uint GetBaseSize() { return 56; }

        // MatchSearchMsg uses the default WireData readstream implementation.
    }

    // Structure representing a search reply
    //  maps to XMATCH_SEARCHRESULT_HEADER in xonline.x
    //
    public class MatchSearchReply : XRLObject2
    {
        public uint             dwMessageLength;
        public ushort           wNumSearchResults;
        [WireInfo(HexString=true)]
        public ushort           wFlags;             // Unused, always zero
        [WireInfo(HexString=true)]
        public uint             dwLoggingThreshold; // Unused, always zero

        [WireInfo(SizeParam="wNumSearchResults")]
        public SearchResult[]   rgResults;
        public uint GetBaseSize() { return 12; }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(dwMessageLength);
            binaryWriter.Write(wNumSearchResults);
            binaryWriter.Write(wFlags);
            binaryWriter.Write(dwLoggingThreshold);
            for (int i = 0; i < wNumSearchResults; ++i)
            {
                rgResults[i].WriteStream(binaryWriter);
            }
        }

    }

    // Structure representing a request to split an existing session
    //  maps to XMATCH_SPLIT in xonline.x
    //
    public class MatchSplitMsg : XRLObject2
    {
        public uint             dwMessageLength;
        [WireInfo(HexString=true)]
        public ulong            qwSessionId;
        [WireInfo(HexString=true)]
        public ulong            qwSplitSessionId;
        [WireInfo(HexString=true)]
        public uint             dwTitleId;
        public XNADDR           HostAddress;
        public uint             dwNumAttributes;

        [WireInfo(SizeParam="dwNumAttributes")]
        public uint[]           rgdwAttrOffsets;

        [WireInfo(SizeParam="dwNumAttributes")]
        public MatchAttribute[] rgAttributes;

        public override string Xrl { get { return "/xmatch/xmatchsplit.ashx"; } }
        public uint GetBaseSize() { return 64; }

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            try
            {
                // Log the input buffer
                Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, "WireData Binary Input: ");
                Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, LogBinary(binaryReader.BaseStream));

                dwMessageLength     = binaryReader.ReadUInt32();
                qwSessionId         = binaryReader.ReadUInt64();
                qwSplitSessionId    = binaryReader.ReadUInt64();
                dwTitleId           = binaryReader.ReadUInt32();
                HostAddress         = new XNADDR();
                HostAddress.ReadStream(binaryReader);
                dwNumAttributes     = binaryReader.ReadUInt32();
                if(dwNumAttributes > MatchDefs.X_MATCH_MAX_TOTAL_SCHEMA_ATTRS)
                {
                    throw new XRLException(
                            HResult.XONLINE_E_MATCH_TOO_MANY_ATTR,
                            XEvent.Id.MATCH_HACK_SPLIT_NUM_ATTR,
                            String.Format("MatchSplitMsg.ReadStream: too many attributes {0} > {1}",
                                dwNumAttributes,
                                MatchDefs.X_MATCH_MAX_TOTAL_SCHEMA_ATTRS)
                            );
                }

                rgdwAttrOffsets = new uint[dwNumAttributes];
                for (int i = 0; i < dwNumAttributes; ++i)
                {
                    rgdwAttrOffsets[i] = (uint)binaryReader.ReadInt32();
                }
                rgAttributes = new MatchAttribute[dwNumAttributes];
                for (int i = 0; i < dwNumAttributes; ++i)
                {
                    rgAttributes[i] = new MatchAttribute();
                    rgAttributes[i].ReadStream(binaryReader);
                }

                // Log text representation
                Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, "WireData Text Input: ");
                Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, LogText());
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.MATCH_HACK_SPLIT_END_OF_STREAM, 
                    "Reached end of stream trying to read MatchSplitMsg", e);
            }
            return this;
        }
    }

    // Structure representing a reply to a split a session
    //  maps to a single XMATCH_SEARCHSESSION in xonline.x
    //
    //  We need to work with XRLObject2 but don't want 
    //  SearchResult to extend XRLObject2. On the wire
    //  this is just a search result object.
    //
    public class MatchSplitReply : XRLObject2
    {
        public SearchResult     Session;

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // Don't write the padding in a split reply since there is only
            // one result and the client doesn't want padding if there's only
            // one and not an array.
            Session.rgbPadding = null;

            Session.WriteStream(binaryWriter);
        }
    }
} // namespace xonline.common.protocol
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\profileprot.cs ===
/*==========================================================================
 *
 *  xqrywire.cs -- This module defines the wire protocol for query service apis
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

using xonline.common.service;

namespace xonline.common.protocol 
{
    public class ProfileProperty : WireData
    {
        public ushort Id;
        public ushort ValueLen;
        
        [WireInfo(SizeParam="ValueLen")]        
        public byte[] Value;
    }
    
    public class ProfileReadRequest : XRLObject2
    {
        public uint titleId;
        public ulong userId;
        
        //[WireInfo(Max=XOn.XONLINE_MAX_PROFILE_PROPERTY_COUNT)]
        public ushort propertyCount;
        
        [WireInfo(SizeParam="propertyCount")]        
        public ushort[] propertyIds;
    }
    
    
    public class ProfileReadResponse : XRLObject2
    {
        //[WireInfo(Max=XOn.XONLINE_MAX_PROFILE_PROPERTY_COUNT)]
        public ushort propertyCount;
        
        [WireInfo(SizeParam="propertyCount")]        
        public ProfileProperty[] properties;
    
    }    
    
    
    public class ProfileWriteRequest : XRLObject2
    {
        public uint titleId;
        public ulong userId;
        
        //[WireInfo(Max=XOn.XONLINE_MAX_PROFILE_PROPERTY_COUNT)]
        public ushort propertyCount;
        
        [WireInfo(SizeParam="propertyCount")]        
        public ProfileProperty[] properties;
        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\presenceprot.cs ===
// 
// PresenceProt.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Presence Service Integration
// Xbox Online Service
// 
// Author: phansen, masonb
//

using System.IO;
using System.Text;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.config;

[assembly: XomAreaDefinition(XomAreaName.PresenceProxy)]


namespace xonline.common.protocol 
{
    //
    // Enum of message types. 
    //  Maps to Q_MSG_TYPES in xonline.x
    //  
    public enum Q_MSG_TYPES
    {
        //
        // Incoming messages
        //
        QMSG_MIN_REQ_TYPE                  =  0,
        QMSG_HELLO                         =  0,
        QMSG_USER_INFO                     =  1,
        QMSG_ADD                           =  2,
        QMSG_DELETE                        =  3,
        QMSG_DELETE_MATCHES                =  4,
        QMSG_DEAD_XBOX                     =  5,
        QMSG_DEAD_SG                       =  6,
        QMSG_LIST                          =  7,
        QMSG_DEQUEUE                       =  8,
        QMSG_DEAD_USER                     =  9,
        QMSG_WEB_USER_INFO                 = 10,
        QMSG_WEB_PRESENCE                  = 11,
        QMSG_WEB_LIST                      = 12,
        QMSG_ENUM_MESSAGES                 = 13,
        QMSG_MESSAGE_SUMMARY               = 14,
        QMSG_MESSAGE_DETAILS               = 15,
        QMSG_DELETE_MESSAGE                = 16,
        QMSG_SEND_MESSAGE                  = 17,
        QMSG_REVOKE_MESSAGE                = 18,
        QMSG_DELETE_TITLE                  = 19,
        QMSG_ENUM_TITLES                   = 20,
        QMSG_MESSAGE_FLAGS                 = 21,
        QMSG_ENUM_SYSTEM_MESSAGES          = 22,
        QMSG_SYSTEM_MESSAGE_DETAILS        = 23,
        QMSG_DELETE_SYSTEM_MESSAGE         = 24,
        QMSG_SEND_SYSTEM_MESSAGE           = 25,
        QMSG_REVOKE_MESSAGE_EX             = 26,
        QMSG_ENUM_MESSAGES_2               = 27,
        QMSG_MESSAGE_SUMMARY_2             = 28,
        QMSG_MAX_REQ_TYPE                  = 28,

        //
        // Outgoing messages
        //
        QMSG_MIN_REPLY_TYPE                = 100,
        QMSG_LIST_REPLY                    = 100,
        QMSG_WEB_LIST_REPLY                = 101,
        QMSG_ENUM_MESSAGES_REPLY           = 102,
        QMSG_MESSAGE_SUMMARY_REPLY         = 103,
        QMSG_MESSAGE_DETAILS_REPLY         = 104,
        QMSG_DELETE_MESSAGE_REPLY          = 105,
        QMSG_SEND_MESSAGE_REPLY            = 106,
        QMSG_REVOKE_MESSAGE_REPLY          = 107,
        QMSG_DELETE_TITLE_REPLY            = 108,
        QMSG_ENUM_TITLES_REPLY             = 109,
        QMSG_MESSAGE_FLAGS_REPLY           = 110,
        QMSG_ENUM_SYSTEM_MESSAGES_REPLY    = 111,
        QMSG_SYSTEM_MESSAGE_DETAILS_REPLY  = 112,
        QMSG_DELETE_SYSTEM_MESSAGE_REPLY   = 113,
        QMSG_SEND_SYSTEM_MESSAGE_REPLY     = 114,
        QMSG_ENUM_MESSAGES_2_REPLY         = 115,
        QMSG_MESSAGE_SUMMARY_2_REPLY       = 116,
        QMSG_LIST_REPLY_2                  = 117,
        QMSG_MAX_REPLY_TYPE                = 117
    };       


    public enum P_MSG_TYPES
    {
        //
        // Incoming messages
        //
        PMSG_MIN_REQ_TYPE                  = 1000,
        PMSG_HELLO                         = 1000,
        PMSG_ALIVE                         = 1001,
        PMSG_SYNC                          = 1002,
        PMSG_REFRESH                       = 1003,
        PMSG_ADD                           = 1004,
        PMSG_DELETE                        = 1005,
        PMSG_ACCEPT                        = 1006,
        PMSG_REJECT                        = 1007,
        //Mute is the right name which is used internally. Adding PMSG_MUTE. Leaving PMSG_BLOCK so that if we do a search, we still find it.
        //PMSG_BLOCK                         = 1008, 
        PMSG_MUTE                          = 1008,
        //UnMute is the right name which is used internally. Adding PMSG_UNMUTE. Leaving PMSG_UNBLOCK so that if we do a search, we still find it.
        //PMSG_UNBLOCK                       = 1009, 
        PMSG_UNMUTE                        = 1009,
        PMSG_INVITE                        = 1010,
        PMSG_CANCEL                        = 1011,
        PMSG_INVITE_ANSWER                 = 1012,
        PMSG_NICKNAME                      = 1013,
        PMSG_STATE                         = 1014,
        PMSG_DEAD_XBOX                     = 1015,
        PMSG_DEAD_SG                       = 1016,
        PMSG_ANNOUNCE                      = 1017,
        PMSG_SUBSCRIBED                    = 1018,
        PMSG_UNSUBSCRIBE                   = 1019,
        PMSG_ADDED                         = 1020,
        PMSG_ACCEPTED                      = 1021,
        PMSG_REMOVED                       = 1022,
        PMSG_KICK                          = 1023,
        PMSG_DEAD_USER                     = 1024,
        PMSG_ALIVE_2                       = 1025,
        PMSG_WEB_FRIENDS                   = 1026,
        PMSG_WEB_ALIVE                     = 1027,
        PMSG_WEB_ANNOUNCE                  = 1028,
        PMSG_WEB_SUBSCRIBED                = 1029,
        PMSG_WEB_UNSUBSCRIBE               = 1030,
        PMSG_PEER_SESSION                  = 1031,
        PMSG_TEAM_LIST_TEAMS               = 1032,
        PMSG_TEAM_LIST_MEMBERS             = 1033,
        PMSG_TEAM_CREATE                   = 1034,
        PMSG_TEAM_DELETE                   = 1035,
        PMSG_TEAM_REMOVE                   = 1036,
        PMSG_TEAM_MANAGE_TEAM              = 1037,
        PMSG_TEAM_MANAGE_MEMBER            = 1038,
        PMSG_TEAM_RECRUIT                  = 1039,
        PMSG_TEAM_JOIN                     = 1040,
        PMSG_TEAM_GET_TICKET               = 1041,
        PMSG_PEER_SUBSCRIBE                = 1042,
        PMSG_PEER_UNSUBSCRIBE              = 1043,
        PMSG_WATCH_START                   = 1044,
        PMSG_WATCH_STOP                    = 1045,
        PMSG_ADD_2                         = 1046,
        PMSG_INVITE_2                      = 1047,
        PMSG_ALIVE_INTERNAL                = 1048,
        PMSG_STATE_2                       = 1049,        
        PMSG_GET_STATE                     = 1050,
        PMSG_TEAM_CREATE_XE                = 1051,
        PMSG_TEAM_MANAGE_TEAM_XE           = 1052,
        PMSG_ADD_AFFILIATES                = 1053,
        PMSG_IS_AFFILIATE                  = 1054,
        PMSG_QUERY_AFFILIATES              = 1055,
        PMSG_GET_PRESENCE_INFO             = 1056,
        PMSG_PRESENCE_INFO_REPLY            =1057,
        PMSG_INVALIDATE_USER               = 1058,
        PMSG_FIND_USER                     = 1059,
        PMSG_CHECK_TITLE_MESSAGES          = 1060,
        PMSG_TEAM_LIST_USER_TEAMS          = 1061,
        PMSG_USER_PRE_MIGRATION            = 1062,
        PMSG_USER_FULL_MIGRATION           = 1063,
        PMSG_LOGON_CHECK                   = 1064,
        PMSG_FIND_USERS                    = 1065,
        PMSG_ALIVE_INTERNAL_2              = 1066,
        PMSG_PEER_SUBSCRIBE_EX             = 1067,
        PMSG_PURGE_USER                    = 1068,
        PMSG_GET_FRIENDS_LIST              = 1069,
        PMSG_CONTINUATION                  = 1070,
        PMSG_CONNECTION_HEALTH             = 1071,
        PMSG_ADD_USERS_TO_NEVERLIST        = 1072,
        PMSG_REMOVE_USERS_FROM_NEVERLIST   = 1073,
        PMSG_CAN_SEND_MESSAGE              = 1074,
        PMSG_WEB_ALIVE2                    = 1075,
        PMSG_GET_FRIENDS_NO_PRESENCE       = 1076,
        PMSG_GET_FRIENDS_LIMITED_PRESENCE  = 1077,
        PMSG_TITLE_CHANGE                  = 1078,
        PMSG_MAX_REQ_TYPE                  = 1078,
        


        //
        // Outgoing messages
        //
        PMSG_MIN_REPLY_TYPE                = 1101,
        PMSG_ALIVE_REPLY                   = 1101,
        PMSG_SYNC_REPLY                    = 1102,
        PMSG_WEB_FRIENDS_REPLY             = 1103,
        PMSG_WEB_ALIVE_REPLY               = 1104,
        PMSG_PEER_SESSION_REPLY            = 1105,
        PMSG_INVITE_REPLY                  = 1106,
        PMSG_TEAM_LIST_TEAMS_REPLY         = 1107,
        PMSG_TEAM_LIST_MEMBERS_REPLY       = 1108,
        PMSG_TEAM_CREATE_REPLY             = 1109,
        PMSG_TEAM_DELETE_REPLY             = 1110,
        PMSG_TEAM_REMOVE_REPLY             = 1111,
        PMSG_TEAM_MANAGE_TEAM_REPLY        = 1112,
        PMSG_TEAM_MANAGE_MEMBER_REPLY      = 1113,
        PMSG_TEAM_RECRUIT_REPLY            = 1114,
        PMSG_TEAM_JOIN_REPLY               = 1115,
        PMSG_TEAM_GET_TICKET_REPLY         = 1116,
        PMSG_PEER_SUBSCRIBE_REPLY          = 1117,
        PMSG_PEER_UNSUBSCRIBE_REPLY        = 1118,
        PMSG_GET_STATE_REPLY               = 1119,
        PMSG_IS_AFFILIATE_REPLY            = 1120,
        PMSG_QUERY_AFFILIATES_REPLY        = 1121,
        PMSG_FIND_USER_REPLY               = 1122,
        PMSG_CHECK_TITLE_MESSAGES_REPLY    = 1123,
        PMSG_TEAM_LIST_USER_TEAMS_REPLY    = 1124,
        PMSG_LOGON_CHECK_REPLY             = 1125,
        PMSG_FIND_USERS_REPLY              = 1126,
        PMSG_PEER_SUBSCRIBE_EX_REPLY       = 1127,
        PMSG_PURGE_USER_REPLY              = 1128,
        PMSG_GET_FRIENDS_LIST_REPLY        = 1129,
        PMSG_CONNECTION_HEALTH_REPLY       = 1130,
        PMSG_CAN_SEND_MESSAGE_REPLY        = 1131,
        PMSG_GET_FRIENDS_NO_PRESENCE_REPLY = 1132,
        PMSG_GET_FRIENDS_LIMITED_PRESENCE_REPLY = 1133,
        PMSG_MAX_REPLY_TYPE                = 1133
    };

    public enum P_QUEUE_TYPES : ushort
    {
        //
        // Outgoing queued response items
        //
        PQUEUE_BUDDY_REQ            = 0,
        PQUEUE_LIST_CHANGE          = 1,
        PQUEUE_PRESENCE             = 2,
        PQUEUE_INVITE               = 3,
        PQUEUE_INVITE_ANSWER        = 4,
        PQUEUE_TRANSIENT_MSGS       = 5,
        PQUEUE_PEER_PRESENCE        = 6,
        PQUEUE_PRESENCE_2           = 7,
       
        PQUEUE_NUM_TYPES            = 8
    };


    public class PresDefs
    {
        public const int CURRENT_XPPROTOCOL_VER = 0x00010000;
        
        public const int XONLINE_GAMERTAG_SIZE             = 16;
        public const int XONLINE_PRESENCE_LOCALE_SIZE      = 40;
        public const int MAX_TITLE_STATE_BYTES             = 32;

        // public system set state flags
        public const uint P_STATE_FLAG_NONE                = 0;
        public const uint P_STATE_FLAG_ONLINE              = 0x00000001; // Set if online
        public const uint P_STATE_FLAG_PLAYING             = 0x00000002; // Set if playing a game
        public const uint P_STATE_FLAG_CLOAKED             = 0x00000004; // Set to fake being offline
        public const uint P_STATE_FLAG_VOICE               = 0x00000008; // Set if supports voice
        public const uint P_STATE_FLAG_JOINABLE            = 0x00000010; // Set if session is joinable
        public const uint P_STATE_MASK_GUESTS              = 0x00000060;
        public const uint P_STATE_FLAG_RESERVED0           = 0x00000080;
        public const uint P_STATE_MASK_JOINABLE_FRIENDS_ONLY = 0x00000100;
        public const uint P_STATE_MASK_PARTY_JOINABLE = 0x00000200;
        public const uint P_STATE_MASK_PARTY_JOINABLE_FRIENDS_ONLY = 0x00000400;
        public const uint P_STATE_MASK_PARTY_PLAYING = 0x00000800;

        // reuse of client flags for server-specific flags
        public const uint P_STATE_MASK_CLIENTFLAGS   = 0xFC000000;
        public const uint P_STATE_MASK_TITLEID_CHANGED = 0x80000000;
        public const uint P_STATE_MASK_TITLEDATA_CHANGED = 0x40000000;
        public const uint P_STATE_MASK_SESSIONID_CHANGED = 0x20000000;
        public const uint P_STATE_MASK_RICHPRES_CHANGED = 0x10000000;

        // private user set state enumeration
        public const uint P_STATE_ENUM_ONLINE              = 0x00000000;
        public const uint P_STATE_ENUM_AWAY                = 0x00010000;
        public const uint P_STATE_ENUM_BUSY                = 0x00020000;
        public const uint P_STATE_ENUM_WEB                 = 0x00030000;
        public const uint P_STATE_ENUM_RESERVED2           = 0x00040000;
        public const uint P_STATE_ENUM_RESERVED3           = 0x00050000;
        public const uint P_STATE_ENUM_RESERVED4           = 0x00060000;
        public const uint P_STATE_MASK_USER_STATE          = 0x000F0000;

        // console types
        public const uint P_STATE_MASK_CONSOLE_TYPE        = 0x00007000;
        public const uint P_STATE_ENUM_CONSOLE_XBOX        = 0x00000000;
        public const uint P_STATE_ENUM_CONSOLE_XENON       = 0x00001000;
        public const uint P_STATE_ENUM_CONSOLE_WINPC       = 0x00002000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD1       = 0x00003000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD2       = 0x00004000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD3       = 0x00005000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD4       = 0x00006000;
        public const uint P_STATE_ENUM_CONSOLE_RSVD5       = 0x00007000;

        // messaging/notification state flags
        public const uint P_STATE_FLAG_VOICE_TV            = 0x02000000;
        public const uint P_STATE_FLAG_SENTINVITE          = 0x04000000;
        public const uint P_STATE_FLAG_RECEIVEDINVITE      = 0x08000000;
        public const uint P_STATE_FLAG_INVITEACCEPTED      = 0x10000000;
        public const uint P_STATE_FLAG_INVITEREJECTED      = 0x20000000;
        public const uint P_STATE_FLAG_SENTREQUEST         = 0x40000000;
        public const uint P_STATE_FLAG_RECEIVEDREQUEST     = 0x80000000;

        // User buddy status
        public const uint P_BUDDY_STATUS_OK                = 0; // Mutually accepted buddy
        public const uint P_BUDDY_STATUS_PENDING           = 1; // Buddy request pending acceptance
        public const uint P_BUDDY_STATUS_REQUEST           = 2; // Buddy request to accept or reject
 
        // Invite answers
        public const ushort PINVITE_REPLY_NO               = 0;
        public const ushort PINVITE_REPLY_YES              = 1;
        public const ushort PINVITE_REPLY_NEVER            = 2;

        // Affiliate flags for valid list types
        public const uint X_AFFILIATE_ENCOUNTERED_INDEX         = 0;
        public const uint X_AFFILIATE_COMPLETED_GAME_INDEX      = 1;
        public const uint X_AFFILIATE_POSITIVE_FEEDBACK_INDEX   = 2;
        public const uint X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX   = 3;
        public const uint X_AFFILIATE_AVOIDING_ME_INDEX         = 4;
        public const uint X_AFFILIATE_FAVORITES_INDEX           = 5;
        // Affiliate flags for other types
        public const uint X_AFFILIATE_FRIEND_INDEX              = 16;
        public const uint X_AFFILIATE_BLOCK_INDEX               = 17;
        public const uint X_AFFILIATE_MUTE_INDEX                = 18;

        public const uint X_AFFILIATE_INDEX_ERROR = 0xFFFFFFFF;

        public const uint NUM_STORED_AFFILIATE_LISTS            = 6;

        public static int MAX_AFFILIATES(uint dwListType)
        {
            switch(dwListType)
            {
                case X_AFFILIATE_ENCOUNTERED_INDEX:
                    return Config.GetIntSetting(Setting.presence_AffiliatesEncounteredListSize);
                case X_AFFILIATE_COMPLETED_GAME_INDEX:
                    return Config.GetIntSetting(Setting.presence_AffiliatesCompletedGameListSize);
                case X_AFFILIATE_POSITIVE_FEEDBACK_INDEX:
                    return Config.GetIntSetting(Setting.presence_AffiliatesPositiveFeedbackListSize);
                case X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX:
                    return Config.GetIntSetting(Setting.presence_AffiliatesNegativeFeedbackListSize);
                case X_AFFILIATE_AVOIDING_ME_INDEX:
                    return Config.GetIntSetting(Setting.presence_AffiliatesAvoidingMeListSize);
                case X_AFFILIATE_FAVORITES_INDEX:
                    return Config.GetIntSetting(Setting.presence_AffiliatesFavoritesListSize);
                default:
                    return 0;
            }
        }

        public static uint X_AFFILIATE_INDEX_TO_FLAG(uint dwIndex) { return (uint)(1 << (int)dwIndex); }
        public static uint X_AFFILIATE_FLAG_TO_INDEX(uint dwFlag)
        {
            return (
            ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_ENCOUNTERED_INDEX)) ? PresDefs.X_AFFILIATE_ENCOUNTERED_INDEX :
            ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_COMPLETED_GAME_INDEX)) ? PresDefs.X_AFFILIATE_COMPLETED_GAME_INDEX :
            ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_POSITIVE_FEEDBACK_INDEX)) ? PresDefs.X_AFFILIATE_POSITIVE_FEEDBACK_INDEX :
            ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX)) ? PresDefs.X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX :
            ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_AVOIDING_ME_INDEX)) ? PresDefs.X_AFFILIATE_AVOIDING_ME_INDEX :
            ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_FAVORITES_INDEX)) ? PresDefs.X_AFFILIATE_FAVORITES_INDEX :
            ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_FRIEND_INDEX)) ? PresDefs.X_AFFILIATE_FRIEND_INDEX :
            ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_BLOCK_INDEX)) ? PresDefs.X_AFFILIATE_BLOCK_INDEX :
            ((dwFlag) == X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_MUTE_INDEX)) ? PresDefs.X_AFFILIATE_MUTE_INDEX : PresDefs.X_AFFILIATE_INDEX_ERROR
            );
        }

        public const uint X_AFFILIATE_MASK_POSITIVE =
            X_AFFILIATE_COMPLETED_GAME_INDEX |
            X_AFFILIATE_ENCOUNTERED_INDEX |
            X_AFFILIATE_FAVORITES_INDEX |
            X_AFFILIATE_FRIEND_INDEX |
            X_AFFILIATE_POSITIVE_FEEDBACK_INDEX;

        public const uint MAX_ADD_AFFILIATE = 16;

        public const uint MAX_FIND_USERS_REQUESTS = 100;

        public const uint XONLINE_PRESENCE_LOGON_KNOWN_CONSOLE = 0;
        public const uint XONLINE_PRESENCE_LOGON_FIRST_TIME_CONSOLE = 1;
        public const uint XONLINE_PRESENCE_LOGON_FIRST_TIME_LIVE = 2;


        public static byte GetPlatformType(uint dwState)
        {
            switch (dwState & P_STATE_MASK_CONSOLE_TYPE)
            {
                case P_STATE_ENUM_CONSOLE_XBOX:
                    return XOn.XPLT_XBOX1;
                case P_STATE_ENUM_CONSOLE_XENON:
                    return XOn.XPLT_XBOX360;
                case P_STATE_ENUM_CONSOLE_WINPC:
                    return XOn.XPLT_PC;
                default:
                    return XOn.XPLT_INVALID;
            }
        }
    };



    //
    // Structure Representing base Presence & Notification Message info
    //  Maps to BASE_MSG_HEADER in xonline.x
    //  
    public class BaseHeader : WireData
    {
        public uint     dwMsgType;
        public uint     dwMsgLen;
        [WireInfo(HexString=true)]
        public uint     dwSeqNum;
        public SGADDR   sgaddr;

        // BYTE rgbMsgData[ dwMsgLen ];

        [WireInfo(Serialize=false)]
        private WireData container;

        public WireData Container
        {
            get {return container;}
            set {container = value;}
        }
        
        // 
        // WireData requires a default constructor with no args for deserialization, so this must exist
        //        
        public BaseHeader()
        {
        }
        
        // 
        // When creating WireData headers to serialize, it's convenient to set the type automagically
        //        
        public BaseHeader( Q_MSG_TYPES msgType, WireData parent )
        {
            dwMsgType = (uint)msgType;
            container = parent;
            sgaddr = new SGADDR();
            // Default to sgAddrIgnore
            sgaddr.inaSg = 0; 
            sgaddr.dwSpiSg = 0;
            sgaddr.qwXboxId = 0;
            sgaddr.abReserved = 0;
        }

        public BaseHeader(P_MSG_TYPES msgType, WireData parent)
        {
            dwMsgType = (uint)msgType;
            container = parent;
            sgaddr = new SGADDR();
            // Default to sgAddrIgnore
            sgaddr.inaSg = 0; 
            sgaddr.dwSpiSg = 0;
            sgaddr.qwXboxId = 0;
            sgaddr.abReserved = 0;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {          
            // 
            // NOTE!! The containing WireData object MUST also override Size() otherwise
            //  this will result in an infinite recursion/stack overflow situation
            // 
            if( null != container )
            {
                dwMsgLen = (uint)( container.Size() - Size() );
            }
            else
            {
                // We allow this case for unit tests that want to simulate truncated messages by just sending 
                // the correct base header.
                dwMsgLen = 0;
            }

            binaryWriter.Write(dwMsgType);
            binaryWriter.Write(dwMsgLen);
            binaryWriter.Write(dwSeqNum);
            sgaddr.WriteStream(binaryWriter);

        }

         public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                dwMsgType = (uint)binaryReader.ReadInt32();
                dwMsgLen = (uint)binaryReader.ReadInt32();
                dwSeqNum = (uint)binaryReader.ReadInt32();
                sgaddr = new SGADDR();
                sgaddr.ReadStream(binaryReader);
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_14, 
                    "Reached end of stream trying to read BaseHeader", e);
            }
            return this;
        }

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER )
            return 32;
        }        
    };

    public class PresenceXrlObject : XRLObject2
    {
        public override string Xrl
        {
            get
            {
                return "/xpnfront/xpresence.srf";
            }
        }
    }

    //
    // Structure representing a request to make a user active on the system
    //  maps to P_HELLO_MSG in xonline.x
    //
    public class PresenceHelloMsg : XRLObject2
    {
        public PresenceHelloMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_HELLO, this );
        }

        public BaseHeader       header;
        public uint             dwProtocolVersion;

        [WireInfo(NullTerminate=true, ArraySize=79)]
        public string           szDescription;      

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceHelloMsg )
            return 32 + 4 + 80;
        }        
    }


    public class PresenceConnectionHealthMsg : XRLObject2
    {
        public PresenceConnectionHealthMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_CONNECTION_HEALTH, this );
        }

        public BaseHeader       header;
        public uint             dwVersion;
        public uint             dwFlags;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceConnectionHealthMsg )
            return 32 + 8;
        }        
    }

    public class PresenceConnectionHealthReplyMsg : XRLObject2
    {
        public PresenceConnectionHealthReplyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_CONNECTION_HEALTH_REPLY, this );
        }

        public BaseHeader       header;
        public HResult          hr;
        public uint             dwFlags;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceConnectionHealthReplyMsg )
            return 32 + 8;
        }        
    }

    // Structures returned by APIs ///////////////////////////////////////////////////////////

    //
    // Structure representing a buddy in an Alive reply
    //  maps to P_REPLY_BUDDY in xonline.x
    //
    public class ReplyBuddy : WireData
    {
        public ulong            qwBuddyID;
        public ushort           cbAcctName; // Includes the '\0'
        public byte             bStatus;    // See P_BUDDY_STATUS_XXX
       
        [WireInfo(SizeParam="cbAcctName", NullTerminate=true)]
        public string           szAcctName; // ASCII Null terminated

        override public int Size()
        {
            // Get the correct sizes before we use them
            cbAcctName = null == szAcctName ? (ushort) 0 : (ushort)( Encoding.UTF8.GetByteCount( szAcctName ) + 1 );

            return 11 + cbAcctName;
        }
    }

    //
    // Structure representing a result from an affiliates query
    //  maps to P_QUERY_AFFILIATES_REPLY_DATA_MSG in xonline.x
    //
    public class QueryAffiliatesReplyData : WireData
    {
        [WireInfo(HexString=true)]
        public ulong            qwAffiliateID;
        [WireInfo(HexString=true)]
        public uint             dwListFlags;
        [WireInfo(HexString=true)]
        public uint             dwTitleID;
        [WireInfo(HexString=true)]
        public ulong            qwSessionID;
        [WireInfo(HexString=true)]
        public uint             mtDateUpdated;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string           szGamerTag; // ASCII Null terminated

        override public int Size()
        {
            return 44;
        }

         public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                qwAffiliateID = (ulong)binaryReader.ReadInt64();
                dwListFlags = (uint)binaryReader.ReadInt32();
                dwTitleID = (uint)binaryReader.ReadInt32();
                qwSessionID = (ulong)binaryReader.ReadInt64();
                mtDateUpdated = (uint)binaryReader.ReadInt32();
                string s = new UTF8Encoding().GetString(binaryReader.ReadBytes(PresDefs.XONLINE_GAMERTAG_SIZE));
                int termPos = s.IndexOf((char)0);
                if (termPos > 0)
                {
                    szGamerTag = s.Substring(0, s.IndexOf((char)0));
                }
                else if (termPos == -1)
                {
                    szGamerTag = s;
                }
                else
                {
                    szGamerTag = "";
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_15, 
                    "Reached end of stream trying to read QueryAffiliatesReplyData", e);
            }
            return this;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(qwAffiliateID);
            binaryWriter.Write(dwListFlags);
            binaryWriter.Write(dwTitleID);
            binaryWriter.Write(qwSessionID);
            binaryWriter.Write(mtDateUpdated);

            byte[] b;
            if (szGamerTag != null)
            {
                // write the string, but only up to XONLINE_GAMERTAG_SIZE
                b = new UTF8Encoding().GetBytes(szGamerTag);
                if (b.Length <= PresDefs.XONLINE_GAMERTAG_SIZE)
                {
                    binaryWriter.Write(b);
                }
                else
                {
                    binaryWriter.Write(b, 0, PresDefs.XONLINE_GAMERTAG_SIZE);
                }
            }
            else
            {
                b = new byte[0];
            }

            // if we need to, zero pad the string out to XONLINE_GAMERTAG_SIZE
            for (int i = b.Length; i < PresDefs.XONLINE_GAMERTAG_SIZE; ++i)
            {
                binaryWriter.Write((byte)0);
            }
        }
    }


    // Externally-callable Presence APIs /////////////////////////////////////////////////////

    //
    // Structure representing a request to see if a user is already logged on.
    //  maps to P_LOGON_CHECK_MSG in xonline.x
    //
    public class PresenceLogonCheckMsg : XRLObject2
    {
        public PresenceLogonCheckMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_LOGON_CHECK, this);
        }

        public BaseHeader header;
        public ulong qwUserID;

        public override int Size()
        {
            return 32 + 8;
        }
    }

    //
    // Structure representing a the response to see if a user is already logged on.
    //  maps to P_LOGON_CHECK_REPLY_MSG in xonline.x
    //
    public class PresenceLogonCheckReplyMsg : XRLObject2
    {
        public PresenceLogonCheckReplyMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_LOGON_CHECK_REPLY, this);
        }

        public BaseHeader header;
        public HResult hr;

        public override int Size()
        {
            return 32 + 4;
        }
    }

    //
    // Structure representing a request to make a user active on the system
    //  maps to P_ALIVE_MSG in xonline.x
    //
    public class PresenceAliveMsg : XRLObject2
    {
        public PresenceAliveMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ALIVE, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public ushort           cbAcctName;
        public uint             dwBuddyListVersion;
        public uint             dwBlockListVersion;
        public uint             dwState;            // Must be ( P_STATE_MASK_ONLINE | P_STATE_MASK_CLOAKED )
        public ulong            qwMatchSessionID;   // Must be zero
        public ushort           cbNickname;         // Must be zero
        public ushort           cbTitleStuff;       // Must be zero

        [WireInfo(SizeParam="cbAcctName", NullTerminate=true)]
        public string           szAcctName;

        [WireInfo(SizeParam="cbTitleStuff")]
        public byte[]           rgbTitleStuff;
 
        [WireInfo(SizeParam="cbNickname")]
        public byte[]           rgbNickName;        

        public override int Size()
        {
            // Get the correct sizes before we use them
            cbAcctName = null == szAcctName ? (ushort) 0 : (ushort)( Encoding.UTF8.GetByteCount( szAcctName ) + 1 );
            cbTitleStuff = null == rgbTitleStuff ? (ushort) 0 : (ushort) rgbTitleStuff.Length;
            cbNickname = null == rgbNickName ? (ushort) 0 : (ushort) rgbNickName.Length;

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAliveMsg ) + cbAcctName + cbTitleStuff + cbNickname
            return 32 + 38 + cbAcctName + cbTitleStuff + cbNickname;
        }        

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                header.ReadStream(binaryReader);
                qwUserID = binaryReader.ReadUInt64();
                dwTitleID = binaryReader.ReadUInt32();
                cbAcctName = binaryReader.ReadUInt16();
                dwBuddyListVersion = binaryReader.ReadUInt32();
                dwBlockListVersion = binaryReader.ReadUInt32();
                dwState = binaryReader.ReadUInt32();
                qwMatchSessionID = binaryReader.ReadUInt64();
                cbNickname = binaryReader.ReadUInt16();
                cbTitleStuff = binaryReader.ReadUInt16();

                string s = new UTF8Encoding().GetString(binaryReader.ReadBytes(cbAcctName));
                int termPos = s.IndexOf((char)0);
                if (termPos > 0)
                {
                    szAcctName = s.Substring(0, s.IndexOf((char)0));
                }
                else if (termPos == -1)
                {
                    szAcctName = s;
                }
                else
                {
                    szAcctName = "";
                }

                rgbTitleStuff = binaryReader.ReadBytes(cbTitleStuff);
                rgbNickName = binaryReader.ReadBytes(cbNickname);
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_16, 
                    "Reached end of stream trying to read PresenceAliveMsg", e);
            }
            return this;
        }

    }

    //
    // Structure representing a request to make a user active on the system, version 2
    //  maps to P_ALIVE_2_MSG in xonline.x
    //
    public class PresenceAlive2Msg : XRLObject2
    {
        public PresenceAlive2Msg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ALIVE_2, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ushort           cbAcctName;

        public XNADDR           xnaddr;
        public ulong            xnkid;

        [WireInfo(ArraySize=16)]
        public byte[]           xnkey;

        public uint             dwBuddyListVersion;
        public uint             dwBlockListVersion;

        // These fields are filled in by SGInfo at the front door (dwTitleID must be filled in and match what the SG returns)
        public ulong            clientVersion;
        public uint             dwTitleID;
        public uint             dwTitleVersion;
        public uint             dwTitleRegion;
        public ushort           ipportI;
        public uint             ipaI;
        public ulong            liNonce;
        public ulong            liTimeInit;

        [WireInfo(SizeParam="cbAcctName", NullTerminate=true)]
        public string           szAcctName;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cbAcctName = null == szAcctName ? (ushort) 0 : (ushort)( Encoding.UTF8.GetByteCount( szAcctName ) + 1 );

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAlive2Msg ) + cbAcctName
            return 32 + 120 + cbAcctName;
        }        

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                header.ReadStream(binaryReader);
                qwUserID = binaryReader.ReadUInt64();
                cbAcctName = binaryReader.ReadUInt16();
                xnaddr = new XNADDR();
                xnaddr.ReadStream(binaryReader);
                xnkid = binaryReader.ReadUInt64();
                xnkey = binaryReader.ReadBytes(16);
                dwBuddyListVersion = binaryReader.ReadUInt32();
                dwBlockListVersion = binaryReader.ReadUInt32();
                clientVersion = binaryReader.ReadUInt64();
                dwTitleID = binaryReader.ReadUInt32();
                dwTitleVersion = binaryReader.ReadUInt32();
                dwTitleRegion = binaryReader.ReadUInt32();
                ipportI = binaryReader.ReadUInt16();
                ipaI = binaryReader.ReadUInt32();
                liNonce = binaryReader.ReadUInt64();
                liTimeInit = binaryReader.ReadUInt64();

                string s = new UTF8Encoding().GetString(binaryReader.ReadBytes(cbAcctName));
                int termPos = s.IndexOf((char)0);
                if (termPos > 0)
                {
                    szAcctName = s.Substring(0, s.IndexOf((char)0));
                }
                else if (termPos == -1)
                {
                    szAcctName = s;
                }
                else
                {
                    szAcctName = "";
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_17, 
                    "Reached end of stream trying to read PresenceAlive2Msg", e);
            }
            return this;
        }

    }

    //
    // Structure representing a request to make a user active on the system, internal version
    //  maps to P_ALIVE_INTERNAL_MSG in xonline.x
    //
    public class PresenceAliveInternalMsg : XRLObject2
    {
        public PresenceAliveInternalMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ALIVE_INTERNAL, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ushort           cbAcctName;

        public XNADDR           xnaddr;
        public ulong            xnkid;

        [WireInfo(ArraySize=16)]
        public byte[]           xnkey;

        public uint             dwBuddyListVersion;
        public uint             dwBlockListVersion;

        // These fields are filled in by SGInfo at the front door (dwTitleID must be filled in and match what the SG returns)
        public XBOX_LIBRARY_VERSION clientVersion;
        public uint             dwAuthDataFlags;
        public uint             dwTitleID;
        public uint             dwAltTitleID1;
        public uint             dwAltTitleID2;
        public uint             dwAltTitleID3;
        public uint             dwAltTitleID4;
        public uint             dwTitleVersion;
        public uint             dwTitleRegion;
        public ushort           ipportI;
        public uint             ipaI;
        public ulong            liNonce;
        public ulong            liTimeInit;

        [WireInfo(SizeParam="cbAcctName", NullTerminate=true)]
        public string           szAcctName;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cbAcctName = null == szAcctName ? (ushort) 0 : (ushort)( Encoding.UTF8.GetByteCount( szAcctName ) + 1 );

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAliveInternalMsg ) + cbAcctName
            return 32 + 140 + cbAcctName;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup the string length
            if (szAcctName != null)
            {
                cbAcctName = (ushort)(Encoding.UTF8.GetByteCount(szAcctName) + 1); // null terminated
            }
            else
            {
                cbAcctName = (ushort)0;
            }

            header.WriteStream(binaryWriter);
            binaryWriter.Write(qwUserID);
            binaryWriter.Write(cbAcctName);
            xnaddr.WriteStream(binaryWriter);
            binaryWriter.Write(xnkid);
            binaryWriter.Write(xnkey);
            binaryWriter.Write(dwBuddyListVersion);
            binaryWriter.Write(dwBlockListVersion);
            clientVersion.WriteStream(binaryWriter);
            binaryWriter.Write(dwAuthDataFlags);
            binaryWriter.Write(dwTitleID);
            binaryWriter.Write(dwAltTitleID1);
            binaryWriter.Write(dwAltTitleID2);
            binaryWriter.Write(dwAltTitleID3);
            binaryWriter.Write(dwAltTitleID4);
            binaryWriter.Write(dwTitleVersion);
            binaryWriter.Write(dwTitleRegion);
            binaryWriter.Write(ipportI);
            binaryWriter.Write(ipaI);
            binaryWriter.Write(liNonce);
            binaryWriter.Write(liTimeInit);
            if (szAcctName != null)
            {
                byte[] b = Encoding.UTF8.GetBytes(szAcctName);
                binaryWriter.Write(b);
                binaryWriter.Write((byte)0);
            }
        }

    }

    public class PresenceAliveInternal2Msg : XRLObject2
    {
        public PresenceAliveInternal2Msg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ALIVE_INTERNAL_2, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ushort           cbAcctName;

        public XNADDR           xnaddr;
        public ulong            xnkid;

        [WireInfo(ArraySize=16)]
        public byte[]           xnkey;

        public uint             dwBuddyListVersion;
        public uint             dwBlockListVersion;

        // These fields are filled in by SGInfo at the front door (dwTitleID must be filled in and match what the SG returns)
        public XBOX_LIBRARY_VERSION clientVersion;
        public uint             dwAuthDataFlags;
        public uint             dwTitleID;
        public uint             dwAltTitleID1;
        public uint             dwAltTitleID2;
        public uint             dwAltTitleID3;
        public uint             dwAltTitleID4;
        public uint             dwTitleVersion;
        public uint             dwTitleRegion;
        public ushort           ipportI;
        public uint             ipaI;
        public ulong            liNonce;
        public ulong            liTimeInit;

        [WireInfo(ArraySize=PresDefs.XONLINE_PRESENCE_LOCALE_SIZE)]
        public string           szLocale;

        public ulong            qwVersionFlags;

        [WireInfo(SizeParam="cbAcctName", NullTerminate=true)]
        public string           szAcctName;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cbAcctName = null == szAcctName ? (ushort) 0 : (ushort)( Encoding.UTF8.GetByteCount( szAcctName ) + 1 );

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAliveInternalMsg ) + cbAcctName
            return 32 + 148 + PresDefs.XONLINE_PRESENCE_LOCALE_SIZE + cbAcctName;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup the string length
            if (szAcctName != null)
            {
                cbAcctName = (ushort)(Encoding.UTF8.GetByteCount(szAcctName) + 1); // null terminated
            }
            else
            {
                cbAcctName = (ushort)0;
            }

            header.WriteStream(binaryWriter);
            binaryWriter.Write(qwUserID);
            binaryWriter.Write(cbAcctName);
            xnaddr.WriteStream(binaryWriter);
            binaryWriter.Write(xnkid);
            binaryWriter.Write(xnkey);
            binaryWriter.Write(dwBuddyListVersion);
            binaryWriter.Write(dwBlockListVersion);
            clientVersion.WriteStream(binaryWriter);
            binaryWriter.Write(dwAuthDataFlags);
            binaryWriter.Write(dwTitleID);
            binaryWriter.Write(dwAltTitleID1);
            binaryWriter.Write(dwAltTitleID2);
            binaryWriter.Write(dwAltTitleID3);
            binaryWriter.Write(dwAltTitleID4);
            binaryWriter.Write(dwTitleVersion);
            binaryWriter.Write(dwTitleRegion);
            binaryWriter.Write(ipportI);
            binaryWriter.Write(ipaI);
            binaryWriter.Write(liNonce);
            binaryWriter.Write(liTimeInit);
            int iLocaleLen = 0;
            if (szLocale != null)
            {
                byte[] b = Encoding.UTF8.GetBytes(szLocale);
                binaryWriter.Write(b);
                iLocaleLen = b.Length;
            }
            for (int iByte = iLocaleLen; iByte < PresDefs.XONLINE_PRESENCE_LOCALE_SIZE; iByte++)
            {
                binaryWriter.Write((byte)0);
            }
            binaryWriter.Write(qwVersionFlags);
            if (szAcctName != null)
            {
                byte[] b = Encoding.UTF8.GetBytes(szAcctName);
                binaryWriter.Write(b);
                binaryWriter.Write((byte)0);
            }
        }

    }

    //
    // Structure representing a reply to an Alive request
    //  maps to P_ALIVE_REPLY_MSG in xonline.x
    //
    public class PresenceAliveReply : XRLObject2
    {
        public PresenceAliveReply()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ALIVE_REPLY, this );
        }

        public BaseHeader       header;
        public HResult          hr;                         // On fail other fields set to 0
        public uint             dwBuddyListVersion;
        public ushort           cBuddiesSent;
        public uint             dwBlockListVersion;
        public ushort           cBlocksSent;

        [WireInfo(SizeParam="cBuddiesSent")]
        public ReplyBuddy[]     rgReplyBuddies;
      
        [WireInfo(SizeParam="cBlocksSent")]
        public ulong[]          rgqwBlockIDs; // maps to P_REPLY_BLOCK in xonline.x

        public override int Size()
        {
            // Get the correct sizes before we use them
            cBuddiesSent = null == rgReplyBuddies ? (ushort) 0 : (ushort) rgReplyBuddies.Length;
            cBlocksSent = null == rgqwBlockIDs ? (ushort) 0 : (ushort) rgqwBlockIDs.Length;

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAliveReply ) + cBuddiesSent * sizeof( ReplyBuddy ) + cBlocksSent * sizeof( ulong )
            int iSize = 32 + 16 + cBlocksSent * 8;
            for( int iBuddy = 0; iBuddy < cBuddiesSent; iBuddy++ )
            {
                iSize += rgReplyBuddies[ iBuddy ].Size();
            }
            return iSize;
        }        
    }

    //
    // Structure representing a request to take a user offline
    //  maps to P_DEAD_USER_MSG/Q_DEAD_USER_MSG
    //
    public class PresenceDeadUserMsg : XRLObject2
    {
        public PresenceDeadUserMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_DEAD_USER, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceDeadUserMsg )
            return 32 + 8;
        }        
    }

    //
    // Structure representing a request to change a user's state
    //  maps to P_STATE_MSG in xonline.x
    //
    // NOTE: Only allowed on the datacenter port
    //
    public class PresenceStateMsg : PresenceXrlObject
    {
        public PresenceStateMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_STATE, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwState;            // See P_STATE_MASK_XXX
        public ulong            qwMatchSessionID;
        public ushort           cbTitleStuff;

        [WireInfo(SizeParam="cbTitleStuff")]
        public byte[]           rgbTitleStuff;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cbTitleStuff = null == rgbTitleStuff ? (ushort) 0 : (ushort) rgbTitleStuff.Length;

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceStateMsg ) + cbTitleStuff
            return 32 + 22 + cbTitleStuff;
        }        
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup array lengths
            cbTitleStuff = rgbTitleStuff == null ? (ushort)0 : (ushort)rgbTitleStuff.Length;
            header.WriteStream(binaryWriter);
            binaryWriter.Write(qwUserID);
            binaryWriter.Write(dwState);
            binaryWriter.Write(qwMatchSessionID);
            binaryWriter.Write(cbTitleStuff);
            binaryWriter.Write(rgbTitleStuff);
        }
    }
    

    //
    // Structure representing a rich presence state data
    //  maps to P_RICH_PRESENCE in xonline.x
    //
    public class RichPresence : WireData
    {
        public uint             titlePresence;
        
        public ushort           cContexts;
        public ushort           cProperties;

        [WireInfo(SizeParam="cContexts")]
        public GIContext[]      rgContexts;

        [WireInfo(SizeParam="cProperties")]
        public GIProperty[]     rgProps;

        public override int Size()
        {
            cContexts = rgContexts == null ? (ushort)0 : (ushort)rgContexts.Length;
            cProperties = rgProps == null ? (ushort)0 : (ushort)rgProps.Length;            
            
            // sizeof( RichPresence )
            int cb = 8;

            // add all the contexts
            cb += cContexts * 8;
            
            // add all the props
            if (cProperties > 0)
            {
                foreach (GIProperty prop in rgProps)
                {
                    cb += prop.Size();
                }
            }

            return cb;
        }        

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                titlePresence = binaryReader.ReadUInt32();
                cContexts = binaryReader.ReadUInt16();
                cProperties = binaryReader.ReadUInt16();
                rgContexts = new GIContext[cContexts];
                for (int i = 0; i < cContexts; ++i)
                {
                    rgContexts[i] = new GIContext();
                    rgContexts[i].ReadStream(binaryReader);
                }
                rgProps = new GIProperty[cProperties];
                for (int i = 0; i < cProperties; ++i)
                {
                    rgProps[i] = new GIProperty();
                    rgProps[i].ReadStream(binaryReader);
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_18, 
                    "Reached end of stream trying to read RichPresence", e);
            }
            return this;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup array lengths
            cContexts = rgContexts == null ? (ushort)0 : (ushort)rgContexts.Length;
            cProperties = rgProps == null ? (ushort)0 : (ushort)rgProps.Length;

            binaryWriter.Write(titlePresence);
            binaryWriter.Write(cContexts);
            binaryWriter.Write(cProperties);
            for (int i = 0; i < cContexts; ++i)
            {
                rgContexts[i].WriteStream(binaryWriter);
            }
            for (int i = 0; i < cProperties; ++i)
            {
                rgProps[i].WriteStream(binaryWriter);
            }
        }
    }

        
    //
    // Structure representing a request to change a user's state
    //  maps to P_STATE_MSG in xonline.x
    //
    // NOTE: Only allowed on the datacenter port
    //
    public class PresenceState2Msg : PresenceXrlObject
    {
        public PresenceState2Msg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_STATE_2, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwState;            // See P_STATE_MASK_XXX
        public ulong            qwMatchSessionID;

        public uint             dwTitleId;          // Xenon state now conveys title changes
        public uint             cbRichPresence;     // Count of RP data

        public ushort           cbMemcacheData;     // Count of memcache data
        
        public RichPresence     rpData;

        [WireInfo(SizeParam="cbMemcacheData")]
        public byte[] rgbMemcacheData;

        public override int Size()
        {
            cbMemcacheData = (rgbMemcacheData == null) ? (ushort)0 : (ushort)rgbMemcacheData.Length;

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceStateMsg ) + sizeof ( RichPresence ) + sizeof(rgbMemcacheData)
            int cb = 32 + 30 + rpData.Size() + cbMemcacheData;
            
            return cb;
        }        
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            cbMemcacheData = (rgbMemcacheData == null) ? (ushort)0 : (ushort)rgbMemcacheData.Length;
            
            header.WriteStream(binaryWriter);
            binaryWriter.Write(qwUserID);
            binaryWriter.Write(dwState);
            binaryWriter.Write(qwMatchSessionID);
            binaryWriter.Write(dwTitleId);
            binaryWriter.Write(cbRichPresence);
            binaryWriter.Write(cbMemcacheData);
            rpData.WriteStream(binaryWriter);

            if (rgbMemcacheData != null)
            {
                binaryWriter.Write(rgbMemcacheData);
            }
        }
    }

    //
    // Structure representing a request to fetch a user's state
    //  maps to P_GET_STATE_MSG in xonline.x
    //
    // NOTE: Only allowed on the datacenter port
    //
    public class PresenceGetStateMsg : PresenceXrlObject
    {
        public PresenceGetStateMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_GET_STATE, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( qwUserID )
            return 32 + 8;
        }        
        
    }

    //
    // Structure representing a reply to a PresenceGetStateMsg request
    //  maps to P_GET_STATE_MSG in xonline.x
    //
    // NOTE: Only allowed on the datacenter port
    //
    public class PresenceGetStateReplyMsg : PresenceXrlObject
    {
        public PresenceGetStateReplyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_GET_STATE_REPLY, this );
            presenceData = new RichPresence();
        }

        public BaseHeader       header;
        public HResult          hr;
        
        public uint             dwState;            // See P_STATE_MASK_XXX
        public ulong            qwMatchSessionID;

        public uint             dwTitleId;          // Xenon state now conveys title changes
        
        RichPresence            presenceData;
        
        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceStateMsg ) + sizeof ( RichPresence )
            int cb = 32 + 20 + presenceData.Size();

            return cb;
        }                
    }
    
    //
    // Structure representing a request to add a user to another user's friends list
    //  maps to P_ADD_MSG in xonline.x
    // 
    public class PresenceAddBuddyMsg : PresenceXrlObject
    {
        public PresenceAddBuddyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ADD, this );
        }

        public BaseHeader       header;
        public ulong            qwSenderID;
        public ulong            qwBuddyID;
        public ushort           cbBuddyAcctName;
 
        [WireInfo(SizeParam="cbBuddyAcctName", NullTerminate=true)]
        public string           szBuddyAcctName; // ASCII Null terminated, only used if qwBuddyID == 0

        public override int Size()
        {
            // Get the correct sizes before we use them
            cbBuddyAcctName = null == szBuddyAcctName ? (ushort) 0 : (ushort) Encoding.UTF8.GetByteCount( szBuddyAcctName );
            // add one for the null terminator
            cbBuddyAcctName ++; 

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAddBuddyMsg ) + cbBuddyAcctName
            return 32 + 18 + cbBuddyAcctName;
        }        
        
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                header.ReadStream(binaryReader);
                qwSenderID = binaryReader.ReadUInt64();
                qwBuddyID = binaryReader.ReadUInt64();
                cbBuddyAcctName = binaryReader.ReadUInt16();

                string s = new UTF8Encoding().GetString(binaryReader.ReadBytes(cbBuddyAcctName));
                int termPos = s.IndexOf((char)0);
                if (termPos > 0)
                {
                    szBuddyAcctName = s.Substring(0, s.IndexOf((char)0));
                }
                else if (termPos == -1)
                {
                    szBuddyAcctName = s;
                }
                else
                {
                    szBuddyAcctName = "";
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_19, 
                    "Reached end of stream trying to read PresenceAddBuddyMsg", e);
            }
            return this;
        }
     }

    //
    // Structure representing a request to add  users to another user's affiliates list
    //  maps to P_ADD_AFFILIATES_MSG in xonline.x
    // 
    public class PresenceAddAffiliatesMsg : PresenceXrlObject
    {
        public PresenceAddAffiliatesMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ADD_AFFILIATES, this );
        }

        public BaseHeader       header;
        public ulong            qwSenderID;
        public uint             dwListFlag;
        public uint             dwTitleID;
        public ushort           cwAffiliates;
 
        [WireInfo(SizeParam="cwAffiliates")]
        public ulong[]          pqwAffiliates;
        
        public override int Size()
        {
            cwAffiliates = (pqwAffiliates == null) ? (ushort)0 : (ushort)pqwAffiliates.Length;
            
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAddAffiliatesMsg ) + cwAffiliates * sizeof(ulong);
            return 32 + 18 + (8 * cwAffiliates);
        }        
    }

    //
    // Structure representing a request to test if a user is on the sender's affiliates list
    //  maps to P_IS_AFFILIATE_MSG in xonline.x
    // 
    public class PresenceIsAffiliateMsg : PresenceXrlObject
    {
        public PresenceIsAffiliateMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_IS_AFFILIATE, this );
        }

        public BaseHeader       header;
        public ulong            qwSenderID;
        public ulong            qwAffiliateID;
        
        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceIsAffiliateMsg );
            return 32 + 16;
        }        
    }

    //
    // Structure representing a reply to test if a user is on the sender's affiliates list
    //  maps to P_IS_AFFILIATE_REPLY_MSG in xonline.x
    // 
    public class PresenceIsAffiliateReplyMsg : PresenceXrlObject
    {
        public PresenceIsAffiliateReplyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_IS_AFFILIATE_REPLY, this );
        }

        public BaseHeader       header;
        public HResult          hr;
        public ulong            qwAffiliateID;
        public uint             dwListFlags;
        
        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceIsAffiliateReplyMsg );
            return 32 + 16;
        }        
    }

    //
    // Structure representing a request to obtain the sender's affiliates list
    //  maps to P_QUERY_AFFILIATES_MSG in xonline.x
    // 
    public class PresenceQueryAffiliatesMsg : PresenceXrlObject
    {
        public PresenceQueryAffiliatesMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_QUERY_AFFILIATES, this );
        }

        public BaseHeader       header;
        [WireInfo(HexString=true)]
        public ulong            qwSenderID;
        [WireInfo(HexString=true)]
        public uint             dwListFlags;
        public uint             cdwLimit;
        [WireInfo(HexString=true)]
        public uint             dwOnlineTitleID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceQueryAffiliatesMsg );
            return 32 + 20;
        }        
    }

    //
    // Structure representing a reply with the sender's affiliates list
    //  maps to P_QUERY_AFFILIATES_REPLY_MSG in xonline.x
    // 
    public class PresenceQueryAffiliatesReplyMsg : PresenceXrlObject
    {
        public PresenceQueryAffiliatesReplyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_QUERY_AFFILIATES_REPLY, this );
        }

        public BaseHeader       header;
        [WireInfo(HexString=true)]
        public HResult          hr;
        public uint             cdwResults;

        [WireInfo(SizeParam="cdwResults")]
        public QueryAffiliatesReplyData[]      rgResults;
        
        public override int Size()
        {
            cdwResults = rgResults == null ? (uint)0 : (uint)rgResults.Length;
            
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceQueryAffiliatesReplyMsg ) + cdwResults * sizeof( QueryAffiliatesReplyData );
            return (int)(32 + 8 + (cdwResults * 44));
        }        
        
         public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                header.ReadStream(binaryReader);
                hr = (uint)binaryReader.ReadInt32();
                cdwResults = (uint)binaryReader.ReadInt32();
                rgResults = new QueryAffiliatesReplyData[cdwResults];
                for (int i = 0; i < cdwResults; ++i)
                {
                    rgResults[i] = new QueryAffiliatesReplyData();
                    rgResults[i].ReadStream(binaryReader);
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_20, 
                    "Reached end of stream trying to read PresenceQueryAffiliatesReplyMsg", e);
            }
            return this;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup array lengths
            cdwResults = rgResults == null ? (uint)0 : (uint)rgResults.Length;

            header.WriteStream(binaryWriter);
            binaryWriter.Write(hr);
            binaryWriter.Write(cdwResults);
            for (int i = 0; i < cdwResults; ++i)
            {
                rgResults[i].WriteStream(binaryWriter);
            }
        }
    }


    //
    // Structure representing a request to add a user to another user's friends list
    //  maps to P_ADD_2_MSG in xonline.x
    // 
    public class PresenceAddBuddy2Msg : PresenceXrlObject
    {
        public PresenceAddBuddy2Msg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ADD_2, this );
        }

        public BaseHeader       header;
        public ulong            qwSenderID;
        public ulong            qwBuddyID;
        public uint             dwMessageFlags;
        public ushort           cbDetails;
 
        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string           szBuddyAcctName; // ASCII Null terminated, only used if qwBuddyID == 0

        [WireInfo(SizeParam="cbDetails")]
        public byte[]   rgbDetails;

        public MessageDetails details
        {
            get
            {
                if ((rgbDetails != null) && (rgbDetails.Length > 0))
                {
                    MessageDetails ret = new MessageDetails();
                    ret.ReadBytes(rgbDetails);
                    return ret;
                }
                else
                {
                    return null;
                }
            }
            set
            {
                if (value == null)
                {
                    rgbDetails = null;
                }
                else
                {
                    rgbDetails = (byte[])value;
                    cbDetails = (ushort)(rgbDetails.Length);
                }
            }
        }

        public override int Size()
        {
            // Get the correct sizes before we use them
            cbDetails = (null == rgbDetails) ? (ushort) 0 : (ushort) rgbDetails.Length;

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAddBuddy2Msg ) + cbDetails
            return 32 + 38 + cbDetails;
        }        
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            header.WriteStream(binaryWriter);
            binaryWriter.Write(qwSenderID);
            binaryWriter.Write(qwBuddyID);
            binaryWriter.Write(dwMessageFlags);
            binaryWriter.Write(cbDetails);

            byte[] b;
            if (szBuddyAcctName != null)
            {
                b = Encoding.UTF8.GetBytes(szBuddyAcctName);
                binaryWriter.Write(b);
            }
            else
            {
                b = new byte[0];
            }

            // zero pad out to PresDefs.XONLINE_GAMERTAG_SIZE length
            for (int i = b.Length; i < PresDefs.XONLINE_GAMERTAG_SIZE; ++i)
            {
                binaryWriter.Write((byte)0);
            }

            if (rgbDetails != null)
            {
                binaryWriter.Write(rgbDetails);
            }
        }
     }

    //
    // Structure representing a request to remove a user from another user's friends list
    //  maps to P_DELETE_MSG in xonline.x
    // 
    public class PresenceDeleteBuddyMsg : PresenceXrlObject
    {
        public PresenceDeleteBuddyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_DELETE, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwBuddyID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceDeleteBuddyMsg )
            return 32 + 16;
        }        
    }

    //
    // Structure representing a request to accept a friend request
    //  maps to P_ACCEPT_MSG in xonline.x
    // 
    public class PresenceAcceptBuddyMsg : PresenceXrlObject
    {
        public PresenceAcceptBuddyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_ACCEPT, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwBuddyID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAcceptBuddyMsg )
            return 32 + 16;
        }        
    }

    //
    // Structure representing a request to reject a friend request
    //  maps to P_REJECT_MSG in xonline.x
    // 
    public class PresenceRejectBuddyMsg : PresenceXrlObject
    {
        public PresenceRejectBuddyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_REJECT, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwBuddyID;
        public uint             dwNever;
        
        
        public bool fNever
        {
            get { return (dwNever == 0 ? false : true); }
            set { dwNever = (uint)(value ? 1 : 0); }
        }    

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceRejectBuddyMsg )
            return 32 + 20;
        }        
    }
    
    //
    // Structure representing a request to add a user to another user's mute list
    //  maps to old P_BLOCK_MSG in xonline.x
    // 
    public class PresenceMuteUserMsg : PresenceXrlObject
    {
        public PresenceMuteUserMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_MUTE, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwBlockID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceMuteUserMsg )
            return 32 + 16;
        }        
    }

    //
    // Structure representing a request to remove a user from another user's mute list
    //  maps to old P_UNBLOCK_MSG in xonline.x
    // 
    public class PresenceUnmuteUserMsg : PresenceXrlObject
    {
        public PresenceUnmuteUserMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_UNMUTE, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwBlockID; // If qwBlockID == 0, clear the entire block list

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceUnmuteUserMsg )
            return 32 + 16;
        }        
    }

    //
    // Structure representing a request to add a list of users to neverlist (block communications)
    // 
    public class AddUsersToNeverListMsg : PresenceXrlObject
    {
        public AddUsersToNeverListMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_ADD_USERS_TO_NEVERLIST, this);
        }

        public BaseHeader header;
        public ulong qwUserID;

        [WireInfo(Max = MsgDefs.XONLINE_MAX_MESSAGE_RECIPIENTS)]
        public ushort cNeverListUserCount;

        [WireInfo(SizeParam = "cNeverListUserCount")]
        public ulong[] rgqwNeverListUsers;
        
        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof(qwUserID) + sizeof(cNeverListUserCount) + cNeverListUserCount * sizeof (ulong)
            return header.Size() + sizeof(ulong) + sizeof(ushort) + cNeverListUserCount*sizeof(ulong);
        }     
    }


    //
    // Structure representing a request to remove a list of users from neverlist (allow previously blocked communication)
    // 
    public class RemoveUsersFromNeverListMsg : PresenceXrlObject
    {
        public RemoveUsersFromNeverListMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_REMOVE_USERS_FROM_NEVERLIST, this);
        }

        public BaseHeader header;
        public ulong qwUserID;
        
        [WireInfo(Max = MsgDefs.XONLINE_MAX_MESSAGE_RECIPIENTS)]
        public ushort cNeverListUserCount;

        [WireInfo(SizeParam = "cNeverListUserCount")]
        public ulong[] rgqwNeverListUsers;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof(qwUserID) + sizeof(cNeverListUserCount) + cNeverListUserCount * sizeof (ulong)
            return header.Size() + sizeof(ulong) + sizeof(ushort) + cNeverListUserCount * sizeof(ulong);
        }   
    }


    //
    // Structure representing a request to check if a given user can send communication to another user
    // 
    public class CanSendMessageToUsersMsg : PresenceXrlObject
    {
        public CanSendMessageToUsersMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_CAN_SEND_MESSAGE, this);
        }

        public BaseHeader header;
        public ulong qwUserID;

        [WireInfo(Max = MsgDefs.XONLINE_MAX_MESSAGE_RECIPIENTS)]
        public ushort cUserListCount;

        [WireInfo(SizeParam = "cUserListCount")]
        public ulong[] rgqwUsers;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof(qwUserID) + sizeof(cUserListCount) + cUserListCount * sizeof (ulong)
            return header.Size() + sizeof(ulong) + sizeof(ushort) + cUserListCount * sizeof(ulong);
        }   
    }

    public class CanSendMessageToUsersResponse : PresenceXrlObject
    {
        public CanSendMessageToUsersResponse()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_CAN_SEND_MESSAGE_REPLY, this);
        }

        public BaseHeader header;
        public ulong qwUserID;

        [WireInfo(Max = MsgDefs.XONLINE_MAX_MESSAGE_RECIPIENTS)]
        public ushort cResponseListCount;

        [WireInfo(SizeParam = "cResponseListCount")]
        public uint[] rghrResponses;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof(qwUserID) + sizeof(cResponseListCount) + cResponseListCount * sizeof (uint)
            return header.Size() + sizeof(ulong) + sizeof(ushort) + cResponseListCount * sizeof(uint);
        } 
    }

    //
    // Structure representing a request to invite users to a game session
    //  maps to P_INVITE_MSG in xonline.x
    // 
    public class PresenceInviteUserMsg : PresenceXrlObject
    {
        public PresenceInviteUserMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_INVITE, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public ulong            qwMatchSessionID;
        public ushort           cInvitees;
 
        [WireInfo(SizeParam="cInvitees")]
        public ulong[]          rgqwInvitees;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cInvitees = null == rgqwInvitees ? (ushort) 0 : (ushort) rgqwInvitees.Length;

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceInviteUserMsg ) + cInvitees * sizeof( ulong )
            return 32 + 22 + cInvitees * 8;
        }        
    }

    //
    // Structure representing a request to invite users to a game session
    //  maps to P_INVITE_2_MSG in xonline.x
    // 
    public class PresenceInviteUser2Msg : PresenceXrlObject
    {
        public PresenceInviteUser2Msg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_INVITE_2, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwSenderContext;
        public uint             dwTitleID;
        public uint             dwMessageFlags;
        public ushort           cInvitees;
        public ushort           cbDetails;
 
        [WireInfo(SizeParam="cInvitees")]
        public ulong[]          rgqwInvitees;

        public MessageDetails   details;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cInvitees = null == rgqwInvitees ? (ushort) 0 : (ushort) rgqwInvitees.Length;
            cbDetails = null == details ? (ushort) 0 : (ushort) details.Size();

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceInviteUser2Msg ) + cInvitees * sizeof( ulong ) + cbDetails
            return 32 + 28 + cInvitees * 8 + cbDetails;
        }        
    }

    //
    // Structure representing a request to cancel an invitation to a game session
    //  maps to P_CANCEL_MSG in xonline.x
    // 
    public class PresenceCancelInviteMsg : PresenceXrlObject
    {
        public PresenceCancelInviteMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_CANCEL, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwMatchSessionID;
        public ushort           cInvitees;
 
        [WireInfo(SizeParam="cInvitees")]
        public ulong[]          rgqwInvitees;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cInvitees = null == rgqwInvitees ? (ushort) 0 : (ushort) rgqwInvitees.Length;

            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceCancelInviteMsg ) + cInvitees * sizeof( ulong )
            return 32 + 18 + cInvitees * 8;
        }        
    }

    //
    // Structure representing a request to answer an invitation to a game session
    //  maps to P_INVITE_ANSWER_MSG in xonline.x
    // 
    public class PresenceAnswerInviteMsg : PresenceXrlObject
    {
        public PresenceAnswerInviteMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_INVITE_ANSWER, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwHostID;
        public ulong            qwMatchSessionID;
        public ushort           wAnswer;          // See PINVITE_REPLY_XXX

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PresenceAnswerInviteMsg )
            return 32 + 26;
        }        
    }


    // Externally-callable Notification APIs /////////////////////////////////////////////////

    //
    // Structure representing a request to dequeue notification items on behalf of a user
    //  maps to Q_DEQUEUE_MSG in xonline.x
    //  
    public class NotificationDequeueMsg : XRLObject2
    {
        public NotificationDequeueMsg()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_DEQUEUE,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ushort           wQType;
        public uint             dwStartItemID;
        public ushort           wMaxItems;
        public uint             dwMaxTotalItemDataSize;

        public override int Size()
        {
            // sizeof( Q_DEQUEUE_MSG )
            return 52;
        }
    }


    //
    // Structure representing a single list item in a NotificationListItem
    //  object. This structure is serialized into rgbItemData for 
    //  queues of type PQUEUE_LIST_CHANGE
    //
    public class ListChangeItem : WireData
    {
        public uint        dwListVersion;
        public ulong       qwTargetID;
        public ushort      wOperationID;
        public HResult     hr;
        public ushort      cbTargetAcctName;
        
        [WireInfo(SizeParam="cbTargetAcctName")]  // ASCII string null terminated
        public string      szTargetAcctName;

        public override int Size()
        {
            cbTargetAcctName = (szTargetAcctName == null) ? (ushort)0 : (ushort)Encoding.UTF8.GetByteCount(szTargetAcctName);

            // sizeof( Q_LIST_ITEM ) + wItemLen
            return 20 + cbTargetAcctName;
        }        
    };

    //
    // Structure representing a single list item in a NotificationListItem
    //  object. This structure is serialized into rgbItemData for 
    //  queues of type PQUEUE_PRESENCE
    //
    public class PresenceItem : WireData
    {
        public ulong      qwBuddyID;
        public uint       dwTitleID;
        public uint       dwState;
        public ulong      qwMatchSessionID;
        public ushort     cbNickname;
        public ushort     cbTitleStuff;
        
        [WireInfo(SizeParam="cbNickname")]
        public byte[]     rgbNickName;
        
        [WireInfo(SizeParam="cbTitleStuff")]
        public byte[]     rgbTitleStuff;

        public override int Size()
        {
            cbNickname = (rgbNickName == null) ? (ushort)0 : (ushort)rgbNickName.Length;
            cbTitleStuff = (rgbTitleStuff == null) ? (ushort)0 : (ushort)rgbTitleStuff.Length;
            
            // sizeof( PresenceItem ) + cbNickname + cbTitleStuff
            return 28 + cbNickname + cbTitleStuff;
        }        
    };

    //
    // Structure representing a single list item in a NotificationListItem
    //  object. This structure is serialized into rgbItemData for 
    //  queues of type PQUEUE_INVITE
    //
    public class InvitationItem : WireData
    {
        public ulong      qwHostID;
        public ulong      qwMatchSessionID;
        public uint       dwTitleID;
        public ulong      ftSent;

        public override int Size()
        {
            // sizeof( InvitationItem ) 
            return 28;
        }        
    };

    //
    // Structure representing a single list item in a NotificationListItem
    //  object. This structure is serialized into rgbItemData for 
    //  queues of type PQUEUE_INVITE_ANSWER
    //
    public class InvitationAnswerItem : WireData   
    {
        public ulong      qwInviteeID;
        public ulong      qwMatchSessionID;
        public ulong      ftSent;
        public ushort     wAnswer;

        public override int Size()
        {
            // sizeof( InvitationAnswerItem ) 
            return 26;
        }        
    };


    //
    // Structure representing a single list item in a NotificationListItem
    //  object. This structure is serialized into rgbItemData for 
    //  queues of type PQUEUE_PEER_PRESENCE
    //
    public class PeerPresenceItem : WireData
    {
        public ulong      qwUserID;
        public uint       dwTitleID;
        public uint       dwState;
        public ulong      qwMatchSessionID;
        public ushort     cbTitleStuff;
        
        [WireInfo(SizeParam="cbTitleStuff")]
        public byte[]     rgbTitleStuff;

        public override int Size()
        {
            cbTitleStuff = (rgbTitleStuff == null) ? (ushort)0 : (ushort)rgbTitleStuff.Length;

            // sizeof( PeerPresenceItem ) + cbTitleStuff
            return 26 + cbTitleStuff;
        }        
    };

    //
    // Structure representing a single list item in a NotificationListItem
    //  object. This structure is serialized into rgbItemData for 
    //  queues of type PQUEUE_PRESENCE_2
    //
    public class Presence2Item : WireData
    {
        public ulong            qwUserID;
        public uint             dwTitleID;
        public uint             dwState;
        public ulong            qwMatchSessionID;
        public uint             mtUserTime;
        
        public ushort           cbRichPresence;
        public ushort           cbrpData;

        [WireInfo(SizeParam="cbRichPresence")]
        public string           szRichPresence;        
        
        [WireInfo(SizeParam="cbData", Serialize=false)]
        public RichPresence     rpData;

        public override int Size()
        {
            cbRichPresence = (szRichPresence == null) ? (ushort)0 : (ushort)Encoding.UTF8.GetByteCount(szRichPresence);
            cbrpData = (ushort)rpData.Size();
            
            // sizeof( Presence2Item ) + cbRichPresence + cbData
            return 32 + cbRichPresence + rpData.Size();
        }        

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                qwUserID = binaryReader.ReadUInt64();
                dwTitleID = binaryReader.ReadUInt32();
                dwState = binaryReader.ReadUInt32();
                qwMatchSessionID = binaryReader.ReadUInt64();
                mtUserTime = binaryReader.ReadUInt32();
                cbRichPresence = binaryReader.ReadUInt16();
                cbrpData = binaryReader.ReadUInt16();
                byte[] byteString = binaryReader.ReadBytes(cbRichPresence);
                szRichPresence = new UTF8Encoding().GetString(byteString);

                if (cbrpData > 0)
                {
                    rpData = new RichPresence();
                    rpData.ReadStream(binaryReader);
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_21, 
                    "Reached end of stream trying to read Presence2Item", e);
            }

            return this;
        }        

        public override void WriteStream( BinaryWriter binaryWriter )
        {          
            // Implement a little trickery. To the client, rgbData is an array of bytes with 
            //  cbData as the SizeParam. Set the size properly here since WireData won't
            if (null != rpData)
            {
                cbrpData = (ushort)rpData.Size();
            }
            else
            {
                cbrpData = 0;
            }

            byte[] b;
            if (szRichPresence != null)
            {
                b = new UTF8Encoding().GetBytes(szRichPresence);
            }
            else
            {
                b = new byte[0];
            }

            binaryWriter.Write(qwUserID);
            binaryWriter.Write(dwTitleID);
            binaryWriter.Write(dwState);
            binaryWriter.Write(qwMatchSessionID);
            binaryWriter.Write(mtUserTime);

            // fixup cbRichPresence before we write it
            cbRichPresence = (ushort)b.Length;

            binaryWriter.Write(cbRichPresence);
            binaryWriter.Write(cbrpData);
            if (szRichPresence != null)
            {
                binaryWriter.Write(b);
            }

        }
    };

    //
    // Structure representing a single list item in a dequeue response
    //  maps to Q_LIST_ITEM in xonline.x
    //
    public class NotificationListItem : WireData
    {
        public uint             dwItemID;
        public ushort           wItemLen;
 
        [WireInfo(SizeParam="wItemLen")]
        public byte[]           rgbItemData;

        public override int Size()
        {
            // Get the correct sizes before we use them
            wItemLen = null == rgbItemData ? (ushort) 0 : (ushort) rgbItemData.Length;

            // sizeof( Q_LIST_ITEM ) + wItemLen
            return 6 + wItemLen;
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                dwItemID = binaryReader.ReadUInt32();
                wItemLen = binaryReader.ReadUInt16();
                rgbItemData = binaryReader.ReadBytes(wItemLen);
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_22, 
                    "Reached end of stream trying to read NotificationListItem", e);
            }
            return this;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup array lengths
            wItemLen = rgbItemData == null? (ushort)0 : (ushort)rgbItemData.Length;

            binaryWriter.Write(dwItemID);
            binaryWriter.Write(wItemLen);
            binaryWriter.Write(rgbItemData);
        }

    }
    
    //
    // Structure representing reply to a request to dequeue notification items on behalf of a user
    //  maps to Q_LIST_REPLY_MSG in xonline.x
    //  
    public class NotificationDequeueReply : XRLObject2
    {
        public NotificationDequeueReply()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_LIST_REPLY,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ushort           wQType;
        public HResult          hr;
        public uint             dwNextItemID;
        public ushort           wQLeft;
        public ushort           wNumItems;
        public uint             dwTotalItemDataSize;
        public uint             cQVals;
 
        [WireInfo(SizeParam="cQVals")]
        public uint[]           rgdwQVals;

        [WireInfo(SizeParam="wNumItems")]
        public NotificationListItem[] rgListItems;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cQVals = null == rgdwQVals ? (uint) 0 : (uint) rgdwQVals.Length;
            wNumItems = null == rgListItems ? (ushort) 0 : (ushort) rgListItems.Length;

            // sizeof( Q_LIST_REPLY_MSG ) + ( cQVals * sizeof( DWORD ) )
            int iSize = 62 + ( (int) cQVals * 4 );

            // Add up the size of the list items
            for( int iItem = 0; iItem < wNumItems; iItem++ )
            {
                iSize += rgListItems[ iItem ].Size();
            }
 
            return iSize;
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                // constructor for this class already constructed the header
                header.ReadStream(binaryReader);
                qwUserID = binaryReader.ReadUInt64();
                wQType = binaryReader.ReadUInt16();
                hr = binaryReader.ReadUInt32();
                dwNextItemID = binaryReader.ReadUInt32();
                wQLeft = binaryReader.ReadUInt16();
                wNumItems = binaryReader.ReadUInt16();
                dwTotalItemDataSize = binaryReader.ReadUInt32();
                cQVals = binaryReader.ReadUInt32();
                rgdwQVals = new uint[cQVals];
                for (int i = 0; i < cQVals; ++i)
                {
                    rgdwQVals[i] = binaryReader.ReadUInt32();
                }
                rgListItems = new NotificationListItem[wNumItems];
                for (int i = 0; i < wNumItems; ++i)
                {
                    rgListItems[i] = new NotificationListItem();
                    rgListItems[i].ReadStream(binaryReader);
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_23, 
                    "Reached end of stream trying to read NotificationDequeueReply", e);
            }
            return this;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup array lengths
            cQVals = rgdwQVals == null ? (uint)0 : (uint)rgdwQVals.Length;
            wNumItems = rgListItems == null ? (ushort)0 : (ushort)rgListItems.Length;

            header.WriteStream(binaryWriter);
            binaryWriter.Write(qwUserID);
            binaryWriter.Write(wQType);
            binaryWriter.Write(hr);
            binaryWriter.Write(dwNextItemID);
            binaryWriter.Write(wQLeft);
            binaryWriter.Write(wNumItems);
            binaryWriter.Write(dwTotalItemDataSize);
            binaryWriter.Write(cQVals);
            for (int i = 0; i < cQVals; ++i)
            {
                binaryWriter.Write(rgdwQVals[i]);
            }
            for (int i = 0; i < wNumItems; ++i)
            {
                rgListItems[i].WriteStream(binaryWriter);
            }
        }

    }

    public class NotificationDequeueReply2 : XRLObject2
    {
        public NotificationDequeueReply2()
        {
            header = new BaseHeader(Q_MSG_TYPES.QMSG_LIST_REPLY_2,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ushort           wQType;
        public HResult          hr;
        public uint             dwNextItemID;
        public ushort           wQLeft;
        public ushort           wNumItems;
        public uint             dwTotalItemDataSize;
        public uint             cQVals;
 
        [WireInfo(ArraySize=PresDefs.XONLINE_PRESENCE_LOCALE_SIZE)]
        public string           szLocale;

        [WireInfo(SizeParam="cQVals")]
        public uint[]           rgdwQVals;

        [WireInfo(SizeParam="wNumItems")]
        public NotificationListItem[] rgListItems;

        public override int Size()
        {
            // Get the correct sizes before we use them
            cQVals = null == rgdwQVals ? (uint) 0 : (uint) rgdwQVals.Length;
            wNumItems = null == rgListItems ? (ushort) 0 : (ushort) rgListItems.Length;

            // sizeof( Q_LIST_REPLY_MSG ) + ( cQVals * sizeof( DWORD ) )
            // we continue to use Q_LIST_REPLY_MSG size rather than Q_LIST_REPLY_2 size, so that writestream serializes this the same way.
            int iSize = 62 + ( (int) cQVals * 4 );

            // Add up the size of the list items
            for( int iItem = 0; iItem < wNumItems; iItem++ )
            {
                iSize += rgListItems[ iItem ].Size();
            }
 
            return iSize;
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                // constructor for this class already constructed the header
                header.ReadStream(binaryReader);
                qwUserID = binaryReader.ReadUInt64();
                wQType = binaryReader.ReadUInt16();
                hr = binaryReader.ReadUInt32();
                dwNextItemID = binaryReader.ReadUInt32();
                wQLeft = binaryReader.ReadUInt16();
                wNumItems = binaryReader.ReadUInt16();
                dwTotalItemDataSize = binaryReader.ReadUInt32();
                cQVals = binaryReader.ReadUInt32();
                rgdwQVals = new uint[cQVals];
                string s = new UTF8Encoding().GetString(binaryReader.ReadBytes(PresDefs.XONLINE_PRESENCE_LOCALE_SIZE));
                int termPos = s.IndexOf((char)0);
                if (termPos > 0)
                {
                    szLocale = s.Substring(0, s.IndexOf((char)0));
                }
                else if (termPos == -1)
                {
                    szLocale = s;
                }
                else
                {
                    szLocale = null;
                }                
                for (int i = 0; i < cQVals; ++i)
                {
                    rgdwQVals[i] = binaryReader.ReadUInt32();
                }
                rgListItems = new NotificationListItem[wNumItems];
                for (int i = 0; i < wNumItems; ++i)
                {
                    rgListItems[i] = new NotificationListItem();
                    rgListItems[i].ReadStream(binaryReader);
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_23, 
                    "Reached end of stream trying to read NotificationDequeueReply", e);
            }
            return this;
        }

        // write stream does not include the szLocale field.  szLocale is an internal only field.
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // fixup array lengths
            cQVals = rgdwQVals == null ? (uint)0 : (uint)rgdwQVals.Length;
            wNumItems = rgListItems == null ? (ushort)0 : (ushort)rgListItems.Length;

            header.WriteStream(binaryWriter);
            binaryWriter.Write(qwUserID);
            binaryWriter.Write(wQType);
            binaryWriter.Write(hr);
            binaryWriter.Write(dwNextItemID);
            binaryWriter.Write(wQLeft);
            binaryWriter.Write(wNumItems);
            binaryWriter.Write(dwTotalItemDataSize);
            binaryWriter.Write(cQVals);
            for (int i = 0; i < cQVals; ++i)
            {
                binaryWriter.Write(rgdwQVals[i]);
            }
            for (int i = 0; i < wNumItems; ++i)
            {
                rgListItems[i].WriteStream(binaryWriter);
            }
        }
    }

    public class PurgeUserRequest : PresenceXrlObject
    {
        public PurgeUserRequest()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_PURGE_USER, this);
        }
        
        public BaseHeader header;
        public ulong puid;
                
        public override int Size()
        {
            return header.Size() + 8;
        }        
    }
    
    public class PurgeUserResponse : PresenceXrlObject
    {
        public PurgeUserResponse()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_PURGE_USER_REPLY, this);
        }
        
        public BaseHeader header;
        public HResult hr;
        
        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string szGamerTag;
                
        public override int Size()
        {
            return header.Size() + 20;
        }        
    }
    
    public class WebAliveRequest : PresenceXrlObject
    {
        public WebAliveRequest()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_WEB_ALIVE, this);
        }
        
        public BaseHeader header;
        public ulong puid;
                
        public override int Size()
        {
            return header.Size() + 8;
        }        
    }
    
    public class WebAliveResponse : PresenceXrlObject
    {
        public WebAliveResponse()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_WEB_ALIVE_REPLY, this);
        }
        
        public BaseHeader header;
        public HResult hr;
        public ulong puid;
                
        public override int Size()
        {
            return header.Size() + 12;
        }        
    }

    public class WebAlive2Request : PresenceXrlObject
    {
        public WebAlive2Request()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_WEB_ALIVE2, this);
        }

        public BaseHeader header;
        public ulong puid;
        public uint titleId;

        public override int Size()
        {
            return header.Size() + 12;
        }
    }

    public class WebFriendsRequest : PresenceXrlObject
    {
        public WebFriendsRequest()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_WEB_FRIENDS, this);
        }
        
        public BaseHeader header;
        public ulong puid;
        
        
        public override int Size()
        {
            return header.Size() + 8;
        }        
    }    
    
    public class WebFriendsResponse : PresenceXrlObject
    {
        public WebFriendsResponse()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_WEB_FRIENDS_REPLY, this);
        }
        
        public BaseHeader header;
        public HResult hr;
        public ulong puid;
        public uint version;
        public uint cdwFriends;

        [WireInfo(SizeParam="cdwFriends")]
        public WebFriendsData[] rgFriends;
        
        public override int Size()
        {
            cdwFriends = (rgFriends == null) ? 0 : (uint)rgFriends.Length;
            
            int cbFriends = 0;
            for (int iFriend = 0; iFriend < cdwFriends; iFriend++)
            {
                cbFriends += rgFriends[iFriend].Size();
            }
            
            return header.Size() + 20 + cbFriends;
        }        
    }
    
    public class WebFriendsData : PresenceXrlObject
    {
        public ulong Puid;
        public uint FriendStatus;
        public uint OnlineState;
        public uint TitleId;
        public uint mtLastActive;
        public ushort StateDataLen;
        public uint RPDataLen;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string szGamerTag;

        [WireInfo(SizeParam="StateDataLen")]
        public byte[] StateData;
        
        [WireInfo(SizeParam="RPDataLen")]
        public byte[] RPData;
        
        public override int Size()
        {
            StateDataLen = (StateData == null) ? (ushort)0 : (ushort)StateData.Length;
            RPDataLen = (RPData == null) ? (ushort)0 : (ushort)RPData.Length;

            return 46 + (int)RPDataLen + (int)StateDataLen;
        }        
    }

    public class GetFriendsLimitedPresenceRequest : PresenceXrlObject
    {
        public GetFriendsLimitedPresenceRequest()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_GET_FRIENDS_LIMITED_PRESENCE, this);
        }
        
        public BaseHeader header;
        public ulong puid;
        
        
        public override int Size()
        {
            return header.Size() + 8;
        }        
    }    
    
    public class GetFriendsLimitedPresenceResponse : PresenceXrlObject
    {
        public GetFriendsLimitedPresenceResponse()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_GET_FRIENDS_LIMITED_PRESENCE_REPLY, this);
        }
        
        public BaseHeader header;
        public HResult hr;
        public ulong puid;
        public uint cdwFriends;
        [WireInfo(SizeParam="cdwFriends")]
        public GetFriendsLimitedPresenceData[] rgFriends;
        
        public override int Size()
        {
            cdwFriends = (rgFriends == null) ? 0 : (uint)rgFriends.Length;
            
            int cbFriends = 0;
            for (int iFriend = 0; iFriend < cdwFriends; iFriend++)
            {
                cbFriends += rgFriends[iFriend].Size();
            }

            return header.Size() + 16 + cbFriends;
        }        
    }
    
    public class GetFriendsLimitedPresenceData : PresenceXrlObject
    {
        public ulong Puid;
        public uint FriendStatus;
        public uint OnlineState;
        public uint TitleId;
        public uint mtLastSeen;
        [WireInfo(ArraySize = PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string szGamerTag;
        public override int Size()
        {
            return 24 + PresDefs.XONLINE_GAMERTAG_SIZE;
        }
    }

    public class GetFriendsNoPresenceRequest : PresenceXrlObject
    {
        public GetFriendsNoPresenceRequest()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_GET_FRIENDS_NO_PRESENCE, this);
        }
        
        public BaseHeader header;
        public ulong puid;
        
        
        public override int Size()
        {
            return header.Size() + 8;
        }        
    }

    public class GetFriendsNoPresenceResponse : PresenceXrlObject
    {
        public GetFriendsNoPresenceResponse()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_GET_FRIENDS_NO_PRESENCE_REPLY, this);
        }
        
        public BaseHeader header;
        public HResult hr;
        public ulong puid;
        public uint cdwFriends;

        [WireInfo(SizeParam="cdwFriends")]
        public GetFriendsNoPresenceData[] rgFriends;
        
        public override int Size()
        {
            cdwFriends = (rgFriends == null) ? 0 : (uint)rgFriends.Length;
            
            int cbFriends = 0;
            for (int iFriend = 0; iFriend < cdwFriends; iFriend++)
            {
                cbFriends += rgFriends[iFriend].Size();
            }
            
            return header.Size() + 16 + cbFriends;
        }        
    }

    public class GetFriendsNoPresenceData : PresenceXrlObject
    {
        public ulong Puid;
        public uint FriendStatus;
        public override int Size()
        {
            return 12;
        }
    }

    public class GetFriendsListRequest : PresenceXrlObject
    {
        public GetFriendsListRequest()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_GET_FRIENDS_LIST, this);
        }
        
        public BaseHeader header;
        public ulong qwSender;
        public ulong qwTarget;
        
        
        public override int Size()
        {
            return header.Size() + 16;
        }        
    }    
    
    public class GetFriendsListResponse : PresenceXrlObject
    {
        public GetFriendsListResponse()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_GET_FRIENDS_LIST_REPLY, this);
        }
        
        public BaseHeader header;
        public HResult hr;
        public ulong puid;
        public uint version;
        public uint cdwFriends;

        [WireInfo(SizeParam="cdwFriends")]
        public GetFriendsListData[] rgFriends;
        
        public override int Size()
        {
            cdwFriends = (rgFriends == null) ? 0 : (uint)rgFriends.Length;

            int cbFriends = 0;
            for (int iFriend = 0; iFriend < cdwFriends; iFriend++)
            {
                cbFriends += rgFriends[iFriend].Size();
            }
            
            return header.Size() + 20 + cbFriends;
        }        
    }
    
    public class GetFriendsListData : PresenceXrlObject
    {
        public ulong Puid;
        public uint FriendStatus;
        public uint OnlineState;
        public uint TitleId;
        public uint mtLastActive;
        public ushort StateDataLen;
        public uint RPDataLen;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string szGamerTag;

        [WireInfo(SizeParam="StateDataLen")]
        public byte[] StateData;
        
        [WireInfo(SizeParam="RPDataLen")]
        public byte[] RPData;
        
        public override int Size()
        {
            StateDataLen = (StateData == null) ? (ushort)0 : (ushort)StateData.Length;
            RPDataLen = (RPData == null) ? (ushort)0 : (ushort)RPData.Length;
            
            return 46 + (int)RPDataLen + (int)StateDataLen;
        }        
    }
                
    public class GetPresenceInfoRequest : PresenceXrlObject
    {
        public GetPresenceInfoRequest()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_GET_PRESENCE_INFO, this);
        }
        
        public BaseHeader header;
        public uint dwContext;
        public ulong qwSenderID;
        public uint cdwUsers;
        
        [WireInfo(SizeParam="cdwUsers")]
        public ulong[] rgUsers;        
        
        public override int Size()
        {
            cdwUsers = (rgUsers == null) ? 0 : (uint)rgUsers.Length;
            
            return header.Size() + 16 + ((int)cdwUsers * 8);
        }        
    }    
    
    public class PresenceInfoResponse : PresenceXrlObject
    {
        public PresenceInfoResponse()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_PRESENCE_INFO_REPLY, this);
        }
        
        public BaseHeader header;
        public uint dwContext;
        public ulong qwSenderID;
        public uint cdwUsers;
        
        [WireInfo(SizeParam="cdwUsers")]
        public PresenceInfoData[] rgUsers;        
        
        public override int Size()
        {
            cdwUsers = (rgUsers == null) ? 0 : (uint)rgUsers.Length;

            int cbUsers = 0;
            for (int iUser = 0; iUser < cdwUsers; iUser++)
            {
                cbUsers += rgUsers[iUser].Size();
            }
            
            return header.Size() + 16 + cbUsers;
        }        
    }    
    
    public class PresenceInfoData : PresenceXrlObject
    {
        public ulong Puid;
        public uint OnlineState;
        public uint TitleId;
        public uint mtLastActive;
        public ulong qwSessionID;
        public ushort StateDataLen;
        public uint RPDataLen;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string szGamerTag;

        [WireInfo(SizeParam="StateDataLen")]
        public byte[] StateData;
        
        [WireInfo(SizeParam="RPDataLen")]
        public byte[] RPData;
        
        public override int Size()
        {
            StateDataLen = (StateData == null) ? (ushort)0 : (ushort)StateData.Length;
            RPDataLen = (RPData == null) ? (ushort)0 : (ushort)RPData.Length;

            return 50 + (int)RPDataLen + (int)StateDataLen;
        }        
    }
        
    //
    // Structure representing a request to invalidate a user's cached data
    //  maps to PMSG_INVALIDATE_USER
    //
    public class InvalidateUserMsg : PresenceXrlObject
    {
        public InvalidateUserMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_INVALIDATE_USER, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( InvalidateUserMsg )
            return 32 + 8;
        }        
    }

    //
    // Structure representing a request to obtain a users xnaddr info
    //  maps to PMSG_PEER_SESSION
    //
    public class PeerSessionMsg : PresenceXrlObject
    {
        public PeerSessionMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_PEER_SESSION, this );
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public ulong            qwHostID;       

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PeerSessionMsg )
            return 32 + 16;
        }        
    }

    //
    // Structure representing a request to obtain a users xnaddr info
    //  maps to PMSG_PEER_SESSION_REPLY
    //
    public class PeerSessionReplyMsg : PresenceXrlObject
    {
        public PeerSessionReplyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_PEER_SESSION_REPLY, this );
        }

        public BaseHeader       header;

        public uint dwTitleID;
        public uint dwTitleVersion;
        public uint dwTitleRegion;

        public XNADDR xnaddr;
        [WireInfo(ArraySize=8)]
        public byte[] xkid;
        [WireInfo(ArraySize=16)]
        public byte[] xnkey;
        
        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( PeerSessionReplyMsg )
            return 32 + 12 + 36 + 8 + 16;
        }        
    }


    //
    // Structure representing a request to lookup a user's PUID via gamertag
    //  maps to PMSG_FIND_USER
    //
    public class FindUserMsg : PresenceXrlObject
    {
        public FindUserMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_FIND_USER, this );
        }

        public BaseHeader       header;
        
        public ulong            qwUserID;       // User making the request

        public ulong            qwFindID;       // User to be found
        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string           szGamerTag;     // Gamertag to be found

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( FindUserMsg )
            return 32 + 16 + PresDefs.XONLINE_GAMERTAG_SIZE;
        }        
    }

    //
    // Structure representing a reply to lookup a user's PUID by gamertag
    //  maps to PMSG_FIND_USER_REPLY
    //
    public class FindUserReplyMsg : PresenceXrlObject
    {
        public FindUserReplyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_FIND_USER_REPLY, this );
        }

        public BaseHeader       header;
        
        public ulong            qwFoundID;      // User found - 0 if not found
        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string           szGamerTag;     // Gamertag found - only valid if qwUserID is not 0

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( FindUserMsg )
            return 32 + 8 + PresDefs.XONLINE_GAMERTAG_SIZE;
        }        
    }

    public class FindUsersData : PresenceXrlObject
    {
        public ulong qwUserID;

        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string szGamerTag;

        public override int Size()
        {
            return 24;
        }        
    }
    
    //
    // Structure representing a request to lookup a user's PUID via gamertag
    //  maps to PMSG_FIND_USER
    //
    public class FindUsersMsg : PresenceXrlObject
    {
        public FindUsersMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_FIND_USERS, this );
        }
        
        public FindUsersMsg(uint cdwQueries)
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_FIND_USERS, this );
            this.cdwQueries = cdwQueries;
            rgQueries = new FindUsersData[cdwQueries];
        }

        public BaseHeader header;
        
        public ulong qwUserID;       // User making the request

        [WireInfo(Min=1, Max=PresDefs.MAX_FIND_USERS_REQUESTS)]
        public uint cdwQueries;

        [WireInfo(SizeParam="cdwQueries")]
        public FindUsersData[] rgQueries;

        public override int Size()
        {
            cdwQueries = (rgQueries == null) ? 0 : (uint)rgQueries.Length;
            
            // sizeof( BASE_MSG_HEADER ) + sizeof( FindUsersMsg ) + ( cdwQueries * sizeof( FindUsersData ) )
            return 32 + 12 + (24 * (int)cdwQueries);
        }        
    }

    //
    // Structure representing a reply to lookup a user's PUID by gamertag
    //  maps to PMSG_FIND_USER_REPLY
    //
    public class FindUsersReplyMsg : PresenceXrlObject
    {
        public FindUsersReplyMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_FIND_USERS_REPLY, this );
        }
        
        public FindUsersReplyMsg(uint cdwResults)
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_FIND_USERS_REPLY, this );
            this.cdwResults = cdwResults;
            rgResults = new FindUsersData[cdwResults];
        }

        public BaseHeader       header;

        public uint cdwResults;
        
        [WireInfo(SizeParam="cdwResults")]
        public FindUsersData[] rgResults;

        public override int Size()
        {
            cdwResults = (rgResults == null) ? 0 : (uint)rgResults.Length;
            
            // sizeof( BASE_MSG_HEADER ) + sizeof( FindUserMsg ) + ( cdwResults * sizeof( FindUsersData ) )
            return 32 + 4 + (24 * (int)cdwResults);
        }        
    }

    //
    // Structure representing a request to ick a user off the system
    //  maps to PMSG_KICK
    //
    public class KickMsg : PresenceXrlObject
    {
        public BaseHeader  header;
        public ulong       qwUserID;
        public uint        fFlushTickets;

        public KickMsg()
        {
            header = new BaseHeader( P_MSG_TYPES.PMSG_KICK, this );
        }

        public override int Size()
        {
            return header.Size() + 12;
        }
    }
    

} // namespace XBOX.Online.Protocol.Presence
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\msgutil.cs ===
using System;
using System.Collections;
using System.IO;
using System.Text;

using xonline.common.config;
using xonline.common.service;

namespace xonline.common.protocol 
{
    // Common code shared by CUserMessage and CSystemMessage for building messages
    public class CMessage
    {
        public void AddProperty( ushort wPropTag )
        {
            if( MsgDefs.XONLINE_MSG_PROP_TYPE_NULL != MsgDefs.XOnlineMessageGetPropType( wPropTag ) )
            {
                throw new ApplicationException( "Setting a non-null property type to a null value" );
            }

            MessageProperty prop = new MessageProperty();
            prop.wPropTag = wPropTag;
            prop.wPropOffset = 0; // For NULL types there is no data
            m_alPropDescriptors.Add( prop );
        }

        public void AddProperty( ushort wPropTag, byte bData )
        {
            if( MsgDefs.XONLINE_MSG_PROP_TYPE_I1 != MsgDefs.XOnlineMessageGetPropType( wPropTag ) )
            {
                throw new ApplicationException( "Setting a non-byte property type to a byte value" );
            }

            MessageProperty prop = new MessageProperty();
            prop.wPropTag = wPropTag;
            prop.wPropOffset = bData; // For I1 types the data is held right in the offset
            m_alPropDescriptors.Add( prop );
        }

        public void AddProperty( ushort wPropTag, ushort wData )
        {
            if( MsgDefs.XONLINE_MSG_PROP_TYPE_I2 != MsgDefs.XOnlineMessageGetPropType( wPropTag ) )
            {
                throw new ApplicationException( "Setting a non-ushort property type to a ushort value" );
            }

            MessageProperty prop = new MessageProperty();
            prop.wPropTag = wPropTag;
            prop.wPropOffset = wData; // For I2 types the data is held right in the offset
            m_alPropDescriptors.Add( prop );
        }

        public void AddProperty( ushort wPropTag, uint dwData )
        {
            if( MsgDefs.XONLINE_MSG_PROP_TYPE_I4 != MsgDefs.XOnlineMessageGetPropType( wPropTag ) &&
                MsgDefs.XONLINE_MSG_PROP_TYPE_STRING_ID != MsgDefs.XOnlineMessageGetPropType( wPropTag ) )
            {
                throw new ApplicationException( "Setting a non-uint property type to a uint value" );
            }

            MessageProperty prop = new MessageProperty();
            prop.wPropTag = wPropTag;
            prop.wPropOffset = (ushort) m_PropDataStream.Length;
            m_alPropDescriptors.Add( prop );

            BinaryWriter writer = new BinaryWriter( m_PropDataStream );
            writer.Write( dwData );
        }

        public void AddProperty( ushort wPropTag, ulong qwData )
        {
            if( MsgDefs.XONLINE_MSG_PROP_TYPE_I8 != MsgDefs.XOnlineMessageGetPropType( wPropTag ) )
            {
                throw new ApplicationException( "Setting a non-ulong property type to a ulong value" );
            }

            MessageProperty prop = new MessageProperty();
            prop.wPropTag = wPropTag;
            prop.wPropOffset = (ushort) m_PropDataStream.Length;
            m_alPropDescriptors.Add( prop );

            BinaryWriter writer = new BinaryWriter( m_PropDataStream );
            writer.Write( qwData );
        }

        public void AddProperty( ushort wPropTag, string strData )
        {
            if( MsgDefs.XONLINE_MSG_PROP_TYPE_STRING != MsgDefs.XOnlineMessageGetPropType( wPropTag ) )
            {
                throw new ApplicationException( "Setting a non-string property type to a string value" );
            }

            MessageProperty prop = new MessageProperty();
            prop.wPropTag = wPropTag;
            prop.wPropOffset = (ushort) m_PropDataStream.Length;
            m_alPropDescriptors.Add( prop );

            // New UTF8 encoding, no byte order mark, throw on bad encoding
            UTF8Encoding utf8 = new UTF8Encoding( false, true );

            MessageStringProperty str = new MessageStringProperty();
            str.cbString = (ushort) utf8.GetByteCount( strData );
            str.szString = strData;
            str.WriteStream( m_PropDataStream );
        }

        public void AddProperty( ushort wPropTag, DateTime ftData )
        {
            if( MsgDefs.XONLINE_MSG_PROP_TYPE_FILETIME != MsgDefs.XOnlineMessageGetPropType( wPropTag ) )
            {
                throw new ApplicationException( "Setting a non-time property type to a time value" );
            }

            MessageProperty prop = new MessageProperty();
            prop.wPropTag = wPropTag;
            prop.wPropOffset = (ushort) m_PropDataStream.Length;
            m_alPropDescriptors.Add( prop );

            BinaryWriter writer = new BinaryWriter( m_PropDataStream );
            writer.Write( ftData.ToFileTimeUtc() );
        }

        public void AddProperty( ushort wPropTag, byte[] rgbData )
        {
            if( MsgDefs.XONLINE_MSG_PROP_TYPE_BINARY != MsgDefs.XOnlineMessageGetPropType( wPropTag ) )
            {
                throw new ApplicationException( "Setting a non-binary property type to a binary value" );
            }

            MessageProperty prop = new MessageProperty();
            prop.wPropTag = wPropTag;
            prop.wPropOffset = (ushort) m_PropDataStream.Length;
            m_alPropDescriptors.Add( prop );

            MessageBinaryProperty bin = new MessageBinaryProperty();
            bin.cbData = (ushort) rgbData.Length;
            bin.rgbData = rgbData;
            bin.WriteStream( m_PropDataStream );
        }

        public void AddAttachment( ushort wPropTag, string strStoragePath, uint cbAttachment, uint dwAttachFlags )
        {
            if( MsgDefs.XONLINE_MSG_PROP_TYPE_ATTACHMENT != MsgDefs.XOnlineMessageGetPropType( wPropTag ) )
            {
                throw new ApplicationException( "Setting a non-attachment property type to an attachment value" );
            }

            MessageProperty prop = new MessageProperty();
            prop.wPropTag = wPropTag;
            prop.wPropOffset = (ushort) m_PropDataStream.Length;
            m_alPropDescriptors.Add( prop );

            // New UTF8 encoding, no byte order mark, throw on bad encoding
            UTF8Encoding utf8 = new UTF8Encoding( false, true );

            MessageAttachmentProperty attach = new MessageAttachmentProperty();
            attach.cbAttach = cbAttachment;
            attach.dwAttachFlags = dwAttachFlags;
            attach.cbAttachUrl = (uint) utf8.GetByteCount( strStoragePath );
            attach.szAttachUrl = strStoragePath;
            attach.WriteStream( m_PropDataStream );
        }

        public void AddProperty( ushort wPropTag, bool fData )
        {
            if( MsgDefs.XONLINE_MSG_PROP_TYPE_BOOL != MsgDefs.XOnlineMessageGetPropType( wPropTag ) )
            {
                throw new ApplicationException( "Setting a non-bool property type to a bool value" );
            }

            MessageProperty prop = new MessageProperty();
            prop.wPropTag = wPropTag;
            prop.wPropOffset = fData ? (ushort) 1 : (ushort) 0; // For BOOL types the data is held right in the offset
            m_alPropDescriptors.Add( prop );
        }

        public ushort SetDetails( ref MessageDetails details )
        {
            details.wPropCount = (ushort) m_alPropDescriptors.Count;

            if( 0 != m_alPropDescriptors.Count )
            {
                details.rgProperties = new MessageProperty[ m_alPropDescriptors.Count ];
                for( int iProp = 0; iProp < m_alPropDescriptors.Count; iProp++ )
                {
                    details.rgProperties[ iProp ] = (MessageProperty) m_alPropDescriptors[ iProp ];
                }

                details.rgbData = m_PropDataStream.ToArray();
                details.cbData = (ushort) m_PropDataStream.Length;

                return (ushort) details.Size();
            }
            else
            {
                details.cbData = 0;
                return 0;
            }
        }

        public void SetAuthData( string authdata )
        {
            m_AuthData = authdata;
        }

        public string GetAuthData()
        {
            return m_AuthData;
        }

        private ArrayList m_alPropDescriptors = new ArrayList();
        private MemoryStream m_PropDataStream = new MemoryStream();
        private string m_AuthData;

    } // class CMessage
 
    // Utility class for sending user messages
    public class CUserMessage : CMessage
    {
        public CUserMessage( ulong qwSenderPUID, ulong qwSenderContext, uint dwMessageFlags, uint dwSenderTitleID,
                            ushort wExpireMinutes, byte bMessageType, string strSenderName )
        {
            m_request = new SendMessageMsg();

            m_request.header.sgaddr.inaSg = 0;
            m_request.header.sgaddr.dwSpiSg = 0;
            m_request.header.sgaddr.qwXboxId = 0;
            m_request.header.sgaddr.abReserved = 0;
            m_request.header.dwSeqNum = 0;            

            m_request.qwSenderID = qwSenderPUID;
            m_request.qwSenderContext = qwSenderContext;
            m_request.dwMessageFlags = dwMessageFlags;
            m_request.dwSenderTitleID = dwSenderTitleID;
            m_request.wExpireMinutes = wExpireMinutes;
            m_request.cRecipients = 0;
            m_request.cbDetails = 0;
            m_request.bMessageType = bMessageType;
            m_request.szSenderName = strSenderName;
        
            m_request.details = new MessageDetails();
            m_request.details.wPropCount = 0;
            m_request.details.cbData = 0;
        }

        static public HResult SendUserMessageForGeneratedAccount( ulong userPuid )
        {
            HResult hr = HResult.E_UNEXPECTED;
            uint messageId = Config.GetUIntSetting(Setting.xuacs_WelcomeToXboxLiveMessageForGeneratedAccount);

            if ( 0 != messageId )
            {
                CUserMessage msg = new CUserMessage(
                      0                                     // qwSenderPUID
                    , 0                                     // qwSenderContext
                    , MsgDefs.XONLINE_MSG_FLAG_RECOMMENDED  // dwMessageFlags
                    , XOn.DASH_TITLE_ID                     // dwSenderTitleID
                    , 0                                     // wExpireMinutes = default
                    , MsgDefs.XONLINE_MSG_TYPE_LIVE_MESSAGE // bMessageType
                    , "LIVE System"                         // strSenderName 
                    );

                msg.AddRecipient( userPuid );
                msg.AddProperty( MsgDefs.XONLINE_MSG_PROP_SYSTEM_TEXT, messageId );

                hr = msg.Send();
            }

            return hr;
        }
        
        public void AddRecipient( ulong qwPUID )
        {
            m_alRecipients.Add( qwPUID );
        }

        public void AddRecipients( ulong[] rgqwPUIDs )
        {
            m_alRecipients.AddRange( rgqwPUIDs );
        }

        public SendMessageReply GetResponse()
        {
            return m_response;
        }

        public byte GetMessageType()
        {
            return m_request.bMessageType;
        }

        public ushort GetExpireMinutes()
        {
            return m_request.wExpireMinutes;
        }

        public uint GetSenderTitleId()
        {
            return m_request.dwSenderTitleID;
        }

        public ulong GetSenderId()
        {
            return m_request.qwSenderID;
        }

        public HResult Send()
        {
            ArrayList recipientList = (ArrayList)(m_alRecipients.Clone());

            // If there are no recipients, then there is nothing to send
            if( 0 == m_alRecipients.Count )
            {
                // Nothing to do
                m_response = new SendMessageReply();
                return 0;
            }

            return SendToList( recipientList );
        }


        /// <summary>
        /// Send message to given list of recipients, in batches of 100.
        /// </summary>
        /// 
        /// <param name="recipients">new list of recipients</param>
        /// <returns>HResult for last batch</returns>
        public HResult SendToList(ArrayList recipients)
        {
            return SendToList(recipients, 100);
        }

        /// <summary>
        /// Send message to given list of recipients, in batches with a size determined by the caller.
        /// </summary>
        /// 
        /// <param name="recipients">new list of recipients</param>
        /// <returns>HResult for last batch</returns>
        public HResult SendToList( ArrayList recipients, int batchLength )
        {
            int sent = 0; // messages sent
            
            // If there are no recipients, then there is nothing to send
            if( 0 == recipients.Count )
            {
                // Nothing to do
                m_response = new SendMessageReply();
                return HResult.S_OK;
            }

            HResult hr = HResult.S_OK;

            while( sent < recipients.Count )
            {
                // add the next batch of recipients
                m_request.cRecipients = (ushort)Math.Min(recipients.Count - sent, batchLength);
                m_request.qwRecipientIDs = new ulong[ m_request.cRecipients ]; 
                for( int iRecip = 0; iRecip < m_request.cRecipients; iRecip++ )
                {
                    m_request.qwRecipientIDs[ iRecip ] = (ulong) recipients[ sent + iRecip ];
                }

                hr = SendInternal();

                if (hr.IsFailure())
                {
                    return hr;
                }
                sent += m_request.cRecipients;
            }

            return hr;
        }
        

        private HResult SendInternal()
        {
            // Add any properties
            m_request.cbDetails = SetDetails( ref m_request.details );

            m_response = new SendMessageReply();
            XRLObject2 xrlo = (XRLObject2) m_response;

            HResult hr = XRLUtil.PostXrlRequest( VirtualInterface.xpnfd_messaging_int, "/xpnfront/xmessaging.srf", GetAuthData(), m_request, ref xrlo );

            if (hr.IsFailure())
            {
                return hr;
            }                                    

            return m_response.hr;
        }

        private SendMessageMsg m_request;
        private SendMessageReply m_response;
        private ArrayList m_alRecipients = new ArrayList();

    }; // class CUserMessage

    // Utility class for sending system messages
    public class CSystemMessage : CMessage
    {
        public CSystemMessage( uint dwTitleID, ulong qwSenderContext, uint dwRegion, uint dwMessageFlags, 
                               ushort wExpireMinutes, byte bMessageType, string strSenderName, DateTime dtSentTime,
                               string strDescription )
        {
            m_request = new SendSystemMessageMsg();

            m_request.header.sgaddr.inaSg = 0;
            m_request.header.sgaddr.dwSpiSg = 0;
            m_request.header.sgaddr.qwXboxId = 0;
            m_request.header.sgaddr.abReserved = 0;
            m_request.header.dwSeqNum = 0;            

            m_request.dwTitleID = dwTitleID;
            m_request.qwSenderContext = qwSenderContext;
            m_request.dtSentTime = dtSentTime;
            m_request.dwRegion = dwRegion;
            m_request.dwMessageFlags = dwMessageFlags;
            m_request.wExpireMinutes = wExpireMinutes;
            m_request.cbDetails = 0;
            m_request.bMessageType = bMessageType;
            m_request.szSenderName = strSenderName;
            m_request.szDescription = strDescription;
        
            m_request.details = new MessageDetails();
            m_request.details.wPropCount = 0;
            m_request.details.cbData = 0;
        }

        public SendSystemMessageReply GetResponse()
        {
            return m_response;
        }

        public HResult Send()
        {
            // Add any properties
            m_request.cbDetails = SetDetails( ref m_request.details );

            m_response = new SendSystemMessageReply();
            XRLObject2 xrlo = (XRLObject2) m_response;

            HResult hr = XRLUtil.PostXrlRequest( VirtualInterface.xpnfd_messaging_int, "/xpnfront/xmessaging.srf", GetAuthData(), m_request, ref xrlo );

            if (hr.IsFailure())
            {
                return hr;
            }                                    

            return m_response.hr;
        }

        private SendSystemMessageMsg m_request;
        private SendSystemMessageReply m_response;

    }; // class CSystemMessage

    //
    // Utility wrappers for making Messaging requests and replies as easy as a simple function call
    //
    public class MsgReq
    {
        // These two functions are used internally for all sending of requests.  They allow for overriding this class and
        // using some other sending mechanism besides PostXrlRequest.
        protected virtual HResult SendRequest( string strWho, XOService service, string path, XRLObject2 postOb, ref XRLObject2 respOb )
        {
            return XRLUtil.PostXrlRequest( service, path, postOb, ref respOb );
        }

        protected virtual HResult SendRequest( string strWho, XOService service, string path, XRLObject2 postOb )
        {
            return XRLUtil.PostXrlRequest( service, path, postOb );
        }

        public HResult EnumMessages( ulong qwUserId, out ushort cMessages, out MessageSummary[] rgMessages )
        {
            EnumerateMessagesMsg request = new EnumerateMessagesMsg();
            EnumerateMessagesReply response = new EnumerateMessagesReply();

            // Build the request
            request.qwUserID = qwUserId;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "EnumMessages, user=" + qwUserId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );
            if (hr.IsFailure())
            {
                cMessages = 0;
                rgMessages = null;
                return hr;
            }

            cMessages = response.cMessages;
            rgMessages = response.rgMessages;

            return response.hr;
        }

        public HResult GetMessageSummary( ulong qwUserId, uint dwMessageId, out MessageSummary summary )
        {
            MessageSummaryMsg request = new MessageSummaryMsg();
            MessageSummaryReply response = new MessageSummaryReply();

            // Build the request
            request.qwUserID = qwUserId;
            request.dwMessageID = dwMessageId;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "GetMessageSummary, user=" + qwUserId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );

            if(hr.IsFailure())
            {
                summary = null;
                return hr;
            }

            summary = response.summary;

            return response.hr;
        }

        public HResult GetMessageDetails( ulong qwUserId, uint dwMessageId, uint dwSetFlags, uint dwUnsetFlags, out MessageSummary summary, out MessageDetails details )
        {
            MessageDetailsMsg request = new MessageDetailsMsg();
            MessageDetailsReply response = new MessageDetailsReply();

            // Build the request
            request.qwUserID = qwUserId;
            request.dwMessageID = dwMessageId;
            request.dwSetFlags = dwSetFlags;
            request.dwUnsetFlags = dwUnsetFlags;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "GetMessageDetails, user=" + qwUserId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );

            if(hr.IsFailure())
            {
                summary = null;
                details = null;
                return hr;
            }

            summary = response.summary;
            details = response.details;

            return response.hr;
        }

        public HResult DeleteMessage( ulong qwUserId, uint dwMessageId, uint dwFlags )
        {
            DeleteMessageMsg request = new DeleteMessageMsg();
            DeleteMessageReply response = new DeleteMessageReply();

            // Build the request
            request.qwUserID = qwUserId;
            request.dwMessageID = dwMessageId;
            request.dwFlags = dwFlags;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "DeleteMessage, user=" + qwUserId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );

            if (hr.IsFailure())
            {
                return hr;
            }

            return response.hr;
        }

        public HResult SetMessageFlags( ulong qwUserId, uint dwMessageId, uint dwSetFlags, uint dwUnsetFlags )
        {
            MessageFlagsMsg request = new MessageFlagsMsg();
            MessageFlagsReply response = new MessageFlagsReply();

            // Build the request
            request.qwUserID = qwUserId;
            request.dwMessageID = dwMessageId;
            request.dwSetFlags = dwSetFlags;
            request.dwUnsetFlags = dwUnsetFlags;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "SetMessageFlags, user=" + qwUserId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );

            if (hr.IsFailure())
            {
                return hr;
            }

            return response.hr;
        }

        public HResult SendMessage( 
            ulong qwSenderId, 
            string szSenderName,
            uint dwSenderTitleId,
            ulong qwSenderContext, 
            uint dwMessageFlags,
            ushort wExpireMinutes,
            byte bMessageType,
            ulong[] rgqwRecipients,
            MessageDetails details,
            out RecipientResult[] rgResults )
        {
            SendMessageMsg request = new SendMessageMsg();
            SendMessageReply response = new SendMessageReply();

            // Build the request
            request.qwSenderID = qwSenderId;
            request.qwSenderContext = qwSenderContext;
            request.dwMessageFlags = dwMessageFlags;
            request.dwSenderTitleID = dwSenderTitleId;
            request.wExpireMinutes = wExpireMinutes;
            if( null != details )
            {
                request.cbDetails = (ushort) details.Size();
            }
            request.cRecipients = (ushort) rgqwRecipients.Length;
            request.bMessageType = bMessageType;
            request.szSenderName = szSenderName;
            request.qwRecipientIDs = rgqwRecipients;
            request.details = details;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "SendMessage, sender=" + qwSenderId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );

            if (hr.IsFailure())
            {
                rgResults = null;
                return hr;
            }

            rgResults = response.recipients;

            return response.hr;
        }

        public HResult RevokeMessage( ulong qwSenderId, ulong qwSenderContext, byte bMessageType, RecipientResult[] rgRecipients )
        {
            RevokeMessageMsg request = new RevokeMessageMsg();
            RevokeMessageReply response = new RevokeMessageReply();

            // Build the request
            request.qwSenderID = qwSenderId;
            request.qwSenderContext = qwSenderContext;
            request.cRecipients = (ushort) rgRecipients.Length;
            request.bMessageType = bMessageType;
            request.rgRecipients = rgRecipients;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "RevokeMessage, sender=" + qwSenderId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );

            if (hr.IsFailure())
            {
                return hr;
            }

            return response.hr;
        }

        public HResult RevokeMessageEx(ulong qwSenderId, ulong qwSenderContext, byte bMessageType, uint flags, RecipientResult[] rgRecipients, ushort wPropTag, byte[] rgbProp)
        {
            RevokeMessageExMsg request = new RevokeMessageExMsg();
            RevokeMessageReply response = new RevokeMessageReply();

            // Build the request
            request.qwSenderID = qwSenderId;
            request.qwSenderContext = qwSenderContext;
            request.cRecipients = (ushort)rgRecipients.Length;
            request.bMessageType = bMessageType;
            request.rgRecipients = rgRecipients;
            request.dwFlags = flags;
            request.wPropTag = wPropTag;
            if (rgbProp != null)
            {
                request.cbProp = (ushort)rgbProp.Length;
                request.rgbProp = rgbProp;
            }
            //TODO: fill in other parameters and expand the API in the future.
            
            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest("RevokeMessageEx, sender=" + qwSenderId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo);

            if (hr.IsFailure())
            {
                return hr;
            }

            return response.hr;
        }

        public HResult DeleteUserTitle( ulong qwUserId, uint dwTitleId )
        {
            DeleteTitleMsg request = new DeleteTitleMsg();
            DeleteTitleReply response = new DeleteTitleReply();

            // Build the request
            request.qwUserID = qwUserId;
            request.dwTitleID = dwTitleId;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "DeleteUserTitle, user=" + qwUserId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );

            if (hr.IsFailure())
            {
                return hr;
            }

            return response.hr;
        }

        public HResult EnumUserTitles( ulong qwUserId, out ushort cTitles, out UserTitleData[] rgTitles )
        {
            EnumerateTitlesMsg request = new EnumerateTitlesMsg();
            EnumerateTitlesReply response = new EnumerateTitlesReply();

            // Build the request
            request.qwUserID = qwUserId;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "EnumUserTitles, user=" + qwUserId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );
            
            if (hr.IsFailure())
            {
                cTitles = 0;
                rgTitles = null;
                return hr;
            }

            cTitles = response.cTitles;
            rgTitles = response.rgTitles;

            return response.hr;
        }

        public HResult EnumSystemMessages( uint dwTitleId, out ushort cMessages, out SystemMessageSummary[] rgMessages )
        {
            EnumerateSystemMessagesMsg request = new EnumerateSystemMessagesMsg();
            EnumerateSystemMessagesReply response = new EnumerateSystemMessagesReply();

            // Build the request
            request.dwTitleID = dwTitleId;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "EnumSystemMessages, title=" + dwTitleId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );

            if (hr.IsFailure())
            {
                cMessages = 0;
                rgMessages = null;
                return hr;
            }

            cMessages = response.cMessages;
            rgMessages = response.rgMessages;

            return response.hr;
        }

        public HResult GetSystemMessageDetails( uint dwTitleId, uint dwMessageId, out SystemMessageSummary summary, out MessageDetails details )
        {
            SystemMessageDetailsMsg request = new SystemMessageDetailsMsg();
            SystemMessageDetailsReply response = new SystemMessageDetailsReply();

            // Build the request
            request.dwTitleID = dwTitleId;
            request.dwMessageID = dwMessageId;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "GetSystemMessageDetails, title=" + dwTitleId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );

            if (hr.IsFailure())
            {
                summary = null;
                details = null;
                return hr;
            }

            summary = response.summary;
            details = response.details;

            return response.hr;
        }

        public HResult DeleteSystemMessage( uint dwTitleId, uint dwMessageId, uint dwFlags )
        {
            DeleteSystemMessageMsg request = new DeleteSystemMessageMsg();
            DeleteSystemMessageReply response = new DeleteSystemMessageReply();

            // Build the request
            request.dwTitleID = dwTitleId;
            request.dwMessageID = dwMessageId;
            request.dwFlags = dwFlags;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "DeleteSystemMessage, title=" + dwTitleId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );

            if (hr.IsFailure())
            {
                return hr;
            }

            return response.hr;
        }

        public HResult SendSystemMessage( 
            uint dwTitleId, 
            string szSenderName,
            ulong qwSenderContext, 
            uint dwRegion,
            uint dwMessageFlags,
            ushort wExpireMinutes,
            byte bMessageType,
            DateTime dtSentTime,
            string szDescription,
            MessageDetails details,
            out uint dwMessageID )
        {
            SendSystemMessageMsg request = new SendSystemMessageMsg();
            SendSystemMessageReply response = new SendSystemMessageReply();

            // Build the request
            request.dwTitleID = dwTitleId;
            request.qwSenderContext = qwSenderContext;
            request.dtSentTime = dtSentTime;
            request.dwRegion = dwRegion;
            request.dwMessageFlags = dwMessageFlags;
            request.wExpireMinutes = wExpireMinutes;
            if( null != details )
            {
                request.cbDetails = (ushort) details.Size();
            }
            request.bMessageType = bMessageType;
            request.szSenderName = szSenderName;
            request.szDescription = szDescription;
            request.details = details;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the Messaging front door to hand the request
            HResult hr = SendRequest( "SendSystemMessage, title=" + dwTitleId.ToString(), XOService.MessagingService, "/xpnfront/xmessaging.srf", request, ref xrlo );

            if (hr.IsFailure())
            {
                dwMessageID = 0;
                return hr;
            }

            dwMessageID = response.dwMessageID;

            return response.hr;
        }

    } // class MsgReq

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\presutil.cs ===
using xonline.common.service;

namespace xonline.common.protocol 
{
    //
    // Utility wrappers for making Presence requests and replies as easy as a simple function call
    //
    public class PresReq
    {
        protected virtual HResult SendRequest( string strWho, XOService service, string path, XRLObject2 postOb, ref XRLObject2 respOb )
        {
            return XRLUtil.PostXrlRequest( service, path, postOb, ref respOb );
        }

        protected virtual HResult SendRequest( string strWho, XOService service, string path, XRLObject2 postOb )
        {
            return XRLUtil.PostXrlRequest( service, path, postOb );
        }

        public HResult Alive( ulong qwUserId, 
                                  uint dwTitleId, 
                                  uint dwBuddyListVersion, 
                                  uint dwBlockListVersion, 
                                  uint dwState,            // Must be ( PresDefs.P_STATE_MASK_ONLINE | PresDefs.P_STATE_MASK_CLOAKED )
                                  ulong qwMatchSessionId,  // Must be zero
                                  string szAcctName, 
                                  byte[] rgbTitleStuff,    // Must be null
                                  byte[] rgbNickName,      // Must be null
                                  out uint dwRetBuddyListVersion,
                                  out uint dwRetBlockListVersion,
                                  out ReplyBuddy[] rgReplyBuddies,
                                  out ulong[] rgqwBlockIDs )
        {
            PresenceAliveMsg request = new PresenceAliveMsg();
            PresenceAliveReply response = new PresenceAliveReply();

            // Build the request
            request.qwUserID = qwUserId;
            request.dwTitleID = dwTitleId;
            request.dwBuddyListVersion = dwBuddyListVersion;
            request.dwBlockListVersion = dwBlockListVersion;
            request.dwState = dwState;
            request.qwMatchSessionID = qwMatchSessionId;
            request.szAcctName = szAcctName;
            request.rgbTitleStuff = rgbTitleStuff;
            request.rgbNickName = rgbNickName;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the front door to handle the request
            HResult hr = SendRequest( "Alive, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request, ref xrlo );
            if( HResult.Failed( hr ) )
            {
                dwRetBuddyListVersion = 0;
                dwRetBlockListVersion = 0;
                rgReplyBuddies = null;
                rgqwBlockIDs = null;

                return hr;
            }

            dwRetBuddyListVersion = response.dwBuddyListVersion;
            dwRetBlockListVersion = response.dwBlockListVersion;
            rgReplyBuddies = response.rgReplyBuddies;
            rgqwBlockIDs = response.rgqwBlockIDs;

            return response.hr;
        }

        public HResult Alive2( ulong qwUserId, 
                            uint dwTitleId,
                            XNADDR xnaddr,
                            ulong xnkid,
                            byte[] xnkey, // 16 bytes
                            uint dwBuddyListVersion, 
                            uint dwBlockListVersion, 
                            string szAcctName, 
                            out uint dwRetBuddyListVersion,
                            out uint dwRetBlockListVersion,
                            out ReplyBuddy[] rgReplyBuddies,
                            out ulong[] rgqwBlockIDs )
        {
            PresenceAlive2Msg request = new PresenceAlive2Msg();
            PresenceAliveReply response = new PresenceAliveReply();

            // Build the request
            request.header.sgaddr = xnaddr.sgaddr;
            request.qwUserID = qwUserId;
            request.dwTitleID = dwTitleId;
            request.xnaddr = xnaddr;
            request.xnkid = xnkid;
            request.xnkey = xnkey;
            request.dwBuddyListVersion = dwBuddyListVersion;
            request.dwBlockListVersion = dwBlockListVersion;
            request.szAcctName = szAcctName;

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = response;

            // Call the front door to handle the request
            HResult hr = SendRequest( "Alive2, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request, ref xrlo );
            if( HResult.Failed( hr ) )
            {
                dwRetBuddyListVersion = 0;
                dwRetBlockListVersion = 0;
                rgReplyBuddies = null;
                rgqwBlockIDs = null;

                return hr;
            }

            dwRetBuddyListVersion = response.dwBuddyListVersion;
            dwRetBlockListVersion = response.dwBlockListVersion;
            rgReplyBuddies = response.rgReplyBuddies;
            rgqwBlockIDs = response.rgqwBlockIDs;

            return response.hr;
        }
       
        public HResult DeadUser( ulong qwUserId )
        {
            PresenceDeadUserMsg request = new PresenceDeadUserMsg();

            // Build the request
            request.qwUserID = qwUserId;

            return SendRequest( "DeadUser, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request );
        }

        public HResult State( ulong qwUserId, 
                                  uint dwState,
                                  ulong qwMatchSessionId,
                                  byte[] rgbTitleStuff )
        {
            PresenceStateMsg request = new PresenceStateMsg();

            // Build the request
            request.qwUserID = qwUserId;
            request.dwState = dwState;
            request.qwMatchSessionID = qwMatchSessionId;
            request.rgbTitleStuff = rgbTitleStuff;

            // Call the front door to handle the request
            HResult hr = SendRequest("State, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request);

            return hr;
        }

        public HResult AddFriend( ulong qwUserId,
                                      ulong qwFriendId,
                                      string szFriendAcctName )
        {
            PresenceAddBuddyMsg request = new PresenceAddBuddyMsg();

            // Build the request
            request.qwSenderID = qwUserId;
            request.qwBuddyID = qwFriendId;
            request.szBuddyAcctName = szFriendAcctName;

            // Call the front door to handle the request
            HResult hr = SendRequest("AddFriend, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request);

            return hr;
        }

        public HResult AddFriend2( ulong qwUserId,
                                       ulong qwFriendId,
                                       string szFriendAcctName,
                                       uint dwMessageFlags,
                                       MessageDetails details )
        {
            PresenceAddBuddy2Msg request = new PresenceAddBuddy2Msg();

            // Build the request
            request.qwSenderID = qwUserId;
            request.qwBuddyID = qwFriendId;
            request.szBuddyAcctName = szFriendAcctName;
            request.dwMessageFlags = dwMessageFlags;
            request.cbDetails = (ushort) details.Size();
            request.details = details;

            // Call the front door to handle the request
            HResult hr = SendRequest("AddFriend2, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request);

            return hr;
        }

        public HResult RemoveFriend(ulong qwUserId,
                                         ulong qwFriendId )
        {
            PresenceDeleteBuddyMsg request = new PresenceDeleteBuddyMsg();

            // Build the request
            request.qwUserID = qwUserId;
            request.qwBuddyID = qwFriendId;

            // Call the front door to handle the request
            HResult hr = SendRequest("RemoveFriend, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request);

            return hr;
        }

        public HResult AcceptFriend(ulong qwUserId,
                                         ulong qwFriendId )
        {
            PresenceAcceptBuddyMsg request = new PresenceAcceptBuddyMsg();

            // Build the request
            request.qwUserID = qwUserId;
            request.qwBuddyID = qwFriendId;

            // Call the front door to handle the request
            HResult hr = SendRequest("AcceptFriend, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request);

            return hr;
        }

        public HResult RejectFriend(ulong qwUserId,
                                         ulong qwFriendId,
                                         bool fNever )
        {
            PresenceRejectBuddyMsg request = new PresenceRejectBuddyMsg();

            // Build the request
            request.qwUserID = qwUserId;
            request.qwBuddyID = qwFriendId;
            request.fNever = fNever;

            // Call the front door to handle the request
            HResult hr = SendRequest("RejectFriend, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request);

            return hr;
        }

        public HResult MuteUser(ulong qwUserId,
                                     ulong qwBlockId )
        {
            PresenceMuteUserMsg request = new PresenceMuteUserMsg();

            // Build the request
            request.qwUserID = qwUserId;
            request.qwBlockID = qwBlockId;

            // Call the front door to handle the request
            HResult hr = SendRequest("MuteUser, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request);

            return hr;
        }

        public HResult UnmuteUser(ulong qwUserId,
                                       ulong qwBlockId )
        {
            PresenceUnmuteUserMsg request = new PresenceUnmuteUserMsg();

            // Build the request
            request.qwUserID = qwUserId;
            request.qwBlockID = qwBlockId;

            // Call the front door to handle the request
            HResult hr = SendRequest("UnmuteUser, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request);

            return hr;
        }

        public HResult GameInvite(ulong qwUserId,
                                       uint dwTitleId,
                                       ulong qwMatchSessionId,
                                       ulong[] rgqwInvitees )
        {
            PresenceInviteUserMsg request = new PresenceInviteUserMsg();

            // Build the request
            request.qwUserID = qwUserId;
            request.dwTitleID = dwTitleId;
            request.qwMatchSessionID = qwMatchSessionId;
            request.cInvitees = (ushort) rgqwInvitees.Length;
            request.rgqwInvitees = rgqwInvitees;

            // Call the front door to handle the request
            HResult hr = SendRequest("GameInvite, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request);

            return hr;
        }

        public HResult GameInvite2(ulong qwUserId,
                                        ulong qwSenderContext,
                                        uint dwTitleId,
                                        uint dwMessageFlags,
                                        MessageDetails details,
                                        ulong[] rgqwInvitees )
        {
            PresenceInviteUser2Msg request = new PresenceInviteUser2Msg();

            // Build the request
            request.qwUserID = qwUserId;
            request.qwSenderContext = qwSenderContext;
            request.dwTitleID = dwTitleId;
            request.dwMessageFlags = dwMessageFlags;
            request.cbDetails = (ushort) details.Size();
            request.details = details;
            request.cInvitees = (ushort) rgqwInvitees.Length;
            request.rgqwInvitees = rgqwInvitees;

            // Call the front door to handle the request
            HResult hr = SendRequest( "GameInvite2, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request );

            return hr;
        }

        public HResult CancelGameInvite(ulong qwUserId,
                                             ulong qwMatchSessionId,
                                             ulong[] rgqwInvitees )
        {
            PresenceCancelInviteMsg request = new PresenceCancelInviteMsg();

            // Build the request
            request.qwUserID = qwUserId;
            request.qwMatchSessionID = qwMatchSessionId;
            request.cInvitees = (ushort) rgqwInvitees.Length;
            request.rgqwInvitees = rgqwInvitees;

            // Call the front door to handle the request
            HResult hr = SendRequest("CancelGameInvite, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request);

            return hr;
        }

        public HResult AnswerGameInvite(ulong qwUserId,
                                             ulong qwHostId,
                                             ulong qwMatchSessionId,
                                             ushort wAnswer )
        {
            PresenceAnswerInviteMsg request = new PresenceAnswerInviteMsg();

            // Build the request
            request.qwUserID = qwUserId;
            request.qwHostID = qwHostId;
            request.qwMatchSessionID = qwMatchSessionId;
            request.wAnswer = wAnswer;

            // Call the front door to handle the request
            HResult hr = SendRequest("AnswerGameInvite, user=" + qwUserId.ToString(), XOService.PresNotification, "/xpnfront/xpresence.srf", request);

            return hr;
        }

    } // class PresReq

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\ProofData.cs ===
//------------------------------------------------------------ 
// Copyright (c) Microsoft Corporation. All rights reserved. 
//------------------------------------------------------------ 

using xonline.common.service;

namespace xonline.common.protocol
{
    public class ProofData : WireData
    {
        /// <summary>
        /// Enumeration detailing the type of the strong proof
        /// </summary>
        public ProofTypeEnum proofType;

        /// <summary>
        /// Protocol element to hold the length of the string
        /// </summary>
        [WireInfo(Max = XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort proofDataLength;

        /// <summary>
        /// The actual data of the strong proof.
        /// </summary>
        [WireInfo(SizeParam = "proofDataLength")]
        public string proofData;
    }

    public class ProofStatus : ProofData
    {
        /// <summary>
        /// Flag to state if the strong proof has already been confirmed
        /// </summary>
        public bool isConfirmed;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\ProofTypeEnum.cs ===
//------------------------------------------------------------ 
// Copyright (c) Microsoft Corporation. All rights reserved. 
//------------------------------------------------------------ 

namespace xonline.common.protocol
{
    public enum ProofTypeEnum : byte
    {
        /// <summary>
        /// A telephone number capable of accepting text messages.
        /// </summary>
        SMS = 1,

        /// <summary>
        /// This proof is an alternative email address to the membername
        /// </summary>
        Email = 2

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\queryprot.cs ===
/*==========================================================================
 *
 *  xqrywire.cs -- This module defines the wire protocol for query service apis
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Serialization;
using xonline.common.service;


namespace xonline.common.protocol 
{

    //
    // Base data for QueryATtribute. This class is used for serialization and deserialization via XML
    // 
    public class QueryAttribute : WireData
    {
        public QueryAttribute() { }
        public QueryAttribute(uint id)
        {
            Id = id;
        }    
        public QueryAttribute(uint id, long l)
        {
            Id = id;
            lValue = l;
        }    
        public QueryAttribute(uint id, string str)
        {
            Id = id;
            strValue = str;
        }    
        public QueryAttribute(uint id, byte[] b)
        {
            Id = id;
            binValue = b;
        }    
        
        
        
        //
        // Data exposed to SOAP
        //
        [XmlAttribute]
        public uint Id;

        public object Value
        {
            get { return _value; }
            set { _value = value; } 
        }       


        //
        // Strongly typed accessors
        //
        [XmlIgnore]
        public long lValue
        {
            get { return (long)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public string strValue
        {
            get { return (string)_value; }
            set { _value = value; } 
        }
        [XmlIgnore]
        public byte[] binValue
        {
            get { return (byte[])_value; }
            set { _value = value; } 
        }
        

        //
        // Private data
        //
        protected object _value;
        
        
        //
        // Override default implementations of WireData methods for this class
        //
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            int     len;
            
            Id = (uint)binaryReader.ReadInt32();          
            
            len = binaryReader.ReadInt32();

            switch(Id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
            {
            case XOn.X_ATTRIBUTE_DATATYPE_INTEGER:
                lValue = binaryReader.ReadInt64();
                break;
            
            case XOn.X_ATTRIBUTE_DATATYPE_STRING:
                strValue = Encoding.UTF8.GetString(binaryReader.ReadBytes(len));
                break;
                
            case XOn.X_ATTRIBUTE_DATATYPE_BLOB:
                binValue = binaryReader.ReadBytes(len);
                break;
            
            default:
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.QUERY_BAD_PARAMETER, 
                    "Unrecgonized datatype: 0x" + (Id & XOn.X_ATTRIBUTE_DATATYPE_MASK).ToString("x") + "! attribute id: " + Id);
            }

			return this;                                
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {            
            binaryWriter.Write(Id);
                
            switch(Id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
            {
            case XOn.X_ATTRIBUTE_DATATYPE_INTEGER:
                binaryWriter.Write((int)8);
                binaryWriter.Write(lValue);
                break;
                
            case XOn.X_ATTRIBUTE_DATATYPE_STRING:
                {
                    byte[] buf;
                    
                    buf = Encoding.UTF8.GetBytes(strValue);
                    binaryWriter.Write((int)buf.Length);
                    
                    //
                    // In .Net 2.0, attempting to write a 0 byte
                    // array to the HttpResponse stream results
                    // in an ArgumentOutOfRangeException thrown.
                    // As a result, a WireData object with an empty
                    // string as a member would fail to be written.
                    //
                    if (buf.Length > 0)
                    {
                        binaryWriter.Write(buf);
                    }
                }
                break;
                
            case XOn.X_ATTRIBUTE_DATATYPE_BLOB:
                binaryWriter.Write(binValue.Length);
                binaryWriter.Write(binValue);
                break;
            
            default:
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.QUERY_BAD_PARAMETER_1, 
                    "Unexpected datatype: 0x" + (Id & XOn.X_ATTRIBUTE_DATATYPE_MASK).ToString("x") + "! attribute id: " + Id);
            }
        }


        // 
        // Provide a formatted ToString method so that we can get good debug output in exceptions/events/logs
        //
        public override string ToString(int indent)
        {
            StringBuilder str = new StringBuilder();
            
            str.Append("\n" + "".PadLeft(indent) + "Id" + "=0x" + Id.ToString("x8"));                
            str.Append("\n" + "".PadLeft(indent) + "Value" + "=");
                
            switch(Id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
            {
            case XOn.X_ATTRIBUTE_DATATYPE_INTEGER:
                str.Append(lValue);
                break;
                
            case XOn.X_ATTRIBUTE_DATATYPE_STRING:
                str.Append(strValue);
                break;
                
            case XOn.X_ATTRIBUTE_DATATYPE_BLOB:
                str.Append(ByteConvert.ToString(binValue));                    
                break;
            }
            
            return str.ToString();
        }
        
    }

    
    //
    // Structure Representing a single message property. 
    //  Maps to _XONLINE_ATTRIBUTE_SPEC, XONLINE_ATTRIBUTE_SPEC, *PXONLINE_ATTRIBUTE_SPEC in xonline.x
    //  
    public class QueryAttributeSpec : XRLObject2
    {
        public QueryAttributeSpec() { }
        public QueryAttributeSpec(uint id)
        {
            type = id;
        }    
        public QueryAttributeSpec(uint id, uint maxlen)
        {
            type = id;
            len = maxlen;
        }    
        
        
        [SoapElement(ElementName="type")]
        [WireInfo(HexString=true)]
        public uint type;

        [SoapElement(ElementName="len")]
        public uint len;
    }
    
    public class AddRequest : XRLObject2
    {
        public uint titleId;
        public ulong userId;
        public ulong teamId;
        public uint datasetId;
        
        [WireInfo(Max=XOn.XONLINE_QUERY_MAX_ATTRIBUTES)]
        public uint attribCount;

        [WireInfo(SizeParam="attribCount")]        
        public QueryAttribute[] attribs;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/xqry/Add.ashx";
            }
        }
    }
    
    

    public class AddResponse : XRLObject2
    {
        public ulong entityId;
    }
    
    
    public class SearchRequest : XRLObject2
    {
        public uint titleId;
        public uint datasetId;
        public uint procIndex;
        public uint page;
        public uint resultsPerPage;
        
        [WireInfo(Max=XOn.XONLINE_QUERY_MAX_SPECS)]
        public uint specCount;
        
        [WireInfo(Max=XOn.XONLINE_QUERY_MAX_ATTRIBUTES)]
        public uint attribCount;        

        [WireInfo(SizeParam="specCount")]        
        public QueryAttributeSpec[] specs;

        [WireInfo(SizeParam="attribCount")]        
        public QueryAttribute[] attribs;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/xqry/Search.ashx";
            }
        }        
    }

    
    public class SearchResponse : XRLObject2
    {
        public uint totalResults;
        public uint returnedResults;        // Number of "rows"
        
        public uint attribCount;            // Total attributes        

        [WireInfo(SizeParam="attribCount")]        
        public QueryAttribute[] attribs;
    }

    
    public class FindFromIdsRequest : XRLObject2
    {
        public uint titleId;
        public uint datasetId;
        public uint procIndex;
        
        [WireInfo(Max=XOn.XONLINE_QUERY_MAX_SPECS)]
        public uint specCount;
        
        [WireInfo(Max=10)]
        public uint idCount;

        [WireInfo(SizeParam="specCount")]        
        public QueryAttributeSpec[] specs;

        [WireInfo(SizeParam="idCount")]        
        public ulong[] entityIds;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/xqry/FindFromIds.ashx";
            }
        }
        
    }
    
    
    public class FindFromIdsResponse : XRLObject2
    {
        public uint returnedResults;

        public uint attribCount;            // Total attributes        

        [WireInfo(SizeParam="attribCount")]        
        public QueryAttribute[] attribs;
    }
    
    
    
    public class RemoveRequest : XRLObject2
    {
        public uint titleId = 0;
        public ulong userId = 0;
        public ulong teamId = 0;
        public uint datasetId = 0;
        public uint procIndex = 0;
        
        [WireInfo(Max=XOn.XONLINE_QUERY_MAX_ATTRIBUTES)]
        public uint attribCount;

        [WireInfo(SizeParam="attribCount")]        
        public QueryAttribute[] attribs;

        
        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/xqry/Remove.ashx";
            }
        }                
    }


    public class RemoveIdRequest : XRLObject2
    {
        public uint titleId = 0;
        public ulong userId = 0;
        public ulong teamId = 0;
        public uint datasetId = 0;
        public ulong entityId = 0;


        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/xqry/RemoveId.ashx";
            }
        }
    }

    
    public class SelectRequest : XRLObject2
    {
        public uint titleId;
        public ulong userId;
        public ulong teamId;
        public uint datasetId;
        public ulong entityId;
        public uint actionId;
        
        [WireInfo(Max=XOn.XONLINE_QUERY_MAX_ATTRIBUTES)]
        public uint attribCount;

        [WireInfo(SizeParam="attribCount")]        
        public QueryAttribute[] attribs;


        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/xqry/Select.ashx";
            }
        }
    }

    public class UpdateRequest : XRLObject2
    {
        public uint titleId;
        public ulong userId;
        public ulong teamId;
        public uint datasetId;
        public uint procIndex;        
        
        [WireInfo(Max=XOn.XONLINE_QUERY_MAX_ATTRIBUTES)]
        public uint attribCount;

        [WireInfo(SizeParam="attribCount")]        
        public QueryAttribute[] attribs;


        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/xqry/update.ashx";
            }
        }        
    }
    
    public class UpdateIdRequest : XRLObject2
    {
        public uint titleId;
        public ulong userId;
        public ulong teamId;
        public uint datasetId;
        public uint procIndex;
        public ulong entityId;
        
        [WireInfo(Max=XOn.XONLINE_QUERY_MAX_ATTRIBUTES)]
        public uint attribCount;

        [WireInfo(SizeParam="attribCount")]        
        public QueryAttribute[] attribs;


        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/xqry/UpdateId.ashx";
            }
        }        
    }
    
    public class QueryTimeWarpRequest : XRLObject2
    {
        public long offsetSeconds;


        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/xqry/timewarp.ashx";
            }
        }
    }

    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\StorageConstants.cs ===
/*
 * Copyright (c) 2003 Microsoft Corporation
 * 
 * Storage 
 * 
 * StorageConstants.cs
 * 
 * Protocol stuff
 * 
 * */


namespace xonline.common.protocol 
{
    // Protocol Constants
    public class ProtocolConstants
    {
        public const int    sizeSignature           = 100;
        public const int    sizeHash                = 20;
        public const int    maxSizeAttributes       = 256;
        public const int    maxSizeName             = 255;
        public const int    maxSizeDomain           = 63;
        public const ushort accessTokenVersion      = 1;
        public const int    sizeAccessTokenBase     = 48 + sizeSignature;
        public const int    maxAccessTokenSize      = sizeAccessTokenBase + maxSizeName;
        public const int    syncDomainReservedSize  = 64;
        public const int    maxStorageOperations    = 100;
        
        // Temporary constants. Have to transform them into configurable 
        // settings at some point.
        public const int        maxFileSize     = 10*1024*1024;
        public const string     wstStoreApp     = "StoreDb";

        public const string     AvatarDomainName = "avatar";

    }



    // Storage Operations
    public enum Operation
    {
        Undefined               = 0,
        FileWrite               = 1,
        FileRead                = 2,
        FileRemove              = 3,
        FileEnumerate           = 4,
        FileEnumeratedRead      = 5,
        ReadTitleFiles          = 6
    }

    public enum Allowed: uint
    {
        None                    = 0,
        All                     = 1,
        Owner                   = 2,
        Team                    = 4,
        UserToken               = 8,
        ServiceToken            = 16,
        ServiceAddr             = 32
    }


    // Each of these enumerations is represented by a uint and each should
    // always have an Invalid member that is defined as 1 greater than the
    // the last legal value.  This allows validation to easily be done and
    // not require changes when new legal values are added.

    // Identity Types
    public enum IdType: uint
    {
        Undefined       = 0,
        UserId          = 1,
        GroupId         = 2,
        TournamentId    = 3,
        TitleId         = 4,
        Invalid         = 5
    }

    // Storage Content Types
    public enum ContentType: uint
    {
        ContentPackage          = 0,
        ContentBlob             = 1,
        Invalid                 = 2 
    }

    // Storage Compression Types
    public enum CompressionType: uint
    {
        Uncompressed            = 0,
        NoCompression           = 1,
        LZX                     = 2,
        Invalid                 = 3
    }

    // Storage Flag Types
    public enum FlagType: uint
    {
        TeamTicket              = 1
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\sgprot.cs ===
// 
// SgProt.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// SG Service Integration
// Xbox Online Service
// 
// Author: phansen
//

using System.IO;
using xonline.common.service;
using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.SGProxy)]


namespace xonline.common.protocol 
{
    public class SgDefs
    {
        public const int XONLINE_MAX_LOGON_USERS                = 4;
        public const int XONLINE_MAX_ALTERNATE_TITLE_ID         = 4;
        public const int XONLINE_KEY_LENGTH                     = 16;
        public const int XONLINE_NUM_PRIVILEGE_DWORDS           = 8;
        public const int XONLINE_MAX_DWORD_SERVICEIDS           = 4;
    }

    //
    // Structure Representing the SGADDR info
    //  Maps to SGADDR in xonline.x
    //  
    public class SGADDR : WireData
    {
        public uint                 inaSg;
        public uint                 dwSpiSg;
        public ulong                qwXboxId;
        public uint                 abReserved;
        
        /// <summary
        /// Function to Compare this to another SGADDR
        /// Could be part of IEquatable but don't know
        /// how that works with serialization.
        /// Returns true if the two are equal.
        /// </summary>
        public bool IsEqual(SGADDR sgaddr)
        {
            return (inaSg == sgaddr.inaSg && dwSpiSg == sgaddr.dwSpiSg && 
                    qwXboxId == sgaddr.qwXboxId && abReserved == sgaddr.abReserved);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(inaSg);
            binaryWriter.Write(dwSpiSg);
            binaryWriter.Write(qwXboxId);
            binaryWriter.Write(abReserved);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                inaSg = (uint)binaryReader.ReadInt32();
                dwSpiSg = (uint)binaryReader.ReadInt32();
                qwXboxId = (ulong)binaryReader.ReadInt64();
                abReserved = (uint)binaryReader.ReadInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_24, 
                    "Reached end of stream trying to read SGADDR", e);
            }
            return this;
        }
    }

    public class XBOX_LIBRARY_VERSION : WireData
    {
        public ushort               wMajorVersion;
        public ushort               wMinorVersion;
        public ushort               wBuildNumber;
        public ushort               wQFENumber;

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(wMajorVersion);
            binaryWriter.Write(wMinorVersion);
            binaryWriter.Write(wBuildNumber);
            binaryWriter.Write(wQFENumber);
         }

    }

    public class XUID : WireData
    {
        public ulong                qwUserId;                   // or qwTeamId
        public uint                 dwUserFlags;                // The high 16 bits should come from the UODB User Table.
    }

    public enum SG_MSG_TYPES : ushort
    {
        // Definitions (0x47 is 'G') ---------------------------------------------------------
        SGMSG_TYPE_KICK_REQ         = 0x4705,  // CSgMsgKickReq
        SGMSG_TYPE_KICK_REP         = 0x4706,  // CSgMsgKickRep
        SGMSG_TYPE_XBTOXB_FORWARD   = 0x470A,  // CSgMsgXbToXbForward
        SGMSG_TYPE_SET_QVALS_LAZY   = 0x470B,  // CSgMsgSetQValsReq
        SGMSG_TYPE_SET_QVALS_PUSH   = 0x470C,  // CSgMsgSetQValsReq
        SGMSG_TYPE_SET_QVALS_REP    = 0x470D,  // CSgMsgSetQValsRep
        SGMSG_TYPE_SPIDATA_REQ      = 0x4710,  // CSgMsgSpiReq
        SGMSG_TYPE_SPIDATA_REP      = 0x4711,  // CSgMsgSpiRep
        SGMSG_TYPE_NOTIFY_CLI_DEL   = 0x4712,  // CSgMsgNotifyCliDelete
        SGMSG_TYPE_NOTIFY_CLI_UPD   = 0x4713,  // CSgMsgNotifyCliUpdate
        SGMSG_TYPE_NOTIFY_CLI_TCHG  = 0x4714,  // CSgMsgNotifyCliTitleChange
        SGMSG_TYPE_XBTOXB_FORWARD2  = 0x4715,  // CSgMsgXbToXbForward2
        SGMSG_TYPE_SPIDATA_REQ2     = 0x4716,  // CSgMsgSpiReq2 

        SGMSG_TYPE_SPIDATA          = 0x4782,  // CSgMsgSpiData in the payload
        SGMSG_TYPE_AUTHDATA         = 0x4783,  // CAuthData in the payload
    }

    // Base class that other SG messages derive from
    //
    public class CSgMsgHdr : WireData
    {
        // WireData requires a default constructor with no args for deserialization, so this must exist
        public CSgMsgHdr()
        {
        }
        
        // When creating WireData headers to serialize, it's convenient to set the type automagically
        public CSgMsgHdr( SG_MSG_TYPES msgType, ushort size )
        {
            _wType = (ushort) msgType;
            _cbEnt = size;
        }

        public ushort           _wType;                         // See SGMSG_TYPE_* above
        public ushort           _cbEnt;                         // Size of this entry (including header)

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                _wType = (ushort)binaryReader.ReadInt16();
                _cbEnt = (ushort)binaryReader.ReadInt16();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_25, 
                    "Reached end of stream trying to read CSgMsgHdr", e);
            }
            return this;
        }

    }

    public class CAuthData : WireData
    {
        public CAuthData()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_AUTHDATA, 218 );
            wAuthDataVersion = 3;
            wAuthDataSize = 214;
        }

        public CSgMsgHdr            header;
        public ushort               wAuthDataVersion;
        public ushort               wAuthDataSize;
        public XBOX_LIBRARY_VERSION clientVersion;
        public uint                 dwTitleID;
        public uint                 dwTitleVersion;
        public uint                 dwTitleRegion;
        public uint                 dwConsoleRegion;
        public uint                 dwMediaID;
        public uint                 dwLanguageID;
        public uint                 dwAuthDataFlags;
        public ushort               wNumPrivileges;
        [WireInfo(ArraySize=SgDefs.XONLINE_NUM_PRIVILEGE_DWORDS)]
        public uint[]               dwPrivileges;
        public ulong                qwXboxID;
        [WireInfo(ArraySize=SgDefs.XONLINE_MAX_LOGON_USERS)]
        public XUID[]               users;
        [WireInfo(ArraySize=SgDefs.XONLINE_MAX_LOGON_USERS)]
        public float[]              afltTrustFactor;
        public uint                 wNumDwordServices;
        [WireInfo(ArraySize=SgDefs.XONLINE_MAX_DWORD_SERVICEIDS)]
        public uint[]               dwServiceID;
        [WireInfo(ArraySize=SgDefs.XONLINE_MAX_ALTERNATE_TITLE_ID)]
        public uint[]               dwAltTitleID;
        [WireInfo(ArraySize=SgDefs.XONLINE_KEY_LENGTH)]
        public byte[]               abKey;
    }

    public class CSgMsgSpiData : WireData
    {
        public CSgMsgSpiData()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_SPIDATA, 54 );
        }

        public CSgMsgHdr            header;
        public ushort               _ipportI;                   // IP port of the client on the Internet
        public uint                 _ipaI;                      // IP address of the client on the Internet
        public SGADDR               _sgaddr;                    // SGADDR of the client
        public ushort               _wVersionKeyEx;             // KeyEx version of the client
        public ushort               _wFlagsKeyEx;               // Flags sent in KeyEx initiator
        public long                 _liNonce;                   // A random nonce associated with this session
        public long                 _liTimeInit;                // FILETIME marking session initiation
        public uint                 _fCs;                       // TRUE if SG is providing connection services
    }

    public class CSgMsgSpiReq : WireData
    {
        public CSgMsgSpiReq()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_SPIDATA_REQ, 14 );
        }

        public CSgMsgHdr            header;
        public uint                 _dwReqNum;                  // Request number from requester
        public uint                 _ipaZ;                      // IP address of the client on the DMZ
        public ushort               _ipportZ;                   // IP port of the client on the DMZ
    }

    public class CSgMsgSpiReq2 : WireData
    {
        public CSgMsgSpiReq2()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_SPIDATA_REQ2, 16 );
        }

        public CSgMsgHdr            header;
        public uint                 _dwReqNum;                  // Request number from requester
        public uint                 _ipaZ;                      // IP address of the client on the DMZ
        public ushort               _ipportZ;                   // IP port of the client on the DMZ
        public ushort               _wAuthDataVersion;          // Maximum supported authdata version
    }

    public class CSgMsgSpiRep : WireData
    {
        public CSgMsgSpiRep()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_SPIDATA_REP, 15 );
        }

        public CSgMsgHdr            header;
        public uint                 _dwReqNum;                  // Copy of _dwReqNum from request
        public uint                 _ipaZ;                      // IP address of the client on the DMZ
        public ushort               _ipportZ;                   // IP port of the client on the DMZ
        public bool                 _fNotFound;                 // TRUE if client not found (no auth-data enclosed)

        [WireInfo(Serialize=false)]
        public CSgMsgSpiData        _spiData;                   // only present if _fNotFound is FALSE

        [WireInfo(Serialize=false)]
        public CAuthData            _authData;

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            if( !_fNotFound )
            {
                _spiData = new CSgMsgSpiData();
                _spiData.ReadStream( binaryReader );
                _authData = new CAuthData();
                _authData.ReadStream( binaryReader );
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            base.WriteStream( binaryWriter );

            if( !_fNotFound )
            {
                _spiData.WriteStream( binaryWriter );
                _authData.WriteStream( binaryWriter );
            }
        }
    }

    public class CSgMsgSetQValsReq : WireData
    {
        public CSgMsgSetQValsReq()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_SET_QVALS_LAZY, 36 );
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr;                    // SGADDR of the client
        public ulong                _qwUserId;                  // User id of the user
        public uint                 _dwContext;                 // Sender's context to be returned in reply

        // The rest of this entry contains a packed series of CQVal structures.
        [WireInfo(Serialize=false)]
        public uint[]               _qvals;

        public void SetPush()
        {
            header._wType = (ushort) SG_MSG_TYPES.SGMSG_TYPE_SET_QVALS_PUSH;
        }

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            if( header._cbEnt > 36 )
            {
                ushort cbQVals = (ushort)( header._cbEnt - 36 );
                ushort cQVals = (ushort)( cbQVals / 4 );
                _qvals = new uint[ cQVals ];
                for( int iQVal = 0; iQVal < cQVals; iQVal++ )
                {
                    _qvals[ iQVal ] = binaryReader.ReadUInt32();
                }
            }
            else
            {
                // Make _qvals.Length valid even when there aren't any
                _qvals = new uint[ 0 ];
            }

            return this;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            header._cbEnt = (ushort)(36 + (_qvals.Length * 4));
            base.WriteStream(binaryWriter);
            for (int iQVal = 0; iQVal < _qvals.Length; iQVal++)
            {
                binaryWriter.Write(_qvals[iQVal]);
            }
        }
    }

    public class CSgMsgSetQValsRep : WireData
    {
        public CSgMsgSetQValsRep()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_SET_QVALS_REP, 38 );
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr;                    // SGADDR of the client
        public ulong                _qwUserId;                  // User id of the user
        public uint                 _dwContext;                 // Sender's context from corresponding request
        public bool                 _fNotFound;                 // TRUE if client not found
        public bool                 _fNoSuchUser;               // TRUE if SG doesn't know about qwUserId
    }

    public class CSgMsgKickReq : WireData
    {
        public CSgMsgKickReq()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_KICK_REQ, 24 );
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr;                    // SGADDR of the client to kick
    }

    public class CSgMsgKickRep : WireData
    {
        public CSgMsgKickRep()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_KICK_REP, 25 );
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr;                    // SGADDR of the client that was kicked
        public bool                 _fNotFound;                 // TRUE if client not found
    }

    public class CSgMsgXbToXbForward : WireData
    {
        public CSgMsgXbToXbForward()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_XBTOXB_FORWARD, 24 );
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr;                    // SGADDR of the target client

        // The rest of this entry contains the actual message being forwarded.
    }

    // If _sgaddr._dwSpiSg and _sgaddr._qwXboxId are zero, then the whole SG is going offline
    public class CSgMsgNotifyCliDelete : XRLObject2
    {
        public CSgMsgNotifyCliDelete()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_NOTIFY_CLI_DEL, 28 );
            _sgaddr = new SGADDR();
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr;                    // SGADDR of the client that is going offline
        public uint                 _dwTitleId;                 // The title the client was last in

        public override int Size()
        {
            return 28;
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                header = new CSgMsgHdr();
                header.ReadStream(binaryReader);
                _sgaddr = new SGADDR();
                _sgaddr.ReadStream(binaryReader);
                _dwTitleId = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_26, 
                    "Reached end of stream trying to read CSgMsgNotifyCliDelete", e);
            }
            return this;
        }
    }

    public class CSgMsgNotifyCliUpdate : XRLObject2
    {
        public CSgMsgNotifyCliUpdate()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_NOTIFY_CLI_UPD, 310 );
            _sgaddr = new SGADDR();
            _rgbTitleData = new byte[ 256 ];
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr; // SGADDR of the client that was updated
        public ulong                _qwUserId;
        public ulong                _qwXnkid;
        public uint                 _dwAuthFlags;
        public uint                 _dwState;
        public uint                 _dwTitleId;
        public ushort               _cbTitleData;

        [WireInfo(ArraySize=256)]
        public byte[]               _rgbTitleData;

        public override int Size()
        {
            return 310;
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                header = new CSgMsgHdr();
                header.ReadStream(binaryReader);
                _sgaddr = new SGADDR();
                _sgaddr.ReadStream(binaryReader);
                _qwUserId = binaryReader.ReadUInt64();
                _qwXnkid = binaryReader.ReadUInt64();
                _dwAuthFlags = binaryReader.ReadUInt32();
                _dwState = binaryReader.ReadUInt32();
                _dwTitleId = binaryReader.ReadUInt32();
                _cbTitleData = binaryReader.ReadUInt16();
                _rgbTitleData = binaryReader.ReadBytes(256);
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_27, 
                    "Reached end of stream trying to read CSgMsgNotifyCliUpdate", e);
            }
            return this;
        }
    }

    public class CSgMsgNotifyCliTitleChange : XRLObject2
    {
        public CSgMsgNotifyCliTitleChange()
        {
            header = new CSgMsgHdr( SG_MSG_TYPES.SGMSG_TYPE_NOTIFY_CLI_TCHG, 32 );
            _sgaddr = new SGADDR();
        }

        public CSgMsgHdr            header;
        public SGADDR               _sgaddr;
        public uint                 _dwOldTitleId;
        public uint                 _dwNewTitleId;

        public override int Size()
        {
            return 32;
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            try
            {
                header = new CSgMsgHdr();
                header.ReadStream(binaryReader);
                _sgaddr = new SGADDR();
                _sgaddr.ReadStream(binaryReader);
                _dwOldTitleId = (uint)binaryReader.ReadInt32();
                _dwNewTitleId = (uint)binaryReader.ReadInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM,
                    XEvent.Id.COMMON_HACK_28, 
                    "Reached end of stream trying to read SGADDR", e);
            }
            return this;
        }

    }

} // namespace xonline.common.protocol
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\RateMediaProtocol.cs ===
using System;
using xonline.common.service;

namespace xonline.common.protocol 
{
    /// <summary>
    /// Wire Data Rate Media Request class
    /// </summary>
    public class RateMediaRequest : XRLObject2
    {
        public Guid mediaId;
        
        public int ratingValue;

        [WireInfo(HexString=true)]
        public ulong userXuid;

        public byte userCountryId;
       
        //TODO: url subjected to change
        public override string Xrl
        {
            get { return "/ratings/submitrating.ashx"; }
        }
    }

    public class GetRatingRequest : XRLObject2
    {
        public Guid mediaId;

        [WireInfo(HexString=true)]
        public ulong userXuid;

        public byte userCountryId;
        
        //TODO: url subjected to change
        public override string Xrl
        {
            get { return "/ratings/getrating.ashx"; }
        }
    }
    
    public class GetRatingResponse : XRLObject2
    {
        public int userValue;
        
        public double ratingsAverage;
        
        public int ratingsCount;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\stringprot.cs ===
// 
// StringProt.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// String Service Protocol Definitions
// Xbox Online Service
// 
// Author: masonb
//

using System;
using xonline.common.service;
using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.StringProxy)]


namespace xonline.common.protocol 
{    
    //
    // String definitions
    //
    public class StringDefs
    {
        public const uint MAX_STRINGSVR_STRING_LEN                    = 512; // characters
    };
    
    //
    // Structure representing a request to look up a string from the String Service.  If
    //  the string exists, but not in the requested language, the string for the default 
    //  language will be returned.
    //  
    public class StringLookupRequest : XRLObject2
    {
        public uint             dwTitleID;
        public ushort           wLanguage;
        public ushort           wNumStrings;

        [WireInfo(SizeParam="wNumStrings")]
        public uint[]           rgdwStringIDs;

        public override string Xrl
        {
            get
            {
                return "/msgserver/getstring.ashx";
            }
        }
    };

    public class StringLookup2Request : XRLObject2
    {
        public uint             dwTitleID;
        public ushort           wNumStrings;
        public ushort           wLocaleLen;

        [WireInfo(SizeParam="wLocaleLen")]
        public string           szLocale;

        [WireInfo(SizeParam="wNumStrings")]
        public uint[]           rgdwStringIDs;

        public override string Xrl
        {
            get
            {
                return "/msgserver/getstring2.ashx";
            }
        }
    };

    public class StringData : WireData
    {
        public ushort           wStringSize;

        [WireInfo(SizeParam="wStringSize")]
        public string           szString;
    };

    public class StringLookupResponse : XRLObject2
    {
        public ushort           wNumStrings;
      
        [WireInfo(SizeParam="wNumStrings")]
        public StringData[]     rgStringData;
    };

    //
    // Structure representing a string in a single language.
    //  
    public class LanguageString : WireData
    {
        public ushort           wLanguage;
        public ushort           wStringSize;

        [WireInfo(SizeParam="wStringSize")]
        public string           szString;
    }

    public class LocaleString : WireData
    {
        public ushort           wLocaleLen;
        public ushort           wStringSize;

        [WireInfo(SizeParam="wLocaleLen")]
        public string           szLocale;
        
        [WireInfo(SizeParam="wStringSize")]
        public string           szString;
    }

    //
    // Structure representing a request to add a new string to the String Service.  Strings
    //  are specified in one or more languages with one language being chosen as the default
    //  language to return if a string is requested in an unknown language.
    //  
    public class StringAddRequest : XRLObject2
    {
        public uint             dwTitleID;
        public uint             dwStringID;         // Use 0xFFFFFFFF to have the service pick an available ID
        public DateTime         dtExpire;
        public ushort           wDefaultLanguage;
        public byte             cLangStrings;
        public bool             fVetText;

        [WireInfo(SizeParam="cLangStrings")]
        public LanguageString[] rgLangStrings;

        public override string Xrl
        {
            get
            {
                return "/msgserver/addstring.ashx";
            }
        }
    };

    public class StringAddResponse : XRLObject2
    {
        public uint             dwStringID;
    };

    public class StringAdd2Request : XRLObject2
    {
        public uint             dwTitleID;
        public uint             dwStringID;         // Use 0xFFFFFFFF to have the service pick an available ID
        public DateTime         dtExpire;
        public ushort           wLocaleLen;
        public byte             cLocaleStrings;
        public bool             fVetText;

        [WireInfo(SizeParam="wLocaleLen")]
        public string           szDefaultLocale;
        
        [WireInfo(SizeParam="cLocaleStrings")]
        public LocaleString[]   rgLocaleStrings;

        public override string Xrl
        {
            get
            {
                return "/msgserver/addstring2.ashx";
            }
        }
    };

    public class StringAdd2Response : XRLObject2
    {
        public uint             dwStringID;
        public ushort           wNumStrings;

        [WireInfo(SizeParam="wNumStrings")]
        public uint[]           rghrString;
    };


    //
    // Structure representing a request to vet a particular string for profanity.
    //  
    public class StringVetRequest : XRLObject2
    {
        public uint             dwTitleID;
        public ushort           wLanguage;
        public ushort           wNumStrings;
      
        [WireInfo(SizeParam="wNumStrings")]
        public StringData[]     rgStringData;

        public override string Xrl
        {
            get
            {
                return "/msgserver/vetstring.ashx";
            }
        }
    };

    public class StringVet2Request : XRLObject2
    {
        public uint             dwTitleID;
        public uint             dwFlags;
        public ushort           wLocaleLen;
        public ushort           wNumStrings;
      
        [WireInfo(SizeParam="wLocaleLen")]
        public string           szLocale;
        
        [WireInfo(SizeParam="wNumStrings")]
        public StringData[]     rgStringData;

        public override string Xrl
        {
            get
            {
                return "/msgserver/vetstring2.ashx";
            }
        }
    };
    
    public class StringVetResponse : XRLObject2
    {
        public ushort           wNumStrings;

        [WireInfo(SizeParam="wNumStrings")]
        public uint[]           rghrString;
    };

    //
    // Structure representing a request to look-up the text representation of a title ID.
    //  
    // NOTE: StringLookupResponse is used to respond
    //
    public class V1TitleIDRequest : XRLObject2
    {
        public ushort           wType; // type=1 for title id lookups, 0 was used for message lookups
        public ushort           wLanguage;
        public ushort           wNumTitles;

        [WireInfo(SizeParam="wNumTitles")]
        public uint[]           rgdwTitleIDs;

        public override string Xrl
        {
            get
            {
                return "/msgserver/msgserver.ashx";
            }
        }
    };

    public class StringLogRequest : XRLObject2
    {
        public ushort          logLinesLength;
      
        [WireInfo(SizeParam="logLinesLength")]
        public string          logLines;
        
        public override string Xrl
        {
            get
            {
                return "/msgserver/logstring.ashx";
            }
        }
    };    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\SocialQueryProt.cs ===
﻿/*==========================================================================
 *
 *  SocialQueryProt.cs -- This module defines the wire protocol for social query service apis
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/
using xonline.common.service;

namespace xonline.common.protocol.socialquery
{
    #region Basic wiredata objects

    public class SocialQueryDefs
    {
        // SQ_FLAG_* constants correspond to XONLINE_FRIENDSTATE_FLAG_* constants on the client

        public const uint SQ_FLAG_ONLINE = 0x00000001; // Set if online

        public const uint SQ_FLAG_PARTY_PLAYING = 0x00000800; // Set if the user is in a party

        public const uint SQ_FLAG_FRIEND_REQUEST_ACCEPTED = 0x00000000;
        public const uint SQ_FLAG_SENTREQUEST = 0x40000000;
        public const uint SQ_FLAG_RECEIVEDREQUEST = 0x80000000;
    }

    public class SocialQueryUser : WireData
    {
        public SocialQueryUser()
        {
        }

        public SocialQueryUser(ulong Xuid, string Gamertag, uint UserState, uint FriendStatus, uint TitleId)
        {
            this.Xuid = Xuid;
            this.Gamertag = Gamertag;
            this.TitleId = TitleId;

            // Generate the Flags field that the client expects.
            if ((UserState & PresDefs.P_STATE_FLAG_ONLINE) == PresDefs.P_STATE_FLAG_ONLINE)
                this.Flags |= SocialQueryDefs.SQ_FLAG_ONLINE;

            if ((UserState & PresDefs.P_STATE_MASK_PARTY_PLAYING) == PresDefs.P_STATE_MASK_PARTY_PLAYING)
                this.Flags |= SocialQueryDefs.SQ_FLAG_PARTY_PLAYING;

            if ((FriendStatus & PresDefs.P_BUDDY_STATUS_PENDING) == PresDefs.P_BUDDY_STATUS_PENDING)
                this.Flags |= SocialQueryDefs.SQ_FLAG_SENTREQUEST;

            if ((FriendStatus & PresDefs.P_BUDDY_STATUS_REQUEST) == PresDefs.P_BUDDY_STATUS_REQUEST)
                this.Flags |= SocialQueryDefs.SQ_FLAG_RECEIVEDREQUEST;
        }

        public ulong Xuid;

        [WireInfo(ArraySize = PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string Gamertag;

        // User flags - party playing, online status, friend status
        // See SocialQueryDefs for valid values.
        public uint Flags;

        // Title currently being played
        public uint TitleId;
    }

    /// <summary>
    /// Types of sorting available to the GetFriendsXrlRequest
    /// </summary>
    public enum GetFriendSortType : uint
    {
        Activity,
        Gamertag,
        OnlineStatus
    }

    /// <summary>
    /// Describes the paging information requested by the client
    /// </summary>
    public class PagingInfo : WireData
    {
        /// <summary>
        /// Size of the page to return
        /// </summary>
        public int              PageSize;

        /// <summary>
        /// Index within the sorted response to begin the returned page
        /// </summary>
        public int              PageStart;

        /// <summary>
        /// Xuid of the user to focus on when pivoting.
        /// </summary>
        public ulong            FocusXuid;
    }

    #endregion

    #region XrlRequest objects

    /// <summary>
    /// The basic friends list request for the current user.
    /// </summary>
    public class GetFriendsXrlRequest : XRLObject2
    {
        /// <summary>
        /// The requesting user
        /// </summary>
        public ulong              RequestorXuid;

        /// <summary>
        /// The owner xuid
        /// </summary>
        public ulong              OwnerXuid;

        /// <summary>
        /// The locale id of the requesting user.
        /// </summary>
        public ushort             LocaleId;

        /// <summary>
        /// How the response should be sorted
        /// </summary>
        public GetFriendSortType  SortType;

        /// <summary>
        /// Title Id used when sorting by activity
        /// </summary>
        public uint               TitleId;

        /// <summary>
        /// Paging information.
        /// </summary>
        public PagingInfo         PagingInfo;

        /// <summary>
        /// The Xrl
        /// </summary>
        public override string  Xrl 
        {
            get { return ("/socialqueryfd/getfriends.ashx"); }
        }
    }

    #endregion

    #region XrlResponse objects

    /// <summary>
    /// Response to GetFriendsXrlRequest,
    /// GetFavoriteFriendsXrlRequest,
    /// GetOnlineFriendsXrlRequest
    /// & GetPendingAndSuggestedFriendsXrlRequest
    /// </summary>
    public class GetFriendsXrlResponse : XRLObject2
    {
        /// <summary>
        /// The hr.
        /// </summary>
        public HResult              hr;

        /// <summary>
        /// The requesting Xuid
        /// </summary>
        public ulong                RequestorXuid;

        /// <summary>
        /// The owner xuid
        /// </summary>
        public ulong                OwnerXuid;

        /// <summary>
        /// The version of the friend list
        /// </summary>
        public uint                 FriendListVersion;

        /// <summary>
        /// The total number of users in the response set
        /// </summary>
        public uint                 TotalNumUsers;

        /// <summary>
        /// The start index of the page within the total set
        /// </summary>
        public uint                 PageStartIndex;

        /// <summary>
        /// The number of friends in this page
        /// </summary>
        public uint                 NumFriends;

        /// <summary>
        /// The page of results
        /// </summary>
        [WireInfo(SizeParam = "NumFriends")]
        public SocialQueryUser[]    Friends;
    }

    #endregion

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\StorageProtocol.cs ===
/*
 * Copyright (c) 2003 Microsoft Corporation
 *
 * Storage
 *
 * Protocol.cs
 *
 * Protocol stuff
 *
 * */

using System;
using System.Collections.Specialized;
using System.IO;
using System.Text;

using xonline.common.service;

namespace xonline.common.protocol
{
    public interface IStorageRequest
    {
        uint  Flags {get;}
        uint  TitleId {get;}
        uint  TitleVersion {get;}
        byte  UserCountryId { get; }
        ulong UserPuid {get;}
        ulong XboxPuid {get;}
        AccessToken Token { get; }
        TeamTickets Tickets { get; }
    }


    public interface IStorageRequestLight
    {
        uint TitleId { get;}
        uint TitleVersion { get;}
    }


    // ReqHdrWriteFile
    // Header of the WriteFile request
    public class ReqHdrWriteFile : IStorageRequest
    {
        public uint         _titleId;
        public uint         _titleVersion;
        public byte         _userCountryId;
        public byte         _compressionType;
        public uint         _contentType;
        public byte[]       _blobHash;
        public byte[]       _blobSignature;
        public uint         _blobSizeUncompressed;
        public ushort       _attributesSize;
        public uint         _blobSize;

        public byte[]       _attributes;
        public WriteFileToken _accessToken;
        public TeamTickets  _teamTickets;

        public string GetXRL()
        {
            return "/stfd/writefile.ashx";
        }

        // ReadFrom
        // Parse message from stream
        public void ReadFrom(BinaryReader r)
        {
            _accessToken              = new WriteFileToken(r);
            _titleId                  = r.ReadUInt32();
            _titleVersion             = r.ReadUInt32();
            _userCountryId            = r.ReadByte();
            _compressionType          = r.ReadByte();
            _contentType              = r.ReadUInt32();
            _blobHash                 = r.ReadBytes(ProtocolConstants.sizeHash);
            _blobSignature            = r.ReadBytes(ProtocolConstants.sizeSignature);
            _blobSizeUncompressed     = r.ReadUInt32();
            _attributesSize           = r.ReadUInt16();
            _blobSize                 = r.ReadUInt32();


            _attributes = ( 0 == _attributesSize ) ? null : r.ReadBytes(_attributesSize);

            // read team tickets if flags indicate they are present
            if ( (_accessToken._flags & (uint)FlagType.TeamTicket) == (uint)FlagType.TeamTicket )
            {
                _teamTickets = new TeamTickets(r);
            }
        }

        // WriteTo
        // Write message to stream
        public void WriteTo(BinaryWriter w)
        {
            _attributesSize = (_attributes == null) ? (ushort) 0 : (ushort) _attributes.Length;

            _accessToken.WriteTo(w);

            w.Write(_titleId);
            w.Write(_titleVersion);
            w.Write(_userCountryId);
            w.Write(_compressionType);
            w.Write(_contentType);
            w.Write(_blobHash);
            w.Write(_blobSignature);
            w.Write(_blobSizeUncompressed);
            w.Write(_attributesSize);
            w.Write(_blobSize);

            if ( _attributes != null )
            {
                w.Write(_attributes);
            }

            if ( _teamTickets != null )
            {
                _teamTickets.WriteStream(w);
            }
        }

        public void Validate()
        {
            _accessToken.Validate();

            if ( _contentType >= (uint) ContentType.Invalid )
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_174,
                    "Validate: invalid content type: " + _contentType);
            }

            if ( _compressionType >= (uint) CompressionType.Invalid )
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_175,
                    "Validate: invalid compression type: " + _compressionType);
            }

            if ( _attributes != null && _attributes.Length > ProtocolConstants.maxSizeAttributes )
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_176,
                    "Validate: attributes size too large: " + _attributes.Length);
            }
        }

        public uint Size()
        {
            return
                ( _accessToken == null ? 0 : (uint) _accessToken.Size() ) +
                ( _attributes == null ? 0 : (uint) _attributes.Length ) +
                144;
        }

        // ToString
        // Dump message contents
        public override string ToString()
        {
            return
                " _titleId:0x"+_titleId.ToString("X")+
                " _titleVersion:"+_titleVersion+
                " _userCountryId:"+_userCountryId+
                " _compressionType:"+_compressionType+
                " _contentType:"+_contentType+
                " _blobHash:"+(_blobHash!=null ? "(binary)" : "null")+
                " _blobSignature:"+(_blobSignature!=null ? "(binary)" : "null")+
                " _blobSizeUncompressed:"+_blobSizeUncompressed+
                " _attributesSize:"+_attributesSize+
                " _blobSize:"+_blobSize+
                " _attributes:"+(_attributes!=null ? "(binary)" : "null")+
                " _accessToken:"+(_accessToken!=null ? "(" + _accessToken.ToString()+ ")" : "null")+
                " _teamTickets:"+(_teamTickets!=null ? _teamTickets.ToString() : "null");
        }

        // Implement StorageRequest properties
        public uint Flags
        {
            get { return _accessToken._flags; }
        }
        public uint TitleId
        {
            get { return _titleId; }
        }
        public uint TitleVersion
        {
            get { return _titleVersion; }
        }
        public byte UserCountryId
        {
            get { return _userCountryId; }
        }
        public ulong UserPuid
        {
            get { return _accessToken._userPuid; }
        }
        public ulong XboxPuid
        {
            get { return _accessToken._xboxPuid; }
        }
        public AccessToken Token
        {
            get { return _accessToken; }
        }
        public TeamTickets Tickets
        {
            get { return _teamTickets; }
        }
    }

    // ReqReadFile
    // ReadFile request
    public class ReqReadFile : IStorageRequest
    {
        public uint         _titleId;
        public uint         _titleVersion;
        public byte         _userCountryId;
        public uint         _rangeStart;
        public uint         _rangeEnd;
        public long         _ifModifiedSinceDate;

        public ReadFileToken  _accessToken;
        public TeamTickets  _teamTickets;

        public string GetXRL()
        {
            return "/stfd/readfile.ashx";
        }

        public void ReadFrom(BinaryReader r)
        {
            _accessToken = new ReadFileToken(r);
            _titleId         = r.ReadUInt32();
            _titleVersion    = r.ReadUInt32();
            _userCountryId   = r.ReadByte();
            _rangeStart      = r.ReadUInt32();
            _rangeEnd        = r.ReadUInt32();
            _ifModifiedSinceDate = r.ReadInt64();

            // read team tickets if flags indicate they are present
            if ( (_accessToken._flags & (uint)FlagType.TeamTicket) == (uint)FlagType.TeamTicket )
            {
                _teamTickets = new TeamTickets(r);
            }
        }

        public void WriteTo(BinaryWriter w)
        {
            _accessToken.WriteTo(w);
            w.Write(_titleId);
            w.Write(_titleVersion);
            w.Write(_userCountryId);
            w.Write(_rangeStart);
            w.Write(_rangeEnd);
            w.Write(_ifModifiedSinceDate);

            if ( _teamTickets != null )
            {
                _teamTickets.WriteStream(w);
            }
        }

 
        public void Validate()
        {
            _accessToken.Validate();
        }

        // ToString
        // Dump message contents
        public override string ToString()
        {
            return
                _accessToken.ToString()+
                " _titleId:0x"+_titleId.ToString("X")+
                " _titleVersion:0x"+_titleVersion.ToString("X")+
                " _userCountryId:"+_userCountryId+
                " _rangeStart:"+_rangeStart+
                " _rangeEnd:"+_rangeEnd+
                " _ifModifiedSinceDate:"+_ifModifiedSinceDate+
                " _teamTickets:"+(_teamTickets!=null ? _teamTickets.ToString() : "null");
        }

        // Implement StorageRequest properties
        public uint Flags
        {
            get { return _accessToken._flags; }
        }
        public uint TitleId
        {
            get { return _titleId; }
        }
        public uint TitleVersion
        {
            get { return _titleVersion; }
        }
        public byte UserCountryId
        {
            get { return _userCountryId; }
        }
        public ulong UserPuid
        {
            get { return _accessToken._userPuid; }
        }
        public ulong XboxPuid
        {
            get { return _accessToken._xboxPuid; }
        }
        public AccessToken Token
        {
            get { return _accessToken; }
        }
        public TeamTickets Tickets
        {
            get { return _teamTickets; }
        }
    }

    // EnumeratedReadFilerequest fields
    public class EnumeratedReadFileParameters
    {
        public const string IfModifiedSince     = "_ifModifiedSinceDate";

        public const string TitleId             = "_titleId";

        public const string TitleVersion        = "_titleVersion";

        public const string PathName            = "_pathName";

        public const string PathNameSize        = "_pathNameSize";

        public const string SendXRLResponse     = "_sendXRLResponse";

    }


    // This class represents all of the data of a EnumeratedReadFile 
    public class EnumeratedReadFileInfo
    {
        public ushort _pathNameSize;
        public string _pathName;
        //public long _creationDate = new long();
        public long _modifiedDate = new long();


        public EnumeratedReadFileInfo()
        {
        }

        public EnumeratedReadFileInfo(string path, DateTime modifiedDate)
        {
            _pathName = path;
            _pathNameSize = (ushort) path.Length;
            _modifiedDate = modifiedDate.ToFileTimeUtc();
        }

        public void ReadFrom(byte[] values)
        {
            using (MemoryStream stream = new MemoryStream(values))
            {
                using (BinaryReader reader = new BinaryReader(stream))
                {
                    _pathNameSize = reader.ReadUInt16();                    
                    if (_pathNameSize > 0)
                    {
                        //_pathName = Encoding.ASCII.GetString(reader.ReadBytes(_pathNameSize));
                        _pathName = reader.ReadString(); 
                    }
                    _modifiedDate = reader.ReadInt64();
                    //_creationDate = reader.ReadInt64();
                }
            }
        }

        public void WriteTo(byte[] values)
        {
            using (MemoryStream stream = new MemoryStream(values))
            {
                using (BinaryWriter w = new BinaryWriter(stream))
                {
                    w.Write(_pathNameSize);
                    if (_pathNameSize > 0)
                        w.Write(_pathName);
                    w.Write(_modifiedDate);
                    //w.Write(_creationDate);
                }
            }
        }

        public int Size()
        {
                        
            if (_pathNameSize == 0)
                return (int) (sizeof(ushort) + sizeof(long) );
            else
                return (int) (sizeof(ushort) + sizeof(long) + (_pathName.Length * sizeof(char)));
        }


        // ToString
        public override string ToString()
        {
            return (
                " _path :" + _pathName 
                //+ " _creationDate:" + _creationDate
                + " _modifiedDate:" + _modifiedDate );
        }

    }


    // ReqEnumeratedReadFile
    // EnumeratedReadFile request
    public class ReqEnumeratedReadFile : IStorageRequestLight
    {
        public long _ifModifiedSinceDate;
        public uint _titleId;
        public uint _titleVersion;
        public ushort _pathNameSize;
        public string _pathName;

        //public uint _rangeStart;
        //public uint _rangeEnd;
        //public ReadFileToken _accessToken;

        public string GetXRL()
        {
            return "/stfd/enumeratedreadfile.ashx";
        }

        public void ReadFrom(BinaryReader r)
        {
            _titleId = r.ReadUInt32();
            _titleVersion = r.ReadUInt32();
            _pathNameSize = r.ReadUInt16();
            if (_pathNameSize > 0)
            {
                _pathName = r.ReadString();
            }
            _ifModifiedSinceDate = r.ReadInt64();

            //_accessToken = new ReadFileToken(r);
            //_rangeStart = r.ReadUInt32();
            //_rangeEnd = r.ReadUInt32();           
                     
        }

        public void WriteTo(BinaryWriter w)
        {
            w.Write(_titleId);
            w.Write(_titleVersion);
            w.Write(_pathNameSize);
            w.Write(_pathName);
            w.Write(_ifModifiedSinceDate);
        }

        public ReqEnumeratedReadFile()
        {

        }

        public ReqEnumeratedReadFile(NameValueCollection parameters)
        {


            string[] values = new string[] { };
            string key = "";

            //PathName parameter
            key = EnumeratedReadFileParameters.PathName;
            values = parameters.GetValues(key);
            if ((values == null ) || (values.Length !=1 ))
            {
                throw new ApplicationException(" PathName parameter required ");
            }
            else if (values.Length == 1)
            {
                _pathName = parameters[key];
            }


            //PathNameSize
            _pathNameSize = Convert.ToUInt16(_pathName.Length);


            //IfModifiedSince parameter
            key = EnumeratedReadFileParameters.IfModifiedSince;
            values = parameters.GetValues(key);
            if ((values == null) ||  (values.Length == 0))
            {
                _ifModifiedSinceDate = 0;
            }
            else if (values.Length == 1)
            {
                _ifModifiedSinceDate = Convert.ToDateTime(parameters[key]).ToFileTime();
            }
            else
            {
                throw new ApplicationException(" Only one IfModifiedSinceDate parameter expected");
            }


            //TitleId parameter
            key = EnumeratedReadFileParameters.TitleId;
            values = parameters.GetValues(key);
            if ((values == null) || (values.Length == 0))
            {
                _titleId = 0;
            }
            else if (values.Length == 1)
            {
                _titleId = Convert.ToUInt32(parameters[key]);
            }

            else
            {
                throw new ApplicationException(" Only one TitleId parameter expected");
            }


            //TitleVersion parameter
            key = EnumeratedReadFileParameters.TitleVersion;
            values = parameters.GetValues(key);
            if ((values == null) || (values.Length == 0))
            {
                _titleVersion = 0;
            }
            else if (values.Length == 1)
            {
                _titleVersion = Convert.ToUInt32(parameters[key]);
            }
            else
            {
                throw new ApplicationException(" Only one TitleVersion parameter expected");
            }
        }


        public void Validate()
        {
            //_accessToken.Validate();
            if (_pathNameSize == 0 || _pathNameSize > ProtocolConstants.maxSizeName)
            {
                //XommTrace(atTrace, L_ERROR, "Validate: invalid pathNameSize: " + _pathNameSize);
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_148,
                    "Validate: invalid pathNameSize: " + _pathNameSize);
            }
            if (_pathNameSize != _pathName.Length)
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_149,
                    "Validate: pathNameSize mismatch.");
            }

        }

        // ToString
        // Dump message contents
        public override string ToString()
        {
            return
                " _titleId:0x" + _titleId.ToString("X") +
                " _titleVersion:0x" + _titleVersion.ToString("X") +
                " _pathNameSize:" + _pathNameSize +
                " _pathName:" + _pathName +
                " _ifModifiedSinceDate:" + _ifModifiedSinceDate
                ;
        }

        // Implement StorageRequest properties
        public uint TitleId
        {
            get { return _titleId; }
        }
        public uint TitleVersion
        {
            get { return _titleVersion; }
        }
    }

    // RepReadFile
    // ReadFile reply header
    public class RepHdrReadFile
    {
        public uint         _titleId           = 0;
        public uint         _titleVersion      = 0;
        public ulong        _userPuid          = 0;
        public byte         _userCountryId     = 0;
        public ulong        _xboxPuid          = 0;
        public byte         _compressionType   = 0;
        public uint         _contentType       = 0;
        public byte[]       _blobSignature     = new byte[ProtocolConstants.sizeSignature];
        public uint         _blobSizeUncompressed = 0;
        public long         _creationDate      = 0;
        public long         _modifiedDate      = 0;
        public ushort       _attributesSize    = 0;
        public uint         _blobSize          = 0;
        public byte[]       _attributes        = null;

        public void ReadFrom(BinaryReader r)
        {
            _titleId           = r.ReadUInt32();
            _titleVersion      = r.ReadUInt32();
            _userPuid          = r.ReadUInt64();
            _userCountryId     = r.ReadByte();
            _xboxPuid          = r.ReadUInt64();
            _compressionType   = r.ReadByte();
            _contentType       = r.ReadUInt32();
            _blobSignature     = r.ReadBytes(ProtocolConstants.sizeSignature);
            _blobSizeUncompressed  = r.ReadUInt32();
            _creationDate      = r.ReadInt64();
            _attributesSize    = r.ReadUInt16();
            _blobSize          = r.ReadUInt32();

            if ( _attributesSize > 0 )
            {
                _attributes = r.ReadBytes(_attributesSize);
            }
        }

        public void WriteTo(BinaryWriter w)
        {
            _attributesSize = (_attributes == null) ? (ushort) 0 : (ushort) _attributes.Length;

            w.Write(_titleId);
            w.Write(_titleVersion);
            w.Write(_userPuid);
            w.Write(_userCountryId);
            w.Write(_xboxPuid);
            w.Write(_compressionType);
            w.Write(_contentType);
            w.Write(_blobSignature);
            w.Write(_blobSizeUncompressed);
            w.Write(_creationDate);
            w.Write(_attributesSize);
            w.Write(_blobSize);

            if ( _attributes != null )
            {
                w.Write(_attributes);
            }
        }

        // ToString
        // Dump message contents
        public override string ToString()
        {
            return
                " _titleId:0x"+_titleId.ToString("X")+
                " _titleVersion:"+_titleVersion+
                " _userPuid:0x"+_userPuid.ToString("X")+
                " _userCountryId:"+_userCountryId+
                " _xboxPuid:0x"+_xboxPuid.ToString("X")+
                " _compressionType:"+_compressionType+
                " _contentType:"+_contentType+
                " _blobSignature:"+_blobSignature+
                " _blobSizeUncompressed:"+_blobSizeUncompressed+
                " _creationDate:"+_creationDate+
                " _modifiedDate:"+_modifiedDate+
                " _attributesSize:"+_attributesSize+
                " _blobSize:"+_blobSize+
                " _attributes:"+(_attributes!=null ? "(binary)" : "null");
        }
    }


    // RepEnumeratedReadFile
    // EnumeratedReadFile reply header
    public class RepHdrEnumeratedReadFile
    {
        public string _path;
        public long _creationDate;
        public long _modifiedDate;

        public void ReadFrom(BinaryReader r)
        {
            _creationDate = r.ReadInt64();
        }

        public void WriteTo(BinaryWriter w)
        {
            w.Write(_creationDate);
        }

        // ToString
        // Dump message contents
        public override string ToString()
        {
            return (
                " _path :" + _path+
                " _modifiedDate:" + _modifiedDate +
                " _creationDate:" + _creationDate );
        }
    }


    public class ReqRemoveFile : IStorageRequest
    {
        public uint _titleId;
        public uint _titleVersion;
        public RemoveFileToken _accessToken;
        public TeamTickets _teamTickets;

        public string GetXRL()
        {
            return "/stfd/removefile.ashx";
        }

        public void ReadFrom(BinaryReader r)
        {
            _accessToken     = new RemoveFileToken(r);
            _titleId         = r.ReadUInt32();
            _titleVersion    = r.ReadUInt32();

            // read team tickets if flags indicate they are present
            if ( (_accessToken._flags & (uint)FlagType.TeamTicket) == (uint)FlagType.TeamTicket )
            {
                _teamTickets = new TeamTickets(r);
            }
        }

        public void WriteTo(BinaryWriter w)
        {
            _accessToken.WriteTo(w);
            w.Write(_titleId);
            w.Write(_titleVersion);

            if ( _teamTickets != null )
            {
                _teamTickets.WriteStream(w);
            }
        }

        public void Validate()
        {
            _accessToken.Validate();
        }

        public override string ToString()
        {
            return
                _accessToken.ToString()+
                " _titleId:0x"+_titleId.ToString("X")+
                " _titleVersion:0x"+_titleVersion.ToString("X")+
                " _teamTickets:"+(_teamTickets!=null ? _teamTickets.ToString() : "null");
        }

        // Implement StorageRequest properties
        public uint Flags
        {
            get { return _accessToken._flags; }
        }
        public uint TitleId
        {
            get { return _titleId; }
        }
        public uint TitleVersion
        {
            get { return _titleVersion; }
        }
        public byte UserCountryId
        {
            get { return 0; }
        }
        public ulong UserPuid
        {
            get { return _accessToken._userPuid; }
        }
        public ulong XboxPuid
        {
            get { return _accessToken._xboxPuid; }
        }
        public AccessToken Token
        {
            get { return _accessToken; }
        }
        public TeamTickets Tickets
        {
            get { return _teamTickets; }
        }
    }

    public class ReadFileHashRequest : XRLObject2
    {
        [WireInfoAttribute(Min=1, Max=ProtocolConstants.maxSizeName)]
        public ushort pathNameLen;

        [WireInfoAttribute(SizeParam="pathNameLen")]
        public string pathName;

        public override string Xrl
        {
            get { return "/stfd/readfilehash.ashx"; }
        }

        public override string ToString()
        {
            return
                " pathNameLen:"+pathName.Length+
                " pathName:"+pathName;
        }
    }

    public class ReadFileHashResponse : XRLObject2
    {
        [WireInfoAttribute(ArraySize=(int)ProtocolConstants.sizeHash)]
        public byte[] hash;

        public override string ToString()
        {
            return
                " hash:"+(hash == null ? "" : ByteConvert.ToString(hash));
        }
    }

    public class GetQuotaRequest : XRLObject2
    {
        public uint  _domainId;
        public uint  _titleId;
        public uint  _keyType;
        public ulong _keyValue;

        public override string Xrl
        {
            get { return "/stfd/getquota.ashx"; }
        }

        public override int Size()
        {
            return 20;
        }
    }

    public class GetQuotaResponse : XRLObject2
    {
        public ulong _maxFileSize;
        public ulong _totalBytesMax;
        public ulong _totalBytesUsed;
        public uint  _totalFilesMax;
        public uint  _totalFilesUsed;

        public override int Size()
        {
            return 24;
        }
    }

    public class ReportBrokenLinkRequest : XRLObject2
    {
        public uint statusData;

        [WireInfoAttribute(Min=1, Max=XOn.MAX_STORAGE_PATHNAME_LENGTH*XOn.UTF8_MULT)]
        public ushort pathnameLen;

        [WireInfoAttribute(SizeParam="pathnameLen", Min=1, Max=XOn.MAX_STORAGE_PATHNAME_LENGTH)]
        public string pathname;

        public override string Xrl
        {
            get { return "/stfd/reportbrokenlink.ashx"; }
        }
    }

    public class ResolveNameRequest : XRLObject2
    {
        [WireInfoAttribute(Min=1, Max=XOn.MAX_STORAGE_PATHNAME_LENGTH*XOn.UTF8_MULT)]
        public ushort pathnameLen;

        [WireInfoAttribute(SizeParam="pathnameLen", Min=1, Max=XOn.MAX_STORAGE_PATHNAME_LENGTH)]
        public string pathname;

        public override string Xrl
        {
            get { return "/stfd/reportbrokenlink.ashx"; }
        }
    }

    public class ResolveNameResponse : XRLObject2
    {
        public uint primaryIP;
        public ushort primaryPort;
        public uint alternateIP;
        public ushort alternatePort;
        public DateTime expiration;
        public ushort ruleLen;

        [WireInfoAttribute(SizeParam="ruleLen")]
        public string rule;
    }

    // ReqEnumerateFiles
    // EnumerateFile request
    public class ReqEnumerateFiles : IStorageRequest
    {
        public uint         _titleId;
        public uint         _titleVersion;
        public byte         _userCountryId;
        public uint         _resultsStart;
        public uint         _resultsEnd;
        public long         _ifModifiedSinceDate;

        public ReadFileToken  _accessToken;
        public TeamTickets  _teamTickets;

        public string GetXRL()
        {
            return "/stfd/enumeratefiles.ashx";
        }

        public void ReadFrom(BinaryReader r)
        {
            _accessToken = new ReadFileToken(r);
            _titleId         = r.ReadUInt32();
            _titleVersion    = r.ReadUInt32();
            _userCountryId   = r.ReadByte();
            _resultsStart    = r.ReadUInt32();
            _resultsEnd      = r.ReadUInt32();
            _ifModifiedSinceDate = r.ReadInt64();

            // read team tickets if flags indicate they are present
            if ( (_accessToken._flags & (uint)FlagType.TeamTicket) == (uint)FlagType.TeamTicket )
            {
                _teamTickets = new TeamTickets(r);
            }
        }

        public void WriteTo(BinaryWriter w)
        {
            _accessToken.WriteTo(w);
            w.Write(_titleId);
            w.Write(_titleVersion);
            w.Write(_userCountryId);
            w.Write(_resultsStart);
            w.Write(_resultsEnd);
            w.Write(_ifModifiedSinceDate);

            if ( _teamTickets != null )
            {
                _teamTickets.WriteStream(w);
            }
        }

        public void Validate()
        {
            _accessToken.Validate();
        }

        // ToString
        // Dump message contents
        public override string ToString()
        {
            return
                _accessToken.ToString()+
                " _titleId:0x"+_titleId.ToString("X")+
                " _titleVersion:0x"+_titleVersion.ToString("X")+
                " _userCountryId:"+_userCountryId+
                " _resultsStart:"+_resultsStart+
                " _resultsEnd:"+_resultsEnd+
                " _ifModifiedSinceDate:"+_ifModifiedSinceDate+
                " _teamTickets:"+(_teamTickets!=null ? _teamTickets.ToString() : "null");
        }

        // Implement StorageRequest properties
        public uint Flags
        {
            get { return _accessToken._flags; }
        }
        public uint TitleId
        {
            get { return _titleId; }
        }
        public uint TitleVersion
        {
            get { return _titleVersion; }
        }
        public byte UserCountryId
        {
            get { return _userCountryId; }
        }
        public ulong UserPuid
        {
            get { return _accessToken._userPuid; }
        }
        public ulong XboxPuid
        {
            get { return _accessToken._xboxPuid; }
        }
        public AccessToken Token
        {
            get { return _accessToken; }
        }
        public TeamTickets Tickets
        {
            get { return _teamTickets; }
        }
    }

    // RepEnumerateFiles
    // ReadFile reply header
    public class RepEnumerateFiles
    {
        public uint         _titleId           = 0;
        public uint         _titleVersion      = 0;
        public ulong        _userPuid          = 0;
        public byte         _userCountryId     = 0;
        public ulong        _xboxPuid          = 0;
        public uint         _contentType       = 0;
        public uint         _blobSize          = 0;
        public uint         _blobSizeUncompressed = 0;
        public long         _creationDate      = 0;
        public long         _modifiedDate      = 0;
        public ushort       _pathNameSize      = 0;
        public ushort       _attributesSize    = 0;
        public string       _pathName          = null;
        public byte[]       _attributes        = null;

        public void ReadFrom(BinaryReader r)
        {
            _titleId           = r.ReadUInt32();
            _titleVersion      = r.ReadUInt32();
            _userPuid          = r.ReadUInt64();
            _userCountryId     = r.ReadByte();
            _xboxPuid          = r.ReadUInt64();
            _contentType       = r.ReadUInt32();
            _blobSize          = r.ReadUInt32();
            _blobSizeUncompressed  = r.ReadUInt32();
            _creationDate      = r.ReadInt64();
            _modifiedDate      = r.ReadInt64();
            _attributesSize    = r.ReadUInt16();
            _pathNameSize      = r.ReadUInt16();

            if ( _attributesSize > 0 )
            {
                _attributes = r.ReadBytes(_attributesSize);
            }
            if ( _pathNameSize > 0 )
            {
                _pathName = Encoding.UTF8.GetString(r.ReadBytes(_pathNameSize));
            }
        }

        public void WriteTo(BinaryWriter w)
        {
            _attributesSize = (_attributes == null) ? (ushort) 0 : (ushort) _attributes.Length;

            byte[] encName = null;
            if ( _pathName != null )
            {
                encName = Encoding.UTF8.GetBytes(_pathName);
                _pathNameSize = (ushort) encName.Length;
            }
            else
            {
                _pathNameSize = 0;
            }

            w.Write(_titleId);
            w.Write(_titleVersion);
            w.Write(_userPuid);
            w.Write(_userCountryId);
            w.Write(_xboxPuid);
            w.Write(_contentType);
            w.Write(_blobSize);
            w.Write(_blobSizeUncompressed);
            w.Write(_creationDate);
            w.Write(_modifiedDate);
            w.Write(_attributesSize);
            w.Write(_pathNameSize);

            if ( _attributes != null )
            {
                w.Write(_attributes);
            }
            if ( _pathName != null && _pathNameSize > 0 )
            {
                w.Write(encName);
            }
        }

        // ToString
        // Dump message contents
        public override string ToString()
        {
            return
                " _titleId:0x"+_titleId.ToString("X")+
                " _titleVersion:"+_titleVersion+
                " _userPuid:0x"+_userPuid.ToString("X")+
                " _userCountryId:"+_userCountryId+
                " _xboxPuid:0x"+_xboxPuid.ToString("X")+
                " _contentType:"+_contentType+
                " _blobSize:"+_blobSize+
                " _blobSizeUncompressed:"+_blobSizeUncompressed+
                " _creationDate:"+_creationDate+
                " _modifiedDate:"+_modifiedDate+
                " _attributesSize:"+_attributesSize+
                " _attributes:"+(_attributes!=null ? "(binary)" : "null")+
                " _pathNameSize:"+_pathNameSize+
                " _pathName:"+_pathName;
        }
    }

    public class Translator
    {
        public static ReqReadFile TranslateRequest(ReqEnumeratedReadFile reqEnum)
        {
            ReqReadFile reqReadFile = new ReqReadFile();

            reqReadFile._accessToken = null;
            reqReadFile._ifModifiedSinceDate = reqEnum._ifModifiedSinceDate;
            reqReadFile._titleId = reqEnum._titleId;
            reqReadFile._titleVersion= reqEnum._titleVersion;

            reqReadFile._rangeEnd = reqReadFile._rangeStart = 0;

            return reqReadFile;
        }

        

        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\statsprot.cs ===
using System;
using System.IO;
using System.Text;
using System.Collections;
using xonline.common.service;
using xonline.common.mgmt;

namespace xonline.common.protocol
{
    public class ProtocolConstant
    {
        public const uint   MaxNicknameLength = 31;
        public const uint   MaxSpecsPerRequest = 101;
        public const uint   MaxSpecsPerSetDataRequest = 20;
        public const uint   MaxAttrPerSpec = 64;
        public const uint   MaxAttrPerUnitSpec = 70;
        public const string AttachStorageDomain = "Stats";

        // BUGBUG: review V2 protocol parameters:
        public const uint   MaxProcedureCount = 1000;
        public const uint   MaxUtf8StringParamSize = 1024;
        public const uint   MaxStatPostParamCount = 256;
        public const uint   MaxStatUnitGetSpecs   = 5;
        public const uint   MaxStatUnitEnumEntries = 100;
    }

    // Reserved attribute ids for special types of stats
    public class SpecialAttrib
    {
        public const ushort Rank                = 0xFFFF;
        public const ushort Rating              = 0xFFFE;
        public const ushort Nickname            = 0xFFFD;
        public const ushort LeaderboardSize     = 0xFFFC;
        public const ushort AttachmentPathName  = 0xFFFB;
        public const ushort AttachmentSize      = 0xFFFA;
        public const ushort UnitActivity        = 0xFFF9;
        public const ushort UnitLastPlayedDate  = 0xFFF8;

        // MuSigma attributes
        public const ushort Skill               = 61;
        public const ushort GamesPlayed         = 62;
        public const ushort Mu                  = 63;
        public const ushort Sigma               = 64;
    }

    public class StatParam
    {
        public const byte Null         = 0;
        public const byte Int8         = 1;
        public const byte Int16        = 2;
        public const byte Int32        = 3;
        public const byte Int64        = 4;
        public const byte Float        = 5;
        public const byte Utf8string   = 6;
        public const byte Puid         = 7;

        static public byte MapFromAttrType(AttrType attrType)
        {
            byte statParamType = 0;

            switch (attrType)
            {
                case AttrType.None:
                    statParamType = StatParam.Null;
                    break;

                case AttrType.Long:
                    statParamType = StatParam.Int32;
                    break;

                case AttrType.LongLong:
                    statParamType = StatParam.Int64;
                    break;

                case AttrType.Double:
                    statParamType = StatParam.Float;
                    break;

                case AttrType.String:
                    statParamType = StatParam.Utf8string;
                    break;

                default:
                    throw new Exception("Invalid AttrType " + attrType.ToString() + " to StatParam");
            }

            return statParamType;
        }

        static public AttrType MapToAttrType(byte statParamType)
        {
            AttrType attrType = AttrType.None;

            switch (statParamType)
            {
                case StatParam.Null:
                    attrType = AttrType.None;
                    break;

                case StatParam.Int8:
                case StatParam.Int16:
                case StatParam.Int32:
                    attrType = AttrType.Long;
                    break;

                case StatParam.Puid:
                case StatParam.Int64:
                    attrType = AttrType.LongLong;
                    break;

                case StatParam.Float:
                    attrType = AttrType.Double;
                    break;

                case StatParam.Utf8string:
                    attrType = AttrType.String;
                    break;

                default:
                    throw new Exception("Invalid StatParam " + statParamType.ToString() + " to AttrType");
            }

            return attrType;
        }
    }

    public class StatPostProcedure
    {
        public const ushort Replace     = 0x8001;
        public const ushort ReplaceUnit = 0x8002;
        public const ushort Add         = 0x8003;
        public const ushort AddUnit     = 0x8004;
        public const ushort Elo         = 0x8005;
        public const ushort EloUnit     = 0x8006;
        public const ushort If          = 0x8007;
        public const ushort IfUnit      = 0x8008;
        public const ushort Min         = 0x8009;
        public const ushort MinUnit     = 0x800A;
        public const ushort Max         = 0x800B;
        public const ushort MaxUnit     = 0x800C;
        public const ushort MuSigma     = 0x800D;
        public const ushort MuSigmaEx   = 0x800E;
    }

    public class StatPostIfComparisonType
    {
        public const byte Equal             = 1;
        public const byte Greater           = 2;
        public const byte GreaterOrEqual    = 3;
        public const byte Less              = 4;
        public const byte LessOrEqual       = 5;
        public const byte Exist             = 6;
        public const byte NotExist          = 7;
        public const byte NotEqual          = 8;
    }

    public class UnitEnumFlags
    {
        public const uint   SortActivity = 1;
        public const uint   SortRating   = 2;
        //public const uint   NoTags       = 4; // BUGBUG: implement this back someday
    }

    // Attribute types
    public enum AttrType
    {
        None        = 0,
        Long        = 1,
        LongLong    = 2,
        Double      = 3,
        String      = 4
    }

    /// <summary>
    /// StatLbIdParser
    /// </summary>
    /// <remarks>
    /// Leaderboard ID parser helper class
    /// </remarks>
    public class StatLbIdParser
    {
        public const int MaxCompetitionPartitions = 4;
        public const uint PartitionMask           = 0xC0000000;
        public const uint TemplateMask            = 0x3C000000;
        public const uint CompetitionMask         = PartitionMask | TemplateMask;
        public const int  TemplateShift           = 26;
        public const int  PartitionShift          = 30;
        public const uint SkillMask               = 0x02000000;

        public const uint SkillModeMask           = 0x0000ffff;
        public const uint SkillTypeMask           = 0xffff0000;

        public const uint SkillTypeRanked         = 0xffff0000;
        public const uint SkillTypeStandard       = 0xfffe0000;


        static public bool IsCompetition(uint uiLbId)
        {
            return ((uiLbId & CompetitionMask) != 0) && !IsSkill(uiLbId);
        }

        static public bool IsSkill(uint uiLbId)
        {
            return ((uiLbId & SkillMask) != 0);
        }

        static public bool IsRankedSkill(uint uiLbId)
        {
            return ((uiLbId & SkillTypeMask) == SkillTypeRanked);
        }
        static public bool IsStandardSkill(uint uiLbId)
        {
            return ((uiLbId & SkillTypeMask) == SkillTypeStandard);
        }
        static public uint GetGameModeId(uint uiLbId)
        {
            return (uiLbId & SkillModeMask);
        }

        static public byte GetPartition(uint uiLbId)
        {
            return (byte)((uiLbId & PartitionMask) >> PartitionShift);
        }

        static public uint GetTemplateId(uint uiLbId)
        {
            return (uiLbId & TemplateMask) >> TemplateShift;
        }

    }

    #region Stats/Leaderboard V1 (XBOX) Protocol

    /// <summary>
    /// MsgSetData
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="UserId">User PUID</param>
    /// <param name="LbId">Leaderboard ID</param>
    /// <param name="AttrCount">Count of attributes</param>
    /// <param name="Attribs">Attribute data message</param>
    /// <returns>
    /// RepSetDataCanUploadAtt for S_CAN_UPLOAD_ATT
    /// </returns>
    public class MsgSetData
    {
        public uint             _uiTitleId;     // Title Id
        public ulong            _ulUserId;      // User PUID
        public uint             _uiLbId;        // Leaderboard Id
        public uint             _uiAttrCount;   // Attribute count
        public MsgAttribData[]  _attribs;       // Attributes. Number of objects is _uiAttrCount

        public void ReadFrom(BinaryReader reader)
        {
            _uiTitleId      = reader.ReadUInt32();
            _ulUserId       = reader.ReadUInt64();

            if(_ulUserId == 0)
                throw new Exception("_ulUserId cannot be zero.");

            _uiLbId         = reader.ReadUInt32();
            _uiAttrCount    = reader.ReadUInt32();

            if(_uiAttrCount < 1)
                throw new Exception("_uiAttrCount cannot be zero.");

            if(_uiAttrCount > ProtocolConstant.MaxAttrPerSpec)
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_STATS, XEvent.Id.XSTATSFD_INVALID_REQUEST,
                    "_uiAttrCount ("+_uiAttrCount+") > " + ProtocolConstant.MaxAttrPerSpec);

            _attribs        = new MsgAttribData[_uiAttrCount];
            for(int ndx=0; ndx < _uiAttrCount; ndx++)
            {
                _attribs[ndx] = new MsgAttribData();
                _attribs[ndx].ReadFrom(reader);
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            _uiAttrCount = (uint) _attribs.Length;

            writer.Write(_uiTitleId);
            writer.Write(_ulUserId);
            writer.Write(_uiLbId);
            writer.Write(_uiAttrCount);

            for(int ndx=0; ndx < _uiAttrCount; ndx++)
            {
                _attribs[ndx].WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiTitleId=0x"+_uiTitleId.ToString("x")+
                "\n_ulUserId=0x"+_ulUserId.ToString("x")+
                "\n_uiLbId="+_uiLbId+
                "\n_uiAttrCount="+_uiAttrCount+
                "\n_attribs:");

            for(int ndx=0; ndx < _attribs.Length; ndx++)
            {
                str.Append("\n " + ndx.ToString().PadLeft(2,'0') + ": " + _attribs[ndx].ToString());
            }

            return str.ToString();
        }
    }

    /// <summary>
    /// RepSetDataCanUploadAtt
    /// </summary>
    /// <param name="AccessToken">Storage access token</param>
    /// <param name="RefCount">Count of objects in Refs</param>
    /// <param name="Refs">Leaderboard/User pairs</param>
    /// <remarks>
    /// Response object with a storage access token that allows an attachment to be uploaded
    /// <para>
    /// Response for MsgSetData request that returns S_CAN_UPLOAD_ATT
    /// </para>
    /// </remarks>
    public class RepSetDataCanUploadAtt
    {
        public WriteFileToken   _accessToken;               // Storage access token
        public ushort                   _usRefCount;        // # of objects in _refs
        public RepSetDataReference[]    _refs;              // Lb/User pairs that will have a reference to this attachment. Size is _usRefCount

        public void WriteTo(BinaryWriter writer)
        {
            _usRefCount = (ushort) _refs.Length;

            _accessToken.WriteTo(writer);
            writer.Write(_usRefCount);
            foreach(RepSetDataReference reference in _refs)
            {
                reference.WriteTo(writer);
            }
        }

        public void ReadFrom(BinaryReader reader)
        {
            _accessToken        = new WriteFileToken();
            _accessToken.ReadFrom(reader);
            _usRefCount         = reader.ReadUInt16();
            _refs               = new RepSetDataReference[_usRefCount];
            for(uint ndx=0; ndx < _usRefCount; ndx++)
            {
                _refs[ndx] = new RepSetDataReference();
                _refs[ndx].ReadFrom(reader);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_accessToken: " + _accessToken.ToString() +
                "\n_usRefCount=" + _usRefCount);

            for(int ndx=0; ndx < _usRefCount; ndx++)
            {
                str.Append("\n " + ndx + ":" + _refs[ndx].ToString());
            }

            return str.ToString();
        }
    }

    /// <summary>
    /// RepSetDataReference
    /// </summary>
    /// <param name="Lb">Leaderboard id</param>
    /// <param name="User">User PUID</param>
    /// <remarks>
    /// Attachment part of RepSetDataCanUploadAtt
    /// <para>
    /// Response for MsgSetData request that returns S_CAN_UPLOAD_ATT
    /// </para>
    /// </remarks>
    public class RepSetDataReference
    {
        public uint     _uiLb;      // Leaderboard Id
        public ulong    _ulUser;    // User PUID

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_uiLb);
            writer.Write(_ulUser);
        }

        public void ReadFrom(BinaryReader reader)
        {
            _uiLb           = reader.ReadUInt32();
            _ulUser         = reader.ReadUInt64();
        }

        public override string ToString()
        {
            return string.Format("_uiLb={0} _ulUser=0x{1}", _uiLb, _ulUser);
        }
    }

    /// <summary>
    /// ReqGetData
    /// </summary>
    /// <param name="Messages">Request messages</param>
    /// <returns>RepGetData response</returns>
    /// <remarks>
    /// Reads data from leaderboard server as described in the request messages
    /// </remarks>
    public class ReqGetData
    {
        public MsgGetData[]    _messages;

        public void ReadFrom(BinaryReader reader)
        {
            ArrayList messages = new ArrayList((int)ProtocolConstant.MaxSpecsPerRequest);

            try
            {
                while(true)
                {
                    MsgGetData newMsg = new MsgGetData();
                    newMsg.ReadFrom(reader);

                    if(messages.Count == ProtocolConstant.MaxSpecsPerRequest)
                        throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_SPECS, XEvent.Id.XSTATSFD_INVALID_REQUEST_1,
                            "Too many specs in request");
                        // BUGBUG: hr=HResult.XONLINE_E_STAT_TOO_MANY_SPECS
                        
                    messages.Add(newMsg);
                }
            }
            catch (PeekCharEndOfStreamException)
            {
                //We are not using peek char anymore to detetect end of stream.
            }

            if(messages.Count == 0)
                throw new Exception("Request cannot be empty.");

            _messages = (MsgGetData[]) messages.ToArray(typeof(MsgGetData));
        }

        public void WriteTo(BinaryWriter writer)
        {
            foreach(MsgGetData msg in _messages)
            {
                msg.WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder();

            for(int ndx=0; ndx < _messages.Length; ndx++)
            {
                str.Append(_messages[ndx]);
            }

            return str.ToString();
        }
    }

    /// <summary>
    /// MsgGetData
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="UserId">User PUID</param>
    /// <param name="LbId">Leaderboard ID</param>
    /// <param name="AttrCount">Attribute count</param>
    /// <param name="AttrIds">Array of attribute ids (size==AttrCount)</param>
    /// <remarks>
    /// Leaderboard query message.  Specifies title, leaderboard, and attributes to retrieve.
    /// </remarks>
    public class MsgGetData
    {
        public uint     _uiTitleId;     // Title Id
        public ulong    _ulUserId;      // User PUID
        public uint     _uiLbId;        // Leaderboard Id
        public uint     _uiAttrCount;   // Attribute Count
        public ushort[] _attrIds;       // Array of attribute ids. Size is _uiAttrCount.

        public void ReadFrom(BinaryReader reader)
        {
            try
            {
                _uiTitleId      = reader.ReadUInt32();
            }
            catch (EndOfStreamException)
            {
                //only the first element following a previous peekchar
                throw new PeekCharEndOfStreamException();
            }
            
            _ulUserId       = reader.ReadUInt64();
            _uiLbId         = reader.ReadUInt32();
            _uiAttrCount    = reader.ReadUInt32();

            if(_uiAttrCount < 1)
                throw new Exception("_uiAttrCount is zero.");

            if( _uiAttrCount > ProtocolConstant.MaxAttrPerSpec )
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_STATS, XEvent.Id.XSTATSFD_INVALID_REQUEST_2,
                    "_uiAttrCount (" +_uiAttrCount+" > " + ProtocolConstant.MaxAttrPerSpec);

            _attrIds = new ushort[_uiAttrCount];
            for(int ndx=0; ndx < _uiAttrCount; ndx++)
            {
                _attrIds[ndx] = reader.ReadUInt16();
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            _uiAttrCount = (uint) _attrIds.Length;

            writer.Write(_uiTitleId);
            writer.Write(_ulUserId);
            writer.Write(_uiLbId);
            writer.Write(_uiAttrCount);

            for(int ndx=0; ndx < _uiAttrCount; ndx++)
            {
                writer.Write(_attrIds[ndx]);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiTitleId=0x"+_uiTitleId.ToString("x")+
                "\n_ulUserId=0x"+_ulUserId.ToString("x")+
                "\n_uiLbId="+_uiLbId+
                "\n_uiAttrCount="+_uiAttrCount+
                "\n_attrIds: ");

            for(int ndx=0; ndx < _uiAttrCount; ndx++)
            {
                str.Append(_attrIds[ndx] + " ");
            }

            return str.ToString();
        }
    }

    // RepGetData
    public class RepGetData
    {
        public MsgRepGetData[] _reps = null;

        public void WriteTo(BinaryWriter writer)
        {
            foreach(MsgRepGetData msg in _reps)
            {
                msg.WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder();

            for(int ndx=0; ndx < _reps.Length; ndx++)
            {
                str.Append(_reps[ndx]);
            }

            return str.ToString();
        }
    }

    // MsgRepGetData
    // GetData reply
    public class MsgRepGetData
    {
        public ulong            _ulUserId;  // User PUID
        public uint             _uiLbId;    // Leaderboard Id
        public MsgAttribData[]  _attribs;   // Attributes

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_ulUserId);
            writer.Write(_uiLbId);
            foreach(MsgAttribData attribData in _attribs)
            {
                attribData.WriteTo(writer);
            }
        }

        public void ReadFrom(BinaryReader reader)
        {
            _ulUserId   = reader.ReadUInt64();
            _uiLbId     = reader.ReadUInt32();

            for(int ndx=0; ndx < _attribs.Length; ndx++)
            {
                _attribs[ndx] = new MsgAttribData();
                _attribs[ndx].ReadFrom(reader);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_ulUserId=0x"+_ulUserId.ToString("x")+
                "\n_uiLbId="+_uiLbId+
                "\n_attribs:");

            for(int ndx=0; ndx < _attribs.Length; ndx++)
            {
                str.Append("\n " + ndx.ToString().PadLeft(2,'0') + ": " + _attribs[ndx].ToString());
            }

            return str.ToString();
        }
    }

    // MsgEnumLB
    // Message Enumerate Leaderboard
    public class MsgEnumLB
    {
        public uint     _uiTitleId;             // Title ID
        public uint     _uiLb;                  // Leaderboard id
        public ulong    _ulPivotOrPageStart;    // if _bIsPivotUser == 0, this is the page start, otherwise this is the pivot user
        public byte     _bIsPivotUser;          // Defines if _ulPivotOrPageStart is the page start or the pivot user
        public uint     _uiPageSize;            // Page size
        public uint     _uiAttrCount;           // Size of _attrIds
        public ushort[] _attrIds;               // Array of attribute ids. Size is _uiAttrCount.

        public void ReadFrom(BinaryReader reader)
        {
            _uiTitleId      = reader.ReadUInt32();
            _uiLb           = reader.ReadUInt32();
            _ulPivotOrPageStart = reader.ReadUInt64();
            _bIsPivotUser   = reader.ReadByte();
            _uiPageSize     = reader.ReadUInt32();
            _uiAttrCount    = reader.ReadUInt32();

            if( _uiAttrCount > ProtocolConstant.MaxAttrPerSpec )
            {
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_STATS, XEvent.Id.XSTATSFD_INVALID_REQUEST_3,
                    "Invalid MsgEnumLb. _uiAttrCount("+_uiAttrCount+") > ProtocolConstant.MaxAttrPerSpec("+ProtocolConstant.MaxAttrPerSpec+")");
            }

            if ( _uiPageSize == 0)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.COMMON_HACK_33,
                    "Invalid MsgEnumLb.   _uiPageSize was 0!");
            }

            _attrIds        = new ushort[_uiAttrCount];
            for(uint ndx=0; ndx < _uiAttrCount; ndx++)
            {
                _attrIds[ndx] = reader.ReadUInt16();
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_uiTitleId);
            writer.Write(_uiLb);
            writer.Write(_ulPivotOrPageStart);
            writer.Write(_bIsPivotUser);
            writer.Write(_uiPageSize);
            writer.Write(_uiAttrCount);

            for(uint ndx=0; ndx < _uiAttrCount; ndx++)
            {
                writer.Write(_attrIds[ndx]);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiTitleId=0x"+_uiTitleId.ToString("x")+
                "\n_uiLb="+_uiLb+
                "\n_ulPivotOrPageStart="+_ulPivotOrPageStart+
                "\n_bIsPivotUser="+_bIsPivotUser+
                "\n_uiPageSize="+_uiPageSize+
                "\n_uiAttrCount="+_uiAttrCount+
                "\n_attrIds: ");

            for(int ndx=0; ndx < _uiAttrCount; ndx++)
            {
                str.Append(_attrIds[ndx] + " ");
            }

            return str.ToString();
        }
    }

    // RepEnumLB
    // Reply to Enumerate Leaderboard
    public class RepEnumLB
    {
        public uint             _uiLbSize;
        public uint             _uiRepUserCount;
        public uint             _uiAttrPerUser;
        public RepEnumLBUser[]  _users;

        public void ReadFrom(BinaryReader reader)
        {
            _uiLbSize           = reader.ReadUInt32();
            _uiRepUserCount     = reader.ReadUInt32();
            _uiAttrPerUser      = reader.ReadUInt32();

            _users              = new RepEnumLBUser[_uiRepUserCount];
            for(uint ndx=0; ndx<_uiRepUserCount; ndx++)
            {
                _users[ndx] = new RepEnumLBUser((int)_uiAttrPerUser);
                _users[ndx].ReadFrom(reader);
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            _uiRepUserCount = (uint)_users.Length;

            writer.Write(_uiLbSize);
            writer.Write(_uiRepUserCount);
            writer.Write(_uiAttrPerUser);

            for(uint ndx=0; ndx<_uiRepUserCount; ndx++)
            {
                _users[ndx].WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiLbSize=" + _uiLbSize+
                "\n_uiRepUserCount=" + _uiRepUserCount+
                "\n_uiAttrPerUser=" + _uiAttrPerUser +
                "\n_users:\n");

            for(uint ndx=0; ndx < _users.Length; ndx++)
            {
                str.Append("\n "+ndx+":" + _users[ndx].ToString());
            }

            return str.ToString();
        }
    }

    // RepEnumLBUser
    // Single row in a reply to Enumerate Leaderboard (part ot RepEnumLB)
    public class RepEnumLBUser
    {
        public RepEnumLBUser(int iAttrCount)
        {
            _attribs = new MsgAttribData[iAttrCount];
        }

        public ulong            _ulUser;
        public uint             _uiRank;
        public long             _lRating;
        public byte             _bSizeXName;
        public byte             _bSizeNickname;
        public string           _xName;
        public string           _nickname;
        public MsgAttribData[]  _attribs;

        public void ReadFrom(BinaryReader reader)
        {
            _ulUser             = reader.ReadUInt64();
            _uiRank             = reader.ReadUInt32();
            _lRating            = reader.ReadInt64();
            _bSizeXName         = reader.ReadByte();
            _bSizeNickname      = reader.ReadByte();

            byte [] arrByte     = reader.ReadBytes(_bSizeXName);
            if (arrByte.Length != (int)_bSizeXName)
                throw new Exception("Error - RepEnumLBUser:: Bytes Read is not equal _bSizeXName");

            _xName              = Encoding.UTF8.GetString(arrByte);
            _nickname           = Encoding.Unicode.GetString(reader.ReadBytes(_bSizeNickname));

            for(int ndx=0; ndx<_attribs.Length; ndx++)
            {
                _attribs[ndx] = new MsgAttribData();
                _attribs[ndx].ReadFrom(reader);
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            byte[] encXName = Encoding.UTF8.GetBytes(_xName);
            _bSizeXName     = (byte) encXName.Length;

            byte[] encNick  = Encoding.Unicode.GetBytes(_nickname);
            _bSizeNickname  = (byte) encNick.Length;

            writer.Write(_ulUser);
            writer.Write(_uiRank);
            writer.Write(_lRating);
            writer.Write(_bSizeXName);
            writer.Write(_bSizeNickname);
            writer.Write(encXName);
            writer.Write(encNick);

            foreach(MsgAttribData attrib in _attribs)
            {
                attrib.WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_ulUser=0x" + _ulUser.ToString("x") +
                "\n_uiRank=" + _uiRank +
                "\n_lRating=" + _lRating +
                "\n_bSizeXName=" + _bSizeXName +
                "\n_bSizeNickname=" + _bSizeNickname +
                "\n_xName=" + _xName +
                "\n_nickname=" + _nickname +
                "\n_attribs=");

            for(int ndx=0; ndx < _attribs.Length; ndx++)
            {
                str.Append("\n" + _attribs[ndx].ToString());
            }

            return str.ToString();
        }
    }

    // MsgAttribData
    // Attribute with data. Used in several messages.
    public class MsgAttribData
    {
        public ushort   _usAttrId;
        public byte     _bAttrType;
        public object   _value;

        public void ReadFrom(BinaryReader reader)
        {
            _usAttrId   = reader.ReadUInt16();
            _bAttrType  = reader.ReadByte();

            switch((AttrType)_bAttrType)
            {
                case AttrType.None:
                    break;
                case AttrType.Long:
                    _value = (object) reader.ReadInt32();
                    break;
                case AttrType.LongLong:
                    _value = (object) reader.ReadInt64();
                    break;
                case AttrType.Double:
                    _value = (object) reader.ReadDouble();
                    break;
                case AttrType.String:
                    if(_usAttrId == SpecialAttrib.Nickname)
                    {
                        // Handle nickname's special case
                        byte bNickSize = reader.ReadByte();
                        _value = (object) Encoding.Unicode.GetString(reader.ReadBytes(bNickSize));
                    }
                    else
                    {
                        ushort usSize = reader.ReadUInt16();
                        _value = (object) Encoding.UTF8.GetString(reader.ReadBytes(usSize));
                    }
                    break;
                default:
                    throw new Exception("Invalid attribute type "+_bAttrType);
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_usAttrId);
            writer.Write(_bAttrType);

            switch((AttrType)_bAttrType)
            {
                case AttrType.None:
                    break;
                case AttrType.Long:
                    writer.Write((int)_value);
                    break;
                case AttrType.LongLong:
                    writer.Write((long)_value);
                    break;
                case AttrType.Double:
                    writer.Write((double)_value);
                    break;
                case AttrType.String:
                    if(_usAttrId == SpecialAttrib.Nickname)
                    {
                        // Handle nickname's special case
                        byte[] nickbin = Encoding.Unicode.GetBytes((string)_value);
                        writer.Write((byte)nickbin.Length);
                        writer.Write(nickbin);
                    }
                    else
                    {
                        byte[] stringbin = Encoding.UTF8.GetBytes((string)_value);
                        writer.Write((ushort)stringbin.Length);
                        writer.Write(stringbin);
                    }
                    break;
                default:
                    throw new Exception("Invalid attribute type "+_bAttrType);
            }
        }

        public override string ToString()
        {
            return string.Format("_usAttrId={0} _bAttrType={1} _value={2}",
                _usAttrId, _bAttrType, (_value != null ? _value : "(null)"));
        }
    }

    // MsgReset
    // Reset message
    public class MsgReset
    {
        public uint titleId;
        public ulong userId;
        public uint leaderBoardType;
        public xonline.common.protocol.TeamTickets _teamTickets = null;

        public void ReadFrom(BinaryReader reader)
        {
            titleId         = reader.ReadUInt32();
            userId          = reader.ReadUInt64();
            leaderBoardType = reader.ReadUInt32();

            try
            {
                _teamTickets = new xonline.common.protocol.TeamTickets(reader);
            }
            catch (PeekCharEndOfStreamException)
            {
                //This tells us there were no more data as peekchar would have told us
                //This is different than end of stream while in the middle of deserializing an object
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(titleId);
            writer.Write(userId);
            writer.Write(leaderBoardType);

            if(_teamTickets != null)
            {
                _teamTickets.WriteStream(writer);
            }
        }

        public override string ToString()
        {
            return
                "\ntitleId=0x"+titleId.ToString("x")+
                "\nuserId=0x"+userId.ToString("x")+
                "\nleaderBoardType="+leaderBoardType+
                "\n_teamTickets: "+(_teamTickets != null ? _teamTickets.ToString() : "(null)");
        }

        public string GetXRL()
        {
            return "/xstats/xstatsreset.ashx";
        }
    }

    // MsgCommitAttachment
    // CommitAttachment message.
    public class MsgCommitAttachment
    {
        public uint     _uiTitleId;
        public uint     _uiAttSize;
        public uint     _uiAttSizeUncomp;
        public ushort   _usSizePathName;
        public ushort   _usRefCount;
        public string   _pathName;
        public MsgCommitAttachmentReference[] _refs;

        public void WriteTo(BinaryWriter writer)
        {
            byte[] encPathName  = Encoding.UTF8.GetBytes(_pathName);
            _usSizePathName     = (ushort) encPathName.Length;
            _usRefCount         = (ushort) _refs.Length;

            writer.Write(_uiTitleId);
            writer.Write(_uiAttSize);
            writer.Write(_uiAttSizeUncomp);
            writer.Write(_usSizePathName);
            writer.Write(_usRefCount);
            writer.Write(encPathName);

            foreach(MsgCommitAttachmentReference reference in _refs)
            {
                reference.WriteTo(writer);
            }
        }

        public void ReadFrom(BinaryReader reader)
        {
            _uiTitleId      = reader.ReadUInt32();
            _uiAttSize      = reader.ReadUInt32();
            _uiAttSizeUncomp= reader.ReadUInt32();
            _usSizePathName = reader.ReadUInt16();
            _usRefCount     = reader.ReadUInt16();

            if(_usRefCount > ProtocolConstant.MaxSpecsPerSetDataRequest)
                throw new Exception("_usRefCount("+_usRefCount+")>ProtocolConstant.MaxSpecsPerSetDataRequest("+ProtocolConstant.MaxSpecsPerSetDataRequest+")");

            _pathName       = Encoding.UTF8.GetString(reader.ReadBytes(_usSizePathName));
            _refs           = new MsgCommitAttachmentReference[_usRefCount];

            for(uint ndx=0; ndx < _usRefCount; ndx++)
            {
                _refs[ndx] = new MsgCommitAttachmentReference();
                _refs[ndx].ReadFrom(reader);
            }
        }

        public override string ToString()
        {
            return
                " _uiTitleId:0x"+_uiTitleId.ToString("x")+
                " _uiAttSize:"+_uiAttSize+
                " _uiAttSizeUncomp:"+_uiAttSizeUncomp+
                " _usSizePathName:"+_usSizePathName+
                " _usRefCount:"+_usRefCount+
                " _pathName:"+_pathName+
                " _refs:"+MsgCommitAttachmentReference.ToString(_refs);
        }
    }

    // MsgCommitAttachmentReference
    // Attachment reference part of MsgCommitAttachment
    public class MsgCommitAttachmentReference
    {
        public uint     _uiLb;
        public ulong    _ulUser;

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_uiLb);
            writer.Write(_ulUser);
        }

        public void ReadFrom(BinaryReader reader)
        {
            _uiLb           = reader.ReadUInt32();
            _ulUser         = reader.ReadUInt64();
        }

        public override string ToString()
        {
            return
                " _uiLb:"+_uiLb+
                " _ulUser:"+_ulUser;
        }

        public static string ToString(IList msgs)
        {
            StringBuilder str = new StringBuilder();
            foreach(MsgCommitAttachmentReference msg in msgs)
            {
                str.Append(msg.ToString());
            }
            return str.ToString();
        }
    }

    // MsgWebEnumLB
    // Message Web Enumerate Leaderboard
    public class MsgWebEnumLB
    {
        public uint     _uiTitleId;             // Title ID
        public uint     _uiLb;                  // Leaderboard id
        public ulong    _ulPivotOrPageStart;    // if _bIsPivotUser == 0, this is the page start, otherwise this is the pivot user
        public byte     _bIsPivotUser;          // Defines if _ulPivotOrPageStart is the page start or the pivot user
        public uint     _uiPageSize;            // Page size

        public void ReadFrom(BinaryReader reader)
        {
            _uiTitleId      = reader.ReadUInt32();
            _uiLb           = reader.ReadUInt32();
            _ulPivotOrPageStart = reader.ReadUInt64();
            _bIsPivotUser   = reader.ReadByte();
            _uiPageSize     = reader.ReadUInt32();

            if ( _uiPageSize == 0)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.COMMON_HACK_34,
                    "Invalid MsgEnumLb.   _uiPageSize was 0!");
            }


        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_uiTitleId);
            writer.Write(_uiLb);
            writer.Write(_ulPivotOrPageStart);
            writer.Write(_bIsPivotUser);
            writer.Write(_uiPageSize);
        }

        public override string ToString()
        {
            return
                "\n_uiTitleId=0x"+_uiTitleId.ToString("x")+
                "\n_uiLb="+_uiLb+
                "\n_ulPivotOrPageStart="+_ulPivotOrPageStart+
                "\n_bIsPivotUser="+_bIsPivotUser+
                "\n_uiPageSize="+_uiPageSize;
        }
    }

    // RepWebEnumLB
    // Reply to Web Enumerate Leaderboard
    public class RepWebEnumLB
    {
        public uint                 _uiLbSize;
        public ulong                _ulLastResetTime;
        public uint                 _uiRepUserCount;
        public RepWebEnumLBUser[]   _users;

        public void ReadFrom(BinaryReader reader)
        {
            _uiLbSize           = reader.ReadUInt32();
            _ulLastResetTime    = reader.ReadUInt64();
            _uiRepUserCount     = reader.ReadUInt32();

            _users              = new RepWebEnumLBUser[_uiRepUserCount];
            for(uint ndx=0; ndx<_uiRepUserCount; ndx++)
            {
                _users[ndx] = new RepWebEnumLBUser();
                _users[ndx].ReadFrom(reader);
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            _uiRepUserCount = (uint)_users.Length;

            writer.Write(_uiLbSize);
            writer.Write(_ulLastResetTime);
            writer.Write(_uiRepUserCount);

            for(uint ndx=0; ndx<_uiRepUserCount; ndx++)
            {
                _users[ndx].WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder();

            str.AppendFormat(
                "\n_uiLbSize={0}"+
                "\n_ulLastResetTime={1}"+
                "\n_uiRepUserCount={2}" +
                "\n_users:\n",
                _uiLbSize,
                _ulLastResetTime,
                _uiRepUserCount);

            for(uint ndx=0; ndx < _users.Length; ndx++)
            {
                str.AppendFormat("\n {0}:{1}", ndx.ToString(), _users[ndx].ToString());
            }

            return str.ToString();
        }
    }

    // RepEnumLBUser
    // Single row in a reply to Enumerate Leaderboard (part ot RepEnumLB)
    public class RepWebEnumLBUser
    {
        public ulong            _ulUser;
        public uint             _uiRank;
        public long             _lRating;
        public byte             _bAttribCount;
        public MsgAttribData[]  _attribs;

        public void ReadFrom(BinaryReader reader)
        {
            _ulUser             = reader.ReadUInt64();
            _uiRank             = reader.ReadUInt32();
            _lRating            = reader.ReadInt64();
            _bAttribCount       = reader.ReadByte();

            _attribs = new MsgAttribData[_bAttribCount];
            for(int ndx=0; ndx<_attribs.Length; ndx++)
            {
                _attribs[ndx] = new MsgAttribData();
                _attribs[ndx].ReadFrom(reader);
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_ulUser);
            writer.Write(_uiRank);
            writer.Write(_lRating);
            writer.Write(_bAttribCount);

            foreach(MsgAttribData attrib in _attribs)
            {
                attrib.WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder();

            str.AppendFormat(
                "\n_ulUser=0x{0}" +
                "\n_uiRank={1}" +
                "\n_lRating={2}" +
                "\n_attribs=",
                _ulUser.ToString("x"),
                _uiRank.ToString(),
                _lRating.ToString());

            for(int ndx=0; ndx < _attribs.Length; ndx++)
            {
                str.Append("\n" + _attribs[ndx].ToString());
            }

            return str.ToString();
        }
    }

    // ReqRemoveAtt
    // Remove Attachment request
    public class MsgRemoveAtt
    {
        public ushort       _usSizeAttachPathName = 0;
        public string       _attachPathName       = null;

        public void ReadFrom(BinaryReader reader)
        {
            _usSizeAttachPathName = reader.ReadUInt16();
            _attachPathName = Encoding.UTF8.GetString(reader.ReadBytes(_usSizeAttachPathName));
        }

        public void WriteTo(BinaryWriter writer)
        {
            byte[] encAttachPathName = Encoding.UTF8.GetBytes(_attachPathName);
            _usSizeAttachPathName = (ushort) encAttachPathName.Length;

            writer.Write(_usSizeAttachPathName);
            writer.Write(encAttachPathName);
        }

        public override string ToString()
        {
            return
                "\n_usSizeAttachPathName=" + _usSizeAttachPathName +
                "\n_attachPathName=" + _attachPathName != null ? _attachPathName : "(null)";
        }
    }

    // RepRemoveAtt
    public class RepRemoveAtt
    {
        public ushort   _usPuidCount    = 0;
        public ulong[]  _puids          = null;

        public void ReadFrom(BinaryReader br)
        {
            _usPuidCount = br.ReadUInt16();
            _puids = new ulong[_usPuidCount];

            for(int i=0; i < _puids.Length; i++)
            {
                _puids[i] = br.ReadUInt64();
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usPuidCount = (ushort) _puids.Length;

            bw.Write(_usPuidCount);

            for(int i=0; i < _puids.Length; i++)
            {
                bw.Write(_puids[i]);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_usPuidCount=" + _usPuidCount +
                "\n_puids=");

            if(_puids != null)
            {
                for(int i=0; i < _puids.Length; i++)
                {
                    str.Append(" 0x"+_puids[i].ToString("x"));
                }
            }

            return str.ToString();
        }
    }

    /// <summary>
    /// ReqStatPost
    /// </summary>
    /// <param name="TitleID">Title ID</param>
    /// <param name="ProcCount">Count of procedures</param>
    /// <param name="Procs">Procedure calls</param>
    /// <param name="TeamTickets">Team Tickets objects</param>
    /// <remarks>
    /// Supports running leaderboard operator procedures as defined in StatPostProcedure
    /// </remarks>
    public class ReqStatPost
    {
        public uint         _uiTitleId   = 0;
        public ushort       _usProcCount = 0;
        public MsgStatPostProcedureCall[] _procs = null;
        public xonline.common.protocol.TeamTickets _teamTickets = null;

        public string GetXRL()
        {
            return "/xstats/statpost.ashx";
        }

        public void ReadFrom(BinaryReader reader)
        {
            _uiTitleId      = reader.ReadUInt32();
            _usProcCount    = reader.ReadUInt16();

            if(_usProcCount > ProtocolConstant.MaxProcedureCount)
            {
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_PROCEDURES, XEvent.Id.XSTATSFD_INVALID_REQUEST_4,
                    "Too many procedures (" + _usProcCount + ")");
            }

            _procs = new MsgStatPostProcedureCall[_usProcCount];
            for(ushort i=0; i < _procs.Length; i++)
            {
                _procs[i] = new MsgStatPostProcedureCall();
                _procs[i].ReadFrom(reader);
            }

            try
            {
                _teamTickets = new xonline.common.protocol.TeamTickets(reader);
            }
            catch (PeekCharEndOfStreamException)
            {
                //We are not using peek char anymore to detetect end of stream.
            }
            

            Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_LOW, ToString());

        }

        public void WriteTo(BinaryWriter writer)
        {
            _usProcCount = (ushort) _procs.Length;

            writer.Write(_uiTitleId);
            writer.Write(_usProcCount);

            for(ushort i=0; i < _usProcCount; i++)
            {
                _procs[i].WriteTo(writer);
            }

            if(_teamTickets != null)
            {
                _teamTickets.WriteStream(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiTitleId="+_uiTitleId+
                "\n_usProcCount="+_usProcCount+
                "\n_procs: ");

            if(_procs != null)
            {
                for(ushort i=0; i < _procs.Length; i++)
                {
                    str.Append(_procs[i].ToString());
                }
            }

            str.Append("\n_teamTickets: "+(_teamTickets != null ? _teamTickets.ToString() : "(null)"));

            return str.ToString();
        }
    }


    // MsgStatPostProcedureCall
    public class MsgStatPostProcedureCall
    {
        public ushort       _usProcId = 0;
        public ushort       _usParamCount = 0;
        public MsgStatPostParameter[] _params = null;

        public void ReadFrom(BinaryReader reader)
        {
            _usProcId = reader.ReadUInt16();
            _usParamCount = reader.ReadUInt16();

            if(_usParamCount > ProtocolConstant.MaxStatPostParamCount)
            {
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_PARAMETERS, XEvent.Id.XSTATSFD_INVALID_REQUEST_5,
                    "Procedure id: "+_usProcId+" has too many parameters ("+ _usParamCount +")");
            }

            _params = new MsgStatPostParameter[_usParamCount];

            for(ushort i=0; i < _usParamCount; i++)
            {
                _params[i] = new MsgStatPostParameter();
                _params[i].ReadFrom(reader);
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            _usParamCount = (ushort) _params.Length;

            writer.Write(_usProcId);
            writer.Write(_usParamCount);

            for(ushort i=0; i < _usParamCount; i++)
            {
                _params[i].WriteTo(writer);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_usProcId="+_usProcId+
                "\n_usParamCount="+_usParamCount+
                "\n_params: ");

            if(_params != null)
            {
                for(ushort i=0; i < _params.Length; i++)
                {
                    // BUGBUG: add extra check on _param[i] != null. Repeat this on the rest of the file.
                    str.Append(_params[i].ToString());
                }
            }

            return str.ToString();
        }
    }

    // MsgStatPostParameter
    public class MsgStatPostParameter
    {
        public byte         _bParamType = 0;
        public object       _data = null;

        public void ReadFrom(BinaryReader reader)
        {
            _bParamType = reader.ReadByte();

            switch(_bParamType)
            {
                case StatParam.Null:
                    // Eat a byte.  It's unused but the console marshaller
                    // requires something to be written.
                    reader.ReadByte();
                    break;
                case StatParam.Int8:
                    _data = (object) reader.ReadByte(); // BUGBUG: sign?
                    break;
                case StatParam.Int16:
                    _data = (object) reader.ReadInt16();
                    break;
                case StatParam.Int32:
                    _data = (object) reader.ReadInt32();
                    break;
                case StatParam.Int64:
                    _data = (object) reader.ReadInt64();
                    break;
                case StatParam.Float:
                    _data = (object) reader.ReadDouble();
                    break;
                case StatParam.Utf8string:
                {
                    ushort strsize = reader.ReadUInt16();

                    if(strsize > ProtocolConstant.MaxUtf8StringParamSize)
                    {
                        throw new Exception(
                            "Utf8String parameter size greater than allowed max (" +
                            ProtocolConstant.MaxUtf8StringParamSize + ")");
                    }

                    _data = (object) Encoding.UTF8.GetString(reader.ReadBytes(strsize));
                    break;
                }
                case StatParam.Puid:
                    _data = (object) reader.ReadUInt64();
                    break;
                default:
                    throw new Exception(
                        "Invalid parameter type " + _bParamType.ToString());
            }
        }

        public void WriteTo(BinaryWriter writer)
        {
            writer.Write(_bParamType);

            switch(_bParamType)
            {
                case StatParam.Null:
                    // Write a byte.  It's unused but the console unmarshaller
                    // requires something to be present.
                    writer.Write((byte)0);
                    break;
                case StatParam.Int8:
                    writer.Write((byte)_data);
                    break;
                case StatParam.Int16:
                    writer.Write((short)Convert.ToInt16(_data));
                    break;
                case StatParam.Int32:
                    writer.Write((int)_data);
                    break;
                case StatParam.Int64:
                    writer.Write((long)_data);
                    break;
                case StatParam.Float:
                    writer.Write((double)_data);
                    break;
                case StatParam.Utf8string:
                {
                    byte[] encstring = Encoding.UTF8.GetBytes((string)_data);
                    writer.Write((ushort) encstring.Length);
                    writer.Write(encstring);
                    break;
                }
                case StatParam.Puid:
                    writer.Write((ulong)_data);
                    break;
                default:
                    throw new Exception(
                        "Invalid parameter type " + _bParamType.ToString());
            }
        }

        public override string ToString()
        {
            return "("+_bParamType+")"+
                (_data == null ? "(null)" : _data.ToString()) + " ";
        }
    }

    // ReqStatUnitGet
    public class ReqStatUnitGet // BUGBUG: name doesn't match with reply's. words inverted.
    {
        public uint     _uiTitleId  = 0;
        public ulong    _ulPuid1    = 0;
        public ulong    _ulPuid2    = 0;
        public ulong    _ulPuid3    = 0;
        public ulong    _ulPuid4    = 0;
        public ushort   _usSpecCount= 0;
        public MsgUnitStatGetSpec[] _specs = null;

        public void ReadFrom(BinaryReader br)
        {
            _uiTitleId  = br.ReadUInt32();
            _ulPuid1    = br.ReadUInt64();
            _ulPuid2    = br.ReadUInt64();
            _ulPuid3    = br.ReadUInt64();
            _ulPuid4    = br.ReadUInt64();
            _usSpecCount= br.ReadUInt16();

            if(_usSpecCount > ProtocolConstant.MaxStatUnitGetSpecs)
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_SPECS, XEvent.Id.XSTATSFD_INVALID_REQUEST_6,
                    "_usSpecCount("+_usSpecCount+" > MaxStatUnitGetSpecs("+ProtocolConstant.MaxStatUnitGetSpecs+")");

            _specs = new MsgUnitStatGetSpec[_usSpecCount];
            for(ushort i=0; i < _usSpecCount; i++)
            {
                _specs[i] = new MsgUnitStatGetSpec();
                _specs[i].ReadFrom(br);
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usSpecCount = (ushort) _specs.Length;

            bw.Write(_uiTitleId);
            bw.Write(_ulPuid1);
            bw.Write(_ulPuid2);
            bw.Write(_ulPuid3);
            bw.Write(_ulPuid4);
            bw.Write(_usSpecCount);

            for(ushort i=0; i < _usSpecCount; i++)
            {
                _specs[i].WriteTo(bw);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiTitleId=0x"+ _uiTitleId.ToString("x")+
                "\n_ulPuid1=0x" +  _ulPuid1.ToString("x")+
                "\n_ulPuid2=0x" +  _ulPuid2.ToString("x")+
                "\n_ulPuid3=0x" +  _ulPuid3.ToString("x")+
                "\n_ulPuid4=0x" +  _ulPuid4.ToString("x")+
                "\n_usSpecCount="+ _usSpecCount +
                "\n_specs:");

            if(_specs != null)
            {
                for(int i=0; i < _specs.Length; i++)
                {
                    if(_specs[i] != null)
                    {
                        str.Append(_specs[i].ToString());
                    }
                }
            }

            return str.ToString();
        }
    }

    // MsgUnitStatGetSpec
    public class MsgUnitStatGetSpec
    {
        public uint         _uiLbId     = 0;
        public ushort       _usNumStats = 0;
        public ushort[]     _statIds    = null;

        public void ReadFrom(BinaryReader br)
        {
            _uiLbId     = br.ReadUInt32();
            _usNumStats = br.ReadUInt16();

            if(_usNumStats > ProtocolConstant.MaxAttrPerUnitSpec)
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_STATS, XEvent.Id.XSTATSFD_INVALID_REQUEST_7,
                    "_usNumStats("+_usNumStats+" > MaxAttrPerSpec("+ProtocolConstant.MaxAttrPerUnitSpec+")");

            _statIds = new ushort[_usNumStats];

            for(ushort i=0; i < _usNumStats; i++)
            {
                _statIds[i] = br.ReadUInt16();
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usNumStats = (ushort) _statIds.Length;

            bw.Write(_uiLbId);
            bw.Write(_usNumStats);

            for(ushort i=0; i < _usNumStats; i++)
            {
                bw.Write(_statIds[i]);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "_uiLbId = " + _uiLbId +
                "_usNumStats = " + _usNumStats +
                "_statIds: ");

            if(_statIds != null)
            {
                for(int i=0; i < _statIds.Length; i++)
                {
                    str.Append(" "+i);
                }
            }

            return str.ToString();
        }
    }

    // RepUnitStatGet
    public class RepUnitStatGet
    {
        public ushort                   _usSpecCount = 0;
        public MsgUnitStatGetSpecData[] _specs       = null;

        public void ReadFrom(BinaryReader br)
        {
            _usSpecCount = br.ReadUInt16();
            _specs = new MsgUnitStatGetSpecData[_usSpecCount];

            for(ushort i=0; i < _usSpecCount; i++)
            {
                _specs[i] = new MsgUnitStatGetSpecData();
                _specs[i].ReadFrom(br);
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usSpecCount = (ushort) _specs.Length;
            bw.Write(_usSpecCount);

            for(ushort i=0; i < _usSpecCount; i++)
            {
                _specs[i].WriteTo(bw);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_usSpecCount="+_usSpecCount+
                "\n_specs: ");

            if(_specs != null)
            {
                for(int i=0; i < _specs.Length; i++)
                {
                    if(_specs[i] != null)
                    {
                        str.Append(_specs[i].ToString());
                    }
                }
            }

            return str.ToString();
        }
    }

    // MsgUnitStatGetSpecData
    public class MsgUnitStatGetSpecData
    {
        public uint             _uiLbId;
        public ushort           _usNumStats;
        public MsgAttribData[]  _stats;

        public void ReadFrom(BinaryReader br)
        {
            _uiLbId = br.ReadUInt32();
            _usNumStats = br.ReadUInt16();
            _stats = new MsgAttribData[_usNumStats];
            for(ushort i=0; i < _usNumStats; i++)
            {
                _stats[i] = new MsgAttribData();
                _stats[i].ReadFrom(br);
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usNumStats = (ushort) _stats.Length;

            bw.Write(_uiLbId);
            bw.Write(_usNumStats);

            for(ushort i=0; i < _usNumStats; i++)
            {
                _stats[i].WriteTo(bw);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiLbId="+_uiLbId+
                "\n_usNumStats="+_usNumStats+
                "\n_stats:");

            if(_stats != null)
            {
                for(int i=0; i < _stats.Length; i++)
                {
                    if(_stats[i] != null)
                    {
                        str.Append(" " + _stats[i].ToString());
                    }
                }
            }

            return str.ToString();
        }
    }

    // ReqUnitEnum
    public class ReqUnitEnum
    {
        public uint     _uiTitleId      = 0;
        public uint     _uiLbId         = 0;
        public uint     _uiFlags        = 0;
        public ulong    _ulPuid         = 0;
        public ushort   _usPageSize     = 0;
        public ushort   _usStatCount    = 0;
        public ushort[] _statIds        = null;

        public void ReadFrom(BinaryReader br)
        {
            _uiTitleId      = br.ReadUInt32();
            _uiLbId         = br.ReadUInt32();
            _uiFlags        = br.ReadUInt32();

            if( (_uiFlags & UnitEnumFlags.SortActivity) != 0
                && (_uiFlags & UnitEnumFlags.SortRating) != 0 )
                throw new Exception("Invalid flags. SortActivity and SortRating flags are mutually exclusive.");

            if((_uiFlags & ~(UnitEnumFlags.SortActivity |
                           UnitEnumFlags.SortRating)) != 0)
            {
                throw new Exception("Invalid flags.");
            }

            _ulPuid         = br.ReadUInt64();
            _usPageSize     = br.ReadUInt16();

            if(_usPageSize == 0)
                throw new Exception("Error: _usPageSize is zero");

            _usStatCount    = br.ReadUInt16();

            if(_usStatCount > ProtocolConstant.MaxAttrPerUnitSpec)
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_STATS, XEvent.Id.XSTATSFD_INVALID_REQUEST_8,
                    "_usStatCount (" + _usStatCount + ") > MaxAttrPerSpec ("+
                    ProtocolConstant.MaxAttrPerUnitSpec + ")");

            _statIds        = new ushort[_usStatCount];
            for(ushort i=0; i < _usStatCount; i++)
            {
                _statIds[i] = br.ReadUInt16();
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usStatCount = (ushort) _statIds.Length;

            bw.Write(_uiTitleId);
            bw.Write(_uiLbId);
            bw.Write(_uiFlags);
            bw.Write(_ulPuid);
            bw.Write(_usPageSize);
            bw.Write(_usStatCount);

            for(ushort i=0; i < _usStatCount; i++)
            {
                bw.Write(_statIds[i]);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_uiTitleId=0x"+  _uiTitleId.ToString("x")+
                "\n_uiLbId="+       _uiLbId+
                "\n_uiFlags="+      _uiFlags+
                "\n_ulPuid=0x"+     _ulPuid.ToString("x")+
                "\n_usPageSize="+   _usPageSize+
                "\n_usStatCount="+  _usStatCount+
                "\n_statIds: ");

            if(_statIds != null)
            {
                for(ushort i=0; i < _usStatCount; i++)
                {
                    str.Append(" "+_statIds[i]);
                }
            }

            return str.ToString();
        }
    }

    // RepUnitEnum
    public class RepUnitEnum
    {
        public ushort               _usNumEntries   = 0;
        public MsgUnitEnumEntry[]   _entries        = null;

        public void ReadFrom(BinaryReader br)
        {
            _usNumEntries = br.ReadUInt16();
            _entries = new MsgUnitEnumEntry[_usNumEntries];

            for(ushort i=0; i < _usNumEntries; i++)
            {
                _entries[i] = new MsgUnitEnumEntry();
                _entries[i].ReadFrom(br);
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usNumEntries = (ushort) _entries.Length;
            bw.Write(_usNumEntries);

            for(ushort i=0; i < _usNumEntries; i++)
            {
                _entries[i].WriteTo(bw);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_usNumEntries=" + _usNumEntries +
                "\n_entries: ");

            if(_entries != null)
            {
                for(ushort i=0; i < _entries.Length; i++)
                {
                    str.Append(_entries[i].ToString());
                }
            }

            return str.ToString();
        }
    }

    // MsgUnitEnumEntry
    public class MsgUnitEnumEntry
    {
        public ulong            _puid1          = 0;
        public ulong            _puid2          = 0;
        public ulong            _puid3          = 0;
        public ulong            _puid4          = 0;
        public ushort           _usSizeName1    = 0;
        public string           _name1          = String.Empty;
        public ushort           _usSizeName2    = 0;
        public string           _name2          = String.Empty;
        public ushort           _usSizeName3    = 0;
        public string           _name3          = String.Empty;
        public ushort           _usSizeName4    = 0;
        public string           _name4          = String.Empty;
        public ushort           _usStatCount    = 0;
        public MsgAttribData[]  _stats          = null;

        public void ReadFrom(BinaryReader br)
        {
            _puid1        = br.ReadUInt64();
            _puid2        = br.ReadUInt64();
            _puid3        = br.ReadUInt64();
            _puid4        = br.ReadUInt64();
            _usSizeName1  = br.ReadUInt16();
            _name1        = Encoding.UTF8.GetString(br.ReadBytes(_usSizeName1));
            _usSizeName2  = br.ReadUInt16();
            _name2        = Encoding.UTF8.GetString(br.ReadBytes(_usSizeName2));
            _usSizeName3  = br.ReadUInt16();
            _name3        = Encoding.UTF8.GetString(br.ReadBytes(_usSizeName3));
            _usSizeName4  = br.ReadUInt16();
            _name4        = Encoding.UTF8.GetString(br.ReadBytes(_usSizeName4));
            _usStatCount  = br.ReadUInt16();
            _stats        = new MsgAttribData[_usStatCount];
            for(ushort i=0; i < _usStatCount; i++)
            {
                _stats[i] = new MsgAttribData();
                _stats[i].ReadFrom(br);
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            byte[] encName1 = Encoding.UTF8.GetBytes(_name1);
            _usSizeName1 = (ushort) encName1.Length;
            byte[] encName2 = Encoding.UTF8.GetBytes(_name2);
            _usSizeName2 = (ushort) encName2.Length;
            byte[] encName3 = Encoding.UTF8.GetBytes(_name3);
            _usSizeName3 = (ushort) encName3.Length;
            byte[] encName4 = Encoding.UTF8.GetBytes(_name4);
            _usSizeName4 = (ushort) encName4.Length;

            bw.Write(_puid1);
            bw.Write(_puid2);
            bw.Write(_puid3);
            bw.Write(_puid4);
            bw.Write(_usSizeName1);
            bw.Write(encName1);
            bw.Write(_usSizeName2);
            bw.Write(encName2);
            bw.Write(_usSizeName3);
            bw.Write(encName3);
            bw.Write(_usSizeName4);
            bw.Write(encName4);
            bw.Write(_usStatCount);

            for(ushort i=0; i < _usStatCount; i++)
            {
                _stats[i].WriteTo(bw);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_puid1=0x"+      _puid1.ToString("x")+
                "\n_puid2=0x"+      _puid2.ToString("x")+
                "\n_puid3=0x"+      _puid3.ToString("x")+
                "\n_puid4=0x"+      _puid4.ToString("x")+
                "\n_usSizeName1="+  _usSizeName1+
                "\n_name1="+        _name1+
                "\n_usSizeName2="+  _usSizeName2+
                "\n_name2="+        _name2+
                "\n_usSizeName3="+  _usSizeName3+
                "\n_name3="+        _name3+
                "\n_usSizeName4="+  _usSizeName4+
                "\n_name4="+        _name4+
                "\n_usStatCount="+  _usStatCount+
                "\n_stats: ");

            if(_stats != null)
            {
                for(ushort i=0; i < _usStatCount; i++)
                {
                    if(_stats[i] != null)
                    {
                        str.Append(" " + _stats[i].ToString());
                    }
                }
            }

            return str.ToString();
        }
    }

    public class ReqCompCreateLb
    {
        public uint     _uiTitleId      = 0;
        public uint     _uiTemplateId   = 0;

        public void ReadFrom(BinaryReader br)
        {
            _uiTitleId      = br.ReadUInt32();
            _uiTemplateId   = br.ReadUInt32();
        }

        public void WriteTo(BinaryWriter bw)
        {
            bw.Write(_uiTitleId);
            bw.Write(_uiTemplateId);
        }

        public override string ToString()
        {
            return
                "\n_uiTitleId: 0x" + _uiTitleId.ToString("x")+
                "\n_uiTemplateId: "+ _uiTemplateId;
        }
    }

    public class RepCompCreateLb
    {
        public uint     _uiLbId     = 0;

        public void ReadFrom(BinaryReader br)
        {
            _uiLbId = br.ReadUInt32();
        }

        public void WriteTo(BinaryWriter bw)
        {
            bw.Write(_uiLbId);
        }

        public override string ToString()
        {
            return
                "\n_uiLbId: 0x" + _uiLbId.ToString("x");
        }
    }

    public class ReqCompDeleteLb
    {
        public uint     _uiTitleId      = 0;
        public uint     _uiLbId         = 0;

        public void ReadFrom(BinaryReader br)
        {
            _uiTitleId      = br.ReadUInt32();
            _uiLbId         = br.ReadUInt32();
        }

        public void WriteTo(BinaryWriter bw)
        {
            bw.Write(_uiTitleId);
            bw.Write(_uiLbId);
        }

        public override string ToString()
        {
            return
                "\n_uiTitleId: 0x" + _uiTitleId.ToString("x")+
                "\n_uiLbId: "+ _uiLbId;
        }
    }

    public class ReqFindRating
    {
        public uint     _uiTitleId      = 0;
        public uint     _uiLbId         = 0;
        public long     _lRating        = 0;

        public void ReadFrom(BinaryReader br)
        {
            _uiTitleId  = br.ReadUInt32();
            _uiLbId     = br.ReadUInt32();
            _lRating    = br.ReadInt64();
        }

        public void WriteTo(BinaryWriter bw)
        {
            bw.Write(_uiTitleId);
            bw.Write(_uiLbId);
            bw.Write(_lRating);
        }

        public override string ToString()
        {
            return
                "\n_uiTitleId: 0x" + _uiTitleId.ToString("x")+
                "\n_uiLbId: " + _uiLbId+
                "\n_lRating: " + _lRating;
        }
    }

    public class RepFindRating
    {
        public ulong    _ulPuid     = 0;
        public uint     _uiRank     = 0;
        public long     _lRating    = 0;

        public void ReadFrom(BinaryReader br)
        {
            _ulPuid = br.ReadUInt64();
            _uiRank = br.ReadUInt32();
            _lRating = br.ReadInt64();
        }

        public void WriteTo(BinaryWriter bw)
        {
            bw.Write(_ulPuid);
            bw.Write(_uiRank);
            bw.Write(_lRating);
        }

        public override string ToString()
        {
            return
                "\n_ulPuid: 0x"+_ulPuid.ToString("x")+
                "\n_uiRank: "+_uiRank+
                "\n_lRating: "+_lRating;
        }
    }

    public class ReqCertReset
    {
        public ulong    _ulPuid     = 0;

        public void ReadFrom(BinaryReader br)
        {
            _ulPuid = br.ReadUInt64();
        }

        public void WriteTo(BinaryWriter bw)
        {
            bw.Write(_ulPuid);
        }

        public override string ToString()
        {
            return
                "\n_ulPuid: 0x"+_ulPuid.ToString("x");
        }
    }

    public class ReqCertVerify
    {
        public ulong    _ulPuid     = 0;

        public void ReadFrom(BinaryReader br)
        {
            _ulPuid = br.ReadUInt64();
        }

        public void WriteTo(BinaryWriter bw)
        {
            bw.Write(_ulPuid);
        }

        public override string ToString()
        {
            return
                "\n_ulPuid: 0x"+_ulPuid.ToString("x");
        }
    }

    public class RepCertVerify
    {
        public ushort               _usEntryCount = 0;
        public MsgCertVerifyEntry[] _entries = null;

        public void ReadFrom(BinaryReader br)
        {
            _usEntryCount = br.ReadUInt16();
            _entries = new MsgCertVerifyEntry[_usEntryCount];
            for(int i=0; i < _entries.Length; i++)
            {
                _entries[i] = new MsgCertVerifyEntry();
                _entries[i].ReadFrom(br);
            }
        }

        public void WriteTo(BinaryWriter bw)
        {
            _usEntryCount = (ushort) _entries.Length;
            bw.Write(_usEntryCount);
            for(int i=0; i < _entries.Length; i++)
            {
                _entries[i].WriteTo(bw);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\n_usEntryCount:"+_usEntryCount+
                "\n_entries:");

            for(int i=0; i < _entries.Length; i++)
            {
                str.Append((_entries[i] != null ? _entries[i].ToString() : "(null)"));
            }

            return str.ToString();
        }
    }

    public class MsgCertVerifyEntry
    {
        public byte     _bLevel;
        public ushort   _usSizeDescription = 0;
        public string   _description;

        public void ReadFrom(BinaryReader br)
        {
            _bLevel = br.ReadByte();
            _usSizeDescription  = br.ReadUInt16();
            _description = Encoding.UTF8.GetString(br.ReadBytes((int)_usSizeDescription));
        }

        public void WriteTo(BinaryWriter bw)
        {
            byte[] binDescription = Encoding.UTF8.GetBytes(_description);
            _usSizeDescription = (ushort) binDescription.Length;

            bw.Write(_bLevel);
            bw.Write(_usSizeDescription);
            bw.Write(binDescription);
        }
    }
    #endregion

    #region Stats/Leaderboard V2 (Xenon) Protocol

    /// <summary>
    /// StatsColumn
    /// </summary>
    /// <param name="ColumnId">Stats column id (usually ordinal)</param>
    /// <param name="Type">Stats column datatype</param>
    /// <param name="Data">Stat data value</param>
    /// <remarks>
    /// Data object for holding the contents of a stat column.
    /// </remarks>
    public class StatsColumn : WireData
    {
        public ushort ColumnId;
        public byte Type = 0;
        protected object _data = null;

        public StatsColumn()
        {
        }

        public StatsColumn(ushort ColumnId, byte Type, object Data)
        {
            this.ColumnId = ColumnId;
            this.Type     = Type;
            this._data    = Data;
        }

        public object Data
        {
            get { return _data; }
            set { _data = value; }
        }

        /// <summary>
        /// ReadStream
        /// </summary>
        /// <param name="binaryReader">BinaryReader object that has the input stream</param>
        /// <returns>WireData object</returns>
        /// <remarks>
        /// Overrride of default WireData implementation.
        /// </remarks>
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            ColumnId = binaryReader.ReadUInt16();
            Type = binaryReader.ReadByte();

            switch(Type)
            {
                case StatParam.Null:
                case StatParam.Int8:
                    _data = (object) binaryReader.ReadByte();
                    break;
                case StatParam.Int16:
                    _data = (object) binaryReader.ReadInt16();
                    break;
                case StatParam.Int32:
                    _data = (object) binaryReader.ReadInt32();
                    break;
                case StatParam.Int64:
                    _data = (object) binaryReader.ReadInt64();
                    break;
                case StatParam.Float:
                    _data = (object) binaryReader.ReadDouble();
                    break;
                case StatParam.Utf8string:
                {
                    ushort strsize = binaryReader.ReadUInt16();

                    if(strsize > ProtocolConstant.MaxUtf8StringParamSize)
                    {
                        throw new Exception(
                            "Utf8String parameter size greater than allowed max (" +
                            ProtocolConstant.MaxUtf8StringParamSize + ")");
                    }

                    _data = (object) Encoding.UTF8.GetString(binaryReader.ReadBytes(strsize));
                    break;
                }
                case StatParam.Puid:
                    _data = (object) binaryReader.ReadUInt64();
                    break;
                default:
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST,
                                           XEvent.Id.COMMON_CODE_53,
                                           "Unexpected type: " + Type.ToString());
            }

            return this;
        }

        /// <summary>
        /// WriteStream
        /// </summary>
        /// <param name="binaryWriter">BinaryWriter object that has the output stream</param>
        /// <remarks>
        /// Overrride of default WireData implementation.
        /// </remarks>
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(ColumnId);
            binaryWriter.Write(Type);

            switch(Type)
            {
                case StatParam.Null:
                    binaryWriter.Write((Byte) 0);
                    break;
                case StatParam.Int8:
                    binaryWriter.Write((Byte) _data);
                    break;
                case StatParam.Int16:
                    binaryWriter.Write((Int16) _data);
                    break;
                case StatParam.Int32:
                    binaryWriter.Write((Int32) _data);
                    break;
                case StatParam.Int64:
                    binaryWriter.Write((Int64) _data);
                    break;
                case StatParam.Float:
                    binaryWriter.Write((Double) _data);
                    break;
                case StatParam.Utf8string:
                {
                    byte[] encstring = Encoding.UTF8.GetBytes((string) _data);
                    binaryWriter.Write((UInt16) encstring.Length);
                    binaryWriter.Write(encstring);
                    break;
                }
                case StatParam.Puid:
                    binaryWriter.Write((UInt64) _data);
                    break;
                default:
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST,
                                           XEvent.Id.COMMON_CODE_54,
                                           "Unexpected type: " + Type.ToString());
            }
        }
    }

    /// <summary>
    /// </summary>
    /// <param name="Puid">User PUID</param>
    /// <param name="Rating">User rating</param>
    /// <param name="GamerTagLength">Length of gamer tag string</param>
    /// <param name="GamerTag">Gamer tag string</param>
    /// <param name="ColumnCount">Count of columns</param>
    /// <param name="Columns">Stats columns collection</param>
    /// <remarks>
    /// Data object for a stats result row
    /// </remarks>
    public class StatsRow : WireData
    {
        public ulong Puid   = 0;
        public uint  Rank   = 0;
        public ulong Rating = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_OP_PARAM_DATA)]
        public uint GamerTagLength = 0;

        [WireInfo(SizeParam="GamerTagLength")]
        public string GamerTag = null;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_COL_COUNT)]
        public uint ColumnCount = 0;

        [WireInfo(SizeParam="ColumnCount")]
        public StatsColumn[] Columns = null;

        public StatsRow()
        {
        }

        /// <summary>
        /// StatsRow constructor
        /// </summary>
        /// <param name="puid">User ID for row</param>
        /// <param name="rank">Rank of row</param>
        /// <param name="rating">Rating of row</param>
        /// <param name="gamerTag">GamerTag for row</param>
        /// <param name="columns">Count of columns of data in row</param>
        /// <remarks>
        /// Constructor that sets values for row and allocates an array for column data
        /// </remarks>
        public StatsRow(ulong puid, uint rank, ulong rating, string gamerTag, uint columns)
        {
            Puid        = puid;
            Rank        = rank;
            Rating      = rating;
            GamerTag    = gamerTag;
            ColumnCount = columns;
            Columns     = new StatsColumn[columns];
        }
    }

    /// <summary>
    /// StatsResultSet
    /// </summary>
    /// <param name="ViewId">View id (leaderboard ID)</param>
    /// <param name="RowCount">Stat row count</param>
    /// <param name="Rows">Stat rows collection</param>
    /// <remarks>
    /// Data object for result set of stat query
    /// </remarks
    public class StatsResultSet : WireData
    {
        public ulong ViewId;
        public uint ViewSize = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ROW_COUNT)]
        public uint RowCount = 0;

        [WireInfo(SizeParam="RowCount")]
        public StatsRow[] Rows = null;
    }

    /// <summary>
    /// StatsSpec
    /// </summary>
    /// <param name="ViewId">View id (leaderboard id)</param>
    /// <param name="ColumnCount">Count of column id's</param>
    /// <param name="ColumnIds">Collection of column id's to query</param>
    /// <remarks>
    /// Data object representing a stats query
    /// </remarks>
    public class StatsSpec : WireData
    {
        public uint ViewId = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_COL_COUNT)]
        public uint ColumnCount = 0;

        [WireInfo(SizeParam="ColumnCount")]
        public ushort[] ColumnIds = null;
    }

    /// <summary>
    /// StatsOperatorParameter
    /// </summary>
    /// <param name="Type">Paramter data type (StatParamType)</param>
    /// <param name="Data">Parameter data</param>
    /// <remarks>
    /// Data object for a stats operator parameter
    /// </remarks>
    public class StatsOperatorParameter : WireData
    {
        public byte Type = 0;
        protected object _data = null;

        public StatsOperatorParameter()
        {
        }

        public StatsOperatorParameter(byte Type, object Data)
        {
            this.Type  = Type;
            this._data = Data;
        }

        public object Data
        {
            get { return _data; }
            set { _data = value; }
        }

        /// <summary>
        /// ReadStream
        /// </summary>
        /// <param name="binaryReader">BinaryReader object that has the input stream</param>
        /// <returns>WireData object</returns>
        /// <remarks>
        /// Overrride of default WireData implementation.
        /// </remarks>
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            Type = binaryReader.ReadByte();

            switch(Type)
            {
                case StatParam.Null:
                    // Eat a byte.  It's unused but the console marshaller
                    // requires something to be written.
                    binaryReader.ReadByte();
                    break;
                case StatParam.Int8:
                    _data = (object) binaryReader.ReadByte();
                    break;
                case StatParam.Int16:
                    _data = (object) binaryReader.ReadInt16();
                    break;
                case StatParam.Int32:
                    _data = (object) binaryReader.ReadInt32();
                    break;
                case StatParam.Int64:
                    _data = (object) binaryReader.ReadInt64();
                    break;
                case StatParam.Float:
                    _data = (object) binaryReader.ReadDouble();
                    break;
                case StatParam.Utf8string:
                {
                    ushort strsize = binaryReader.ReadUInt16();

                    if(strsize > ProtocolConstant.MaxUtf8StringParamSize)
                    {
                        throw new Exception(
                            "Utf8String parameter size greater than allowed max (" +
                            ProtocolConstant.MaxUtf8StringParamSize + ")");
                    }

                    _data = (object) Encoding.UTF8.GetString(binaryReader.ReadBytes(strsize));
                    break;
                }
                case StatParam.Puid:
                    _data = (object) binaryReader.ReadUInt64();
                    break;
                default:
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST,
                                           XEvent.Id.COMMON_CODE_55,
                                           "Unexpected _datatype: " + Type.ToString());
            }

            return this;
        }

        /// <summary>
        /// WriteStream
        /// </summary>
        /// <param name="binaryWriter">BinaryWriter object that has the output stream</param>
        /// <remarks>
        /// Overrride of default WireData implementation.
        /// </remarks>
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(Type);

            switch(Type)
            {
                case StatParam.Null:
                    // Write a byte.  It's unused but the console unmarshaller
                    // requires something to be present.
                    binaryWriter.Write((Byte) 0);
                    break;
                case StatParam.Int8:
                    binaryWriter.Write((Byte) _data);
                    break;
                case StatParam.Int16:
                    binaryWriter.Write((Int16) _data);
                    break;
                case StatParam.Int32:
                    binaryWriter.Write((Int32) _data);
                    break;
                case StatParam.Int64:
                    binaryWriter.Write((Int64) _data);
                    break;
                case StatParam.Float:
                    binaryWriter.Write((Double) _data);
                    break;
                case StatParam.Utf8string:
                {
                    byte[] encstring = Encoding.UTF8.GetBytes((string) _data);
                    binaryWriter.Write((UInt16) encstring.Length);
                    binaryWriter.Write(encstring);
                    break;
                }
                case StatParam.Puid:
                    binaryWriter.Write((UInt64) _data);
                    break;
                default:
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST,
                                           XEvent.Id.COMMON_CODE_56,
                                           "Unexpected _datatype: " + Type.ToString());
            }
        }

        public override string ToString(int indent)
        {
            StringBuilder bldr = new StringBuilder();

            bldr.Append("\n" + "".PadLeft(indent));
            bldr.Append("Type=" + Type + "\n");
            bldr.Append("".PadLeft(indent));
            bldr.Append("_data=");

            switch(Type)
            {
                case StatParam.Null:
                    bldr.Append("NULL");
                    break;
                case StatParam.Int8:
                    bldr.Append((Byte) _data);
                    break;
                case StatParam.Int16:
                    bldr.Append((Int16) _data);
                    break;
                case StatParam.Int32:
                    bldr.Append((Int32) _data);
                    break;
                case StatParam.Int64:
                    bldr.Append((Int64) _data);
                    break;
                case StatParam.Float:
                    bldr.Append((Double) _data);
                    break;
                case StatParam.Utf8string:
                {
                    byte[] encstring = Encoding.UTF8.GetBytes((string) _data);
                    bldr.Append((UInt16) encstring.Length);
                    bldr.Append(encstring);
                    break;
                }
                case StatParam.Puid:
                    bldr.Append((UInt64) _data);
                    break;
                default:
                    bldr.Append("UNKNOWN!");
                    break;
            }

            return bldr.ToString();
        }
    }

    /// <summary>
    /// StatsOperator
    /// </summary>
    /// <param name="OperatorId">Operator type</param>
    /// <param name="ParameterCount">Count of operator parameters</param>
    /// <param name="Parameters">Collection of parameters</param>
    /// <remarks>
    /// Data object for a stats operator
    /// </remarks>
    public class StatsOperator : WireData
    {
        public ushort OperatorId = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_OP_PARAMS)]
        public ushort ParameterCount = 0;

        [WireInfo(SizeParam="ParameterCount")]
        public StatsOperatorParameter[] Parameters = null;

        public StatsOperator()
        {
        }

        public StatsOperator(BinaryReader binaryReader)
        {
            base.ReadStream(binaryReader);
        }
    }

    /// <summary>
    /// StatsPostRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="OperatorCount">Count of operators</param>
    /// <param name="Operators">Collection of operators</param>
    /// <param name="TeamTickets">Collection of team tickets (optional)</param>
    /// <returns>StatsPostResponse</returns>
    /// <remarks>
    /// Batch of stat operator requests that generates StatsPostResponse.
    /// Operators dictate the functionality.
    /// Typical operators include REPLACE, ADD, MIN, MAX
    /// </remarks>
    public class StatsPostRequest : XRLObject2
    {
        public uint TitleId = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_OP_COUNT)]
        public ushort OperatorCount = 0;

        [WireInfo(SizeParam="OperatorCount")]
        public StatsOperator[] Operators = null;

        public TeamTickets TeamTickets = null;

        public override string Xrl
        {
            get { return "/xstats/xstatpostxe.ashx"; }
        }

        /// <summary>
        /// ReadStream
        /// </summary>
        /// <param name="binaryReader">BinaryReader object that has the input stream</param>
        /// <returns>WireData object</returns>
        /// <remarks>
        /// Overrride of default WireData implementation.
        /// </remarks>
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            TitleId       = binaryReader.ReadUInt32();
            OperatorCount = binaryReader.ReadUInt16();

            if (OperatorCount > XOn.XONLINE_MAX_STATS_OP_COUNT)
            {
                throw new XRLException(HResult.XONLINE_E_STAT_TOO_MANY_PROCEDURES, XEvent.Id.COMMON_HACK_40,
                    "Operators exceed max allowed (" + OperatorCount + ")");
            }
            ArrayList operators = new ArrayList();
            for (ushort i = 0; i < OperatorCount; i++)
            {
                operators.Add(new StatsOperator(binaryReader));
            }
            Operators = new StatsOperator[OperatorCount];
            operators.CopyTo(Operators);

            // Check to see if there are any team tickets
            try
            {
                
                TeamTickets = new TeamTickets(binaryReader);
            }
            catch (PeekCharEndOfStreamException)
            {
                //We are not using peek char anymore to detetect end of stream.
            }

            return this;
        }

        /// <summary>
        /// WriteStream
        /// </summary>
        /// <param name="binaryWriter">BinaryWriter object that has the output stream</param>
        /// <remarks>
        /// Overrride of default WireData implementation.
        /// </remarks>
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(TitleId);

            if (OperatorCount == 0 && Operators.Length > 0)
            {
                OperatorCount = (ushort) Operators.Length;
            }

            binaryWriter.Write(OperatorCount);

            foreach (StatsOperator op in Operators)
            {
                op.WriteStream(binaryWriter);
            }

            if (TeamTickets != null)
            {
                TeamTickets.WriteStream(binaryWriter);
            }
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(
                "\nTitleId=" + TitleId +
                "\nOperatorCount=" + OperatorCount +
                "\nOperators: ");

            if (Operators != null)
            {
                foreach (StatsOperator op in Operators)
                {
                    str.Append(op.ToString());
                }
            }

            str.Append("\nTeamTickets: " + (TeamTickets != null ? TeamTickets.ToString() : "(null)"));

            return str.ToString();
        }
    }

    /// <summary>
    /// StatsPostResponse
    /// </summary>
    /// <returns>TitleId</returns>
    /// <remarks>
    /// Response for StatPostRequest.
    /// </remarks>
    public class StatsPostResponse : XRLObject2
    {
        public uint TitleId = 0;

        // TODO: Return array of operation return codes
    }

    /// <summary>
    /// StatsReadRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="UserCount">Count of users</param>
    /// <param name="Users">Collection of user id's</param>
    /// <param name="SpecCount">Count of query specs</param>
    /// <param name="Specs">Collection of query specs</param>
    /// <returns>StatsReadResponse</returns>
    /// <remarks>
    /// Query for users and specific view columns.
    /// Results are generated with one result set per query spec with
    /// each user having a record in the result set.
    /// </remarks>
    public class StatsReadRequest : XRLObject2
    {
        public uint TitleId;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_USER_COUNT)]
        public uint UserCount;

        [WireInfo(SizeParam="UserCount")]
        public ulong[] Users = null;

        // TODO: make the spec count NPDB configurable
        [WireInfo(Max=XOn.XONLINE_MAX_STATS_SPEC_COUNT)]
        public uint SpecCount;

        [WireInfo(SizeParam="SpecCount")]
        public StatsSpec[] Specs = null;

        public override string Xrl
        {
            get { return "/xstats/xstatread.ashx"; }
        }
    }

    /// <summary>
    /// StatsEnumByUserRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="UserId">User id for beginning of page</param>
    /// <param name="PageSize">Count of max rows to retrieve for enum</param>
    /// <param name="Spec">Query spec</param>
    /// <returns>StatsReadResponse</returns>
    /// <remarks>
    /// Enumerate list of users starting with specified user id and
    /// including up to the number of rows specified by page size
    /// </remarks>
    public class StatsEnumByUserRequest : XRLObject2
    {
        public uint  TitleId  = 0;
        public ulong UserId   = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ENUM_COUNT, Min=1)]
        public uint  PageSize = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ENUM_SPEC_COUNT)]
        public uint  SpecsLen = 0;
        public StatsSpec[] Specs = null;

        public override string Xrl
        {
            get { return "/xstats/xstatenumbyuser.ashx"; }
        }
    }

    /// <summary>
    /// StatsEnumByRankRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="Rank">Rank value for beginning of page</param>
    /// <param name="PageSize">Count of max rows to retrieve for enum</param>
    /// <param name="Spec">Query spec</param>
    /// <returns>StatsReadResponse</returns>
    /// <remarks>
    /// Enumerate list of users starting with specified rank and
    /// including up to the number of rows specified by page size
    /// </remarks>
    public class StatsEnumByRankRequest : XRLObject2
    {
        public uint  TitleId  = 0;
        public ulong Rank     = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ENUM_COUNT, Min=1)]
        public uint  PageSize = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ENUM_SPEC_COUNT)]
        public uint  SpecsLen = 0;
        public StatsSpec[] Specs = null;

        public override string Xrl
        {
            get { return "/xstats/xstatenumbyrank.ashx"; }
        }
    }

    /// <summary>
    /// StatsEnumByRatingRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="Rating">Rating for beginning of page</param>
    /// <param name="PageSize">Count of max rows to retrieve for enum</param>
    /// <param name="Spec">Query spec</param>
    /// <returns>StatsReadResponse</returns>
    /// <remarks>
    /// Enumerate list of users starting with specified rating and
    /// including up to the number of rows specified by page size
    /// </remarks>
    public class StatsEnumByRatingRequest : XRLObject2
    {
        public uint  TitleId  = 0;
        public ulong Rating   = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ENUM_COUNT, Min=1)]
        public uint  PageSize = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ENUM_SPEC_COUNT)]
        public uint SpecsLen = 0;
        public StatsSpec[] Specs = null;

        public override string Xrl
        {
            get { return "/xstats/xstatenumbyrating.ashx"; }
        }
    }

    /// <summary>
    /// StatsReadResponse
    /// </summary>
    /// <param name="ResultsCount">Count of result sets</param>
    /// <param name="Results">Collection of result sets</param>
    /// <remarks>
    /// Response to StatsReadRequest.
    /// Contains collection of result sets for the corresponding query specs.
    /// </remarks>
    public class StatsReadResponse : XRLObject2
    {
        [WireInfo (Max=XOn.XONLINE_MAX_STATS_SPEC_COUNT)]
        public uint ResultsCount = 0;

        [WireInfo(SizeParam="ResultsCount")]
        public StatsResultSet[] Results = null;
    }

    public class StatsEnumResponse : XRLObject2
    {
        public ushort StatsResultSetLen = 0;
        [WireInfo(SizeParam="StatsResultSetLen")]
        public StatsResultSet[] Results = null;
    }

    public class StatsEstimateRankRequestStruct:XRLObject2
    {
        public int   m_nLbId = 0;
        public ulong m_ulRating = 0;
    }
    
    public class StatsEstimateRankForRatingsRequest:XRLObject2
    {
        public int  m_nTitleId = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ESTIMATE_RATING_COUNT)]
        public uint m_uRatingRequestCount = 0;

        [WireInfo(SizeParam="m_uRatingRequestCount")]
        public StatsEstimateRankRequestStruct[] m_arrRatingStruct = null;

        public override string Xrl
        {
            get { return "/xstats/xstatestimaterankforratings.ashx"; }
        }
    }

    public class StatsEstimateRankForRatingsResponse:XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_MAX_STATS_ESTIMATE_RATING_COUNT)]
        public uint m_uRankForRatingReplyCount = 0;

        [WireInfo(SizeParam="m_uRankForRatingReplyCount")]
        public uint[] m_arruiRankForRating = null;
    }

    #endregion

    #region Achievements Protocol (Xenon)

    /// <summary>
    /// Achievement
    /// </summary>
    /// <param name="AchievementId">Achievement ID</param>
    /// <param name="Achieved">Achieved datetime</param>
    /// <param name="Flags">Flags</param>
    /// <remarks>
    /// Data object for an achievement
    /// </remarks>
    public class Achievement : WireData
    {
        public uint  AchievementId = 0;
        public DateTime Achieved   = XOn.MinDateTime;
        public uint  Sequence      = 0;
        public int   Flags         = 0;
        public byte  Type          = 0;
        public int   Cred          = 0;

        public uint  ImageId       = 0;

        public byte TitleLen       = 0;
        public string Title        = "";

        public byte DescriptionLen = 0;
        public string Description  = "";

        public byte HowToLen       = 0;
        public string HowTo        = "";

        public byte NextIdsLen     = 0;
        public uint[] NextIds      = null;

        public byte ReplaceIdsLen  = 0;
        public uint[] ReplaceIds      = null;


        public Achievement()
        {
        }

        /// <summary>
        /// Achievement
        /// </summary>
        /// <param name="achievementId">Achievement ID</param>
        /// <param name="achieved">Achieved datetime</param>
        /// <param name="flags">Flags</param>
        /// <remarks>
        /// Achievement constructor
        /// </remarks>
        public Achievement(uint achievementId, DateTime achieved, int flags)
        {
            this.AchievementId = achievementId;
            this.Achieved      = achieved;
            this.Flags         = flags;
        }

        public static int SetPlatformTypeInFlags(int existingFlags, int platformType)
        {
            uint newFlags = (uint)existingFlags & ~(XOn.XACHIEVEMENT_DETAILS_PLATFORM_MASK);
            uint avatarFlag = (uint)MapPlatformTypeFlags(platformType);
            newFlags |= (uint)avatarFlag & XOn.XACHIEVEMENT_DETAILS_PLATFORM_MASK;
            return (int)newFlags;
        }
        // Function added to map the XPL_* platform flags to the XAVATAR_DETAILS_* flags
        // which was needed when we added Windows Mobile and WebGames Platforms that can now earn avatar awards
        public static int MapPlatformTypeFlags(int platformType)
        {
            return (int)ProfileDefs.XOnPlatformToXProfilePlatform((uint)platformType) << XOn.XACHIEVEMENT_DETAILS_PLATFORM_SHIFT;
        }

        public static int GetPlatformTypeFromFlags(int flags)
        {
            uint platformFlags = (uint)flags & XOn.XACHIEVEMENT_DETAILS_PLATFORM_MASK;
            uint platform = (uint)platformFlags >> XOn.XACHIEVEMENT_DETAILS_PLATFORM_SHIFT;
            return (int)ProfileDefs.XProfilePlatformToXOnPlatform(platform);
        }
    }

    /// <summary>
    /// AchievementWriteRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="Puid">User PUID</param>
    /// <param name="AchievementCount">Count of achievements</param>
    /// <param name="Achievements">Collection of achievements</param>
    /// <returns>AchievementWriteResponse</returns>
    /// <remarks>
    /// Request to write a set of achievements to the database for a specific user + title.
    /// </remarks>
    public class SyncAchievementsRequest : XRLObject2
    {
        public uint  TitleId = 0;
        public ulong UserId  = 0;
        public DateTime Version = XOn.MinDateTime;
        public ushort LocaleId = 0;
        public ushort StartingIndex = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_ACHIEVEMENTS)]
        public ushort AchievementCount = 0;

        [WireInfo(SizeParam="AchievementCount")]
        public Achievement[] Achievements = null;

        public override string Xrl
        {
            get { return "/xstats/syncachievements.ashx"; }
        }
    }

    /// <summary>
    /// AchievementWriteResponse
    /// </summary>
    /// <returns>TitleId</returns>
    /// <remarks>
    /// Response to a AchievementWriteRequest.
    /// </remarks>
    public class SyncAchievementsResponse : XRLObject2
    {
        public DateTime Version = XOn.MinDateTime;
        public ushort TotalAchievements = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_ACHIEVEMENTS)]
        public ushort  AchievementCount = 0;

        [WireInfo(SizeParam="AchievementCount")]
        public Achievement[] Achievements = null;
    }

    /// <summary>
    /// AchievementEnumRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="Puid">User PUID</param>
    /// <returns>AchievementEmumResponse</returns>
    /// <remarks>
    /// Request to read all achievements for a specific user
    /// </remarks>
    public class AchievementEnumRequest : XRLObject2
    {
        public uint  TitleId = 0;
        public ulong Puid    = 0;
        public ulong ForPuid = 0;
        public ushort LocaleId = 0;
        public ushort StartingIndex = 0;
        public ushort MaxAchievements = XOn.XONLINE_MAX_ACHIEVEMENTS;


        public override string Xrl
        {
            get { return "/xstats/xachievementenum.ashx"; }
        }
    }

    /// <summary>
    /// AchievementEnumResponse
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="Puid">User PUID</param>
    /// <param name="AchievementsCount">Count of achievements</param>
    /// <param name="Achievements">Collection of achievement descriptions</param>
    /// <remarks>
    /// Response to AchievementEnumRequest.
    /// </remarks>
    public class AchievementEnumResponse : XRLObject2
    {
        public ushort AchievementsCount = 0;

        [WireInfo(SizeParam="AchievementsCount")]
        public Achievement[] Achievements = null;
    }

    /// <summary>
    /// AchievementClearRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="Puid">User PUID</param>
    /// <returns>AchievementClearResponse</returns>
    /// <remarks>
    /// Request to clear all achievements for a specific user
    /// for the specified title id
    /// </remarks>
    public class AchievementClearRequest : XRLObject2
    {
        public uint  TitleId = 0;
        public ulong Puid    = 0;

        public override string Xrl
        {
            get { return "/xstats/xachievementclear.ashx"; }
        }
    }

    /// <summary>
    /// AchievementClearResponse
    /// </summary>
    /// <returns>TitleId</returns>
    /// <returns>Puid</returns>
    /// <remarks>
    /// Response to a AchievementWriteRequest.
    /// </remarks>
    public class AchievementClearResponse : XRLObject2
    {
        public uint  TitleId = 0;
        public ulong Puid    = 0;
    }

    #endregion

    #region Avatar Assets Protocol (Xenon)

    /// <summary>
    /// AvatarAsset
    /// </summary>
    /// <param name="AvatarAssetOrdinal">Avatar Asset Ordinal</param>
    /// <param name="Awarded">Awarded datetime</param>
    /// <param name="Flags">Flags</param>
    /// <remarks>
    /// Data object for an avatar asset
    /// </remarks>
    public class AvatarAsset : WireData
    {
        public uint AvatarAssetOrdinal = 0;
        public DateTime Awarded = XOn.MinDateTime;
        public uint Sequence = 0;
        public int Flags = 0;

        // guid assigned to asset by XLAST
        [WireInfo(ArraySize = 16)]
        public byte[] AvatarAssetId;

        public uint ImageId = 0;

        public byte TitleLen = 0;
        public string Title = "";

        public byte DescriptionLen = 0;
        public string Description = "";

        public byte HowToLen = 0;
        public string HowTo = "";

        public byte BodyTypeMask = 0;
        public uint BodyComponent = 0;
        public uint SubCategory = 0;

        public AvatarAsset()
        {
        }

        /// <summary>
        /// AvatarAsset
        /// </summary>
        /// <param name="avatarAssetOrdinal">Avatar Asset Ordinal</param>
        /// <param name="avatarAssetBodyTypeMask">Avatar Asset Body Type mask</param>
        /// <param name="awarded">Awarded datetime</param>
        /// <param name="flags">Flags</param>
        /// <remarks>
        /// AvatarAsset constructor
        /// </remarks>
        public AvatarAsset(uint avatarAssetOrdinal, byte avatarAssetBodyTypeMask, DateTime awarded, int flags)
        {
            this.AvatarAssetOrdinal = avatarAssetOrdinal;
            this.BodyTypeMask = avatarAssetBodyTypeMask;
            this.Awarded = awarded;
            this.Flags = flags;
        }

        public static int SetPlatformTypeInFlags(int existingFlags, int platformType)
        {
            uint newFlags = (uint)existingFlags & ~(XOn.XAVATAR_DETAILS_PLATFORM_MASK);
            uint avatarFlag = (uint)MapPlatformTypeFlags(platformType);
            newFlags |= (uint)avatarFlag & XOn.XAVATAR_DETAILS_PLATFORM_MASK;
            return (int)newFlags;
        }
        // Function added to map the XPL_* platform flags to the XAVATAR_DETAILS_* flags
        // which was needed when we added Windows Mobile and WebGames Platforms that can now earn avatar awards
        public static int MapPlatformTypeFlags(int platformType)
        {
            return (int)ProfileDefs.XOnPlatformToXProfilePlatform((uint)platformType) << XOn.XAVATAR_DETAILS_PLATFORM_SHIFT;
        }

        public static int GetPlatformTypeFromFlags(int flags)
        {
            uint platformFlags = (uint)flags & XOn.XAVATAR_DETAILS_PLATFORM_MASK;
            uint platform = (uint)platformFlags >> XOn.XAVATAR_DETAILS_PLATFORM_SHIFT;
            return (int)ProfileDefs.XProfilePlatformToXOnPlatform(platform);
        }
    }

    /// <summary>
    /// SyncAvatarAssetRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="Puid">User PUID</param>
    /// <param name="AvatarAssetCount">Count of avatar assets</param>
    /// <param name="AvatarAssets">Collection of avatar assets</param>
    /// <returns>SyncAvatarAssetResponse</returns>
    /// <remarks>
    /// Request to write a set of avatar assets to the database for a specific user + title.
    /// </remarks>
    public class SyncAvatarAssetRequest : XRLObject2
    {
        public uint TitleId = 0;
        public ulong UserId = 0;
        public DateTime Version = XOn.MinDateTime;
        public ushort LocaleId = 0;
        public ushort StartingIndex = 0;

        [WireInfo(Max = XOn.XONLINE_MAX_AVATAR_ASSETS)]
        public ushort AvatarAssetCount = 0;

        [WireInfo(SizeParam = "AvatarAssetCount")]
        public AvatarAsset[] AvatarAssets = null;

        public override string Xrl
        {
            get { return "/xstats/syncavatarassets.ashx"; }
        }
    }

    /// <summary>
    /// SyncAvatarAssetResponse
    /// </summary>
    /// <returns>TitleId</returns>
    /// <remarks>
    /// Response to a SyncAvatarAssetRequest.
    /// </remarks>
    public class SyncAvatarAssetResponse : XRLObject2
    {
        public DateTime Version = XOn.MinDateTime;
        public uint MoreAvatarAssetPending = 0;

        [WireInfo(Max = XOn.XONLINE_MAX_AVATAR_ASSETS)]
        public ushort AvatarAssetCount = 0;

        [WireInfo(SizeParam = "AvatarAssetCount")]
        public AvatarAsset[] AvatarAssets = null;
    }

    /// <summary>
    /// AvatarAssetEnumRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="Puid">User PUID</param>
    /// <returns>AvatarAssetEnumResponse</returns>
    /// <remarks>
    /// Request to read all avatar assets for a specific user
    /// </remarks>
    public class AvatarAssetEnumRequest : XRLObject2
    {
        public uint TitleId = 0;
        public ulong Puid = 0;
        public ulong ForPuid = 0;
        public ushort LocaleId = 0;
        public ushort StartingIndex = 0;
        public ushort MaxAssets = XOn.XONLINE_MAX_AVATAR_ASSETS;


        public override string Xrl
        {
            get { return "/xstats/xavatarassetenum.ashx"; }
        }
    }

    /// <summary>
    /// AvatarAssetEnumResponse
    /// </summary>
    /// <param name="AvatarAssetsCount">Count of avatar assets</param>
    /// <param name="AvatarAssets">Collection of avatar asset information</param>
    /// <remarks>
    /// Response to AvatarAssetEnumRequest.
    /// </remarks>
    public class AvatarAssetEnumResponse : XRLObject2
    {
        public ushort AvatarAssetsCount = 0;

        [WireInfo(SizeParam = "AvatarAssetsCount")]
        public AvatarAsset[] AvatarAssets = null;
    }

    /// <summary>
    /// ValidateAvatarManifestRequest
    /// </summary>
    /// <param name="UserId">User PUID</param>
    /// <param name="ValidationFlags">Types of validation requested by client. 0 means default.</param>
    /// <returns>ValidateAvatarManifestResponse</returns>
    /// <remarks>
    /// Request to read all avatar assets for a specific user
    /// </remarks>
    public class ValidateAvatarManifestRequest : XRLObject2
    {
        public ulong UserId = 0;

        // flags that can be set with ValidationFlags
        public const int XAVATAR_VALIDATE_AVATAR_AWARDS = 0x00000001;

        public uint ValidationFlags = 0;

        [WireInfo(Max = XOn.XONLINE_MAX_SETTING_VALUE_BYTES)]
        public ushort AvatarManifestLen = 0;

        [WireInfo(SizeParam = "AvatarManifestLen")]
        public byte[] AvatarManifest = null;

        public override string Xrl
        {
            get { return "/xstats/validateavatarmanifest.ashx"; }
        }
    }

    /// <summary>
    /// ValidateAvatarManifestResponse
    /// </summary>
    /// <param name="ValidationResult">Zero for failure, non-zero for success.</param>
    /// <remarks>
    /// Response to ValidateAvatarManifestRequest.
    /// </remarks>
    public class ValidateAvatarManifestResponse : XRLObject2
    {
        public byte ValidationResult = 0;
    }

    #endregion

    public class ProfileDefs
    {
        public const uint XPROFILE_PERMISSIONS                          = 0x10040000;
        public const uint XPROFILE_GAMER_TYPE                           = 0x10040001;
        public const uint XPROFILE_GAMER_YAXIS_INVERSION                = 0x10040002;
        public const uint XPROFILE_OPTION_CONTROLLER_VIBRATION          = 0x10040003;
        public const uint XPROFILE_TITLE_SPECIFIC1                      = 0x63E83FFF;
        public const uint XPROFILE_TITLE_SPECIFIC2                      = 0x63E83FFE;
        public const uint XPROFILE_TITLE_SPECIFIC3                      = 0x63E83FFD;
        public const uint XPROFILE_GAMERCARD_ZONE                       = 0x10040004;
        public const uint XPROFILE_GAMERCARD_REGION                     = 0x10040005;
        public const uint XPROFILE_GAMERCARD_CRED                       = 0x10040006;
        public const uint XPROFILE_GAMER_PRESENCE_USER_STATE            = 0x10040007;
        public const uint XPROFILE_GAMERCARD_HAS_VISION                 = 0x10040008;
        public const uint XPROFILE_GAMERCARD_REP                        = 0x5004000B;
        public const uint XPROFILE_OPTION_VOICE_MUTED                   = 0x1004000C;
        public const uint XPROFILE_OPTION_VOICE_THRU_SPEAKERS           = 0x1004000D;
        public const uint XPROFILE_OPTION_VOICE_VOLUME                  = 0x1004000E;
        public const uint XPROFILE_GAMERCARD_PICTURE_KEY                = 0x4064000F;
        public const uint XPROFILE_GAMERCARD_PERSONAL_PICTURE           = 0x40640010;
        public const uint XPROFILE_GAMERCARD_MOTTO                      = 0x402C0011;
        public const uint XPROFILE_GAMERCARD_TITLES_PLAYED              = 0x10040012;
        public const uint XPROFILE_GAMERCARD_ACHIEVEMENTS_EARNED        = 0x10040013;
        public const uint XPROFILE_GAMER_DIFFICULTY                     = 0x10040015;
        public const uint XPROFILE_GAMER_CONTROL_SENSITIVITY            = 0x10040018;
        public const uint XPROFILE_GAMER_PREFERRED_COLOR_FIRST          = 0x1004001d;
        public const uint XPROFILE_GAMER_PREFERRED_COLOR_SECOND         = 0x1004001e;
        public const uint XPROFILE_GAMER_ACTION_AUTO_AIM                = 0x10040022;
        public const uint XPROFILE_GAMER_ACTION_AUTO_CENTER             = 0x10040023;
        public const uint XPROFILE_GAMER_ACTION_MOVEMENT_CONTROL        = 0x10040024;
        public const uint XPROFILE_GAMER_RACE_TRANSMISSION              = 0x10040026;
        public const uint XPROFILE_GAMER_RACE_CAMERA_LOCATION           = 0x10040027;
        public const uint XPROFILE_GAMER_RACE_BRAKE_CONTROL             = 0x10040028;
        public const uint XPROFILE_GAMER_RACE_ACCELERATOR_CONTROL       = 0x10040029;
        public const uint XPROFILE_GAMERCARD_TITLE_CRED_EARNED          = 0x10040038;
        public const uint XPROFILE_GAMERCARD_TITLE_ACHIEVEMENTS_EARNED  = 0x10040039;
        public const uint XPROFILE_GAMER_TIER                           = 0x1004003A;
        public const uint XPROFILE_MESSENGER_SIGNUP_STATE               = 0x1004003B;
        public const uint XPROFILE_MESSENGER_AUTO_SIGNIN                = 0x1004003C;
        public const uint XPROFILE_SAVE_WINDOWS_LIVE_PASSWORD           = 0x1004003D;
        public const uint XPROFILE_FRIENDSAPP_SHOW_BUDDIES              = 0x1004003E;
        public const uint XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS         = 0x1004003F;
        public const uint XPROFILE_GAMERCARD_USER_NAME                  = 0x41040040;
        public const uint XPROFILE_GAMERCARD_USER_LOCATION              = 0x40520041;
        public const uint XPROFILE_GAMERCARD_USER_URL                   = 0x41900042;
        public const uint XPROFILE_GAMERCARD_USER_BIO                   = 0x43E80043;
        public const uint XPROFILE_GAMERCARD_AVATAR_INFO_1              = 0x63E80044;
        public const uint XPROFILE_GAMERCARD_AVATAR_INFO_2              = 0x63E80045;
        public const uint XPROFILE_GAMERCARD_PARTY_INFO                 = 0x61000046;
        public const uint XPROFILE_TENURE_LEVEL                         = 0x10040047;
        public const uint XPROFILE_TENURE_MILESTONE                     = 0x10040048;
        public const uint XPROFILE_TENURE_NEXT_MILESTONE_DATE           = 0x70080049; // client-only setting 
        public const uint XPROFILE_SUBSCRIPTION_TYPE_LENGTH_IN_MONTHS   = 0x1004004B; // client-only setting
        public const uint XPROFILE_SUBSCRIPTION_PAYMENT_TYPE            = 0x1004004C; // client-only setting
        public const uint XPROFILE_VIDEO_METADATA                       = 0x6020004A;
        public const uint XPROFILE_JUMP_IN_LIST                         = 0x63E80051;

        // Web-only settings
        public const uint WEB_EMAIL_FORMAT                              = 0x10042000;
        public const uint WEB_FLAGS                                     = 0x10042001;
        public const uint WEB_SPAM                                      = 0x10042002;
        public const uint WEB_FAVORITE_GENRE                            = 0x10042003;
        public const uint WEB_FAVORITE_GAME                             = 0x10042004;
        public const uint WEB_FAVORITE_GAME1                            = 0x10042005;
        public const uint WEB_FAVORITE_GAME2                            = 0x10042006;
        public const uint WEB_FAVORITE_GAME3                            = 0x10042007;
        public const uint WEB_FAVORITE_GAME4                            = 0x10042008;
        public const uint WEB_FAVORITE_GAME5                            = 0x10042009;
        public const uint WEB_PLATFORMS_OWNED                           = 0x1004200a;
        public const uint WEB_CONNECTION_SPEED                          = 0x1004200b;
        public const uint WEB_FLASH                                     = 0x1004200c;
        public const uint WEB_VIDEO_PREFERENCE                          = 0x1004200d;

        // Argo/Crux settings
        public const uint XPROFILE_CRUX_MEDIA_PICTURE                   = 0x406403E8;
        public const uint XPROFILE_CRUX_MEDIA_STYLE1                    = 0x100403EA;
        public const uint XPROFILE_CRUX_MEDIA_STYLE2                    = 0x100403EB;
        public const uint XPROFILE_CRUX_MEDIA_STYLE3                    = 0x100403EC;
        public const uint XPROFILE_CRUX_TOP_ALBUM1                      = 0x100403ED;
        public const uint XPROFILE_CRUX_TOP_ALBUM2                      = 0x100403EE;
        public const uint XPROFILE_CRUX_TOP_ALBUM3                      = 0x100403EF;
        public const uint XPROFILE_CRUX_TOP_ALBUM4                      = 0x100403F0;
        public const uint XPROFILE_CRUX_TOP_ALBUM5                      = 0x100403F1;
        public const uint XPROFILE_CRUX_OFFLINE_ID                      = 0x603403F2;
        public const uint XPROFILE_CRUX_BKGD_IMAGE                      = 0x100403F3;
        public const uint XPROFILE_CRUX_LAST_CHANGE_TIME                = 0x700803F4;
        public const uint XPROFILE_CRUX_TOP_MUSIC                       = 0x60A803F5;
        public const uint XPROFILE_CRUX_MEDIA_MOTTO                     = 0x410003F6;
        public const uint XPROFILE_CRUX_TOP_MEDIAID1                    = 0x601003F7;
        public const uint XPROFILE_CRUX_TOP_MEDIAID2                    = 0x601003F8;
        public const uint XPROFILE_CRUX_TOP_MEDIAID3                    = 0x601003F9;
        public const uint XPROFILE_CRUX_BIO                             = 0x43E803FA;
        public const uint XPROFILE_CRUX_BG_SMALL_PUBLIC                 = 0x406403FD;
        public const uint XPROFILE_CRUX_BG_LARGE_PUBLIC                 = 0x406403FE;

        // Bit defines for XPROFILE_GAMER_TYPE
        public const uint XPROFILE_GAMER_TYPE_TEAM                      = 0x00000001;
        public const uint XPROFILE_GAMER_TYPE_CHEATER                   = 0x00000002;
        public const uint XPROFILE_GAMER_TYPE_NXE_TEAM                  = 0x00000004;

        // Service Types
        // (service type flag) = 0x1 << (service type id)
        // service type ids are found in t_service_types
        // 1 = Xbox Live
        // 2 = Zune
        public const uint XPROFILE_SERVICE_TYPE_FLAG_XBOX = 0x2;
        public const uint XPROFILE_SERVICE_TYPE_FLAG_ZUNE = 0x4;


        // Platform conversion stuff
        public const uint XPROFILE_PLATFORM_TYPE_360 = 1;
        public const uint XPROFILE_PLATFORM_TYPE_PC = 2;
        public const uint XPROFILE_PLATFORM_TYPE_MOBILE = 3;
        public const uint XPROFILE_PLATFORM_TYPE_WEB_GAMES = 4;

        public static uint XOnPlatformToXProfilePlatform(uint xop)
        {
            switch (xop)
            {
                case XOn.XPLT_XBOX360:
                    return XPROFILE_PLATFORM_TYPE_360;
                case XOn.XPLT_PC:
                    return XPROFILE_PLATFORM_TYPE_PC;
                case XOn.XPLT_MOBILE:
                    return XPROFILE_PLATFORM_TYPE_MOBILE;
                case XOn.XPLT_WEB_GAMES:
                    return XPROFILE_PLATFORM_TYPE_WEB_GAMES;
                default:
                    return 0;
            }
        }

        public static uint XProfilePlatformToXOnPlatform(uint xpp)
        {
            switch (xpp)
            {
                case XPROFILE_PLATFORM_TYPE_360:
                    return XOn.XPLT_XBOX360;
                case XPROFILE_PLATFORM_TYPE_PC:
                    return XOn.XPLT_PC;
                case XPROFILE_PLATFORM_TYPE_MOBILE:
                    return XOn.XPLT_MOBILE;
                case XPROFILE_PLATFORM_TYPE_WEB_GAMES:
                    return XOn.XPLT_WEB_GAMES;
                default:
                    return 0;
            }
        }
        

        // cache stuff
        public static byte[] BuildCacheKey(uint settingId, uint titleId, ulong userId)
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter br = new BinaryWriter(ms);
            br.Write(ProfileDefs.CachePrefix);
            br.Write(titleId);
            br.Write(settingId);
            br.Write(userId);
            return ms.ToArray();
        }
        
        public static byte[] CachePrefix
        {
            get
            {
                return _CachePrefix;
            }
        }
        public static byte[] CacheNoValue
        {
            get 
            {
                return _CacheNoValue;
            }
        }

        private static byte[] _CachePrefix;
        private static byte[] _CacheNoValue;

        static ProfileDefs()
        {
            _CachePrefix = new byte[] {(byte)'P', (byte)'r', (byte)'o', (byte)'f', (byte)'i', (byte)'l', (byte)'e'};
            _CacheNoValue = new byte[] {(byte)'N', (byte)'o', (byte)' ', (byte)'V', (byte)'a', (byte)'l', (byte)'u', (byte)'e'};
        }
    }

    #region Gamer Profile Protocol (Xenon)

    /// <summary>
    /// UserSetting
    /// </summary>
    /// <remarks>
    /// Describes a single setting.  Used in both setting and getting values.
    /// </remarks>
    public class UserSetting : WireData
    {
        public UserSetting() {}
        public UserSetting(ulong userId, uint settingId)
        {
            UserId = userId;
            SettingId = settingId;
        }
        public UserSetting(ulong userId, uint source, uint settingId, byte[] value)
        {
            UserId = userId;
            SettingId = settingId;
            Source = source;
            Value = value;
        }

        public uint Source = XOn.XSOURCE_NO_VALUE;
        public ulong UserId = 0;
        public uint SettingId = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_VALUE_BYTES)]
        public ushort ValueLen = 0;

        [WireInfo(SizeParam="ValueLen")]
        public byte[] Value = null;
    }

    /// <summary>
    /// ReadSettingsRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="UserId">User ID</param>
    /// <param name="ForUserIdsLen">Count of user id's</param>
    /// <param name="ForUserIds">User ids to read</param>
    /// <param name="SettingsIdsLen">Count of settings</param>
    /// <param name="SettingsIds">Setting ids to read</param>
    /// <remarks>
    /// Retrieves a list of settings for a list of users
    /// </remarks>
    public class ReadSettingsRequest : XRLObject2
    {
        public uint TitleId;
        public ulong UserId;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_USERS)]
        public ushort ForUserIdsLen;
        [WireInfo(SizeParam="ForUserIdsLen")]
        public ulong[] ForUserIds;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_COUNT)]
        public ushort SettingIdsLen;
        [WireInfo(SizeParam="SettingIdsLen")]
        public uint[] SettingIds;

        public override string Xrl
        {
            get { return "/xstats/readsettings.ashx"; }
        }
     }

    /// <summary>
    /// ReadSettingsResponse
    /// </summary>
    /// <param name="SettingsLen">Count of settings</param>
    /// <param name="Settings">User settings collection</param>
    /// <remarks>
    /// Returned in response to ReadSettingsRequest
    /// </remarks>
    public class ReadSettingsResponse : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_COUNT * XOn.XONLINE_MAX_SETTING_USERS)]
        public ushort SettingsLen = 0;

        [WireInfo(SizeParam="SettingsLen")]
        public UserSetting[] Settings = null;
    }





    public class UserTitle : WireData
    {
        public UserTitle() {}
        public UserTitle(uint titleId, DateTime lastPlayed, uint sequence, uint creds, ushort achievements)
        {
            TitleId = titleId;
            LastPlayed = lastPlayed;
            Sequence = sequence;
            NumCreds = creds;
            NumAchievements = achievements;
        }


        public uint TitleId = 0;

        [WireInfo(Max=XOn.MAX_TITLE_NAME_LEN)]
        public ushort TitleNameLen = 0;

        [WireInfo(SizeParam="TitleNameLen")]
        public string TitleName = "";

        public DateTime LastPlayed = DateTime.MinValue;
        public uint NumCreds = 0;
        public ushort NumAchievements = 0;
        public ushort TotalAchievements = 0;
        public uint TotalCred = 0;
        public uint Sequence = 0;
        public byte HasExtendedData = 0;
        public byte TitleType = 0;
        public ushort PlatformFlags = 0;

        public void SetPlatformFlag(uint xplatformid, bool value)
        {
            uint xprofileid = ProfileDefs.XOnPlatformToXProfilePlatform(xplatformid);
            ushort mask = (ushort)(1 << (int)xprofileid);
            PlatformFlags &= (ushort)~mask;
            PlatformFlags |= (ushort)(value ? mask : 0);
        }

        public bool HasPlatformFlag(uint xplatformid)
        {
            uint xprofileid = ProfileDefs.XOnPlatformToXProfilePlatform(xplatformid);
            ushort mask = (ushort)(1 << (int)xprofileid);
            return (PlatformFlags & mask) != 0;
        }

        public bool ShouldAppearInUserHistory()
        {
            if (TotalAchievements > 0) return true;  // title has achievements, so it must be public.

            if (HasExtendedData == 0) return true;  // no extended data to base on.  can't do any further filtering.

            // for anything that's made it this far, filter out title type (system, demo, app).
            if (TitleType == XOn.TITLE_TYPE_SYSTEM) return false;
            if (TitleType == XOn.TITLE_TYPE_DEMO) return false;
            if (TitleType == XOn.TITLE_TYPE_APPLICATION) return false;

            // else
            return true;
        }
    }

    public class SyncTitlesRequest : XRLObject2
    {
        public SyncTitlesRequest() {}
        public SyncTitlesRequest(ulong userId, DateTime version)
        {
            UserId = userId;
            Version = version;
        }

        public ulong UserId = 0;
        public ushort LocaleId = 0;
        public ushort StartingIndex = 0;

        public DateTime Version = DateTime.MinValue;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_COUNT)]
        public ushort TitlesLen = 0;

        [WireInfo(SizeParam="TitlesLen")]
        public UserTitle[] Titles = null;



        public override string Xrl
        {
            get { return "/xstats/synctitles.ashx"; }
        }
    }


    public class SyncTitlesResponse : XRLObject2
    {
        public DateTime Version = DateTime.MinValue;
        public ushort TotalTitles = 0;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_COUNT)]
        public ushort TitlesLen = 0;

        [WireInfo(SizeParam="TitlesLen")]
        public UserTitle[] Titles = null;
    }




    public class EnumTitlesRequest : XRLObject2
    {
        public EnumTitlesRequest() {}
        public EnumTitlesRequest(ulong userId, ulong forUserId, ushort startingIndex, ushort maxTitles)
        {
            UserId = userId;
            ForUserId = forUserId;
            StartingIndex = startingIndex;
            MaxTitles = maxTitles;
        }

        public ulong UserId;
        public ulong ForUserId;
        public ushort LocaleId;
        public ushort StartingIndex;
        public ushort MaxTitles;

        public override string Xrl
        {
            get { return "/xstats/enumtitles.ashx"; }
        }


    }

    public class EnumTitlesResponse : XRLObject2
    {
        public ushort TitlesLen;
        [WireInfo(SizeParam="TitlesLen")]
        public UserTitle[] Titles;
    }



    public class TitleClearRequest : XRLObject2
    {
        public ulong UserId;
        public uint TitleId;

        public override string Xrl
        {
            get { return "/xstats/cleartitle.ashx"; }
        }

    }






    /// <summary>
    /// SyncSettingsRequest
    /// </summary>
    /// <param name="TitleId">Title ID</param>
    /// <param name="UserId">User ID</param>
    /// <param name="Version">Version</param>
    /// <param name="SettingsLen">Count of settings</param>
    /// <param name="Settings">User settings collection</param>
    /// <remarks>
    /// Updates one or more of a single user's profile settings
    /// </remarks>
    public class SyncSettingsRequest : XRLObject2
    {
        public uint TitleId;
        public ulong UserId;
        public DateTime Version;
        public ushort StartinIndex;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_COUNT)]
        public ushort SettingsLen;

        [WireInfo(SizeParam="SettingsLen")]
        public UserSetting[] Settings;

        public override string Xrl
        {
            get { return "/xstats/syncsettings.ashx"; }
        }
    }

    /// <summary>
    /// SyncSettingsResponse
    /// </summary>
    /// <param name="Version">Version</param>
    /// <param name="SettingsLen">Count of settings</param>
    /// <param name="Settings">User settings collection</param>
    /// <remarks>
    /// Returned in response to SyncSettingsRequest
    /// </remarks>
    public class SyncSettingsResponse : XRLObject2
    {
        public DateTime Version;
        public ushort TotalSettings;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_RESPONSE_COUNT)]
        public ushort SettingsLen = 0;

        [WireInfo(SizeParam="SettingsLen")]
        public UserSetting[] Settings = null;
    }




    public class SyncAllRequest : XRLObject2
    {
        public SyncAllRequest() {}
        public SyncAllRequest(ulong userId, uint titleId, ushort localeId, byte[] guid)
        {
            UserId = userId;
            TitleId = titleId;
            LocaleId = localeId;
            Guid = guid;
        }


        public uint TitleId;
        public ulong UserId;
        public ushort LocaleId;

        [WireInfo(ArraySize=16)]
        public byte[] Guid;


        // settings
        //
        public DateTime SettingsVersion;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_COUNT)]
        public ushort SettingsLen;

        [WireInfo(SizeParam="SettingsLen")]
        public UserSetting[] Settings;

        // titles
        //
        public DateTime TitlesVersion;

        [WireInfo(Max=XOn.XONLINE_MAX_SETTING_COUNT)]
        public ushort TitlesLen = 0;

        [WireInfo(SizeParam="TitlesLen")]
        public UserTitle[] Titles = null;


        // achievements
        //
        public DateTime AchievementsVersion;

        [WireInfo(Max=XOn.XONLINE_MAX_ACHIEVEMENTS)]
        public ushort AchievementsCount = 0;

        [WireInfo(SizeParam="AchievementsCount")]
        public Achievement[] Achievements = null;


        public override string Xrl
        {
            get { return "/xstats/syncall.ashx"; }
        }
    }

    /// <summary>
    /// SyncSettingsResponse
    /// </summary>
    /// <param name="Version">Version</param>
    /// <param name="SettingsLen">Count of settings</param>
    /// <param name="Settings">User settings collection</param>
    /// <remarks>
    /// Returned in response to SyncSettingsRequest
    /// </remarks>
    public class SyncAllResponse : XRLObject2
    {
        public SyncSettingsResponse Settings = new SyncSettingsResponse();
        public SyncTitlesResponse Titles = new SyncTitlesResponse();
        public SyncAchievementsResponse Achievements = new SyncAchievementsResponse();
    }


    public class ContextString : WireData
    {
        public uint ContextId;
        public uint NameLen;
        public string Name;
    }

    public class ContextEnumRequest : XRLObject2
    {
        public uint TitleId;
        public uint ContextId;
        public ushort LocaleId;
        public uint StartingIndex;
        public uint MaxContexts;

        public override string Xrl
        {
            get { return "/xstats/contextenum.ashx"; }
        }

    }

    public class ContextEnumResponse : XRLObject2
    {
        public uint TotalContexts;

        public uint ContextsLen;
        public ContextString[] Contexts;
    }

    #endregion

    #region Console Audit List(Xenon)

    public class ConsoleIdData : WireData
    {
        [WireInfo(ArraySize = 5)]
        public byte[] ConsoleId = null;

        public static ulong GetDecimalValue(byte[] consoleIdBytes)
        {
            if (consoleIdBytes == null)
            {
                return 0;
            }

            ulong result = 0;
            for (int i = consoleIdBytes.Length - 1; i >= 0; --i)
            {
                result = (result << 8) + consoleIdBytes[i];
            }
            return result;
        }

        public ConsoleIdData()
        {
        }

        public ConsoleIdData(byte[] ConsoleId)
        {
            this.ConsoleId = ConsoleId;
        }
    }

    /// <summary>
    /// UploadConsoleListRequest
    /// </summary>
    /// <param name="UploadingConsole">Console Id for console doing the upload</param>
    /// <param name="SigningConsole">Console Id of console that signed the PEC</param>
    /// <param name="ConsoleCount">Count of consoles</param>
    /// <param name="ConsoleList">Collection of console ids</param>
    /// <returns>nothing</returns>
    /// <remarks>
    /// Upload a list of consoles that have modified the PEC on the console
    /// </remarks>
    public class UploadConsoleListRequest : XRLObject2
    {
        public ulong UserId = 0;

        public ConsoleIdData UploadingConsoleId = new ConsoleIdData();
        public ConsoleIdData SigningConsoleId = new ConsoleIdData();

        [WireInfo(Max = XOn.XONLINE_MAX_CONSOLE_AUDIT_LIST)]
        public byte ConsoleCount = 0;

        [WireInfo(SizeParam = "ConsoleCount")]
        public ConsoleIdData[] ConsoleIdList = null;

        public override string Xrl
        {
            get { return "/xstats/uploadconsoleauditlist.ashx"; }
        }
    }

    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\VortexProt.cs ===
// VortexProt.cs
//
// Copyright (c) 2010 Microsoft Corporation. All Rights Reserved.
// Xbox Live
// Author: kgoodier 02/2010
//
// Definitions (and parsing code) for Vortex's binary protocol. This is a pretty compact 
// protocol, perhaps it will get used outside of the Vortex and distributed monitoring 
// world.
//
// This is not WireData, by the way. It's self-describing and doesn't, currently, have a 
// manifest or attributed classes describing all the various messages. 
//
// See http://xblwiki/default.aspx/XboxLive/VortexProtocol.html for spec.
//
   
using System;
using System.IO;
using System.Collections.Generic;
using System.Text;
using System.Net;

using xonline.common.service;
using xonline.common.utilities2;

namespace xonline.common.protocol 
{

    // ----------------------------------------------------------------------------------
    // VortexBinaryReader
    //
    // Extends the basic BinaryReader, which only provides a signed 32-bit version of 
    // Read7BitEncodedXXX.  We need an unsigned 64-bit version.
    // ----------------------------------------------------------------------------------
    public class VortexBinaryReader : BinaryReader
    {
        public VortexBinaryReader(Stream inStream)
            : base(inStream)
        {
        }

        public ulong Read7BitEncodedUInt64()
        {
            byte b;
            ulong num = 0;
            int dataBits = 0;
            do
            {
                if (dataBits > 64)
                {
                    throw new FormatException("Invalid 7-bit encoding format: too many bits");
                }
                b = this.ReadByte();
                num |= (ulong)(b & 0x7f) << dataBits;
                dataBits += 7;
            }
            while ((b & 0x80) != 0);
            return num;
        }

        public long Read7BitEncodedInt64()
        {
            ulong num = Read7BitEncodedUInt64();
            return unchecked((long)FromZigZag(num));
        }

        public ulong FromZigZag(ulong v)
        {
            // Must right-shift with a signed left-hand-side, to ensure an arithmetic 
            // shift. Basically, we want all 0's if LSB is 0 or all 1's if LSB is 1. I 
            // can't find anything that left-shifts and extends with 1's instead of 0's.  
            // 
            // Note the cast to a long is the magic here, a right-shift of a signed number 
            // is an arithmetic shift that will leave 1s behind.
            ulong signbitmask = (ulong)((long)(v << 63) >> 63);

            // Must right-shift with an unsigned left-hand-side, to ensure a logical 
            // shift. We don't want to extend the sign bit here.
            return (v >> 1) ^ signbitmask;
        }

        public byte[] ReadBlob()
        {
            ulong count = Read7BitEncodedUInt64();
            return ReadBytes((int)count);
        }

        public object ReadVxField(out uint fieldType, out uint fieldId)
        {
            ReadVxFieldTypeId(out fieldType, out fieldId);
            return ReadVxFieldValue(fieldType);
        }

        // @@@ ReadString?

        public void ReadVxFieldTypeId(out uint fieldType, out uint fieldId)
        {
            ulong fieldTypeId = Read7BitEncodedUInt64();
            fieldType = (uint)(fieldTypeId & VxProtocol.c_FieldTypeMask);
            fieldId = (uint)(fieldTypeId >> VxProtocol.c_FieldTypeShift);
        }

        public object ReadVxFieldValue(uint fieldType)
        {
            // Read field-value
            switch (fieldType)
            {
            case (uint)VxProtocol.VxFieldType.Terminator:
                return null;

            case (uint)VxProtocol.VxFieldType.VarInt:
                return Read7BitEncodedUInt64();

            case (uint)VxProtocol.VxFieldType.Blob:
                return ReadBlob();

            case (uint)VxProtocol.VxFieldType.Single:
                return ReadSingle();

            case (uint)VxProtocol.VxFieldType.Double:
                return ReadDouble();

            case (uint)VxProtocol.VxFieldType.String:
                return UTF8Encoding.UTF8.GetString(ReadBlob());

            case (uint)VxProtocol.VxFieldType.SVarInt:
                return Read7BitEncodedInt64();

            case (uint)VxProtocol.VxFieldType.Special:
                {
                    uint specialFieldType;
                    uint specialFieldId;
                    SpecialField specialField = new SpecialField();

                    ReadVxFieldTypeId(out specialFieldType, out specialFieldId);
                    specialField.Value = ReadVxFieldValue(specialFieldType);
                    specialField.Id = specialFieldId;
                    return specialField;
                }

            default:
                throw new Exception("Unknown field type " + fieldType); // @@@
            }
        }

    }

    // ----------------------------------------------------------------------------------
    // VortexBinaryWriter
    //
    // Extends the basic BinaryWriter, which only provides a signed 32-bit version of 
    // Write7BitEncodedXXX.  We need an unsigned 64-bit version.
    // ----------------------------------------------------------------------------------
    public class VortexBinaryWriter : BinaryWriter
    {
        public VortexBinaryWriter(Stream inStream)
            : base(inStream)
        {
        }

        public void Write7BitEncodedUInt64(ulong v)
        {
            while (v >= 0x80)
            {
                Write((byte)(v | 0x80));
                v = v >> 7;
            }
            Write((byte)v);
        }

        public void Write7BitEncodedInt64(long v)
        {
            ulong num = ToZigZag(unchecked((ulong)v));
            Write7BitEncodedUInt64(num);
        }

        private ulong ToZigZag(ulong v)
        {
            // Must right-shift with a signed left-hand-side, to ensure an arithmetic 
            // shift. Basically, we want all 0's if MSB is 0 or all 1's if MSB is 1. 
            ulong signbitmask = (ulong)((long)v >> 63);
            return (v << 1) ^ signbitmask;
        }

        private void WriteVxFieldTypeId(uint fieldType, uint fieldId)
        {
            // 29 bits is max
            if (fieldId > 0x1FFFFFFF)
            {
                throw new ArgumentOutOfRangeException("Maximum value for field id is 29 bits, or 536870911. " + fieldId + " is out of range.", "fieldId");
            }
            ulong v = ((ulong)fieldId << VxProtocol.c_FieldTypeShift) | (ulong)(fieldType & VxProtocol.c_FieldTypeMask);
            Write7BitEncodedUInt64(v);
        }

        public void WriteBlob(byte[] blob)
        {
            Write7BitEncodedUInt64((ulong)blob.Length);
            Write(blob);
        }

        // Helpers

        public void WriteVxField(uint fieldId, ulong v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.VarInt, fieldId);
            Write7BitEncodedUInt64(v);
        }

        public void WriteVxField(uint fieldId, long v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.SVarInt, fieldId);
            Write7BitEncodedInt64((long)v);
        }

        public void WriteVxField(uint fieldId, uint v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.VarInt, fieldId);
            Write7BitEncodedUInt64((ulong)v);
        }

        public void WriteVxField(uint fieldId, int v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.SVarInt, fieldId);
            Write7BitEncodedInt64((long)v);
        }

        public void WriteVxField(uint fieldId, ushort v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.VarInt, fieldId);
            Write7BitEncodedUInt64((ulong)v);
        }

        public void WriteVxField(uint fieldId, short v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.SVarInt, fieldId);
            Write7BitEncodedInt64((long)v);
        }

        public void WriteVxField(uint fieldId, byte v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.VarInt, fieldId);
            Write7BitEncodedUInt64((ulong)v);
        }

        public void WriteVxField(uint fieldId, sbyte v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.SVarInt, fieldId);
            Write7BitEncodedInt64((long)v);
        }

        public void WriteVxField(uint fieldId, byte[] v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.Blob, fieldId);
            WriteBlob(v);
        }

        public void WriteVxField(uint fieldId, float v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.Single, fieldId);
            Write(v);
        }

        public void WriteVxField(uint fieldId, double v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.Double, fieldId);
            Write(v);
        }

        public void WriteVxField(uint fieldId, string v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.String, fieldId);
            WriteBlob(UTF8Encoding.UTF8.GetBytes(v));
        }

        public void WriteVxField(uint fieldId, SpecialField sf)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.Special, fieldId);
            WriteVxField(sf.Id, sf.Value);
        }

        public void WriteVxField(uint fieldId, Guid v)
        {
            WriteVxFieldTypeId((int)VxProtocol.VxFieldType.Blob, fieldId);
            WriteBlob(v.ToByteArray());
        }

        public void WriteVxField(uint fieldId, DateTime dt)
        {
            WriteVxField(fieldId, (ulong)dt.ToFileTimeUtc());
        }

        public void WriteVxField(uint fieldId, object o)
        {
            if (o == null)
                WriteVxFieldTypeId((int)VxProtocol.VxFieldType.Terminator, fieldId);
            else if (o is byte)
                WriteVxField(fieldId, (byte)o);
            else if (o is sbyte)
                WriteVxField(fieldId, (sbyte)o);
            else if (o is short)
                WriteVxField(fieldId, (short)o);
            else if (o is ushort)
                WriteVxField(fieldId, (ushort)o);
            else if (o is int)
                WriteVxField(fieldId, (int)o);
            else if (o is uint)
                WriteVxField(fieldId, (uint)o);
            else if (o is long)
                WriteVxField(fieldId, (long)o);
            else if (o is ulong)
                WriteVxField(fieldId, (ulong)o);
            else if (o is float)
                WriteVxField(fieldId, (float)o);
            else if (o is double)
                WriteVxField(fieldId, (double)o);
            else if (o is string)
                WriteVxField(fieldId, (string)o);
            else if (o is byte[])
                WriteVxField(fieldId, (byte[])o);
            else if (o is SpecialField)
                WriteVxField(fieldId, (SpecialField)o);
            else if (o is Blob)
                WriteVxField(fieldId, (byte[])o);
            else if (o is Guid)
                WriteVxField(fieldId, (Guid)o);
            else if (o is DateTime)
                WriteVxField(fieldId, (DateTime)o);
            else if (o is char)
                WriteVxField(fieldId, new string(new char[] { (char)o }));
            else if (o is char[])
                WriteVxField(fieldId, new string((char[])o));
            else if (o is IPAddress)
                WriteVxField(fieldId, (byte[])((IPAddress)o).GetAddressBytes());
            else if (o is Floken)
                WriteVxField(fieldId, (ulong)((Floken)o).FlowToken);
            else
                throw new ArgumentException("Unknown field type " + o.GetType().ToString() + ": " + o.ToString());

        }

    }


    // ----------------------------------------------------------------------------------
    // VxEvent
    //
    // This is a generic representation of any binary message sent with the 
    // VortexProtocol. Since it is NOT a well-defined message type, it can be used to 
    // represent any incoming message, known or unknown.
    //
    // This class is best used to provide random-access (by ordinal) to the field
    // values. If you need more of wiredata scenario, where you already know the 
    // exact format of the message/event, then you should write some code to handle
    // that explicitly. It will be faster.
    //
    // ----------------------------------------------------------------------------------
    public class VxEvent
    {
        public const char c_ProducerEventSeparator = '@';
        public const uint c_MaxFieldOrdinal = 256;

        public Blob ProducerId
        {
            get { return _ProducerId; }
        }

        public uint EventId 
        {
            get { return _EventId; }
        }

        public DateTime Timestamp
        {
            get { return _Timestamp; }
        }

        public string LogStringId 
        {
            get 
            { 
                if (_LogStringId == null)
                {
                    // Return "ProducerId@EventId" in lieue of a pretty LogStringId
                    _LogStringId = _ProducerId.ToString() + c_ProducerEventSeparator + _EventId.ToString();
                }
                return _LogStringId;
            }
            set 
            { 
                _LogStringId = value; 
            }
        }

        public VortexFieldCollection EventFields
        {
            get { return _FieldCollection; }
        }

        public VxEvent(VortexBinaryReader inStream)
            : this(inStream, Blob.Empty, 0)
        {
        }

        public VxEvent(VortexBinaryReader inStream, Blob lastProducerId, long timestampBase)
        {
            Blob producerId = inStream.ReadBlob();
            _EventId = (uint)inStream.Read7BitEncodedUInt64();
            long timestampDelta = inStream.Read7BitEncodedInt64();
            _Timestamp = DateTime.FromFileTimeUtc(timestampBase + timestampDelta);
            _LogStringId = null;  // requires a manifest

            // Encoded run of producer ids, use last seen one if this one isn't present
            if (producerId.Length == 0)
            {
                _ProducerId = lastProducerId;
            }
            else
            {
                _ProducerId = producerId;
            }

            // Read event fields
            _FieldCollection = new VortexFieldCollection();
            while (true)
            {
                // Read field-type-id
                uint fieldType;
                uint fieldId;
                object val;

                val = inStream.ReadVxField(out fieldType, out fieldId);
                if (val == null)
                {
                    // We're done. Get out of here.
                    return;
                }
                _FieldCollection.AddField(fieldType, fieldId, val);
            }
        }

        public VxEvent(Blob producerId, uint eventId, DateTime timestamp)
        {
            _ProducerId = producerId;
            _EventId = eventId;
            _Timestamp = timestamp;
            _LogStringId = null;  // requires a manifest
            _FieldCollection = new VortexFieldCollection();
        }

        public VxEvent Clone()
        {
            VxEvent result = new VxEvent(_ProducerId, _EventId, _Timestamp);

            result._LogStringId = _LogStringId;
            result._FieldCollection = _FieldCollection.Clone();

            return result;
        }

        public void WriteStream(VortexBinaryWriter bw)
        {
            WriteStream(bw, Blob.Empty, 0);
        }

        public void WriteStream(VortexBinaryWriter bw, Blob lastProducerId, long timestampBase)
        {
            long timestampDiff = Timestamp.ToFileTimeUtc() - timestampBase;

            // Event headers
            if (lastProducerId == ProducerId)
            {
                // Encode a run.
                bw.Write((byte)0);
            }
            else
            {
                bw.WriteBlob(ProducerId);
            }
            bw.Write7BitEncodedUInt64(EventId);
            bw.Write7BitEncodedInt64(timestampDiff);
            
            // Fields
            EventFields.WriteStream(bw);

            // Terminator
            bw.Write((byte)0);
        }

        public override string ToString()
        {
            return ToString(true);
        }

        public string ToString(bool fIncludeTimestamp)
        {
            // [ClientTimestamp]|LogStringId|EventFields...

            StringBuilder sb = new StringBuilder(500);
            if (fIncludeTimestamp)
            {
                sb.Append(XDateTime.ToString(_Timestamp));
                sb.Append("|");
            }
            sb.Append(LogStringId);
            string fieldsStr = EventFields.ToString();
            if (!String.IsNullOrEmpty(fieldsStr))
            {
                sb.Append("|");
                sb.Append(fieldsStr);
            }
            return sb.ToString();
        }

        private Blob _ProducerId;
        private uint _EventId;
        private DateTime _Timestamp;
        private string _LogStringId;
        private VortexFieldCollection _FieldCollection;


        // ------------------------------------------------------------------------------
        // class VortexFieldCollection
        //
        // This represents a single-namespace's worth of fields. They are stored in a 
        // generic object form, but will always be a ulong, byte[], float, or double.  
        //
        // It is random-access by ordinal field id.
        // ------------------------------------------------------------------------------
        public class VortexFieldCollection
        {
            private Dictionary<uint, object> _fieldValues;
            private HashSet<uint> _specialFieldOrdinals;
            private uint _maxFieldOrdinal = 0;

            public int Count
            {
                get
                {
                    return _fieldValues.Count;
                }
            }

            public uint MaxFieldOrdinal
            {
                get
                {
                    return _maxFieldOrdinal;
                }
                set
                {
                    // The manifest may specify more fields, and this will help 
                    // ToString().
                    _maxFieldOrdinal = value;
                }
            }

            public uint[] SpecialFieldOrdinals
            {
                get 
                {
                    // @@@ if only we had Linq, we could just do 
                    // _specialFieldOrdinals.ToArray();
                    var list = new List<uint>();
                    foreach (uint i in _specialFieldOrdinals)
                    {
                        list.Add(i);
                    }
                    return list.ToArray();
                }
            }

            public VortexFieldCollection()
            {
                _fieldValues = new Dictionary<uint, object>(16); // rough guess of size
                _specialFieldOrdinals = new HashSet<uint>();
                _maxFieldOrdinal = 0;
            }

            public VortexFieldCollection Clone()
            {
                VortexFieldCollection result = new VortexFieldCollection();

                foreach (var field in _fieldValues)
                {
                    result._fieldValues.Add(field.Key, field.Value);
                }

                foreach (var item in _specialFieldOrdinals)
                {
                    result._specialFieldOrdinals.Add(item);
                }

                result._maxFieldOrdinal = _maxFieldOrdinal;

                return result;
            }

            public void AddField(uint fieldOrdinal, object fieldValue)
            {
                _fieldValues[fieldOrdinal] = fieldValue;
                if (fieldValue is SpecialField)
                {
                    _specialFieldOrdinals.Add(fieldOrdinal);
                }
                _maxFieldOrdinal = Math.Max(fieldOrdinal, _maxFieldOrdinal);
            }

            public void AddField(uint fieldType, uint fieldOrdinal, object fieldValue)
            {
                _fieldValues[fieldOrdinal] = fieldValue;
                if (fieldType == (uint)VxProtocol.VxFieldType.Special)
                {
                    _specialFieldOrdinals.Add(fieldOrdinal);
                }
                _maxFieldOrdinal = Math.Max(fieldOrdinal, _maxFieldOrdinal);
            }

            public void RemoveField(uint fieldOrdinalRemove, bool fShift)
            {
                if (!_fieldValues.ContainsKey(fieldOrdinalRemove))
                {
                    return;
                }

                // Build new dictionaries, since we may have to shift all the keys anyway 
                // or we may have removed the max ordinal. This is easier.
                Dictionary<uint, object> oldFieldValues = _fieldValues;
                uint oldMaxFieldOrdinal = _maxFieldOrdinal;

                _fieldValues = new Dictionary<uint, object>(oldFieldValues.Count);
                _specialFieldOrdinals = new HashSet<uint>();
                _maxFieldOrdinal = 0;

                uint shiftVal = 0;
                for (uint fieldId = 1; fieldId <= oldMaxFieldOrdinal; fieldId++)
                {
                    if (fieldId == fieldOrdinalRemove)
                    {
                        // This is the field we're removing
                        if (fShift)
                        {
                            shiftVal = 1;
                        }
                    }
                    else
                    {
                        uint newOrdinal = (uint)(fieldId - shiftVal);

                        object v;
                        if (!oldFieldValues.TryGetValue(fieldId, out v))
                            continue;

                        AddField(newOrdinal, v);
                    }
                }
            }

            public override string ToString()
            {
                StringBuilder sb = new StringBuilder(500);
                string sep = "";

                // Fields start at 1, not 0. We need to fill missing fields with the 
                // separator.
                // We also cap the max number of fields to 256 when converting to a 
                // string.
                uint maxFields = Math.Min(VxEvent.c_MaxFieldOrdinal, MaxFieldOrdinal);
                for (uint fieldId = 1; fieldId <= maxFields; fieldId++)
                {

                    sb.Append(sep);
                    sep = "|";

                    object v;
                    if (!_fieldValues.TryGetValue(fieldId, out v))
                        continue;

                    if (v is SpecialField)
                    {
                        v = ((SpecialField)v).Value;
                    }

                    if (v == null)
                        continue;
                    else if (v is ulong)
                        sb.Append(((ulong)v).ToString("X"));
                    else if (v is uint)
                        sb.Append(((uint)v).ToString("X"));
                    else if (v is ushort)
                        sb.Append(((ushort)v).ToString("X"));
                    else if (v is byte)
                        sb.Append(((byte)v).ToString("X"));
                    else if (v is byte[])
                        sb.Append(((Blob)(byte[])v).ToString());
                    else if (v is DateTime)
                        sb.Append(XDateTime.ToString((DateTime)v));
                    else
                    {
                        // Everything else is fine in its native format (right?)
                        sb.Append(v.ToString());
                    }
                }
                return sb.ToString();
            }

            public void WriteStream(VortexBinaryWriter bw)
            {
                // No ordering guarantees, don't do anything for "missing" ordinals, of 
                // course.
                foreach (var kvp in _fieldValues)
                {
                    bw.WriteVxField(kvp.Key, kvp.Value);
                }
            }

            // Generic accessor where you don't know the specific type, you just want the 
            // generic version. This will always return one of the following types:
            // * ulong
            // * long
            // * byte[]
            // * float
            // * double
            // * string
            // * SpecialField
            //

            public object GetField(uint fieldId)
            {
                object val;
                if (!_fieldValues.TryGetValue(fieldId, out val))
                {
                    throw new IndexOutOfRangeException("Field " + fieldId + " not found.");
                }
                return val;
            }

            public bool TryGetField(uint fieldId, out object val)
            {
                return _fieldValues.TryGetValue(fieldId, out val);
            }

            // These accessors are for when you know the specific type and want to read 
            // it.
            public ushort GetUInt16(uint fieldId)
            {
                return (ushort)(ulong)GetField(fieldId);
            }

            public uint GetUInt32(uint fieldId)
            {
                return (uint)(ulong)GetField(fieldId);
            }

            public ulong GetUInt64(uint fieldId)
            {
                return (ulong)GetField(fieldId);
            }

            public short GetInt16(uint fieldId)
            {
                return (short)(long)GetField(fieldId);
            }

            public int GetInt32(uint fieldId)
            {
                return (int)(long)GetField(fieldId); 
            }

            public long GetInt64(uint fieldId)
            {
                return (long)(long)GetField(fieldId);
            }

            public sbyte GetSByte(uint fieldId)
            {
                return (sbyte)(long)GetField(fieldId);
            }

            public byte GetByte(uint fieldId)
            {
                return (byte)(ulong)GetField(fieldId);
            }

            public float GetSingle(uint fieldId)
            {
                return (float)GetField(fieldId);
            }

            public double GetDouble(uint fieldId)
            {
                return (double)GetField(fieldId);
            }

            public byte[] GetBytes(uint fieldId)
            {
                return (byte[])GetField(fieldId);
            }

            public string GetString(uint fieldId)
            {
                return (string)GetField(fieldId);
            }

            public SpecialField GetSpecialField(uint fieldId)
            {
                return (SpecialField)GetField(fieldId);
            }

            // Some helper accessors, but not strictly necessary

            public Guid GetGuid(uint fieldId)
            {
                byte[] buf = (byte[])GetField(fieldId);
                return new Guid(buf);
            }

            public DateTime GetDateTime(uint fieldId)
            {
                long ft = (long)GetUInt64(fieldId);
                return DateTime.FromFileTimeUtc(ft);
            }
        }

    }

    // ------------------------------------------------------------------------------
    // class SpecialField
    //
    // ------------------------------------------------------------------------------
    public class SpecialField
    {
        public uint Id;
        public object Value;
    }

    // ----------------------------------------------------------------------------------
    // VxProtocol
    //
    // Main entry point for reading a binary Vortex protocol message. Right now, it 
    // assumes you want a generic representation of the events in the message with 
    // random-access to the individual fields by ordinal.
    // ----------------------------------------------------------------------------------
    public class VxProtocol
    {
        public const int c_FieldTypeShift = 3;
        public const int c_FieldTypeMask = (1 << c_FieldTypeShift) - 1;

        public enum VxProtocolType : byte
        {
            Etx = 1
        };

        // Only get 3 bits for this value in the protocol
        public enum VxFieldType : uint
        {
            Terminator = 0,
            VarInt = 1,
            Blob = 2,
            Single = 3,
            Double = 4,
            String = 5,
            SVarInt = 6,
            Special = 7,
        };

        public enum VxSpecialFieldTypeId : uint
        {
            VortexDeletedField = 1,    // Vortex should delete this field and shift ordinals
        }

        public static List<VxEvent> ReadStream(Stream inStream)
        {
            VortexBinaryReader br = new VortexBinaryReader(inStream);

            byte protocolType = br.ReadByte();
            switch (protocolType)
            {
                case (byte)VxProtocolType.Etx:
                    return ReadEtxStream(br);
                default:
                    throw new InvalidOperationException("Unrecognized protocol type " + protocolType);
            }
        }

        private static List<VxEvent> ReadEtxStream(VortexBinaryReader inStream)
        {
            // @@@ fixed or varint?
            long timestampBase = inStream.ReadInt64();

            List<VxEvent> eventList = new List<VxEvent>();
            try
            {
                // Give it a default value
                Blob lastProducerId = new Blob();

                // Note: instream.BaseStream.Position is supported for MemoryStreams, but 
                // not supported for HttpRequestStreams. Boo! So I guess we just have to 
                // read until an EndOfStreamException?

                if (inStream.BaseStream.CanSeek)
                {
                    while (inStream.BaseStream.Position < inStream.BaseStream.Length)
                    {
                        // @@@ Note: if we implement special fields that span multiple events
                        // then we'll need to store that knowledge and pass it to future events.
                        var msg = new VxEvent(inStream, lastProducerId, timestampBase);
                        lastProducerId = msg.ProducerId;
                        eventList.Add(msg);
                    }
                }
                else
                {
                    // wait for the exception...
                    while (true)
                    {
                        // @@@ Note: if we implement special fields that span multiple events
                        // then we'll need to store that knowledge and pass it to future events.
                        var msg = new VxEvent(inStream, lastProducerId, timestampBase);
                        lastProducerId = msg.ProducerId;
                        eventList.Add(msg);
                    }
                }

            }
            catch (EndOfStreamException)
            {
                // walked off end. any way to tell caller this but still return a valid 
                // list?
                if (eventList.Count == 0)
                    throw;
            }

            return eventList;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\teamticket.cs ===
//
// TeamTicket.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
using System;
using System.IO;

using xonline.common.service;


namespace xonline.common.protocol 
{
    public class TeamTicket : WireData
    {
        public ulong userID;
        public short cTeams;
        public short cbSignature;
        
        [WireInfo(SizeParam="cTeams")] 
        public ulong [] rgqwTeamIDs;
        
        [WireInfo(SizeParam="cbSignature")] 
        public byte [] rgbSignature;

        [WireInfo(Serialize=false)]
        private bool verified = false;
        
        [WireInfo(Serialize=false)]
        public const int TEAM_TICKET_SIGNATURE_LENGTH = 8;

        [WireInfo(Serialize=false)]
        public const uint MAXIMUM_TEAMS_PER_TICKET = 8;

        // 
        // Must have a default constructor for deserialization
        // 
        public TeamTicket()
        {
        }
        
        public TeamTicket(ulong userId, ulong teamId)
        {
            userID = userId;
            cTeams = 1;
            rgqwTeamIDs = new ulong[1];
            rgqwTeamIDs[0] = teamId;

            cbSignature = 0;
            rgbSignature = null;
        }
        
        public TeamTicket(BinaryReader reader)
        {
            base.ReadStream(reader);
            if (cTeams > MAXIMUM_TEAMS_PER_TICKET)
            {
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.AUTHDATA_BAD_TEAM_TICKETS, "TeamTicket contains too many teams: " + cTeams);
            }
            verified = false;
        }


        // 
        // Methods for creating and validating a ticket given SGInfo
        // 
        private byte[] TicketSignature(SGInfo sginfo)
        {
            MemoryStream m = new MemoryStream(100);
            BinaryWriter w = new BinaryWriter(m);

            w.Write(userID);
            w.Write((short)rgqwTeamIDs.Length);
            w.Write((short)TEAM_TICKET_SIGNATURE_LENGTH);
            foreach(ulong t in rgqwTeamIDs)
            {
                w.Write(t);
            }
            byte[] teamTicket = m.ToArray();

            byte[] fullSignature = sginfo.SignWithKey(teamTicket, 0, teamTicket.Length);
            byte[] signature = new byte[TEAM_TICKET_SIGNATURE_LENGTH];
            Array.Copy(fullSignature,signature,TEAM_TICKET_SIGNATURE_LENGTH);

            return signature;
        }

        public void SignTicket(SGInfo sginfo)
        {
            cbSignature = TEAM_TICKET_SIGNATURE_LENGTH;
            rgbSignature = TicketSignature(sginfo);
        }

        public void SignTicket()
        {
            SignTicket(SGInfo.Current);
        }
        
        public void VerifyTicket(SGInfo sginfo)
        {
            if (!verified && AuthToggle.On)
            {
                if (rgbSignature == null || !ByteArray.Equals(TicketSignature(sginfo), rgbSignature))
                {
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.AUTHDATA_BAD_TEAM_TICKETS_1, "TeamTicket signature verification failed");
                }
                if (!sginfo.IsUserPresent(userID))
                {
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.AUTHDATA_BAD_TEAM_TICKETS_2, "Team ticket is for user not present in auth data: " + userID.ToString("X"));
                }
                verified = true;
            }            
        }

        public void VerifyTicket()
        {
            VerifyTicket(SGInfo.Current);
        }
        
        //
        // Return size of this team ticket after serialization
        //
        public override int Size()
        {
            return 12 + (8 * cTeams) + cbSignature;
        }

        public bool Signed()
        {
            return (cbSignature != 0);
        }
        
        public void ClearSignature()
        {
            cbSignature = 0;
            rgbSignature = null;
        }
        
        // 
        // Helper method to verify that a user is a member of a team
        // 
        public bool VerifyMembership(ulong userId, ulong teamId)
        {
            bool fResult = false;

            if (userId == userID)
            {
                foreach(ulong t in rgqwTeamIDs)
                {
                    if (t == teamId)
                    {
                        fResult = true;
                        break;
                    }
                }
            }
            
            return fResult;            
        }
    }
    
    public class TeamTickets : WireData
    {
        public ushort wType; // == TEAM_TICKETS_TYPE
        public ushort wLength; // number of bytes following this ushort
        public ushort cTickets; // maximum of MAXIMUM_TEAM_TICKETS
        
        [WireInfo(SizeParam="cTickets")] 
        public TeamTicket[] teamTickets;
        
        [WireInfo(Serialize=false)]
        public const ushort TEAM_TICKETS_TYPE = 0x0001;

        [WireInfo(Serialize=false)]
        public const uint MAXIMUM_TEAM_TICKETS = 1024;

        // 
        // Must have a default constructor for deserialization
        // 
        public TeamTickets()
        {
        }
        
        public TeamTickets(BinaryReader reader)
        {
            ReadStream(reader);
        }

        public TeamTickets(TeamTicket[] paramTeamTickets)
        {
            teamTickets = paramTeamTickets;

            cTickets = (ushort)teamTickets.Length;
            if (cTickets > MAXIMUM_TEAM_TICKETS)
            {
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.AUTHDATA_BAD_TEAM_TICKETS_3, "Team Tickets contains too many tickets: " + cTickets);
            }
        }

        //
        // Override default implementations of WireData methods for this class
        //
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            int actualLength = 2;

            try
            {
                wType = binaryReader.ReadUInt16();
            }
            catch (EndOfStreamException)
            {
                //We need to throw a peekcharendofstreamexception instead of a plain endofstream exception
                //This is to accurately tell the same thing as what peekchar would have told us
                //that is there were no more data in the stream
                throw new PeekCharEndOfStreamException();
            }
            
            if (wType != TEAM_TICKETS_TYPE)
            {
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.AUTHDATA_BAD_TEAM_TICKETS_4, "Team Tickets type expected. Received: " + wType.ToString("X"));
            }
            wLength = binaryReader.ReadUInt16();          
            cTickets = binaryReader.ReadUInt16();
            if (cTickets > MAXIMUM_TEAM_TICKETS)
            {
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.AUTHDATA_BAD_TEAM_TICKETS_5, "Team Tickets contains too many tickets: " + cTickets);
            }
            teamTickets = new TeamTicket[cTickets];
            for (int i = 0; i < cTickets; ++i)
            {
                teamTickets[i] = new TeamTicket(binaryReader);
                actualLength += teamTickets[i].Size();
            }
            if (actualLength != wLength)
            {
                throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.AUTHDATA_BAD_TEAM_TICKETS_6, "Team Tickets length inconsistent. Stated:" + wLength + " Actual:" + actualLength);
            }

            return this;                                
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {            
            wType = TEAM_TICKETS_TYPE;
            cTickets = (ushort)teamTickets.Length;
            wLength = 2; // length of cTickets
            for (int i = 0; i < cTickets; ++i)
            {
                wLength += (ushort)teamTickets[i].Size();
            }
            base.WriteStream(binaryWriter);
        }

        public void VerifyTickets(SGInfo sginfo)
        {
            foreach(TeamTicket t in teamTickets)
            {
                t.VerifyTicket(sginfo);
            }
        }
        
        public void VerifyTickets()
        {
            VerifyTickets(SGInfo.Current);
        }
        
        // 
        // Helper method to verify that a user is a member of a team
        // 
        public bool VerifyMembership(ulong userId, ulong teamId)
        {
            foreach(TeamTicket t in teamTickets)
            {
                if (t.userID == userId)
                {
                    return t.VerifyMembership(userId, teamId);
                }
            }

            return false;
        }

        public void VerifyMembershipThrow(ulong userId, ulong teamId)
        {
            if (false == VerifyMembership(userId, teamId))
            {
                throw new XRLException(HResult.XONLINE_E_TEAMS_NOT_A_MEMBER, XEvent.Id.AUTHDATA_BAD_TEAM_TICKETS_7, "User " + userId + " is not a member of team " + teamId);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\teamprot.cs ===
// 
// Message.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Presence Service Integration
// Xbox Online Service
// 
// Author: phansen
//

using xonline.common.service;
using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.TeamProxy)]

namespace xonline.common.protocol 
{    
    //
    // Teams Definitions
    //
    public class TeamDefs
    {
        public const uint MAX_TEAM_COUNT                            = 8;
        public const uint MAX_TEAM_MEMBER_COUNT                     = 100;

        //
        // Unicode zero-teminated strings length
        //
        public const uint MAX_TEAM_NAME_SIZE                        = 16;
        public const uint MAX_TEAM_DESCRIPTION_SIZE                 = 256;
        public const uint MAX_TEAM_MOTTO_SIZE                       = 256;
        public const uint MAX_TEAM_URL_SIZE                         = 256;

        public const uint MAX_TEAM_DATA_SIZE                        = 100;
        public const uint MAX_TEAM_MEMBER_DATA_SIZE                 = 100;

        //
        // Team constants
        //
        public const uint MAX_TEAMS                                 = MAX_TEAM_COUNT;
        public const uint MAX_TEAM_NAME_CHAR                        = MAX_TEAM_NAME_SIZE;
        public const uint MAX_TEAM_NAME_BYTES                       = MAX_TEAM_NAME_SIZE * 2;
        public const uint MAX_TEAM_DESCRIPTION_CHAR                 = MAX_TEAM_DESCRIPTION_SIZE;
        public const uint MAX_TEAM_DESCRIPTION_BYTES                = MAX_TEAM_DESCRIPTION_SIZE * 2;
        public const uint MAX_TEAM_MOTTO_CHAR                       = MAX_TEAM_MOTTO_SIZE;
        public const uint MAX_TEAM_MOTTO_BYTES                      = MAX_TEAM_MOTTO_SIZE * 2;
        public const uint MAX_TEAM_URL_CHAR                         = MAX_TEAM_URL_SIZE;
        public const uint MAX_TEAM_URL_BYTES                        = MAX_TEAM_URL_SIZE * 2;
        public const uint MAX_TEAM_DATA_BYTES                       = MAX_TEAM_DATA_SIZE;
        public const uint MAX_TEAM_MEMBER_DATA_BYTES                = MAX_TEAM_MEMBER_DATA_SIZE;
        
    };
    
    public class TeamsXrlObject : XRLObject2
    {
        public override string Xrl
        {
            get
            {
                return "/xpnfront/xteams.srf";
            }
        }   
    }

    //
    // Structure Representing a request to get a team ticket for a ser
    //  maps to PMSG_TEAM_GET_TICKET in xonline.x
    //  
    public class TeamGetTicketMsg : XRLObject2
    {
        public TeamGetTicketMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_GET_TICKET,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;

        public override int Size()
        {
            // sizeof( PMSG_TEAM_GET_TICKET )
            return 44;
        }        
        
    };

    //
    // Structure Representing the reply to an TeamGetTicketMsg message
    //  maps to PMSG_TEAM_GET_TICKET_REPLY in xonline.x
    //  
    public class TeamGetTicketReply : XRLObject2
    {
        public TeamGetTicketReply()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_GET_TICKET_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public TeamTicket       sTeamTicket;

        public override int Size()
        {
            // sizeof( PMSG_TEAM_GET_TICKET_REPLY )
            return 36 + sTeamTicket.Size();
        }        
    };

    //
    //  Maps to P_TEAM_CREATE_MSG in xonline.x
    //  
    public class TeamCreateMsg : TeamsXrlObject
    {
        public TeamCreateMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_CREATE,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public uint             dwMaxMembers;
        public short            cbTeamName;
        public short            cbTeamDescription;
        public short            cbTeamMotto;
        public short            cbTeamURL;
        public short            cbTeamData;
        public short            cbCreatorData;

        [WireInfo(SizeParam="cbTeamName")]
        public byte[]           rgbTeamName;

        [WireInfo(SizeParam="cbTeamDescription")]
        public byte[]           rgbTeamDescription;

        [WireInfo(SizeParam="cbTeamMotto")]
        public byte[]           rgbTeamMotto;

        [WireInfo(SizeParam="cbTeamURL")]
        public byte[]           rgbTeamURL;

        [WireInfo(SizeParam="cbTeamData")]
        public byte[]           rgbTeamData;
        
        [WireInfo(SizeParam="cbCreatorData")]
        public byte[]           rgbCreatorData;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamCreateMsg ) + cbTeamName + cbTeamDescription + cbTeamMotto + cbTeamURL + cbTeamData + cbCreatorData
            return 32 + 28 + cbTeamName + cbTeamDescription + cbTeamMotto + cbTeamURL + cbTeamData + cbCreatorData;
        }
    };

    public class TeamCreateXeMsg : TeamCreateMsg
    {
        public TeamCreateXeMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_CREATE_XE,this);
        }
    }

    //
    //  Maps to P_TEAM_CREATE_REPLY_MSG in xonline.x
    //  
    public class TeamCreateReplyMsg : XRLObject2
    {
        public TeamCreateReplyMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_CREATE_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public ulong            qwTeamID;
        public ulong            ftCreated;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamCreateReplyMsg )
            return 32 + 20;
        } 
    }; 

    //
    //  Maps to P_TEAM_DELETE_MSG in xonline.x
    //  
    public class TeamDeleteMsg : TeamsXrlObject
    {
        public TeamDeleteMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_DELETE,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public ulong            qwTeamID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamDeleteMsg )
            return 32 + 20;
        } 
    };
 
    //
    // Structure Representing a request to get a team ticket for a ser
    //  maps to P_TEAM_DELETE_REPLY_MSG in xonline.x
    //  
    public class TeamDeleteReplyMsg : XRLObject2
    {
        public TeamDeleteReplyMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_DELETE_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamDeleteReplyMsg )
            return 32 + 4;
        } 
    };

    //
    // Maps to P_TEAM_REMOVE_MSG in xonline.x
    //  
    public class TeamRemoveMsg : TeamsXrlObject
    {
        public TeamRemoveMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_REMOVE,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public ulong            qwTeamID;
        public ulong            qwMemberID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamRemoveMsg ) + cbTeamName + cbTeamDescription + cbTeamMotto + cbTeamURL + cbTeamData + cbCreatorData
            return 32 + 28;
        }
    };
 
    //
    //  Maps to P_TEAM_REMOVE_REPLY_MSG in xonline.x
    //  
    public class TeamRemoveReplyMsg : XRLObject2
    {
        public TeamRemoveReplyMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_REMOVE_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamRemoveReplyMsg )
            return 32 + 4;
        } 
    };

    //
    //  Maps to P_TEAM_MANAGE_TEAM_MSG in xonline.x
    //  
    public class TeamManageTeamMsg : TeamsXrlObject
    {
        public TeamManageTeamMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_MANAGE_TEAM,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public ulong            qwTeamID;
        public short            cbTeamName;
        public short            cbTeamDescription;
        public short            cbTeamMotto;
        public short            cbTeamURL;
        public short            cbTeamData;

        [WireInfo(SizeParam="cbTeamName")]
        public byte[]           rgbTeamName;

        [WireInfo(SizeParam="cbTeamDescription")]
        public byte[]           rgbTeamDescription;

        [WireInfo(SizeParam="cbTeamMotto")]
        public byte[]           rgbTeamMotto;

        [WireInfo(SizeParam="cbTeamURL")]
        public byte[]           rgbTeamURL;

        [WireInfo(SizeParam="cbTeamData")]
        public byte[]           rgbTeamData;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamManageTeamMsg ) + cbTeamName + cbTeamDescription + cbTeamMotto + cbTeamURL + cbTeamData
            return 32 + 30 + cbTeamName + cbTeamDescription + cbTeamMotto + cbTeamURL + cbTeamData;
        }
    };

    public class TeamManageTeamXeMsg : TeamManageTeamMsg
    {
        public TeamManageTeamXeMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_MANAGE_TEAM_XE,this);
        }
    }

    //
    //  Maps to P_TEAM_MANAGE_TEAM_REPLY_MSG in xonline.x
    //  
    public class TeamManageTeamReplyMsg : XRLObject2
    {
        public TeamManageTeamReplyMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_MANAGE_TEAM_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamManageTeamReplyMsg )
            return 32 + 4;
        } 
    };
 
    //
    //  Maps to P_TEAM_MANAGE_MEMBER_MSG in xonline.x
    //  
    public class TeamManageMemberMsg : TeamsXrlObject
    {
        public TeamManageMemberMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_MANAGE_MEMBER,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public ulong            qwTeamID;
        public ulong            qwMemberID;
        public uint             dwMemberPriv;
        public short            cbMemberData;
        
        [WireInfo(SizeParam="cbMemberData")]
        public byte[]           rgbMemberData;
        
        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamManageTeamMsg ) + cbMemberData
            return 32 + 34 + cbMemberData;
        }
    };

    //
    //  Maps to P_TEAM_MANAGE_MEMBER_REPLY_MSG in xonline.x
    //  
    public class TeamManageMemberReplyMsg : XRLObject2
    {
        public TeamManageMemberReplyMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_MANAGE_MEMBER_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamManageMemberReplyMsg )
            return 32 + 4;
        } 
    };

    //
    //  Maps to P_TEAM_RECRUIT_MSG in xonline.x
    //  
    public class TeamRecruitMsg : TeamsXrlObject
    {
        public TeamRecruitMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_RECRUIT,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public ulong            qwTeamID;
        public ulong            qwMemberID;
        [WireInfo(ArraySize=PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string           szMemberName;
        public uint             dwMemberPriv;
        public uint             dwMessageFlags;
        public short            cbMemberData;
        public short            cbDetails;

        [WireInfo(SizeParam="cbDetails")]
        public byte[]           rgbDetails;
        
        [WireInfo(SizeParam="cbMemberData")]
        public byte[]           rgbMemberData;  

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamManageTeamMsg ) + cbDetails + cbMemberData
            return 32 + 56 + cbDetails + cbMemberData;
        }
    };

    //
    //  Maps to P_TEAM_RECRUIT_REPLY_MSG in xonline.x
    //  
    public class TeamRecruitReplyMsg : XRLObject2
    {
        public TeamRecruitReplyMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_RECRUIT_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamRecruitReplyMsg )
            return 32 + 4;
        } 
    };

    //
    //  Maps to P_TEAM_JOIN_MSG in xonline.x
    //  
    public class TeamJoinMsg : TeamsXrlObject
    {
        public TeamJoinMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_JOIN,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public ulong            qwTeamID;
        public uint             dwRecruitMsgID;
        public byte             bAnswer;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamJoinMsg )
            return 32 + 25;
        }
    };

    //
    //  Maps to P_TEAM_JOIN_REPLY_MSG in xonline.x
    //  
    public class TeamJoinReplyMsg : XRLObject2
    {
        public TeamJoinReplyMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_JOIN_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamJoinReplyMsg )
            return 32 + 4;
        } 
    };

    //
    //  Maps to P_REPLY_TEAM in xonline.x
    //  
    public class ReplyTeam : TeamsXrlObject
    {
        public ulong            qwTeamID;
        public uint             dwNumMembers;
        public short            cbTeamName;
        public short            cbTeamDescription;
        public short            cbTeamMotto;
        public short            cbTeamURL;
        public short            cbTeamData;
        public ulong            ftCreated;

        [WireInfo(SizeParam="cbTeamName")]
        public byte[]           rgbTeamName;

        [WireInfo(SizeParam="cbTeamDescription")]
        public byte[]           rgbTeamDescription;

        [WireInfo(SizeParam="cbTeamMotto")]
        public byte[]           rgbTeamMotto;

        [WireInfo(SizeParam="cbTeamURL")]
        public byte[]           rgbTeamURL;

        [WireInfo(SizeParam="cbTeamData")]
        public byte[]           rgbTeamData;

        public override int Size()
        {
            // sizeof( ReplyTeam ) + cbTeamName + cbTeamDescription + cbTeamMotto + cbTeamURL + cbTeamData
            return 30 + cbTeamName + cbTeamDescription + cbTeamMotto + cbTeamURL + cbTeamData;
        } 
    };

    //
    //  Maps to P_REPLY_USER_TEAM in xonline.x
    //  
    public class ReplyUserTeam : WireData
    {
        public ulong            qwTeamID;
        public uint             fMember;

        [WireInfo(ArraySize=(int)TeamDefs.MAX_TEAM_NAME_BYTES)]
        public byte[]           rgbTeamName;

        public override int Size()
        {
            // sizeof( ReplyUserTeam ) 
            return 12 + (int)TeamDefs.MAX_TEAM_NAME_BYTES;
        } 
    };

    //
    //  Maps to P_REPLY_TEAM_MEMBER in xonline.x
    //  
    public class ReplyTeamMember : XRLObject2
    {
        public ulong            qwMemberID;
        public byte             cbMemberName;
        public uint             fMember;
        public uint             dwMemberPriv;
        public short            cbMemberData;
        public ulong            ftJoined;

        [WireInfo(SizeParam="cbMemberName")]
        public string           szMemberName;
        
        [WireInfo(SizeParam="cbMemberData")]
        public byte[]           rgbMemberData;

        public override int Size()
        {
            // sizeof( ReplyTeamMember ) + cbMemberName + cbMemberData
            return 27 + cbMemberName + cbMemberData;
        }
    };

    //
    //  Maps to P_TEAM_LIST_TEAMS_MSG in xonline.x
    //  
    public class TeamListTeamsMsg : TeamsXrlObject
    {
        public TeamListTeamsMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_LIST_TEAMS,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public uint             cTeamIDs;

        [WireInfo(SizeParam="cTeamIDs")]
        public ulong[]          rgqwTeamIDs;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamListTeamsMsg )
            return 32 + 16 + ((int)cTeamIDs * 8);
        }       
    };

    //
    //  Maps to P_TEAM_LIST_TEAMS_REPLY_MSG in xonline.x
    //  
    public class TeamListTeamsReplyMsg : XRLObject2
    {
        public TeamListTeamsReplyMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_LIST_TEAMS_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public uint             cTeams;

        [WireInfo(SizeParam="cTeams")]
        public ReplyTeam[]      replyTeam;

        public override int Size()
        {
            int iSize = 0;
            int i;

            // sizeof( BASE_MSG_HEADER )
            iSize += 32;

            // sizeof( TeamListTeamsReplyMsg )
            iSize += 8;

            for (i=0; i<cTeams; i++)
            {
                iSize += replyTeam[i].Size();
            }

            return iSize;
        }
    };

    //
    //  Maps to P_TEAM_LIST_USER_TEAMS_MSG in xonline.x
    //  
    public class TeamListUserTeamsMsg : TeamsXrlObject
    {
        public TeamListUserTeamsMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_LIST_USER_TEAMS,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamListUserTeamsMsg )
            return 32 + 12;
        }       
    };

    //
    //  Maps to P_TEAM_LIST_USER_TEAMS_REPLY_MSG in xonline.x
    //  
    public class TeamListUserTeamsReplyMsg : XRLObject2
    {
        public TeamListUserTeamsReplyMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_LIST_USER_TEAMS_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public uint             cTeams;

        [WireInfo(SizeParam="cTeams")]
        public ReplyUserTeam[] replyUserTeam;

        public override int Size()
        {
            int iSize = 0;
            int i;

            // sizeof( BASE_MSG_HEADER )
            iSize += 32;

            // sizeof( TeamListUserTeamsReplyMsg )
            iSize += 8;

            for (i=0; i<cTeams; i++)
            {
                iSize += replyUserTeam[i].Size();
            }
            
            return iSize;
        }
    };

    //
    //  Maps to P_TEAM_LIST_MEMBERS_MSG in xonline.x
    //  
    public class TeamListMembersMsg : TeamsXrlObject
    {
        public TeamListMembersMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_LIST_MEMBERS,this);
        }

        public BaseHeader       header;
        public ulong            qwUserID;
        public uint             dwTitleID;
        public ulong            qwTeamID;
        public uint             fShowRecruits;

        public override int Size()
        {
            // sizeof( BASE_MSG_HEADER ) + sizeof( TeamListMembersMsg )
            return 32 + 24;
        }
    };

    //
    //  Maps to P_TEAM_LIST_TEAMS_REPLY_MSG in xonline.x
    //  
    public class TeamListMembersReplyMsg : XRLObject2
    {
        public TeamListMembersReplyMsg()
        {
            header = new BaseHeader(P_MSG_TYPES.PMSG_TEAM_LIST_MEMBERS_REPLY,this);
        }

        public BaseHeader       header;
        public HResult          hr;
        public ulong            qwTeamID;
        public ushort           cMembers;

        [WireInfo(SizeParam="cMembers")]
        public ReplyTeamMember[]      replyTeamMember;

        public override int Size()
        {
            int iSize = 0;
            int i;

            // sizeof( BASE_MSG_HEADER )
            iSize += 32;

            // sizeof( TeamListMembersReplyMsg )
            iSize += 14;

            for (i=0; i<cMembers; i++)
            {
                iSize += replyTeamMember[i].Size();
            }

            return iSize;
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\UsageProt.cs ===
using xonline.common.service;

namespace xonline.common.protocol
{
    public class UsageDefs
    {
        public const ushort USAGE_QUERY_BY_ATTRIBUTES_SORT_BY_DATE = 0xFFFF;

        public const ushort USAGE_SOURCE_XBOX = 1;
        public const ushort USAGE_SOURCE_ZUNE = 2;
        
        public const ushort USAGE_ATTRIBUTE_MIN = 1;
        public const ushort USAGE_ATTRIBUTE_PLAYCOUNT = 1;
        public const ushort USAGE_ATTRIBUTE_DOWNLOADCOUNT = 2;
        public const ushort USAGE_ATTRIBUTE_PURCHASECOUNT = 3;
        public const ushort USAGE_ATTRIBUTE_RATING = 4;
        public const ushort USAGE_ATTRIBUTE_STREAMCOUNT = 5;
        public const ushort USAGE_ATTRIBUTE_SENDCOUNT = 6;
        public const ushort USAGE_ATTRIBUTE_COMMENTCOUNT = 7;
        public const ushort USAGE_ATTRIBUTE_SKIPCOUNT = 8;
        public const ushort USAGE_ATTRIBUTE_AD_PLAYCOUNT = 9;
        public const ushort USAGE_ATTRIBUTE_PERCENTAGE_VIEWED = 10;
        public const ushort USAGE_ATTRIBUTE_MAX = 10;

        public static bool IsAggregateAttribute(ushort attribute)
        {
            switch (attribute)
            {
            case USAGE_ATTRIBUTE_PLAYCOUNT:
            case USAGE_ATTRIBUTE_DOWNLOADCOUNT:
            case USAGE_ATTRIBUTE_PURCHASECOUNT:
            case USAGE_ATTRIBUTE_STREAMCOUNT:
            case USAGE_ATTRIBUTE_SENDCOUNT:
            case USAGE_ATTRIBUTE_COMMENTCOUNT:
            case USAGE_ATTRIBUTE_SKIPCOUNT:
            case USAGE_ATTRIBUTE_AD_PLAYCOUNT:
                return true;
            default:
                return false;
            }
        }

        public static bool IsReplaceAttribute(ushort attribute)
        {
            switch (attribute)
            {
            case USAGE_ATTRIBUTE_RATING:
            case USAGE_ATTRIBUTE_PERCENTAGE_VIEWED:
                return true;
            default:
                return false;
            }
        }

        public static bool IsIntegerValueAttribute(ushort attribute)
        {
            switch (attribute)
            {
            case USAGE_ATTRIBUTE_PLAYCOUNT:
            case USAGE_ATTRIBUTE_DOWNLOADCOUNT:
            case USAGE_ATTRIBUTE_PURCHASECOUNT:
            case USAGE_ATTRIBUTE_STREAMCOUNT:
            case USAGE_ATTRIBUTE_SENDCOUNT:
            case USAGE_ATTRIBUTE_COMMENTCOUNT:
            case USAGE_ATTRIBUTE_SKIPCOUNT:
            case USAGE_ATTRIBUTE_RATING:
            case USAGE_ATTRIBUTE_AD_PLAYCOUNT:
            case USAGE_ATTRIBUTE_PERCENTAGE_VIEWED:
                return true;
            default:
                return false;            
            }
        }

        public static bool IsBinaryValueAttribute(ushort attribute)
        {
            switch (attribute)
            {
            default:
                return false;
            }
        }
    }

    public class UsageStoreRequest : XRLObject2
    {
        public uint XMLSize;

        [WireInfo(SizeParam="XMLSize")]
        public string XML;

        public override string Xrl
        {
            get
            {
                return "/xstats/usagestore.ashx";
            }
        }
    }

    public class UsageStoreResponse : XRLObject2
    {
        public HResult hr;
    }

/*
    public class UsageQueryByAttributes : XRLObject2
    {
        public ulong userID;
        public ushort numAttributes;
        public ushort iSortAttribute; 
        public uint offsetResults;
        public uint maxResults;

        [WireInfo(SizeParam="numAttributes")]
        public int[] attributes;

        public string GetXRL()
        {
            return "/xstats/usagequerybyattributes.ashx";
        }
    }

    public class UsageQueryByAttributesResponse : XRLObject2
    {
        public HResult hr;
        public uint numResults;

        [WireInfo(SizeParam="numResults")]
        public UsageQueryByAttributesResponseData[] results;
    }

    public class UsageQueryByAttributesResponseData : WireData
    {
        public byte[] mediaInstanceId;
        public ushort numAttributes;

        [WireInfo(SizeParam="numAttributes")]
        public UsageAttributeData[] attributes;
    }

    public class UsageAttributeData : WireData
    {
        public ushort attributeId;
        public int attributeIntData;

        public uint attributeBinarySize;

        [WireInfo(SizeParam="attributeBinarySize")]
        public byte[] attributeBinaryData;
    }
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\websvcprot.cs ===
/*==========================================================================
 *
 *  WebSvcProt.cs -- This module defines the wire protocol for Web Service Methods
 *
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

using System;
using System.IO;
using System.Collections.Generic;
using System.Text;
using System.Web;
using System.Xml;

using xonline.common.service;


namespace xonline.common.protocol
{
    public class WebServiceNameValuePair : WireData
    {
        public string name;
        public string value;

        public WebServiceNameValuePair(string name, string value)
        {
            this.name = name;
            this.value = value;
        }

        internal WebServiceNameValuePair(string pair)
        {
            string[] vals = pair.Split('=');

            name = HttpUtility.UrlDecode(vals[0]);
            value = HttpUtility.UrlDecode(vals[1]);
        }

        public override void WriteStream(BinaryWriter bw)
        {
            if (!String.IsNullOrEmpty(name))
            {
                bw.Write(Encoding.UTF8.GetBytes(HttpUtility.UrlEncode(name)));
                bw.Write((byte)61); // converted '=' character
                if (!String.IsNullOrEmpty(value))
                {
                    bw.Write(Encoding.UTF8.GetBytes(HttpUtility.UrlEncode(value)));
                }
            }
        }

        public override WireData ReadStream(BinaryReader br)
        {
            throw new NotImplementedException();
        }

        public override string ToString()
        {
            return String.Concat("[", name, "], [", value, "]");
        }
    }

    public class LivecacheWebSvcRequest : XRLObject2
    {
        protected List<WebServiceNameValuePair> pairs = new List<WebServiceNameValuePair>();

        public override void WriteStream(BinaryWriter bw)
        {
            if (pairs != null)
            {
                for (int i = 0; i < pairs.Count - 1; i++)
                {
                    pairs[i].WriteStream(bw);
                    bw.Write((byte)38); // converted '&' character
                }

                // Write the last remaining entry without the extra '&' character
                pairs[pairs.Count-1].WriteStream(bw);
            }
        }

        public override WireData ReadStream(BinaryReader br)
        {
            byte[] buf = null;

            buf = br.ReadBytes(1024);
            while (buf != null && buf.Length>0 )
            {
                string s = Encoding.UTF8.GetString(buf);
                string[] nv = s.Split('&');

                for (int i = 0; i < nv.Length - 1; i ++)
                {
                    pairs.Add(new WebServiceNameValuePair(nv[i]));
                }

                byte[] buf2 = br.ReadBytes(1024);
                if (buf2.Length > 0)
                {
                    int offset = s.LastIndexOf('&') + 1;
                    // -1 works, because that mean the entire buffer needs to be copied over
                    byte[] bufNew = new byte[buf2.Length + buf.Length - offset];

                    Array.ConstrainedCopy(buf, offset, bufNew, 0, buf.Length - offset);
                    Array.ConstrainedCopy(buf2, 0, bufNew, buf.Length - offset, buf2.Length);
                    buf = bufNew;
                }
                else
                {
                    // This is the complete last entry, just add it to the list
                    pairs.Add(new WebServiceNameValuePair(nv[nv.Length - 1]));
                    buf = null;
                }
            }

            return this;
        }

        public List<WebServiceNameValuePair> NameValuePairs
        {
            get { return pairs; }
        }

        public override string ContentType
        {
            get { return "application/x-www-form-urlencoded"; }
        }
    }

    public class LiveCacheWebSvcResponse : XRLObject2
    {
        public string response;

        public override WireData ReadStream(BinaryReader br)
        {
            return ReadStream(br.BaseStream);
        }

        public override WireData ReadStream(Stream s)
        {
            XmlTextReader reader = new XmlTextReader(s);

            reader.MoveToContent();
            response = reader.ReadOuterXml();

            return this;
        }

        public override void WriteStream(BinaryWriter bw)
        {
            throw new NotImplementedException();
        }
    }

    public class LiveCacheWebHeaderCollection : LivecacheWebSvcRequest
    {
        /// <summary>
        /// Returns UT8 encoded string representation of the class
        /// </summary>
        /// <returns>UTF8 encoded string.</returns>
        public string GetEncodedString()
        {
            string returnString = Encoding.UTF8.GetString(base.ToArray());

            return returnString;
        }

        /// <summary>
        /// Constructs the object from the string.
        /// </summary>
        /// <param name="value">UTF8 encoded string value</param>
        /// <returns></returns>
        public WireData LoadFromString(string value)
        {
            byte[] byteArray = Encoding.UTF8.GetBytes(value);

            MemoryStream stream = new MemoryStream(byteArray);

            return base.ReadStream(new BinaryReader(stream));

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\xcryptoprot.cs ===
using System;

using xonline.common.service;

namespace xonline.common.protocol
{
    public class XCryptoRequestBase : XRLObject2
    {
        public uint containerClass;
    }

    public class XCryptoData : WireData
    {
        [WireInfo(Min=1)]
        public uint dataLength;

        [WireInfo(SizeParam="dataLength")]
        public byte[] data;

        public XCryptoData()
        {
        }

        public XCryptoData(byte[] data)
            : this(data, data.Length)
        {
        }

        public XCryptoData(byte[] data, int dataLength)
        {
            this.data = data;
            this.dataLength = (uint)dataLength;
        }
    }

    public class XCryptoSignRequest : XCryptoRequestBase
    {
        public XCryptoData sha1;

        public override string Xrl { get { return "/xcrypto/XCryptoSign.ashx"; } }
    }

    public class XCryptoSignResponse : XRLObject2
    {
        public XCryptoData sig;
    }


    public class XCryptoVerifySignatureRequest : XCryptoRequestBase
    {
        public XCryptoData sha1;

        public XCryptoData sig;

        public override string Xrl { get { return "/xcrypto/XCryptoVerifySignature.ashx"; } }
    }

    public class XCryptoVerifySignatureResponse : XRLObject2
    {
        public bool verified;
    }


    public class XCryptoVerifyConsolePakRequest : XCryptoRequestBase
    {
        public const int DATA_SIZE = 16;

        public UInt64 consoleId;

        public XCryptoData clear;

        public XCryptoData pakEncrypted;

        public override string Xrl { get { return "/xcrypto/XCryptoVerifyConsolePak.ashx"; } }
    }

    public class XCryptoVerifyConsolePakResponse : XRLObject2
    {
        public bool verified;
    }

    public class XCryptoDecryptRequest : XCryptoRequestBase
    {
        public XCryptoData cipher;

        public override string Xrl { get { return "/xcrypto/XCryptoDecrypt.ashx"; } }
    }

    public class XCryptoDecryptResponse : XRLObject2
    {
        public XCryptoData clear;
    }

    public class XCryptoEncryptRequest : XCryptoRequestBase
    {
        public XCryptoData clear;

        public override string Xrl { get { return "/xcrypto/XCryptoEncrypt.ashx"; } }
    }

    public class XCryptoEncryptResponse : XRLObject2
    {
        public XCryptoData cipher;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\XSubNotiProt.cs ===
using System;
using System.Collections;
using System.Runtime.InteropServices;



namespace xonline.common.protocol.SubNoti
{
    // Schema identifier for messages.
    public enum MESSAGE_TYPES : uint
    {
        /* IF YOU ADD ANYTHING HERE, ALSO ADD TO SubNotiDefs.MessageTypeToString() BELOW! */
        
        // MIN_REQUEST_TYPE
        eConnect = 100,
        eDisconnect = 101,
        eSubscribe = 102,
        eUnsubscribe = 103,
        eQuery = 104,
        ePublish = 105,
        // MAX_REQUEST_TYPE

        // MIN_REPLY_TYPE
        eErrorReply = 300,
        eConnectReply = 301,
        eDisconnectReply = 302,
        eSubscribeReply = 303,
        eUnsubscribeReply = 304,
        eQueryReply = 305,
        ePublishReply = 306,
        // MAX_REPLY_TYPE

        // MIN_NOTIFICATION_TYPE
        eDataNotification = 500
        // MAX_NOTIFICATION_TYPE
    };

    public class SubNotiDefs
    {
        // protocol version.
        public const int CURRENT_PROTOCOL_VERSION = 1;
        public const uint MIN_REQUEST_TYPE = 100;
        public const uint MAX_REQUEST_TYPE = 105;
        public const uint MIN_REPLY_TYPE = 300;
        public const uint MAX_REPLY_TYPE = 306;
        public const uint MIN_NOTIFICATION_TYPE = 500;
        public const uint MAX_NOTIFICATION_TYPE = 500;
        public const ushort MIN_DATA_TYPE = 1000;
        public const ushort MAX_DATA_TYPE = 1008;
        public const ushort MIN_INTERNAL_DATA_TYPE = 2000;
        public const ushort MAX_INTERNAL_DATA_TYPE = 2008;

        // message header flags.
        public const int XONLINE_CONNSRV_SUBSCRIBE_ABSOLUTE_SYNC = 0x1;
        public const int XONLINE_CONNSRV_CONNECT_RECONNECT = 0x1;

        public static uint UserIndicesToFlags(int[] rgUserIndices)
        {
            uint dwUserIndexFlags = 0;
            for (int iIndex = 0; iIndex < rgUserIndices.Length; iIndex++)
            {
                dwUserIndexFlags |= (uint)(1 << rgUserIndices[iIndex]);
            }

            return dwUserIndexFlags;
        }

        public static int[] UserFlagsToIndices(uint dwUserIndexFlags)
        {
            ArrayList alIndices = new ArrayList();
            
            int index = 0;
            while (dwUserIndexFlags > 0)
            {
                if ((dwUserIndexFlags & 1) != 0)
                {
                    alIndices.Add(index);
                }
                
                dwUserIndexFlags >>= 1;
                index += 1;
            }

            return (int[])(alIndices.ToArray(typeof(int)));
        }

        public static string MessageTypeToString(uint dwMessageType)
        {
            switch (dwMessageType)
            {
                case (uint)MESSAGE_TYPES.eConnect: return "eConnect";
                case (uint)MESSAGE_TYPES.eDisconnect: return "eDisconnect";
                case (uint)MESSAGE_TYPES.eSubscribe: return "eSubscribe";
                case (uint)MESSAGE_TYPES.eUnsubscribe: return "eUnsubscribe";
                case (uint)MESSAGE_TYPES.eQuery: return "eQuery";
                case (uint)MESSAGE_TYPES.ePublish: return "ePublish";
                case (uint)MESSAGE_TYPES.eErrorReply: return "eErrorReply";
                case (uint)MESSAGE_TYPES.eConnectReply: return "eConnectReply";
                case (uint)MESSAGE_TYPES.eDisconnectReply: return "eDisconnectReply";
                case (uint)MESSAGE_TYPES.eSubscribeReply: return "eSubscribeReply";
                case (uint)MESSAGE_TYPES.eUnsubscribeReply: return "eUnsubscribeReply";
                case (uint)MESSAGE_TYPES.eQueryReply: return "eQueryReply";
                case (uint)MESSAGE_TYPES.ePublishReply: return "ePublishReply";
                case (uint)MESSAGE_TYPES.eDataNotification: return "eDataNotification";
                default: return dwMessageType.ToString();
            }
        }

    };

    // header for all API message types in the subscription/notification system.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct BASE_MESSAGE_HEADER
    {
        // Protocol version identifier.
        public uint dwProtocolVersion;
        
        // API identifier.  see MESSAGE_TYPES.
        public uint dwMessageType;

        // Sequence number.
        public uint dwSeqNum;

        // User index map for users to which this message applies.
        // 1 << (user index)
        public uint dwUserIndexFlags;

        // Total size of the message, including sizeof(BASE_MESSAGE_HEADER).
        public uint dwTotalSize;

        // Extra flags for this message.
        public uint dwHeaderFlags;
    };

    // Generic error response.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct ERROR_REPLY_MESSAGE
    {
        public BASE_MESSAGE_HEADER header;
        
        // return code.
        public int hr;
    };

    // API to log on to the XSubNoti system.
    // This message contains everything the system needs to know about a user in order to service that user's requests.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct CONNECT_MESSAGE
    {
        public BASE_MESSAGE_HEADER header;
        
        // Number of connected users.
        public ushort wNumUsers;

        // ulong rgUserIDs[wNumUsers];
    };

    // response to CONNECT_MESSAGE.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct CONNECT_REPLY_MESSAGE
    {
        public ERROR_REPLY_MESSAGE errorMsg;
    };

    // API to log off from the XSubNoti system.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct DISCONNECT_MESSAGE
    {
        public BASE_MESSAGE_HEADER header;
        
        // reason for disconnection?
        public uint dwReason;
    };

    // response to DISCONECT_MESSAGE.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct DISCONNECT_REPLY_MESSAGE
    {
        public ERROR_REPLY_MESSAGE errorMsg;
    };

    // API to create a subscription to specified data objects.
    // The current state of each subscribed object will be returned.  Additional changes made to subscribed objects
    // will be sent in further NOTIFICATION_MESSAGE packets until the objects are unsubscribed.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct SUBSCRIBE_MESSAGE
    {
        public BASE_MESSAGE_HEADER header;
        
        // number of objects requested.
        public uint dwNumDataObjects;

        // object specifiers.
        // DATA_OBJECT_SPECIFIER rgDataObjects[dwNumDataObjects];
    };

    // response to SUBSCRIBE_MESSAGE.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct SUBSCRIBE_REPLY_MESSAGE
    {
        public ERROR_REPLY_MESSAGE errorMsg;

        // number of objects returned.
        public uint dwNumDataObjects;

        // the objects returned.  not actually a fixed size array.  each object size is held in BASE_DATA_HEAER.doSpec.dwObjectSize.
        // BASE_DATA_HEADER rgDataObjects[dwNumDataObjects];
    };

    // API to tear down subscriptions to specified data objects.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct UNSUBSCRIBE_MESSAGE
    {
        public BASE_MESSAGE_HEADER header;
        
        // number of objects requested.
        public uint dwNumDataObjects;

        // object specifiers.
        // DATA_OBJECT_SPECIFIER rgDataObjects[dwNumDataObjects];
    };

    // response to UNSUBSCRIBE_MESSAGE.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct UNSUBSCRIBE_REPLY_MESSAGE
    {
        public ERROR_REPLY_MESSAGE errorMsg;
    };

    // API to receive one-time value of specified data objects.  no subscription is made.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct QUERY_MESSAGE
    {
        public BASE_MESSAGE_HEADER header;
        
        // number of objects requested.
        public uint dwNumDataObjects;

        // object specifiers.
        // DATA_OBJECT_SPECIFIER rgDataObjects[dwNumDataObjects];
    };

    // response to QUERY_MESSAGE.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct QUERY_REPLY_MESSAGE
    {
        public ERROR_REPLY_MESSAGE errorMsg;

        // number of objects returned.
        public uint dwNumDataObjects;

        // the objects returned.  not actually a fixed size array.  each object size is held in BASE_DATA_HEAER.doSpec.dwObjectSize.
        // BASE_DATA_HEADER rgDataObjects[dwNumDataObjects];
    };

    // API to publish value of specified data objects.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct PUBLISH_MESSAGE
    {
        public BASE_MESSAGE_HEADER header;
        
        // number of objects requested.
        public uint dwNumDataObjects;

        // object data.  not actually a fixed size array.  each object size is held in BASE_DATA_HEAER.doSpec.dwObjectSize.
        // BASE_DATA_HEADER rgDataObjects[dwNumDataObjects];
    };

    // response to PUBLISH_MESSAGE.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct PUBLISH_REPLY_MESSAGE
    {
        public ERROR_REPLY_MESSAGE errorMsg;
    }
    
    // message sent from server to client containing subscribed data objects that have changed.
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct NOTIFICATION_MESSAGE
    {
        public BASE_MESSAGE_HEADER header;
        
        // number of objects returned.
        public uint dwNumDataObjects;

        // the objects returned.  not actually a fixed size array.  each object size is held in BASE_DATA_HEAER.doSpec.dwObjectSize.
        // BASE_DATA_HEADER rgDataObjects[dwNumDataObjects];
    };

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\UacsProtocol.cs ===
using System;

using xonline.common.service;
using xonline.core.wiredata;

namespace xonline.common.protocol
{
    public class AcceptTermsOfUseRequest : XRLObject2
    {
        public ulong userPuid = 0;

        public ulong machinePuid = 0;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/AcceptTou.ashx"; }
        }
    }


    public class ChangeGamertagRequest : XRLObject2
    {
        public ulong machinePuid     = 0;

        public ulong userPuid        = 0;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag       = "";

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/ChangeGamertag.ashx"; }
        }
    }

    public class ChangeGamertagResponse : XRLObject2
    {
        [WireInfo(ArraySize=(int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] key  = null;    // new key
    }


    public class ClearSubscriptionsRequest : XRLObject2
    {
        public ulong machinePuid = 0;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/ClearSubscriptions.ashx"; }
        }
    }

    public class EnumerateEligibleRequest : XRLObject2
    {
        public ulong       userPuid;

        public uint        titleId;

        public uint        clientBufferSize;

        public uint        rating;

        public DateTime    lastChangedDate = DateTime.Now;

        public uint        offeringType;

        public uint        bitFilter;

        public uint        descriptionIndex;

        public ushort      startingIndex;

        public ushort      maxResults;

        [WireInfo(Min=XOn.XONLINE_LANGUAGE_MIN, Max=XOn.XONLINE_LANGUAGE_MAX)]
        public ushort      languageId;

        public ushort      voucherLength;

        [WireInfo(SizeParam="voucherLength")]
        public string      voucher;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/EnumerateEligible.ashx"; }
        }
    }

    public class GetANIDRequest : XRLObject2
    {
        public ulong userXuid;

        public override string Xrl
        {
            get { return "/xuacs/XeGetANID.ashx"; }
        }
    }

    public class GetANIDResponse : XRLObject2
    {
        public ushort AnidLength;

        [WireInfo(SizeParam = "AnidLength")]
        public string userAnid;

        public HResult anidHr;
    }

    public class GetPaymentInfoRequest : XRLObject2
    {
        public ulong userPuid;

        [WireInfo(ArraySize = XOn.ACCOUNT_PIN_LENGTH, MaskString=true)]
        public byte[] accountPin;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/GetPaymentInfo.ashx"; }
        }
    }

    public class GetPaymentInfoResponse : XRLObject2
    {
        public byte countryId;

        public byte cardTypeId;

        [WireInfo(MaskString=true)]
        public DateTime cardExpiration;

        public byte msSpam;

        public byte partnerSpam;

        public ushort firstNameLength;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        public ushort lastNameLength;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public ushort street1Length;

        [WireInfo(SizeParam="street1Length")]
        public string street1;

        public ushort street2Length;

        [WireInfo(SizeParam="street2Length")]
        public string street2;

        public ushort districtLength;

        [WireInfo(SizeParam="districtLength")]
        public string district;

        public ushort cityLength;

        [WireInfo(SizeParam="cityLength")]
        public string city;

        public ushort stateLength;

        [WireInfo(SizeParam="stateLength")]
        public string state;

        public ushort postalCodeLength;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode;

        public ushort phonePrefixLength;

        [WireInfo(SizeParam="phonePrefixLength")]
        public string phonePrefix;

        public ushort phoneNumberLength;

        [WireInfo(SizeParam="phoneNumberLength")]
        public string phoneNumber;

        public ushort phoneExtensionLength;

        [WireInfo(SizeParam="phoneExtensionLength")]
        public string phoneExtension;

        public ushort cardHolderLength;

        [WireInfo(SizeParam="cardHolderLength")]
        public string cardHolder;

        public ushort cardNumberLength;

        [WireInfo(SizeParam="cardNumberLength", MaskString=true)]
        public string cardNumber;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        public ushort bankCodeLength;

        [WireInfo(SizeParam="bankCodeLength")]
        public string bankCode;

        public ushort branchCodeLength;

        [WireInfo(SizeParam="branchCodeLength")]
        public string branchCode;

        public ushort checkDigitsLength;

        [WireInfo(SizeParam="checkDigitsLength", MaskString=true)]
        public string checkDigits;
    }

    public class GetPostalCodeRequest : XRLObject2
    {
        public byte countryId = 0;

        public ushort postalCodeLength = 0;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode = String.Empty;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/GetPostalCode.ashx"; }
        }
    }

    public class GetPostalCodeResponse : XRLObject2
    {
        public byte matchCount;

        [WireInfo(SizeParam="matchCount")]
        public PostalCodeMatch[] match;
    }

    public class PostalCodeMatch : WireData
    {
        public ushort postalCodeLength = 0;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode = String.Empty;

        public ushort provinceLength = 0;

        [WireInfo(SizeParam="provinceLength")]
        public string province = String.Empty;

        public ushort cityLength = 0;

        [WireInfo(SizeParam="cityLength")]
        public string city = String.Empty;

        public ushort streetLength = 0;

        [WireInfo(SizeParam="streetLength")]
        public string street = String.Empty;
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class CreateAccountRequest : XRLObject2, ICreateAccountRequest
    {
        public ulong machinePuid;

        public uint titleId;

        public DateTime birthdate;

        public byte msSpam;

        public byte partnerSpam;

        public byte countryId;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte cardTypeId;

        [WireInfo(MaskString=true)]
        public DateTime cardExpiration;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(Min=1, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=1, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        [WireInfo(Min=1, Max=XOn.MAX_STREET_SIZE*XOn.UTF8_MULT)]
        public ushort street1Length;

        [WireInfo(SizeParam="street1Length")]
        public string street1;

        [WireInfo(Min=0, Max=XOn.MAX_STREET_SIZE*XOn.UTF8_MULT)]
        public ushort street2Length;

        [WireInfo(SizeParam="street2Length")]
        public string street2;

        [WireInfo(Min=0, Max=XOn.MAX_DISTRICT_SIZE*XOn.UTF8_MULT)]
        public ushort districtLength;

        [WireInfo(SizeParam="districtLength")]
        public string district;

        [WireInfo(Min=1, Max=XOn.MAX_CITY_SIZE*XOn.UTF8_MULT)]
        public ushort cityLength;

        [WireInfo(SizeParam="cityLength")]
        public string city;

        [WireInfo(Min=0, Max=XOn.MAX_STATE_SIZE*XOn.UTF8_MULT)]
        public ushort stateLength;

        [WireInfo(SizeParam="stateLength")]
        public string state;

        [WireInfo(Min=0, Max=XOn.MAX_POSTALCODE_SIZE*XOn.UTF8_MULT)]
        public ushort postalCodeLength;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode;

        [WireInfo(Min=1, Max=XOn.MAX_PHONE_PREFIX_SIZE*XOn.UTF8_MULT)]
        public ushort phonePrefixLength;

        [WireInfo(SizeParam="phonePrefixLength")]
        public string phonePrefix;

        [WireInfo(Min=1, Max=XOn.MAX_PHONE_NUMBER_SIZE*XOn.UTF8_MULT)]
        public ushort phoneNumberLength;

        [WireInfo(SizeParam="phoneNumberLength")]
        public string phoneNumber;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_EXTENSION_SIZE*XOn.UTF8_MULT)]
        public ushort phoneExtensionLength;

        [WireInfo(SizeParam="phoneExtensionLength")]
        public string phoneExtension;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NAME_SIZE*XOn.UTF8_MULT)]
        public ushort cardHolderLength;

        [WireInfo(SizeParam="cardHolderLength")]
        public string cardHolder;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NUMBER_SIZE*XOn.UTF8_MULT)]
        public ushort cardNumberLength;

        [WireInfo(SizeParam="cardNumberLength", MaskString=true)]
        public string cardNumber;

        [WireInfo(Min=1, Max=XOn.MAX_EMAIL_SIZE)]
        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        [WireInfo(Min=0, Max=XOn.MAX_BANK_CODE_SIZE*XOn.UTF8_MULT)]
        public ushort bankCodeLength;

        [WireInfo(SizeParam="bankCodeLength")]
        public string bankCode;

        [WireInfo(Min=0, Max=XOn.MAX_BRANCH_CODE_SIZE*XOn.UTF8_MULT)]
        public ushort branchCodeLength;

        [WireInfo(SizeParam="branchCodeLength")]
        public string branchCode;

        [WireInfo(Min=0, Max=XOn.MAX_CHECK_DIGITS_SIZE)]
        public ushort checkDigitsLength;

        [WireInfo(SizeParam="checkDigitsLength", MaskString=true)]
        public string checkDigits;

        [WireInfo(Min=0, Max=XOn.ACTIVATION_CODE_LENGTH)]
        public ushort activationCodeLength;

        [WireInfo(SizeParam="activationCodeLength")]
        public string activationCode;

        [WireInfo(Serialize=false)]
        public string countryCode;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/CreateOwnerAcct.ashx"; }
        }

        // ICreateAccountRequest properties
        public string FirstName
        {
            get { return firstName; }
        }
        public string LastName
        {
            get { return lastName; }
        }
        public string Gamertag
        {
            get { return gamertag; }
        }
        public string Email
        {
            get { return email; }
        }
        public PhoneInfoData PhoneInfo
        {
            get
            {
                PhoneInfoData pi = new PhoneInfoData();
                pi.phonePrefix = phonePrefix;
                pi.phoneNumber = phoneNumber;
                pi.phoneExtension = phoneExtension;
                return pi;
            }
        }
        public AddressInfoData AddressInfo
        {
            get
            {
                AddressInfoData ai = new AddressInfoData();
                ai.street1 = street1;
                ai.street2 = street2;
                ai.city = city;
                ai.district = district;
                ai.state = state;
                ai.postalCode = postalCode;
                return ai;
            }
        }
        public byte PaymentInstrumentType
        {
            get { return (byte) 1; }
        }
        public CreditCardInfoData CreditCardInfo
        {
            get
            {
                CreditCardInfoData cci = new CreditCardInfoData();
                cci.accountHolderName = cardHolder;
                cci.accountNumber = cardNumber;
                cci.cardType = cardTypeId;
                cci.expirationDate = cardExpiration;
                return cci;
            }
        }
        public DirectDebitInfoData DirectDebitInfo
        {
            get { return new DirectDebitInfoData(); }
        }
        public WholesaleInfoData WholesaleInfo
        {
            get { return new WholesaleInfoData(); }
        }
        public byte CountryId
        {
            get { return countryId; }
        }
        public ushort LanguageId
        {
            get { return languageId; }
        }
        public string CountryCode
        {
            get { return xonline.common.utilities.CountryDictionary.CountryCode(countryId); }
        }
        public DateTime BirthDate
        {
            get { return birthdate; }
        }
        public ulong MachinePuid
        {
            get { return machinePuid; }
        }
        public byte MsftOptIn
        {
            get { return msSpam; }
        }
        public byte PartnerOptIn
        {
            get { return partnerSpam; }
        }
    }

    public class CreateAccountResponse : XRLObject2
    {
        public ulong puid;

        [WireInfo(ArraySize=(int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] key;

        [WireInfo(ArraySize=(int)XOn.XONLINE_USERDOMAIN_SIZE)]
        public string domain;

        [WireInfo(ArraySize=(int)XOn.XONLINE_REALM_NAME_SIZE)]
        public string realm;
    }

    public class GetSubscriptionInfoRequest : XRLObject2
    {
        public ulong userPuid;

        public override string Xrl
        {
            get { return "/xuacs/GetSubscriptionInfo.ashx"; }
        }
    }

    public class GetSubscriptionInfoResponse : XRLObject2
    {
        public byte subscriptionLengthInMonths;

        public uint paymentTypeId;
    }

    public class GetSubscriptionStatusRequest : XRLObject2
    {
        public ulong userPuid;

        public ulong machinePuid;

        public uint  titleId;

        public uint  serviceId;

        public uint  languageId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/GetSubscriptionStatus.ashx"; }
        }
    }

    public class GetSubscriptionStatusResponse : XRLObject2
    {
        public ulong currentOfferId;

        public byte  currentOfferStatus;

        public byte  anniversaryDate;

        public DateTime startDate;

        public DateTime endDate;

        public uint  renewalGracePeriod;

        public byte  renewalStatus;

        public ulong renewalOfferId;

        //
        // + Details object for current offer
        //
        public GetSubscriptionStatusDetailsData currentOfferDetails;

        //
        // + Details object for renewal offer if applicable
        //

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/GetSubscriptionStatus.ashx"; }
        }
    }

    public class GetSubscriptionStatusDetailsData : XRLObject2
    {
        public uint   wholePart;

        public byte   fractionalPart;

        public byte   currencyFormat;

        [WireInfo(ArraySize=3)]
        public string ISOCode;

        public uint   offeringDetails;
    }

    // requests that contain account recovery type information should
    // implement this so the common comparison routine can be used.
    public interface IRecoveryRequest
    {
        string PostalCode { get; }
        string PhonePrefix { get; }
        string PhoneNumber { get; }
        string PhoneExtension { get; }
        string CardHolder { get; }
        string CardNumber { get; }
    }

    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class LinkWebAccountRequest : XRLObject2, IRecoveryRequest
    {
        [WireInfo(Min=1)]
        public uint credentialType;

        [WireInfo(Min=1, Max=128)] // TODO: fix the max value
        public ushort webIdLen;

        [WireInfo(SizeParam="webIdLen")]
        public byte[] webId;

        public byte webIdIsOwner;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_PREFIX_SIZE)]
        public ushort phonePrefixLength;

        [WireInfo(SizeParam="phonePrefixLength")]
        public string phonePrefix;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_NUMBER_SIZE)]
        public ushort phoneNumberLength;

        [WireInfo(SizeParam="phoneNumberLength")]
        public string phoneNumber;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_EXTENSION_SIZE)]
        public ushort phoneExtensionLength;

        [WireInfo(SizeParam="phoneExtensionLength")]
        public string phoneExtension;

        [WireInfo(Min=0, Max=XOn.MAX_POSTALCODE_SIZE)]
        public ushort postalCodeLength;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NAME_SIZE)]
        public ushort cardHolderLength;

        [WireInfo(SizeParam="cardHolderLength")]
        public string cardHolder;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NUMBER_SIZE)]
        public ushort cardNumberLength;

        [WireInfo(SizeParam="cardNumberLength", MaskString=true)]
        public string cardNumber;


        // IRecoveryRequest properties
        public string PostalCode
        {
            get { return postalCode; }
        }
        public string PhonePrefix
        {
            get { return phonePrefix; }
        }
        public string PhoneNumber
        {
            get { return phoneNumber; }
        }
        public string PhoneExtension
        {
            get { return phoneExtension; }
        }
        public string CardHolder
        {
            get { return cardHolder; }
        }
        public string CardNumber
        {
            get { return cardNumber; }
        }

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/LinkWebAccount.ashx"; }
        }
    }

    public class LinkWebAccountResponse : XRLObject2
    {
        public ulong userPuid;

        public ulong ownerPuid;

        public ulong oldUserWebPuid;

        public ulong oldOwnerWebPuid;
    }

    public class RenewSubscriptionRequest : XRLObject2
    {
        public ulong    userPuid;

        public ulong    machinePuid;

        public uint     titleId;

        public ulong    offerId;

        [WireInfo(Min=0, Max=XOn.ACTIVATION_CODE_LENGTH)]
        public ushort   voucherLength;

        [WireInfo(SizeParam="voucherLength")]
        public string   voucher;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/RenewSubscription.ashx"; }
        }
    }

    public class ReserveNameRequest : XRLObject2
    {
        public ulong machinePuid;

        public byte countryId;

        [WireInfo(Max=64)]
        public ushort maxSuggestedNames;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength  = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        public override string Xrl
        {
            get { return "/xuacs/ReserveName.ashx"; }
        }
    }

    public class ReserveNameSuggestedName : XRLObject2
    {
        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort nameLength;

        [WireInfo(SizeParam="nameLength")]
        public string name;
    }

    public class ReserveNameResponse : XRLObject2
    {
        [WireInfo(Max=64)]
        public ushort nameCount;

        [WireInfo(SizeParam="nameCount")]
        public ReserveNameSuggestedName[] names;
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class RestoreAccountRequest : XRLObject2, IRecoveryRequest
    {
        public ulong machinePuid;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_PREFIX_SIZE)]
        public ushort phonePrefixLength;

        [WireInfo(SizeParam="phonePrefixLength")]
        public string phonePrefix;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_NUMBER_SIZE)]
        public ushort phoneNumberLength;

        [WireInfo(SizeParam="phoneNumberLength")]
        public string phoneNumber;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_EXTENSION_SIZE)]
        public ushort phoneExtensionLength;

        [WireInfo(SizeParam="phoneExtensionLength")]
        public string phoneExtension;

        [WireInfo(Min=0, Max=XOn.MAX_POSTALCODE_SIZE)]
        public ushort postalCodeLength;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NAME_SIZE)]
        public ushort cardHolderLength;

        [WireInfo(SizeParam="cardHolderLength")]
        public string cardHolder;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NUMBER_SIZE)]
        public ushort cardNumberLength;

        [WireInfo(SizeParam="cardNumberLength", MaskString=true)]
        public string cardNumber;

        // IRecoveryRequest properties
        public string PostalCode
        {
            get { return postalCode; }
        }
        public string PhonePrefix
        {
            get { return phonePrefix; }
        }
        public string PhoneNumber
        {
            get { return phoneNumber; }
        }
        public string PhoneExtension
        {
            get { return phoneExtension; }
        }
        public string CardHolder
        {
            get { return cardHolder; }
        }
        public string CardNumber
        {
            get { return cardNumber; }
        }

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/RestoreAccount.ashx"; }
        }
    }

    public class RestoreAccountResponse : XRLObject2
    {
        public ulong userPuid;

        [WireInfo(ArraySize=(int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] key;

        [WireInfo(ArraySize=(int)XOn.XONLINE_USERDOMAIN_SIZE)]
        public string domain;

        [WireInfo(ArraySize=(int)XOn.XONLINE_REALM_NAME_SIZE)]
        public string realm;
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class SetPaymentInfoRequest : XRLObject2
    {
        public ulong userPuid;

        [WireInfo(ArraySize=XOn.ACCOUNT_PIN_LENGTH, MaskString=true)]
        public byte[] accountPin;

        public byte countryId;

        public byte cardTypeId;

        [WireInfo(MaskString=true)]
        public DateTime cardExpiration;

        public byte msSpam;

        public byte partnerSpam;

        [WireInfo(Min=1, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=1, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        [WireInfo(Min=1, Max=XOn.MAX_STREET_SIZE*XOn.UTF8_MULT)]
        public ushort street1Length;

        [WireInfo(SizeParam="street1Length")]
        public string street1;

        [WireInfo(Min=0, Max=XOn.MAX_STREET_SIZE*XOn.UTF8_MULT)]
        public ushort street2Length;

        [WireInfo(SizeParam="street2Length")]
        public string street2;

        [WireInfo(Min=0, Max=XOn.MAX_DISTRICT_SIZE*XOn.UTF8_MULT)]
        public ushort districtLength;

        [WireInfo(SizeParam="districtLength")]
        public string district;

        [WireInfo(Min=1, Max=XOn.MAX_CITY_SIZE*XOn.UTF8_MULT)]
        public ushort cityLength;

        [WireInfo(SizeParam="cityLength")]
        public string city;

        [WireInfo(Min=0, Max=XOn.MAX_STATE_SIZE*XOn.UTF8_MULT)]
        public ushort stateLength;

        [WireInfo(SizeParam="stateLength")]
        public string state;

        [WireInfo(Min=0, Max=XOn.MAX_POSTALCODE_SIZE*XOn.UTF8_MULT)]
        public ushort postalCodeLength;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode;

        [WireInfo(Min=1, Max=XOn.MAX_PHONE_PREFIX_SIZE*XOn.UTF8_MULT)]
        public ushort phonePrefixLength;

        [WireInfo(SizeParam="phonePrefixLength")]
        public string phonePrefix;

        [WireInfo(Min=1, Max=XOn.MAX_PHONE_NUMBER_SIZE*XOn.UTF8_MULT)]
        public ushort phoneNumberLength;

        [WireInfo(SizeParam="phoneNumberLength")]
        public string phoneNumber;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_EXTENSION_SIZE*XOn.UTF8_MULT)]
        public ushort phoneExtensionLength;

        [WireInfo(SizeParam="phoneExtensionLength")]
        public string phoneExtension;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NAME_SIZE*XOn.UTF8_MULT)]
        public ushort cardHolderLength;

        [WireInfo(SizeParam="cardHolderLength")]
        public string cardHolder;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NUMBER_SIZE*XOn.UTF8_MULT)]
        public ushort cardNumberLength;

        [WireInfo(SizeParam="cardNumberLength", MaskString=true)]
        public string cardNumber;

        [WireInfo(Min=1, Max=XOn.MAX_EMAIL_SIZE)]
        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        [WireInfo(Min=0, Max=XOn.MAX_BANK_CODE_SIZE*XOn.UTF8_MULT)]
        public ushort bankCodeLength;

        [WireInfo(SizeParam="bankCodeLength")]
        public string bankCode;

        [WireInfo(Min=0, Max=XOn.MAX_BRANCH_CODE_SIZE*XOn.UTF8_MULT)]
        public ushort branchCodeLength;

        [WireInfo(SizeParam="branchCodeLength")]
        public string branchCode;

        [WireInfo(Min=0, Max=XOn.MAX_CHECK_DIGITS_SIZE)]
        public ushort checkDigitsLength;

        [WireInfo(SizeParam="checkDigitsLength", MaskString=true)]
        public string checkDigits;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/SetPaymentInfo.ashx"; }
        }
    }

    public class SetUserAccountStatusRequest : XRLObject2
    {
        public ulong puid           = 0;

        public int newTermsOfService = 0;

        public int forceNameChangeRequired = 0;

        public DateTime suspendedUntil = DateTime.Now;

        public ushort totalDaysSuspended = 0;

        public DateTime voiceBannedUntil = DateTime.Now;

        public ushort totalDaysVoiceBanned = 0;

        public uint billingAccountStatus = 0;

        public uint resetPassword = 0;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/SetUserAccountStatus.ashx"; }
        }
    }

    public class TroubleshootAccountRequest : XRLObject2
    {
        public ulong userPuid;

        public ulong machinePuid;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/TroubleshootAccount.ashx"; }
        }
    }

    public class TroubleshootAccountResponse : XRLObject2
    {
        public int newTOS;

        public int nameChangeRequired;

        public DateTime suspendedUntil = DateTime.UtcNow;

        public ushort totalDaysSuspended;

        public DateTime voiceBannedUntil = DateTime.UtcNow;

        public ushort totalDaysVoiceBanned;

        public HResult billingHR;
    }

    public class VerifyBillingPinRequest : XRLObject2
    {
        public ulong  userPuid;

        [WireInfo(ArraySize=XOn.ACCOUNT_PIN_LENGTH, MaskString=true)]
        public byte[] accountPin;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/VerifyBillingPIN.ashx"; }
        }
    }

    public class VerifyVoucherRequest : XRLObject2
    {
        public byte countryId;

        public ushort voucherLength;

        [WireInfo(SizeParam="voucherLength")]
        public string voucher;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/VerifyVoucherGetOffer.ashx"; }
        }
    }

    public class VerifyVoucherResponse : XRLObject2
    {
        public ulong offerId;
    }

    public class SetUserSettingsRequest : XRLObject2
    {
        public ulong    userPuid           =0;        // user we're talking about

        public ushort   userFlags          =0;        // the new user flags

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/SetUserSettings.ashx"; }
        }
    }

    public class SetUserSettings2Request : XRLObject2
    {
        public ulong    userPuid           =0;        // user we're talking about

        public ushort   tier               =0;        // the new tier of the user

        public ushort   userFlags          =0;        // the new user flags

        [WireInfo(ArraySize=XOn.PRIVILEGE_DWORD_LENGTH)]
        public uint[]   userPrivileges;               // the new user privileges

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/SetUserSettings2.ashx"; }
        }
    }

    public class XeGetPointsBalanceRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public override string Xrl
        {
            get
            {
                return "/xuacs/XeGetPointsBalance.ashx";
            }
        }
    }

    public class XeGetPointsBalanceResponse : XRLObject2WithFlags
    {
        static byte AboveLowBalance             = 0x01;

        public XeGetPointsBalanceResponse()
        {
            responseFlags = 0;
        }

        public uint pointsBalance;

        public byte dmpAccountStatus;

        public byte responseFlags; // aboveLowBalance

        public bool aboveLowBalance
        {
            get
            {
                return IsFlagSet(AboveLowBalance, responseFlags);
            }
            set
            {
                SetFlag(AboveLowBalance, value, ref responseFlags);
            }
        }
    }

    public class PassportToken : WireData
    {
        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedPuid;   // Passport session ticket.

        public static implicit operator byte[] (PassportToken value)
        {
            return value.signedPuid;
        }

        public static implicit operator PassportToken(byte[] value)
        {
            PassportToken t = new PassportToken();
            t.signedPuid = value;
            return t;
        }
    }

    public class UpdateParentalControlsRequest : XRLObject2
    {
        public ulong    userPuid           =0;        // user we're talking about

        [WireInfo(ArraySize=XOn.PRIVILEGE_DWORD_LENGTH)]
        public uint[]   userGrantPrivileges;               // the user granted privileges

        [WireInfo(ArraySize=XOn.PRIVILEGE_DWORD_LENGTH)]
        public uint[]   userRestrictPrivileges;               // the user restricted privileges

        [WireInfo(Min=1, Max=XOn.XONLINE_MAX_PARENTAL_CONTROLS_SOURCE_LENGTH*XOn.UTF8_MULT)]
        public ushort sourceLength = 0;

        [WireInfo(SizeParam="sourceLength", NullTerminate=true)]
        public string source;

        [WireInfo(MinSchemaVersion = "6.3")]
        public ushort tokenLength = 0;

        [WireInfo(MinSchemaVersion = "6.3", SizeParam = "tokenLength", NullTerminate = false)]
        public PassportToken[] tokens = null;

        [WireInfo(MinSchemaVersion = "6.5")]
        public uint setProfilePermissionEntries = 0;

        [WireInfo(MinSchemaVersion = "6.5")]
        public uint clearProfilePermissionEntries = 0;
        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeUpdateParentalControls.ashx"; }
        }
    }

    public class GetParentalControlsRequest : XRLObject2
    {
        public Puid requestorPuid = 0;    // user making the request.

        public Puid userPuid = 0;        // user we're talking about.

        public override string Xrl
        {
            get { return "/xuacs/GetParentalControls.ashx"; }
        }
    }

    public class GetParentalControlsResponse : XRLObject2
    {
        [WireInfo(ArraySize = XOn.PRIVILEGE_DWORD_LENGTH)]
        public uint[]       userGrantPrivileges;               // the user granted privileges

        [WireInfo(ArraySize = XOn.PRIVILEGE_DWORD_LENGTH)]
        public uint[]       userRestrictPrivileges;               // the user restricted privileges
    }

    public class GetUserBillingNotificationsRequest : XRLObject2
    {
        public const byte FlagUnreadNotifications   = 0x0001; // set bit 0 for notifications with read flag to be returned
        public const byte FlagTransientNotification = 0x0002; // set bit 1 for notification to be treated as unread until expiration date

        [WireInfo(HexString=true)]
        public       ulong    userPuid;         // userid to read notifications for

        public       byte     flags;            // Set bit 0 for all messages

        public       DateTime notificationDate; // notifications before this date

        public override string Xrl
        {
            get { return "/xuacs/GetUserBillingNotifications.ashx"; }
        }
    }

    public class UserBillingNotification : WireData
    {
        public const int      notificationIdSubscriptionExpiration = 10020;
        public const int      notificationIdCreditCardDecline      = 20010;

        public       DateTime notificationDate = DateTime.MinValue; // Date of arrival

        public       int      isReadNotification = 0;

        // Protocol only supports
        public       int      notificationId = 0;

        // Valid for notificationId = CreditCardDecline only
        public       int      creditCardType = 0; // maps to XONLINE_CREDIT_CARD_TYPE in xondefs.h

        // Valid for notificationId = CreditCardDecline only
        public       ushort   accountNumberLastFour = 0;

        // Valid for notificationId = CreditCardDecline only
        public       int      declineReasonId = 0; // maps to XONLINE_CREDIT_CARD_DECLINE_TYPE in xondefs.h

        // Valid for notificationId = SubscriptionExpiration
        public       DateTime subscriptionExpirationDate;

        // Valid for notificationId = SubscriptionExpiration
        [WireInfo(MinSchemaVersion = "6.2")]
        public       bool     subscriptionIsTrial;

        // Valid for notificationId = SubscriptionExpiration
        [WireInfo(MinSchemaVersion = "6.2", HexString=true)]
        public       uint     subscriptionTitleId;

        // Valid for notificationId = SubscriptionExpiration
        [WireInfo(MinSchemaVersion = "6.2")]
        public       Guid     subscriptionOfferId;
    }

    public class GetUserBillingNotificationsResponse : XRLObject2
    {
        public const int      MAX_COUNT = 10;

        [WireInfo(Max=MAX_COUNT)]
        public ushort userBillingNotificationsCount;

        [WireInfo(SizeParam="userBillingNotificationsCount")]
        public UserBillingNotification[] userBillingNotifications;
    }

    public class XeGetUserSubscriptionDetailsRequest : XRLObject2
    {
        public ulong userPuid;

        public ulong machinePuid;

        [WireInfo(HexString=true)]
        public ulong offerId;

        public ushort instanceIdLength = 0;

        [WireInfo(SizeParam="instanceIdLength")]
        public string instanceId = "";

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeGetUserSubscriptionDetails.ashx"; }
        }
    }

    public class UserSubscriptionDetailsData : XRLObject2
    {
        public const ushort maxFormattedPriceLength = 20;

        public uint wholePart;

        public byte fractionalPart;

        [WireInfo(HexString=true)]
        public byte currencyFormat;

        [WireInfo(Min=0, Max=3)]
        public ushort isoCodeLength;

        [WireInfo(SizeParam="isoCodeLength")]
        public string isoCode;

        [WireInfo(Min=0, Max=maxFormattedPriceLength)]
        public ushort formattedPriceLength;

        [WireInfo(SizeParam="formattedPriceLength")]
        public string formattedPrice;

        [WireInfo(HexString=true)]
        public uint offeringDetails;
    }

    public class XeGetUserSubscriptionDetailsResponse : XRLObject2
    {
        public const ushort maxDescriptionLength = 500;
        public const ushort maxFriendlyNameLength = 50;

        public ushort subscriptionIdLength = 0;

        [WireInfo(SizeParam="subscriptionIdLength")]
        public string subscriptionId = "";

        [WireInfo(Max=maxDescriptionLength)]
        public ushort descriptionLength = 0;

        [WireInfo(SizeParam="descriptionLength")]
        public string description = "";

        public byte currentOfferStatus;

        [WireInfo(MinSchemaVersion = "4.3")]
        public bool delayedCancel;

        [WireInfo(Max=(maxFriendlyNameLength * 2))]
        public ushort friendlyNameLength = 0;

        [WireInfo(SizeParam="friendlyNameLength")]
        public string friendlyName = "";

        public byte anniversaryDate;

        public DateTime purchaseDate = DateTime.UtcNow;

        public DateTime activationDate = DateTime.UtcNow;

        public DateTime endDate = DateTime.UtcNow;

        public byte hasViolations;

        public uint renewalGracePeriod;

        public byte renewalOfferStatus;

        [WireInfo(HexString=true)]
        public ulong renewalOfferId;

        public UserSubscriptionDetailsData currentOfferDetails;

        public UserSubscriptionDetailsData renewalOfferDetails;

        public PaymentInstrumentInfoEx paymentInstrument;

    }

    public class EnumFamilyMembersRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public Puid userPuid = 0;

        // When the user is logged in, the passport token can be NULL and this API will validate
        // identity through the SG. In cases where a user isn't logged in (such as account recovery),
        // the caller can pass a passport token to be used instead.
        [WireInfo(MinSchemaVersion = "7.0", Max=1)]
        public ushort userPassportTokenLength = 0;

        [WireInfo(MinSchemaVersion = "7.0", SizeParam = "userPassportTokenLength", NullTerminate = false)]
        public PassportToken[] userPassportToken = null;

        public override string Xrl
        {
            get { return "/xuacs/EnumFamilyMembers.ashx"; }
        }
    }

    public class FamilyDefs
    {
        public const ushort FAMILY_OWNER = 0x0001;
        public const ushort FAMILY_SUBSCRIPTION_GOLD = 0x0002;
    }

    public class FamilyMember : WireData
    {
        [WireInfo(HexString = true)]
        public Puid userPuid;

        public ushort userFlags = 0; // FAMILY_* flags from FamilyDefs

        [WireInfo(ArraySize = PresDefs.XONLINE_GAMERTAG_SIZE)]
        public string gamertag;
    }

    public class EnumFamilyMembersResponse : XRLObject2
    {
        // 25 dependents + owner
        public const ushort MAX_FAMILY_MEMBERS = 26;

        [WireInfo(Max = MAX_FAMILY_MEMBERS)]
        public ushort numFamilyMembers;

        [WireInfo(SizeParam = "numFamilyMembers")]
        public FamilyMember[] familyMembers;
    }

    public class AddDependentRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public Puid machinePuid = 0;

        // The xuid of the new dependent
        [WireInfo(HexString = true)]
        public Puid userPuid = 0;

        // The xuid of the new owner. This user must be signed in.
        [WireInfo(HexString = true)]
        public Puid ownerPuid = 0;

        // The passport credentials of the old owner. If the dependent was an independent
        // account, this will be the passport of the dependent. If the dependent was owned
        // by another account and is being transferred, this is the old owner.
        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedOldOwnerPassportPuid;

        public override string Xrl
        {
            get { return "/xuacs/AddDependent.ashx"; }
        }
    }

    public class RemoveDependentRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public Puid machinePuid = 0;

        // The xuid of the dependent being removed from the family
        [WireInfo(HexString = true)]
        public Puid userPuid = 0;

        // The xuid of the owner performing the remove operation
        [WireInfo(HexString = true)]
        public Puid ownerPuid = 0;

        public override string Xrl
        {
            get { return "/xuacs/RemoveDependent.ashx"; }
        }
    }

    // If the user is the owner of a family and has a family gold subscription,
    // this allows the user to see how many users can be granted gold rights
    // as partof the subscription and how many gold seats are available to be assigned.
    // This is used by the family center application to display information about the
    // user's subscription.
    public class FamilySubscriptionGoldUserCountRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public Puid userPuid = 0;

        public override string Xrl
        {
            get { return "/xuacs/FamilySubscriptionGoldUserCount.ashx"; }
        }
    }

    public class FamilySubscriptionGoldUserCountResponse : XRLObject2
    {
        // The total number of gold seats that are provided by the family subscription of the
        // requesting user, including the one provided to the subscriber.
        // If the requesting user does not have an active family subscription, or is a dependent
        // that had been assigned a gold seat in a family subscription, this will be 0.
        public ushort total;

        // The number of gold seats for the requesting user's family subscription that have not
        // had dependents assigned to them
        public ushort available;
    }

    public class FamilySubscriptionAssignGoldUserRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public Puid machinePuid = 0;

        // The xuid of the dependent being assigned a gold seat
        [WireInfo(HexString = true)]
        public Puid userPuid = 0;

        // The xuid of the owner performing the assignment operation
        [WireInfo(HexString = true)]
        public Puid ownerPuid = 0;

        public override string Xrl
        {
            get { return "/xuacs/FamilySubscriptionAssignGoldUser.ashx"; }
        }
    }

    public class FamilySubscriptionRemoveGoldUserRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public Puid machinePuid = 0;

        // The xuid of the dependent being removed from a gold seat
        [WireInfo(HexString = true)]
        public Puid userPuid = 0;

        // The xuid of the owner performing the remove operation
        [WireInfo(HexString = true)]
        public Puid ownerPuid = 0;

        public override string Xrl
        {
            get { return "/xuacs/FamilySubscriptionRemoveGoldUser.ashx"; }
        }
    }

    /// <summary>
    /// Request class for Preview Merge subscription. Takes primary and secondary puid
    /// </summary>
    public class PreviewMergeSubscriptionRequest : XRLObject2
    {
        // The xuid of the primary family gold primary user
        [WireInfo(HexString = true)]
        public Puid primaryUserPuid = 0;

        // The xuid of the secondary  gold  user whose subscription is being merged with Primary
        [WireInfo(HexString = true)]
        public Puid secondaryUserPuid = 0;

        // 0 if there's no owner passport token, 1 if there is.
        // a passport token is required if the secondary user is not a
        // dependent of the primary user.
        [WireInfo(Max = 1)]
        public ushort ownerPassportTokenLength;

        // The passport token of the secondary's owner
        [WireInfo(SizeParam = "ownerPassportTokenLength")]
        public PassportToken[] ownerPassportToken;

        public override string Xrl
        {
            get { return "/xuacs/PreviewMergeSubscription.ashx"; }
        }
    }

    /// <summary>
    /// Response for PreviewMergeSubscription Request
    /// </summary>
    public class PreviewMergeSubscriptionResponse : XRLObject2
    {
        //Months transfered to Family gold subscription
        public uint monthsTransferred;

        //Next charge data for family gold subscription
        public DateTime nextChargeDate;
    }

    public class GetParentalControlGroupTemplatesRequest : XRLObject2
    {
        // The user making the request
        public ulong userPuid = 0;

        public override string Xrl
        {
            get { return "/xuacs/GetParentalControlGroupTemplates.ashx"; }
        }
    }

    // Information about a single privilege/permission setting in a template definition
    public class ParentalControlGroupSettingDefinition : WireData
    {
        public uint settingId;
        public bool enabled;
    }

    public class ParentalControlGroupTemplateDefinition : WireData
    {
        public const byte MaxSettings = 32;

        public int parentalControlGroupId;

        // The default privileges settings for the template
        [WireInfo(Max = MaxSettings)]
        public byte privilegeCount;

        [WireInfo(SizeParam = "privilegeCount")]
        public ParentalControlGroupSettingDefinition[] privileges;

        // The default profile permission settings for the template
        [WireInfo(Max = MaxSettings)]
        public byte permissionCount;

        [WireInfo(SizeParam = "permissionCount")]
        public ParentalControlGroupSettingDefinition[] permissions;
    }

    public class GetParentalControlGroupTemplatesResponse : XRLObject2
    {
        [WireInfo(ArraySize = 3)]
        public ParentalControlGroupTemplateDefinition[] templates;
    }

    public class UserParentalControlGroup : WireData
    {
        [WireInfo(HexString = true)]
        public Puid userPuid;

        // The id of the user's parental control group
        public int parentalControlGroupId;

        // true if any privileges/permissions have been changed
        // from the template value
        public bool custom;
    }

    public class GetUserParentalControlGroupRequest : XRLObject2
    {
        // 25 dependents + owner
        public const ushort MaxFamilyMembers = 26;

        public const byte MaxSettings = 32;

        // Must be signed in and must either be the target user (you can alway
        // see your own parental control group) or must be the owner of the target.
        public Puid requestorPuid;

        // The users whose parental control group are being requested
        [WireInfo(Max = MaxFamilyMembers)]
        public byte userPuidCount;

        [WireInfo(SizeParam = "userPuidCount")]
        public Puid[] userPuids;

        public override string Xrl
        {
            get { return "/xuacs/GetUserParentalControlGroup.ashx"; }
        }
    }

    public class GetUserParentalControlGroupResponse : XRLObject2
    {
        // A list of the requested users and their effective parental control group.
        // Any requested user that the requestor doesn't have permission to see will
        // not be in the result array.
        [WireInfo(Max = GetUserParentalControlGroupRequest.MaxFamilyMembers)]
        public byte userCount;

        [WireInfo(SizeParam = "userCount")]
        public UserParentalControlGroup[] users;
    }

    public class UpdateParentalControlGroupRequest : XRLObject2
    {
        // The target user to update
        public ulong userPuid = 0;

        // The new parental control group to set on the target user.
        public int parentalControlGroupId;

        // 0 if there's no owner passport token, 1 if there is.
        [WireInfo(Max = 1)]
        public ushort ownerPassportLength;

        // The passport token of the target's owner
        [WireInfo(SizeParam = "ownerPassportLength")]
        public PassportToken[] ownerPassport;

        public override string Xrl
        {
            get { return "/xuacs/UpdateParentalControlGroup.ashx"; }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\passport\PassportAddProofRequest.cs ===
//------------------------------------------------------------ 
// Copyright (c) Microsoft Corporation. All rights reserved. 
//------------------------------------------------------------ 

using xonline.common.service;

namespace xonline.common.protocol.passport
{
    public class PassportAddProofRequest : XRLObject2
    {
        /// <summary>
        /// The Xuid of the account that is attempting to perform the operation.
        /// Since the console can have multiple users attached, need to distinguish
        /// which user is making the request.
        /// </summary>
        public Puid userPuid;

        /// <summary>
        /// The console where the user make the request.
        /// </summary>
        public Puid machinePuid;

        /// <summary>
        /// Standard Xbox protocol element to state that this operation should be
        /// password verified.  It represents the signed passport puid of the account
        /// being accessed.
        /// </summary>
        public PassportToken sessionToken;

        /// <summary>
        /// The strong proof data
        /// </summary>
        public ProofData proofData;

        public override string Xrl
        {
            get
            {
                return "/xuacs/PassportAddProof.ashx";
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\xsigprot.cs ===
/*==========================================================================
 *
 *  XSigProt.cs -- This module defines the wire protocol for Signature server
 *
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

using System;
using System.IO;
using System.Xml.Serialization;

using xonline.common.service;
namespace xonline.common.protocol
{
    public class XSigAuthData : WireData
    {
        public uint        _titleID;
        public uint        _titleVersion;
        public ulong       _XboxID;
        public ulong       _userID1;
        public ulong       _userID2;
        public ulong       _userID3;
        public ulong      _userID4;
        static public int GetSizeInBytes()
        {
            return 48;
        }
    };

    // ------------------------------------------
    //      SignOnBehalf request
    // ------------------------------------------
    public class XSigSignOnBehalfRequest : XRLObject2
    {
        public const int XONLINE_XSIG_DIGEST_SIZE=20;
        public uint        _serviceId;

        [WireInfo(ArraySize=XONLINE_XSIG_DIGEST_SIZE)]
        public byte[]  _digest;

        public XSigAuthData  _authData;

        static public int GetSizeInBytes()
        {
            return 4+XSigAuthData.GetSizeInBytes()+XSigSignOnBehalfRequest.XONLINE_XSIG_DIGEST_SIZE;
        }

        public virtual new string ToString()
        {
            string szSigData = _serviceId.ToString("X8") + "|"
                +(ByteConvert.ToString(_digest))+ "|"
                + _authData._titleID.ToString("X8") + "|"
                + _authData._titleVersion.ToString("X8") + "|"
                + _authData._XboxID.ToString("X16") + "|"
                + _authData._userID1.ToString("X16") + "|"
                + _authData._userID2.ToString("X16") + "|"
                + _authData._userID3.ToString("X16") + "|"
                + _authData._userID4.ToString("X16");

            return szSigData;
        }

        public override string Xrl
        {
            get { return "/xsig/SignOnBehalf.ashx"; }
        }
    }

    // ------------------------------------------
    //      GetSigningKey request
    // ------------------------------------------
    //
    // None: This request type takes no input data.


    public class XSigSignature : XRLObject2
    {
        public const int XONLINE_XSIG_RESERVED_SIZE = 16;
        public const int XONLINE_XSIG_SIGNATURE_KEY_SIZE = 20;
        public const short XONLINE_XSIG_SIGNATURE_VERSION = 1;

        public short       _signatureVersion = XONLINE_XSIG_SIGNATURE_VERSION;
        public short       _keyVersion;
        public uint        _serviceId = 0;
        public long        _timeStamp ;
        public XSigAuthData       _authData;
        [WireInfo(ArraySize=XONLINE_XSIG_RESERVED_SIZE)]
        public byte[]  _reserved;
        [WireInfo(ArraySize=XONLINE_XSIG_SIGNATURE_KEY_SIZE)]
        public byte[]  _signature;

        [WireInfo(Serialize=false)]
        public ulong _liNonce = 0;

        static public int GetSizeInBytes()
        {
            return 16 + XSigAuthData.GetSizeInBytes() + XONLINE_XSIG_RESERVED_SIZE + XONLINE_XSIG_SIGNATURE_KEY_SIZE;
        }

        // NOTE: Since WireData overloads operator byte[], casting this object to a byte[] will allow you to
        // get the signature for use as a binary array.

        public virtual new string ToString()
        {
            string szSigData;

            if ( this._signature == null )
            {
                szSigData = this._signatureVersion.ToString("X4")   + "|" +
                    ((int)   this._keyVersion).ToString("X4")       + "|" +
                    ((uint) this._serviceId).ToString("X8")         + "|" +
                    (this._timeStamp).ToString("X16")               + "|" +
                    (this._liNonce).ToString("X16")                 + "|" +
                    ((int)   this._authData._titleID).ToString("X8")          + "|" +
                    ((int)   this._authData._titleVersion).ToString("X8")     + "|" +
                    ((ulong) this._authData._XboxID).ToString("X16")          + "|" +
                    ((ulong) this._authData._userID1).ToString("X16")         + "|" +
                    ((ulong) this._authData._userID2).ToString("X16")         + "|" +
                    ((ulong) this._authData._userID3).ToString("X16")         + "|" +
                    ((ulong) this._authData._userID4).ToString("X16")         + "|" +
                    "null";
            }
            else
            {
                szSigData = this._signatureVersion.ToString("X4")   + "|" +
                    ((int)   this._keyVersion).ToString("X4")       + "|" +
                    ((uint) this._serviceId).ToString("X8")         + "|" +
                    (this._timeStamp).ToString("X16")               + "|" +
                    (this._liNonce).ToString("X16")                 + "|" +
                    ((int)   this._authData._titleID).ToString("X8")          + "|" +
                    ((int)   this._authData._titleVersion).ToString("X8")     + "|" +
                    ((ulong) this._authData._XboxID).ToString("X16")          + "|" +
                    ((ulong) this._authData._userID1).ToString("X16")         + "|" +
                    ((ulong) this._authData._userID2).ToString("X16")         + "|" +
                    ((ulong) this._authData._userID3).ToString("X16")         + "|" +
                    ((ulong) this._authData._userID4).ToString("X16")         + "|" +
                    (ByteConvert.ToString(this._signature));
            }

            return szSigData;
        }

    };

    // ------------------------------------------
    //      SignOnBehalf response
    // ------------------------------------------
    public class XSigSignOnBehalfResponse : XRLObject2
    {
        public uint          _hresult;
        public XSigSignature _signature;
    }

    // ------------------------------------------
    //      XSigVerifySignatureRequest request
    // ------------------------------------------
    public class XSigVerifySignatureRequest : XRLObject2
    {
        [WireInfo(ArraySize=XSigSignOnBehalfRequest.XONLINE_XSIG_DIGEST_SIZE)]
        public byte[]  _digest;
        public XSigSignature  _signature;

        static public int GetSizeInBytes()
        {
            return XSigSignature.GetSizeInBytes()+XSigSignOnBehalfRequest.XONLINE_XSIG_DIGEST_SIZE;
        }

        public override string Xrl
        {
            get { return "/xsig/VerifySignature.ashx"; }
        }
    }

    // ------------------------------------------
    //      XSigVerifySignatureResponse
    // ------------------------------------------
    public class XSigVerifySignatureResponse : XRLObject2
    {
         public uint      _hresult;
    }

    // ------------------------------------------
    //      CheckRevocation
    // ------------------------------------------

    public class ContentTuple : WireData
    {
        public uint TitleId;
        public uint TitleVersion;
        public ulong ConsolePuid;

        [WireInfo(ArraySize=5)]
        public byte[] ConsoleId = new byte[5];

        [WireInfo(ArraySize=4)]
        public ulong[] UserPuid = new ulong[4];

        [WireInfo(ArraySize=20)]
        public byte[] Digest = new byte[20];

        public override WireData ReadStream(BinaryReader reader)
        {
            TitleId = reader.ReadUInt32();
            TitleVersion = reader.ReadUInt32();
            ConsolePuid = reader.ReadUInt64();

            ConsoleId = reader.ReadBytes(5);
            if (ConsoleId.Length != 5)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.COMMON_CODE_177, "failed to read 5 bytes for ConsoleID!");
            }


            for (int i = 0; i < UserPuid.Length; i++)
                UserPuid[i] = reader.ReadUInt64();

            Digest = reader.ReadBytes(20);
            if (Digest.Length != 20)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.COMMON_CODE_178, "failed to read 20 bytes for Digest!");
            }

            return this;
        }

    }

    public class CheckRevocationRequest : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_SIG_MAX_CONTENT_TUPLES)]
        public uint NumContentTuples = 0;

        [WireInfo(SizeParam="NumContentTuples")]
        public ContentTuple[] Tuples = new ContentTuple[0];

        public override string Xrl
        {
            get { return "/xsig/CheckRevocation.ashx"; }
        }

        public override WireData ReadStream(BinaryReader reader)
        {
            NumContentTuples = reader.ReadUInt32();
            if (NumContentTuples > XOn.XONLINE_SIG_MAX_CONTENT_TUPLES)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.COMMON_CODE_179, "Rquest contained too many Content Tuples!");
            }

            Tuples = new ContentTuple[NumContentTuples];
            for (int i = 0; i < NumContentTuples; i++)
            {
                Tuples[i] = new ContentTuple();
                Tuples[i].ReadStream(reader);
            }

            return this;
        }

    }

    public class CheckRevocationResponse : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_SIG_MAX_CONTENT_TUPLES)]
        public uint NumHrs = 0;

        [WireInfo(SizeParam="NumHrs")]
        public uint[] Hrs = new uint[0];

        public override void WriteStream(BinaryWriter writer)
        {
            writer.Write(Hrs.Length);
            for (int i = 0; i < Hrs.Length; i++)
            {
                writer.Write(Hrs[i]);
            }
        }
    }


    public class XmstvCreateCertificateRequest : XRLObject2
    {
        const int RSAPUB_2048_SIZE = 272;
        public const int SHA1_DIGEST_SIZE = 20;

        public uint Flags;

        [WireInfo(ArraySize=RSAPUB_2048_SIZE)]
        public byte[] AvPubKey;

        [WireInfo(ArraySize=RSAPUB_2048_SIZE)]
        public byte[] NonAvPubKey;

        public ulong KeyNonce;

        [WireInfo(ArraySize=SHA1_DIGEST_SIZE)]
        public byte[] KeyedHash;

        public override string Xrl
        {
            get
            {
                return "/xsig/XmstvCreateCertificate.ashx";
            }
        }
    }


    public class XmstvCreateCertificateResponse : XRLObject2
    {
        public const int MAX_CERT_SIZE = 1500;

        [WireInfo(Min=1, Max=MAX_CERT_SIZE)]
        public ushort AvCertificateSize;

        [WireInfo(SizeParam="AvCertificateSize")]
        public byte[] AvCertificate;

        [WireInfo(Min=1, Max=MAX_CERT_SIZE)]
        public ushort AvSerializedCertificateSize;

        [WireInfo(SizeParam="AvSerializedCertificateSize")]
        public byte[] AvSerializedCertificate;

        [WireInfo(Min=1, Max=MAX_CERT_SIZE)]
        public ushort NonAvCertificateSize;

        [WireInfo(SizeParam="NonAvCertificateSize")]
        public byte[] NonAvCertificate;

        [WireInfo(Min=1, Max=MAX_CERT_SIZE)]
        public ushort NonAvSerializedCertificateSize;

        [WireInfo(SizeParam="NonAvSerializedCertificateSize")]
        public byte[] NonAvSerializedCertificate;
    }


    public class CreateCertificateRequest : XRLObject2
    {
        public const int MAX_APPID_LEN = 64;
        public const int RSAPUB_2048_SIZE = 272;

        [WireInfo(Min = 1, Max = MAX_APPID_LEN)]
        public ushort appIdLen;

        [WireInfo(SizeParam = "appIdLen")]
        public string appId;

        public ulong userPuid;

        [WireInfo(ArraySize = RSAPUB_2048_SIZE)]
        public byte[] PubKey;

        public override string Xrl
        {
            get
            {
                return "/xsig/CreateCertificate.ashx";
            }
        }
    }


    public class CreateCertificateResponse : XRLObject2
    {
        public const int MAX_CERT_SIZE = 1500;

        [WireInfo(Min = 1, Max = MAX_CERT_SIZE)]
        public ushort CertificateSize;

        [WireInfo(SizeParam = "CertificateSize")]
        public byte[] Certificate;

        [WireInfo(Min = 1, Max = MAX_CERT_SIZE)]
        public ushort SerializedCertificateSize;

        [WireInfo(SizeParam = "SerializedCertificateSize")]
        public byte[] SerializedCertificate;
    }

    public class CreateCertificate2Request : XRLObject2
    {
        public const int MAX_APPID_LEN = 64;
        public const int XE_CONSOLE_CERTIFICATE_SIZE = 424;
        public const int CONSOLE_CERTIFICATE_SIGNATURE_SIZE = 256;

        [WireInfo(Min = 1, Max = MAX_APPID_LEN)]
        public ushort appIdLen;

        [WireInfo(SizeParam = "appIdLen")]
        public string appId;

        [WireInfo(ArraySize = XE_CONSOLE_CERTIFICATE_SIZE - CONSOLE_CERTIFICATE_SIGNATURE_SIZE)]
        public byte[] ConsoleCertificate;

        [WireInfo(ArraySize = CONSOLE_CERTIFICATE_SIGNATURE_SIZE)]
        public byte[] Signature;

        public override string Xrl
        {
            get
            {
                return "/xsig/CreateCertificate2.ashx";
            }
        }
    }

    public class XEConsoleCertificate : WireData
    {
        public const int XE_CONSOLE_CERTIFICATE_SIZE = 424;
        public const int CONSOLE_ID_SIZE = 5;
        public const int CONSOLE_CERT_PART_NUMBER_SIZE = 11;
        public const int CONSOLE_CERTIFICATE_RESERVED_SIZE = 4;
        public const int CONSOLE_PUBLIC_KEY_EXPONENT_SIZE = 4;
        public const int CONSOLE_PUBLIC_KEY_MODULUS_SIZE = 128;
        public const int CONSOLE_CERTIFICATE_SIGNATURE_SIZE = 256;

        [WireInfo(Min = 1, Max = XE_CONSOLE_CERTIFICATE_SIZE)]
        public ushort CertSize;             // Size of this structure (424);

        [WireInfo(ArraySize = CONSOLE_ID_SIZE)]
        public byte[] ConsoleId;            // Uniquely ids console

        [WireInfo(ArraySize = CONSOLE_CERT_PART_NUMBER_SIZE)]
        public byte[] ConsolePartNumber;    // Identifies mfg part number

        [WireInfo(ArraySize = CONSOLE_CERTIFICATE_RESERVED_SIZE)]
        public byte[] Reserved;             // Reserved for future use

        public ushort Privileges;           // Privileges for SG

        public uint ConsoleType;            // States whether console is a retail or dev/test kit

        public ulong ManufacturingDate;     // Date of mfg for console

        [WireInfo(ArraySize = CONSOLE_PUBLIC_KEY_EXPONENT_SIZE + CONSOLE_PUBLIC_KEY_MODULUS_SIZE)]
        public byte[] ConsolePublicKey;     // Console's Public Key

        [WireInfo(ArraySize = CONSOLE_CERTIFICATE_SIGNATURE_SIZE)]
        public byte[] Signature;      // RsaSign(MasterKey.Private, CertSize thru ConsolePublicKey)

    }

    public class CreateCertificate2Response : XRLObject2
    {
        public const int MAX_CERT_SIZE = 1500;

        [WireInfo(Min = 1, Max = MAX_CERT_SIZE)]
        public ushort CertificateSize;

        [WireInfo(SizeParam = "CertificateSize")]
        public byte[] Certificate;

        [WireInfo(Min = 1, Max = MAX_CERT_SIZE)]
        public ushort SerializedCertificateSize;

        [WireInfo(SizeParam = "SerializedCertificateSize")]
        public byte[] SerializedCertificate;
    }

    public interface ILicenseApiResponse
    {
        MediaInstanceIdOfferIdPair IdPair { get; set; }
        HResult Hr { get; set; }
    }

    public class MediaInstanceIdOfferIdPair : WireData
    {
        public Guid miid;
        public Guid oid;
    }

    public class MediaLicense : WireData, ILicenseApiResponse
    {
        public MediaInstanceIdOfferIdPair idPair;

        public ushort licenseType;

        public const int LICENSE_BLOCK_MAX_COUNT = 13;

        [XmlIgnoreAttribute]
        [WireInfo(Max=LICENSE_BLOCK_MAX_COUNT)]
        public ushort licenseBlockCount;

        [XmlIgnoreAttribute]
        [WireInfo(SizeParam="licenseBlockCount")]
        public XeGenericBlock[] licenseBlocks;

        [WireInfo(Serialize=false)]
        public byte[] license;

        public HResult hr;

        [XmlIgnoreAttribute]
        public MediaInstanceIdOfferIdPair IdPair { get { return idPair; } set { idPair = value; } }
        [XmlIgnoreAttribute]
        public HResult Hr { get { return hr; } set { hr = value; } }
    }

    public class AcquireMediaLicensesRequest : XRLObject2
    {
        [WireInfo(Min=1)]
        public ushort idPairsLength;

        [WireInfo(SizeParam="idPairsLength")]
        public MediaInstanceIdOfferIdPair[] idPairs;

        public ulong userPuid;

        public const int CLIENT_INFO_BLOCK_MAX_COUNT = 13;

        [WireInfo(Min=1, Max=CLIENT_INFO_BLOCK_MAX_COUNT)]
        public ushort clientInfoBlockCount;

        [WireInfo(SizeParam="clientInfoBlockCount")]
        public XeGenericBlock[] clientInfoBlocks;

        public override string Xrl { get { return "/xsig/AcquireMediaLicenses.ashx"; } }
    }

    public class AcquireMediaLicensesResponse : XRLObject2
    {
        [WireInfo(Min=1)]
        public ushort mediaLicensesLength;

        [WireInfo(SizeParam="mediaLicensesLength")]
        public MediaLicense[] mediaLicenses;
    }


    public class Acknowledgement : WireData, ILicenseApiResponse
    {
        public MediaInstanceIdOfferIdPair idPair;

        public HResult hr;

        [XmlIgnoreAttribute]
        public MediaInstanceIdOfferIdPair IdPair { get { return idPair; } set { idPair = value; } }
        [XmlIgnoreAttribute]
        public HResult Hr { get { return hr; } set { hr = value; } }
    }

    public class AcknowledgeLicensesDeliveryRequest : XRLObject2
    {
        public ulong userPuid;

        [WireInfo(Min=1)]
        public ushort idPairsLength;

        [WireInfo(SizeParam="idPairsLength")]
        public MediaInstanceIdOfferIdPair[] idPairs;

        public override string Xrl { get { return "/xsig/AcknowledgeLicensesDelivery.ashx"; } }
    }

    public class AcknowledgeLicensesDeliveryResponse : XRLObject2
    {
        [WireInfo(Min=1)]
        public ushort acknowledgementsLength;

        [WireInfo(SizeParam="acknowledgementsLength")]
        public Acknowledgement[] acknowledgements;
    }


    public class RefreshGameLicenseRequest : XRLObject2
    {
        public UInt64 userId;

        public UInt64 machineId;

        [WireInfo(Min=1, Max=XOn.XONLINE_CONTENT_LICENSE_MAX_LEN)]
        public UInt16 licenseLength;

        [WireInfo(SizeParam="licenseLength")]
        public byte[] license;

        public override string Xrl { get { return "/xsig/RefreshGameLicense.ashx"; } }
    }

    public class RefreshGameLicenseResponse : XRLObject2
    {
        [WireInfo(Min=1, Max=XOn.XONLINE_CONTENT_LICENSE_MAX_LEN)]
        public UInt16 licenseLength;

        [WireInfo(SizeParam="licenseLength")]
        public byte[] license;
    }

    public enum UpdateTransferStateEnum
    {
        Start,
        Complete,
        Cancel
    }

    public class UpdateLicenseTransferStateRequest : XRLObject2
    {
        public UpdateTransferStateEnum command;

        public UInt64 userPuid;

        public override string Xrl { get { return "/xsig/UpdateLicenseTransferState.ashx"; } }
    }

    public enum LicenseTransferStatusEnum
    {
        LicenseTransferTimeout = -2,
        MultipleSignInDetected = -1,

        NotStarted = 0,
        PendingConsoleSignIn = 1,
        PendingUserConfirmation = 2,
        Completed = 3
    }

    public class GetLicenseTransferStateRequest : XRLObject2
    {
        public UInt64 userPuid;

        public override string Xrl { get { return "/xsig/GetLicenseTransferState.ashx"; } }
    }

    public class ConsoleLicenseCount : WireData
    {
        public UInt32 licenseCount;

        public UInt16 consoleIdLength;

        [WireInfo(SizeParam = "consoleIdLength")]
        public string consoleId;
    }

    public class GetLicenseTransferStateResponse : XRLObject2
    {
        public const int XONLINE_CONSOLEID_LENGTH   = 16;
        public const int XONLINE_CONSOLE_ARRAY_SIZE = 100;

        public LicenseTransferStatusEnum currentStatus = LicenseTransferStatusEnum.NotStarted;

        public Boolean restartAllowed = true;

        public DateTime lastUpdated = WireData.MinDateTimeValue;

        [WireInfo(Max = XONLINE_CONSOLEID_LENGTH)]
        public UInt16 consoleIdLength;

        [WireInfo(SizeParam = "consoleIdLength")]
        public string consoleId;

        [WireInfo(Max = XONLINE_CONSOLE_ARRAY_SIZE)]
        public UInt16 sourceConsolesLength;

        [WireInfo(SizeParam = "sourceConsolesLength")]
        public ConsoleLicenseCount[] sourceConsoles;

        public UInt16 sourceVideoConsolesLength;

        [WireInfo(SizeParam = "sourceVideoConsolesLength")]
        public ConsoleLicenseCount[] sourceVideoConsoles;

        [WireInfo(MinSchemaVersion = "7.0")]
        public DateTime nextAvailableTransfer = WireData.MinDateTimeValue;

    }


    public sealed class GetSignedHeaderRequest : XRLObject2
    {
        public const int XONLINE_HEADER_HASH_SIZE = 20;

        public const uint ONLY_LEGAL_FILE_TYPE = 0x52475459;

        public UInt32 fileSize;

        public UInt32 fileType;

        [WireInfo(ArraySize = XONLINE_HEADER_HASH_SIZE)]
        public byte[] fileHash;

        public override string Xrl { get { return "/xsig/GetSignedHeader.ashx"; } }
    }

    public sealed class GetSignedHeaderResponse : XRLObject2
    {
        public UInt32 headerSize;

        [WireInfo(SizeParam = "headerSize", LimitString = true)]
        public byte[] header;
    }

    public sealed class ValidateCertificateRequest : XRLObject2
    {
        // Everyone loves powers of 2.
        public const int MAX_CERT_SIZE = 32768;

        [WireInfo(Min = 1, Max = MAX_CERT_SIZE)]
        public ushort certificateSize;

        [WireInfo(SizeParam = "certificateSize")]
        public byte[] certificate;

        public override string Xrl
        {
            get
            {
                return "/xsig/ValidateCertificate.ashx";
            }
        }
    }

    public sealed class ValidateCertificateResponse : XRLObject2
    {
        public HResult  hr;
        public DateTime validUntil;
    }

    public class CreatePlayReadyCertificateRequest : XRLObject2
    {
        public const int PUBLIC_SIGNING_KEY_LEN = 64;
        public const int PUBLIC_ENCRYPTION_KEY_LEN = 64;

        [WireInfo(Min=0, Max=0)]
        public uint flags;

        [WireInfo(ArraySize=PUBLIC_SIGNING_KEY_LEN)]
        public byte[] publicSigningKey;

        [WireInfo(ArraySize=PUBLIC_ENCRYPTION_KEY_LEN)]
        public byte[] publicEncryptionKey;

        public override string Xrl { get { return "/xsig/CreatePlayReadyCertificate.ashx"; } }
    }

    public class CreatePlayReadyCertificateResponse : XRLObject2
    {
        public const int CERTIFICATE_BLOCK_MAX_COUNT = 3;

        [WireInfo(Min=1, Max=CERTIFICATE_BLOCK_MAX_COUNT)]
        public ushort certBlockCount;

        [WireInfo(SizeParam="certBlockCount")]
        public XeGenericBlock[] certBlocks;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\XTOUProtocol.cs ===
using xonline.common.service;       // XRLObject2

namespace xonline.common.protocol
{
    public class GetLanguagesForCountryRequest : XRLObject2
    {
        public byte countryId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xtou/GetLanguagesForCountry.ashx"; }
        }
    }

    public class XtouLanguageDefinition : XRLObject2
    {
        public int languageId;

        public ushort languageNameLength = 0;

        [WireInfo(SizeParam = "languageNameLength")]
        public string languageName;
    }

    public class GetLanguagesForCountryResponse : XRLObject2
    {
        public ushort count;

        [WireInfo(SizeParam="count")]
        public XtouLanguageDefinition[] languageDefinitions;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\passport\PassportAddProofResponse.cs ===
//------------------------------------------------------------ 
// Copyright (c) Microsoft Corporation. All rights reserved. 
//------------------------------------------------------------ 

using xonline.common.service;

namespace xonline.common.protocol.passport
{
    public class PassportAddProofResponse : XRLObject2
    {
        /// <summary>
        /// Flag to state if the strong proof has already been confirmed
        /// </summary>
        public bool isConfirmed;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\passport\PassportGetProofsRequest.cs ===
//------------------------------------------------------------ 
// Copyright (c) Microsoft Corporation. All rights reserved. 
//------------------------------------------------------------ 

using xonline.common.service;

namespace xonline.common.protocol.passport
{
    public class PassportGetProofsRequest : XRLObject2
    {
        /// <summary>
        /// The Xuid of the account that is attempting to perform the operation.
        /// Since the console can have multiple users attached, need to distinguish
        /// which user is making the request.
        /// </summary>
        public Puid userPuid;

        /// <summary>
        /// The console where the user make the request.
        /// </summary>
        public Puid machinePuid;

        /// <summary>
        /// Standard Xbox protocol element to state that this operation should be
        /// password verified.  It represents the signed passport puid of the account
        /// being accessed.
        /// </summary>
        public PassportToken sessionToken;

        public override string Xrl
        {
            get
            {
                return "/xuacs/PassportGetProofs.ashx";
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\passport\PassportGetProofsResponse.cs ===
//------------------------------------------------------------ 
// Copyright (c) Microsoft Corporation. All rights reserved. 
//------------------------------------------------------------ 

using xonline.common.service;

namespace xonline.common.protocol.passport
{
    public class PassportGetProofsResponse : XRLObject2
    {
        /// <summary>
        /// Protocol element to hold the array length.
        /// </summary>
        public ushort proofsLength;

        /// <summary>
        /// The list of strong proofs returned from passport
        /// </summary>
        [WireInfo(SizeParam = "proofsLength")]
        public ProofStatus[] proofs;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\XbosProtocol.cs ===
using System;


using xonline.common.service;


namespace xonline.common.protocol
{
    public enum OfferCatalogTypeEnum
    {
        Unknown     = 0,
        Xbox        = 1,
        Ems         = 2
    }

    public class AutoupdReferralRequest : XRLObject2
    {
        public ulong  machinePuid;
        public uint   titleId;
        public uint   baseVersion; // Base version (Dash only)

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/AutoupdReferral.ashx"; }
        }
    }

    public class ReferralLocation : WireData
    {
        public ushort rank;

        public ushort xrlLength;

        [WireInfo(SizeParam="xrlLength", NullTerminate=true)]
        public string xrl;            // XRL to update package
    }

    public class AutoupdReferralResponse : XRLObject2
    {
        public ushort flags;          // Flags

        public ushort locationCount;  // Number of XRLs

        public uint   packageSize;    // Wire size of package

        public uint   installSize;    // Accurate install size

        public uint   titleVersion;   // Update version

        [WireInfo(ArraySize=16)]
        public byte[] symKey;         // Symmetric key

        [WireInfo(ArraySize=284)]
        public byte[] pubKey;         // Public key

        [WireInfo(SizeParam="locationCount")]
        public ReferralLocation[] locations;
    }

    public class ContentAvailableRequest : XRLObject2
    {
        public uint titleId =0;

        public int esrbRating =0;

        public uint bitFilter =0;

        public DateTime lastChangedDate = DateTime.UtcNow;

        public byte countryId = 0;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/ContentAvailable.ashx"; }
        }
    }

    public class ContentReferralRequest : XRLObject2
    {
        public ulong machinePuid;
        public ulong userPuid0;
        public ulong userPuid1;
        public ulong userPuid2;
        public ulong userPuid3;
        public uint  titleId;
        public ulong offerId;
        public uint  esrbRating;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/ContentReferral.ashx"; }
        }
    }

    public class ContentReferralResponse : XRLObject2
    {
        public ushort flags;          // Flags

        public ushort locationCount;  // Number of XRLs

        public uint   packageSize;    // Wire size of package

        public uint   installSize;    // Accurate install size

        public uint   bitFlags;       // Package bit flags

        [WireInfo(ArraySize=16)]
        public byte[] symKey;         // Symmetric key

        [WireInfo(ArraySize=284)]
        public byte[] pubKey;         // Public key

        [WireInfo(SizeParam="locationCount")]
        public ReferralLocation[] locations;
    }

    public class OfferingCancelRequest : XRLObject2
    {
        public ulong userPuid;

        public ulong offerId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/OfferingCancel.ashx"; }
        }
    }

    public class OfferingDetailsRequest : XRLObject2
    {
        public ulong userPuid;

        public ulong machinePuid;

        public uint titleId;

        public ulong offerId;

        public int descriptionIndex;

        [WireInfo(Min=XOn.XONLINE_LANGUAGE_MIN, Max=XOn.XONLINE_LANGUAGE_MAX)]
        public ushort languageId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/OfferingDetails.ashx"; }
        }
    }

    public class OfferingDetailsResponse : XRLObject2
    {
        public uint   instanceCount;

        public uint   wholePart;

        public byte   fractionalPart;

        public byte   currencyFormat;

        [WireInfo(ArraySize=3)]
        public string isoCode;

        public uint   offeringDetails;

        public uint   detailsBlobLength;

        [WireInfo(SizeParam="detailsBlobLength")]
        public byte[] detailsBlob;
    }

    public class OfferingDetailsNoUserRequest : XRLObject2
    {
        public byte countryId;

        public ulong machinePuid;

        public uint titleId;

        public ulong offerId;

        public int descriptionIndex;

        [WireInfo(Min=XOn.XONLINE_LANGUAGE_MIN, Max=XOn.XONLINE_LANGUAGE_MAX)]
        public ushort languageId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/OfferingDetailsNoUser.ashx"; }
        }
    }

    public class OfferingEnumerateRequest : XRLObject2
    {
        public ulong       userPuid;

        public uint        titleId;

        public uint        clientBufferSize;

        public int         esrbRating;

        public DateTime    lastChangedDate = DateTime.UtcNow;

        public uint        offerType;

        public uint        bitFilter;

        public int         descriptionIndex;

        public ushort      startingIndex;

        public ushort      maxResults;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/OfferingEnumerate.ashx"; }
        }
    }

    public class OfferingEnumerateRecord : XRLObject2
    {
        public short  recordSize;

        public short  recordIndex;

        public ulong  offerId;

        public int    offerType;

        public int    bitFlags;

        public int    packageSize;

        public int    installSize;

        public DateTime activationDate;

        public int    esrbRating;

        public short  offerFlags;

        public int    titleSpecificDataSize;

        public int    titleSpecificDataOffset;

        [WireInfo(SizeParam="titleSpecificDataSize")]
        public byte[] enumBlob;
    }

    public class OfferingEnumerateResponse : XRLObject2
    {
        public short    recordCount;

        public short    flags;

        public DateTime lastChangedDate;

        [WireInfo(SizeParam="recordCount")]
        public OfferingEnumerateRecord[] records;
    }

    public class OfferingPurchaseRequest : XRLObject2
    {
        public ulong userPuid;

        public ulong machinePuid;

        public uint  titleId;

        public ulong offerId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/OfferingPurchase.ashx"; }
        }
    }

    [WireInfo(MaxSchemaVersion="4.9")]
    public class ContentUpdateAccessTimesRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public uint titleID;

        [WireInfo(HexString=true)]
        public uint titleCategories;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeContentUpdateAccessTimes.ashx";
            }
        }
    }

    public class ContentEnumerateRequest : XRLObject2WithFlags
    {
        static byte UserPlayedGameFilter        = 0x01;
        static byte UserHasPurchasedFilter      = 0x02;
        static byte NewContentOnlyFilter        = 0x04;
        static byte MatchRequiredTierFilter     = 0x08;

        [WireInfo(HexString = true)]
        public ulong userPuid;

        public byte countryID;

        public ushort languageID;

        [WireInfo(HexString=true)]
        public ushort gameRating;

        [WireInfo(HexString=true)]
        public uint offerType; // content, points bundle, gamertag, etc

        [WireInfo(HexString=true)]
        public uint paymentType; // credit card, token, points, etc

        public byte tierRequired;

        [WireInfo(HexString=true)]
        public uint titleID;

        [WireInfo(HexString=true)]
        public uint titleCategories;

        [WireInfo(HexString=true)]
        public byte requestFlags; // userPlayedGameFilter, userHasPurchasedFilter

        [WireInfo(Min=0, Max=65535)]
        public int startingIndex;

        [WireInfo(Min=0, Max=65535)]
        public int maxResults;

        public int genreID = 0;

        public bool userPlayedGameFilter
        {
            get
            {
                return IsFlagSet(UserPlayedGameFilter, requestFlags);
            }
            set
            {
                SetFlag(UserPlayedGameFilter, value, ref requestFlags);
            }
        }

        public bool userHasPurchasedFilter
        {
            get
            {
                return IsFlagSet(UserHasPurchasedFilter, requestFlags);
            }
            set
            {
                SetFlag(UserHasPurchasedFilter, value, ref requestFlags);
            }
        }

        public bool newContentOnlyFilter
        {
            get
            {
                return IsFlagSet(NewContentOnlyFilter, requestFlags);
            }
            set
            {
                SetFlag(NewContentOnlyFilter, value, ref requestFlags);
            }
        }

        public bool matchRequiredTierFilter
        {
            get
            {
                return IsFlagSet(MatchRequiredTierFilter, requestFlags);
            }
            set
            {
                SetFlag(MatchRequiredTierFilter, value, ref requestFlags);
            }
        }

        public override string Xrl
        {
            get
            {
                return "/xbos/XeContentEnumerate2.ashx";
            }
        }
    }

    public class OfferPrice : WireData
    {
        public uint paymentType;

        public byte taxType;

        public int wholePrice;

        public int fractionalPrice;

        public ushort priceTextLength;

        [WireInfo(SizeParam="priceTextLength", NullTerminate=true)]
        public string priceText;
      }

    public class GamertagContentInfo : XRLObject2
    {
        public Guid offerID;

        public ushort offerNameLength;

        [WireInfo(SizeParam = "offerNameLength", NullTerminate = true)]
        public string offerName;

        public uint offerType;

        public int sellTextLength;

        [WireInfo(SizeParam = "sellTextLength", NullTerminate = true)]
        public string sellText;

        // NOTE: this parameter is not serialized to the wire.  it is only used for internal calculation.
        [WireInfo(Serialize = false)]
        public System.DateTime maxStartDate;

        public byte pricesLength;

        [WireInfo(SizeParam = "pricesLength")]
        public OfferPrice[] prices;

    }

    public class BasicContentInfo : XRLObject2WithFlags
    {
        static ushort UserHasPurchased          = 0x0001;
        static ushort UserHasViewed             = 0x0002;
        static ushort IsUnrestricted            = 0x0004;
        static ushort IsRecentContent           = 0x0008;

        public BasicContentInfo()
        {
            responseFlags = 0;
        }

        public ulong offerID;

        [WireInfo(MinSchemaVersion="2.0")]
        public ulong previewOfferID;

        public ushort offerNameLength;

        [WireInfo(SizeParam="offerNameLength", NullTerminate=true)]
        public string offerName;

        public uint offerType;

        [WireInfo(ArraySize=(int)XOn.XONLINE_CONTENT_ID_LEN)]
        public byte[] contentId;

        [WireInfo(MinSchemaVersion="2.0")]
        public uint licenseMask;

        public uint titleID;

        public uint titleCategory;

        public ushort titleNameLength;

        [WireInfo(SizeParam="titleNameLength", NullTerminate=true)]
        public string titleName;

        public byte tierRequired;

        public ushort gameRating;

        public ushort responseFlags; // userHasPurchased, userHasViewed, isUnrestricted

        public uint packageSize;

        public uint installSize;

        public int sellTextLength;

        [WireInfo(SizeParam="sellTextLength", NullTerminate=true)]
        public string sellText;

        [WireInfo(MinSchemaVersion="2.0")]
        public uint assetID;

        [WireInfo(MinSchemaVersion="2.0")]
        public uint purchaseQuantity;

        public byte pricesLength;

        // NOTE: this parameter is not serialized to the wire.  it is only used for internal calculation.
        [WireInfo(Serialize=false)]
        public System.DateTime maxStartDate;

        [WireInfo(SizeParam="pricesLength")]
        public OfferPrice [] prices;

        public bool userHasPurchased
        {
            get
            {
                return IsFlagSet(UserHasPurchased, responseFlags);
            }
            set
            {
                SetFlag(UserHasPurchased, value, ref responseFlags);
            }
        }

        public bool userHasViewed
        {
            get
            {
                return IsFlagSet(UserHasViewed, responseFlags);
            }
            set
            {
                SetFlag(UserHasViewed, value, ref responseFlags);
            }
        }

        public bool isUnrestricted
        {
            get
            {
                return IsFlagSet(IsUnrestricted, responseFlags);
            }
            set
            {
                SetFlag(IsUnrestricted, value, ref responseFlags);
            }
        }

        public bool isRecentContent
        {
            get
            {
                return IsFlagSet(IsRecentContent, responseFlags);
            }
            set
            {
                SetFlag(IsRecentContent, value, ref responseFlags);
            }
        }
    }

    public class GamertagEnumerateResult : XRLObject2
    {
        public ushort offersReturned;

        [WireInfo(SizeParam = "offersReturned")]
        public GamertagContentInfo[] infos;

        public uint offersTotal;
    }

    public class ContentEnumerateResponse : XRLObject2, IMeasurable
    {
        public ushort offersReturned;

        [WireInfo(SizeParam="offersReturned")]
        public BasicContentInfo [] infos;

        public uint offersTotal;

        uint IMeasurable.GetSize()
        {
            uint size = 6;

            for (uint iInfo = 0; iInfo < offersReturned; iInfo++)
            {
                size += 90;
                size += infos[iInfo].offerNameLength;
                size += (uint)infos[iInfo].sellTextLength;
                size += infos[iInfo].titleNameLength;

                for (uint iPrice = 0; iPrice < infos[iInfo].pricesLength; iPrice++)
                {
                    size += 15;
                    size += infos[iInfo].prices[iPrice].priceTextLength;
                }
            }

            return size;
        }

        public ContentEnumerateResponse Copy()
        {
            ContentEnumerateResponse copy = new ContentEnumerateResponse();

            copy.offersReturned = offersReturned;
            copy.offersTotal = offersTotal;

            copy.infos = new BasicContentInfo[infos.Length];
            for (uint iInfo = 0; iInfo < infos.Length; iInfo++)
            {
                copy.infos[iInfo] = new BasicContentInfo();

                copy.infos[iInfo].offerID = infos[iInfo].offerID;
                copy.infos[iInfo].previewOfferID = infos[iInfo].previewOfferID;
                copy.infos[iInfo].offerNameLength = infos[iInfo].offerNameLength;
                copy.infos[iInfo].offerName = infos[iInfo].offerName;
                copy.infos[iInfo].offerType = infos[iInfo].offerType;
                copy.infos[iInfo].contentId = infos[iInfo].contentId;
                copy.infos[iInfo].licenseMask = infos[iInfo].licenseMask;
                copy.infos[iInfo].titleID = infos[iInfo].titleID;
                copy.infos[iInfo].titleCategory = infos[iInfo].titleCategory;
                copy.infos[iInfo].titleNameLength = infos[iInfo].titleNameLength;
                copy.infos[iInfo].titleName = infos[iInfo].titleName;
                copy.infos[iInfo].tierRequired = infos[iInfo].tierRequired;
                copy.infos[iInfo].gameRating = infos[iInfo].gameRating;
                copy.infos[iInfo].responseFlags = infos[iInfo].responseFlags;
                copy.infos[iInfo].packageSize = infos[iInfo].packageSize;
                copy.infos[iInfo].installSize = infos[iInfo].installSize;
                copy.infos[iInfo].sellTextLength = infos[iInfo].sellTextLength;
                copy.infos[iInfo].sellText = infos[iInfo].sellText;
                copy.infos[iInfo].assetID = infos[iInfo].assetID;
                copy.infos[iInfo].purchaseQuantity = infos[iInfo].purchaseQuantity;
                copy.infos[iInfo].pricesLength = infos[iInfo].pricesLength;
                copy.infos[iInfo].maxStartDate = infos[iInfo].maxStartDate;

                copy.infos[iInfo].prices = new OfferPrice[infos[iInfo].prices.Length];
                for (uint iPrice =0; iPrice < infos[iInfo].prices.Length; iPrice++)
                {
                    copy.infos[iInfo].prices[iPrice] = new OfferPrice();

                    copy.infos[iInfo].prices[iPrice].paymentType = infos[iInfo].prices[iPrice].paymentType;
                    copy.infos[iInfo].prices[iPrice].taxType = infos[iInfo].prices[iPrice].taxType;
                    copy.infos[iInfo].prices[iPrice].wholePrice = infos[iInfo].prices[iPrice].wholePrice;
                    copy.infos[iInfo].prices[iPrice].fractionalPrice = infos[iInfo].prices[iPrice].fractionalPrice;
                    copy.infos[iInfo].prices[iPrice].priceTextLength = infos[iInfo].prices[iPrice].priceTextLength;
                    copy.infos[iInfo].prices[iPrice].priceText = infos[iInfo].prices[iPrice].priceText;
                }
            }

            return copy;
        }
    }

    public class ContentDetailsRequest : XRLObject2
    {
        public ulong userPuid;

        public byte countryID;

        public ushort languageID;

        [WireInfo(MinSchemaVersion="2.0")]
        public ushort offers;        // count of offers

        [WireInfo(HexString=true, SizeParam="offers", MinSchemaVersion="2.0")]
        public ulong [] offerIDs;

        [WireInfo(HexString=true, MaxSchemaVersion="1.0")]
        public ulong offerID;

        [WireInfo(HexString=true)]
        public uint paymentType;    // credit card, token, points, etc

        public byte tierRequired;

        [WireInfo(HexString=true)]
        public byte ratingSystem;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeContentDetails.ashx";
            }
        }
    }

    public class ContentDetailsResponse : XRLObject2
    {
        [WireInfo(MinSchemaVersion="2.0")]
        public ushort offersReturned;

        [WireInfo(SizeParam="offersReturned", MinSchemaVersion="2.0")]
        public BasicContentInfo [] infos;

        [WireInfo(MaxSchemaVersion="1.0")]
        public BasicContentInfo basicInfo;
    }

    public class SubscriptionEnumerateRequest : XRLObject2WithFlags
    {
        static ushort QueryForNew                      = 0x0001;
        static ushort QueryForRenewals                 = 0x0002;
        static ushort QueryForCurrent                  = 0x0004;
        static ushort QueryForExpired                  = 0x0008;
        static ushort QueryForSuspended                = 0x0010;

        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public byte userTier;

        public byte countryID;

        public ushort languageID;

        [WireInfo(HexString=true)]
        public ushort gameRating;

        [WireInfo(HexString=true)]
        public uint offerType; // live, game, 24-hour, add-on

        [WireInfo(HexString=true)]
        public uint paymentType; // credit card, token, points, etc

        [WireInfo(HexString=true)]
        public uint titleID;

        [WireInfo(HexString=true)]
        public uint titleCategories;

        [WireInfo(HexString=true)]
        public ushort requestFlags; // queryForEquivalent, queryForUpgrades, queryForDowngrades

        [WireInfo(Min=0, Max=65535)]
        public int startingIndex;

        [WireInfo(Min=0, Max=65535)]
        public int maxResults;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeSubscriptionEnumerate.ashx";
            }
        }

        public bool queryForNew
        {
            get
            {
                return IsFlagSet(QueryForNew, requestFlags);
            }
            set
            {
                SetFlag(QueryForNew, value, ref requestFlags);
            }
        }

        public bool queryForRenewals
        {
            get
            {
                return IsFlagSet(QueryForRenewals, requestFlags);
            }
            set
            {
                SetFlag(QueryForRenewals, value, ref requestFlags);
            }
        }

        public bool queryForCurrent
        {
            get
            {
                return IsFlagSet(QueryForCurrent, requestFlags);
            }
            set
            {
                SetFlag(QueryForCurrent, value, ref requestFlags);
            }
        }

        public bool queryForExpired
        {
            get
            {
                return IsFlagSet(QueryForExpired, requestFlags);
            }
            set
            {
                SetFlag(QueryForExpired, value, ref requestFlags);
            }
        }

        public bool queryForSuspended
        {
            get
            {
                return IsFlagSet(QueryForSuspended, requestFlags);
            }
            set
            {
                SetFlag(QueryForSuspended, value, ref requestFlags);
            }
        }
    }

    public class BasicSubscriptionInfo : XRLObject2WithFlags
    {
        static ushort UserIsSubscribed          = 0x0001;
        static ushort UserHasCancelled          = 0x0002;

        public BasicSubscriptionInfo()
        {
            responseFlags = 0;
        }

        public ulong offerID;

        public ushort offerNameLength;

        [WireInfo(SizeParam="offerNameLength", NullTerminate=true)]
        public string offerName;

        public uint offerType;

        public byte relationType;

        public byte convertMode;

        public ushort instanceIDLength;

        [WireInfo(SizeParam="instanceIDLength", NullTerminate=true)]
        public string instanceID;

        public uint titleID;

        public uint titleCategory;

        public ushort titleNameLength;

        [WireInfo(SizeParam="titleNameLength", NullTerminate=true)]
        public string titleName;

        public ushort gameRating;

        public byte duration;

        public byte frequency;

        public byte tierProvided;

        public byte tierRequired;

        public int sellTextLength;

        [WireInfo(SizeParam="sellTextLength", NullTerminate=true)]
        public string sellText;

        public ulong relatedOfferID;

        public ushort responseFlags; // userIsSubscribed | userHasCancelled

        public byte pricesLength;

        [WireInfo(SizeParam="pricesLength")]
        public OfferPrice [] prices;

        [WireInfo(Serialize=false)]
        public int subscriptionStatusID;

        public bool userIsSubscribed
        {
            get
            {
                return IsFlagSet(UserIsSubscribed, responseFlags);
            }
            set
            {
                SetFlag(UserIsSubscribed, value, ref responseFlags);
            }
        }

        public bool userHasCancelled
        {
            get
            {
                return IsFlagSet(UserHasCancelled, responseFlags);
            }
            set
            {
                SetFlag(UserHasCancelled, value, ref responseFlags);
            }
        }
    }


    public class SubscriptionEnumerateResponse : XRLObject2
    {
        public ushort offersReturned;

        [WireInfo(SizeParam="offersReturned")]
        public BasicSubscriptionInfo [] infos;

        public int offersTotal;
    }

    public class SubscriptionDetailsRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public byte countryID;

        [WireInfo(Min=XOn.XONLINE_LANGUAGE_MIN, Max=XOn.XONLINE_LANGUAGE_MAX)]
        public ushort languageID;

        [WireInfo(HexString=true)]
        public ulong offerID;

        [WireInfo(HexString=true)]
        public uint paymentType; // credit card, token, points, etc

        public byte tierRequired;

        [WireInfo(HexString=true)]
        public byte ratingSystem;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeSubscriptionDetails.ashx";
            }
        }
    }

    public class SubscriptionDetailsResponse : XRLObject2
    {
        public BasicSubscriptionInfo basicInfo;
    }

    [WireInfo(MaxSchemaVersion="4.9")]
    public class XeContentAvailableRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public byte countryID;

        public byte tierRequired;

        [WireInfo(HexString=true)]
        public uint titleID;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeContentAvailable.ashx";
            }
        }
    }

    public class XeContentAvailableResponse : XRLObject2
    {
        public byte newOffersLength = 32;

        [WireInfo(SizeParam="newOffersLength")]
        public uint [] newOffers;

        public byte totalOffersLength = 32;

        [WireInfo(SizeParam="totalOffersLength")]
        public uint [] totalOffers;
    }


    public class OfferExpectedPrice : XRLObject2
    {
        public Guid offerId;

        public uint expectedPrice;
    }

    [WireInfo(MaxSchemaVersion="4.9")]
    public class PurchaseOffersRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public ulong machinePuid;

        public uint offersLength;

        [WireInfo(SizeParam="offersLength")]
        public OfferExpectedPrice [] offers;

        [WireInfo(HexString=true)]
        public uint paymentType;

        public ushort paymentInstrumentIDLength;

        [WireInfo(SizeParam="paymentInstrumentIDLength")]
        public string paymentInstrumentID;

        public ushort billingTokenLength;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken;

        [WireInfo(MinSchemaVersion="3.3")]
        public uint storeId = 1;

        public override string Xrl
        {
            get
            {
                return "/xbos/PurchaseOffers.ashx";
            }
        }
    }

    public class OfferMediaTypeExpectedPrice : XRLObject2
    {
        public Guid offerId;

        public int mediaTypeId;

        public uint expectedPriceWhole;

        [WireInfo(MinSchemaVersion="5.2", Min=0, Max=99)]
        public uint expectedPriceFractional;
    }

    public class PurchaseMediaOffersRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public ulong machinePuid;

        public uint offersLength;

        [WireInfo(SizeParam="offersLength")]
        public OfferMediaTypeExpectedPrice [] offers;

        [WireInfo(HexString=true)]
        public uint paymentType;

        public ushort paymentInstrumentIDLength;

        [WireInfo(SizeParam="paymentInstrumentIDLength")]
        public string paymentInstrumentID;

        public ushort billingTokenLength;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken;

        [WireInfo(MinSchemaVersion="3.3")]
        public uint storeId = 1;

        [WireInfo(MinSchemaVersion = "6.4")]
        public SubscriptionPurchaseInfo subscriptionPurchaseInfo=null;

        [WireInfo(MinSchemaVersion="6.9")]
        public Guid trackingGuid = Guid.Empty;

        public override string Xrl
        {
            get
            {
                return "/xbos/PurchaseMediaOffers.ashx";
            }
        }
    }

    public class SubscriptionPurchaseInfo : XRLObject2
    {
        [WireInfo(MinSchemaVersion = "6.4")]
        public uint subscriptionTimeExtendedInMonths = 0;
    }

    public class XeOfferPurchaseRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public byte countryID;

        public ushort languageID;

        public byte tier;

        public ulong machinePuid;

        [WireInfo(MinSchemaVersion="2.0")]
        public uint offerIDLength;

        [WireInfo(SizeParam="offerIDLength", HexString=true, MinSchemaVersion="2.0")]
        public ulong [] offerIDs;

        [WireInfo(MaxSchemaVersion="1.0")]
        public ulong offerID;

        [WireInfo(HexString=true)]
        public uint paymentType;

        public ushort paymentInstrumentIDLength;

        [WireInfo(SizeParam="paymentInstrumentIDLength")]
        public string paymentInstrumentID;

        public ushort billingTokenLength;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken;

        [WireInfo(MinSchemaVersion="3.2")]
        public ushort encryptedPasswordLength; // for wholesale providers

        [WireInfo(SizeParam="encryptedPasswordLength", MinSchemaVersion="3.2")]
        public string encryptedPassword;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeOfferPurchase.ashx";
            }
        }
    }

    public class XeOfferPurchaseGamertagRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public byte countryID;

        public ushort languageID;

        public byte tier;

        public ulong machinePuid;

        [WireInfo(HexString=true)]
        public ulong offerID;

        [WireInfo(HexString=true)]
        public uint paymentType;

        public ushort billingTokenLength;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeOfferPurchaseGamertag.ashx";
            }
        }
    }

    public class XeOfferPurchaseGamertagResponse : XRLObject2
    {
        public byte newKeyLength;

        [WireInfo(SizeParam="newKeyLength")]
        public byte [] newKey;
    }

    public class MusicItem : XRLObject2
    {
        public ushort mnetIDLength;

        [WireInfo(SizeParam="mnetIDLength")]
        public string mnetID;

        public uint componentType;

        public ushort artistNameLength;

        [WireInfo(SizeParam="artistNameLength")]
        public string artistName;

        public ushort titleFieldLength;

        [WireInfo(SizeParam="titleFieldLength")]
        public string titleField;

        public int retailPriceInPoints;

        public decimal retailPriceInCurrency;

        public decimal wholesalePriceInCurrency;
    }

    public class XeOfferPurchaseMusicRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public ushort ipAddressLength;

        [WireInfo(SizeParam="ipAddressLength")]
        public string ipAddress;

        public ushort externalOrderIDLength;

        [WireInfo(SizeParam="externalOrderIDLength")]
        public string externalOrderID;

        public ushort itemCount;

        [WireInfo(SizeParam="itemCount")]
        public MusicItem [] items;

        [WireInfo(HexString=true)]
        public uint paymentType;

        public ushort paymentInstrumentIDLength;

        [WireInfo(SizeParam="paymentInstrumentIDLength")]
        public string paymentInstrumentID;

        public ushort billingTokenLength;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeOfferPurchaseMusic.ashx";
            }
        }
    }

    public class PointsPurchaseQuery : XRLObject2
    {
        public ushort purchaseType; // DMPPurchaseType

        public ushort orderIDType; // DMPOrderIDType

        public ushort orderIDLength;

        [WireInfo(SizeParam="orderIDLength")]
        public string orderID;
    }

    public class XeGetPointsPurchaseStatusRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public ushort queryCount;

        [WireInfo(SizeParam="queryCount")]
        public PointsPurchaseQuery [] queries;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeGetPointsPurchaseStatus.ashx";
            }
        }
    }

    public class PointsPurchaseStatus : XRLObject2
    {
        public ushort orderIDLength;

        [WireInfo(SizeParam="orderIDLength")]
        public string orderID;

        public int status; // DMPTransacionStatus
    }

    public class XeGetPointsPurchaseStatusResponse : XRLObject2
    {
        public ushort statusCount;

        [WireInfo(SizeParam="statusCount")]
        public PointsPurchaseStatus [] statuses;
    }

    public class WMID : XRLObject2
    {
        public ushort wmidLength;

        [WireInfo(SizeParam="wmidLength")]
        public string wmid;

        public uint videoType;
    }


    public class XRLObject2WithFlags : XRLObject2
    {
        public static void SetFlag(byte flag, bool set, ref byte value)
        {
            if (set == true)
                value = (byte) (value | flag);
            else
                value = (byte) (value & ~flag);
        }

        public static void SetFlag(ushort flag, bool set, ref ushort value)
        {
            if (set == true)
                value = (ushort) (value | flag);
            else
                value = (ushort) (value & ~flag);
        }

        public static bool IsFlagSet(byte flag, byte value)
        {
            return ((flag & value) == flag);
        }

        public static bool IsFlagSet(ushort flag, ushort value)
        {
            return ((flag & value) == flag);
        }
    }

    //
    // banner of the day protocol
    //

    public enum BannerListLevel : byte
    {
        BannerOnly = 1,
        HotList = 2
    }

    [WireInfo(MaxSchemaVersion="4.9")]
    public class BannerListRequest : XRLObject2
    {
        public ulong userPuid;
        public uint langId;
        public byte level;
        public int  startingIndex;
        public int  maxResults;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeBannerGetList.ashx";
            }
        }
    }

    public enum BannerType : byte
    {
        Min = 0,
        Live_Blade_Billboard = 0,
        Live_Blade_Marketplace = 1,
        Marketplace_Storefront = 2,
        V1_Marketplace_Demos_and_Game_Videos = 3,
        V1_Marketplace_Games = 4,
        V1_Marketplace_Themes_and_Gamer_Pictures = 5,
        Games_Blade_Arcade_Banner = 6,
        V1_Marketplace_Arcade = 7,
        V1_Marketplace_Game_Demos = 8,
        V1_Marketplace_Trailers_and_Game_Videos = 9,
        V1_Marketplace_Gamer_Pictures = 10,
        V1_Marketplace_Media_and_Entertainment = 11,
        MediaMarketplace_Video_Main_Large = 12,
        MediaMarketplace_Video_Main_Small = 13,
        MediaMarketplace_Video_Movies_Main = 14,
        MediaMarketplace_Video_TV_Main = 15,
        MediaMarketplace_Video_Music_Videos_Main = 16,
        MediaMarketplace_Video_Viral_Main_Top = 17,
        MediaMarketplace_Video_Viral_Main_Middle = 18,
        MediaMarketpalce_Video_Viral_Main_Bottom = 19,
        V2_Marketplace_Demos_and_Game_Videos = 20,
        V2_Marketplace_Games = 21,
        V2_Marketplace_Themes_and_Gamer_Pictures = 22,
        V2_Marketplace_Arcade = 23,
        V2_Marketplace_Game_Demos = 24,
        V2_Marketplace_Trailers_and_Game_Videos = 25,
        V2_Marketplace_Gamer_Pictures = 26,
        V2_Marketplace_Media_and_Entertainment = 27,
        V2_Marketplace_Game_Trailers = 28,
        V2_Marketplace_Gaming_Community = 29,
        V2_Marketplace_Game_Tips_and_Support_Videos = 30,
        // Added in Spring 2007
        V2_Games_Blade_Title_Promo = 31,
        V2_Marketplace_Games_Small = 32,
        V2_Marketplace_Game_Arcade_Small = 33,
        V2_Marketplace_GameDemos_Small = 34,
        V2_Marketplace_ThemesGamerPic_Small = 35,
        V2_Marketplace_Video_GameVideo_US_Small = 36,
        V2_Marketplace_Video_GameVideo_US_Large = 37,
        V2_Marketplace_Video_NonUS_Small = 38,
        V2_Marketplace_Video_GameVideo_NonUS_Small = 39,
        // Added in Fall 2007
        XBLA = 40,
        Games_Blade_Featured_Title = 41,
        Feature_Item_Flag_Slot = 42,
        Free_TV = 43,
        Games_on_Demand_Small = 44,
        Games_on_Demand_Large = 45,
        V3_Featured_Items_1 = 46,
        V3_Featured_Items_2 = 47,
        V3_Featured_Items_3 = 48,
        V3_Featured_Items_4 = 49,
        V3_Featured_Items_5 = 50,
        V3_Featured_Items_6 = 51,
        V3_Featured_Items_7 = 52,
        V3_Featured_Items_8 = 53,
        V3_Featured_Items_9 = 54,
        V3_Featured_Items_10 = 55,
        Games_Lib_Featured_BDE = 56,
        Game_AddOns_Small = 57,
        Game_AddOns_Large = 58,
        Game_Related_Downloads_small = 59,
        Game_Related_Downloads_large = 60,
        New_Arrivals = 61,
        Billboard_Games_Blade = 62,
        Billboard_Media_Blade = 63,
        Marketplace_top_level_slot_A = 64,
        Marketplace_top_level_slot_B = 65,
        Marketplace_top_level_slot_C = 66,
        BDE_Parking = 67,
        // Begin Future Slots
        Future_slot_A = 68,
        Future_slot_B = 69,
        Future_slot_C = 70,
        Future_slot_D = 71,
        Future_slot_E = 72,
        Future_slot_F = 73,
        Future_slot_G = 74,
        Future_slot_H = 75,
        // End Future Slots
        Max,
    }

    public class XOnlineString : WireData
    {
        public ushort len;
        [WireInfo(SizeParam="len")]
        public string str;
    }

    public class BannerBaseListEntry : WireData
    {
        public byte bannerType;
        public bool isMyGame;  // whether banner shows on personalized pages
        public ushort width;
        public ushort height;
        public XOnlineString path = new XOnlineString();
    }

    public class BannerHotListEntry : BannerBaseListEntry
    {
        public uint titleId;
        public XOnlineString titleName = new XOnlineString();
        public ulong offerId;
        public XOnlineString offerName = new XOnlineString();
        public OfferPrice price;
        public DateTime dateApproved;
    }

    public class BannerListResponse : XRLObject2
    {
        public DateTime expires;   // how long can the list be cached by client
        public int cultureId;

        public ushort bannerCountTotal = 0;
        public ushort bannerCount = 0;
        [WireInfo(SizeParam="bannerCount")]
        public BannerBaseListEntry[] bannerList = null;  // can be BannerHotListEntry[]
    }

    public class BannerHotListResponse : XRLObject2
    {
        public DateTime expires;   // how long can the list be cached by client
        public int cultureId;

        public ushort bannerCountTotal = 0;
        public ushort bannerCount = 0;
        [WireInfo(SizeParam="bannerCount")]
        public BannerHotListEntry[] hotList = null;
    }


    [WireInfo(MaxSchemaVersion="4.9")]
    public class XeGetTitleDetailsRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public uint titleId;

        public byte countryId;

        [WireInfo(Min=XOn.XONLINE_LANGUAGE_MIN, Max=XOn.XONLINE_LANGUAGE_MAX)]
        public ushort languageId;

        public byte tierRequired;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeGetTitleDetails.ashx";
            }
        }
    }

    public class XeGetTitleDetailsResponse : XRLObject2, IMeasurable
    {
        [WireInfo(HexString=true)]
        public ushort gameRating;

        public ushort titleLength;
        [WireInfo(SizeParam="titleLength")]
        public string title;

        public ushort sellTextLength;
        [WireInfo(SizeParam="sellTextLength")]
        public string sellText;

        public ushort developerLength;
        [WireInfo(SizeParam="developerLength")]
        public string developer;

        public ushort publisherLength;
        [WireInfo(SizeParam="publisherLength")]
        public string publisher;

        public ushort genreLength;
        [WireInfo(SizeParam="genreLength")]
        public string genre;

        public bool subscriptionContent;
        public bool themeContent;
        public bool demoContent;
        public bool trailerContent;
        public bool played;

        uint IMeasurable.GetSize()
        {
            uint size = 12 + 5;

            size += (uint) (titleLength + sellTextLength + developerLength + publisherLength + genreLength);

            return size;
        }
    }

    [WireInfo(MaxSchemaVersion="4.9")]
    public class XeEnumerateTitlesByFilterRequest : XRLObject2WithFlags
    {
        static ushort QueryForNew                      = 0x0001;
        static ushort QueryForPlayed                 = 0x0002;

        [WireInfo(HexString=true)]
        public ulong userPuid;

        public byte countryId;

        [WireInfo(Min=XOn.XONLINE_LANGUAGE_MIN, Max=XOn.XONLINE_LANGUAGE_MAX)]
        public ushort languageId;

        public uint startIndex;
        public uint maxCount;

        [WireInfo(HexString=true)]
        public ushort gameRating;

        public byte tierRequired;
        public int genreId = 0;

        public uint offerType = 0;

        [WireInfo(HexString=true)]
        public ushort requestFlags; // new content filter, games played filter

        public override string Xrl
        {
            get
            {
                return "/xbos/XeEnumerateTitlesByFilter.ashx";
            }
        }

        public bool gamesWithNewContentFilter
        {
            get
            {
                return IsFlagSet(QueryForNew, requestFlags);
            }
            set
            {
                SetFlag(QueryForNew, value, ref requestFlags);
            }
        }

        public bool gamesPlayedFilter
        {
            get
            {
                return IsFlagSet(QueryForPlayed, requestFlags);
            }
            set
            {
                SetFlag(QueryForPlayed, value, ref requestFlags);
            }
        }
    }

    public class XeEnumerateTitlesByFilterResponse : XRLObject2, IMeasurable
    {
        public uint titlesReturned = 0;

        [WireInfo(SizeParam="titlesReturned")]
        public EnumeratedTitleInfo [] titles;

        public uint totalTitleCount = 0;

        uint IMeasurable.GetSize()
        {
            uint size = 8;

            for (uint iTitle = 0; iTitle < titlesReturned; iTitle++)
            {
                size += 16;
                size += titles[iTitle].titleNameLength;
            }

            return size;
        }
    }

    public class EnumeratedTitleInfo : XRLObject2
    {
        public ushort titleNameLength;
        [WireInfo(SizeParam="titleNameLength")]
        public string titleName;

        public uint titleId;

        public bool played;

        public uint purchasedContentCount;
        public uint totalContentCount;
        public bool newContentExists;
    }

    [WireInfo(MaxSchemaVersion="4.9")]
    public class XeEnumerateGenresRequest : XRLObject2
    {
        public byte countryId;

        [WireInfo(Min=XOn.XONLINE_LANGUAGE_MIN, Max=XOn.XONLINE_LANGUAGE_MAX)]
        public ushort languageId;

        public uint startIndex;
        public uint maxCount;

        [WireInfo(HexString=true)]
        public ushort gameRating;

        public byte tierRequired;
        public uint offerType = 0;
        public int parentGenreId = 0;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeEnumerateGenres.ashx";
            }
        }
    }

    public class XeEnumerateGenresResponse : XRLObject2
    {
        public ushort genresReturned = 0;

        [WireInfo(SizeParam="genresReturned")]
        public EnumeratedGenreInfo [] genres;

        public uint totalGenreCount = 0;
    }

    public class EnumeratedGenreInfo : XRLObject2
    {
        public int genreId = 0;

        public ushort localizedGenreLength = 0;

        [WireInfo(SizeParam="localizedGenreLength")]
        public string localizedGenreName = "";
    }


    [WireInfo(MaxSchemaVersion = "4.9")]
    public class XeContentReferralRequest : XRLObject2
    {
        public ulong userId;

        [WireInfo(ArraySize=(int)XOn.XONLINE_CONTENT_ID_LEN)]
        public byte[] contentId;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeContentReferral.ashx";
            }
        }
    }

    public class XeContentReferralLocation : XRLObject2
    {
        public ushort rank;

        [WireInfo(Min=1, Max=XOn.XONLINE_CONTENT_XRL_MAX_LEN)]
        public ushort xrlLength;

        [WireInfo(SizeParam="xrlLength", NullTerminate=true)]
        public string xrl;
    }

    public class XeContentReferralResponse : XRLObject2
    {
        public uint packageSize;

        public uint installSize;

        [WireInfo(ArraySize=(int)XOn.XONLINE_CONTENT_SYMMETRIC_KEY_LEN)]
        public byte[] symKey;

        [WireInfo(ArraySize=(int)XOn.XONLINE_CONTENT_PUBLIC_KEY_LEN)]
        public byte[] pubKey;

        [WireInfo(Min=1, Max=XOn.XONLINE_CONTENT_LOCATIONS_MAX_COUNT)]
        public ushort locationsCount;

        [WireInfo(SizeParam="locationsCount")]
        public XeContentReferralLocation[] locations;
    }


    public class FindMediaInstanceUrlsRequest : XRLObject2
    {
        [WireInfo(Min=1, Max=20)]
        public uint mediaInstanceIdCount;

        [WireInfo(SizeParam="mediaInstanceIdCount")]
        public Guid[] mediaInstanceIds;

        public override string Xrl
        {
            get
            {
                return "/xbos/FindMediaInstanceUrls.ashx";
            }
        }
    }

    public class GetMediaLicenseRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong userPuid;

        public Guid offerId;

        public uint mediaInstanceIdCount;

        [WireInfo(SizeParam = "mediaInstanceIdCount")]
        public Guid[] mediaInstanceIds;

        public uint clientInfoLength;
        [WireInfo(SizeParam = "clientInfoLength")]
        public string clientInfo;

        public override string Xrl { get { return "/xbos/GetMediaLicense.ashx"; } }
    }

    public class GetMediaLicenseResponse : XRLObject2
    {
        public HResult resultCode;

        public Guid offerId;

        public uint mediaInstanceIdCount;

        [WireInfo(SizeParam = "mediaInstanceIdCount")]
        public Guid[] mediaInstanceIds;

        public uint licenseLength;

        [WireInfo(SizeParam = "licenseLength")]
        public string license;
    }

    public enum MediaUrlType : int
    {
        Video               = 1,
        VideoChapter        = 2,    // unsupported by XBOX client
        SAMI                = 3,
        Image               = 4,
        Music               = 5,
        GameContent         = 6,
        App                 = 7
    }

    public class TypedMediaUrl : WireData
    {
        public int type;

        [WireInfo(Min=1, Max=500)]
        public uint length;

        [WireInfo(SizeParam="length", NullTerminate=true)]
        public string url;
    }

    public class MediaInstanceUrl : WireData
    {
        [WireInfo(MinSchemaVersion = "4.1")]
        public Guid mediaId;

        public Guid mediaInstanceId;

        [WireInfo(MinSchemaVersion = "4.4")]
        public ulong packageSize;

        [WireInfo(MinSchemaVersion = "4.4")]
        public ulong installSize;

        [WireInfo(MinSchemaVersion = "4.4", ArraySize=(int)XOn.XONLINE_CONTENT_SYMMETRIC_KEY_LEN)]
        public byte[] symKey;

        [WireInfo(MinSchemaVersion = "4.4", ArraySize=(int)XOn.XONLINE_CONTENT_PUBLIC_KEY_LEN)]
        public byte[] pubKey;

        [WireInfo(MinSchemaVersion = "5.1")] // New in Summer 2009
        public uint packageType;

        [WireInfo(Max=10)]
        public uint fileCount;

        [WireInfo(SizeParam="fileCount")]
        public TypedMediaUrl[] urls;
    }

    public class FindMediaInstanceUrlsResponse : XRLObject2
    {
        public uint mediaInstanceIdCount;

        [WireInfo(SizeParam="mediaInstanceIdCount")]
        public MediaInstanceUrl[] mediaInstanceUrls;
    }


    public class XeContentRefreshLicenseRequest : XRLObject2
    {
        public UInt64 userId;

        public UInt64 machineId;

        [WireInfo(Min=1, Max=XOn.XONLINE_CONTENT_LICENSE_MAX_LEN)]
        public UInt16 licenseLength;

        [WireInfo(SizeParam="licenseLength")]
        public byte[] license;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeContentRefreshLicense.ashx";
            }
        }
    }

    public class XeContentRefreshLicenseResponse : XRLObject2
    {
        [WireInfo(Min=1, Max=XOn.XONLINE_CONTENT_LICENSE_MAX_LEN)]
        public UInt16 licenseLength;

        [WireInfo(SizeParam="licenseLength")]
        public byte[] license;
    }

    public class GetTitleActivationListRequest : XRLObject2
    {
        public const uint SIGNATUREFORMAT_LITTLE_ENDIAN = 0;
        public const uint SIGNATUREFORMAT_BIG_ENDIAN    = 1;

        // machinePuid or consoleId?
        [WireInfo(HexString=true)]
        public UInt64 machineId;

        [WireInfo(ArraySize=(int)XOn.XONLINE_MAX_LOGON_USERS, HexString=true)]
        public UInt64[] userIds;

        [WireInfo(HexString=true)]
        public UInt32 nonce;

        [WireInfo(HexString=true)]
        public UInt32 requestedTitleId;

        [WireInfo(Min=0, Max=1)]
        public UInt32 signatureFormat;

        public override string Xrl
        {
            get
            {
                return "/xbos/GetTitleActivationList.ashx";
            }
        }
    }

    public class GetTitleActivationListResponse : XRLObject2
    {
        [WireInfo(ArraySize=(int)XOn.TITLE_ACTIVATION_LIST_SIGNATURE_SIZE)]
        public byte[] signature;

        // Everything below here (the body) is signed

        [WireInfo(HexString=true)]
        public UInt64 machineId;

        [WireInfo(ArraySize=(int)XOn.XONLINE_MAX_LOGON_USERS, HexString=true)]
        public UInt64[] userIds;

        [WireInfo(HexString=true)]
        public UInt32 nonce;

        [WireInfo(Min=0, Max=XOn.TITLE_ACTIVATION_LIST_MAX_LEN)]
        public UInt32 titlesLength;

        [WireInfo(SizeParam="titlesLength")]
        public TitleLicenseInfo[] titles;

        // Not part of protocol...

        public uint GetBodySize()
        {
            return
                + 8
                + (XOn.XONLINE_MAX_LOGON_USERS * 8)
                + 4
                + 4
                + (titlesLength * 8);
        }

    }

    public class TitleLicenseInfo : WireData
    {
        public const uint LicenseFlags_GrantedUser1   = 0x01;
        public const uint LicenseFlags_GrantedUser2   = 0x02;
        public const uint LicenseFlags_GrantedUser3   = 0x04;
        public const uint LicenseFlags_GrantedUser4   = 0x08;
        public const uint LicenseFlags_GrantedMachine = 0x10;

        [WireInfo(HexString=true)]
        public UInt32 titleId;

        [WireInfo(HexString=true)]
        public UInt32 licenseFlags;
    }

    public class XeOfferingVerifyTokenRequest : XRLObject2
    {
        public byte countryId;

        public ushort voucherLength;

        [WireInfo(SizeParam="voucherLength")]
        public string voucher;

        [WireInfo(HexString=true, MinSchemaVersion="4.2")]
        public ulong userPuid = 0;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xbos/XeOfferingVerifyToken.ashx"; }
        }
    }

    public class XeOfferingVerifyTokenResponse : XRLObject2
    {
        public ulong offerId;

        public uint offerTypeId;
    }

    public class XeVerifyTokenRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public ushort billingTokenLength;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken;

        public uint storeId = 1;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeVerifyToken.ashx";
            }
        }
    }

    public class XeXboxOfferInfo : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong offerId;

        public uint offerTypeId;
    }

    public class XeEmsOfferInfo : XRLObject2
    {
        public Guid offerId;

        public Guid mediaId;

        public uint mediaType;
    }

    public class XeVerifyTokenResponse : XRLObject2
    {
        public ushort offerCatalogType;

        public XeXboxOfferInfo xboxOfferInfo = null;

        public XeEmsOfferInfo emsOfferInfo = null;
    }

    public class XeGetRevocationListRequest : XRLObject2
    {
        [WireInfo(ArraySize=(int)XOn.REVOCATION_LIST_CLIENT_NONCE_SIZE)]
        public byte[] clientNonce;

        public override string Xrl
        {
            get { return "/xbos/GetRevocationList.ashx"; }
        }
    }

    public class XeGetRevocationListReply : XRLObject2
    {
        [WireInfo(ArraySize=(int)XOn.REVOCATION_LIST_SIGNATURE_SIZE)]
        public byte[] signature;

        [WireInfo(ArraySize=(int)XOn.REVOCATION_LIST_SERVER_NONCE_SIZE)]
        public byte[] serverNonce;

        [WireInfo(Max=XOn.REVOCATION_LIST_MAX_ENTRIES)]
        public uint numListEntries;

        [WireInfo(SizeParam="numListEntries")]
        public RevocationListEntry[] entries;
    }

    public class RevocationListEntry : XRLObject2
    {
        [WireInfo(ArraySize=(int)XOn.REVOCATION_LIST_ENTRY_DIGEST_SIZE)]
        public byte[] digest;
    }


    public class Asset : WireData
    {
        public uint     assetID;

        public int      quantity;        // signed quantity, may be negative during Consume
    }

    public class AssetEnumerateRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong    userPuid;

        [WireInfo(HexString=true)]
        public ulong    machinePuid;

        [WireInfo(HexString=true)]
        public uint     titleID;

        [WireInfo(MinSchemaVersion = "6.9")]
        public bool signAssets = true;

        public uint     flags;          // unused

        public ushort   startingIndex;

        public ushort   maxResults;

        public override string Xrl
        {
            get
            {
                return "/xbos/AssetEnumerate.ashx";
            }
        }
    }

    // Signable asset structure.
    public class AssetPackage : WireData
    {
        public DateTime  dtAssets;

        public uint     cAssets;

        public uint     cTotalAssets;

        [WireInfo(SizeParam="cAssets")]
        public Asset[]  assets;
    }

    public class AssetEnumerateResponse : XRLObject2
    {
        public const int ASSET_SIGNATURE_SIZE = 256;

        [WireInfo(ArraySize=ASSET_SIGNATURE_SIZE)]
        public byte[]   signature;

        public AssetPackage package;
    }

    public class AssetConsumeRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong    userPuid;

        [WireInfo(HexString=true)]
        public ulong    machinePuid;

        [WireInfo(HexString=true)]
        public uint     titleID;

        [WireInfo(MinSchemaVersion = "6.9")]
        public Guid trackingGuid;

        public uint     cAssets;

        [WireInfo(SizeParam="cAssets")]
        public Asset []  assets;

        public override string Xrl
        {
            get
            {
                return "/xbos/AssetConsume.ashx";
            }
        }
    }

    public class AssetConsumeResponse : XRLObject2
    {

    }

    public class XeWmdrmCreateCertificateRequest : XRLObject2
    {
        public const int DEVICE_PUBLIC_KEY_LEN = 40;

        [WireInfo(Min=0, Max=0)]
        public uint flags;

        [WireInfo(ArraySize=DEVICE_PUBLIC_KEY_LEN)]
        public byte[] devicePublicKey;

        public override string Xrl
        {
            get
            {
                return "/xbos/XeWmdrmCreateCertificate.ashx";
            }
        }
    }

    public class XeWmdrmCreateCertificateReply : XRLObject2
    {
        public const int DEVICE_CERTIFICATE_BLOCK_MAX_COUNT = 2;

        [WireInfo(Min=1, Max=DEVICE_CERTIFICATE_BLOCK_MAX_COUNT)]
        public ushort certBlockCount;

        [WireInfo(SizeParam="certBlockCount")]
        public XeGenericBlock[] certBlocks;
    }

    [WireInfo(MaxSchemaVersion="4.9")]
    public class ContentHistoryEnumerateRequest : XRLObject2WithFlags
    {
        static byte QueryForIsAcquirable = 0x0001;

        [WireInfo(HexString=true)]
        public ulong userPuid; // user's live XUID making the request

        [WireInfo(MinSchemaVersion = "3.0")]
        public ulong machinePuid;

        public byte countryID; // live Country

        public ushort languageID; // live Language

        [WireInfo(HexString=true)]
        public uint offerType; // content OfferTypes, or SyncCastWMIS

        [WireInfo(HexString=true)]
        public byte requestFlags; // isAcquirableOnlyFilter

        public int startingIndex;

        public int maxResults;

        public bool isAcquirableOnlyFilter
        {
            get
            {
                return IsFlagSet(QueryForIsAcquirable, requestFlags);
            }
            set
            {
                SetFlag(QueryForIsAcquirable, value, ref requestFlags);
            }
        }

        public override string Xrl
        {
            get
            {
                return "/xbos/XeContentHistoryEnumerate.ashx";
            }
        }
    }

    public class ContentHistoryEnumerateResponse : XRLObject2
    {
        public ushort offersReturned;

        [WireInfo(SizeParam="offersReturned")]
        public BasicContentHistoryInfo [] infos;

        public uint offersTotal;
    }

    public class BasicContentHistoryInfo : XRLObject2WithFlags
    {
        static ushort IsAcquirable = 0x0001;
        static ushort IsUnrestricted = 0x0002;

        public BasicContentHistoryInfo()
        {
            responseFlags = 0;
        }

        public ulong offerID; // OfferID for Xbox-LIVE true/full Offers

        public ushort offerNameLength;

        [WireInfo(SizeParam="offerNameLength", NullTerminate=true)]
        public string offerName; // Text-Name for the above offerID

        public uint offerType; // content OfferTypes, or SyncCastWMIS

        public uint titleID; // primary TitleID that the Offer belongs to

        public ushort titleNameLength;

        [WireInfo(SizeParam="titleNameLength", NullTerminate=true)]
        public string titleName; // Text-Name for above titleID

        public ushort responseFlags; // isAcquirable, isUnrestricted

        public WMID wmid; // WMIS Guid/Type structure (movie/tv episode/tv season)

        [WireInfo(MinSchemaVersion = "3.0")]
        public bool licenseAcknowledged;

        [WireInfo(MinSchemaVersion = "3.0")]
        public DateTime licenseExpiration;

        [WireInfo(MinSchemaVersion = "3.0")]
        public bool licensedOnMachine;

        public bool isAcquirable
        {
            get
            {
                return IsFlagSet(IsAcquirable, responseFlags);
            }
            set
            {
                SetFlag(IsAcquirable, value, ref responseFlags);
            }
        }

        public bool isUnrestricted
        {
            get
            {
                return IsFlagSet(IsUnrestricted, responseFlags);
            }
            set
            {
                SetFlag(IsUnrestricted, value, ref responseFlags);
            }
        }
    }

    public class InGameOfferPrice : WireData
    {
        public uint paymentType;

        public int price;

        public ushort priceTextLength;

        [WireInfo(SizeParam="priceTextLength", NullTerminate=true)]
        public string priceText;
    }

    public class InGameContentInfo : XRLObject2WithFlags
    {
        static ushort UserHasPurchased          = 0x0001;
        static ushort IsAcquirable              = 0x0002;
        static ushort IsUnrestricted            = 0x0004;
        static ushort IsUnrated                 = 0x0008;

        public InGameContentInfo()
        {
            responseFlags = 0;
        }

        public ulong offerID;

        public ushort offerNameLength;

        [WireInfo(SizeParam="offerNameLength", NullTerminate=true)]
        public string offerName;

        public uint offerType;

        [WireInfo(ArraySize=(int)XOn.XONLINE_CONTENT_ID_LEN)]
        public byte[] contentId;

        public uint licenseMask;

        public uint titleID;

        public uint titleCategory;

        public ushort titleNameLength;

        [WireInfo(SizeParam="titleNameLength", NullTerminate=true)]
        public string titleName;

        public byte tierRequired;

        public ushort emsGameRating;

        public ushort responseFlags; // userHasPurchased, IsAcquirable, isUnrestricted

        public uint packageSize;

        public uint installSize;

        public int sellTextLength;

        [WireInfo(SizeParam="sellTextLength", NullTerminate=true)]
        public string sellText;

        public uint assetID;

        public uint purchaseQuantity;

        public byte pricesLength;

        // NOTE: this parameter is not serialized to the wire.  it is only used for internal calculation.
        [WireInfo(Serialize=false)]
        public System.DateTime maxStartDate;

        // NOTE: this parameter is not serialized to the wire.  it is only used for internal calculation.
        [WireInfo(Serialize=false)]
        public System.Guid emsOfferId;

        [WireInfo(SizeParam="pricesLength")]
        public InGameOfferPrice [] prices;

        public bool userHasPurchased
        {
            get
            {
                return IsFlagSet(UserHasPurchased, responseFlags);
            }
            set
            {
                SetFlag(UserHasPurchased, value, ref responseFlags);
            }
        }

        public bool isAcquirable
        {
            get
            {
                return IsFlagSet(IsAcquirable, responseFlags);
            }
            set
            {
                SetFlag(IsAcquirable, value, ref responseFlags);
            }
        }

        public bool isUnrestricted
        {
            get
            {
                return IsFlagSet(IsUnrestricted, responseFlags);
            }
            set
            {
                SetFlag(IsUnrestricted, value, ref responseFlags);
            }
        }

        public bool isUnrated
        {
            get
            {
                return IsFlagSet(IsUnrated, responseFlags);
            }
            set
            {
                SetFlag(IsUnrated, value, ref responseFlags);
            }
        }
    }



    public class InGameContentEnumerateRequest : XRLObject2WithFlags
    {
        static byte HideUnratedContentFilter    = 0x01;

        [WireInfo(HexString = true)]
        public ulong userPuid;

        [WireInfo(HexString = true)]
        public ulong machinePuid;

        public byte countryID;

        public ushort liveLanguageID;

        [WireInfo(HexString=true)]
        public ushort emsGameRating;

        [WireInfo(HexString=true)]
        public uint offerType; // content, points bundle, gamertag, etc

        public byte tierRequired;

        [WireInfo(HexString=true)]
        public uint titleID;

        [WireInfo(HexString=true)]
        public uint titleCategories;

        [WireInfo(HexString=true)]
        public byte requestFlags; // hideUnratedContentFilter

        [WireInfo(Min = 0, Max = 100, MinSchemaVersion = "5.1")]
        public ushort offerIdsLength;

        [WireInfo(SizeParam = "offerIdsLength", MinSchemaVersion = "5.1")]
        public ulong[] offerIDs;

        [WireInfo(HexString=true, MinSchemaVersion = "5.5")]
        public uint avatarBodyTypes;  // Avatar Body Types

        [WireInfo(Min=0, Max=65535)]
        public int startingIndex;

        [WireInfo(Min=0, Max=65535)]
        public int maxResults;

        public bool hideUnratedContentFilter
        {
            get
            {
                return IsFlagSet(HideUnratedContentFilter, requestFlags);
            }
            set
            {
                SetFlag(HideUnratedContentFilter, value, ref requestFlags);
            }
        }

        public override string Xrl
        {
            get
            {
                return "/xbos/InGameContentEnumerate.ashx";
            }
        }
    }

    public class InGameContentEnumerateResponse : XRLObject2
    {
        public ushort offersReturned;

        [WireInfo(SizeParam="offersReturned")]
        public InGameContentInfo [] infos;

        public uint offersTotal;
    }
    public class InGameContentAvailableRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public byte countryID;

        public ushort liveLanguageID;

        public byte tierRequired;

        [WireInfo(HexString=true)]
        public uint titleID;

        public DateTime lastViewed = DateTime.UtcNow;

        [WireInfo(HexString=true, MinSchemaVersion = "5.5")]
        public uint avatarBodyTypes;  // Avatar Body Types

        public override string Xrl
        {
            get
            {
                return "/xbos/InGameContentAvailable.ashx";
            }
        }
    }

    public class InGameContentAvailableResponse : XRLObject2
    {
        public byte newOffersLength = 32;

        [WireInfo(SizeParam="newOffersLength")]
        public uint [] newOffers;

        public byte totalOffersLength = 32;

        [WireInfo(SizeParam="totalOffersLength")]
        public uint [] totalOffers;
    }

    /// <summary>
    /// Xrl request for Preview Product Purchase API
    /// </summary>
    public class PreviewProductPurchaseRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong userPuid;

        [WireInfo(HexString = true)]
        public ulong machinePuid;

        public uint offersLength;

        [WireInfo(SizeParam = "offersLength")]
        public OfferProductInfo[] offers;

        [WireInfo(HexString = true)]
        public uint paymentType;

        public ushort paymentInstrumentIDLength;

        [WireInfo(SizeParam = "paymentInstrumentIDLength")]
        public string paymentInstrumentID;

        public uint storeId = 1;

        [WireInfo(MinSchemaVersion = "6.6")]
        public ushort billingTokenLength=0;

        [WireInfo(SizeParam = "billingTokenLength", MinSchemaVersion = "6.6")]
        public string billingToken=string.Empty;

        public override string Xrl
        {
            get
            {
                return "/xbos/PreviewProductPurchase.ashx";
            }
        }
    }

    /// <summary>
    /// Offer Product Info class
    /// </summary>
    public class OfferProductInfo : XRLObject2
    {
        public Guid offerId;

        public int productTypeId;
    }

    public class PreviewProductPurchaseResponse : XRLObject2
    {
        public Guid offerId;

        public double offerPrice;

        public PreviewSubscriptionProductInfo previewSubscriptionInfo;

        public int taxTypeId;

        public override string Xrl
        {
            get
            {
                return "/xbos/PreviewProductPurchase.ashx";
            }
        }

    }

    public class PreviewSubscriptionProductInfo : XRLObject2
    {
        public Guid subscriptionId;

        public bool autoRenewal;

        public double nextChargeAmount;

        public DateTime nextChargeDate;

        public double netPrice;

        public double discount;

        public int timeExtendedinMonths;

        public Guid defaultRenewalOfferId = Guid.Empty;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\passport\PassportGetProofTypesRequest.cs ===
//------------------------------------------------------------ 
// Copyright (c) Microsoft Corporation. All rights reserved. 
//------------------------------------------------------------ 

using xonline.common.service;

namespace xonline.common.protocol.passport
{

    public class PassportGetProofTypesRequest : XRLObject2
    {
        /// <summary>
        /// The Xuid of the account that is attempting to perform the operation.
        /// Since the console can have multiple users attached, need to distinguish
        /// which user is making the request.
        /// </summary>
        public Puid userPuid;

        /// <summary>
        /// The console where the user make the request.
        /// </summary>
        public Puid machinePuid;

        public override string Xrl
        {
            get
            {
                return "/xuacs/PassportGetProofTypes.ashx";
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\useraccount\MergeUserEntitlementsRequest.cs ===
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------

using System;
using xonline.common.service;

namespace xonline.common.protocol.useraccount
{
    public class MergeUserEntitlementsRequest : XRLObject2
    {
        public Puid srcUserPuid;
        public Puid destUserPuid;

        public PassportToken signedUserPassportPuidToDrop;
        public PassportToken signedUserPassportPuidToKeep;

        public bool transferPoints;

        public Guid trackingGuid;

        public override string Xrl
        {
            get { return "/xuacs/MergeUserEntitlements.ashx"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\passport\PassportGetProofTypesResponse.cs ===
//------------------------------------------------------------ 
// Copyright (c) Microsoft Corporation. All rights reserved. 
//------------------------------------------------------------ 

using xonline.common.protocol;
using xonline.common.service;

namespace xonline.common.protocol.passport
{
    public class PassportGetProofTypesResponse : XRLObject2
    {
        /// <summary>
        /// Protocol element to hold the array length
        /// </summary>
        public int proofTypesLength;

        /// <summary>
        /// Array of proof types that are tied to the account that can be
        /// queried without knowledge of the password.
        /// </summary>
        [WireInfo(SizeParam = "proofTypesLength")]
        public ProofTypeEnum[] proofTypes;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\useraccount\PreviewSubscriptionInfo.cs ===
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------

using System;

using xonline.common.service;

namespace xonline.common.protocol.useraccount
{
    public class PreviewSubscriptionInfo : XRLObject2
    {
        public Guid offerId;

        [WireInfo(HexString = true)]
        public ulong liveOfferId;

        public ushort instanceIdLength;

        [WireInfo(SizeParam="instanceIdLength")]
        public string instanceId;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\useraccount\PreviewSwitchUserCountryResponse.cs ===
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------

using System;

using xonline.common.service;

namespace xonline.common.protocol.useraccount
{
    public class PreviewSwitchUserCountryResponse : XRLObject2
    {
        [WireInfo(HexString = true)]
        public HResult expectedHResult;

        public ushort subscriptionsToMigrateLength;

        [WireInfo(SizeParam="subscriptionsToMigrateLength")]
        public PreviewSubscriptionInfo[] subscriptionsToMigrate;

        public ushort subscriptionsToCancelLength;

        [WireInfo(SizeParam="subscriptionsToCancelLength")]
        public PreviewSubscriptionInfo[] subscriptionsToCancel;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\proxy\XSigProxy.cs ===
using System;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.protocol;
using xonline.common.service;


namespace xonline.common.proxy
{
    public static class XSigProxy
    {
        public static byte[] GetSignedHeader(uint fileSize, uint fileType, byte[] fileHash)
        {
            HResult hr = HResult.S_OK;

            // Build the request to send to xsig.
            GetSignedHeaderRequest request = new GetSignedHeaderRequest();
            request.fileSize = fileSize;
            request.fileType = fileType;
            request.fileHash = fileHash;

            // Call accross to xsig.
            GetSignedHeaderResponse response = new GetSignedHeaderResponse();
            XRLObject2 xrlo = response;
            hr = XRLUtil.PostXrlRequest(VirtualInterface.xsig_int, request.Xrl, null, request, ref xrlo);

            // Do some error checking on the response.
            if (hr.IsFailure())
            {
                throw new XblException(hr, "Proxy call to xsig failed. Check event viewer for error.");
            }

            if (response.headerSize != response.header.Length)
            {
                throw new XblException(HResult.XONLINE_E_INTERNAL_ERROR,
                    "Actual size of the header returned ({0}) is different than the headerSize returned ({1}). That's fishy.",
                    response.header.Length, response.headerSize);
            }

            return response.header;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\protocol\useraccount\PreviewSwitchUserCountryRequest.cs ===
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------

using System;

using xonline.common.service;

namespace xonline.common.protocol.useraccount
{
    public class PreviewSwitchUserCountryRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public Puid userPuid;

        public byte countryId;

        public int cultureId;

        public override string Xrl
        {
            get { return "/xuacs/PreviewSwitchUserCountry.ashx"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\AAInfo.cs ===
//
// AAInfo.cs aka ActiveAuthInfo
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// This is a class that exposes the ActiveAuth related client data from the 
// ActiveAuthModule / ActiveAuthGateway.  This is only the base class, which holds all the 
// data and has handy accessors.  There are 2 child classes that actually implement the 
// functionality to populate this class. This class can be used in more of a "read-only" 
// context, but cannot populate the LiveXuid, UserInfo, or UserPrivileges fields.
//
// To use this class directly from a standard front door (has Webstore dependency)
//  
//   #using xonline.common.service;
//   ...
//   AAInfo aainfo = AAInfoMiddleTier.Current;
//   ulong puid = aainfo.LiveXuid;
//   ... 
//
// To use this class if your component lives on the internet tier and runns the 
// aamodule.dll in-process:
//
//   #using xonline.common.service;
//   ...
//   AAInfo aainfo = AAInfoInternetTier.Current;
//   ulong puid = aainfo.LiveXuid;
//   ...
//
// To use this class in the "read-only" context:
//
//   #using xonline.common.service;
//   ...
//   AAInfo aainfo = AAInfo.Current;
//   Floken flowToken = aainfo.FlowToken;
//   ...
// 
// To use it indirectly via SGInfo (sorry for the extra step):
//
//   if (SGInfo.IsActiveAuth)
//   {
//       // This check is only necessary if your code doesn't know what tier it is being 
//       // called from, but is still capable of linking against xblsecurity.dll and
//       // Webstore libraries.
//       
//       AAInfo aainfo;
//       if (AAInfo.IsInternetTier)
//       {
//           aainfo = AAInfoInternetTier.Current;
//       }
//       else if (AAInfo.IsMiddleTier)
//       {
//           aainfo = AAInfoMiddleTier.Current;
//       }
//
//       // OR, just do AAInfo.Current for the simpler instance.
//       ...
//   }
//   else
//   {
//       SGInfo sginfo = SGInfo.Current;
//       ...
//   }
//
// You can also do the check
//
//   if (AAInfo.IsActiveAuthAvailable)
//   ...
//
// If your code can run on either the Internet tier or Middle tier, that's odd and should 
// be thought about at length. But if you insist, check the AAInfo.IsInternetTier and 
// AAInfo.IsMiddleTier properties. If you are still in doubt, just use the 
// AAInfoInternetTier class - it will work securely from any tier but incur a perf hit.
//
// Author: kgoodier 6/2007
// Updated: kgoodier 1/2009
//

using System;
using System.Web;
using System.IO;
using System.Net;
using System.Collections;
using System.Collections.Specialized;
using System.Text;
using System.Diagnostics;
using System.ServiceModel;

using xonline.common.mgmt;
using xonline.common.config;

[assembly: XomAreaDefinition(XomAreaName.aainfo)]

namespace xonline.common.service
{

public class AAInfo 
{
    // -------------------------------------------------------------------------
    // Current - this is how a consumer, like a front-door, can retrieve a  
    // previously created/found ActiveAuthInfo for a request.
    // NOTE: This only retrieves the value form the Context, and never creates
    // a new AAInfo
    // -------------------------------------------------------------------------
    public static AAInfo Current
    {
        get
        {
            HttpContextAdapter ctx = HttpContextAdapter.Current;
            AAInfo aa = (AAInfo)null;

            if (ctx != null)
            {
                // @@@ we should probably remove these 3 separate caches and collapse them 
                // to one. There are a few edge cases that still need to be worked out, 
                // namely removing AAInfoMiddleTier and AAInfoInternetTier. Until then, 
                // we'll grab from their caches, but won't put it back there.

                // Location 1/3: MiddleTier cache. It has the most hoops to jump through.
                if (aa == null)
                {
                    aa = (AAInfo)ctx.Items[c_CtxKey_AAInfoCacheMTier];
                }

                // Location 2/3: InternetTier cache.
                if (aa == null)
                {
                    aa = (AAInfo)ctx.Items[c_CtxKey_AAInfoCacheITier];
                }

                // Last chance: the "read-only" version. 
                if (aa == null)
                {
                    aa = (AAInfo)ctx.Items[c_CtxKey_AAInfoCache];
                }

                if (aa != null)
                {
                    return aa;
                }

                // Ok. Not cached. We'll deserialize from the appropriate place, but it 
                // will only be an "AAInfo" instance, so you lose some functionality.  
                // Don't call any of those "Populatexxx" functions.

                aa = new AAInfo();

                if (AAInfo.IsMiddleTier)
                {
                    // In the http headers, which would have come from the 
                    // ActiveAuthGateway.
                    if (!TryMarshallFromHeaders(ctx.Request.Headers, ref aa))
                    {
                        aa = null;
                    }
                }
                else if (AAInfo.IsInternetTier)
                {
                    // In the local context, which would have come from the 
                    // ActiveAuthModule running in our process.
                    if (!TryMarshallFromContext(ctx, ref aa))
                    {
                        aa = null;
                    }
                }

                // Put back in our cache for later use. Note our children won't grab from 
                // here.
                if (aa != null)
                {
                    ctx.Items[c_CtxKey_AAInfoCache] = aa;
                }
            }

            return aa;
        }
    }

    // -------------------------------------------------------------------------
    //
    // Public properties and accessors
    //
    // -------------------------------------------------------------------------

    public string CertDeviceId
    {
        get { return _certDeviceId; }
    }
    
    public string GamerTag
    {
        get { 
            if (null != _xblSamlToken)
                return _xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_gamertag0);
            throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_AAINFO_TOKEN_DATA_NOTFOUND, "GamerTag");
        }
    }
    
    public ulong PassportCId
    {
        get { 
            if (0 == _passportCId && null != _xblSamlToken)
                _passportCId = ulong.Parse(_xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_cid0));
            return _passportCId;
        }
    }
    
    public ulong PassportPuid
    {
        get { 
            if (0 == _passportPuid && null != _xblSamlToken)
                _passportPuid = ulong.Parse(_xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_puid0));
            return _passportPuid;
        }
    }

    public byte PlatformType
    {
        get { 
            if (null != _xblSamlToken)
                return byte.Parse(_xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_platformtype));
            throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_AAINFO_TOKEN_DATA_NOTFOUND, "PlatformType");
        }
    }
    
    public string IpAddressInternet 
    {
        get { 
            return _ipAddressInternet; 
        }
    }

    public DateTime IssueInstant
    {
        get {
            if (null != _xblSamlToken)
            {
                return _xblSamlToken.NotBefore;
            }
            else
                return _issueInstantDateTime;
        }
    }

    public DateTime NotAfter
    {
        get {
            if (null != _xblSamlToken)
                return _xblSamlToken.ValidTo;
            else
                return _notAfterDateTime; 
        }
    }

    public IPAddress OriginatingIP
    {
        get
        {
            if(_originatingIP == null)
            {
                ushort srcPort = 0;
                SGAddressValidator.GetSourceAddress(HttpContextAdapter.Current, ref _originatingIP, ref srcPort);
            }

            return _originatingIP;
        }
    }

    public ulong LiveXuid
    {
        get 
        { 
            if (_liveXuid == null)
            {
                if (null == _xblSamlToken)
                {
                    XomRequestTimeElapsed startTime = new XomRequestTimeElapsed();
                    PopulateLiveXuidFromXCache();
                    if (!IsUserValid)
                    {
                        PopulateLiveXuid(); 
                    }
                    AAInfoCounters.IncLoadXuid(startTime.TimeElapsed * 1000);
                }
                else
                {
                    string value;
                    if ( _xblSamlToken.TryGetAttributeValue(XblSamlToken.name_attribute_xuid0, out value))
                    {
                        _liveXuid = ulong.Parse(value);
                    }
                    else
                    {
                        throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_AAINFO_TOKEN_FIELD_NOTVALID, "LiveXuid");
                    }
                }
            }
            return (ulong)_liveXuid; 
        }
    }

    // Lighter-weight property that only looks at XCache -- currently used in common logging code
    public ulong LiveXuidFromXCache
    {
        get 
        {
            string value;
            ulong xuid = _liveXuid ?? 0;

            if (_liveXuid == null)
            {
                if (null != _xblSamlToken)
                {
                    if (_xblSamlToken.TryGetAttributeValue(XblSamlToken.name_attribute_xuid0, out value))
                    {
                        _liveXuid = xuid = ulong.Parse(value);
                    }
                }
                else
                {
                    XomRequestTimeElapsed startTime = new XomRequestTimeElapsed();
                    PopulateLiveXuidFromXCache();
                    xuid = (ulong) _liveXuid;

                    // reset in edge case where we didn't find the XUID
                    if (_liveXuid == 0)
                        _liveXuid = null;

                    AAInfoCounters.IncLoadXuid(startTime.TimeElapsed * 1000);
                }
            }

            return xuid; 
        }
    }

    // Note: This is one of many user-related fields we can expose for free, but we aren't 
    // now because no one has requested them.  Please keep this in mind.
 
    public byte CountryId
    {
        get 
        {
            if (_countryId == null)
            {
                if (null != _xblSamlToken)  // Did you mean VerifyUserCountryId? Datatypes for CountryId don't match from different AAInfo sources!
                    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_AAINFO_TOKEN_FIELD_NOTVALID, "CountryId");

                XomRequestTimeElapsed startTime = new XomRequestTimeElapsed();
                PopulateUserInfo();
                AAInfoCounters.IncLoadUserInfo(startTime.TimeElapsed * 1000);
            }
            return (byte)_countryId;
        }
    }

    public BitArray UserPrivileges
    {
        get
        {
            if (_userPrivileges == null)
            {
                if (null == _xblSamlToken)
                {
                    XomRequestTimeElapsed startTime = new XomRequestTimeElapsed();
                    PopulateUserPrivileges();
                    AAInfoCounters.IncLoadPrivileges(startTime.TimeElapsed * 1000);
                }
                else
                {
                    PopulateUserPrivilegesFromToken();
                }
            }
            return _userPrivileges;
        }
    }

    public bool HasPrivilege(int privilege)
    {
        return UserPrivileges[privilege];
    }

    public bool IsUserValid
    {
        get { return LiveXuid > 0; }
    }

    public XblSamlToken XblSamlToken
    {
        get { return _xblSamlToken; }
    }

    public Floken FlowToken
    {
        get 
        { 
            return _flowToken; 
        }
    }

    // -------------------------------------------------------------------------
    // IsCached - returns true if AAInfo is available in the local cache, or false if not.
    // -------------------------------------------------------------------------
    public static bool IsCached
    {
        get
        {
            try
            {
                HttpContextAdapter ctx = HttpContextAdapter.Current;

                if (ctx == null)
                    return false;

                if (null != ctx.Items[c_CtxKey_AAInfoCache])
                    return true;

                if (null != ctx.Items[c_CtxKey_AAInfoCacheITier])
                    return true;

                if (null != ctx.Items[c_CtxKey_AAInfoCacheMTier])
                    return true;

                return false;
            }
            catch (Exception)
            {
                return false;
            }
        }
    }

    // -------------------------------------------------------------------------
    // ClearCache - clears the AAInfo.Current AAInfo object from the HttpContext cache.  
    // Bit of a hack to work around an issue with auto-floken-grabbing code.
    // -------------------------------------------------------------------------
    public static void ClearCache()
    {
        HttpContextAdapter.Current.Items[c_CtxKey_AAInfoCache] = null;
    }

    // -------------------------------------------------------------------------
    // IsActiveAuthAvailable - returns true if AAInfo is available somewhere, either in 
    // the httpcontext (from aamodule directly) or in the http headers (from authsg 
    // forwarder).
    // @@@ DOES NOT LOOK AT THE LOCAL CACHE (it should, and we should change that once we 
    // clean up the AAInfoMiddleTier and AAInfoInternetTier mess)
    // -------------------------------------------------------------------------
    public static bool IsActiveAuthAvailable
    {
        get
        {
            return IsInternetTier || IsMiddleTier;
        }
    }

    // -------------------------------------------------------------------------
    // IsInternetTier - returns true if it appears the AAInfo is coming from the Internet 
    // tier, implying you should use AAInfoInternetTier.Current. This is not 100% reliable 
    // but is pretty good.
    // -------------------------------------------------------------------------
    public static bool IsInternetTier
    {
        get
        {
            HttpContextAdapter ctx = HttpContextAdapter.Current;

            // In context? Implies local aamodule --> Internet tier
            if (ctx != null &&
                ctx.Items[c_CtxKey_PassportPuid] != null &&
                ctx.Items[c_CtxKey_IpAddressInternet] != null)
            {
                return true;
            }

            return false;
        }
    }


    // -------------------------------------------------------------------------
    // IsMiddleTier - returns true if it appears the AAInfo is coming from the middle 
    // tier, implying you should use AAInfoMiddleTier.Current. This is not 100% reliable 
    // but is pretty good.
    // -------------------------------------------------------------------------
    public static bool IsMiddleTier
    {
        get
        {
            // In context? Implies local aamodule --> Internet tier. It's possible the 
            // sender could have included an "Authz" http header, so we need to lock this 
            // check down a bit by making sure there is also nothing in the context and 
            // the request didn't come from a real SG.
            try
            {
                HttpContextAdapter ctx = HttpContextAdapter.Current;

                if (ctx != null &&
                    ctx.Request != null &&
                    ctx.Request.Headers[XHttpHdr.AUTHZ] != null &&
                    !IsInternetTier)
                {
                    IPAddress srcIP = null;
                    ushort    srcPort  = 0;
                    SGAddressValidator.GetSourceAddress(ctx, ref srcIP, ref srcPort);

                    if (SGAddressValidator.Check(srcIP, srcPort) == SGAddressValidator.Answer.Yes)
                    {
                        Xom.NtEvent(XEvent.Id.AAINFO_INVALID_REQUEST, 
                            "IsMiddleTier: \"{0}\" header found, but request came from a real SG ({1}:{2}). XRL: {3}",
                            XHttpHdr.AUTHZ, srcIP.ToString(), srcPort, ctx.Request.Url.LocalPath
                    );

                        return false;
                    }

                    // If not from SG, or unknown (xblob case), then we're ok 
                    return true;
                }

                return false;
            }
            catch (Exception)
            {
                return false;
            }
        }
    }

    // -------------------------------------------------------------------------
    //
    // Public validators (SGInfo like)
    //
    // -------------------------------------------------------------------------

    public void VerifyAttribute( string name, Object value )
    {
        bool isValid = false;
        
        if (value is byte)
            isValid = ((byte)value == byte.Parse(_xblSamlToken.GetAttributeValue(name)));
        if (value is ulong)
            isValid = ((ulong)value == ulong.Parse(_xblSamlToken.GetAttributeValue(name)));
        if (value is uint)
        {
            if (XblSamlToken.name_attribute_titleid == name)
                isValid = ((uint)value == uint.Parse(_xblSamlToken.GetAttributeValue(name), System.Globalization.NumberStyles.AllowHexSpecifier));
            else
                isValid = ((uint)value == uint.Parse(_xblSamlToken.GetAttributeValue(name)));
        }
        if (value is int)
            isValid = ((int)value == int.Parse(_xblSamlToken.GetAttributeValue(name)));
        if (value is ushort)
            isValid = ((ushort)value == ushort.Parse(_xblSamlToken.GetAttributeValue(name)));
        if (value is string)
            isValid = ((string)value == _xblSamlToken.GetAttributeValue(name));
        if (!isValid)
        {
            throw new XRLException( HResult.XONLINE_E_AUTHDATA_MISMATCH, XEvent.Id.AAINFO_DATA_VERIFICATION_ERROR, 
                "VerifyAttribute value:" + value.ToString() + " " + name + ":" + _xblSamlToken.GetAttributeValue(name)
                );
        }
    }

    public void VerifyCertDeviceId( string value )
    {
        if (value != _certDeviceId)
        {
            throw new XRLException( HResult.XONLINE_E_AUTHDATA_MISMATCH, XEvent.Id.AAINFO_DATA_VERIFICATION_ERROR, 
                "VerifyCertDeviceId value:" + value.ToString() + " CertDeviceId:" + _certDeviceId
                );
        }
    }

    public void VerifyMachineId( ulong value )
    {
        if (value != ulong.Parse(_xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_machineid)))
        {
            throw new XRLException( HResult.XONLINE_E_AUTHDATA_MISMATCH, XEvent.Id.AAINFO_DATA_VERIFICATION_ERROR, 
                "VerifyMachineId value:" + value.ToString() + " " + XblSamlToken.name_attribute_machineid + ":" + _xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_machineid)
                );
        }
    }

    public void VerifyPassportId( ulong value )
    {
        if (value != PassportPuid)
        {
            throw new XRLException( HResult.XONLINE_E_AUTHDATA_MISMATCH, XEvent.Id.AAINFO_DATA_VERIFICATION_ERROR, 
                "VerifyPassportId value:" + value.ToString() + " PassportPuid:" + ((Puid)PassportPuid).ToString()
                );
        }
    }

    public void VerifyPlatformType( byte value )
    {
        if (value != byte.Parse(_xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_platformtype)))
        {
            throw new XRLException( HResult.XONLINE_E_AUTHDATA_MISMATCH, XEvent.Id.AAINFO_DATA_VERIFICATION_ERROR, 
                "VerifyPlatformType value:" + value.ToString() + " " + XblSamlToken.name_attribute_platformtype + ":" + _xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_platformtype)
                );
        }
    }

    public void VerifyTitleId( uint value )
    {
        if (value != uint.Parse(_xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_titleid), System.Globalization.NumberStyles.AllowHexSpecifier))
        {
            throw new XRLException( HResult.XONLINE_E_AUTHDATA_MISMATCH, XEvent.Id.AAINFO_DATA_VERIFICATION_ERROR, 
                "VerifyTitleId value:" + value.ToString() + " " + XblSamlToken.name_attribute_titleid + ":" + _xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_titleid)
                );
        }
    }

    public void VerifyTitleVersion( uint value )
    {
        if (value != uint.Parse(_xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_titleversion)))
        {
            throw new XRLException( HResult.XONLINE_E_AUTHDATA_MISMATCH, XEvent.Id.AAINFO_DATA_VERIFICATION_ERROR, 
                "VerifyTitleVersion value:" + value.ToString() + " " + XblSamlToken.name_attribute_titleversion + ":" + _xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_titleversion)
                );
        }
    }

    public void VerifyUserCountryId( int value )
    {
        if (value != int.Parse(_xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_country0)))
        {
            throw new XRLException( HResult.XONLINE_E_AUTHDATA_MISMATCH, XEvent.Id.AAINFO_DATA_VERIFICATION_ERROR, 
                "VerifyUserCountryId value:" + value.ToString() + " " + XblSamlToken.name_attribute_country0 + ":" + _xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_country0)
                );
        }
    }

    public void VerifyUserId( ulong value )
    {
        if (value != LiveXuid)
        {
            throw new XRLException( HResult.XONLINE_E_AUTHDATA_MISMATCH, XEvent.Id.AAINFO_DATA_VERIFICATION_ERROR, 
                "VerifyUserId value:" + value.ToString() + " LiveXuid:" + LiveXuid.ToString()
                );
        }
    }

    public void VerifyUserTier( int value )
    {
        if (value != int.Parse(_xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_tier0)))
        {
            throw new XRLException( HResult.XONLINE_E_AUTHDATA_MISMATCH, XEvent.Id.AAINFO_DATA_VERIFICATION_ERROR, 
                "VerifyUserTier value:" + value.ToString() + " " + XblSamlToken.name_attribute_tier0 + ":" + _xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_tier0)
                );
        }
    }

    public void VerifyXblSamlToken()
    {
        if ( null == _xblSamlToken )
        {
            throw new XRLException( HResult.XONLINE_E_AUTHDATA_MISMATCH, XEvent.Id.AAINFO_DATA_VERIFICATION_ERROR, 
                "VerifyXblSamlToken value: NULL"
                );
        }
    }

    static readonly byte[] AAInfoXBancKeyPrefix = new byte[] {
        (byte)'A', (byte)'A', (byte)'I', (byte)'n', (byte)'f', (byte)'o'
    };

    public byte[] AAInfoXBancKey
    {
        get
        {
            MemoryStream ms = new MemoryStream(18);
            BinaryWriter bw = new BinaryWriter(ms);
            bw.Write(AAInfo.AAInfoXBancKeyPrefix);
            bw.Write(ProtocolVersion);  // no collisions for ZDT
            bw.Write(LiveXuid);
            return ms.ToArray();
        }
    }


    // -------------------------------------------------------------------------
    //
    // Private members below here, nothing to see, move along.
    //
    // -------------------------------------------------------------------------

    
    protected UInt32 ProtocolVersion
    {
        // Increment when wire protocol changes!
        get { return WireData.MakeSchemaVersion(2, 1); }
    }

    public bool UseXBanc
    {
        get { return _fUseXBanc; }
        set { _fUseXBanc = value; }
    }

    // -------------------------------------------------------------------------
    // MarshallToHeaders
    //
    // Input for 'headers' should come from WebClient.Headers or HttpRequest.Headers 
    // (HttpContext.Current.Request.Headers). Only used by ActiveAuthGateway.
    // -------------------------------------------------------------------------
    public static void MarshallToHeaders(
        NameValueCollection headers, 
        AAInfo              aa)
    {
        string base64string = aa.ConvertToHttpHeaderValue();
        headers[XHttpHdr.AUTHZ] = base64string;
    }

    // -------------------------------------------------------------------------
    // TryMarshallFromContext
    // -------------------------------------------------------------------------
    public static bool TryMarshallFromContext(
        HttpContext ctx, 
        ref AAInfo  aa)
    {
        return TryMarshallFromContext(new HttpContextAdapter(ctx), ref aa);
    }

    public static bool TryMarshallFromContext(
        HttpContextAdapter ctx,
        ref AAInfo aa)
    {
        ulong?      passportPuid;
        string      ipAddressInternet;
        ulong?      xuid;
        ulong?      passportCId;
        DateTime?   issueInstant;
        DateTime?   notAfter;
        string      certDeviceId;
        string      samlToken;
        string      flowTokenString;
       
        passportPuid      = (ulong?)(ctx.Items[c_CtxKey_PassportPuid]);
        ipAddressInternet = (string)(ctx.Items[c_CtxKey_IpAddressInternet]);
        xuid              = (ulong?)(ctx.Items[c_CtxKey_LiveXuid]);
        passportCId       = (ulong?)(ctx.Items[c_CtxKey_PassportCId]);
        issueInstant      = (DateTime?)(ctx.Items[c_CtxKey_IssueInstantDateTime]);
        notAfter          = (DateTime?)(ctx.Items[c_CtxKey_NotAfterDateTime]);
        certDeviceId      = (string)(ctx.Items[c_CtxKey_certDeviceId]);
        samlToken         = (string)(ctx.Items[c_CtxKey_samlToken]);
        flowTokenString   = (string)(ctx.Items[c_CtxKey_flowToken]);
        
       
        // Passport puid and ip address are required. xuid is optional.
        if (passportPuid == null ||
            ipAddressInternet == null)
        {
            return false;
        }

        aa._passportPuid = (ulong)passportPuid;
        aa._ipAddressInternet = ipAddressInternet;
        if (xuid != null)
        {
            aa._liveXuid = xuid;
        }
        aa._passportCId = (ulong)passportCId;
        aa._issueInstantDateTime = (DateTime)issueInstant;
        aa._notAfterDateTime = (DateTime)notAfter;
        aa._certDeviceId = certDeviceId;
        aa._samlToken = samlToken;
        aa._flowToken = new Floken(flowTokenString);
        if ( 0 < aa._samlToken.Length )
        {
            aa._xblSamlToken = new XblSamlToken( aa._samlToken );
        }
        
        return true;
    }

    // -------------------------------------------------------------------------
    // TryMarshallFromHeaders
    // -------------------------------------------------------------------------
    public static bool TryMarshallFromHeaders(
        NameValueCollection headers, 
        ref AAInfo          aa)
    {
        string base64string = headers[XHttpHdr.AUTHZ];
        if (base64string == null)
        {
            return false;
        }

        aa.ReadFromHttpHeaderValue(base64string);
        return true;
    }

    // -------------------------------------------------------------------------
    // CreateFromAuthZHeader
    // -------------------------------------------------------------------------
    public static AAInfo CreateFromAuthZHeader(
        string              authzHdr)
    {
        AAInfo aa = new AAInfo();
        aa.ReadFromHttpHeaderValue(authzHdr);
        return aa;
    }

    // -------------------------------------------------------------------------
    // BitArrayToIntArray - convert the user privileges from a BitArray to an int[] array. 
    // Useful for serialization and such.
    // -------------------------------------------------------------------------
    public static int[] BitArrayToIntArray(BitArray userPrivileges)
    {
        if (userPrivileges == null)
            return null;

        // I hate using int instead of uint, but the BitArray constructor takes in an int 
        // array, so we're kinda stuck using it.
        int[] privs = new int[(userPrivileges.Length+31) / 32]; // round up
        for (int bit = 0; bit < userPrivileges.Length; bit++)
        {
            if (userPrivileges[bit])
            {
                privs[bit / 32] |= (1 << (bit % 32));
            }
        }
        return privs;
    }


    // -------------------------------------------------------------------------
    // AAInfo default constructor 
    // 
    // Doesn't do much, unlike SGInfo.  
    // -------------------------------------------------------------------------
    protected AAInfo()
    {
        _fUseXBanc = true;

        _passportPuid = 0;
        _ipAddressInternet = null;
        _liveXuid = null;
        _countryId = null;
        _userPrivileges = null;
        _originatingIP = null;
    }

    // -------------------------------------------------------------------------
    // AAInfo marshalling constructor
    //
    // Used by the marshalling code
    // -------------------------------------------------------------------------
    protected AAInfo(ulong passportPuid, string ipAddressInternet)
        : this()
    {
        _passportPuid = passportPuid;
        _ipAddressInternet = ipAddressInternet;
    }


    // -------------------------------------------------------------------------
    // ConvertToHttpHeaderValue - serializes object into a base64 encoded string for use 
    // in an HTTP header.
    // -------------------------------------------------------------------------
    protected string ConvertToHttpHeaderValue()
    {
        MemoryStream ms = new MemoryStream(500); // very rough guess of size
        BinaryWriter bw = new BinaryWriter(ms);

        bw.Write(FullQualifiedName); 
        bw.Write(ProtocolVersion); 
        bw.Write(_passportPuid);
        bw.Write(_ipAddressInternet);
        if (_liveXuid != null)
        {
            bw.Write((ulong)_liveXuid);
        }
        else
        {
            bw.Write((ulong)0);
        }
        bw.Write(_passportCId);
        bw.Write(_issueInstantDateTime.ToBinary());
        bw.Write(_notAfterDateTime.ToBinary());
        bw.Write(_certDeviceId);
        bw.Write(_samlToken);
        _flowToken.Write(bw);

        // we don't write the extra fields. at the moment, the only time we need to 
        // serialize this object is for the authsg to send it to a front door, and in that 
        // case, only the passportPuid and ipAddressInternet are available to the authsg.
        
        return Convert.ToBase64String(ms.ToArray());  // .net call
    }
    
    // -------------------------------------------------------------------------
    // ReadFromHttpHeaderValue - populates object from base64 encoded string that comes 
    // from a HTTP header.
    // -------------------------------------------------------------------------
    protected void ReadFromHttpHeaderValue(string base64string)
    {
        byte[] bytes = Convert.FromBase64String(base64string);
        MemoryStream ms = new MemoryStream(bytes);
        BinaryReader br = new BinaryReader(ms);

        string fullQualifiedName = br.ReadString();  // interesting, but ignored for now
        uint protocolVersion     = br.ReadUInt32();
        //if (protocolVersion > ProtocolVersion)
        //{
        //    throw new Exception(String.Format(
        //        "Version mismatch: Expected name {0}, ver {1}. Got name {2}, ver {3}.",
        //        FullQualifiedName,
        //        ProtocolVersion,
        //        fullQualifiedName,
        //        protocolVersion));
        //}

        _passportPuid            = br.ReadUInt64();
        _ipAddressInternet       = br.ReadString();

        if (protocolVersion >= WireData.MakeSchemaVersion(1, 1))
        {
            ulong xuid           = br.ReadUInt64();
            if (xuid > 0)
            {
                _liveXuid = xuid;
            }

            _passportCId            = br.ReadUInt64();
            _issueInstantDateTime   = DateTime.FromBinary(br.ReadInt64());
            _notAfterDateTime       = DateTime.FromBinary(br.ReadInt64());
            _certDeviceId           = br.ReadString();
            _samlToken              = br.ReadString();

            if ( 0 < _samlToken.Length )
            {
                _xblSamlToken = new XblSamlToken( _samlToken );
            }
        }
        if (protocolVersion >= WireData.MakeSchemaVersion(2, 1))
        {
            _flowToken              = new Floken(br);
        }
        
    }

    // -------------------------------------------------------------------------
    // PopulateLiveXuidFromXCache - look up passport puid in xcache and map to a live 
    // xuid.  
    //
    // Inputs  : _passportPuid
    // Outputs : _liveXuid (will be 0 if lookup failed)
    // -------------------------------------------------------------------------
    protected void PopulateLiveXuidFromXCache()
    {
        _liveXuid = 0;  // never null

        if (PassportPuid == 0)
        {
            Xom.Trace(XomAreaName.aainfo, LogLevel.L_WARNING, "PopulateLiveXuidFromXCache: passportpuid is 0, can't look up user");
            return;
        }

        // if this code appears to be running in a server context, try using
        // XCache to lookup the user puid rather than making a separate stored
        // procedure call to UODB.
        if (HttpContextAdapter.Current != null)
        {
            try
            {
                _liveXuid = XCache.LookupPUID(PassportPuid);
            }
            catch (Exception e)
            {
                // @@@ event here?
                Xom.Trace(XomAreaName.aainfo, LogLevel.L_ERROR, "XCache: XCache exception: " + e.Message);
            }
        }
        if (_liveXuid > 0)
        {
            AAInfoCounters.IncXCacheHits();
            Xom.Trace(XomAreaName.aainfo, LogLevel.L_LOW, 
                     String.Format("XCache: ppuid 0x{0:X} mapped to xuid 0x{1:X}", 
                     PassportPuid, _liveXuid));
        }
        else
        {
            AAInfoCounters.IncXCacheMisses();
            Xom.Trace(XomAreaName.aainfo, LogLevel.L_NORMAL, 
                     String.Format("XCache: ppuid 0x{0:X} not found", 
                     PassportPuid));
        }
    }

    protected void PopulateUserPrivilegesFromToken()
    {
        _userPrivileges = new BitArray(XOn.XONLINE_MAX_PRIVILEGE_ID);
        string userPrivileges;

        if (_xblSamlToken.TryGetAttributeValue(XblSamlToken.name_attribute_privileges0, out userPrivileges))
        {
            string[] privileges = userPrivileges.Split(',');

            foreach (string privilege in privileges)
            {
                _userPrivileges[int.Parse(privilege)] = true;
            }
        }
    }
    
    // -------------------------------------------------------------------------
    // TryGetFromXBanc - try to populate class from the XBanc cache
    //
    // Returns true if succeeded, or false if entry wasn't found in XBanc.
    // -------------------------------------------------------------------------
    protected bool TryGetFromXBanc()
    {
        if (!UseXBanc || !IsUserValid)
        {
            return false;
        }

        XBanc xb = new XBanc();
        byte[] xbancValue;
        HResult hr = xb.Query(AAInfoXBancKey, out xbancValue);

        if (! hr.IsOk())
        {
            // xbanc will log an event for most codes, but not S_FALSE (not found) or 
            // E_INVALIDARG.
            if (hr == HResult.S_FALSE)
            {
                Xom.Trace(XomAreaName.aainfo, LogLevel.L_NORMAL,
                         String.Format("XBanc.Query: LiveXuid 0x{0:X} not found", LiveXuid));
            }
            else if (hr == HResult.E_INVALIDARG)
            {
                // @@@ log event instead of trace
                Xom.Trace(XomAreaName.aainfo, LogLevel.L_ERROR, "XBanc.Query: invalid args!");
            }
            else
            {
                Xom.Trace(XomAreaName.aainfo, LogLevel.L_ERROR, 
                         String.Format("XBanc.Query: failed with hr = {0}", hr));
            }
            AAInfoCounters.IncXBancMisses();
            return false;
        }
        
        Xom.Trace(XomAreaName.aainfo, LogLevel.L_LOW,
                 String.Format("XBanc: found entry for xuid 0x{0:X}.",
                 LiveXuid));

        // Deserialize from xbanc value

        MemoryStream ms = new MemoryStream(xbancValue);
        BinaryReader br = new BinaryReader(ms);

        _countryId = br.ReadByte();
        byte[] privs = br.ReadBytes(XOn.XONLINE_NUM_PRIVILEGE_DWORDS * 4);
        _userPrivileges = new BitArray(privs);
        Debug.Assert(_userPrivileges.Length == XOn.XONLINE_MAX_PRIVILEGE_ID);

        AAInfoCounters.IncXBancHits();
        return true;
    }

    // -------------------------------------------------------------------------
    // PutToXBanc - cache ourself to XBanc
    //
    // Returns true if successfully inserted into XBanc, or false if an error occurred.
    // -------------------------------------------------------------------------
    protected bool PutToXBanc()
    {
        if (!UseXBanc)
        {
            return false;
        }

        // Serialize to xbanc value

        MemoryStream ms = new MemoryStream(50);
        BinaryWriter bw = new BinaryWriter(ms);

        bw.Write(CountryId);
        int[] privs = BitArrayToIntArray(UserPrivileges);
        Debug.Assert(privs.Length == XOn.XONLINE_NUM_PRIVILEGE_DWORDS);
        for (int i = 0; i < privs.Length; i++)
        {
            bw.Write(privs[i]);
        }
        
        byte[] xbancValue = ms.ToArray();
       
        XBanc xb = new XBanc();
        uint expirationTimeInSeconds = Config.GetUIntSetting(Setting.aainfo_xbancExpirationInSeconds);
        HResult hr = xb.Insert(
            AAInfoXBancKey,
            xbancValue,
            expirationTimeInSeconds,    // absolute time
            0);                         // sliding time

        if (hr != HResult.S_OK)
        {
            if (hr == HResult.S_FALSE || hr == HResult.E_ACCESSDENIED)
            {
                Xom.Trace(XomAreaName.aainfo, LogLevel.L_NORMAL,
                         String.Format("Xbanc.SetData: data already existed for LiveXuid 0x{0:X}", LiveXuid));
                // entry IS there, we just didn't put it there.
                return true;
            }
            else if (hr == HResult.E_INVALIDARG)
            {
                // @@@ log event instead of trace
                Xom.Trace(XomAreaName.aainfo, LogLevel.L_ERROR, "XBanc.SetData: invalid args!");
            }
            else
            {
                Xom.Trace(XomAreaName.aainfo, LogLevel.L_ERROR,
                         String.Format("XBanc.SetData: failed with hr = {0}", hr));
            }
            return false;
        }

        return true;
    }


    // -------------------------------------------------------------------------
    //
    // Constants used internally. Don't reference them unless your name is 
    // ActiveAuthModule.
    //
    // -------------------------------------------------------------------------

    public const string c_CtxKey_PassportPuid         = "AAInfo_PassportPuid";
    public const string c_CtxKey_IpAddressInternet    = "AAInfo_IpAddressInternet";
    public const string c_CtxKey_LiveXuid             = "AAInfo_LiveXuid";
    public const string c_CtxKey_PassportCId          = "AAInfo_PassportCId";
    public const string c_CtxKey_NotAfterDateTime     = "AAInfo_NotAfterDateTime";
    public const string c_CtxKey_IssueInstantDateTime = "AAInfo_IssueInstantDateTime";
    public const string c_CtxKey_certDeviceId         = "AAInfo_certDeviceId";
    public const string c_CtxKey_samlToken            = "AAInfo_samlToken";
    public const string c_CtxKey_flowToken            = "AAInfo_flowToken";
    public const string c_CtxKey_AAInfoCacheITier     = "AAInfo_CacheCurrentInternetTier";
    public const string c_CtxKey_AAInfoCacheMTier     = "AAInfo_CacheCurrentMiddleTier";
    public const string c_CtxKey_AAInfoCache          = "AAInfo_CacheCurrent";

    protected string FullQualifiedName
    {
        get { return this.GetType().AssemblyQualifiedName; } 
    }


    // -------------------------------------------------------------------------
    //
    // Private members for holding state
    //
    // -------------------------------------------------------------------------

    protected bool          _fUseXBanc;

    // Native properties
    //
    // These come from ActiveAuthModule

    protected ulong         _passportPuid;
    protected string        _ipAddressInternet;
    protected ulong         _passportCId;
    protected DateTime      _notAfterDateTime;
    protected DateTime      _issueInstantDateTime;
    protected string        _certDeviceId;
    protected string        _samlToken;
    protected XblSamlToken  _xblSamlToken;
    protected Floken        _flowToken = Floken.None;

    // AuthSG ip when MiddleTier, otherwise an External IP
    protected IPAddress     _originatingIP;

    // Extended properties
    //
    // We have to look these up. We do it on-demand.

    protected ulong?        _liveXuid;
    protected int?          _countryId;
    protected BitArray      _userPrivileges;

    // -------------------------------------------------------------------------
    //
    // Virtual methods, to be implemented by the children.
    //
    // We'll provide no implementation so that we can still use AAInfo in a "read-only" 
    // manner, but you can't call these methods.
    //
    // -------------------------------------------------------------------------

    virtual protected void PopulateLiveXuid()
    {
        throw new NotImplementedException("Not implemented in AAInfo. Please use AAInfoMiddlerTier or AAInfoInternetTier.");
    }

    virtual protected void PopulateUserInfo()
    {
        throw new NotImplementedException("Not implemented in AAInfo. Please use AAInfoMiddlerTier or AAInfoInternetTier.");
    }

    virtual protected void PopulateUserPrivileges()
    {
        throw new NotImplementedException("Not implemented in AAInfo. Please use AAInfoMiddlerTier or AAInfoInternetTier.");
    }

    // -------------------------------------------------------------------------
    //
    // Override(s).
    //
    // -------------------------------------------------------------------------

    public override string ToString()
    {
        try
        {
            StringBuilder bldr = new StringBuilder();

            bldr.Append("InternetIP:  ");
            bldr.Append(IpAddressInternet.ToString());
            bldr.Append("\r\nOriginatingIP:    ");
            bldr.Append(OriginatingIP.ToString());
            bldr.Append("\r\nPassportPuid:   0x");
            bldr.Append(PassportPuid.ToString("X"));
            bldr.Append("\r\nLiveXuid:  0x");
            bldr.Append(LiveXuidFromXCache.ToString("X"));

            if(_countryId != null)
            {
                bldr.Append("\r\nCountryId:   ");
                bldr.Append(((int)_countryId).ToString());
            }

            return bldr.ToString();
        }
        catch(Exception e)
        {
            return "Error building AAInfo.ToString(): " + e.ToString();
        }
    }

}


[XomPerformanceCounterCategoryAttr( "AAInfo", "Xbox Live Active Auth Info", true )]
public class AAInfoCounters : XomPerformanceCounterCategory
{
    // Rate: Load Privileges
    // Rate: Load UserInfo
    // Rate: Load Xuid
    // Rate: XBanc AAInfo hits
    // Rate: XBanc AAInfo misses
    // Rate: XCache Xuid hits
    // Rate: XCache Xuid misses
    // Time: Avg Load Privileges (ms)
    // Time: Avg Load UserInfo (ms)
    // Time: Avg Load Xuid (ms)
    // Total: Load Privileges
    // Total: Load UserInfo
    // Total: Load Xuid
    // Total: XBanc AAInfo hits
    // Total: XBanc AAInfo misses
    // Total: XCache Xuid hits
    // Total: XCache Xuid misses
    
    [XomPerformanceCounterAttr(
        "Rate: Load Privileges",
        "Load Privileges calls per second",
         PerformanceCounterType.RateOfCountsPerSecond32)]
    public PerformanceCounter RateLoadPrivileges;

    [XomPerformanceCounterAttr(
        "Rate: Load UserInfo",
        "Load UserInfo calls per second",
         PerformanceCounterType.RateOfCountsPerSecond32)]
    public PerformanceCounter RateLoadUserInfo;

    [XomPerformanceCounterAttr(
        "Rate: Load Xuid",
        "Load Xuid calls per second",
         PerformanceCounterType.RateOfCountsPerSecond32)]
    public PerformanceCounter RateLoadXuid;

    [XomPerformanceCounterAttr(
        "Rate: XBanc AAInfo hits",
        "XBanc AAInfo hits calls per second",
         PerformanceCounterType.RateOfCountsPerSecond32)]
    public PerformanceCounter RateXBancHits;

    [XomPerformanceCounterAttr(
        "Rate: XBanc AAInfo misses",
        "XBanc AAInfo misses calls per second",
         PerformanceCounterType.RateOfCountsPerSecond32)]
    public PerformanceCounter RateXBancMisses;

    [XomPerformanceCounterAttr(
        "Rate: XCache Xuid hits",
        "XCache Xuid hits calls per second",
         PerformanceCounterType.RateOfCountsPerSecond32)]
    public PerformanceCounter RateXCacheHits;

    [XomPerformanceCounterAttr(
        "Rate: XCache Xuid misses",
        "XCache Xuid misses calls per second",
         PerformanceCounterType.RateOfCountsPerSecond32)]
    public PerformanceCounter RateXCacheMisses;


    [XomPerformanceCounterAttr(
        "Time: Avg Load Privileges (ms)",
        "Average time to load privileges, in milliseconds",
         PerformanceCounterType.AverageTimer32)]
    public PerformanceCounter TimeLoadPrivileges;

    [XomPerformanceCounterAttr(
        "Time: Avg Load Privileges (base)",
        "Avg Load Privileges (base)",
         PerformanceCounterType.AverageBase)]
    public PerformanceCounter TimeLoadPrivilegesBase;

    [XomPerformanceCounterAttr(
        "Time: Avg Load UserInfo (ms)",
        "Average time to load userinfo, in milliseconds",
         PerformanceCounterType.AverageTimer32)]
    public PerformanceCounter TimeLoadUserInfo;

    [XomPerformanceCounterAttr(
        "Time: Avg Load UserInfo (base)",
        "Avg Load UserInfo (base)",
         PerformanceCounterType.AverageBase)]
    public PerformanceCounter TimeLoadUserInfoBase;

    [XomPerformanceCounterAttr(
        "Time: Avg Load Xuid (ms)",
        "Average time to load xuid, in milliseconds",
         PerformanceCounterType.AverageTimer32)]
    public PerformanceCounter TimeLoadXuid;
    
    [XomPerformanceCounterAttr(
        "Time: Avg Load Xuid (base)",
        "Avg Load Xuid (base)",
         PerformanceCounterType.AverageBase)]
    public PerformanceCounter TimeLoadXuidBase;


    [XomPerformanceCounterAttr(
        "Total: Load Privileges",
        "Load Privileges total calls",
         PerformanceCounterType.NumberOfItems64)]
    public PerformanceCounter TotalLoadPrivileges;

    [XomPerformanceCounterAttr(
        "Total: Load UserInfo",
        "Load UserInfo total calls",
         PerformanceCounterType.NumberOfItems64)]
    public PerformanceCounter TotalLoadUserInfo;

    [XomPerformanceCounterAttr(
        "Total: Load Xuid",
        "Load Xuid total calls",
         PerformanceCounterType.NumberOfItems64)]
    public PerformanceCounter TotalLoadXuid;

    [XomPerformanceCounterAttr(
        "Total: XBanc AAInfo hits",
        "XBanc AAInfo hits total calls",
         PerformanceCounterType.NumberOfItems64)]
    public PerformanceCounter TotalXBancHits;

    [XomPerformanceCounterAttr(
        "Total: XBanc AAInfo misses",
        "XBanc AAInfo misses total calls",
         PerformanceCounterType.NumberOfItems64)]
    public PerformanceCounter TotalXBancMisses;

    [XomPerformanceCounterAttr(
        "Total: XCache Xuid hits",
        "XCache Xuid hits total calls",
         PerformanceCounterType.NumberOfItems64)]
    public PerformanceCounter TotalXCacheHits;

    [XomPerformanceCounterAttr(
        "Total: XCache Xuid misses",
        "XCache Xuid misses total calls",
         PerformanceCounterType.NumberOfItems64)]
    public PerformanceCounter TotalXCacheMisses;

    static public AAInfoCounters Counters = new AAInfoCounters();

    static public void IncLoadPrivileges(long elapsedTime)
    {
        Counters.RateLoadPrivileges.Increment();
        Counters.TotalLoadPrivileges.Increment();
        Counters.TimeLoadPrivileges.IncrementBy(elapsedTime);
        Counters.TimeLoadPrivilegesBase.Increment();
    }

    static public void IncLoadUserInfo(long elapsedTime)
    {
        Counters.RateLoadUserInfo.Increment();
        Counters.TotalLoadUserInfo.Increment();
        Counters.TimeLoadUserInfo.IncrementBy(elapsedTime);
        Counters.TimeLoadUserInfoBase.Increment();
    }

    static public void IncLoadXuid(long elapsedTime)
    {
        Counters.RateLoadXuid.Increment();
        Counters.TotalLoadXuid.Increment();
        Counters.TimeLoadXuid.IncrementBy(elapsedTime);
        Counters.TimeLoadXuidBase.Increment();
    }

    static public void IncXBancHits()
    {
        Counters.RateXBancHits.Increment();
        Counters.TotalXBancHits.Increment();
    }

    static public void IncXBancMisses()
    {
        Counters.RateXBancMisses.Increment();
        Counters.TotalXBancMisses.Increment();
    }

    static public void IncXCacheHits()
    {
        Counters.RateXCacheHits.Increment();
        Counters.TotalXCacheHits.Increment();
    }

    static public void IncXCacheMisses()
    {
        Counters.RateXCacheMisses.Increment();
        Counters.TotalXCacheMisses.Increment();
    }


}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\AvatarManifest.cs ===
﻿using System;
using System.IO;
using xonline.common.config;

namespace xonline.common.service
{
    public class AvatarManifest : WireData
    {
        // A note about byte ordering:
        // This structure is generally manipulated on an Xbox 360 and sent to
        // the service as a byte stream (varbinary(1000)). So integer members are
        // generally stored in the byte stream in big-endian format.

        // *********
        // XDK classes
        // *********

        // ARGB Color; 8-8-8-8 bit unsigned normalized integer components packed into
        // a 32 bit integer.  The normalized color is packed into 32 bits using 8 bit
        // unsigned, normalized integers for the alpha, red, green, and blue components.
        // The alpha component is stored in the most significant bits and the blue
        // component in the least significant bits (A8R8G8B8):
        // [32] aaaaaaaa rrrrrrrr gggggggg bbbbbbbb [0]
        public class XMCOLOR : WireData
        {
            // note: C# doesn't have unions, so we just keep the uint
            [WireInfo(BigEndian = false)]
            public uint c;
        }

        public enum XAVATAR_COMPONENT_MASK : ushort
        {
            None        = 0x0000,
            Head        = 0x0001,
            Body        = 0x0002,
            Hair        = 0x0004,
            Shirt       = 0x0008,
            Trousers    = 0x0010,
            Shoes       = 0x0020,
            Hat         = 0x0040,
            Gloves      = 0x0080,
            Glasses     = 0x0100,
            Wristwear   = 0x0200,
            Earrings    = 0x0400,
            Ring        = 0x0800,
            Carryable   = 0x1000,
            All         = 0x1FFF
        }

        public enum XAVATAR_COMPONENT
        {
             Head       =  0,
             Body       =  1,
             Hair       =  2,
             Shirt      =  3,
             Trousers   =  4,
             Shoes      =  5,
             Hat        =  6,
             Gloves     =  7,
             Glasses    =  8,
             Wristwear  =  9,
             Earrings   = 10,
             Ring       = 11,
             Carryable  = 12,
             Count      = 13,
             ForceDWORD = 0x7fffffff
        }

        public class XAVATAR_COMPONENT_INFO : WireData
        {
            [WireInfo(SerializeAs = typeof(Guid), BigEndian = true)]
            public AvatarAssetId            ModelAssetId;

            [WireInfo(BigEndian = true)]
            public ushort ComponentMask;

            public ushort padding;

            [WireInfo(ArraySize = 3)]
            public XMCOLOR[]                CustomColors = new XMCOLOR[3];
        }

        const int CONSOLE_ID_SIZE = 5;

        // *********
        // supporting enums and classes
        // *********

        // Scoped enumeration of blend shapes that can be applied to an 
        // avatar model after loading.
        public enum Shape_e
        {
            Chin = 0,
            Nose,
            Ear,
            Count
        };

        // Scoped enumeration of dynamic textures that can be applied to an
        // avatar model after loading.
        public enum Texture_e
        {
            Mouth = 0,
            Eye,
            EyeBrow,
            FacialHair,
            EyeShadow,
            SkinFeatures,
            Count
        };

        // Scoped enumeration of dynamic colors that can be applied to an
        // avatar model using pixel shader constants.
        public enum Color_e
        {
            Skin = 0,
            Hair,
            Mouth,
            Iris,
            EyeBrow,
            EyeShadow,
            FacialHair,
            SkinFeatures1,
            SkinFeatures2,
            Count
        };

        // A 2d scale, rotation, translation matrix representing the exact
        // placement of a dynamic texture on the avatar.
        public class TexturePlacement_c : WireData
        {
            [WireInfo(BigEndian = true)]
            public float                Scale;
            [WireInfo(BigEndian = true)]
            public float Rotation;
            [WireInfo(BigEndian = true, ArraySize = 2)]
            public float[]              Translation = new float[2];
        };

        // Structure defining a single replacement texture, including the
        // the asset to replace it with, and placement of the texture.
        public class ReplacementTexture_c : WireData
        {
            [WireInfo(SerializeAs = typeof(Guid), BigEndian = true)]
            public AvatarAssetId        TextureAssetId;
            public TexturePlacement_c   Placement;
        };

        // Structure defining a single blend-shape to be applied to the
        // asset after download.
        public class BlendShape_c : WireData
        {
            [WireInfo(SerializeAs = typeof(Guid), BigEndian = true)]
            public AvatarAssetId        BlendShapeAssetId;
        };

        // *********
        // the data
        // *********

        [WireInfo(BigEndian = true)]
        public uint Version;

        // Finally we begin the actual data members. First the weight and
        // height factors for the avatar. These will be applied to the 
        // skeleton to make it fatter/thinner and taller/shorter.
        [WireInfo(BigEndian = true)]
        public float                    WeightFactor;
        [WireInfo(BigEndian = true)]
        public float                    HeightFactor;

        // Next, identifiers for blend-shape assets that are be applied to
        // this model after it has downloaded. The order of this array
        // corresponds exactly to the Shape_e enumeration above.
        [WireInfo(ArraySize = (int)Shape_e.Count)]
        public BlendShape_c[]           BlendShapes = new BlendShape_c[(int)Shape_e.Count];
        
        // A list of replacement textures to be applied to the model after
        // it has downloaded, including the asset to replace it with, and
        // placement of that texture. The order of this array corresponds
        // exactly to the Texture_e enumeration above.
        [WireInfo(ArraySize = (int)Texture_e.Count)]
        public ReplacementTexture_c[]   ReplacementTextures = new ReplacementTexture_c[(int)Texture_e.Count];

        // A list of dynamic color attributes for the avatar model. These
        // are implemented as pixel shader constants. The order of this
        // array corresponds exactly to the Color_e enumeration above.
        [WireInfo(ArraySize = (int)Color_e.Count)]
        public XMCOLOR[]                DynamicColors = new XMCOLOR[(int)Color_e.Count];
        
        // Next the component info for the body and head components. These
        // must always be present, and so are listed here explicitly.
        public XAVATAR_COMPONENT_INFO   BodyComponentInfo;
        public XAVATAR_COMPONENT_INFO   HeadComponentInfo;

        // Next, the additional component info for all other assets to
        // be associated with the avatar, such as shirts, shoes, etc.
        [WireInfo(ArraySize = (int)XAVATAR_COMPONENT.Count)]
        public XAVATAR_COMPONENT_INFO[] ComponentInfo = new XAVATAR_COMPONENT_INFO[(int)XAVATAR_COMPONENT.Count];

        // Finally, an array of previous, exact assets that match
        // each component mask. These are used as fall-back assets
        // when we need to put an asset on to a slot, but don't
        // have a user selection to use. To avoid running out of
        // space in the manifest, we only store 4 components; the
        // exact components tracked are determined by whoever
        // first writes the manifest (but atm are shoes, trousers,
        // shirt and hair)
        [WireInfo(ArraySize = 4)]
        public XAVATAR_COMPONENT_INFO[] PreviousRequiredComponentInfo = new XAVATAR_COMPONENT_INFO[4];

        // We track the XUID of the manifest's owner so that during
        // asset retrieval we can figure out if we can read the
        // asset from the user's profile.  If there is no valid XUID,
        // we just fall back to our other methods of asset retrieval.
        [WireInfo(BigEndian = true)]
        public Puid                     OwnerXuid;

        // This is a runtime setting that we write into the manifest when
        // it is read locally.  This allows the avatar core to know if
        // the manifest is for a local user (even if they are not
        // signed in).
        [WireInfo(ArraySize = CONSOLE_ID_SIZE)]
        public byte[]                   SrcConsoleId;

        public static AvatarManifest Read(byte[] bytes)
        {
            if (bytes == null)
            {
                return null;
            }

            AvatarManifest manifest = new AvatarManifest();

            MemoryStream stream = new MemoryStream(bytes, false);

            manifest.ReadStream(stream);

            return manifest;
        }

        // When we're converting the manifest back to bytes, we need to serialize the data
        // to bytes, then pad it with 0 bytes to make the length correct (1000).
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            long beginPosition = binaryWriter.BaseStream.Position;

            base.WriteStream(binaryWriter);

            while (binaryWriter.BaseStream.Position < beginPosition + XOn.XONLINE_MAX_SETTING_VALUE_BYTES)
            {
                binaryWriter.Write((byte)0);
            }

            if (binaryWriter.BaseStream.Position - beginPosition != XOn.XONLINE_MAX_SETTING_VALUE_BYTES)
            {
                throw new ApplicationException(string.Format("AvatarManifest serialized length is incorrect. Expected {0} bytes, length is {1} bytes", XOn.XONLINE_MAX_SETTING_VALUE_BYTES, binaryWriter.BaseStream.Position - beginPosition));
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\AccelerationProxy.cs ===
using System;
using System.IO;
using System.Collections;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Diagnostics;

using xonline.common.config;
using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.AccelerationProxy)]
    
namespace xonline.common.service
{
    public class Acceleration
    {
        protected static uint m_dwMaxKeyLength;

        internal AccelerationConnectionCluster _cluster;
        public string InterfaceName
        {
            get
            {
                return _cluster.InterfaceName;
            }
        }

        public delegate void AccelerationNotificationHandler(byte[][] keys);
        public delegate void AccelerationNotificationFailureHandler();
        
        static Acceleration()
        {
            // config setting change handler.
            Config.SettingChange += new SettingChangeEventHandler(Acceleration.ChangeSetting);
            m_dwMaxKeyLength = Config.GetUIntSetting(Setting.acceleration_max_key_length);
        }

        public Acceleration(string iface)
        {
            _cluster = AccelerationConnectionCluster.BuildCluster(iface);
        }

        public void RegisterNotificationHandler(AccelerationNotificationHandler notificationCallback)
        {
            _cluster.RegisterNotificationHandler(notificationCallback);
        }

        public void RegisterNotificationFailureHandler(AccelerationNotificationFailureHandler failureCallback)
        {
            _cluster.RegisterNotificationFailureHandler(failureCallback);
        }

        public void UnregisterHandlers()
        {
            _cluster.UnregisterHandlers();
        }
                
        public static bool CompareByteArrays(byte[] array1, byte[] array2)
        {
            if (array1 == null) return (array2 == null);
            if (array2 == null) return false;
            if (array1.Length != array2.Length) return false;
            for (int i = 0; i < array1.Length; i++)
            {
                if (array1[i] != array2[i]) return false;
            }
            return true;
        }

        public bool ValidateKey(byte[] key)
        {
            /* TODO: add this to enforce that users call Init() before anything else.
            if (!m_fInitialized)
            {
                Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_NOT_INITIALIZED, "AccelerationProxy accessed without being initialized.  Did you forget to call Acceleration.Init() in your startup code?");
                return false;
            }
            */
            
            if ((key == null) ||
                (key.Length == 0) ||
                (key.Length > m_dwMaxKeyLength))
            {
                return false;
            }

            return true;
        }

        public bool ValidateValue(byte[] value)
        {
            if ((value == null) ||
                (value.Length == 0))
            {
                return false;
            }

            return true;
        }
        
        protected uint HashKeyToBucket(byte[] key)
        {
            uint sum = 0;
            for (int i = 0; i < key.Length; i++)
            {
                sum += (uint)key[i];
            }

            return sum % _cluster.GetNumBuckets();
        }

        public static uint GetExtendedError(Exception e, byte[] rgbStream)
        {
            if (e is XRLException)
            {
                XRLException xrle = (XRLException)e;
                
                // check for a failure code from the inh server.
                if ((xrle.HResult == HResult.XONLINE_E_END_OF_STREAM) &&
                    (rgbStream != null))
                {
                    try
                    {
                        AccelerationEmptyResponse response = new AccelerationEmptyResponse();
                        response.ReadBytes(rgbStream);

                        // return the hr from the server.
                        return response.hr;
                    }
                    catch (Exception)
                    {
                        // couldnt get anything more.  we can eat this exception.
                    }
                }

                Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_REQUEST_FAILED, xrle, "Acceleration caught an XRLException (via GetExtendedError)");

                // return exception failure.
                return xrle.HResult;
            }
            else
            {
                Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_REQUEST_FAILED, e, "Acceleration caught an exception (via GetExtendedError)");
                
                // generic send failure.
                return HResult.E_ABORT;
            }
        }
        
        public uint Query(byte[] key, out byte[] value)
        {
            uint validSeconds;
            uint version;
            return Query(key, out value, out validSeconds, out version);
        }

        public uint Query(byte[] key, out byte[] value, out uint validSeconds)
        {
            uint version;
            return Query(key, out value, out validSeconds, out version);
        }

        public uint Query(byte[] key, out byte[] value, out uint validSeconds, out uint version)
        {
            uint[] rgValidSeconds;
            uint[] rgVersions;
            byte[][] values;
            uint[] retVals;

            retVals = Query(new byte[][]{key}, out values, out rgValidSeconds, out rgVersions);

            value = values[0];
            validSeconds = rgValidSeconds[0];
            version = rgVersions[0];
            return retVals[0];
         }

        public uint[] Query(byte[][] keys, out byte[][] values, out uint[] validSeconds)
        {
            uint[] rgVersions;
            return Query(keys, out values, out validSeconds, out rgVersions);
        }
        
        public uint[] Query(byte[][] keys, out byte[][] values, out uint[] validSeconds, out uint[] versions)
        {
            values = null;
            validSeconds = null;
            versions = null;
            
            if ((keys == null) || (keys.Length == 0))
            {
                return null;
            }

            uint[] retVals = new uint[keys.Length];
            validSeconds = new uint[keys.Length];
            versions = new uint[keys.Length];
            values = new byte[keys.Length][];

            // If the client has requested that all acceleration queries fail,
            // then don't even bother with the real query.
            if (XbancMiss.HandleBehaviorInjectionQuery(retVals))
            {
                return retVals;
            }

            AccelerationContext context = new AccelerationContext(keys.Length);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                // assume failure for each key until proven otherwise.
                retVals[iKey] = HResult.E_ABORT;
                
                if (!ValidateKey(keys[iKey]))
                {
                    retVals[iKey] = HResult.E_INVALIDARG;
                    continue;
                }
                
                AccelerationQueryRequest request = new AccelerationQueryRequest();
                request.rgbKey = keys[iKey];
                context.AddRequest(iKey, HashKeyToBucket(keys[iKey]), request);
            }

            _cluster.SendContext(context);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if (context._wtObjects[iKey] == null)
                {
                    // we never sent this key to acceleration.  it likely has a prior success/error code from above.
                    continue;
                }
                else if (context._wtObjects[iKey]._response == null)
                {
                    // we got nothing back from acceleration.
                    retVals[iKey] = HResult.E_ABORT;
                }
                else
                {
                    try
                    {
                        // parse the response.
                        AccelerationQueryResponse response = new AccelerationQueryResponse();
                        response.ReadBytes(context._wtObjects[iKey]._response);

                        values[iKey] = response.rgbValue;
                        validSeconds[iKey] = response.dwValidSeconds;
                        versions[iKey] = response.dwVersion;
                        retVals[iKey] = response.hr;
                    }
                    catch (Exception e)
                    {
                        retVals[iKey] = GetExtendedError(e, context._wtObjects[iKey]._response);
                    }
                }
            }
            
            return retVals;
        }

        public uint Insert(byte[] key, byte[] value)
        {
            uint[] retVals = Insert(new byte[][]{key}, new byte[][]{value}, new uint[]{0}, new uint[]{0});
            return retVals[0];
        }

        public uint Insert(byte[] key, byte[] value, uint absoluteSeconds, uint slidingSeconds)
        {
            uint[] retVals = Insert(new byte[][]{key}, new byte[][]{value}, new uint[]{absoluteSeconds}, new uint[]{slidingSeconds});
            return retVals[0];
        }

        public uint[] Insert(byte[][] keys, byte[][] values, uint[] absoluteExpiries, uint[] slidingExpiries)
        {
            if (keys == null)
            {
                return null;
            }
            
            // Insert is now identical to SetData with version = 0.
            uint[] versions = new uint[keys.Length];
            return SetData(keys, values, absoluteExpiries, slidingExpiries, versions);
        }

        public uint Remove(byte[] key)
        {
            uint[] retVals = Remove(new byte[][]{key});
            return retVals[0];
        }

        public uint[] Remove(byte[][] keys)
        {
            if ((keys == null) || (keys.Length == 0))
            {
                return null;
            }

            uint[] retVals = new uint[keys.Length];

            AccelerationContext context = new AccelerationContext(keys.Length);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if (!ValidateKey(keys[iKey]))
                {
                    retVals[iKey] = HResult.E_INVALIDARG;
                }
                else
                {
                    AccelerationRemoveRequest request = new AccelerationRemoveRequest();
                    request.rgbKey = keys[iKey];
                    request.fMatchExact = true;
                    context.AddRequest(iKey, HashKeyToBucket(keys[iKey]), request);
                }
            }

            _cluster.SendContext(context);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if ((context._wtObjects[iKey] == null) ||
                    (context._wtObjects[iKey]._response == null))
                {
                    // prior error?
                    if (retVals[iKey] == 0)
                    {
                        retVals[iKey] = HResult.E_ABORT;
                    }
                }
                else
                {
                    try
                    {
                        // parse the response.
                        AccelerationRemoveResponse response = new AccelerationRemoveResponse();
                        response.ReadBytes(context._wtObjects[iKey]._response);

                        retVals[iKey] = response.hr;
                    }
                    catch (Exception e)
                    {
                        retVals[iKey] = GetExtendedError(e, context._wtObjects[iKey]._response);
                    }
                }
            }
            
            return retVals;
        }

        public uint Remove(byte[] key, bool matchExact)
        {
            if (matchExact == true)
            {
                return Remove(key);
            }
            
            if (!ValidateKey(key))
            {
                return HResult.E_INVALIDARG;
            }
            
            // make a request copy for each server.
            uint cServers = _cluster.GetNumServers();
            AccelerationRemoveRequest[] requests = new AccelerationRemoveRequest[cServers];            
            for (uint iServer = 0; iServer < cServers; iServer++)
            {
                requests[iServer] = new AccelerationRemoveRequest();
                requests[iServer].rgbKey = key;
                requests[iServer].fMatchExact = false;
            }

            try
            {
                // we treat these sends as fire and forget.
                _cluster.SendToAllServers(requests);
                return HResult.S_OK;
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_REMOVE_FAILED, e, "Acceleration.Remove() caught exception");

                return HResult.E_ABORT;
            }
        }


        // old (protocol version 1 style) SetData API assumes always overwrite.  we translate that to pass
        // AccelerationDefs.ACCELERATION_SET_DATA_VERSION_OVERWRITE as the version.
        public uint SetData(byte[] key, byte[] value)
        {
            uint[] retVals = SetData(new byte[][]{key}, new byte[][]{value}, new uint[]{0}, new uint[]{0}, new uint[]{AccelerationDefs.ACCELERATION_SET_DATA_VERSION_OVERWRITE});
            return retVals[0];
        }
        public uint SetData(byte[] key, byte[] value, uint absoluteSeconds, uint slidingSeconds)
        {
            uint[] retVals = SetData(new byte[][]{key}, new byte[][]{value}, new uint[]{absoluteSeconds}, new uint[]{slidingSeconds}, new uint[]{AccelerationDefs.ACCELERATION_SET_DATA_VERSION_OVERWRITE});
            return retVals[0];
        }
        public uint[] SetData(byte[][] keys, byte[][] values, uint[] absoluteExpiries, uint[] slidingExpiries)
        {
            if (keys == null)
            {
                return null;
            }
            
            uint[] versions = new uint[keys.Length];
            for (int iKey = 0; iKey < keys.Length; iKey++)
            {
                versions[iKey] = AccelerationDefs.ACCELERATION_SET_DATA_VERSION_OVERWRITE;
            }
            return SetData(keys, values, absoluteExpiries, slidingExpiries, versions);
        }

        // new (protocol version 2) SetData API requires a version to write.  E_ACCESSDENIED is returned if any existing value
        // does not match the specified version.  a successful write will internally increment the version.
        public uint SetData(byte[] key, byte[] value, ref uint version)
        {
            uint[] versions = new uint[]{version};
            uint[] retVals = SetData(new byte[][]{key}, new byte[][]{value}, new uint[]{0}, new uint[]{0}, versions);
            version = versions[0];
            return retVals[0];
        }

        public uint SetData(byte[] key, byte[] value, uint absoluteSeconds, uint slidingSeconds, ref uint version)
        {
            uint[] versions = new uint[]{version};
            uint[] retVals = SetData(new byte[][]{key}, new byte[][]{value}, new uint[]{absoluteSeconds}, new uint[]{slidingSeconds}, versions);
            version = versions[0];
            return retVals[0];
        }

        public uint[] SetData(byte[][] keys, byte[][] values, uint[] absoluteExpiries, uint[] slidingExpiries, uint[] versions)
        {
            if ((keys == null) || (values == null) || (absoluteExpiries == null) || (slidingExpiries == null) || (versions == null) ||
                (keys.Length == 0) || (values.Length != keys.Length) || (absoluteExpiries.Length != keys.Length) ||(slidingExpiries.Length != keys.Length) || (versions.Length != keys.Length))
            {
                return null;
            }

            uint[] retVals = new uint[keys.Length];

            AccelerationContext context = new AccelerationContext(keys.Length);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if (!ValidateKey(keys[iKey]) || !ValidateValue(values[iKey]))
                {
                    retVals[iKey] = HResult.E_INVALIDARG;
                }
                else
                {
                    AccelerationSetDataRequest request = new AccelerationSetDataRequest();
                    request.rgbKey = keys[iKey];
                    request.rgbValue = values[iKey];
                    request.dwAbsoluteSeconds = absoluteExpiries[iKey];
                    request.dwSlidingSeconds = slidingExpiries[iKey];
                    request.dwVersion = versions[iKey];
                    context.AddRequest(iKey, HashKeyToBucket(keys[iKey]), request);
                }
            }

            _cluster.SendContext(context);
            
            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if ((context._wtObjects[iKey] == null) ||
                    (context._wtObjects[iKey]._response == null))
                {
                    // prior error?
                    if (retVals[iKey] == 0)
                    {
                        retVals[iKey] = HResult.E_ABORT;
                    }
                }
                else
                {
                    try
                    {
                        // parse the response.
                        AccelerationSetDataResponse response = new AccelerationSetDataResponse();
                        response.ReadBytes(context._wtObjects[iKey]._response);

                        retVals[iKey] = response.hr;
                        versions[iKey] = response.dwVersion;
                    }
                    catch (Exception e)
                    {
                        retVals[iKey] = GetExtendedError(e, context._wtObjects[iKey]._response);
                    }
                }
            }
            
            return retVals;
        }

        public uint Increment(byte[] key, ulong amount, out ulong result)
        {
            return Increment(key, amount, AccelerationDefs.ACCELERATION_INCREMENT_HALFLIFE_INFINITE, 0, 0, out result);
        }

        public uint Increment(byte[] key, ulong amount, uint halfLifeSeconds, out ulong result)
        {
            return Increment(key, amount, halfLifeSeconds, 0, 0, out result);
        }

        public uint Increment(byte[] key, ulong amount, uint halfLifeSeconds, uint absoluteSeconds, uint slidingSeconds, out ulong result)
        {
            ulong[] results;
            uint[] retVals = Increment(new byte[][]{key}, new ulong[]{amount}, new uint[]{halfLifeSeconds}, new uint[]{absoluteSeconds}, new uint[]{slidingSeconds}, out results);
            
            result = results[0];
            return retVals[0];
        }

        public uint[] Increment(byte[][] keys, ulong[] amounts, out ulong[] results)
        {
            uint[] halfLives = new uint[keys.Length];
            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                halfLives[iKey] = AccelerationDefs.ACCELERATION_INCREMENT_HALFLIFE_INFINITE;
            }
            return Increment(keys, amounts, halfLives, new uint[keys.Length], new uint[keys.Length], out results);
        }
        
        public uint[] Increment(byte[][] keys, ulong[] amounts, uint[] halfLives, uint[] absoluteExpiries, uint[] slidingExpiries, out ulong[] results)
        {
            results = null;
            
            if ((keys == null) || (amounts == null) || (halfLives == null) || (absoluteExpiries == null) || (slidingExpiries == null) ||
                (keys.Length == 0) || (amounts.Length != keys.Length) || (halfLives.Length != keys.Length) || (absoluteExpiries.Length != keys.Length) ||(slidingExpiries.Length != keys.Length))
            {
                return null;
            }

            uint[] retVals = new uint[keys.Length];
            results = new ulong[keys.Length];

            AccelerationContext context = new AccelerationContext(keys.Length);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if (!ValidateKey(keys[iKey]) || (halfLives[iKey] == 0))
                {
                    retVals[iKey] = HResult.E_INVALIDARG;
                }
                else
                {
                    AccelerationIncrementRequest request = new AccelerationIncrementRequest();
                    request.rgbKey = keys[iKey];
                    request.qwIncrementAmount = amounts[iKey];
                    request.dwHalfLifeSeconds = halfLives[iKey];
                    request.dwAbsoluteSeconds = absoluteExpiries[iKey];
                    request.dwSlidingSeconds = slidingExpiries[iKey];
                    context.AddRequest(iKey, HashKeyToBucket(keys[iKey]), request);
                }
            }

            _cluster.SendContext(context);
            
            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if ((context._wtObjects[iKey] == null) ||
                    (context._wtObjects[iKey]._response == null))
                {
                    // prior error?
                    if (retVals[iKey] == 0)
                    {
                        retVals[iKey] = HResult.E_ABORT;
                    }
                }
                else
                {
                    try
                    {
                        // parse the response.
                        AccelerationIncrementResponse response = new AccelerationIncrementResponse();
                        response.ReadBytes(context._wtObjects[iKey]._response);

                        results[iKey] = response.qwResult;
                        retVals[iKey] = response.hr;
                    }
                    catch (Exception e)
                    {
                        retVals[iKey] = GetExtendedError(e, context._wtObjects[iKey]._response);
                    }
                }
            }
            
            return retVals;
        }

        public uint[] Health()
        {            
            // make a request copy for each server.
            uint cServers = _cluster.GetNumServers();
            AccelerationRemoveRequest[] requests = new AccelerationRemoveRequest[cServers];            
            for (uint iServer = 0; iServer < cServers; iServer++)
            {
                requests[iServer] = new AccelerationRemoveRequest();
                requests[iServer].rgbKey = System.Text.Encoding.ASCII.GetBytes("Health");
                requests[iServer].fMatchExact = true;
            }

            uint[] hrs = _cluster.SendToAllServers(requests, true);

            return hrs;
        }

        public static void ChangeSetting(object sender, SettingChangeEventArgs e)
        {
        }

    }

    internal class AccelerationContext
    {
        public AccelerationWaitTableObject[] _wtObjects;
        public int _keysRemaining;
        public ManualResetEvent _event = null;

        public AccelerationContext(int numRequests)
        {
            _keysRemaining = 0;
            _wtObjects = new AccelerationWaitTableObject[numRequests];
            _event = new ManualResetEvent(false);
        }

        public void AddRequest(uint keyIndex, uint bucket, AccelerationMessageHeader request)
        {
            _wtObjects[keyIndex] = new AccelerationWaitTableObject(this, keyIndex, bucket, request);
            _keysRemaining++;
        }
    }

    internal class AccelerationWaitTableObject
    {
        public AccelerationContext _context;
        public AccelerationMessageHeader _request;
        public byte[] _response;
        public uint _keyIndex;
        public uint _seqnum;
        public uint _bucket;

        public XomRequestTimeElapsed _waitTime;

        public AccelerationWaitTableObject(AccelerationContext context, uint keyIndex, uint bucket, AccelerationMessageHeader request)
        {
            _context = context;
            _keyIndex = keyIndex;
            _bucket = bucket;
            _request = request;
            _seqnum = 0;
        }
    }

    // singleton class for each cluster
    internal class AccelerationConnectionCluster
    {
        internal const int LOCK_TIMEOUT = 30000;
        internal const int REPLY_TIMEOUT = 3000;

        private static Hashtable _htClusters = null;

        private string _iface = null;
        public string InterfaceName
        {
            get
            {
                return _iface;
            }
        }

        // an array of InhConnection objects, use
        // GetInhConnection to access it.
        private ReaderWriterLock _rwlConnections = null;
        private int[] _bucketMap = null;
        private AccelerationConnection[] _connections = null;

        // fast fail
        internal FastFailHelper _fastFailHelper = null;
        internal string _timeoutSetting = null;

        // notification callbacks
        internal Acceleration.AccelerationNotificationHandler _notificationCallback = null;
        internal Acceleration.AccelerationNotificationFailureHandler _failureCallback = null;

        static AccelerationConnectionCluster()
        {
            // setup config change handlers.
            Config.InterfaceBucketChange += new InterfaceBucketChangeEventHandler(AccelerationConnectionCluster.ChangeBucketMap);
            Config.ServerListChange += new ServerListChangeEventHandler(AccelerationConnectionCluster.ChangeServerList);

            _htClusters = new Hashtable();
        }

        internal AccelerationConnectionCluster(string iface)
        {
            _iface = iface;

            // create a fast fail helper.
            _fastFailHelper = GetFastFailHelper(iface);
            _timeoutSetting = GetTimeoutSetting(iface);

            // create reader/writer lock for static connection management.
            _rwlConnections = new ReaderWriterLock();

            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                LockCookie lc = _rwlConnections.UpgradeToWriterLock(LOCK_TIMEOUT);
                try
                {
                    // first get the servers.
                    string[] serverList = Config.GetServerListByInterface(iface);
                    _connections = new AccelerationConnection[serverList.Length];

                    for (int iServer = 0; iServer < _connections.Length; iServer++)
                    {
                        IInterfaceInfo ifaceinfo = Config.GetInterface(serverList[iServer], iface);

                        // create the new InhConnection object
                        Xom.Trace(XomAreaName.AccelerationProxy, 
                            LogLevel.L_NORMAL,
                            "AccelerationConnection.InitConnections: creating new InhConnection to Inh server "
                            + iServer.ToString()
                            + ", IP address "
                            + ifaceinfo.IPAddressString);
                        
                        _connections[iServer] = new AccelerationConnection(ifaceinfo, serverList[iServer], this);
                    }
                    
                    // now we have to make the bucket map. 
                    uint numBuckets = Config.GetBucketCount(iface);
                    _bucketMap = new int[numBuckets];
                   
                    for (int iBucket = 0; iBucket < numBuckets; iBucket++)
                    {
                        _bucketMap[iBucket] = -1;
                        
                        IBucketServer b = Config.GetBucketServer(iface, (uint)iBucket);

                        // find this bucket's server in the list of servers
                        for (int iServer = 0; iServer < serverList.Length; iServer++)
                        {
                            if (0 == String.Compare(b.CurrentServerName, serverList[iServer], StringComparison.OrdinalIgnoreCase))
                            {
                                // found it.
                                _bucketMap[iBucket] = iServer;
                                break;
                            }
                        }

                        if (_bucketMap[iBucket] == -1)
                        {
                            Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_BUCKET_MAP_FAILED, "Could not map bucket " + iBucket.ToString() + "to server " + b.CurrentServerName);
                        }
                    }
                }
                finally
                {
                    _rwlConnections.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                _rwlConnections.ReleaseReaderLock();
            }
        }

        public static AccelerationConnectionCluster FindCluster(string iface)
        {
            lock (_htClusters.SyncRoot)
            {
                return (AccelerationConnectionCluster)_htClusters[iface];
            }
        }

        public static AccelerationConnectionCluster BuildCluster(string iface)
        {
            lock (_htClusters.SyncRoot)
            {
                AccelerationConnectionCluster cluster = FindCluster(iface);
                if (cluster == null)
                {
                    cluster = new AccelerationConnectionCluster(iface);
                    _htClusters[iface] = cluster;
                }

                return cluster;
            }
        }

        public static void ChangeBucketMap(object sender, InterfaceBucketChangeEventArgs e)
        {
            AccelerationConnectionCluster cluster = FindCluster(e.Interface);
            if (cluster == null)
            {
                // we're only concerned with acceleration's buckets.
                return;
            }
            
            if (0 == String.Compare(e.ValueNew.CurrentServerName, e.ValueOld.CurrentServerName, StringComparison.OrdinalIgnoreCase))
            {
                // no change that we care about.
                return;
            }
            
            bool fChanged = false;

            cluster._rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                LockCookie lc = cluster._rwlConnections.UpgradeToWriterLock(LOCK_TIMEOUT);
                try
                {            
                    for (int iServer = 0; iServer < cluster._connections.Length; iServer++)
                    {
                        if (0 == String.Compare(e.ValueNew.CurrentServerName, cluster._connections[iServer].GetServerName(), StringComparison.OrdinalIgnoreCase))
                        {
                            cluster._bucketMap[e.Bucket] = iServer;
                            fChanged = true;
                            break;
                        }
                    }
                }
                finally
                {
                    cluster._rwlConnections.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                cluster._rwlConnections.ReleaseReaderLock();
            }

            if (!fChanged)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.ACCELERATION_PROXY_BUCKET_CHANGE_FAILED, "AccelerationConnection::ChangeBucketMap() could not find a connection to server " + e.ValueNew.CurrentServerName);
            }
        }

        public static void ChangeServerList(object sender, ServerListChangeEventArgs e)
        {
            AccelerationConnectionCluster cluster = FindCluster(e.Interface);
            if (cluster == null)
            {
                // we're only concerned with acceleration's servers.
                return;
            }

            cluster._rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                // build a translation map for the indices.
                int[] iIndexMap = new int[cluster._connections.Length];

                for (int iOldServer = 0; iOldServer < cluster._connections.Length; iOldServer++)
                {
                    iIndexMap[iOldServer] = -1;
                    for (int iNewServer = 0; iNewServer < e.ValueNew.Length; iNewServer++)
                    {
                        if (0 == String.Compare(cluster._connections[iOldServer].GetServerName(), e.ValueNew[iNewServer], StringComparison.OrdinalIgnoreCase))
                        {
                            iIndexMap[iOldServer] = iNewServer;
                        }
                    }
                }

                LockCookie lc = cluster._rwlConnections.UpgradeToWriterLock(LOCK_TIMEOUT);
                try
                {
                    // make a new connection list and copy over any old connections that still remain.
                    AccelerationConnection[] newConnections = new AccelerationConnection[e.ValueNew.Length];
                    for (int iOldServer = 0; iOldServer < cluster._connections.Length; iOldServer++)
                    {
                        if (iIndexMap[iOldServer] == -1)
                        {
                            // not in the map -- we dont need this one anymore.
                            cluster._connections[iOldServer].Shutdown(false);
                        }
                        else
                        {
                            newConnections[iIndexMap[iOldServer]] = cluster._connections[iOldServer];
                        }                

                        cluster._connections[iOldServer] = null;
                    }

                    // make new connections
                    for (int iNewServer = 0; iNewServer < newConnections.Length; iNewServer++)
                    {
                        if (newConnections[iNewServer] == null)
                        {
                            IInterfaceInfo ifaceinfo = Config.GetInterface(e.ValueNew[iNewServer], cluster._iface);

                            // create the new InhConnection object
                            Xom.Trace(XomAreaName.AccelerationProxy,
                                LogLevel.L_NORMAL,
                                "AccelerationConnection.ChangeServerList: creating new InhConnection to Inh server "
                                + iNewServer.ToString()
                                + ", IP address "
                                + ifaceinfo.IPAddressString);
                            
                            newConnections[iNewServer] = new AccelerationConnection(ifaceinfo, e.ValueNew[iNewServer], cluster);
                        }
                    }

                    // switch to the new connection list
                    cluster._connections = newConnections;

                    // rearrange the bucket map
                    for (int iBucket = 0; iBucket < cluster._bucketMap.Length; iBucket++)
                    {
                        cluster._bucketMap[iBucket] = iIndexMap[cluster._bucketMap[iBucket]];
                        if (cluster._bucketMap[iBucket] == -1)
                        {
                            Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_SERVER_CHANGE_FAILED, "Could not map bucket " + iBucket.ToString() + "to server.  Check config for consistency.");
                        }
                    }
                }
                finally
                {
                    cluster._rwlConnections.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                cluster._rwlConnections.ReleaseReaderLock();
            }
        }

        public uint GetNumBuckets()
        {
            uint cBuckets = 0;
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            cBuckets = (uint)_bucketMap.Length;
            _rwlConnections.ReleaseReaderLock();
            return cBuckets;
        }

        public uint GetNumServers()
        {
            uint cServers = 0;
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            cServers = (uint)_connections.Length;
            _rwlConnections.ReleaseReaderLock();
            return cServers;
        }

        public AccelerationConnection GetInhConnection(uint bucketNum)
        {
            AccelerationConnection xbcRet = null;
            
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                int iServer = _bucketMap[bucketNum];
                if (iServer != -1)
                {
                    xbcRet = _connections[iServer];
                }
            }
            finally
            {
                _rwlConnections.ReleaseReaderLock();
            }

            return xbcRet;
        }

        public void RegisterNotificationHandler(Acceleration.AccelerationNotificationHandler notificationCallback)
        {
            _notificationCallback += notificationCallback;
        }

        public void RegisterNotificationFailureHandler(Acceleration.AccelerationNotificationFailureHandler failureCallback)
        {
            _failureCallback += failureCallback;
        }

        public void UnregisterHandlers()
        {
            _notificationCallback = null;
            _failureCallback = null;
        }

        public void ShutdownAll()
        {
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                LockCookie lc = _rwlConnections.UpgradeToWriterLock(LOCK_TIMEOUT);
                try
                {
                    Xom.Trace(XomAreaName.AccelerationProxy, LogLevel.L_NORMAL, "AccelerationConnection.ShutdownAll: called");
                    foreach (AccelerationConnection inhConnection in _connections)
                    {
                        inhConnection.Shutdown(true);
                    }
                    Xom.Trace(XomAreaName.AccelerationProxy, LogLevel.L_NORMAL, "AccelerationConnection.ShutdownAll: complete");
                }
                finally
                {
                    _rwlConnections.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                _rwlConnections.ReleaseReaderLock();
            }
        }

        public void SendToAllServers(AccelerationMessageHeader[] requests)
        {
            SendToAllServers(requests, false);
        }
        
        public uint[] SendToAllServers(AccelerationMessageHeader[] requests, bool fWait)
        {
            int timeout = REPLY_TIMEOUT;
            uint[] retVals = null;
            
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                // need a copy per server.
                if (requests.Length != _connections.Length)
                {
                    throw new ApplicationException( "AccelerationConnection.SendToAllServers(): incorrect number of servers specified.  This should only happen during an Acceleration INH server list change.");
                }
                
                AccelerationContext context = new AccelerationContext(_connections.Length);

                // add all requests before sending any.
                for (uint iServer = 0; iServer < _connections.Length; iServer++)
                {
                    context.AddRequest(iServer, 0, requests[iServer]);
                }

                // now send the requests.
                for(uint iServer = 0; iServer < _connections.Length; iServer++)
                {
                    if (!(_connections[iServer].SendToServer(context._wtObjects[iServer])))
                    {
                        // failed to send this object.
                        Interlocked.Decrement(ref context._keysRemaining);
                        context._wtObjects[iServer] = null;
                    }
                }

                if (fWait)
                {
                    if ((context._keysRemaining > 0) && !(context._event.WaitOne(timeout, false)))
                    {
                        // timed out.  find all the missing replies and remove from waittables.
                        for (uint iServer = 0; iServer < context._wtObjects.Length; iServer++)
                        {
                            if ((context._wtObjects[iServer] != null) && (context._wtObjects[iServer]._response == null))
                            {
                                _connections[iServer].TimeoutWaitTableObject(context._wtObjects[iServer]);
                            }
                        }
                    }

                    retVals = new uint[_connections.Length];
                    for (uint iResponse = 0; iResponse < _connections.Length; iResponse++)
                    {
                        if ((context._wtObjects[iResponse] == null) || 
                            (context._wtObjects[iResponse]._response == null))
                        {
                            retVals[iResponse] = HResult.E_ABORT;
                        }
                        else
                        {
                            try
                            {
                                // parse the response.
                                AccelerationEmptyResponse response = new AccelerationEmptyResponse();
                                response.ReadBytes(context._wtObjects[iResponse]._response);

                                retVals[iResponse] = response.hr;
                            }
                            catch (Exception)
                            {
                                retVals[iResponse] = HResult.E_ABORT;
                            }                            
                        }
                    }
                }
            }
            finally
            {
                _rwlConnections.ReleaseReaderLock();
            }

            return retVals;
        }

        public void SendContext(AccelerationContext context)
        {
            int timeout = REPLY_TIMEOUT;
            try
            {
                timeout = Config.GetIntSetting(_timeoutSetting);
                if (timeout == 0)
                {
                    // this means acceleration is disabled.  dont bother trying to send anything.
                    return;
                }
            }
            catch (Exception)
            {
                // eat this is if the setting doesnt exist.
            }
            
            for (uint iKey = 0; iKey < context._wtObjects.Length; iKey++)
            {
                if (context._wtObjects[iKey] != null)
                {
                    AccelerationConnection xbc = GetInhConnection(context._wtObjects[iKey]._bucket);
                    if (!(xbc.SendToServer(context._wtObjects[iKey])))
                    {
                        // failed to send this object.
                        Interlocked.Decrement(ref context._keysRemaining);
                        context._wtObjects[iKey] = null;
                    }
                }
            }

            if ((context._keysRemaining > 0) && !(context._event.WaitOne(timeout, false)))
            {
                // timed out.  find all the missing replies and remove from waittables.
                for (uint iKey = 0; iKey < context._wtObjects.Length; iKey++)
                {
                    if ((context._wtObjects[iKey] != null) && (context._wtObjects[iKey]._response == null))
                    {
                        AccelerationConnection xbc = GetInhConnection(context._wtObjects[iKey]._bucket);
                        xbc.TimeoutWaitTableObject(context._wtObjects[iKey]);
                    }
                }
            }
        }



        internal static string GetTimeoutSetting(string iface)
        {
            switch (iface.ToLower())
            {
                case "notificationcache":
                    return Setting.NotificationCache_replyTimeout;
                    
                case "presencecache":
                    return Setting.PresenceCache_replyTimeout;
                    
                case "profilecache":
                    return Setting.ProfileCache_replyTimeout;
                    
                case "acceleration":
                    return Setting.acceleration_replyTimeout;
            }

            throw new ApplicationException("Unknown acceleration cluster interface: " + iface);
        }

        internal static FastFailHelper GetFastFailHelper(string iface)
        {
            switch (iface.ToLower())
            {
                case "notificationcache":
                    return new FastFailHelper(
                        Setting.NotificationCache_fastFailTimeoutThresholdCount, 
                        Setting.NotificationCache_fastFailTimeoutTimespanSeconds, 
                        Setting.NotificationCache_fastFailBlockIntervalSeconds);
                    
                case "presencecache":
                    return new FastFailHelper(
                        Setting.PresenceCache_fastFailTimeoutThresholdCount, 
                        Setting.PresenceCache_fastFailTimeoutTimespanSeconds, 
                        Setting.PresenceCache_fastFailBlockIntervalSeconds);
                    
                case "profilecache":
                    return new FastFailHelper(
                        Setting.ProfileCache_fastFailTimeoutThresholdCount, 
                        Setting.ProfileCache_fastFailTimeoutTimespanSeconds, 
                        Setting.ProfileCache_fastFailBlockIntervalSeconds);
                    
                case "acceleration":
                    return new FastFailHelper(
                        Setting.acceleration_fastFailTimeoutThresholdCount, 
                        Setting.acceleration_fastFailTimeoutTimespanSeconds, 
                        Setting.acceleration_fastFailBlockIntervalSeconds);
            }

            throw new ApplicationException("Unknown acceleration cluster interface: " + iface);
        }
    }

    internal class AccelerationConnection
    {
        internal const int SEND_QUEUE_TIMEOUT = 1000;

        private Socket _socket;
        private IInterfaceInfo _interfaceInfo;
        private string _serverName;
        private int _seqNum = 1;

        private AccelerationConnectionCluster _cluster;

        // asynch send stuff
        private bool _shutdown;
        private LockFreeQueue<AccelerationWaitTableObject> _sendQueue;
        private AutoResetEvent _sendQueueEvent;
        private Hashtable _waitTable;
        private XboxLiveThread _sendThread;
        private XboxLiveThread _receiveThread;

        // perf counter instance specific to this connection
        private AccelerationConnectionCounters _instanceCounters;

        private XboxLiveThread _notificationThread;
        private uint _lastChangeID = 0;
        
        public string GetServerName()
        {
            return _serverName;
        }

        public AccelerationConnection(IInterfaceInfo interfaceInfo, string serverName, AccelerationConnectionCluster cluster)
        {
            _cluster = cluster;
            
            // This contains the IP:port info we need to connect to the
            // INH server.
            _interfaceInfo = interfaceInfo;

            // we use the server name to match connections to buckets.
            _serverName = serverName;

            // Get a perf counter instance for this particular connection
            string instanceString = Config.ComponentName + " -> " + _interfaceInfo.Interface + " : " + _interfaceInfo.IPAddressString;
            _instanceCounters = AccelerationConnectionCounters.Total[instanceString];

            // We call Connect() here to create the initial socket and connect
            // it to the INH server. That way, if there are any fundamental
            // communications problems, this thread will see the SocketException
            // right away, and won't have to wait until a Send attempt fails.
            try
            {
                Connect();
            }
            catch (SocketException)
            {
                // dont puke here if the server isnt up yet.
            }

            _shutdown = false;

            // This is a queue of requests to be sent to the INH server.
            _sendQueue = new LockFreeQueue<AccelerationWaitTableObject>(false);

            // When a new item is put into the queue, this event is signaled,
            // which will wake up the SendThread if it has gone to sleep
            _sendQueueEvent = new AutoResetEvent(false);

            // This is a table of requests which have been sent to the INH
            // server, and are waiting on a response from the INH server
            // It is syncronized because it is shared between the SendThread,
            // the ReceiveThread, and the calling thread (via the Timeout method)
            _waitTable = Hashtable.Synchronized(new Hashtable());

            // Start the send thread
            _sendThread = new XboxLiveThread(new ThreadStart(this.SendThread));
            _sendThread.IsBackground = true;
            _sendThread.Start();

            // Start the receive thread
            _receiveThread = new XboxLiveThread(new ThreadStart(this.ReceiveThread));
            _receiveThread.IsBackground = true;
            _receiveThread.Start();

            // setup the notification poll thread.
            _notificationThread = new XboxLiveThread(new ThreadStart(this.PollForNotifications));
            _notificationThread.IsBackground = true;
            _notificationThread.Start();

            Xom.Trace(XomAreaName.AccelerationProxy,
                LogLevel.L_NORMAL,
                "AccelerationConnection.ctor: AccelerationConnection creation successful for "
                + _interfaceInfo.IPAddressString);
        }

        public void Shutdown()
        {
            Shutdown(true);
        }
        public void Shutdown(bool fWait)
        {
            Xom.Trace(XomAreaName.AccelerationProxy, LogLevel.L_NORMAL,
                "Acceleration.Shutdown: Shutdown called for InhConnection to "
                + _interfaceInfo.IPAddressString);

            // set the shutdown flag, which will tell the send and receive
            // threads to begin shutting down
            _shutdown = true;

            if (fWait)
            {
                // wait for the send and receive threads to shutdown
                _sendThread.Join();
                _receiveThread.Join();
                _notificationThread.Join();
            }

            Xom.Trace(XomAreaName.AccelerationProxy, LogLevel.L_LOW,
                "Acceleration.Shutdown: InhConnection successfully shutdown for  "
                + _interfaceInfo.IPAddressString);
        }

        public bool IsValidConnection()
        {
            return (_socket != null && _socket.Connected);
        }

        // Gets the current socket connection, verifying the health of the socket
        // and (re)connecting it if required
        public void Connect()
        {
            if (IsValidConnection())
            {
                return;
            }
            
            try
            {
                _instanceCounters.ConnectionAttempts.Increment();
                AccelerationConnectionCounters.Total.ConnectionAttempts.Increment();
                
                // create a new socket
                Xom.Trace(XomAreaName.AccelerationProxy, LogLevel.L_NORMAL,
                    "XPNFD.InhConnection.GetSocket: creating new socket connection to "
                    + _interfaceInfo.IPAddressString);
                
                _socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream,
                    ProtocolType.Tcp);

                // connect to the specified INH server
                IPEndPoint ipEndPoint =
                    new IPEndPoint(_interfaceInfo.IPAddress, _interfaceInfo.Port);
                _socket.Connect(ipEndPoint);
            }
            catch (SocketException se)
            {
                Disconnect();
                Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_CONNECT_FAILED, "Could not establish socket to " + _serverName + ".  The server is probably not running yet.\r\n" + se.ToString());
            }
        }
        
        public void Disconnect()
        {
            lock (this)
            {
                if (_socket != null)
                {
                    try
                    {
                        _socket.Shutdown(SocketShutdown.Both);
                        _socket.Close();
                    }
                    catch (SocketException)
                    {
                        // eat any exception here.  we're closing anyway.
                    }
                    
                    _socket = null;
                }
            }
        }

        public bool Send(byte[] msg, uint seqNum)
        {
            bool fRetry = true;
            
            while ( IsValidConnection() )
            {
                try
                {
                    // break up msg into packets small enough to be received by the server.
                    int cbStart = 0;
                    int cbLeft = msg.Length;
                    while (cbLeft > 0)
                    {
                        int maxSize = (int)AccelerationDefs.ACCELERATION_MAX_PACKET_SIZE;
                        
                        if (cbStart > 0)
                        {
                            // this isnt the first packet.  make a continuation header to send first.
                            AccelerationMessageHeader header = new AccelerationMessageHeader(ACCELERATION_MSG_TYPES.XBMSG_CONTINUATION_REQ);

                            // the header contribuites to the packet size.
                            maxSize -= header.Size();
                            
                            header.dwMsgLen = (cbLeft > maxSize) ? AccelerationDefs.ACCELERATION_MAX_PACKET_SIZE : (uint)(cbLeft + header.Size());
                            header.dwSeqNum = seqNum;

                            // cant use header.WriteStream() here because it overwrites dwMsgLen.
                            MemoryStream stream = new MemoryStream();
                            BinaryWriter writer = new BinaryWriter(stream);
                            writer.Write(header.dwProtocolVersion);
                            writer.Write(header.dwMsgType);
                            writer.Write(header.dwMsgLen);
                            writer.Write(header.dwSeqNum);

                            // send the header
                            _socket.Send(stream.ToArray());
                        }
                        
                        int cbSent = _socket.Send(
                            msg, 
                            cbStart, 
                            (cbLeft > maxSize) ? maxSize : cbLeft,
                            SocketFlags.None);

                        cbStart += cbSent;
                        cbLeft -= cbSent;
                    }
                    
                    return true;
                }
                catch (SocketException se)
                {
                    Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_SEND_FAILED, se, "Unexpected exception caught." + (fRetry ? " Will attempt 1 retry." : ""));
                    
                    if (fRetry)
                    {
                        fRetry = false;
                        Disconnect();
                        Connect();
                    }
                    else
                    {
                        throw;
                    }
                }
            }
            
            Disconnect();
            return false;
        }

        public byte[] Recv()
        {
            if( IsValidConnection() )
            {
                try
                {
                    return ReceiveAccelerationMessage(_socket);
                }
                catch(Exception e)
                {
                    Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_RECEIVE_FAILED, e, "Unexpected exception caught");
                }
            }
            
            Disconnect();
            return null;
        }

        protected uint GetNextSequenceNumber()
        {
            return (uint)Interlocked.Increment(ref _seqNum);
        }

        public bool SendToServer(AccelerationWaitTableObject wto)
        {
            // check fast fail first.
            if (_cluster._fastFailHelper.InFastFailState(_interfaceInfo.IPAddressString))
            {
                return false;
            }
            
            _instanceCounters.RequestRate.Increment();
            AccelerationConnectionCounters.Total.RequestRate.Increment();
            wto._waitTime = new XomRequestTimeElapsed();

            wto._seqnum = GetNextSequenceNumber();
            wto._request.dwSeqNum = wto._seqnum;
            _sendQueue.Enqueue(wto);
            _sendQueueEvent.Set();

            _instanceCounters.EnqueueRate.Increment();
            _instanceCounters.QueueSize.Increment();
            AccelerationConnectionCounters.Total.EnqueueRate.Increment();
            AccelerationConnectionCounters.Total.QueueSize.Increment();

            return true;
        }

        public void TimeoutWaitTableObject(AccelerationWaitTableObject wto)
        {
            // timed out waiting for a response.  remove it from the wait table.
            AccelerationWaitTableObject wtoRemoved;
            lock (_waitTable.SyncRoot)
            {
                wtoRemoved = (AccelerationWaitTableObject)_waitTable[wto._seqnum];
                _waitTable.Remove(wto._seqnum);
            }
            if (wtoRemoved != null)
            {
                _instanceCounters.WaitTableSize.Decrement();
                AccelerationConnectionCounters.Total.WaitTableSize.Decrement();
                _instanceCounters.ConcurrentRequests.Decrement();
                AccelerationConnectionCounters.Total.ConcurrentRequests.Decrement();
            }

            // report failure to fail fast.
            _cluster._fastFailHelper.ReportFailure(_interfaceInfo.IPAddressString, "Timed out.");

            _instanceCounters.RequestTimeAvg.IncrementBy(wto._waitTime.TimeElapsed);
            _instanceCounters.RequestTimeAvgBase.Increment();
            AccelerationConnectionCounters.Total.RequestTimeAvg.IncrementBy(wto._waitTime.TimeElapsed);
            AccelerationConnectionCounters.Total.RequestTimeAvgBase.Increment();
        }            

        public void DrainSendQueue()
        {
            // loop until queue is empty
            while (true)
            {
                AccelerationWaitTableObject wto = (AccelerationWaitTableObject)_sendQueue.Dequeue();
                if (wto != null)
                {
                    bool fSent = false;
                    // queue is syncronized
                    try
                    {                        
                        // update the queue wait perf counters
                        long elapsed = wto._waitTime.TimeElapsed;
                        AccelerationConnectionCounters.Total.QueueWaitTimeAvg.IncrementBy(elapsed);
                        AccelerationConnectionCounters.Total.QueueWaitTimeAvgBase.Increment();
                        _instanceCounters.QueueWaitTimeAvg.IncrementBy(elapsed);
                        _instanceCounters.QueueWaitTimeAvgBase.Increment();

                        AccelerationConnectionCounters.Total.QueueSize.Decrement();
                        _instanceCounters.QueueSize.Decrement();

                        _instanceCounters.ConcurrentRequests.Increment();
                        AccelerationConnectionCounters.Total.ConcurrentRequests.Increment();
                        // if we are supposed to wait for a response from the
                        // INH server, then put this context into the wait
                        // table.
                        // We want to so this *before* we actually send,
                        // because the INH server could respond before we've 
                        // finished adding the context to the wait table.

                        // store the current time in the context
                        wto._waitTime = new XomRequestTimeElapsed();

                        _waitTable.Add(wto._seqnum, wto);

                        // update perf counters
                        AccelerationConnectionCounters.Total.WaitTableSize.Increment();
                        _instanceCounters.WaitTableSize.Increment();

                        // now do the send
                        Connect();
                        fSent = Send((byte[])(wto._request), wto._seqnum);
                    }
                    finally
                    {
                        if (!fSent)
                        {
                            _instanceCounters.ConcurrentRequests.Decrement();
                            AccelerationConnectionCounters.Total.ConcurrentRequests.Decrement();
                            
                            // removes the item from the wait table, regardless of if it's there or not.
                            AccelerationWaitTableObject wtoRemoved;
                            lock (_waitTable.SyncRoot)
                            {
                                wtoRemoved = (AccelerationWaitTableObject)_waitTable[wto._seqnum];
                                _waitTable.Remove(wto._seqnum);
                            }
                            if (wtoRemoved != null)
                            {
                                _instanceCounters.WaitTableSize.Decrement();
                                AccelerationConnectionCounters.Total.WaitTableSize.Decrement();
                            }

                            if (0 == Interlocked.Decrement(ref wto._context._keysRemaining))
                            {
                                wto._context._event.Set();
                            }
                        }
                    }
                }
                else
                {
                    // queue is empty, break out of the loop and go back to sleep.
                    break;
                }
            }
        }

        public void SendThread()
        {
            try
            {
                // keep processing work items on the queue until we break out of
                // this loop because the _shutdown flag is set
                while (!_shutdown)
                {
                    try
                    {
                        // Wait for an item to be put on the queue
                        if (_sendQueueEvent.WaitOne(SEND_QUEUE_TIMEOUT, false))
                        {
                            // we have work to do
                            DrainSendQueue();
                        }
                    }
                    catch (Exception e)
                    {
                        try
                        {
                            // we don't want an exception to cause this thread to
                            // terminate, so we catch it, log it, and move along
                            Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_SEND_FAILED, e, 
                                "Unexpected Exception thrown in SendThread for connection to INH at {0}",
                                _interfaceInfo.IPAddressString
                            );
                        }
                        catch (Exception)
                        {
                            // eat anything else that could possibly go wrong.
                        }
                    }
                }
            }
            finally
            {
                try
                {
                    // kill the socket. If we don't do this, the receive
                    // thread will never exit.
                    Disconnect();
                }
                catch (Exception)
                {
                    // eat anything else that could possibly go wrong.
                }
            }            
        }

        public void ReceiveMessage()
        {
            try
            {
                // read a response.
                byte[] rgbResp = Recv();
                if (rgbResp == null)
                {
                    return;
                }

                // get the sequence number
                AccelerationMessageHeader response = new AccelerationMessageHeader();
                response.ReadBytes(rgbResp);

                // find the matching Context in the wait table.
                AccelerationWaitTableObject wto;
                lock (_waitTable.SyncRoot)
                {
                    wto = (AccelerationWaitTableObject)_waitTable[response.dwSeqNum];
                    _waitTable.Remove(response.dwSeqNum);
                }

                if (wto == null)
                {
                    // this is expected for contexts that werent waiting (e.g. multi-server remove requests).  do nothing.
                }
                else
                {
                    _instanceCounters.ConcurrentRequests.Decrement();
                    AccelerationConnectionCounters.Total.ConcurrentRequests.Decrement();

                    wto._response = rgbResp;

                    // Update perf counters
                    long elapsed = wto._waitTime.TimeElapsed;
                    AccelerationConnectionCounters.Total.WaitTableSize.Decrement();
                    AccelerationConnectionCounters.Total.WaitTableWaitTimeAvg.IncrementBy(elapsed);
                    AccelerationConnectionCounters.Total.WaitTableWaitTimeAvgBase.Increment();
                    _instanceCounters.WaitTableSize.Decrement();
                    _instanceCounters.WaitTableWaitTimeAvg.IncrementBy(elapsed);
                    _instanceCounters.WaitTableWaitTimeAvgBase.Increment();
                    
                    _cluster._fastFailHelper.ReportSuccess(_interfaceInfo.IPAddressString);

                    if (0 == Interlocked.Decrement(ref wto._context._keysRemaining))
                    {
                        wto._context._event.Set();
                    }
                }
            }
            catch (Exception)
            {
                // Any exceptions at all leave the stream in a bad state. We could be half way
                // through a message, or the socket could have failed, or ?
                // In any of these situations, we invalidate the socket, so we will 
                // reconnect. If there are messages already in the receive buffer,
                // they are going to be lost.
                // Any affected contexts will eventually be timed out and removed from the wait
                // table. Since we didn't successfully receive a complete message
                // we don't really trust the sequence number enough to associate this
                // exception with any particular context, so we don't do anything
                // with the exception except log it.
                // However, during a shutdown, the send thread kills the socket for us,
                // so if we are shutting down, we just eat the exception and move merrily
                // along
                if (!_shutdown)
                {
                    Disconnect();
                    throw;
                }
            }
        }

        public void ReceiveThread()
        {
            // keep receiving messages from the INH server until we break out of
            // this loop because the _shutdown flag is set
            while (!_shutdown)
            {
                try
                {
                    // dont try to receive if the socket is dead.
                    if (IsValidConnection())
                    {
                        ReceiveMessage();
                    }
                    else
                    {
                        Thread.Sleep(1000);
                    }
                }
                catch (Exception e)
                {
                    // we don't want an exception to cause this thread to
                    // terminate, so we catch it, log it, and move along
                    try
                    {
                        Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_RECEIVE_FAILED, e,
                            "Unexpected Exception thrown in ReceiveThread for InhConnection to {0}",
                            _interfaceInfo.IPAddressString
                        );
                    }
                    catch (Exception)
                    {
                        // eat anything else that could possibly go wrong.
                    }
                }
            }
        }

        public void PollForNotifications()
        {
            // dedicated socket for changelist requests.  this avoids having the changelist request block behind other
            // pending requests.  this is important because we expect notifications to result in reciprocal calls to query
            // the data for changed keys.  we dont want to wait for all of those queries to complete before learning
            // of any further changes.
            Socket sock = null;
            
            while (!_shutdown)
            {
                try
                {
                    Thread.Sleep(Config.GetIntSetting(Setting.acceleration_notificationPollInterval));
                    
                    if ((_cluster._notificationCallback == null) && (_cluster._failureCallback == null))
                    {
                        // nobody's listening.
                        goto lDone;
                    }

                    if (sock == null)
                    {
                        sock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

                        // connect to the specified INH server
                        IPEndPoint ipEndPoint = new IPEndPoint(_interfaceInfo.IPAddress, _interfaceInfo.Port);
                        sock.Connect(ipEndPoint);

                        sock.ReceiveTimeout = 2 * Config.GetIntSetting(Setting.acceleration_notificationPollInterval);
                    }
                    
                    int timeout = AccelerationConnectionCluster.REPLY_TIMEOUT;
                    try
                    {
                        timeout = Config.GetIntSetting(_cluster._timeoutSetting);
                        if (timeout == 0)
                        {
                            // this means acceleration is disabled.  dont bother trying to send anything.
                            goto lDone;
                        }
                    }
                    catch (Exception)
                    {
                        // eat this is if the setting doesnt exist.
                    }
                    
                    uint hr = HResult.E_ABORT;
                        
                    AccelerationChangelistRequest request = new AccelerationChangelistRequest();
                    request.dwChangeID = _lastChangeID;

                    // send the changelist request
                    sock.Send((byte[])request);
                    byte[] rgbResponse = ReceiveAccelerationMessage(sock);

                    // here we should have a changelist response.
                    AccelerationChangelistResponse response = new AccelerationChangelistResponse();
                    try
                    {
                        // parse the response.
                        response.ReadBytes(rgbResponse);
                        hr = response.hr;
                    }
                    catch (Exception e)
                    {
                        hr = Acceleration.GetExtendedError(e, rgbResponse);
                    }

                    if (HResult.Failed(hr))
                    {
                        // arrgh?
                        goto lDone;
                    }

                    if (hr == HResult.S_FALSE)
                    {
                        // we dropped some notifications.  fire the failure callback.
                        if (_cluster._failureCallback != null)
                        {
                            try
                            {
                                _cluster._failureCallback();
                            }
                            catch (Exception e)
                            {
                                Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_CALLBACK_EXCEPTION, e,
                                    "PollForNotifications() caught exception in failure callback"
                                );
                            }
                        }
                    }

                    // update the change id.
                    _lastChangeID = response.dwNewChangeID;

                    if (response.dwNumChanges == 0)
                    {
                        // no changes.
                        goto lDone;
                    }

                    // build the key list.
                    byte[][] rgKeys = new byte[response.dwNumChanges][];
                    for (int iKey = 0; iKey < rgKeys.Length; iKey++)
                    {
                        rgKeys[iKey] = response.rgChanges[iKey].rgbKey;
                    }

                    // call the notification callback
                    if (_cluster._notificationCallback != null)
                    {
                        try
                        {
                            _cluster._notificationCallback(rgKeys);
                        }
                        catch (Exception e)
                        {
                            Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_CALLBACK_EXCEPTION, e, "PollForNotifications() caught exception in notification callback");
                        }
                    }
                    
                lDone:

                    continue;
                }
                catch (Exception e)
                {
                    // reconnect after any socket error.
                    if ((e is SocketException) || (sock == null) || !sock.Connected)
                    {
                        sock = null;
                    }

                    // we don't want an exception to cause this thread to
                    // terminate, so we catch it, log it, and move along
                    try
                    {
                        Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_RECEIVE_FAILED, e,
                            "Unexpected Exception thrown in PollForNotifications for InhConnection to {0}.",
                            _interfaceInfo.IPAddressString
                        );
                    }
                    catch (Exception)
                    {
                        // eat anything else that could possibly go wrong.
                    }
                }
            }
        }


        public byte[] ReceiveAccelerationMessage(Socket sock)
        {
            // buffer to receive header.
            byte[] headerBuf = new byte[AccelerationDefs.ACCELERATION_MESSAGE_HEADER_SIZE];

            int cTotalBytes = 0;
            while (cTotalBytes < headerBuf.Length)
            {
                int cBytes = sock.Receive(headerBuf, cTotalBytes, headerBuf.Length - cTotalBytes, SocketFlags.None);
                if (cBytes == 0)
                {
                    throw new ApplicationException( "AccelerationConnection.ReceiveAccelerationMessage(): Received 0 bytes");
                }
                else
                {
                    cTotalBytes += cBytes;
                }
            }

            AccelerationMessageHeader msgHeader = new AccelerationMessageHeader();
            msgHeader.ReadBytes(headerBuf);

            // basic checks on header
            if (msgHeader.dwProtocolVersion != AccelerationDefs.ACCELERATION_PROTOCOL_VERSION_CURRENT)
            {
                throw new ApplicationException( "AccelerationConnection.ReceiveAccelerationMessage(): Protocol Mismatch.  protocol received = " + msgHeader.dwProtocolVersion);
            }
            if ((msgHeader.dwMsgType < (uint)ACCELERATION_MSG_TYPES.XBMSG_MIN_RESP) ||
                (msgHeader.dwMsgType > (uint)ACCELERATION_MSG_TYPES.XBMSG_MAX_RESP))
            {
                throw new ApplicationException( "AccelerationConnection.ReceiveAccelerationMessage(): Unknown response type: " + msgHeader.dwMsgType);
            }
            
            // make a new buffer for header + data
            byte[] buf = new byte[msgHeader.dwMsgLen];

            // copy the header
            System.Buffer.BlockCopy(headerBuf, 0, buf, 0, headerBuf.Length);
            
            while (cTotalBytes < buf.Length)
            {
                int cBytes = sock.Receive(buf, cTotalBytes, buf.Length - cTotalBytes, SocketFlags.None);
                if (cBytes == 0)
                {
                    throw new ApplicationException( "AccelerationConnection.ReceiveAccelerationMessage(): Received 0 bytes");
                }
                else
                {
                    cTotalBytes += cBytes;
                }
            }

            return buf;
        }

    }
    
    [XomPerformanceCounterCategoryAttr( "Acceleration Proxy", "XBox Live Acceleration Service Proxy: Connections to Acceleration INH Servers", true )]
    public class AccelerationConnectionCounters : XomPerformanceCounterCategory
    {
        public virtual AccelerationConnectionCounters this[string instanceName]
        {
            get
            {
                return (AccelerationConnectionCounters) GetInstance(instanceName);
            }
        }

        static public AccelerationConnectionCounters Total = new AccelerationConnectionCounters();

        public AccelerationConnectionCounters() : base()
        {
            RequestRate.RawValue = 0;
            RequestTimeAvg.RawValue = 0;
            RequestTimeAvgBase.RawValue = 0;
            ConnectionAttempts.RawValue = 0;
            ConcurrentRequests.RawValue = 0;
            EnqueueRate.RawValue = 0;
            QueueSize.RawValue = 0;
            QueueWaitTimeAvg.RawValue = 0;
            QueueWaitTimeAvgBase.RawValue = 0;
            WaitTableSize.RawValue = 0;
            WaitTableWaitTimeAvg.RawValue = 0;
            WaitTableWaitTimeAvgBase.RawValue = 0;
        }

        [XomPerformanceCounterAttr(
            "Request Rate", 
            "Number of requests per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestRate;

        [XomPerformanceCounterAttr(
            "Request Time Average", 
            "Average time taken per request.", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter RequestTimeAvg;
        
        [XomPerformanceCounterAttr(
            "Request Time Average Base", 
            "Base for average time taken per request.", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter RequestTimeAvgBase;

        [XomPerformanceCounterAttr(
            "Connection attempts", 
            "Total number of attempts to connect this socket.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter ConnectionAttempts;

        [XomPerformanceCounterAttr(
            "Concurrent requests", 
            "Total number of requests waiting for a response.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter ConcurrentRequests;

        [XomPerformanceCounterAttr(
            "Enqueue Rate", 
            "Number of requests per second added to send queue waiting to be sent to the INH server", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter EnqueueRate;

        [XomPerformanceCounterAttr(
            "Queue Size", 
            "Total number of requests in the send queue waiting to be sent to the INH server", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter QueueSize;

        [XomPerformanceCounterAttr(
            "Queue Wait Time Average", 
            "Average time a request is in the send queue waiting to be sent to the INH server", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter QueueWaitTimeAvg;
        
        [XomPerformanceCounterAttr(
            "Queue Wait Time Average Base", 
            "Base for average time a request is in the send queue waiting to be sent to the INH server", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter QueueWaitTimeAvgBase;

        [XomPerformanceCounterAttr(
            "Wait Table Size", 
            "Total number of requests waiting in the wait table for a response from the INH server", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter WaitTableSize;

        [XomPerformanceCounterAttr(
            "Wait Table Wait Time Average", 
            "Average time a request is waiting in the wait table waiting for a response from the INH server", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter WaitTableWaitTimeAvg;
        
        [XomPerformanceCounterAttr(
            "Wait Table Wait Time Average Base", 
            "Base for average time a request is waiting in the wait table waiting for a response from the INH server", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter WaitTableWaitTimeAvgBase;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\CacheTable.cs ===
//
// CacheTable.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
//  This provides a size-limited cache that maintains size by purging the least used cache items.
//
//  To use it, simply instantiate CacheTable<K,V> in code, and either provide a delegate for resolving items 
//  on cache misses or use the TryGetValue/ContainsKey methods and the Add method to add missing items.
//
// Xbox Online Common Managed Code
// Xbox Online Service
//
// Author: Hoop Somuah (hsomu)
//
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.InteropServices;
using xonline.common.mgmt;

namespace xonline.common.service
{
    [ComVisible(false)]
    public interface IMeasurable
    {
        uint GetSize();
    }

    [ComVisible(false)]
    public delegate V ResolveCacheMissDelegate<K, V>(K key);

    /// <summary>
    /// Implements a fixed size LRU cache for data.
    /// </summary>
    /// <typeparam name="K">The type of the keys in the cache</typeparam>
    /// <typeparam name="V">The type of the values in the cache. V must implement IMeasurable to allow cache size to be measured</typeparam>
    /// <remarks>
    /// This class is very much like a special case dictionary. Items that have not been "touched" in a long time are removed from the Cache if it gets very large.
    /// </remarks>
    [ComVisible(false)]
    public class CacheTable<K, V>
        where V : IMeasurable
    {
        private readonly CacheTableCounters instanceCounter;
        private readonly Dictionary<K, CacheEntry<K, V>> table;
        private readonly LinkedList<K> mruList;
        private readonly ResolveCacheMissDelegate<K, V> itemResolver;
        private readonly Object _syncRoot;
        private uint _maxSize;
        private uint _size;

        /// <summary>
        /// Initializes a new instance of the CacheTable that doesn't resolve items when cache misses's occur.
        /// </summary>
        /// <param name="name">The name of the cache.</param>
        /// <param name="maxSize">The maximum size of the cache.</param>
        public CacheTable(string name, uint maxSize):this(name, maxSize, null){}

        /// <summary>
        /// Initializes a new instance of the CacheTable with an item resolver that is called on a cache miss.
        /// </summary>
        /// <param name="name">The name of the cache.</param>
        /// <param name="maxSize">The maximum size of the cache.</param>
        /// <param name="itemResolver">A delegate to a method that will get called when a cache miss occurs.</param>
        public CacheTable(string name, uint maxSize, ResolveCacheMissDelegate<K, V> itemResolver)
        {
            this.instanceCounter = CacheTableCounters.GetCounter(name);
            
            this._maxSize = maxSize;
            this.instanceCounter.InitializeCounter(maxSize);
            
            this._size = 0;
            
            this.table = new Dictionary<K, CacheEntry<K, V>>();
            this.mruList = new LinkedList<K>();
            this.itemResolver = itemResolver;
            this._syncRoot = new Object();
        }
	
        public Object SyncRoot
        {
            get { return _syncRoot; }
        }

        /// <summary>
        /// Gets the Maximum Size the Cache can grow to.
        /// </summary>
        /// <remarks>
        /// If an items is added to the cache after it reaches MaxSize or when Size + item.GetSize() > MaxSize, then
        /// the least used items in the cache are ejected to make room for the new entry.
        /// </remarks>
        public uint MaxSize
        {
            get { return this._maxSize; }
            set
            {
                lock (this._syncRoot)
                {
                    if (value < this._maxSize)
                    {
                        ShrinkCache(value);
                    }
                    long change = value - (long)this._maxSize;

                    this._maxSize = value;

                    this.instanceCounter.ChangeCacheMaxSize(change);
                }
            }
        }

        /// <summary>
        /// Gets the number of key/value pairs contained in the CacheTable
        /// </summary>
        public int Count
        {
            get { return table.Count; }
        }
	
        /// <summary>
        /// Gets the current size of the cache.
        /// </summary>
        /// <remarks>
        /// This is the sum of the values returned by calling IMeasurable.GetSize() on each item when items are inserted or changed.
        /// </remarks>
        public uint Size
        {
            get { return this._size; }
        }

        /// <summary>
        /// Updates the size of the cache.
        /// </summary>
        /// <remarks>
        /// amount to change the cache size by. If change is negative the cache size is reduced.
        /// 
        /// This method is not thread safe, lock on _syncRoot before calling it.
        /// </remarks>        
        void ChangeSize(long sizeChange, long countChange)
        {
            long newSize = this._size + sizeChange;
            
            Debug.Assert(newSize >= 0, "Size should never become negative!");
            
            Debug.Assert(countChange >= -this.table.Count, "Count should never become negative!");

            this._size = (uint)newSize;
            this.instanceCounter.ChangeCacheSize(sizeChange, countChange);
        }

        /// <summary>
        /// Clears all items form the cache.
        /// </summary>
        public void Flush()
        {
            lock (this._syncRoot)
            {
                ChangeSize(-this._size, -this.table.Count);

                this.table.Clear();
                this.mruList.Clear();
            }
        }

        /// <summary>
        /// Determines whether the Cache contains the specified key
        /// </summary>
        /// <param name="key">The key to locate in the Cache</param>
        /// <returns>true if the Cache contains an element with the specified key; otherwise, false</returns>
        /// <remarks>This method approaches an O(1) operation.</remarks>
        public bool ContainsKey(K key)
        {
            return table.ContainsKey(key);
        }

        /// <summary>
        /// Adds the specified key and value to the cache.
        /// </summary>
        /// <param name="key">The key of the element to add</param>
        /// <param name="data">The value of the element to add. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
        /// <returns></returns>
        public void Add(K key, V data)
        {
            if (key == null)
            {
                throw new ArgumentNullException("key");
            }
            lock (this._syncRoot)
            {
                if (table.ContainsKey(key))
                {
                    throw new ArgumentException("key already exists");
                }
                InternalAdd(key, data);
            }
        }

        /// <summary>
        /// Gets or sets the value associated with the specified key.
        /// </summary>
        /// <param name="key">The key of the value to get or set.</param>
        /// <returns>
        /// The value associated with the specified key. If the specified key is not found and there is no item resolver, a get operation throws a KeyNotFoundException. 
        /// A set operation creates a new element with the specified key if one doesn't exist, otherwise it replaces the exisitng entry and adjusts the cache size accordingly. 
        /// </returns>
        public V this[K key]
        {
            get
            {
                if (key == null)
                {
                    throw new ArgumentNullException("key", "The cache does not support null keys");
                }

                V value;
                if (InternalTryGetValue(key, out value))
                    return value;

                throw new KeyNotFoundException();
            }
            set
            {
                lock (this._syncRoot)
                {
                    CacheEntry<K, V> entry;

                    if (!this.table.TryGetValue(key, out entry))
                    {
                        InternalAdd(key, value);
                    }
                    else
                    {
                        /* replace existing entry in cache */
                        uint oldDataSize = entry.Data.GetSize();
                        uint dataSize = value.GetSize();

                        long sizeChange = dataSize - (long)oldDataSize;
                        if (sizeChange > 0)
                        {
                            EnsureCacheSize((uint)sizeChange);
                        }

                        ChangeSize(sizeChange, 0);
                        this.table[key].Data = value;
                        MakeMRU(entry);
                    }
                }
            }
        }

        /// <summary>
        /// Gets or sets the value associated with the specified key.
        /// </summary>
        /// <param name="key">The key of the value to get</param>
        /// <param name="value">When this method returns, contains the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter. This parameter is passed uninitialized.</param>
        /// <returns>true if the Cache contains an element with the specified key; otherwise, false.</returns>
        /// <remarks>
        /// This method combines the functionality of the ContainsKey method and the Item property.
        /// If the key is not found, then the value parameter gets the appropriate default value for the value type TValue; for example, 0 (zero) for integer types, false for Boolean types, and a null reference (Nothing in Visual Basic) for reference types.
        /// Use the TryGetValue method if you are not usign an item resolver and your code frequently attempts to access keys that are not in the cache. Using this method is more efficient than catching the KeyNotFoundException thrown by the Item property when there is a cache miss and no item resolver exists.
        /// </remarks>
        public bool TryGetValue(K key, out V value)
        {
            if (key == null)
            {
                throw new ArgumentNullException("key");
            }

            return InternalTryGetValue(key, out value);
        }

        /// <summary>
        /// Try to read cached data.
        /// </summary>
        /// <remarks>
        /// We're using a double-check lock pattern below to avoid locking on reads 
        /// although The FindExistingKey method will lock briefly if the key is found 
        /// to update the MRU list. 
        /// </remarks>
        private bool InternalTryGetValue(K key, out V value)
        {
            if (FindExistingEntry(key, out value))
            {
                this.instanceCounter.MarkCacheHit();
                return true;
            }
            else
            {
                if (itemResolver == null)
                {
                    value = default(V);
                    this.instanceCounter.MarkCacheMiss();
                    return false;
                }
                else
                {
                    lock (this._syncRoot)
                    {
                        if (FindExistingEntry(key, out value))
                        {
                            this.instanceCounter.MarkCacheHit();
                            return true;
                        }

                        value = itemResolver.Invoke(key);
                        this.InternalAdd(key, value);
                    }

                    this.instanceCounter.MarkCacheMiss();
                    return true;
                }
            }
        }

        /// <summary>
        /// Search for an item in the cache and if found, move ti to the front of the MRU 
        /// </summary>
        /// <param name="key">The key of the element to look up.</param>
        /// <param name="value">The value of the element if found.</param>
        /// <returns></returns>
        private bool FindExistingEntry(K key, out V value)
        {
            CacheEntry<K, V> entry;
            if (table.TryGetValue(key, out entry))
            {
                MakeMRU(entry);
                value = entry.Data;
                return true;
            }
            else
            {
                value = default(V);
                return false;
            }
        }

        /// <summary>
        /// Make the given CacheEntry the most recently used item in the mry list.
        /// </summary>
        /// <param name="entry">The enrty to bring to the front of the list.</param>
        private void MakeMRU(CacheEntry<K, V> entry)
        {
            /* Perf Note: It's not clear to me whether the cost of this lock is going to be more due to:
             *      A) The cost of acquiring and releasing the lock or
             *      B) The bottleneck created for cache reads. (This is a cache wide lock).
             */
            lock (this._syncRoot)
            {
                this.mruList.Remove(entry.MruNode);
                this.mruList.AddFirst(entry.MruNode);
            }
        }

        /// <summary>
        /// Add a new item to the Cache
        /// </summary>
        /// <param name="key">The key of the element to add</param>
        /// <param name="data">The value of the element to add. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
        /// <remarks>
        /// <para>
        /// This method is not thread safe, lock on _syncRoot before calling it.
        /// </para>
        /// <para>
        /// It might seem that compiler optimizations or processor 
        /// re-ordering will break the double-check lock pattern used before calling 
        /// this from the InternalTryGetValue method.
        /// (http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html)
        /// write re-ordering will NOT occur because the second write is not in the same 
        /// method and the Dictionary.Add method will not be inlined to bring it in 
        /// (it's already NGen compiled and it's a virtual call)
        /// </para>
        /// </remarks>
        private void InternalAdd(K key, V data)
        {
            uint dataSize = data.GetSize();
            EnsureCacheSize(dataSize);

            CacheEntry<K, V> entry = new CacheEntry<K, V>(key, data);
            
            this.ChangeSize(dataSize, 1);
            
            mruList.AddFirst(entry.MruNode);
            this.table.Add(key, entry);
        }

        /// <summary>
        /// Make sure the cache has enough space to grow by dataSize.
        /// If it doesn't,
        /// remove items from the end of the queue until there's enough space
        /// </summary>
        /// <param name="dataSize">size table should grow to acommodatey</param>
        /// <remarks>
        /// This method is not thread safe, lock on _syncRoot before calling it.
        /// </remarks>
        private void EnsureCacheSize(uint dataSize)
        {
            if (this._maxSize < (this._size + dataSize))
            {
                if (dataSize > this._maxSize)
                    throw new InvalidOperationException("data being inserted exceeds the maximum cache size");

                uint targetSize = this._maxSize - dataSize;
                ShrinkCache(targetSize);
            }
        }

        /// <summary>
        /// Purge some items from the cache to make room for new items or to acommodate a change in 
        /// MaxSize.
        /// </summary>
        /// <param name="targetSize">The size the cache needs to be reduced to</param>
        /// <remarks>
        /// This method is not thread safe, lock on _syncRoot before calling it.
        /// </remarks>
        private void ShrinkCache(uint targetSize)
        {
            uint sizeChange = 0;
            uint numPurges = 0;
            while (this._size - sizeChange > targetSize)
            {
                K lruKey = this.mruList.Last.Value;
                CacheEntry<K, V> lruEntry = this.table[lruKey];
                this.mruList.RemoveLast();
                this.table.Remove(lruKey);
                sizeChange += lruEntry.Data.GetSize();
                numPurges++;
            } 

            this.ChangeSize(-sizeChange, -numPurges);
        }

        class CacheEntry<KK, VV>
        {
            private LinkedListNode<KK> _mruNode;
            private VV _data;

            public CacheEntry(KK key, VV data)
            {
                this._data = data;
                this._mruNode = new LinkedListNode<KK>(key);
            }

            public LinkedListNode<KK> MruNode
            {
                get { return _mruNode; }
            }

            public VV Data
            {
                get { return _data; }
                set { _data = value; }
            }
        }
    }



    [ComVisible(false)]
    [XomPerformanceCounterCategoryAttr( "Common Cache Table", "XBox Online Cache", true )]
    public class CacheTableCounters : XomPerformanceCounterCategory
    {
        public void InitializeCounter(long maxSize)
        {
            this.CacheMaxSize.RawValue = maxSize;
            this.CacheUsePercentageBase.RawValue = maxSize;
            this.CacheTotalEntries.RawValue = 0;
            this.CacheSize.RawValue = 0;
            this.CacheHits.RawValue = 0;
            this.CacheMisses.RawValue = 0;
            this.CacheHitRatio.RawValue = 0;
            this.CacheHitRatioBase.RawValue = 0;
            this.CacheTurnoverRate.RawValue = 0;
            this.CacheUsePercentage.RawValue = 0;
        }

        public void ChangeCacheMaxSize(long change)
        {
            this.CacheMaxSize.RawValue += change;
            this.CacheUsePercentageBase.RawValue += change;
        }

        public void ChangeCacheSize(long sizeChange, long countChange)
        {
            this.CacheSize.RawValue += sizeChange;
            this.CacheUsePercentage.RawValue += sizeChange;

            this.CacheTotalEntries.RawValue += countChange;
            this.CacheTurnoverRate.RawValue += Math.Abs(countChange);
        }

        public void MarkCacheHit() { IncrementReads(true); }
        public void MarkCacheMiss() { IncrementReads(false); }
        public void UnMarkCacheHit() { DecrementReads(true); }
        public void UnMarkCacheMiss() { DecrementReads(false); }

        private void IncrementReads(bool isCacheHit)
        {
            if (isCacheHit)
            {
                this.CacheHits.Increment();
                this.CacheHitRatio.Increment();
            }
            else
            {
                this.CacheMisses.Increment();
            }

            this.CacheHitRatioBase.Increment();

            // protect from 32-bit overflow
            if (CacheHitRatioBase.RawValue > 0x70000000)
            {
                CacheHitRatio.RawValue >>= 16;
                CacheHitRatioBase.RawValue >>= 16;
            }
        }
        private void DecrementReads(bool wasCacheHit)
        {
            if (wasCacheHit)
            {
                this.CacheHits.Decrement();
                this.CacheHitRatio.Decrement();
            }
            else
            {
                this.CacheMisses.Decrement();
            }

            this.CacheHitRatioBase.Decrement();
        }

        public static CacheTableCounters GetCounter(string name)
        {
            return (CacheTableCounters)Counters.GetInstance(name);
        }

        static private CacheTableCounters Counters = new CacheTableCounters();

        [XomPerformanceCounterAttr("Cache Entries", "Number of entries in the cache", PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter CacheTotalEntries;

        [XomPerformanceCounterAttr("Cache Size", "Current cache size. This is the sum of the sizes of all the entries", PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CacheSize;

        [XomPerformanceCounterAttr("Cache Maximum Size", "This is the maximum allowable cache size", PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CacheMaxSize;

        [XomPerformanceCounterAttr("Cache Hits", "The total number of requests served from the cache", PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CacheHits;

        [XomPerformanceCounterAttr("Cache Misses", "The number of failed cache requests", PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CacheMisses;

        [XomPerformanceCounterAttr("Cache Hit Ratio", "The ratio of cache hits to cache misses", PerformanceCounterType.RawFraction)]
        public PerformanceCounter CacheHitRatio;

        [XomPerformanceCounterAttr("Cache Hit Ratio Base", "Base for the ratio of cache hits to cache misses", PerformanceCounterType.RawBase)]
        public PerformanceCounter CacheHitRatioBase;

        [XomPerformanceCounterAttr("Cache Turnover Rate", "The number of additions to and removals from the cache per second", PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CacheTurnoverRate;

        [XomPerformanceCounterAttr("Cache Use Percentage", "Percentage of Cache That is filled", PerformanceCounterType.RawFraction)]
        public PerformanceCounter CacheUsePercentage;

        [XomPerformanceCounterAttr("Cache Use Percentage Base", "Base for percentage of Cache That is filled", PerformanceCounterType.RawBase)]
        public PerformanceCounter CacheUsePercentageBase;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\BinaryWriterWrapper.cs ===
using System.IO;

namespace xonline.common.service
{
    public class BinaryWriterWrapper:BinaryWriter
    {
	    public BinaryWriterWrapper(Stream s):base(s)
	    {
	    }

        public override void Write(byte [] arrData)
        {
    		if (null != arrData && 0 == arrData.Length)
    		{
                /*
                    The only case we want to handle is when the array is a Byte Array of 0 length
                    Because: Writing a zero length byte array into a HttpResponseStream in Dot Net 2.0 will throw an Argument Exception.
                             This does not happen in 1.1
                */
    			return;	
    		}

		    base.Write(arrData);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\AccelerationProxyProt.cs ===
using System;
using System.IO;

namespace xonline.common.service
{
    public class AccelerationDefs
    {
///////////////////////////////////////////////////////////////////////////////////////////
// PROTOCOL VERSIONS
//
// 1 -- initial protocol version.
//
// 2 -- added optimistic concurrency via versions.  QUERY_EX_RESP and SET_DATA_EX_REQ added.
//
///////////////////////////////////////////////////////////////////////////////////////////

        public const uint ACCELERATION_PROTOCOL_VERSION_CURRENT = 2;
        public const uint ACCELERATION_MESSAGE_HEADER_SIZE = 16;
        public const uint ACCELERATION_MAX_PACKET_SIZE = 16384;
        public const uint ACCELERATION_INCREMENT_HALFLIFE_INFINITE = 0xFFFFFFFF;
        public const uint ACCELERATION_SET_DATA_VERSION_OVERWRITE = 0xFFFFFFFF;
    }

    public enum ACCELERATION_MSG_TYPES
    {
        // request types:
        XBMSG_MIN_REQ                    = 1000,
        XBMSG_QUERY_REQ                  = 1000,
        XBMSG_INSERT_REQ                 = 1001,
        XBMSG_REMOVE_REQ                 = 1002,
        XBMSG_SET_DATA_REQ               = 1003,
        XBMSG_CONTINUATION_REQ           = 1004,
        XBMSG_INCREMENT_REQ              = 1005,
        XBMSG_CHANGELIST_REQ             = 1006,
        XBMSG_MAX_REQ                    = 1006,

        // response types:
        XBMSG_MIN_RESP                   = 1100,
        XBMSG_EMPTY_RESP                 = 1100,
        XBMSG_QUERY_RESP                 = 1101,
        XBMSG_INSERT_RESP                = 1102,
        XBMSG_REMOVE_RESP                = 1103,
        XBMSG_SET_DATA_RESP              = 1104,
        XBMSG_INCREMENT_RESP             = 1105,
        XBMSG_CHANGELIST_RESP            = 1106,
        XBMSG_MAX_RESP                   = 1106,
    };
    
    public class AccelerationMessageHeader : WireData
    {
        public uint dwProtocolVersion;
        public uint dwMsgType;
        public uint dwMsgLen;
        public uint dwSeqNum;

        public AccelerationMessageHeader()
        {
        }

        public AccelerationMessageHeader(ACCELERATION_MSG_TYPES eType)
        {
            dwProtocolVersion = AccelerationDefs.ACCELERATION_PROTOCOL_VERSION_CURRENT;
            dwMsgType = (uint)eType;
        }

        public override int Size()
        {
            return (int)AccelerationDefs.ACCELERATION_MESSAGE_HEADER_SIZE;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - AccelerationMessageHeader::WriteStream binaryWriter is null");
            }

            if ((dwMsgType < (uint)ACCELERATION_MSG_TYPES.XBMSG_MIN_REQ) ||
                (dwMsgType > (uint)ACCELERATION_MSG_TYPES.XBMSG_MAX_REQ))
            {
                throw new Exception("Fatal Error - AccelerationMessageHeader::WriteStream dwMsgType not a valid request type.");                
            }

            dwMsgLen = (uint)Size();
            
            binaryWriter.Write(dwProtocolVersion);
            binaryWriter.Write(dwMsgType);
            binaryWriter.Write(dwMsgLen);
            binaryWriter.Write(dwSeqNum);
        }
    
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - AccelerationMessageHeader::ReadStream binaryReader is null");
            }

            try
            {
                dwProtocolVersion = binaryReader.ReadUInt32();
                dwMsgType = binaryReader.ReadUInt32();
                dwMsgLen = binaryReader.ReadUInt32();
                dwSeqNum = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.ACCELERATION_END_OF_STREAM, "Reached end of stream trying to read response object header", e);
            }
            
            if ((dwMsgType < (uint)ACCELERATION_MSG_TYPES.XBMSG_MIN_RESP) ||
                (dwMsgType > (uint)ACCELERATION_MSG_TYPES.XBMSG_MAX_RESP))
            {
                throw new Exception("Fatal Error - AccelerationMessageHeader::ReadStream dwMsgType not a valid response type.");                
            }
            
            return this;
        }
    }

    public class AccelerationQueryRequest : AccelerationMessageHeader
    {
        public uint dwKeySize;
        public byte[] rgbKey;

        public AccelerationQueryRequest() : base(ACCELERATION_MSG_TYPES.XBMSG_QUERY_REQ)
        {
        }

        public override int Size()
        {
            return base.Size() + 4 + ((rgbKey == null) ? 0 : rgbKey.Length);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - AccelerationQueryRequest::WriteStream binaryWriter is null");
            }

            dwKeySize = (rgbKey == null) ? 0 : (uint)rgbKey.Length;
            base.WriteStream(binaryWriter);
            
            binaryWriter.Write(dwKeySize);

            if (rgbKey != null)
            {
                binaryWriter.Write(rgbKey);
            }
        }
    }

    public class AccelerationQueryResponse : AccelerationMessageHeader
    {
        public HResult hr;
        public uint dwValueSize;
        public uint dwValidSeconds;
        public uint dwVersion;
        public byte[] rgbValue;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - AccelerationQueryResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
                dwValueSize = binaryReader.ReadUInt32();
                dwValidSeconds = binaryReader.ReadUInt32();
                dwVersion = binaryReader.ReadUInt32();
                rgbValue = binaryReader.ReadBytes((int)dwValueSize);
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.ACCELERATION_END_OF_STREAM, "Reached end of stream trying to read query response object", e);
            }

            return this;
        }
    }

    public class AccelerationInsertRequest : AccelerationMessageHeader
    {
        public uint dwKeySize;
        public uint dwValueSize;
        public uint dwAbsoluteSeconds;
        public uint dwSlidingSeconds;
        public byte[] rgbKey;
        public byte[] rgbValue;

        public AccelerationInsertRequest() : base(ACCELERATION_MSG_TYPES.XBMSG_INSERT_REQ)
        {
        }

        public override int Size()
        {
            return base.Size() + 16 + ((rgbKey == null) ? 0 : rgbKey.Length) + ((rgbValue == null) ? 0 : rgbValue.Length);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - AccelerationInsertRequest::WriteStream binaryWriter is null");
            }

            dwKeySize = (rgbKey == null) ? 0 : (uint)rgbKey.Length;
            dwValueSize = (rgbValue == null) ? 0 : (uint)rgbValue.Length;
            base.WriteStream(binaryWriter);
            
            binaryWriter.Write(dwKeySize);
            binaryWriter.Write(dwValueSize);
            binaryWriter.Write(dwAbsoluteSeconds);
            binaryWriter.Write(dwSlidingSeconds);

            if (rgbKey != null)
            {
                binaryWriter.Write(rgbKey);
            }

            if (rgbValue != null)
            {
                binaryWriter.Write(rgbValue);
            }
        }
    }

    public class AccelerationInsertResponse : AccelerationMessageHeader
    {
        public HResult hr;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - AccelerationInsertResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.ACCELERATION_END_OF_STREAM, "Reached end of stream trying to read insert response object", e);
            }
            
            return this;
        }
    }

    public class AccelerationRemoveRequest : AccelerationMessageHeader
    {
        public uint dwKeySize;
        public bool fMatchExact;
        public byte[] rgbKey;

        public AccelerationRemoveRequest() : base(ACCELERATION_MSG_TYPES.XBMSG_REMOVE_REQ)
        {
        }

        public override int Size()
        {
            return base.Size() + 8 + ((rgbKey == null) ? 0 : rgbKey.Length);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - AccelerationRemoveRequest::WriteStream binaryWriter is null");
            }

            dwKeySize = (rgbKey == null) ? 0 : (uint)rgbKey.Length;
            base.WriteStream(binaryWriter);
            
            binaryWriter.Write(dwKeySize);
            binaryWriter.Write(fMatchExact ? (uint)1 : (uint)0);            

            if (rgbKey != null)
            {
                binaryWriter.Write(rgbKey);
            }
        }
    }

    public class AccelerationRemoveResponse : AccelerationMessageHeader
    {
        public HResult hr;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - AccelerationRemoveResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.ACCELERATION_END_OF_STREAM, "Reached end of stream trying to read remove response object", e);
            }

            return this;
        }
    }

    public class AccelerationSetDataRequest : AccelerationMessageHeader
    {
        public uint dwKeySize;
        public uint dwValueSize;
        public uint dwAbsoluteSeconds;
        public uint dwSlidingSeconds;
        public uint dwVersion;
        public byte[] rgbKey;
        public byte[] rgbValue;

        public AccelerationSetDataRequest() : base(ACCELERATION_MSG_TYPES.XBMSG_SET_DATA_REQ)
        {
        }

        public override int Size()
        {
            return base.Size() + 20 + ((rgbKey == null) ? 0 : rgbKey.Length) + ((rgbValue == null) ? 0 : rgbValue.Length);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - AccelerationSetDataRequest::WriteStream binaryWriter is null");
            }

            dwKeySize = (rgbKey == null) ? 0 : (uint)rgbKey.Length;
            dwValueSize = (rgbValue == null) ? 0 : (uint)rgbValue.Length;
            base.WriteStream(binaryWriter);
            
            binaryWriter.Write(dwKeySize);
            binaryWriter.Write(dwValueSize);
            binaryWriter.Write(dwAbsoluteSeconds);
            binaryWriter.Write(dwSlidingSeconds);
            binaryWriter.Write(dwVersion);

            if (rgbKey != null)
            {
                binaryWriter.Write(rgbKey);
            }

            if (rgbValue != null)
            {
                binaryWriter.Write(rgbValue);
            }
        }
    }

    public class AccelerationSetDataResponse : AccelerationMessageHeader
    {
        public HResult hr;
        public uint dwVersion;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - AccelerationSetDataResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
                dwVersion = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.ACCELERATION_END_OF_STREAM, "Reached end of stream trying to read setdata response object", e);
            }

            return this;
        }
    }

    public class AccelerationIncrementRequest : AccelerationMessageHeader
    {
        public uint dwKeySize;
        public ulong qwIncrementAmount;
        public uint dwHalfLifeSeconds;
        public uint dwAbsoluteSeconds;
        public uint dwSlidingSeconds;
        public byte[] rgbKey;

        public AccelerationIncrementRequest() : base(ACCELERATION_MSG_TYPES.XBMSG_INCREMENT_REQ)
        {
        }

        public override int Size()
        {
            return base.Size() + 24 + ((rgbKey == null) ? 0 : rgbKey.Length);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - AccelerationIncrementRequest::WriteStream binaryWriter is null");
            }

            dwKeySize = (rgbKey == null) ? 0 : (uint)rgbKey.Length;
            base.WriteStream(binaryWriter);
            
            binaryWriter.Write(dwKeySize);
            binaryWriter.Write(qwIncrementAmount);
            binaryWriter.Write(dwHalfLifeSeconds);
            binaryWriter.Write(dwAbsoluteSeconds);
            binaryWriter.Write(dwSlidingSeconds);

            if (rgbKey != null)
            {
                binaryWriter.Write(rgbKey);
            }
        }
    }

    public class AccelerationIncrementResponse : AccelerationMessageHeader
    {
        public HResult hr;
        public ulong qwResult;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - AccelerationIncrementResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
                qwResult = binaryReader.ReadUInt64();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.ACCELERATION_END_OF_STREAM, "Reached end of stream trying to read increment response object", e);
            }
            
            return this;
        }
    }

    public class AccelerationChangelistRequest : AccelerationMessageHeader
    {
        public uint dwChangeID;

        public AccelerationChangelistRequest() : base(ACCELERATION_MSG_TYPES.XBMSG_CHANGELIST_REQ)
        {
        }

        public override int Size()
        {
            return base.Size() + 4;
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - AccelerationChangelistRequest::WriteStream binaryWriter is null");
            }

            base.WriteStream(binaryWriter);
            
            binaryWriter.Write(dwChangeID);
        }
    }

    public class AccelerationChangelistResponse : AccelerationMessageHeader
    {
        public HResult hr;
        public uint dwNewChangeID;
        public uint dwNumChanges;

        [WireInfo(SizeParam="dwNumChanges")]
        public AccelerationChangelistItem[] rgChanges;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - AccelerationQueryResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
                dwNewChangeID = binaryReader.ReadUInt32();
                dwNumChanges = binaryReader.ReadUInt32();

                rgChanges = new AccelerationChangelistItem[dwNumChanges];
                for (uint iChange = 0; iChange < dwNumChanges; iChange++)
                {
                    rgChanges[iChange] = new AccelerationChangelistItem();
                    rgChanges[iChange].ReadStream(binaryReader);
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.ACCELERATION_END_OF_STREAM, "Reached end of stream trying to read query response object", e);
            }

            return this;
        }
    }

    public class AccelerationChangelistItem : WireData
    {
        public uint cbKey;
        
        [WireInfo(SizeParam="dwSize")]
        public byte[] rgbKey;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - AccelerationChangelistItem::ReadStream binaryReader is null");
            }

            try
            {
                cbKey = binaryReader.ReadUInt32();
                rgbKey = binaryReader.ReadBytes((int)cbKey);
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.ACCELERATION_END_OF_STREAM, "Reached end of stream trying to read query response object", e);
            }

            return this;
        }
    }

    public class AccelerationEmptyResponse : AccelerationMessageHeader
    {
        public HResult hr;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - AccelerationEmptyResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.ACCELERATION_END_OF_STREAM, "Reached end of stream trying to read empty response object", e);
            }
            
            return this;
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\BehaviorInjection.cs ===
using System;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Reflection;
using System.Threading;
using System.Web;
using System.Web.Services.Protocols;
using System.Xml;

using xonline.common.config;

namespace xonline.common.service
{
    public abstract class BehaviorInjection
    {
        public string InjectionName { get { return _injectionName; } }
        public bool IsPassThrough { get { return _isPassThrough; } }
        public string InjectionLine
        {
            get { return String.Format("{0};{1};{2}", _injectionName, _specificParams, _genericParams); }
        }

        protected BehaviorInjection(string injectionName, string specificParams, string genericParams)
        {
            _injectionName = injectionName;
            _specificParams = specificParams;
            _genericParams = genericParams;
            _isPassThrough = ParameterParsingUtil.ParseAsNameValuePairs(genericParams)["passThrough"] != null;
        }

        private readonly string _injectionName;
        private readonly string _genericParams;
        private readonly string _specificParams;
        private readonly bool _isPassThrough;
    }


    public sealed class UrlRedirect : BehaviorInjection
    {
        public string Url { get { return _url; } }

        private UrlRedirect(string injectionName, string specificParams, string genericParams)
            : base(injectionName, specificParams, genericParams)
        {
            _url = specificParams;
        }

        public static UrlRedirect Create(BehaviorRequest behaviorRequest)
        {
            return new UrlRedirect(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }

        private readonly string _url;
    }

    internal sealed class SprocFailure : BehaviorInjection
    {
        public void PerformFailureAction(string db, string sproc)
        {
            if (StripDbPrefixes(sproc.ToLower()) == _sproc || StripWebstorePrefixes(db.ToLower()) == _db)
            {
                if (_timeoutInMs.HasValue)
                {
                    Thread.Sleep(_timeoutInMs.Value);
                }
                if (_ex != null)
                {
                    throw _ex;
                }
            }
        }

        private SprocFailure(string injectionName, string specificParams, string genericParams)
            : base(injectionName, specificParams, genericParams)
        {
            NameValueCollection parameters = ParameterParsingUtil.ParseAsNameValuePairs(specificParams);

            if (String.IsNullOrEmpty(parameters["sproc"]) && String.IsNullOrEmpty(parameters["db"]))
            {
                throw new Exception(String.Format("SprocFailure must have one of sproc name or db name associated with it, but neither was found in '{0}'.", specificParams));
            }
            if (!String.IsNullOrEmpty(parameters["sproc"])  && !String.IsNullOrEmpty(parameters["db"]))
            {
                throw new Exception(String.Format("SprocFailure must have one of sproc name or db name associated with it, but both were found in '{0}'.", specificParams));
            }
            if (String.IsNullOrEmpty(parameters["exception"]) && String.IsNullOrEmpty(parameters["timeoutMS"]))
            {
                throw new Exception(String.Format("SprocFailure must have at least one of 'exception' and 'timeoutMS' but neither was found in '{0}'.", specificParams));
            }

            if (!String.IsNullOrEmpty(parameters["sproc"]))
            {
                _sproc = StripDbPrefixes(parameters["sproc"].ToLower());
            }

            if (!String.IsNullOrEmpty(parameters["db"]))
            {
                _db = parameters["db"].ToLower();
            }

            if (!String.IsNullOrEmpty(parameters["timeoutMS"]))
            {
                _timeoutInMs = Int32.Parse(parameters["timeoutMS"]);
            }

            // Exception is harder--we need to find that exception type and create our exception to throw later.
            if (!String.IsNullOrEmpty(parameters["exception"]))
            {
                Type exType = Type.GetType(parameters["exception"], true);
                ConstructorInfo ci = exType.GetConstructor(new Type[] { typeof(string) });
                _ex = (Exception)ci.Invoke(new object[] { String.Format("Sproc '{0}' failing by client request.", _sproc) });
            }
        }

        // This actually only normalizes the sproc in one way, which I found to be
        // the most common in our codebase. A more sophisticated solution could be used
        // if we find things with brackets or somthing.
        private string StripDbPrefixes(string rawSproc)
        {
            string prefix = "dbo.";
            if (rawSproc.StartsWith(prefix))
            {
                return rawSproc.Remove(0, prefix.Length);
            }
            else
            {
                return rawSproc;
            }
        }

        private string StripWebstorePrefixes(string rawDb)
        {
            int separatorIndex = rawDb.LastIndexOf('\\');

            if (separatorIndex != -1)
            {
                return rawDb.Substring(separatorIndex + 1);
            }
            else
            {
                return rawDb;
            }
        }

        public static void HandleBehaviorInjection(string db, string sproc)
        {
            // Short-circuit on an empty stored-proc
            if (String.IsNullOrEmpty(db) && String.IsNullOrEmpty(sproc))
            {
                return;
            }

            List<SprocFailure> sprocFailures;
            if (RequestHeaderBehaviorInjectionMgr.TryGetBehaviorInjections("SprocFailure", out sprocFailures))
            {
                sprocFailures.ForEach(delegate(SprocFailure sf) { sf.PerformFailureAction(db, sproc); });
            }
        }

        public static SprocFailure Create(BehaviorRequest behaviorRequest)
        {
            return new SprocFailure(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }

        private readonly string _sproc;
        private readonly string _db;
        private readonly Exception _ex;
        private readonly int? _timeoutInMs;
    }

    public sealed class ABCHFailure : BehaviorInjection
    {
        public static void HandleBehaviorInjectionFailure()
        {
            bool forceFail = ForceFailOn;
            if (forceFail)
            {
                throw new ApplicationException("ABCHFailure behavior injected.");
            }
        }

        public static bool ForceFailOn
        {
            get
            {
                ABCHFailure obj;
                return RequestHeaderBehaviorInjectionMgr.TryGetBehaviorInjection("ABCHFailure", out obj);
            }
        }

        private ABCHFailure(string injectionName, string specificParams, string genericParams)
            : base(injectionName, specificParams, genericParams)
        {
            if (!String.IsNullOrEmpty(specificParams))
            {
                throw new Exception(String.Format("ABCHFailure takes no parameters, but the parameter string '{0}' was passed.", specificParams));
            }
        }

        public static ABCHFailure Create(BehaviorRequest behaviorRequest)
        {
            return new ABCHFailure(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }
    }


    public sealed class XbancMiss : BehaviorInjection
    {
        public bool ForceMiss { get { return true; } }

        public static bool HandleBehaviorInjectionQuery(uint[] retVals)
        {
            bool forceMiss = ForceMissOn;
            if (forceMiss)
            {
                for (int idx = 0; idx < retVals.Length; ++idx)
                {
                    retVals[idx] = HResult.S_FALSE;
                }
            }
            return forceMiss;
        }

        public static bool ForceMissOn
        {
            get
            {
                XbancMiss xbancMiss;
                return RequestHeaderBehaviorInjectionMgr.TryGetBehaviorInjection("XbancMiss", out xbancMiss) && xbancMiss.ForceMiss;
            }
        }

        private XbancMiss(string injectionName, string specificParams, string genericParams)
            : base(injectionName, specificParams, genericParams)
        {
            if (!String.IsNullOrEmpty(specificParams))
            {
                throw new Exception(String.Format("XbancMiss takes no parameters, but the parameter string '{0}' was passed.", specificParams));
            }
        }

        public static XbancMiss Create(BehaviorRequest behaviorRequest)
        {
            return new XbancMiss(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }
    }

    public sealed class NpdbOverrideInjection : BehaviorInjection, ConfigInstance.IConfigurationOverride
    {
        public static string GetInjectedNpdbValue(string setting, string value)
        {
            List<NpdbOverrideInjection> npdbOverrides;
            if (!IsBlackListedSetting(setting) && RequestHeaderBehaviorInjectionMgr.TryGetBehaviorInjections("NpdbOverride", out npdbOverrides))
            {
                NpdbOverrideInjection noi = npdbOverrides.Find(delegate(NpdbOverrideInjection n) { return n._setting == setting; });
                if (noi != null)
                {
                    return noi._value;
                }
            }
            return value;
        }

        private NpdbOverrideInjection(string injectionName, string specificParams, string genericParams)
            : base(injectionName, specificParams, genericParams)
        {
            NameValueCollection parameters = ParameterParsingUtil.ParseAsNameValuePairs(specificParams, '\\');
            if (parameters.Count != 2 || String.IsNullOrEmpty(parameters["setting"]) || String.IsNullOrEmpty(parameters["value"]))
            {
                throw new Exception(String.Format(
                    "NpdbOverride takes exactly two parameters--'setting' and 'value'. Parameter string was {0}.", specificParams));
            }

            _setting = parameters["setting"];
            _value = parameters["value"];

            Config.DefaultInstance.ConfigurationOverride = this;
        }

        string ConfigInstance.IConfigurationOverride.GetInjectedNpdbValue(string setting, string value)
        {
            return NpdbOverrideInjection.GetInjectedNpdbValue(setting, value);
        }

        public static NpdbOverrideInjection Create(BehaviorRequest behaviorRequest)
        {
            return new NpdbOverrideInjection(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }

        private static bool IsBlackListedSetting(string setting)
        {
            return Array.Exists(s_blacklistedSettings, delegate(string s) { return setting == s; } );
        }

        private readonly string _setting;
        private readonly string _value;

        private static string[] s_blacklistedSettings = new string[] { Setting.bif_AllowBehaviorInjections };
    }


    public sealed class BehaviorRequest
    {
        public BehaviorRequest(string name, string specificParams, string genericParams)
        {
            // We need to trim the name before checking if the injection is registered
            _name = name.Trim();

            if (!RequestHeaderBehaviorInjectionMgr.IsBehaviorRegistered(_name))
            {
                throw new Exception(String.Format("Client is requesting unregistered behavior '{0}'.", name));
            }

            _specificParams = specificParams.Trim();
            _genericParams = genericParams.Trim();
        }

        public string Name { get { return _name; } }
        public string SpecificParams { get { return _specificParams; } }
        public string GenericParams { get { return _genericParams; } }

        private readonly string _name;
        private readonly string _specificParams;
        private readonly string _genericParams;
    }

    public sealed class DmpFailure : BehaviorInjection
    {
        public delegate void PostCallDelegate();

        internal class DmpApiBehavior
        {
            internal DmpApiBehavior(string api)
            {
                Api = api;
            }

            public string Api;
        }

        internal class DmpApiFailure : DmpApiBehavior
        {
            internal DmpApiFailure(string api, string error) : base(api)
            {
                Error = error;
            }
            public string Error;
        }

        internal class DmpApiTimeout : DmpApiBehavior
        {
            internal DmpApiTimeout(string api, int timeoutMillis) : base(api)
            {
                TimeoutMillis = timeoutMillis;
            }

            public int TimeoutMillis;
        }

        internal class DmpApiOutOfMemory : DmpApiBehavior
        {
            internal DmpApiOutOfMemory(string api) : base(api)
            {
            }
        }

        internal static DmpApiBehavior CreateNewDmpApiBehavior(string api, string error, string timeout)
        {
            if ( string.IsNullOrEmpty(api) )
            {
                throw new ArgumentNullException("CreateNewDmpApiBehavior must have an API name associated with it but none was found.");
            }

            if ( string.IsNullOrEmpty(error) && string.IsNullOrEmpty(timeout) )
            {
                throw new ArgumentException("CreateNewDmpApiBehavior must have either an error name or a timeout associated with it but none was found.");
            }

            if ( !string.IsNullOrEmpty(error) )
            {
                if ( error.Equals("System.OutOfMemoryException", StringComparison.InvariantCultureIgnoreCase) )
                {
                    return new DmpApiOutOfMemory(api);
                }
                else
                {
                    return new DmpApiFailure(api, error);
                }
            }
            else
            {
                int timeoutMillis = 1;
                return new DmpApiTimeout(api, timeoutMillis);
            }
        }

        internal static DmpApiBehavior CreateNewDmpApiBehavior(XmlReader rdr)
        {
            if ( rdr == null ) throw new ArgumentNullException("rdr");
            if ( rdr.NodeType != XmlNodeType.Element ) throw new ArgumentException("rdr must be positioned at an Element node.");

            string api = rdr.GetAttribute("api");
            string error = rdr.GetAttribute("error");
            string timeout = rdr.GetAttribute("timeout");

            return CreateNewDmpApiBehavior(api, error, timeout);
        }

        private DmpFailure(string injectionName, string specificParams, string genericParams) :
            base(injectionName, specificParams, genericParams)
        {
            List<DmpApiBehavior> apiBehaviorList = new List<DmpApiBehavior>();


            string xmlRootTag = "<" + injectionName + "List>";

            if ( specificParams.StartsWith(xmlRootTag) )
            {
                apiBehaviorList = InitBehaviorListFromXml(specificParams);
            }
            else
            {
                NameValueCollection parameters = ParameterParsingUtil.ParseAsNameValuePairs(specificParams);
                string api = parameters["api"];
                string error = parameters["error"];
                string timeout = parameters["timeout"];

                apiBehaviorList.Add(CreateNewDmpApiBehavior(api, error, timeout));
            }

            _dmpApiBehaviors = apiBehaviorList;
        }

        private List<DmpApiBehavior> InitBehaviorListFromXml(string xmlText)
        {
            string rootElementName = this.InjectionName + "List";

            List<DmpApiBehavior> apiBehaviorList = new List<DmpApiBehavior>();

            XmlReader rdr = new XmlTextReader(new StringReader(xmlText));
            rdr.MoveToContent();
            while (rdr.EOF == false)
            {
                if (rdr.Name == rootElementName)
                {
                    if (rdr.NodeType == XmlNodeType.EndElement)
                    {
                        rdr.Skip();
                    }
                    else
                    {
                        rdr.ReadStartElement();
                    }
                    continue;
                }

                if (rdr.Name == this.InjectionName)
                {
                    apiBehaviorList.Add(CreateNewDmpApiBehavior(rdr));
                }
                rdr.Skip();
            }

            return apiBehaviorList;
        }

        private static bool CanRetryError(string dmpError)
        {
            switch (dmpError)
            {
            case "DMP_E_UNKNOWNSERVER_ERROR":
            case "DMP_E_CONFIGURATION_ERROR":
            case "DMP_E_SYSTEM_INTERNAL_ERROR":
            case "DMP_E_PROMO_POINTS_UNAVAILIABLE":
                return true;
            default:
                return false;
            }
        }

        public PostCallDelegate PerformFailureAction(string dmpApi, ref int timeout)
        {
            PostCallDelegate noop = delegate() { };

            foreach (DmpApiBehavior apiBehavior in _dmpApiBehaviors)
            {
                if (apiBehavior.Api.Equals(dmpApi, StringComparison.InvariantCultureIgnoreCase))
                {
                    if ( apiBehavior is DmpApiFailure)
                    {
                        string dmpError = ((DmpApiFailure)apiBehavior).Error;

                        string detailMessage = "This error was artifically injected and was not generated by the actual DMP service.";

                        string canRetry = CanRetryError(dmpError).ToString().ToLower();

                        string innerXml = string.Format("<DMPErrorInfo xmlns=\"http://schemas.microsoft.com/DMP/2004/09/API\"><Property>DMP</Property><Error>{0}</Error><DetailMessage>{1}</DetailMessage><CanRetry>{2}</CanRetry></DMPErrorInfo>", dmpError, detailMessage, canRetry);

                        // create a Details element to return in the SoapException
                        XmlDocument doc = new XmlDocument();
                        XmlNode detailNode = doc.CreateNode(XmlNodeType.Element, SoapException.DetailElementName.Name, SoapException.DetailElementName.Namespace);

                        // construct the SoapException
                        SoapException se = new SoapException(detailMessage, SoapException.ClientFaultCode, HttpContext.Current.Request.Url.AbsoluteUri, detailNode);

                        // overwrite the InnerXml with the serialized DMPErrorInfo
                        se.Detail.InnerXml = innerXml;

                        throw se;
                    }
                    else if ( apiBehavior is DmpApiOutOfMemory )
                    {
                        PostCallDelegate postCall = delegate()
                            {
                                throw new OutOfMemoryException(string.Format("Artificial OutOfMemory exception introduced by BehaviorInjection. Call to DMP.{0} was successfully made", apiBehavior.Api));
                            };

                        return postCall;
                    }
                    else if ( apiBehavior is DmpApiTimeout )
                    {
                       timeout = ((DmpApiTimeout)apiBehavior).TimeoutMillis;

                        // For timeouts, it is possible that the DMP API call can
                        // succeed even with a timeout of 1 ms specified.
                        //
                        // This is presumably because the web service call completes
                        // before the internal timer has a chance to fire.
                        //
                        // This delegate will be called immediately after the DMP call
                        // completes and will force an artifical timeout exception.
                        PostCallDelegate postCall = delegate()
                            {
                                throw new WebException(string.Format("Artificial timeout for {0} introduced by BehaviorInjection. Call to DMP.{0} was successfully made", apiBehavior.Api), WebExceptionStatus.Timeout);
                            };

                        return postCall;
                    }
                }
            }

            return noop;
        }

        public static PostCallDelegate HandleBehaviorInjection(string dmpApi, ref int timeout)
        {
            PostCallDelegate noop = delegate() { };

            if ( string.IsNullOrEmpty(dmpApi) )
            {
                return noop;
            }

            DmpFailure dmpFailure;
            if ( RequestHeaderBehaviorInjectionMgr.TryGetBehaviorInjection("DmpFailure", out dmpFailure) )
            {
                return dmpFailure.PerformFailureAction(dmpApi, ref timeout);
            }
            else
            {
                // not a timeout so return a noop delegate
                return noop;
            }
        }

        public static DmpFailure Create(BehaviorRequest behaviorRequest)
        {
            return new DmpFailure(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }

        List<DmpApiBehavior> _dmpApiBehaviors = null;
    }

    public sealed class PassportLoginFailure : BehaviorInjection
    {
        private PassportLoginFailure(string injectionName, string specificParams, string genericParams) :
            base(injectionName, specificParams, genericParams)
        {
            NameValueCollection parameters = ParameterParsingUtil.ParseAsNameValuePairs(specificParams);
            string faultcode = parameters["faultcode"];
            string faultstring = parameters["faultstring"];
            string timeout = parameters["timeout"];

            if ( string.IsNullOrEmpty(faultcode) && string.IsNullOrEmpty(timeout) )
            {
                throw new ArgumentNullException("PassportLoginFailure must have at least one of 'faultcode' or 'timeout' but neither was found in '{0}'.", specificParams);
            }

            if ( !string.IsNullOrEmpty(faultcode) )
            {
                _faultcode = faultcode;
                _faultstring = faultstring;
            }
            else
            {
                if ( !string.IsNullOrEmpty(timeout) )
                {
                    _timeoutMillis = Int32.Parse(timeout);
                }
                else
                {
                    _timeoutMillis = 0;
                }
            }
        }

        public string PerformFailureAction(ref int timeout)
        {
            string xmlReply = null;

            if ( !string.IsNullOrEmpty(_faultcode) )
            {
                string xmlReplyFormat =
                    "<?xml version='1.0' encoding='UTF-8'?>" +
                    "<S:Envelope xmlns:S='http://schemas.xmlsoap.org/soap/envelope/' xmlns:wsse='http://schemas.xmlsoap.org/ws/2002/04/secext' xmlns:psf='http://schemas.microsoft.com/Passport/SoapServices/SOAPFault'>" +
                        "<S:Fault>" +
                            "<faultcode>0x{0}</faultcode>" +
                            "<faultstring>{1} (this error was artificially injected and was not returned by the actual Passport Login API)</faultstring>" +
                        "</S:Fault>" +
                    "</S:Envelope>";

                xmlReply = string.Format(xmlReplyFormat, (_faultcode ?? ""), (_faultstring ?? ""));
            }
            else
            {
                // If the timeout value is 0, force an artificial timeout WebException to be thrown.
                // Between the granularity of the .NET timeout mechanism and the low latency of the
                // Passport EncryptedProxiedAuth API, specifying a timeout of 1 millisecond often
                // results in a successful call rather than a timeout.
                if ( _timeoutMillis.HasValue && _timeoutMillis.Value == 0 )
                {
                    throw new WebException("Artificial timeout introduced by BehaviorInjection.  No call to WLID was actually made.", WebExceptionStatus.Timeout);
                }

                timeout = _timeoutMillis.Value;
            }

            return xmlReply;
        }

        public static string HandleBehaviorInjection(ref int timeout)
        {
            PassportLoginFailure ppFailure;
            if ( RequestHeaderBehaviorInjectionMgr.TryGetBehaviorInjection("PassportLoginFailure", out ppFailure) )
            {
                return ppFailure.PerformFailureAction(ref timeout);
            }

            return null;
        }

        public static PassportLoginFailure Create(BehaviorRequest behaviorRequest)
        {
            return new PassportLoginFailure(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }

        string  _faultcode     = string.Empty;
        string  _faultstring   = string.Empty;
        int?    _timeoutMillis = 0;
    }

    public sealed class MusicnetFailure : BehaviorInjection
    {
        public void PerformFailureAction(string api, string server, string transactionId, ref int timeout)
        {
            if ( api.Equals(_api, StringComparison.InvariantCultureIgnoreCase) )
            {
                if ( _timeoutMillis.HasValue )
                {
                    timeout = _timeoutMillis.Value;
                }
                else
                {
                    string detailMsg = "This error was artifically injected and was not generated by the actual DMP service.";

                    string innerXml = string.Format("<EcommerceB2BServiceException xmlns=\"http://ws.musicnet.com\"><code>{0}</code><details>{1}</details><message>{2}</message><server>{3}</server><transactionId>{4}</transactionId></EcommerceB2BServiceException>", _error, detailMsg, _message ?? "", server, transactionId);

                    // create a Details element to return in the SoapException
                    XmlDocument doc = new XmlDocument();
                    XmlNode detailNode = doc.CreateNode(XmlNodeType.Element, SoapException.DetailElementName.Name, SoapException.DetailElementName.Namespace);

                    // construct the SoapException
                    SoapException se = new SoapException(detailMsg, SoapException.ClientFaultCode, HttpContext.Current.Request.Url.AbsoluteUri, detailNode);

                    // overwrite the InnerXml with the serialized DMPErrorInfo
                    se.Detail.InnerXml = innerXml;

                    throw se;
                }
            }
        }

        private MusicnetFailure(string injectionName, string specificParams, string genericParams)
            : base(injectionName, specificParams, genericParams)
        {
            NameValueCollection parameters = ParameterParsingUtil.ParseAsNameValuePairs(specificParams);

            string api = parameters["api"];

            if ( string.IsNullOrEmpty(api) )
            {
                throw new Exception(String.Format("MusicnetFailure must have an API name associated with it but none was found in '{0}'.", specificParams));
            }

            _api = api;

            string error = parameters["error"];
            string timeout = parameters["timeout"];

            if ( string.IsNullOrEmpty(error) && string.IsNullOrEmpty(timeout) )
            {
                throw new Exception(String.Format("MusicnetFailure must have at least one of 'error' and 'timeout' but neither was found in '{0}'.", specificParams));
            }

            if ( !string.IsNullOrEmpty(error) )
            {
                _error = error;
                _message = parameters["message"];
            }
            else
            {
                if ( !string.IsNullOrEmpty(timeout) )
                {
                    _timeoutMillis = Int32.Parse(timeout);
                }
                else
                {
                    _timeoutMillis = 1;
                }
            }

        }

        public static void HandleBehaviorInjection(string api, string transactionId, ref int timeout)
        {
            MusicnetFailure mnetFailure;
            if (RequestHeaderBehaviorInjectionMgr.TryGetBehaviorInjection("MusicnetFailure", out mnetFailure))
            {
                mnetFailure.PerformFailureAction(api, Environment.MachineName, transactionId, ref timeout);
            }
        }

        public static MusicnetFailure Create(BehaviorRequest behaviorRequest)
        {
            return new MusicnetFailure(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }

        string _api = string.Empty;
        string _error = string.Empty;
        string _message = string.Empty;
        int?   _timeoutMillis;
    }

    public sealed class DummyScsFailure : BehaviorInjection
    {
        private DummyScsFailure(string injectionName, string specificParams, string genericParams)
            : base(injectionName, specificParams, genericParams)
        {
            NameValueCollection parameters = ParameterParsingUtil.ParseAsNameValuePairs(specificParams);

            string api = parameters["api"];

            if ( string.IsNullOrEmpty(api) )
            {
                throw new Exception(String.Format("ScsFailure must have an API name associated with it but none was found in '{0}'.", specificParams));
            }

            string error = parameters["error"];
            string timeout = parameters["timeout"];

            if ( string.IsNullOrEmpty(error) && string.IsNullOrEmpty(timeout) )
            {
                throw new Exception(String.Format("DummyScsFailure must have at least one of 'error' and 'timeout' but neither was found in '{0}'.", specificParams));
            }
        }

        public static DummyScsFailure Create(BehaviorRequest behaviorRequest)
        {
            return new DummyScsFailure(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }

        public void PerformFailureAction(string api, ref int timeout)
        {
        }
    }
    public sealed class DummyCTPFailure : BehaviorInjection
    {
        private DummyCTPFailure(string injectionName, string specificParams, string genericParams)
            : base(injectionName, specificParams, genericParams)
        {
            NameValueCollection parameters = ParameterParsingUtil.ParseAsNameValuePairs(specificParams);

            string api = parameters["api"];

            if (string.IsNullOrEmpty(api))
            {
                throw new Exception(String.Format("ctpFailure must have an API name associated with it but none was found in '{0}'.", specificParams));
            }

            string error = parameters["error"];
            string timeout = parameters["timeout"];

            if (string.IsNullOrEmpty(error) && string.IsNullOrEmpty(timeout))
            {
                throw new Exception(String.Format("DummyCTPFailure must have at least one of 'error' and 'timeout' but neither was found in '{0}'.", specificParams));
            }
        }

        public static DummyCTPFailure Create(BehaviorRequest behaviorRequest)
        {
            return new DummyCTPFailure(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }

        public void PerformFailureAction(string api, ref int timeout)
        {
        }
    }

    public sealed class UpsFailure : BehaviorInjection
    {
        private UpsFailure(string injectionName, string specificParams, string genericParams)
            : base(injectionName, specificParams, genericParams)
        {
            NameValueCollection parameters = ParameterParsingUtil.ParseAsNameValuePairs(specificParams);

            string api = parameters["api"];

            if ( string.IsNullOrEmpty(api) )
            {
                throw new Exception(String.Format("UpsFailure must have an API name associated with it but none was found in '{0}'.", specificParams));
            }

            _api = api;

            string error = parameters["error"];
            string timeout = parameters["timeout"];

            if ( string.IsNullOrEmpty(error) && string.IsNullOrEmpty(timeout) )
            {
                throw new Exception(String.Format("UpsFailure must have at least one of 'error' and 'timeout' but neither was found in '{0}'.", specificParams));
            }

            if ( !string.IsNullOrEmpty(timeout) )
            {
                _timeoutMillis = Int32.Parse(timeout);
            }
            else
            {
                _timeoutMillis = 0;
            }
        }

        public static void HandleBehaviorInjection(string api, ref int timeout)
        {
            UpsFailure upsFailure;
            if (RequestHeaderBehaviorInjectionMgr.TryGetBehaviorInjection("UpsFailure", out upsFailure))
            {
                upsFailure.PerformFailureAction(api, ref timeout);
            }
        }

        public static UpsFailure Create(BehaviorRequest behaviorRequest)
        {
            return new UpsFailure(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }

        public void PerformFailureAction(string api, ref int timeout)
        {
            if ( api.Equals(_api, StringComparison.InvariantCultureIgnoreCase) )
            {
                // If the timeout value is 0, force an artificial timeout WebException to be thrown.
                // Between the granularity of the .NET timeout mechanism and the low latency of UPS,
                // specifying a timeout of 1 millisecond often results in a successful call rather than
                // a timeout.
                if ( _timeoutMillis.HasValue )
                {
                    if ( _timeoutMillis.Value == 0 )
                    {
                        throw new WebException("Artificial UPS timeout introduced by BehaviorInjection.  No call to UPS was actually made.", WebExceptionStatus.Timeout);
                    }
                    else
                    {
                        timeout = _timeoutMillis.Value;
                    }
                }
            }
        }

        string _api;
        int? _timeoutMillis;
    }

    public sealed class DummyFinBusFailure : BehaviorInjection
    {
        public void PerformFailureAction(string api, ref int timeout)
        {
            // This method should never be called because the FinBusPublisher service will replace the
            // behavior injection handler for FinBusFailure with one that has the EDIS FaultException
            // contract compiled in.
            throw new Exception(string.Format("DummyFinBusFailure.PerformFailureAction: called for api: {0}; this should never happen!", api));
        }

        private DummyFinBusFailure(string injectionName, string specificParams, string genericParams)
            : base(injectionName, specificParams, genericParams)
        {
            NameValueCollection parameters = ParameterParsingUtil.ParseAsNameValuePairs(specificParams);

            string api = parameters["api"];

            if ( string.IsNullOrEmpty(api) )
            {
                throw new Exception(String.Format("FinBusFailure must have an API name associated with it but none was found in '{0}'.", specificParams));
            }

            _api = api;

            string errorCode = parameters["errorCode"];
            string timeout = parameters["timeout"];

            if ( string.IsNullOrEmpty(errorCode) && string.IsNullOrEmpty(timeout) )
            {
                throw new Exception(String.Format("FinBusFailure must have at least one of 'errorCode' and 'timeout' but neither was found in '{0}'.", specificParams));
            }

            if ( !string.IsNullOrEmpty(errorCode) )
            {
                // 1002 is the one known error code that has been returned by FinBus
                _errorCode = SafeConvert.ToInt32(errorCode, 1002);
                _message = parameters["message"];
            }
            else
            {
                if ( !string.IsNullOrEmpty(timeout) )
                {
                    _timeoutMillis = Int32.Parse(timeout);
                }
                else
                {
                    _timeoutMillis = 1;
                }
            }

        }

        public static void HandleBehaviorInjection(string api, ref int timeout)
        {
            // This method should never be called because the FinBusPublisher service will replace the
            // behavior injection handler for FinBusFailure with one that has the EDIS FaultException
            // contract compiled in.
            throw new Exception(string.Format("DummyFinBusFailure.HandleBehaviorInjection: called for api: {0}; this should never happen!", api));
        }

        public static DummyFinBusFailure Create(BehaviorRequest behaviorRequest)
        {
            return new DummyFinBusFailure(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }

        string _api = string.Empty;
        int? _errorCode;
        string _message = string.Empty;
        int?   _timeoutMillis;
    }

    public static class ParameterParsingUtil
    {
        public static List<BehaviorRequest> ParseAllBehaviors(string allBehaviors)
        {
            List<BehaviorRequest> behaviorRequests = new List<BehaviorRequest>();
            if (!String.IsNullOrEmpty(allBehaviors))
            {
                foreach (string request in allBehaviors.Split(','))
                {
                    behaviorRequests.Add(ParseBehaviorLine(request));
                }
            }
            return behaviorRequests;
        }

        public static NameValueCollection ParseAsNameValuePairs(string nameValueParams)
        {
            return ParseAsNameValuePairsImpl(nameValueParams, GetSplittingStrategy(null));
        }

        public static NameValueCollection ParseAsNameValuePairs(string nameValueParams, char escapeChar)
        {
            return ParseAsNameValuePairsImpl(nameValueParams, GetSplittingStrategy(escapeChar));
        }

        private static NameValueCollection ParseAsNameValuePairsImpl(string nameValueParams, ISplittingStrategy splitter)
        {
            NameValueCollection nvc = new NameValueCollection();

            if (!String.IsNullOrEmpty(nameValueParams))
            {
                foreach (string nameValue in splitter.Split(nameValueParams, ':'))
                {
                    string[] nameAndValue = nameValue.Split('=');
                    if (nameAndValue.Length != 2)
                    {
                        throw new Exception(String.Format(
                            "The behavior injection parameter string '{0}' parses incorrectly at parameter '{1}'.", nameValueParams, nameValue));
                    }
                    nvc[nameAndValue[0]] = nameAndValue[1];
                }
            }
            return nvc;
        }

        private static BehaviorRequest ParseBehaviorLine(string line)
        {
            string[] requestParts = line.Split(';');
            return new BehaviorRequest(requestParts[0], requestParts[1], requestParts.Length == 3 ? requestParts[2] : String.Empty);
        }

        private static ISplittingStrategy GetSplittingStrategy(char? escape)
        {
            if (escape.HasValue)
            {
                return new EscapingSplittingStrategy(escape.Value);
            }
            else
            {
                return NormalSplittingStrategy.GetInstance();
            }
        }

        private interface ISplittingStrategy
        {
            string[] Split(string s, char delim);
        }

        private class NormalSplittingStrategy : ISplittingStrategy
        {
            private NormalSplittingStrategy() { }

            public static NormalSplittingStrategy GetInstance()
            {
                return _instance;
            }

            public string[] Split(string s, char delim)
            {
                return s.Split(delim);
            }

            private static NormalSplittingStrategy _instance = new NormalSplittingStrategy();
        }

        private class EscapingSplittingStrategy : ISplittingStrategy
        {
            public EscapingSplittingStrategy(char escape)
            {
                _escape = escape;
            }

            public string[] Split(string s, char delim)
            {
                // First, replace escaped chars with a special character--converting the char to a string because for some reason replace won't do that.
                s = s.Replace(String.Format("{0}{1}", _escape, delim), new string(SPECIAL_CHAR, 1));

                // Now do our normal split:
                string[] initialSplit = s.Split(delim);

                // Walk through the initial split and replace the spacial character with the delimiter.
                return Array.ConvertAll<string, string>(initialSplit, delegate(string init) { return init.Replace(SPECIAL_CHAR, delim); });
            }

            private readonly char _escape;
            private const char SPECIAL_CHAR = (char)0x14; // This is the "Device Control 4" in the ASCII table. Hard to imagine anything having this in it.
        }
    }


    public static class RequestHeaderBehaviorInjectionMgr
    {
        static RequestHeaderBehaviorInjectionMgr()
        {
            AddBehaviorInjectionFactory("AlternateBillingUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternateMusicNetUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternateDmpUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternateWmisUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternatePassportUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternatePpCredentialServiceApiUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternatePpProfileServiceApiUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternatePpEncryptedProxiedAuthUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternateUpsUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternateABCHUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternateSingleRatingSessionUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternateAggregatorSessionUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternateFinBusUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("SprocFailure", SprocFailure.Create, BehaviorInjectionFactoryFlags.AllowMultiple);
            AddBehaviorInjectionFactory("XbancMiss", XbancMiss.Create, BehaviorInjectionFactoryFlags.None);
            AddBehaviorInjectionFactory("ABCHFailure", ABCHFailure.Create, BehaviorInjectionFactoryFlags.None);
            AddBehaviorInjectionFactory("NpdbOverride", NpdbOverrideInjection.Create, BehaviorInjectionFactoryFlags.AllowMultiple);
            AddBehaviorInjectionFactory("DmpFailure", DmpFailure.Create, BehaviorInjectionFactoryFlags.None);
            AddBehaviorInjectionFactory("PassportLoginFailure", PassportLoginFailure.Create, BehaviorInjectionFactoryFlags.None);
            AddBehaviorInjectionFactory("MusicnetFailure", MusicnetFailure.Create, BehaviorInjectionFactoryFlags.None);
            AddBehaviorInjectionFactory("ScsFailure", DummyScsFailure.Create, BehaviorInjectionFactoryFlags.None);
            AddBehaviorInjectionFactory("UpsFailure", UpsFailure.Create, BehaviorInjectionFactoryFlags.None);
            AddBehaviorInjectionFactory("FinBusFailure", DummyFinBusFailure.Create, BehaviorInjectionFactoryFlags.None);
            AddBehaviorInjectionFactory("AlternateCTPUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
        }

        public static bool TryGetBehaviorInjection<T>(string injectionName, out T t)
            where T : BehaviorInjection
        {
            t = null;

            // If we don't allow injections at all, let's not incur this cost and potential for errors.
            if (!AllowBehaviorInjection)
            {
                return false;
            }

            if (TestBehaviorInjectionFactoryFlags(injectionName, BehaviorInjectionFactoryFlags.AllowMultiple))
            {
                throw new Exception(String.Format(
                    "Injection '{0}' allows multiples, but you are asking for only one. That is likely an error.", injectionName));
            }

            List<T> ts = null;
            if (TryGetBehaviorInjectionsImpl(injectionName, out ts))
            {
                t = ts[0];
                return true;
            }
            else
            {
                return false;
            }
        }

        public static bool TryGetBehaviorInjections<T>(string injectionName, out List<T> ts)
            where T : BehaviorInjection
        {
            ts = null;

            // If we don't allow injections at all, let's not incur this cost and potential for errors.
            if (!AllowBehaviorInjection)
            {
                return false;
            }

            if (!TestBehaviorInjectionFactoryFlags(injectionName, BehaviorInjectionFactoryFlags.AllowMultiple))
            {
                throw new Exception(String.Format(
                    "Injection {0} does not have the BehaviorInjectionFactoryFlags.AllowMultiple flag, but you asked for multiple.", injectionName));
            }

            return TryGetBehaviorInjectionsImpl(injectionName, out ts);
        }

        private static bool TryGetBehaviorInjectionsImpl<T>(string injectionName, out List<T> ts)
            where T : BehaviorInjection
        {
            // See if we have a registered behavior injection for this name. If not, that is considered an error,
            // since someone missed a step in creating the injection point.

            if (!IsBehaviorRegistered(injectionName))
            {
                throw new Exception(
                    String.Format("Attempting to get an injection behavior object for a non-registered injection name '{0}'.", injectionName));
            }

            ts = null;

            // Get the headers--if they are there, we have work to do. Otherwise, we just return false;
            List<BehaviorInjection> injections = null;
            if (!s_tdh.Data.TryGetValue(injectionName, out injections))
            {
                return false;
            }
            // Use our creation delegate to crfeate a BehaviorInjection-derived class.
            ts = injections.ConvertAll<T>(delegate(BehaviorInjection bi) { return (T) bi; } );
            return true;
        }


        public static void AddBehaviorInjections(NameValueCollection headers)
        {
            // If we allow behavior injections, then parse everything out.
            // If not, then we rely on the fact that s_tdh will always return us a valid
            // (empty) dictionary and therefore lookups will fail gracefully.
            if (AllowBehaviorInjection)
            {
                s_tdh.Data = new BehaviorInjectionDictionary(headers);
            }
        }

        public static void AddPassThroughBehaviorInjections(NameValueCollection headers)
        {
            foreach (List<BehaviorInjection> bis in s_tdh.Data.Values)
            {
                foreach (BehaviorInjection bi in bis)
                {
                    if (bi.IsPassThrough)
                    {
                        headers.Add(BEHAVIOR_INJECTION_KEY, bi.InjectionLine);
                    }
                }
            }
        }

        public static void ClearBehaviorInjections()
        {
            s_tdh.Data = null;
        }

        public static bool IsBehaviorRegistered(string behaviorName)
        {
            return FindRegisteredBehavior(behaviorName) != null;
        }

        private static BehaviorInjectionFactory FindRegisteredBehavior(string behaviorName)
        {
            return _behaviorInjectionFactories[behaviorName.ToLower()];
        }

        public static void AddBehaviorInjectionFactory(string behaviorName, BehaviorInjectionFactoryDelegate factoryDelegate, BehaviorInjectionFactoryFlags factoryFlags)
        {
            BehaviorInjectionFactory factory = new BehaviorInjectionFactory(behaviorName, factoryDelegate, factoryFlags);

            // add all factories to the dictionary
            _behaviorInjectionFactories.Add(behaviorName.ToLower(), factory);

            // legacy factories also need to be added to the legacy list
            if ( (factoryFlags & BehaviorInjectionFactoryFlags.AllowLegacy) == BehaviorInjectionFactoryFlags.AllowLegacy )
            {
                _legacyBehaviorInjectionFactories.Add(factory);
            }
        }

        public static void RemoveBehaviorInjectionFactory(string behaviorName)
        {
            _behaviorInjectionFactories.Remove(behaviorName.ToLower());
        }

        private static bool TestBehaviorInjectionFactoryFlags(string injectionName, BehaviorInjectionFactoryFlags flags)
        {
            return (FindRegisteredBehavior(injectionName).Flags & flags) == flags;
        }

        private static bool AllowBehaviorInjection
        {
            get
            {
                return Config.IsTestEnvironment() && Config.GetBoolSetting(Setting.bif_AllowBehaviorInjections);
            }
        }

        private sealed class BehaviorInjectionDictionary : Dictionary<string, List<BehaviorInjection>>
        {
            public BehaviorInjectionDictionary()
            {
            }

            public BehaviorInjectionDictionary(NameValueCollection headers)
            {
                // Get all the "new version" injections.
                AddBehaviorRequests(headers[BEHAVIOR_INJECTION_KEY]);

                // Get all the "legacy" injections.
                AddLegacyBehaviorRequests(headers);
            }

            private void AddBehaviorRequests(string requestHeader)
            {
                List<BehaviorRequest> behaviorRequests = ParameterParsingUtil.ParseAllBehaviors(requestHeader);
                behaviorRequests.ForEach(AddItem);
            }

            private void AddLegacyBehaviorRequests(NameValueCollection headers)
            {
                foreach (BehaviorInjectionFactory bif in _legacyBehaviorInjectionFactories)
                {
                    if (headers[bif.BehaviorName] != null)
                    {
                        AddItem(new BehaviorRequest(bif.BehaviorName, headers[bif.BehaviorName], String.Empty));
                    }
                }
            }

            private void AddItem(BehaviorRequest br)
            {
                AddItem(FindRegisteredBehavior(br.Name).FactoryDelegate(br));
            }

            private void AddItem(BehaviorInjection bi)
            {
                if (ContainsKey(bi.InjectionName))
                {
                    if (!TestBehaviorInjectionFactoryFlags(bi.InjectionName, BehaviorInjectionFactoryFlags.AllowMultiple))
                    {
                        throw new Exception(String.Format("Can only specify injection '{0}' once per request.", bi.InjectionName));
                    }
                }
                else
                {
                    this[bi.InjectionName] = new List<BehaviorInjection>();
                }

                this[bi.InjectionName].Add(bi);
            }
        }

        private static ThreadDataHelper<BehaviorInjectionDictionary> s_tdh = new ThreadDataHelper<BehaviorInjectionDictionary>();
        public readonly static string BEHAVIOR_INJECTION_KEY = "BEHAVIOR_INJECTIONS";

        // All active BehaviorInjectionFactories are tracked in this dictionary.  The key is
        // the behaviorName (e.g. "StoredProc", "ScsFailure") in lower-case.
        private static Dictionary<string,BehaviorInjectionFactory> _behaviorInjectionFactories = new Dictionary<string,BehaviorInjectionFactory>();


        // Legacy factories need to be quickly accessed so while they exist in the dictionary,
        // they are also tracked separately in a legacy-specific list so the dictionary does not
        // need to be scanned every time an injection is handled.
        private static List<BehaviorInjectionFactory> _legacyBehaviorInjectionFactories = new List<BehaviorInjectionFactory>();

        public delegate BehaviorInjection BehaviorInjectionFactoryDelegate(BehaviorRequest behaviorRequest);

        [Flags]
        public enum BehaviorInjectionFactoryFlags
        {
            None            = 0x00,
            AllowLegacy     = 0x01,
            AllowMultiple   = 0x02,
        }

        private sealed class BehaviorInjectionFactory
        {
            public BehaviorInjectionFactory(string behaviorName, BehaviorInjectionFactoryDelegate factoryDelegate, BehaviorInjectionFactoryFlags flags)
            {
                _behaviorName = behaviorName;
                _factoryDelegate = factoryDelegate;
                _flags = flags;
            }

            public string BehaviorName { get { return _behaviorName; } }
            public BehaviorInjectionFactoryDelegate FactoryDelegate { get { return _factoryDelegate; } }
            public BehaviorInjectionFactoryFlags Flags { get { return _flags; } }

            private readonly string _behaviorName;
            private readonly BehaviorInjectionFactoryDelegate _factoryDelegate;
            private readonly BehaviorInjectionFactoryFlags _flags;
        }
    }


    /*
     * Thin wrapper over TLS data. Pretty simple.
     */
    internal sealed class ThreadDataHelper<T>
        where T : class, new()
    {
        public ThreadDataHelper()
        {
            _tls = Thread.AllocateDataSlot();
        }

        public T Data
        {
            get { return (T) (Thread.GetData(_tls) ?? new T()); }
            set { Thread.SetData(_tls, value); }
        }

        private LocalDataStoreSlot _tls;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\Convert.cs ===
using System;
using System.Runtime.InteropServices;
using System.Text;
using System.Xml;

namespace xonline.common.service
{

[ComVisible(false)]
public class ByteArray
{
    byte[] _bytes;
    int _hashCode;

    public ByteArray(byte[] bytes)
    {
        if (bytes == null || bytes.Length < 1)
        {
            throw new Exception("ByteArray: must have at least 1 byte in array");
        }
        _bytes = bytes;
        UpdateHashCode();
    }

    public void UpdateHashCode()
    {
        _hashCode = _bytes[0];
        for(int i = 1; i < _bytes.Length; i++)
        {
            // 1718205583 is prime
            _hashCode = _hashCode * 1718205583 + _bytes[i];
        }
    }

    override public int GetHashCode()
    {
        return _hashCode;
    }

    override public bool Equals(object o)
    {
        ByteArray ba = (ByteArray)o;

        return Equals( _bytes, ba._bytes );
    }

    public static bool Equals( byte[] ba1, byte[] ba2 )
    {
        if (ba1.Length == ba2.Length)
        {
            for(int i = 0; i < ba1.Length; i++)
            {
                if (ba1[i] != ba2[i])
                {
                    return false;
                }
            }
            return true;
        }
        else
        {
            return false;
        }
    }

    public static bool EqualOrBothNull( byte[] ba1, byte[] ba2 )
    {
        if (ba1 == null && ba2 == null)
        {
            return true;
        }
        if (ba1 == null || ba2 == null)
        {
            return false;
        }
        if (ba1.Length == ba2.Length)
        {
            for(int i = 0; i < ba1.Length; i++)
            {
                if (ba1[i] != ba2[i])
                {
                    return false;
                }
            }
            return true;
        }
        else
        {
            return false;
        }
    }

    override public string ToString()
    {
        return ByteConvert.ToString(_bytes);
    }

    public byte[] Bytes
    {
        get { return _bytes; }
    }
}

[ComVisible(false)]
public class ByteConvert
{
    //
    // turns a byte array into a hex string
    //
    public static string ToString(byte[] ba)
    {
        if (ba == null)
        {
            return "0";
        }

        StringBuilder strb = new StringBuilder(ba.Length * 2);

        for(int i = 0; i < ba.Length; i++)
        {
            strb.Append(ba[i].ToString("x2"));
        }

        return strb.ToString();
    }


    //
    // turns a byte array into a hex string reversed (for little endian stuff)
    //
    public static string ToReverseString(byte[] ba)
    {
        if (ba == null)
        {
            return "0";
        }

        StringBuilder strb = new StringBuilder(ba.Length * 2);

        for(int i = ba.Length-1; i >= 0; i--)
        {
            strb.Append(ba[i].ToString("X2"));
        }

        return strb.ToString();
    }


    public static string[] ToFormattedStrings(byte[] ba)
    {
        return ToFormattedStrings(ba, UInt32.MaxValue);
    }

    public static string[] ToFormattedStrings(byte[] ba, uint maxLines)
    {
        StringBuilder hexBytes = new StringBuilder(50);
        StringBuilder strBytes = new StringBuilder(16);

        string[] lines = new string[Math.Min(maxLines, ba.Length / 16 + (ba.Length % 16 == 0 ? 0 : 1))];

        for (int i = 0; i < lines.Length; i++)
        {
            for (int j = 0; j < 16; j++)
            {
                int index = (i * 16) + j;
                if (index < ba.Length)
                {
                    byte b = ba[index];
                    hexBytes.Append(b.ToString("x2") + (j == 7 ? "-" : " "));
                    strBytes.Append(b >= 0x20 && b < 0x7f ? (char)b : '.');
                }
            }

            lines[i] = hexBytes.ToString().PadRight(48) + strBytes.ToString().PadRight(17);
            hexBytes.Length = 0;
            strBytes.Length = 0;
        }

        return lines;
    }

    //
    // turns a hex string into a byte array
    //
    public static byte[] FromString(string str)
    {
        byte[] ba = new byte[str.Length / 2];
        for (int i = 0; i < ba.Length; i++)
        {
            ba[i] = Convert.ToByte(str.Substring(i*2, 2), 16);
        }
        return ba;
    }
}

[ComVisible(false)]
public class CharConvert
{
    public static string ToString(char[] ca)
    {
        return CharConvert.ToString(ca, new UTF8Encoding());
    }


    public static string ToString(char[] ca, UTF8Encoding enc)
    {
        int c;

        // find the first null char
        for (c = 0; c < ca.Length && ca[c] != 0; c++)
            ;

        // only use the first first c non-null characters
        // to create the string.
        return enc.GetString(enc.GetBytes(ca, 0, c));
    }

    public static char[] FromString(string str)
    {
        return CharConvert.FromString(str, new UTF8Encoding());
    }

    public static char[] FromString(string str, UTF8Encoding enc)
    {
        return enc.GetChars(enc.GetBytes(str));
    }
}


[ComVisible(false)]
public class Int64Convert
{
    public static long FromIntPair(int highPart, int lowPart)
    {
        return (long)(((ulong)highPart << 32) | ((ulong)lowPart & 0x00000000FFFFFFFF));
    }

    public static long FromUintPair(uint highPart, uint lowPart)
    {
        return (long)(((ulong)highPart << 32) | ((ulong)lowPart & 0x00000000FFFFFFFF));
    }

    public static void ToIntPair(long val, out int highPart, out int lowPart)
    {
        highPart = (int)(val >> 32);
        lowPart = (int)(val & 0xffffffff);
    }

    public static void ToUintPair(long val, out uint highPart, out uint lowPart)
    {
        highPart = (uint)(val >> 32);
        lowPart = (uint)(val & 0xffffffff);
    }
}

/// <summary>
/// Provides methods for conversion, with a defualt if the value is null or an empty string
/// </summary>
[ComVisible(false)]
public class XmlSafeConvert
{
    public static int ToInt16(string str)
    {
        return ToInt16(str, 0);
    }
    public static short ToInt16(string str, short nDefault)
    {
        return (str == String.Empty ? nDefault : XmlConvert.ToInt16(str));
    }

    public static int ToInt32(string str)
    {
        return ToInt32(str, 0);
    }
    public static int ToInt32(string str, int nDefault)
    {
        return (str == String.Empty ? nDefault : XmlConvert.ToInt32(str));
    }

    public static ulong ToUInt64(string str)
    {
        return ToUInt64(str, 0);
    }
    public static ulong ToUInt64(string str, ulong nDefault)
    {
        return (str == String.Empty ? nDefault : XmlConvert.ToUInt64(str));
    }

    public static bool ToBoolean(string str)
    {
        return ToBoolean(str, false);
    }
    public static bool ToBoolean(string str, bool bDefault)
    {
        return (str == String.Empty ? bDefault : XmlConvert.ToBoolean(str));
    }
}



[ComVisible(false)]
public class SafeConvert
{
    public static int ToInt16(string str)
    {
        return ToInt16(str, 0);
    }
    public static short ToInt16(string str, short nDefault)
    {
        try
        {
            int fromBase = 10;

            if (IsHex(str))
            {
                fromBase = 16;
                if (str.StartsWith("0x"))
                    str = str.Substring(2);
            }

            return (str == String.Empty ? nDefault : Convert.ToInt16(str, fromBase));
        }
        catch
        {
            return nDefault;
        }

    }

    public static int ToInt32(string str)
    {
        return ToInt32(str, 0);
    }
    public static int ToInt32(string str, int nDefault)
    {
        try
        {
            int fromBase = 10;

            if (IsHex(str))
            {
                fromBase = 16;
                if (str.StartsWith("0x"))
                    str = str.Substring(2);
            }


            return (str == String.Empty ? nDefault : Convert.ToInt32(str, fromBase));
        }
        catch
        {
            return nDefault;
        }

    }

    public static uint ToUInt32(string str)
    {
        return ToUInt32(str, 0);
    }
    public static uint ToUInt32(string str, uint nDefault)
    {
        try
        {
            int fromBase = 10;

            if (IsHex(str))
            {
                fromBase = 16;
                if (str.StartsWith("0x"))
                    str = str.Substring(2);
            }

            if(str.StartsWith("-") && fromBase == 10)
                return ((uint)Convert.ToInt32(str, fromBase));
            else
                return (str == String.Empty ? nDefault : Convert.ToUInt32(str, fromBase));
        }
        catch
        {
            return nDefault;
        }

    }

    public static ulong ToUInt64(string str)
    {
        return ToUInt64(str, 0);
    }
    public static ulong ToUInt64(string str, ulong nDefault)
    {
        try
        {
            int fromBase = 10;

            if (IsHex(str))
            {
                fromBase = 16;
                if (str.StartsWith("0x"))
                    str = str.Substring(2);
            }

            if(str.StartsWith("-") && fromBase == 10)
                return ((ulong)Convert.ToInt64(str, fromBase));
            else
                return (str == String.Empty ? nDefault : Convert.ToUInt64(str, fromBase));
        }
        catch
        {
            return nDefault;
        }
    }

    public static bool ToBoolean(string str)
    {
        return ToBoolean(str, false);
    }
    public static bool ToBoolean(string str, bool bDefault)
    {
        try
        {
            return (str == String.Empty ? bDefault : Convert.ToBoolean(str));
        }
        catch
        {
            return bDefault;
        }
    }

    public static bool IsHex(string str)
    {
        return (str.StartsWith("0x") ||
            str.ToLower().IndexOfAny( new char[] { 'a', 'b', 'c', 'd', 'e', 'f' }) != -1);
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\EventThrottler.cs ===
using System;
using System.Text;
using System.Collections;

using xonline.common.config;
using xonline.common.mgmt;

namespace xonline.common.service
{
    public class EventThrottler
    {

        private const ulong HNS_PER_SECOND = 10000000;

        enum ALLOW_TYPE
        {
            UNKNOWN         = 0,
            ALWAYS_ALLOW    = 1,    // This event will always occur, and isn't tracked
            SOMETIMES_ALLOW = 2,    // This event will sometimes occur (based on other params)
            NEVER_ALLOW     = 3     // This event has been squelched
        };

        class EventTrackingStuff               // sizeof() == 28
        {
            public ulong LastTime         = 0;
            public ulong FirstTimeThisSec = 0;
            public uint  NumSkips         = 0;
            public uint  UnitsLastSec     = 0;
            public uint  UnitsThisSec     = 0;
        };

        class PerEventStuff
        {
            public EventTrackingStuff evt = new EventTrackingStuff();

            public string[] Text = null;
            public ushort EventId = 0;

            public ALLOW_TYPE AllowType = ALLOW_TYPE.UNKNOWN;

            public ulong EventInterval = 0;       // Interval between allowed events in 100-nanosecond units
            public uint AlertUnitsPerSec = 0;     // either events/packets or bytes, depending on fRateUnitsAreBytes
            public uint Reserved = 0;
            
            public bool EventFired(out uint numSkips)
            {
                numSkips = 0;
                bool fireIt = true;
                
                if (AllowType == ALLOW_TYPE.ALWAYS_ALLOW)
                {
                    // always let this thru
                    return true;
                }
                    
                if (AllowType == ALLOW_TYPE.NEVER_ALLOW)
                {
                    return false;
                }


                //
                // Handle any rate tracking on second-aligned boundaries; gather an approximation
                // of the current rate when the trigger threshold is crossed in the current second.
                //
                ulong hnsNow = (ulong) DateTime.Now.ToFileTime();
    
                if( AlertUnitsPerSec > 0 )
                {
                    ulong ulNowSecs = hnsNow / HNS_PER_SECOND;
                    ulong ulThenSecs = evt.FirstTimeThisSec / HNS_PER_SECOND;
    
                    if( ulNowSecs != ulThenSecs )
                    {
                        evt.UnitsLastSec = ( ulNowSecs == ulThenSecs + 1 ) ? evt.UnitsThisSec : 0;
                        evt.UnitsThisSec = 0;
                        evt.FirstTimeThisSec = hnsNow;
                    }
                }
    
                evt.UnitsThisSec++;
    
                if( ( evt.UnitsThisSec >= AlertUnitsPerSec ) &&
                    ( ( 0 == evt.LastTime ) ||
                    ( hnsNow >= evt.LastTime + EventInterval ) ) )
                {
    
                    //
                    // We're going to allow this event; indicate how many similar ones have been skipped
                    //
                    numSkips = evt.NumSkips;
                    evt.NumSkips = 0;
    
                    evt.UnitsThisSec = 0;
                    evt.LastTime = hnsNow;
                    fireIt = true;
                }
                else
                {
                    //
                    // Make sure we track recent rate properly by resetting our counter each second when we would
                    // have alerted if it had been long enough since the last alert
                    //
                    if( ( evt.UnitsThisSec >= AlertUnitsPerSec ) &&
                        ( hnsNow >= evt.FirstTimeThisSec + HNS_PER_SECOND ) )
                    {
                        evt.UnitsThisSec = 0;
                    }
    
                    //
                    // We're suppressing this event because the outside world doesn't want to know about this kind
                    // of thing until we reach our configured rate (globally or per-IP) and it has been 'a while'
                    // since the last time we alerted
                    //
                    evt.NumSkips++;
                    fireIt = false;
                }
                
                return( fireIt );
            }
            
        };


        private static Hashtable _eventThrottlesById = new Hashtable();
        private static ArrayList _eventThrottlesByText = new ArrayList();
        private static bool _reloadConfig = true;

        static EventThrottler()
        {
            Config.MultiSettingChange += new MultiSettingChangeEventHandler(EventThrottler.MultiSettingsChanged);
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(EventThrottler.OnControlRequest);
        }


        public static void MultiSettingsChanged(object sender, MultiSettingChangeEventArgs e)
        {
            if(e.MultiSetting != MultiSetting.xmgmt_eventThrottles)
                return;

            LoadEventSettings(e.ValueNew);
        }


        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                switch (args.Command)
                {
                    case "help":
                        XomControlConnection.SendMessage(
                            "EventThrottler help:\r\n" +
                            " listevents (le) -- lists all currently throttled events.\r\n" +
                            " addevent (ae) -- adds (or updates) event throttling settings.   settings are \r\n" +
                            "       separated by ';'.   They can be:\r\n" +
                            "       id=<event id> (0 if all events)\r\n" +
                            "       text=<search text>\r\n" +
                            "       freq=<always|sometimes|never>\r\n" +
                            "       intervalsecs=<seconds between events>\r\n" +
                            "       alertrate=<# of events per second>\r\n" +
                            "\r\n" +
                            "  For example, to turn off the event thrown from a missing achievement:\r\n" +
                            "   text=Achievement not found;freq=never\r\n" +
                            "  or to limit it to every 5 seconds:\r\n" +
                            "   text=Achievement not found;intervalsecs=5\r\n" +
                            "  or to allow event id 2 up to twenty times per second:\r\n" +
                            "   id=2;alertrate=20\r\n" +
                            "\r\n" +
                            "  NOTE: Events configured via xmgmt will be overwritten if the\r\n" +
                            "   xmgmt_eventThrottles setting changes!\r\n\r\n",
                            args.RequestId);
                        args.Handled = true;
                        break;

                    case "listevents":
                    case "le":
                        XomControlConnection.SendMessage(ProcessListEvents(args), args.RequestId);
                        args.Handled = true;
                        break;

                    case "addevent":
                    case "ae":
                        XomControlConnection.SendMessage(ProcessAddEvent(args), args.RequestId);
                        args.Handled = true;
                        break;
                }
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }

        public static string ProcessListEvents(ControlRequestEventArgs args)
        {
            if (_eventThrottlesById.Keys.Count == 0 &&
                _eventThrottlesByText.Count == 0)
            {
                return "No events are currently throttled.\r\n";
            }

            StringBuilder bldr = new StringBuilder();

            foreach (object key in _eventThrottlesById.Keys)
            {
                PerEventStuff eventConfig = (PerEventStuff)_eventThrottlesById[key];
                bldr.Append("EventID: " + key.ToString() + "\r\n");
                bldr.Append("  Frequency:     " + eventConfig.AllowType.ToString() + "\r\n");
                bldr.Append("  Interval (hns):" + eventConfig.EventInterval + "\r\n");
                bldr.Append("  Rate:          " + eventConfig.AlertUnitsPerSec + "\r\n");
            }


            foreach (PerEventStuff eventConfig in _eventThrottlesByText)
            {
                bldr.Append("EventText: " + String.Join("*", eventConfig.Text) + "\r\n");
                bldr.Append("  Frequency:     " + eventConfig.AllowType.ToString() + "\r\n");
                bldr.Append("  Interval (hns):" + eventConfig.EventInterval + "\r\n");
                bldr.Append("  Rate:          " + eventConfig.AlertUnitsPerSec + "\r\n");
            }

            return bldr.ToString();
        }

        public static string ProcessAddEvent(ControlRequestEventArgs args)
        {
            PerEventStuff eventConfig;
            string error;

            eventConfig = GetPerEventConfig(args.CommandArgs[0], out error);
            if (error != null)
            {
                return error + "\r\n";
            }
            
            if (eventConfig.Text == null || eventConfig.Text.Length == 0)
            {
                _eventThrottlesById[eventConfig.EventId] = eventConfig;
            }
            else
            {
                _eventThrottlesByText.Add(eventConfig);    
            }
            
            return "OK";
        }

        private static void LoadEventSettings(string[] eventThrottles)
        {
            //
            // Load any pre-configured event settings
            //
            PerEventStuff eventConfig;
            string error;   
            ArrayList eventConfigsByText = new ArrayList();
            Hashtable eventConfigsById = new Hashtable();

            // since we log events in this method, make sure those calls don't recursively call back in
            _reloadConfig = false;

            if (eventThrottles == null)
            {
                eventThrottles = Config.GetMultiSetting(MultiSetting.xmgmt_eventThrottles);
            }

            if (eventThrottles != null && eventThrottles.Length != 0)
            {
                foreach (string throttle in eventThrottles)
                {
                    eventConfig = GetPerEventConfig(throttle, out error);
                    if (error != null)
                    {
                        EventBuilder.LogEvent(XEvent.Id.COMMON_CONFIG_274, error, null);
                        continue;
                    }
                    
                    if (eventConfig.Text == null || eventConfig.Text.Length == 0)
                    {
                        eventConfigsById[eventConfig.EventId] = eventConfig;
                    }
                    else
                    {
                        eventConfigsByText.Add(eventConfig);
                    }
                }
            }
            
            _eventThrottlesById = eventConfigsById;
            _eventThrottlesByText = eventConfigsByText;
        }
        
        private static PerEventStuff GetPerEventConfig(string throttle, out string error)
        {
            string[] settings = throttle.Split(new char[] { ';' });
            
            PerEventStuff evtSettings = new PerEventStuff();
            error = null;
            
            // collapse any ;'s that were preceeded by \
            for (int i = 0; i < settings.Length - 1; i++)
            {
                if (settings[i].EndsWith("\\"))
                {
                    // get rid of the escape character, and concatonate the subsequent ';'
                    settings[i] = settings[i].Substring(0, settings[i].Length-1) + ";" + settings[i+1];
                    settings[i+1] = "";
                }
            }
            
            foreach (string setting in settings)
            {
                if (setting == "")
                    continue;
                
                int eqidx = setting.IndexOf('=');
                if (eqidx == -1)
                {
                    error =  "One of the settings for xmgmt_eventThrottler contains an invalid string '" + throttle + "'";
                    evtSettings = null;
                    break;
                }
                
                string name = setting.Substring(0, eqidx).ToLower().Trim();
                string value = setting.Substring(eqidx + 1);
                
                switch (name)
                {
                case "id":
                    try
                    {
                        evtSettings.EventId = Convert.ToUInt16(value);
                    }
                    catch
                    {
                        error = "One of the settings for xmgmt_eventThrottler contains an invalid value for EventId: '" + throttle + "'";
                        evtSettings = null;
                        goto leave;
                    }    
                    break;
                    
                case "text":
                    evtSettings.Text = value.Split('*');
                    for (int i = 0; i< evtSettings.Text.Length - 1; i++)
                    {
                        if (evtSettings.Text[i] != null && evtSettings.Text[i].EndsWith("\\"))
                        {
                            // get rid of the escape character, and concatonate the subsequent '*'
                            evtSettings.Text[i] = evtSettings.Text[i].Substring(0, evtSettings.Text[i].Length-1) + "*" + evtSettings.Text[i+1];
                            evtSettings.Text[i+1] = null;
                        }
                    }        
                    break;

                case "freq":
                    switch( value.ToLower() )
                    {
                    case "maybe":
                    case "some":
                    case "sometimes":
                        evtSettings.AllowType = ALLOW_TYPE.SOMETIMES_ALLOW;
                        break;

                    case "all":
                    case "always":
                    case "yes":
                        evtSettings.AllowType = ALLOW_TYPE.ALWAYS_ALLOW;
                        break;

                    case "no":
                    case "none":
                    case "never":
                        evtSettings.AllowType = ALLOW_TYPE.NEVER_ALLOW;
                        break;

                    default:
                        error = "One of the settings for xmgmt_eventThrottler contains an invalid freq setting: '" + throttle + "'";
                        goto leave;
                    }
                    break;

                case "alertrate":
                    evtSettings.AlertUnitsPerSec = Convert.ToUInt32( value );
                    if (evtSettings.AllowType == ALLOW_TYPE.UNKNOWN)
                        evtSettings.AllowType  = ALLOW_TYPE.SOMETIMES_ALLOW;
                    break;

                case "intervalsecs":
                    evtSettings.EventInterval = Convert.ToUInt64( value );
                    evtSettings.EventInterval *= HNS_PER_SECOND;
                    if (evtSettings.AllowType == ALLOW_TYPE.UNKNOWN)
                        evtSettings.AllowType  = ALLOW_TYPE.SOMETIMES_ALLOW;
                    break;

                case "intervalhns":
                    evtSettings.EventInterval = Convert.ToUInt64( value );
                    if (evtSettings.AllowType == ALLOW_TYPE.UNKNOWN)
                        evtSettings.AllowType  = ALLOW_TYPE.SOMETIMES_ALLOW;
                    break;

                case "rateunits":
                case "trackperip":
                case "comment":
                    //
                    // Quietly ignore these
                    //
                    break;

                default:
                    error = "Unknown parameter '" + name + " in multisetting configuration '" + throttle + "'";
                    evtSettings = null;
                    goto leave;
                }

            }

            if (evtSettings.EventId == 0 && evtSettings.Text == null)
            {
                error = "multisetting configuration '" + throttle + " is invalid.  Either a non-zero eventid or a text search string must be specified!";
                evtSettings = null;
                goto leave;
            }
            
leave:            
            return evtSettings;
        }        


        //////////////////////////////////////////////////////////////////////////////
        public static bool FireEvent(
            uint eventid,
            out uint uiNumSkips )
        {
            uiNumSkips = 0;
            PerEventStuff eventConfig;


            if (_reloadConfig)
            {
                LoadEventSettings(null);
            }

            eventConfig = (PerEventStuff)_eventThrottlesById[(ushort)eventid];
            if (eventConfig == null)
            {
                // nothing configured for this event id
                return true;
            }
            
            return eventConfig.EventFired(out uiNumSkips);
        }
        
        
                
        
        
        //////////////////////////////////////////////////////////////////////////////
        public static bool FireEvent(
            ushort eventid,
            string eventText,
            out uint uiNumSkips )        // How many have been skipped since last allowed event
        {
            bool fFireIt = true;
            uiNumSkips = 0;


            if (_reloadConfig)
            {
                LoadEventSettings(null);
            }

            foreach (PerEventStuff eventConfig in _eventThrottlesByText)
            {
                if (eventConfig.EventId != 0 && eventConfig.EventId != eventid)
                    continue;
            
                bool match = true;
                
                // see if the text matches
                if (eventConfig.Text != null)
                {
                    int idx = 0;
                    
                    for (int i = 0; i < eventConfig.Text.Length; i++)
                    {
                        idx = eventText.IndexOf(eventConfig.Text[i], idx);
                        if (idx == -1)
                        {
                            match = false;
                            break;
                        }
                    }
                }
                
                if (match == true)
                {
                    return eventConfig.EventFired(out uiNumSkips);
                }    
            }    

            return( fFireIt );
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\EventBuilder.cs ===
using System;
using System.Diagnostics;
using System.IO;

using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Web;
using System.Xml;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;

// error CS0420: Warning as Error: a reference to a volatile field will not be treated as 
// volatile
#pragma warning disable 420

namespace xonline.common.service
{
    [ComVisible(false)]
    public class EventBuilder
    {
        private static bool _showSGInfo = true;

        public static bool ShowSGInfo
        {
            get {return _showSGInfo;}
            set {_showSGInfo = value;}
        }

        private static EventLogEntryType[] _typeMapping = {
                                                              EventLogEntryType.Information,
                                                              EventLogEntryType.Information,
                                                              EventLogEntryType.Warning,
                                                              EventLogEntryType.Error
                                                          };

        // Log an NT event, bypassing xmgmt codegen
        //
        // WARNING: Avoid calling this directly where possible.   Xmgmt
        // brings all sorts of goodness, including event throttling by
        // file and line #.   Calling this directly will bypass all that goodness,
        // leaving OPs powerless against this event.
        //
        // Are you SURE you want to call this?
        // consider this instead (without the space in Xom Nt..):
        //  Xom NtEvent(YOUR_EVENT_ID, "Your Message\r\n" + EventBuilder.ExceptionToString(e));

        public static void LogEvent(XEvent.Id eventId, string message, Exception e)
        {
            LogEvent(
                XomLogTargetContext.Empty,
                Config.ComponentName,
                (sbyte)(((uint) eventId)>>30),
                (ushort) XEvent.MessageFromId(eventId),
                null,
                message,
                e);
        }

        // Do not touch this variable outside of the LogEvent method. It's important that 
        // it maintains its integrity.
        [ThreadStatic]
        private static int _logEventCallDepth = 0;

        public static void LogEvent( XomLogTargetContext msgCtx, string area, sbyte level, ushort msgId, byte [] msgData, string message, Exception e )
        {
            try
            {
                // Prevent infinite recursion - if something in LogEvent tries to log an 
                // event using Xom NtEvent (or EventBulder.LogEvent), detect that and bail 
                // out.
                //
                // Also, we don't need to use Interlocked functions nor mark it "volatile" 
                // since this is a thread static variable.
                if (++_logEventCallDepth > 1)
                {
                    // Bypass all the fancy stuff
                    string fullMessage = "[Bypassing event builder. Call depth = " + _logEventCallDepth + ", Thread id = " + Thread.CurrentThread.ManagedThreadId + "]\r\n\r\n" + message;
                    if (e != null)
                    {
                        fullMessage += "\r\n\r\n" + XblException.Format(e);
                    }
                    LogEventSimple(Config.ComponentName, level, msgId, msgData, fullMessage);
                    return;
                }
                
                System.Text.StringBuilder eventText = new System.Text.StringBuilder();
                string srcFile = null;
                ushort srcLine = 0;
                uint numSkips = 0;


                if (false == EventThrottler.FireEvent(msgId, out numSkips))
                {
                    // skip it!
                    return;
                }

                if (numSkips > 0)
                {
                    eventText.Append("EventThrottle: skipped ");
                    eventText.Append(numSkips);
                    eventText.Append(" previous events\r\n\r\n");
                }


                // always need flowtoken. We won't bother showing it if it isn't valid, 
                // though.
                if (msgCtx.FlowToken.IsValid)
                {
                    eventText.AppendLine("Floken: " + msgCtx.FlowToken.ToString());
                }

                if (e == null)
                    GetStackSrc(new StackTrace(true), out srcFile, out srcLine);
                else
                {
                    // when an exception is provided, use the line
                    // from that insetad of the provided file/line numbers
                    //
                    GetExceptionSrc(e, out srcFile, out srcLine);
                }

                if (srcFile == null)
                    eventText.Append("Source from reflection: [not available]\r\n");
                else {
                    // add the src and line
                    eventText.AppendLine("Source from reflection: " + srcFile + ":" + srcLine);
                }

                if (message != null)
                {
                    if (e != null)
                    {
                        HResult hr = XblException.GetHResult(e);
                        message = message + "; hr = " + hr.ToString();
                        if (hr.HasName)
                        {
                            message = message + " (" + hr.Name + ")";
                        }
                    }

                    eventText.AppendLine(message);
                }

                //
                // add info about the exception(s)
                //
                if (e != null)
                {
                    eventText.AppendLine();
                    eventText.Append(EventBuilder.ExceptionToString(e));
                }

                // IIS7 no longer allows testing for null request
                // in Application_Start/End.  It  throws  instead

                HttpContext context = null;
                HttpRequest request = null;
                
                try
                {
                    context = HttpContext.Current;
                    if (context != null) request = context.Request;
                }
                catch (HttpException)
                {
                }

                if (request != null)
                {
                    //
                    // add info about the current sg/aa ticket, if applicable
                    //

                    eventText.AppendLine();

                    try
                    {
                        if (SGInfo.IsActiveAuth())
                        {
                            eventText.AppendLine("----- AA Info -----");

                            AAInfo aainfo = AAInfo.Current;

                            // See if an AAInfo was actually found.  
                            if (aainfo == null)
                                eventText.AppendLine("No AA Info found.");
                            else
                            {
                                eventText.AppendLine(aainfo.ToString());
                            }
                        }
                        else if (ShowSGInfo)
                        {
                            if (SGInfo.IsAvailableInContext(context))
                            {
                                eventText.AppendLine("----- SG Info -----");

                                if (SGInfo.Current == null)
                                    eventText.AppendLine("No SG Info found.");
                                else
                                {
                                    eventText.AppendLine(SGInfo.Current.ToString());
                                }
                            }
                        }
                    }
                    catch(Exception eSgInfo)
                    {
                        // an error getting SGInfo shouldn't be fatal to event logging
                        eventText.Append("\r\nError getting SG/AA Info.\r\n");
                        eventText.Append(eSgInfo.ToString());
                    }

                    //
                    // add info about the http request
                    //

                    eventText.AppendLine();
                    eventText.AppendLine("----- Http Request -----");

                    try
                    {
                        eventText.AppendLine("URL:    " + request.RawUrl);
                        eventText.AppendLine("Headers:");

                        for (int i = 0; i < request.Headers.Count; i++)
                        {
                            string key = request.Headers.Keys[i];

                            string header = request.Headers[i];
                            eventText.Append("  ");
                            eventText.Append(request.Headers.Keys[i]);
                            eventText.Append(": ");

                            if (key == XHttpHdr.AUTHZ || key == XHttpHdr.BUNDLEDAUTHDATA || key == XHttpHdr.HTTPAUTHDATA)
                            {
                                const int truncateTo = 64;

                                if (header.Length > truncateTo)
                                {
                                    header = string.Format("{0} ({1} more bytes)", header.Substring(0, truncateTo), header.Length - truncateTo);
                                }
                            }

                            eventText.Append(header);
                            eventText.Append("\r\n");
                        }

                        eventText.AppendLine();

                        if (context.Items["XErr"] != null)
                        {
                            eventText.AppendLine("X-Err: " + ((HResult)context.Items["XErr"]));
                            eventText.AppendLine();
                        }


                        // if they have a wiredata request,  then attempt  to
                        // format it.  it's as simple as calling the ToString

                        eventText.AppendLine("----- Request Data -----");
                        string postString = string.Empty;

                        try {
                            
                            if (context.Items["XRLRequest"] != null)
                                postString = ((XRLObject2) context.Items["XRLRequest"]).ToString();

                            // joy, they have no request.  that means we failed to
                            // deserialize it, see if there is a POST input stream

                            else if (request.HttpMethod != "POST")
                                postString = "No data available";

                            else if (context.Items["NoPostBufferLog"] != null)
                                postString = "Data is marked as not loggable";

                            // they have an input stream, and we  are  allowed  to
                            // log it.  read it and format based on  content  type
                            // if all else fails then we log  a  hexadecimal  dump

                            else if (request.ContentType.StartsWith("text/xml")) {
                                postString = ToXml(request, Config.GetIntSetting(Setting.wiredata_postLimit));
                            }
                        }
                        catch {
                        }

                        try {
                            if (postString == string.Empty) {
                                postString = ToHex(request, Config.GetIntSetting(Setting.wiredata_postLimit));
                            }
                        }
                        catch {
                            // ignore exception. we don't want a double error when
                            // logging an event or we can loose the initial  error
                        }

                        // if we have anything at this point, then add it to the event

                        if (postString != string.Empty) {
                            eventText.AppendLine(postString);
                        }

                        eventText.AppendLine();

                        if (context.Items["XRLResponse"] != null)
                        {
                            eventText.Append("\r\n\r\n----- Response Data -----\r\n");
                            eventText.Append(((XRLObject2)context.Items["XRLResponse"]).ToString());
                            eventText.Append("\r\n");
                        }

                    }
                    catch (Exception eHttpContext)
                    {
                        eventText.Append("\r\nError reading HTTPContext info:\r\n");
                        eventText.Append(eHttpContext.ToString());
                    }
                }
                //
                // make sure this is an event we want to fire..
                //
                if (false == EventThrottler.FireEvent(msgId, eventText.ToString(), out numSkips))
                {
                    // skip it!
                    return;
                }

                if (numSkips > 0)
                {
                    eventText.Append("EventThrottle: skipped ");
                    eventText.Append(numSkips);
                    eventText.Append(" previous events\r\n\r\n");
                }

                // "area" is the xmgmt area, like DefaultNtLog if using Xom NtEvent. We 
                // don't use that.
                LogEventSimple(Config.ComponentName, level, msgId, msgData, eventText.ToString());

            }
            catch (Exception ex)
            {
                // no messing around, go directly to the event log
                string eStr = ex.ToString();
                int start;
                int len;
                int maxIndex = eStr.Length - 1;

                for( start = 0; start < maxIndex; start += len ) { // event string must be < 32766 characters
                    len = Math.Min( eStr.Length - start, XomLoggingControl.MaxEventLength );
                    System.Diagnostics.EventLog.WriteEntry( "EventBuilder",
                        "ERROR generating event for eventlog!!\r\n" + eStr.Substring( start, len ) + "\r\n\r\n" +
                        "This is the original message trying to be written\r\n" +
                        message,
                        System.Diagnostics.EventLogEntryType.Error,
                        (int) (((uint) XEvent.Id.COMMON_CODE_57) & 30) );
                }
            }
            finally 
            {
                _logEventCallDepth--;
            }
        }


        private static string ToXml(HttpRequest request, int maximumLength)
        {

            long position = request.InputStream.Position;
            XmlDocument document = new XmlDocument();

            request.InputStream.Seek(0, SeekOrigin.Begin);
            document.Load(request.InputStream);
            request.InputStream.Seek(position, SeekOrigin.Begin);

            StringBuilder stringBuilder   = new StringBuilder();
            StringWriter  stringWriter    = new StringWriter(stringBuilder);
            XmlWriterSettings xmlSettings = new XmlWriterSettings();

            xmlSettings.Indent = true;
            xmlSettings.IndentChars = "    ";

            XmlWriter xmlWriter = XmlWriter.Create(stringWriter, xmlSettings);
            document.WriteTo(xmlWriter);
            xmlWriter.Flush();

            if (stringBuilder.Length > maximumLength)
            {
                int length = stringBuilder.Length;
                stringBuilder.Length = maximumLength;
                stringBuilder.AppendLine("\r\n\r\nData truncated (" + (length - maximumLength) + " more bytes)");
            }

            return stringBuilder.ToString();
        }


        private static string ToHex(HttpRequest request, int maximumLength)
        {
            long length = request.InputStream.Length;
            string s    = string.Empty;

            if (length > maximumLength)
            {
                s = "\r\nData truncated (" + (length - maximumLength) + " more bytes)";
                length = maximumLength;
            }

            // allocate the buyffer and read from the beginning of the
            // stream.  reset the stream position when   done  reading

            byte[] bytes = new byte[length];
            long position = request.InputStream.Position;

            request.InputStream.Seek(0, SeekOrigin.Begin);
            request.InputStream.Read(bytes, 0, (int) length);
            request.InputStream.Seek(position, SeekOrigin.Begin);

            // convert the byte array into  a  pretty  hex  dump

            string[] lines = ByteConvert.ToFormattedStrings(bytes);
            for (int i = lines.Length - 1;  i >= 0; i--) s = lines[i] + "\r\n" + s;
            return s;
        }


        public static void LogEventSimple(string eventSource, sbyte level, ushort msgId, byte[] msgData, string eventText)
        {
            // now write to event log.  The final string may be more
            // than one entry can take, so we chunk them up.
            //
            int start;
            int len;
            int maxIndex = eventText.Length - 1;

            for (start = 0; start < maxIndex; start += len)
            {
                len = Math.Min( eventText.Length - start, xonline.common.mgmt.XomLoggingControl.MaxEventLength );

                // Don't pass the msgData in. This is a sometimes huge block of binary 
                // data that we haven't actually seen a use for. If someone feels 
                // strongly about this, add it back but provide a way to log it or 
                // not--probably not should be the default.
                System.Diagnostics.EventLog.WriteEntry(
                    eventSource,
                    eventText.Substring(start, len),
                    _typeMapping[ level ],
                    msgId,
                    0);
                //msgData);
            }
        }

        //
        // Convert an exception to an ops-friendly string.
        //
        public static string ExceptionToString( Exception e )
        {
            return XblException.Format(e);
        }

        public static void GetExceptionSrc( Exception e, out string srcFile, out ushort srcLine )
        {
            Exception eCur = e;
            srcFile = null;
            srcLine = 0;

            // find the first frame with file and line info
            while (srcFile == null && eCur != null)
            {
                StackTrace stack = new StackTrace(eCur, true);

                GetStackSrc(stack, out srcFile, out srcLine);

                eCur = eCur.InnerException;
            }
        }

        public static void GetStackSrc( StackTrace stack, out string srcFile, out ushort srcLine )
        {
            srcFile = null;
            srcLine = 0;

            for (int i = 0; i < stack.FrameCount; i++)
            {
                StackFrame frame = stack.GetFrame(i);

                // skip over the uninteresting Logging/xmgmt calls..
                if (frame.GetMethod().DeclaringType != null)
                {
                    if ((frame.GetMethod().Name == "LogEvent" &&
                         frame.GetMethod().DeclaringType.FullName == "xonline.common.service.EventBuilder") ||
                        (frame.GetMethod().DeclaringType.FullName.StartsWith("xonline.common.mgmt")))
                    continue;
                }

                srcFile = frame.GetFileName();
                srcLine = (ushort)frame.GetFileLineNumber();

                if (srcFile != null)
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\Crypto.cs ===
using System;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;

namespace xonline.common.service 
{
[ComVisible(false)]
public class Crypto
{
    private static RNGCryptoServiceProvider _rng = new RNGCryptoServiceProvider();    
    private static ASCIIEncoding _enc = new ASCIIEncoding();
    
    public static byte[] GetRandomBytes(uint len)
    {
        byte[] ret = new byte[len];

        _rng.GetBytes(ret);

        return ret;
    }

    public static uint GetRandomUInt32()
    {
        byte[] bytes = GetRandomBytes(4);
        return BitConverter.ToUInt32(bytes, 0);
    }

    public static ulong GetRandomUInt64()
    {
        byte[] bytes = GetRandomBytes(8);
        return BitConverter.ToUInt64(bytes, 0);
    }
    
    public static string GetRandomString(uint len)
    {
        uint n = 0;
        uint nFound = 0;
        byte[] charBytes = new byte[len];
        byte[] rndBytes = GetRandomBytes(len * 3);
        
        while (nFound < len)
        {
            if (n >= rndBytes.Length-1)
            {
                rndBytes = GetRandomBytes((len-nFound) * 3);
                n = 0;
            }

            if ((rndBytes[n] >= 48 && rndBytes[n] <= 57)     // '0'-'9'
                ||(rndBytes[n] >= 65 && rndBytes[n] <= 90)   // 'A'-'Z'
                || (rndBytes[n] >= 97 && rndBytes[n] <= 122) ) // 'a'-'z'
            {
                // in the acceptable character range, keep it
                charBytes[nFound++] = rndBytes[n];
            }

            n++;
        }

        return _enc.GetString(charBytes);
    }
    
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\FastFail.cs ===
//------------------------------------------------------------------------------
// FastFail
//
// If you're going to time out anyway, why not do it faster?
//
// When a certain number of failures occur (ThresholdCount) within a certain amount of
// time (ThresholdInterval), then the resource is marked as unavailable for a certain
// amount of time (BlockInterval). Then, a small number of callees are allowed to proceed
// to check the resource again, and if it is found to be ok, the resource moves back to
// the available state. If the resource is found to be bad, then it moves back to the
// unavailable state for BlockInterval seconds again. If nothing happens, another
// BlockInterval will elapse and the resource moves back to the available state
// automatically.
//
// Usage:
//
// Before accessing a resource, call InFastFailState(). If it returns false, continue on.
// If it returns true, do not access the resource.
//
// After accessing the resource, call ReportFailure() if it timed out, or call
// ReportSuccess() if it succeeded. This is somewhat important and tricky to get right.
//
// So besides the constructors, the only functions you need are:
//   InFastFailState()
//   ReportFailure()
//   ReportSuccess()
//
// Walk-through:
//
// Let's say ThresholdCount = 2, ThresholdInterval = 30 seconds, and BlockInterval = 60.
//
// You're chugging along, calling InFastFailState() and getting FALSE back, but all of a
// sudden your database dies, so you end up calling ReportFailure() at least 2 times
// within 30 seconds.
//
// Now future threads call InFastFailState() and get TRUE back for the next 60 seconds.
// Then, the next caller to InFastFailState() will get FALSE back, but subsequent callers
// still get TRUE. This is the Recovery state where we "trickle" people out to the
// resource. If that one released caller calls ReportSuccess(), the resource becomes
// available and the cycle starts over. If ReportFailure() is called, the resource becomes
// unavailable for the next 60 seconds again.
//
// If that one released caller never calls either Report function, then another caller is
// "released" in 60 / 4 seconds (15), then another 15 seconds later, then another 15
// seconds later. After 60 seconds have elapsed in this Recovery state with no Report
// function all, the resource is moved to the available state and the whole cycle starts
// over.
//
// -kgoodier January 2008
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Net;
using System.Runtime.CompilerServices;
using System.Data.SqlClient;

using xonline.common.mgmt;
using xonline.common.config;

// seemingly unnecessary, but stflive  rewrites
// this class under a different namespace


namespace xonline.common.service
{
    // This class implements per-resource fast fail semantics
    public class FastFailInternal
    {
        protected class FastFailTracker
        {
            public int FailureCount;
            public DateTime FirstFailureTime;
            public DateTime LastRecoveryTime;
            public FFState State;

            public FastFailTracker()
            {
                FailureCount = 0;
                FirstFailureTime = DateTime.MinValue;
                LastRecoveryTime = DateTime.MinValue;
                State = FFState.Ok;
            }
        }

        public enum FFState
        {
            Ok,
            Failure,
            Recovery
        };


        public const int c_defaultThresholdCount = 2;
        public const int c_defaultThresholdIntervalSeconds = 30;
        public const int c_defaultBlockIntervalSeconds = 60;
        public const int c_defaultMaxFailureExtensions = 2;
        public const XEvent.Id c_eventIdEnterFailure = XEvent.Id.FAIL_FAST_ENTER;
        public const XEvent.Id c_eventIdExitFailure = XEvent.Id.FAIL_FAST_EXIT;
        public const int c_numAttemptsAtRecovery = 4;

        protected virtual int ThresholdCount
        {
            get { return(m_thresholdCount); }
            set { m_thresholdCount = value; }
        }

        protected virtual int ThresholdIntervalSeconds
        {
            get { return(m_thresholdIntervalSeconds); }
            set { m_thresholdIntervalSeconds = value; }
        }

        protected virtual int BlockIntervalSeconds
        {
            get { return(m_blockIntervalSeconds); }
            set { m_blockIntervalSeconds = value; }
        }

        protected virtual XEvent.Id EventIdEnterFailure
        {
            get { return(m_eventIdEnterFailure); }
            set { m_eventIdEnterFailure = value; }
        }

        protected virtual XEvent.Id EventIdExitFailure
        {
            get { return(m_eventIdExitFailure); }
            set { m_eventIdExitFailure = value; }
        }

        // Private members

        protected int m_thresholdCount;
        protected int m_thresholdIntervalSeconds;
        protected int m_blockIntervalSeconds;
        protected XEvent.Id m_eventIdEnterFailure;
        protected XEvent.Id m_eventIdExitFailure;

        protected Dictionary<string, FastFailTracker> m_FastFailTrackers;

        // ----------------------------------------------------------------------
        // GetFastFailTracker
        //
        // Retrieves object from dictionary, creating it if necessary. To protect the
        // dictionary we're using a synchronous lock. This is faster than a
        // ReaderWriterLock for short-lived locks.
        //
        // TODO: The question remains whether we really need to lock reads, it may be that
        // we can get away with only locking writes.
        // ----------------------------------------------------------------------
        [MethodImpl(MethodImplOptions.Synchronized)]
        protected FastFailTracker GetFastFailTracker(string resourceName)
        {
            FastFailTracker s;
            resourceName = resourceName.ToLower();

            if (!m_FastFailTrackers.TryGetValue(resourceName, out s))
            {
                s = new FastFailTracker();
                m_FastFailTrackers[resourceName] = s;
            }

            return s;
        }


        //
        // PUBLIC STUFF BELOW HERE
        //


        // ----------------------------------------------------------------------
        // FastFailInternal constructor
        //
        // Useful for testing and internal uses. You probably want FastFailHelper for
        // "real" code.
        // ----------------------------------------------------------------------
        public FastFailInternal()
        {
            m_thresholdCount            = c_defaultThresholdCount;
            m_thresholdIntervalSeconds  = c_defaultThresholdIntervalSeconds;
            m_blockIntervalSeconds      = c_defaultBlockIntervalSeconds;
            m_eventIdEnterFailure       = XEvent.Id.FAIL_FAST_ENTER;
            m_eventIdExitFailure        = XEvent.Id.FAIL_FAST_EXIT;
            m_FastFailTrackers          = new Dictionary<string, FastFailTracker>();
        }

        // ----------------------------------------------------------------------
        // FastFailInternal constructor 2
        //
        // Let's you override all the settings with different hard-coded values.
        // ----------------------------------------------------------------------
        internal FastFailInternal(
            int thresholdCount,
            int thresholdIntervalSeconds,
            int blockIntervalSeconds,
            XEvent.Id eventIdEnter,
            XEvent.Id eventIdExit)

            : this()
        {
            m_thresholdCount            = thresholdCount;
            m_thresholdIntervalSeconds  = thresholdIntervalSeconds;
            m_blockIntervalSeconds      = blockIntervalSeconds;
            m_eventIdEnterFailure       = eventIdEnter;
            m_eventIdExitFailure        = eventIdExit;
        }

        // ----------------------------------------------------------------------
        // GetCurrentStatus
        //
        // Returns current state of a resource. Does not change anything. Useful for xmgmt
        // commands, etc.
        //
        // Maybe we could also return the timestamps?
        // ----------------------------------------------------------------------
        public FFState GetCurrentStatus(string resourceName)
        {
            FastFailTracker s = GetFastFailTracker(resourceName);
            return s.State;
        }

        // ----------------------------------------------------------------------
        // InFastFailState
        //
        // Call to check if a resource is in a failure state or not. If the answer is
        // TRUE, you should not try to access the resource in question. If the answer is
        // FALSE, you should access the resource and then call either ReportSuccess or
        // ReportFailure. Do not forget to call one of these!
        // ----------------------------------------------------------------------
        public bool InFastFailState(string resourceName)
        {
            FastFailTracker s = GetFastFailTracker(resourceName);

            // Mainline case avoids lock
            if (s.State == FFState.Ok)
            {
                return false;
            }

            lock (s)
            {
                switch (s.State)
                {
                case FFState.Ok:
                    {
                        return false;
                    }
                case FFState.Recovery:
                    {
                        DateTime now = DateTime.UtcNow;
                        TimeSpan timeInFailureAndRecovery = now.Subtract(s.FirstFailureTime);
                        TimeSpan timeSinceLastRelease = now.Subtract(s.LastRecoveryTime);

                        // If we spend 1 period in Failure and 1 period in Recovery, without
                        // hearing success OR failure, give up and set the resource to Ok.
                        // Maybe the caller forgot to call ReportSuccess.
                        if (timeInFailureAndRecovery.TotalSeconds > BlockIntervalSeconds * 2)
                        {
                            if (EventIdExitFailure != 0)
                            {
                                Xom.NtEvent(EventIdExitFailure, 
                                    "Moving out of fail fast for '{0}' due to time expiration. First failure was at {1}, {2} seconds ago.",
                                    resourceName, s.FirstFailureTime, timeInFailureAndRecovery.TotalSeconds
                                );
                            }

                            s.FirstFailureTime = DateTime.MinValue;
                            s.FailureCount = 0;
                            s.State = FFState.Ok;
                            return false;
                        }

                        // Release 1 thread periodically. The period is not configurable; it
                        // is 1/4 of the BlockIntervalSeconds.

                        if (timeSinceLastRelease.TotalSeconds <= BlockIntervalSeconds / c_numAttemptsAtRecovery)
                        {
                            // too short, still blocked
                            return true;
                        }
                        else
                        {
                            // long enough, release one and reset
                            s.LastRecoveryTime = now;
                            return false;
                        }
                    }
                case FFState.Failure:
                    {
                        // if we are in the fast-fail state, check to see if we should still be in it
                        DateTime now = DateTime.UtcNow;
                        TimeSpan timeSpan = now.Subtract(s.FirstFailureTime);
                        if (timeSpan.TotalSeconds <= BlockIntervalSeconds)
                        {
                            // we are still failing fast
                            return true;
                        }
                        else
                        {
                            // now we have blocked for the entire interval, so move out of fast fail
                            // and let 1 thread attempt to access the resource.
                            s.State = FFState.Recovery;
                            s.LastRecoveryTime = now;
                            return false;
                        }
                    }
                default:
                    throw new Exception("Invalid state " + s.State + " for FastFailTracker.");
                }
            }
        }

        // ----------------------------------------------------------------------
        // ReportFailure
        //
        // Call this to report a resource failure.  errorMessage should provide extended
        // error information. The text of the exception for the failure is a good
        // suggestion.
        // ----------------------------------------------------------------------
        public void ReportFailure(string resourceName, string errorMessage)
        {
            FastFailTracker s = GetFastFailTracker(resourceName);

            lock (s)
            {
                switch (s.State)
                {
                case FFState.Ok:
                    {
                        DateTime now = DateTime.UtcNow;
                        TimeSpan timeSpan = now.Subtract(s.FirstFailureTime);

                        if (timeSpan.TotalSeconds <= ThresholdIntervalSeconds)
                        {
                            // it hasn't been that long since the last failure, so increment the count

                            s.FailureCount++;
                        }
                        else
                        {
                            // it's been a while since we got a failure, so treat this as the first failure

                            s.FirstFailureTime = now;
                            s.FailureCount = 1;
                        }

                        if (s.FailureCount >= ThresholdCount)
                        {
                            s.State = FFState.Failure;

                            // now the last failure time becomes how we measure the fast fail duration
                            s.FirstFailureTime = now;

                            if (EventIdEnterFailure != 0)
                            {
                                Xom.NtEvent(EventIdEnterFailure, 
                                    "Moving to fast fail for '{0}', after receiving {1} failures, each within {2} seconds of each other.\r\n" + 
                                    "The resource will be fast-failed for {3} seconds (max {4} seconds, pending resource success).\r\n" +
                                    "The extended error message is: \r\n{5}",
                                    resourceName, s.FailureCount, ThresholdIntervalSeconds,
                                    BlockIntervalSeconds, BlockIntervalSeconds * 2,
                                    errorMessage == null ? "n/a" : errorMessage
                                );
                            }
                        }
                    }
                    break;
                case FFState.Recovery:
                    {
                        // Uh oh, take a step back
                        s.State = FFState.Failure;
                        s.FirstFailureTime = DateTime.UtcNow;
                        // leave s.FailureCount alone (above threshold)
                    }
                    break;
                case FFState.Failure:
                    {
                        // already failing, nothing to do
                    }
                    break;
                default:
                    throw new Exception("Invalid state " + s.State + " for FastFailTracker.");
                }

            }
        }

        // ----------------------------------------------------------------------
        // ReportSuccess
        //
        // Call this to report a resource success.
        // ----------------------------------------------------------------------
        public void ReportSuccess(string resourceName)
        {
            FastFailTracker s = GetFastFailTracker(resourceName);

            // Mainline case avoids lock
            if (s.State == FFState.Ok)
            {
                return;
            }

            lock (s)
            {
                switch (s.State)
                {
                case FFState.Ok:
                    {
                        // yay, more successes!
                    }
                    break;
                case FFState.Recovery:
                    {
                        DateTime now = DateTime.UtcNow;
                        TimeSpan timeSpan = now.Subtract(s.FirstFailureTime);
                        if (EventIdExitFailure != 0)
                        {
                            Xom.NtEvent(EventIdExitFailure, 
                                "Moving out of fail fast for '{0}' due to success report.  First failure was at {1}, {2} seconds ago.",
                                resourceName, s.FirstFailureTime, timeSpan.TotalSeconds
                            );
                        }

                        s.FirstFailureTime = DateTime.MinValue;
                        s.FailureCount = 0;
                        s.State = FFState.Ok;
                    }
                    break;
                case FFState.Failure:
                    {
                        // hmm.. shouldn't happen, maybe there were some straggler threads.
                        // we're going to stay in Failure mode. Have to move to Recovery state
                        // first.
                    }
                    break;
                default:
                    throw new Exception("Invalid state " + s.State + " for FastFailTracker.");
                }
            }
        }

    }


    // ------------------------------------------------------------------------------
    // FastFailHelper
    //
    // Extends the FastFailInternal class with handy NPDB setting wrappers. You probably
    // want to use this in "real" server code.
    // ------------------------------------------------------------------------------
    public class FastFailHelper : FastFailInternal
    {
        // Config setting names
        protected string m_thresholdCountSettingName;
        protected string m_thresholdIntervalSecondsSettingName;
        protected string m_blockIntervalSecondsSettingName;

        // This object tracks internal failures reading the config settings
        private FastFailInternal m_fastFailConfig;
        private const string c_configResourceName = "FastFailHelper NPDB";

        protected override int ThresholdCount
        {
            get
            {
                if (null != m_thresholdCountSettingName &&
                    !m_fastFailConfig.InFastFailState(c_configResourceName))
                {
                    try
                    {
                        m_thresholdCount = Config.GetIntSetting(m_thresholdCountSettingName);
                        m_fastFailConfig.ReportSuccess(c_configResourceName);
                    }
                    catch (Exception e)
                    {
                        m_fastFailConfig.ReportFailure(c_configResourceName, e.ToString());
                    }
                }

                return (m_thresholdCount);
            }
        }

        protected override int ThresholdIntervalSeconds
        {
            get
            {
                if (null != m_thresholdIntervalSecondsSettingName &&
                    !m_fastFailConfig.InFastFailState(c_configResourceName))
                {
                    try
                    {
                        m_thresholdIntervalSeconds = Config.GetIntSetting(m_thresholdIntervalSecondsSettingName);
                        m_fastFailConfig.ReportSuccess(c_configResourceName);
                    }
                    catch (Exception e)
                    {
                        m_fastFailConfig.ReportFailure(c_configResourceName, e.ToString());
                    }
                }

                return (m_thresholdIntervalSeconds);
            }
        }

        protected override int BlockIntervalSeconds
        {
            get
            {
                if (null != m_blockIntervalSecondsSettingName &&
                    !m_fastFailConfig.InFastFailState(c_configResourceName))
                {
                    try
                    {
                        m_blockIntervalSeconds = Config.GetIntSetting(m_blockIntervalSecondsSettingName);
                        m_fastFailConfig.ReportSuccess(c_configResourceName);
                    }
                    catch (Exception e)
                    {
                        m_fastFailConfig.ReportFailure(c_configResourceName, e.ToString());
                    }
                }

                return (m_blockIntervalSeconds);
            }
        }

        //----------------------------------------------------------------------
        // FastFailHelper constructor
        //
        // The setting names may be null, in which case the default values will be used.
        //----------------------------------------------------------------------
        public FastFailHelper(
            string thresholdCountSettingName,
            string thresholdIntervalSecondsSettingName,
            string blockIntervalSecondsSettingName)

            : base()
        {
            m_thresholdCountSettingName = thresholdCountSettingName;
            m_thresholdIntervalSecondsSettingName = thresholdIntervalSecondsSettingName;
            m_blockIntervalSecondsSettingName = blockIntervalSecondsSettingName;

            m_fastFailConfig = new FastFailInternal();
        }

        //----------------------------------------------------------------------
        // FastFailHelper constructor
        //
        // The setting names may be null, in which case the default values will be used.
        // Extra options to allow you to specify unique event ids for the "resource
        // entered fail state" and "resource exited fail state" events.  Highly
        // recommended.
        //----------------------------------------------------------------------
        public FastFailHelper(
            string thresholdCountSettingName,
            string thresholdIntervalSecondsSettingName,
            string blockIntervalSecondsSettingName,
            XEvent.Id eventIdEnterFailure,
            XEvent.Id eventIdExitFailure)

            : this(thresholdCountSettingName,
                   thresholdIntervalSecondsSettingName,
                   blockIntervalSecondsSettingName)

        {
            EventIdEnterFailure = eventIdEnterFailure;
            EventIdExitFailure = eventIdExitFailure;
        }

        // ----------------------------------------------------------------------
        // ConsiderExceptionAsFailure
        //
        // This function takes an Exception and determines if it qualifies as a "FastFail"
        // level of failure. Only certain classes of SqlException, XRLException, and
        // WebException apply. If the exception type is not one of the above, it is
        // optimistically considered a success, since we don't want potentially
        // user-generated exceptions (bad input) being considered for FastFail.
        // ----------------------------------------------------------------------
        public static bool ConsiderExceptionAsTimeout(Exception e)
        {
            if (e is SqlException)
            {
                foreach (SqlError error in (e as SqlException).Errors)
                {
                    if (SQLDefs.ERROR_LOGIN_TIMEOUT == error.Number ||
                        SQLDefs.ERROR_LOGIN_NETWORK_ERROR == error.Number ||
                        SQLDefs.ERROR_NETWORK_TIMEOUT == error.Number ||
                        SQLDefs.ERROR_SQLCLIENT_TIMEOUT == error.Number ||
                        SQLDefs.ERROR_SQLCLIENT_CONNECTION_FAILED == error.Number ||
                        SQLDefs.ERROR_SQLCLIENT_CONNECTION_FAILED2 == error.Number ||
                        SQLDefs.ERROR_CANNOT_OPEN_DATABASE == error.Number)
                    {
                        return true;
                    }
                }
            }
            else if (e is XRLException)
            {
                SqlException se = (e as XRLException).InnerException as SqlException;
                if (null != se)
                {
                    return ConsiderExceptionAsTimeout(se);
                }
            }
            else if (e is TimeoutException)
            {
                return true;
            }
            else if (e is WebException)
            {
                WebException we = (WebException) e;
                WebExceptionStatus status = we.Status;

                if (status == WebExceptionStatus.ReceiveFailure ||
                    status == WebExceptionStatus.RequestCanceled ||
                    status == WebExceptionStatus.ServerProtocolViolation ||
                    status == WebExceptionStatus.Timeout ||
                    status == WebExceptionStatus.UnknownError ||
                    status == WebExceptionStatus.ConnectionClosed ||
                    status == WebExceptionStatus.KeepAliveFailure ||
                    status == WebExceptionStatus.PipelineFailure
                   )
                {
                    return true;
                }

                // 504 - Gateway timeout doesn't come back in the
                // WebExceptionStatus so we have to hand check it

                else {
                    HttpWebResponse response = (HttpWebResponse) ((WebException) e).Response;
                    if ((response != null) && (response.StatusCode == HttpStatusCode.GatewayTimeout)) return true;
                }
            }
            return false;
        }

        public static bool ConsiderWebExceptionAsTimeout(WebException e)
        {
            return ConsiderExceptionAsTimeout(e);
        }

        private class SQLDefs
        {
            // These errors are not from SQL Server, they must be from the data access layer, SqlClient.
            public const int ERROR_SQLCLIENT_TIMEOUT = -2;              // "Timeout expired.  The timeout period elapsed prior to completion of the operation or the server is not responding."
            public const int ERROR_SQLCLIENT_CONNECTION_FAILED = 2;     // "An error has occurred while establishing a connection to the server.  When connecting to SQL Server 2005, this failure may be caused by the fact that under the default settings SQL Server does not allow remote connections. (provider: Named Pipes Provider, error: 40 - Could not open a connection to SQL Server)"
            public const int ERROR_SQLCLIENT_CONNECTION_FAILED2 = 53;  // same as above, but this is the error code I see. argh.

            // These errors are from SQL Server (sysmessages)
            public const int ERROR_PARAM_MISSING = 201;
            public const int ERROR_COULD_NOT_CONTINUE_SCAN_WITH_NOLOCK = 601;
            public const int ERROR_DEADLOCKED_PROCESS_KILLED = 1205;
            public const int ERROR_PRIMARY_KEY_VIOLATION = 2627;
            public const int ERROR_COULD_NOT_FIND_STORED_PROC = 2812;
            public const int ERROR_TOO_MANY_PARAM = 8144;
            public const int ERROR_INVALID_PARAM_NAME = 8145;
            public const int ERROR_PARAMETER_PROVIDED_MULTIPLE_TIMES = 8143;
            public const int ERROR_DATA_TRUNCATED = 8152;
            public const int ERROR_LOGIN_TIMEOUT = 17197;
            public const int ERROR_LOGIN_NETWORK_ERROR = 17829;
            public const int ERROR_NETWORK_TIMEOUT = 17830;
            public const int ERROR_CANNOT_OPEN_DATABASE = 4060;
        }



    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\FastFailStatistics.cs ===
/* FastFail using the thread throttling approach - Performance Counter Support
 * ----------------------------------------------------------------------------
 * BRIEF OVERVIEW:
 * Statistics act as the basis for driving the throttling functions.
 * The values exposed represent the captured values across a sliding window of
 * time.
 * 
 * FULL OVERVIEW:
 * see: http://xblwiki/default.aspx/XboxLive/FastFailThreadsPerResource.html
 * 
 * current owner: jojohn
 */

namespace xonline.common.service {
   using System;
    using System.Collections.Generic;
    using System.Text;

    using xonline.common.config;

   public enum FastFailResult : uint {
      Success = 0,
      Timeout = 1,
      Failure = 2
   }

   public class FastFailClock {
      public static FastFailClock Clock = new FastFailClock();

      public virtual DateTime Now {
         get { return DateTime.UtcNow; }
      }
   }

   public class FastFailFeature {
      public const uint DefaultBucketCount = 8;

      public static uint BucketCount {
         get {
            if (!_bucketCount.HasValue) {
               try { 
                  _bucketCount = Config.GetUIntSetting(Setting.fastfail_bucketCount);

                  if (_bucketCount < 1) {
                     _bucketCount = DefaultBucketCount;

                     throw new ArgumentException(
                        "npdb bucket count setting must be at least 1",
                        Setting.fastfail_bucketCount);
                  }
               }
               catch (ApplicationException) {
                  //Setting missing
                  _bucketCount = DefaultBucketCount;
               }
               catch (Exception) {
                  _bucketCount = DefaultBucketCount;
                  throw;
               }
            }

            return _bucketCount.Value;
         }
         set {
            if (value == 0)
               throw new ArgumentException("bucket size must be larger than 0.");

            _bucketCount = value;
         }
      }

      private struct Event {
         public Event(DateTime startTime, DateTime endTime) {
            if (startTime > endTime)
               throw new ArgumentException("startTime is greater than endTime");

            this.StartTime = startTime;
            this.Duration = endTime - startTime;
         }

         public DateTime StartTime;
         public TimeSpan Duration;
      }

      private struct Accumulator {
         public void AddEvent(Event newEvent) {
            if (0 == this.Count)
               this.FirstEvent = newEvent;

            this.LastEvent = newEvent;
            this.Count++;
            this.AccumulatedDuration += newEvent.Duration;
         }

         public bool SubtractBucket(Bucket bucket) {
            this.Count -= bucket.Count;
            this.AccumulatedDuration -= bucket.AccumulatedDuration;

            return bucket.Count > 0;
         }

         public Event FirstEvent;
         public Event LastEvent;
         public uint Count;
         public TimeSpan AccumulatedDuration;
      }

      private struct Bucket {
         public void AddEvent(Event newEvent) {
            if (0 == this.Count)
               this.FirstEvent = newEvent;

            this.LastEvent = newEvent;
            this.Count++;
            this.AccumulatedDuration += newEvent.Duration;
         }

         public void Clear() {
            Count = 0;
            AccumulatedDuration = TimeSpan.Zero;
         }

         public Event FirstEvent;
         public Event LastEvent;
         public uint Count;
         public TimeSpan AccumulatedDuration;
      }

      public FastFailFeature(uint bucketCount) {
         accumulator = new Accumulator();
         trackingVector = new Bucket[bucketCount];
         activeTracker = 0;
         oldestTracker = 0;
         youngestTracker = 0;
      }

      public FastFailFeature() 
         : this (BucketCount) { }

      #region Exposed Methods
      public void IngestEvent(DateTime start, DateTime end) {
         trackingVector[activeTracker].AddEvent(new Event(start, end));
         accumulator.AddEvent(new Event(start, end));
         youngestTracker = activeTracker;
      }

      public bool ExpireBucket() {
         uint CurrentTracker = activeTracker;
         bool Result = false;

         activeTracker = NextTracker(activeTracker);

         if (accumulator.SubtractBucket(trackingVector[activeTracker])) {
            trackingVector[activeTracker].Clear();
            oldestTracker = NextTracker(oldestTracker);
            Result = true;
         }

         accumulator.FirstEvent = trackingVector[oldestTracker].FirstEvent;
         accumulator.LastEvent = trackingVector[youngestTracker].LastEvent;

         return Result;
      }

      public override string ToString() {
         StringBuilder Result = new StringBuilder();

         Result.AppendLine("Count = " + Count.ToString());
         Result.AppendLine("AccumulatedDuration = " + AccumulatedDuration.ToString());
         Result.AppendLine("AverageDuration = " + AverageDuration.ToString());
         Result.AppendLine("Rate = " + Rate.ToString());
         Result.AppendLine("LowBiasedRate = " + LowBiasedRate.ToString());
         Result.AppendLine("HighBiasedRate = " + HighBiasedRate.ToString());

         return Result.ToString();
      }
      #endregion

      #region Private Helper Methods
      private uint NextTracker(uint current) {
         return (current + 1) % Buckets;
      }
      #endregion

      #region Properties
      public KeyValuePair<DateTime, TimeSpan> FirstEvent {
         get { return new KeyValuePair<DateTime, TimeSpan>(accumulator.FirstEvent.StartTime, accumulator.FirstEvent.Duration); }
      }

      public KeyValuePair<DateTime, TimeSpan> LastEvent {
         get { return new KeyValuePair<DateTime, TimeSpan>(accumulator.LastEvent.StartTime, accumulator.LastEvent.Duration); }
      }

      public float AccumulatedDuration {
         get { return (float)accumulator.AccumulatedDuration.TotalSeconds; }
      }

      public float Count {
         get { return accumulator.Count; }
      }

      public uint Buckets {
         get { return (uint)trackingVector.Length; }
      }

      public float AverageDuration {
         get { return Count != 0 ? AccumulatedDuration / Count : 0; }
      }

      public float Rate {
         get { return Count != 0 ? Count / AccumulatedDuration : 0; }
      }

      public float LowBiasedRate {
         get { return Count != 0 ? Count / (float)(FastFailClock.Clock.Now - FirstEvent.Key).TotalSeconds : 0; }
      }

      public float HighBiasedRate {
         get { return Count != 0 ? Count / (float)(LastEvent.Key - FirstEvent.Key + LastEvent.Value).TotalSeconds : 0; }
      }
      #endregion

      private static uint? _bucketCount = null;
      private Accumulator accumulator;
      private Bucket[] trackingVector;
      private uint activeTracker;
      private uint oldestTracker;
      private uint youngestTracker;
   }

   public class FastFailFeatureAggregation {
      public FastFailFeatureAggregation() {
         bucketCount       = FastFailFeature.BucketCount;
         allRequests       = new FastFailFeature(bucketCount);
         successfulResults = new FastFailFeature(bucketCount);
         failedRequests    = new FastFailFeature(bucketCount);
         timedoutRequests  = new FastFailFeature(bucketCount);
         ingestionLock     = new object();
      }

      public void IngestEvent(DateTime start, DateTime end, FastFailResult result) {
         lock (ingestionLock) {
            allRequests.IngestEvent(start, end);

            switch (result) {
               case FastFailResult.Timeout:
                  timedoutRequests.IngestEvent(start, end);
                  break;
               case FastFailResult.Failure:
                  failedRequests.IngestEvent(start, end);
                  break;
               default:
                  successfulResults.IngestEvent(start, end);
                  break;
            }
         }
      }

      // Caller responsible for locking this (FastFailStatistics does this)
      public bool ExpireBuckets() {
         return
            allRequests.ExpireBucket() |
            successfulResults.ExpireBucket() |
            failedRequests.ExpireBucket() |
            timedoutRequests.ExpireBucket();
      }

      #region Properties
      public FastFailFeature AllRequests {
         get { return allRequests; }
      }

      public FastFailFeature SuccessfulRequests {
         get { return successfulResults; }
      }

      public FastFailFeature FailedRequests {
         get { return failedRequests; }
      }

      public FastFailFeature TimedoutRequests {
         get { return timedoutRequests; }
      }

      public uint BucketCount {
         get { return bucketCount; }
      }

      public float SuccessRatio {
         get { return allRequests.Count > 0 ? successfulResults.Count / allRequests.Count : 1.0f; }
      }

      public float FailureRatio {
         get { return allRequests.Count > 0 ? failedRequests.Count / allRequests.Count : 0.0f; }
      }

      public float TimeoutRatio {
         get { return allRequests.Count > 0 ? timedoutRequests.Count / allRequests.Count : 0.0f; }
      }
      #endregion

      private FastFailFeature allRequests;
      private FastFailFeature successfulResults;
      private FastFailFeature failedRequests;
      private FastFailFeature timedoutRequests;
      private uint bucketCount;
      private object ingestionLock;
   }

   public class FastFailStatistics {
      public FastFailStatistics(FastFailResourceConfig configuration) {
         if (null == configuration)
            throw new ArgumentNullException("configuration");

         if (configuration.CaptureTimeWindow.TotalSeconds < 1)
            throw new ArgumentException("capture window must be at least 1 second", "configuration.CaptureTimeWindow");

         this.captureTimeWindow = configuration.CaptureTimeWindow;
         this.captureExpirationMark = null;
         this.aggregatedFeatures = new FastFailFeatureAggregation();
         this.ingestionLock = new object();
      }

      public bool AdvanceWindow() {
         DateTime CurrentTick = FastFailClock.Clock.Now;
         bool StatisticsChange = false;

         if (CaptureExpirationMark <= CurrentTick) {
            TimeSpan Delta;
            uint Count;

            Delta = CurrentTick - CaptureExpirationMark;
            Count = (uint)(Delta.TotalSeconds / ExpirationPeriod.TotalSeconds) + 1;
            CaptureExpirationMark += TimeSpan.FromSeconds(ExpirationPeriod.TotalSeconds * Count);

            for (int c = 0; c < Math.Min(aggregatedFeatures.BucketCount, Count); c++)
               StatisticsChange |= aggregatedFeatures.ExpireBuckets();
         }

         return StatisticsChange;
      }

      #region Properties
      private DateTime CaptureExpirationMark {
         get {
            if (!captureExpirationMark.HasValue)
               captureExpirationMark = FastFailClock.Clock.Now + ExpirationPeriod;

            return captureExpirationMark.Value;
         }
         set { captureExpirationMark = value; }
      }

      public TimeSpan ExpirationPeriod {
         get { return TimeSpan.FromSeconds(captureTimeWindow.TotalSeconds / aggregatedFeatures.BucketCount); }
      }

      public FastFailFeatureAggregation AggregatedFeatures {
         get { return aggregatedFeatures; }
      }

      public TimeSpan CaptureTimeWindow {
         get { return captureTimeWindow; }
         set {
            if (value.TotalSeconds < 1)
               throw new ArgumentException("capture window must be at least 1 second", "value");

            captureTimeWindow = value;
            captureExpirationMark = null;
         }
      }

      public object IngestionLock {
         get { return ingestionLock; }
      }
      #endregion

      private TimeSpan captureTimeWindow;
      private DateTime? captureExpirationMark;
      private FastFailFeatureAggregation aggregatedFeatures;
      private object ingestionLock;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\FastFailCounters.cs ===
/* FastFail using the thread throttling approach - Performance Counter Support
 * ----------------------------------------------------------------------------
 * BRIEF OVERVIEW:
 * Performance counters will act as the basis for relaying run-time information
 * to external monitoring system (MOM more than likely).
 *
 * FULL OVERVIEW:
 * see: http://xblwiki/default.aspx/XboxLive/FastFailThreadsPerResource.html
 *
 * USAGE OVERVIEW:
 * The FastFailResourceCategory class needs to be extended in order to get
 * performance counting working for the new resource.  The extended class must
 * do the following:
 *
 *  1. decorated with XomPerformanceCounterCategoryAttr attribute.
 *  2. create public static field of its own type (Counters is a good name,
 *     but it can be named anything).
 *  3. your default constructor must pass the name of the resource to the
 *     base constructor.
 *
 * Refer to FastFailSafeNpdbPerformanceCategory, it only does the 3 things
 * listed above.
 *
 * As convention the category name should be FastFail_[resourceName]
 *
 * current owner: jojohn
 */

namespace xonline.common.service {
   using System;
   using System.Collections.Generic;
   using System.Diagnostics;

   using xonline.common.mgmt;

    [XomPerformanceCounterCategoryAttr( "FastFail: SafeNPDB", "FastFail safe npdb resource", true )]
   public class FastFailSafeNpdbPerformanceCategory : FastFailPerformanceCategory {
      public FastFailSafeNpdbPerformanceCategory()
         : base("SafeNPDB") { }

      public static FastFailSafeNpdbPerformanceCategory Counters = new FastFailSafeNpdbPerformanceCategory();
   }

   public class FastFailPerformanceCategory : XomPerformanceCounterCategory {
      public static FastFailPerformanceCategory GetPerformanceCategory(string resourceName) {
         if (null == resourceName)
            throw new ArgumentNullException("resourceName");
         
         resourceName = resourceName.ToLower();

         if (resourceCategoryLookup.ContainsKey(resourceName))
            return resourceCategoryLookup[resourceName];

         Xom.NtEvent(XEvent.Id.FAST_FAIL_MISSING_COUNTERS,
            "FastFail - " + resourceName + " - " +
            "failed to locate performance counter category."
         );

         return null;
      }

      public FastFailPerformanceCategory(string resourceName) {
         if (null == resourceName)
            throw new ArgumentNullException("resourceName");

         this.resourceName = resourceName.ToLower();
         resourceCategoryLookup[this.resourceName] = this;
      }

      public FastFailPerformanceCategory this[string component] {
         get {
            if (null == component)
               throw new ArgumentNullException("component");

            return (FastFailPerformanceCategory)GetInstance(component);
         }
      }

      public string ResourceName {
         get { return resourceName; }
      }

      [XomPerformanceCounterAttr(
         "Threads, Threshold",
         "Thread threshold on threads for this resource",
         PerformanceCounterType.NumberOfItems32)]
      public PerformanceCounter ThreadThreshold;

      [XomPerformanceCounterAttr(
         "Threads, Percent Utilization",
         "Percentage of threads used for resource",
         PerformanceCounterType.RawFraction)]
      public PerformanceCounter ThreadUtilization;

      [XomPerformanceCounterAttr(
         "Threads, Percent Utilization Base",
         "Percentage of threads used for resource base",
         PerformanceCounterType.RawBase)]
      public PerformanceCounter ThreadUtilizationBase;

      [XomPerformanceCounterAttr(
         "Denial, Per Second",
         "Number of fast fail denied access to this resources per second",
         PerformanceCounterType.RateOfCountsPerSecond32)]
      public PerformanceCounter DenialRate;

      [XomPerformanceCounterAttr(
         "Denial, Total",
         "Totoal number of fast fail denied access to this resource",
         PerformanceCounterType.NumberOfItems64)]
      public PerformanceCounter DenialCount;

      [XomPerformanceCounterAttr(
         "Failure, Per Second",
         "Number of fast fail denied access to this resources per second",
         PerformanceCounterType.RateOfCountsPerSecond32)]
      public PerformanceCounter FailureRate;

      [XomPerformanceCounterAttr(
         "Failure, Total",
         "Total number of fast fail denied access to this resource",
         PerformanceCounterType.NumberOfItems64)]
      public PerformanceCounter FailureCount;

      [XomPerformanceCounterAttr(
         "Timeout, Per Second",
         "Number of timeouts occurring while accessing resources per second",
         PerformanceCounterType.RateOfCountsPerSecond32)]
      public PerformanceCounter TimeoutRate;

      [XomPerformanceCounterAttr(
         "Timeout, Total",
         "Total number of timeouts occurring while accessing the resource",
         PerformanceCounterType.NumberOfItems64)]
      public PerformanceCounter TimeoutCount;

      [XomPerformanceCounterAttr(
         "Request, Avr. Response Time",
         "Average request execution time for resource in (ms)",
         PerformanceCounterType.AverageTimer32)]
      public PerformanceCounter AverageResponse;

      [XomPerformanceCounterAttr(
         "Request, Avr. Response Time Base",
         "Base for the average request execution time for resource",
         PerformanceCounterType.AverageBase)]
      public PerformanceCounter AverageResponseBase;


      private string resourceName;
      private static Dictionary<string, FastFailPerformanceCategory> resourceCategoryLookup = new Dictionary<string, FastFailPerformanceCategory>();
   }

   #region FastFailResourceTracker Performance Counter Methods
   public partial class FastFailResource {
      private void AdjustEventCounters(DateTime start, DateTime end, FastFailResult result) {
         if (null != globalPerformance) {
            TimeSpan Span = end - start;

            globalPerformance.AverageResponse.IncrementBy(Span.Ticks);
            globalPerformance.AverageResponseBase.Increment();

            instancedPerformance.AverageResponse.IncrementBy(Span.Ticks);
            instancedPerformance.AverageResponseBase.Increment();

            switch (result) {
               case FastFailResult.Timeout:
                  globalPerformance.TimeoutRate.Increment();
                  globalPerformance.TimeoutCount.Increment();

                  instancedPerformance.TimeoutRate.Increment();
                  instancedPerformance.TimeoutCount.Increment();
                  break;
               case FastFailResult.Failure:
                  globalPerformance.FailureRate.Increment();
                  globalPerformance.FailureCount.Increment();

                  instancedPerformance.FailureRate.Increment();
                  instancedPerformance.FailureCount.Increment();
                  break;
            }
         }
      }

      private void IncrementDenialCounter() {
         if (null != globalPerformance) {
            globalPerformance.DenialRate.Increment();
            globalPerformance.DenialCount.Increment();

            instancedPerformance.DenialRate.Increment();
            instancedPerformance.DenialCount.Increment();
         }
      }

      private void IncrementThreadCounter() {
         if (null != globalPerformance) {
            globalPerformance.ThreadUtilization.Increment();

            instancedPerformance.ThreadUtilization.Increment();
         }
      }

      private void DecrementThreadCounter() {
         if (null != globalPerformance) {
            globalPerformance.ThreadUtilization.Decrement();

            instancedPerformance.ThreadUtilization.Decrement();
         }
      }

      private void ChangeUtilizationDenominator(uint denominator) {
         if (null != instancedPerformance) {
            instancedPerformance.ThreadThreshold.RawValue = denominator;

            instancedPerformance.ThreadUtilizationBase.RawValue = denominator;
         }
      }
   }
   #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\FastQueue.cs ===
using System;
using System.Threading;

namespace xonline.common.service
{
    public class FastQueue
    {
        
        public FastQueue(int size) : this(size, true) {}
        public FastQueue(int size, bool fUseExceptions)
        {
            _rgItems = new Object[size];
            _iHead = 0;
            _iTail = 0;
            _cItems = 0;
            _iWriting = 0;
            _fUseExceptions = fUseExceptions;
            _rwlGrow = new ReaderWriterLock();
        }

        ~FastQueue()
        {
            for (int i = 0 ; i < _rgItems.Length; i++)
            {
                _rgItems[i] = null;
            }

            _rgItems = null;
        }

        public int Count
        {
            get
            {
                return _cItems;
            }
        }
        
        public bool Enqueue(Object o)
        {
            if (o == null)
            {
                if (_fUseExceptions)
                {
                    throw new ArgumentException("Cannot enqueue null value.");
                }
                else
                {
                    return false;
                }
            }
            
            bool fDone = false;
            
            while (!fDone)
            {
                // always get a reader lock so that we dont do anything while growing.
                _rwlGrow.AcquireReaderLock(-1);
                
                int iSlot = _iTail;
                if (iSlot == Interlocked.CompareExchange(ref _iTail, (iSlot + 1) % _rgItems.Length, iSlot))
                {
                    // we just incremented _iTail -- it should be safe to use the old slot.
                    if (null == Interlocked.CompareExchange(ref _rgItems[iSlot], o, null))
                    {
                        // we got our spot
                        fDone = true;
                    }
                    else
                    {
                        Grow();
                    }
                }
                
                _rwlGrow.ReleaseReaderLock();
            }

            // increment the count.
            Interlocked.Increment(ref _cItems);

            return true;
        }

        public Object Dequeue()
        {
            // test if there is an item available to satisfy this dequeue.
            int count = Interlocked.Decrement(ref _cItems);
            if (count < 0)
            {
                // undo the extraneous decrement.
                Interlocked.Increment(ref _cItems);

                if (_fUseExceptions)
                {
                    throw new InvalidOperationException("queue empty.");
                }
                else
                {
                    return null;
                }
            }
            
            Object o = null;
            
            while (o == null)
            {
                // always get a reader lock so that we dont do anything while growing.
                _rwlGrow.AcquireReaderLock(-1);
                
                int iSlot = _iHead;
                if (iSlot == Interlocked.CompareExchange(ref _iHead, (iSlot + 1) % _rgItems.Length, iSlot))
                {
                    // we just incremented _iHead -- iSlot should contain our item.     
                    o = Interlocked.Exchange(ref _rgItems[iSlot], null);

                    while (o == null)
                    {
                        // this happens if an enqueue has claimed this slot, but was interrupted before populating it.
                        // we know that the slot will be filled as soon as that thread resumes, so we yield to allow it.
                        Thread.Sleep(0);
                        o = Interlocked.Exchange(ref _rgItems[iSlot], null);
                    }
                }
                
                _rwlGrow.ReleaseReaderLock();
            }

            return o;
        }
        
        private void Grow()
        {
            // assumes reader lock is already held.

            // this is a fast check to determine if someone else is already doing the grow.  we dont want multiple calls to Grow to queue up and all succeed.
            if (1 == Interlocked.Increment(ref _iWriting))
            {
                // only the first increment actually writes

                // take the writer lock to prevent any Enqueues or Dequeues
                LockCookie lc = _rwlGrow.UpgradeToWriterLock(-1);

                // double the size of the array
                Object[] rgNew = new Object[_rgItems.Length * 2];

                int iNew = 0;
                _iTail = _iHead;

                // copy the old data.  we rebase _iHead at 0.            
                // there should be roughly _rgItems.Length elements in the list.
                for (; _iHead < _rgItems.Length; _iHead++)
                {
                    if (_rgItems[_iHead] != null)
                    {
                        rgNew[iNew] = _rgItems[_iHead];
                        iNew++;
                    }
                }
                for (_iHead = 0; _iHead < _iTail; _iHead++)
                {
                    if (_rgItems[_iHead] != null)
                    {
                        rgNew[iNew] = _rgItems[_iHead];
                        iNew++;
                    }
                }

                // update new members
                _rgItems = rgNew;
                _iHead = 0;
                _iTail = iNew;

                _rwlGrow.DowngradeFromWriterLock(ref lc);
            }

            Interlocked.Decrement(ref _iWriting);
        }

        private Object[] _rgItems;
        private int _iHead;
        private int _iTail;
        private int _cItems;
        private int _iWriting;
        private bool _fUseExceptions;
        private ReaderWriterLock _rwlGrow;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\FastPool.cs ===
using System;
using System.Threading;

namespace xonline.common.service
{    
    public class FastPool
    {
        public class PoolItem
        {
            public PoolItem()
            {
                _iLocked = 0;
                _o = null;
            }
            
            public int _iLocked;
            public Object _o;
        }

        public class WaitContext
        {
            public WaitContext()
            {
                _event = new ManualResetEvent(false);
            }
            
            public Object _o;
            public ManualResetEvent _event;
        }

        // using this constructor will create a pool that can be empty.
        // if Obtain() is called on an empty pool, an InvalidOperationException will be thrown.
        public FastPool(int size) : this(size, 0, true) {}

        // using this constructor will create a pool that can be empty.
        // if Obtain() is called on an empty pool, and fUseExceptions is false, null is returned.
        public FastPool(int size, bool fUseExceptions) : this(size, 0, fUseExceptions) {}

        // using this constructor will create a pool with an accompanying queue to store wait contexts.
        // if Obtain is called on an empty pool, the call will block until one of the pool items becomes available.
        public FastPool(int poolSize, int queueSize) : this(poolSize, queueSize, true) {}

        // using this constructor will create a pool with an accompanying queue to store wait contexts.
        // if Obtain is called on an empty pool, the call will block until one of the pool items becomes available.
        // if Obtain() is called on an empty pool, and fUseExceptions is false, null is returned.
        public FastPool(int poolSize, int queueSize, bool fUseExceptions)
        {
            _iSize = poolSize;
            _iLastInserted = 0;
            _iLastObtained = 0;
            _fUseExceptions = fUseExceptions;
            _rgItems = new PoolItem[_iSize];

            if (queueSize != 0)
            {
                _waitQueue = new FastQueue(queueSize, fUseExceptions);
            }
            else
            {
                _waitQueue = null;
            }

            for (int i = 0; i < _iSize; i++)
            {
                _rgItems[i] = new PoolItem();
            }
        }

        ~FastPool()
        {
            for (int i = 0; i < _iSize; i++)
            {
                _rgItems[i]._o = null;
                _rgItems[i] = null;
            }
        }

        public bool Insert(Object o)
        {
            if (o == null)
            {
                if (_fUseExceptions)
                {
                    throw new ArgumentException("object cannot be null.");
                }
                else
                {
                    return false;
                }
            }

            if (_waitQueue != null)
            {
                if (_fUseExceptions)
                {
                    try
                    {
                        WaitContext wc = (WaitContext)_waitQueue.Dequeue();

                        // there is a context waiting on a free object.  we have one.
                        wc._o = o;
                        wc._event.Set();

                        // this object is transferred to the wait context and does not go back into the pool at this time.
                        return true;
                    }
                    catch (InvalidOperationException)
                    {
                        // do nothing.
                    }
                }
                else
                {
                    WaitContext wc = (WaitContext)_waitQueue.Dequeue();

                    if (wc != null)
                    {
                        // there is a context waiting on a free object.  we have one.
                        wc._o = o;
                        wc._event.Set();

                        // this object is transferred to the wait context and does not go back into the pool at this time.
                        return true;
                    }
                }
            }

            // a good place to start.
            int iSlot = _iLastObtained;
            int slotsChecked = 0;
            bool fInserted = false;

            while (slotsChecked < _iSize)
            {
                // is it unlocked?
                if (0 == Interlocked.Exchange(ref _rgItems[iSlot]._iLocked, 1))
                {
                    // now we have this slot locked.
                    
                    // is it empty?
                    if (_rgItems[iSlot]._o == null)
                    {
                        // take it.
                        _rgItems[iSlot]._o = o;
                        fInserted = true;
                    }
                    
                    // unlock the slot either way
                    _rgItems[iSlot]._iLocked = 0;
                }

                // did we find a slot?
                if (fInserted)
                {
                    // do this while unlocked.  the next person to call obtain will find an unlocked slot filled with this item.
                    _iLastInserted = iSlot;

                    // we're done!
                    break;
                }

                // next slot
                iSlot = (iSlot + 1) % _iSize;
                ++slotsChecked;
            }

            if (!fInserted)
            {
                // cycled the pool and found no unlocked free slots.
                if (_fUseExceptions)
                {
                    throw new InvalidOperationException("pool full");
                }
                else
                {
                    return false;
                }
            }

            return true;
        }

        public Object Obtain()
        {
            Object o = null;
            
            // a good place to start.
            int iSlot = _iLastInserted;
            int slotsChecked = 0;

            while (slotsChecked < _iSize)
            {
                // is it unlocked?
                if (0 == Interlocked.Exchange(ref _rgItems[iSlot]._iLocked, 1))
                {
                    // now we have this slot locked.
                    
                    // is it filled?
                    if (_rgItems[iSlot]._o != null)
                    {
                        // empty it.
                        o = _rgItems[iSlot]._o;
                        _rgItems[iSlot]._o = null;
                    }
                    
                    // unlock the slot either way
                    _rgItems[iSlot]._iLocked = 0;
                }

                // did we obtain an item?
                if (o != null)
                {
                    // do this while unlocked.  the next person to call insert will find this unlocked slot that is empty.
                    _iLastObtained = iSlot;

                    // we're done!
                    break;
                }

                // next slot (traverse backwards)
                iSlot = (iSlot +_iSize - 1) % _iSize;
                ++slotsChecked;
            }

            if (o == null)
            {
                if (_waitQueue != null)
                {
                    // cycled the pool and found no unlocked free slots.
                    WaitContext wc = new WaitContext();

                    // put context on the queue and wait for an object to become free                
                    _waitQueue.Enqueue(wc);
                    wc._event.WaitOne();

                    // context now contains the free object.
                    o = wc._o;
                }
                else
                {
                    if (_fUseExceptions)
                    {
                        throw new InvalidOperationException("pool empty");
                    }
                    else
                    {
                        return null;
                    }
                }
            }

            return o;
        }

        private PoolItem[] _rgItems;
        private int _iLastInserted;
        private int _iLastObtained;
        private int _iSize;
        private bool _fUseExceptions;
        private FastQueue _waitQueue;
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\Floken.cs ===
using System;
using System.IO;
using System.Globalization;

namespace xonline.common.service
{
    // -----------------------------------------------------------------------------
    // Flow tokens - used to track a session throughout live. This definition should match   
    // the one in xonline.x for native code.
    //
    // See http://xblwiki/default.aspx/XboxLive/FlowTokenDesignSpec.html.
    // -----------------------------------------------------------------------------
    public struct Floken : IEquatable<Floken>, IEquatable<ulong>
    {
        // If this was an internal header, it should go in XOn.cs. But it isn't, and we don't 
        // have a good central place yet, so it's going here.
        public const string XHTTPHDR_FLOWTOKEN = "X-Floken";

        public static Floken None
        {
            get 
            { 
                Floken f = new Floken();
                f._FlowToken = 0;
                return f;
            }
        }

        // Prevent recursion when SGInfo calls XomTrace and it comes back to us (for 
        // instance). No need to use interlocked functions since this is thread static.
        [ThreadStatic]
        private static int s_currentCallDepth = 0;

        public static Floken Current
        {
            get
            {
                try
                {
                    if (++s_currentCallDepth > 1)
                    {
                        return Floken.None;
                    }

                    // @@@ TODO: implement a more generic, pluggable caching / request 
                    // management system.

                    if (AAInfo.IsCached || AAInfo.IsActiveAuthAvailable)
                    {
                        AAInfo aa = AAInfo.Current;
                        if (aa != null)
                        {
                            return aa.FlowToken;
                        }
                        return Floken.None;
                    }

                    if (SGInfo.IsCached)
                    {
                        return SGInfo.Current.FlowToken;
                    }
                    else if (SGInfo.RetrieveSgInfoForFlowToken && SGInfo.IsAvailable)
                    {
                        // This will force an SGInfo lookup
                        try
                        {
                            return SGInfo.Current.FlowToken;
                        }
                        catch (Exception)
                        {
                            // @@@ Trace? Event? Kinda want to keep Xom out of this  
                            // class...
                            return Floken.None;
                        }
                    }
                    else
                    {
                        return Floken.None;
                    }
                    
                }
                catch (Exception)
                {
                    // @@@ TODO: event, trace, something.
                    return Floken.None;
                }
                finally
                {
                    --s_currentCallDepth;
                }
            }
        }

        // Please try to use the provided accessors and operators instead of this
        public ulong FlowToken
        {
            get { return _FlowToken; }
        }

        public bool IsValid
        {
            get { return _FlowToken != 0; }
        }

        // -----------------------------------------------------------------------------
        // Constructor - deserializes floken from a stream
        // -----------------------------------------------------------------------------
        public Floken(BinaryReader br)
        {
            _FlowToken = br.ReadUInt64();
        }

        // -----------------------------------------------------------------------------
        // Constructor - deserializes floken from a hexadecimal string 
        // -----------------------------------------------------------------------------
        public Floken(String s)
        {
            if (String.IsNullOrEmpty(s))
            {
                _FlowToken = 0;
                return;
            }

            if (s.StartsWith("FT", true, CultureInfo.CurrentCulture))
                s = s.Substring(2);
            else if (s.StartsWith("0x", true, CultureInfo.CurrentCulture))
                s = s.Substring(2);

            try
            {
                _FlowToken = UInt64.Parse(s, NumberStyles.HexNumber);
            }
            catch (FormatException)
            {
                // bad client! bad! we don't want to abort the request with an unhandled 
                // exception, though, so carry on.
                _FlowToken = 0;
            }
        }

        // -----------------------------------------------------------------------------
        // Constructor - from a simple ulong. Try not to use this one, k? Flowtokens are 
        // best represented as a Floken, not a ulong.
        // -----------------------------------------------------------------------------
        public Floken(ulong v)
        {
            _FlowToken = v;
        }

        // -----------------------------------------------------------------------------
        // Generates a new random flow token 
        // -----------------------------------------------------------------------------
        public static Floken NewFloken()
        {
            Floken f = new Floken();
            f._FlowToken = Crypto.GetRandomUInt64();
            return f;
        }

        // -----------------------------------------------------------------------------
        // Write - serialize floken to a stream
        // -----------------------------------------------------------------------------
        public void Write(BinaryWriter bw)
        {
            bw.Write(_FlowToken);
        }

        // -----------------------------------------------------------------------------
        // ToString - the one and only way to display a flow token
        // -----------------------------------------------------------------------------
        public override string ToString()
        {
            if (IsValid)
                return "FT" + _FlowToken.ToString("X016");
            else
                return "FT0";
        }

#region Equality overrides
        // {{{
        public override int GetHashCode()
        {
            return _FlowToken.GetHashCode();
        }

        public bool Equals(Floken other)
        {
            return _FlowToken == other._FlowToken;
        }

        public bool Equals(ulong other)
        {
            return _FlowToken == other;
        }

        public override bool Equals(Object obj)
        {
            if (obj == null) return base.Equals(obj);

            if (!(obj is Floken))
                return false;
            else
                return Equals((Floken)obj);
        }

        public static bool operator ==(Floken floken1, Floken floken2)
        {
            return floken1.Equals(floken2);
        }

        public static bool operator !=(Floken floken1, Floken floken2)
        {
            return (!floken1.Equals(floken2));
        }

        // }}}
#endregion

        private ulong _FlowToken;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\FastFailThreading.cs ===
/* FastFail using the thread throttling approach - Core Implementation
 * ----------------------------------------------------------------------------
 * BRIEF OVERVIEW:
 * The idea here is to cap the number of threads a resource may tie up in your
 * process.  The cap is dynamically adjusted based on its performance by a
 * specifiable throttling adjustment function.
 *
 * FULL OVERVIEW:
 * see: http://xblwiki/default.aspx/XboxLive/FastFailThreadsPerResource.html
 *
 * NPDB Settings:
 *   [system]
 *   fastfail_disableThrottling - indicates of throttle enabled [true/false]
 *   fastfail_bucketCount - bucket count for features - [natural numbers]
 *
 *   [resource configuration]
 *   #prefix#_fastFailMaxThreshold - threshold upper bound :num[%]
 *   #prefix#_fastFailMinThreshold - threshold lower bound : num[%]
 *   #prefix#_fastFailWindow - duration of expiration window (sec) : num[.num]
 *
 * current owner: jojohn
 */

namespace xonline.common.service
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;
    using System.Security.Permissions;
    using System.Threading;

    using xonline.common.mgmt;
    using xonline.common.config;


    public class FastFailResourceConfig
    {
        public static FastFailResourceConfig CreateFromResource(
           FastFailResource resource,
           string prefix,
           bool optional)
        {
            FastFailResourceConfig config;

            config = new FastFailResourceConfig();

            if (!optional && null == prefix)
                throw new ArgumentNullException("prefix");
            if (optional && null == resource)
                throw new ArgumentNullException("resource");
            if (optional && null == resource.Statistics)
                throw new ArgumentException("npdb load optional but resource statistics is null", "resource.Statistics");

            if (null != resource)
            {
                lock (resource)
                {
                    config.ThrottlingSelector = resource.ThrottlingSelector;

                    if (optional)
                    {
                        config.MaximumThreshold = resource.MaximumThreshold;
                        config.MinimumThreshold = resource.MinimumThreshold;
                        config.CaptureTimeWindow = resource.Statistics.CaptureTimeWindow;
                    }
                }
            }

            if (null != prefix)
                config.ReadNpdbSettings(prefix, optional);

            return config;
        }

        public static FastFailResourceConfig CreateFromResource(
           FastFailResource resource)
        {
            return CreateFromResource(resource, null, true);
        }

        private static FastFailResourceConfig CreateFromConfig(
           FastFailResourceConfig target,
           FastFailResourceConfig config,
           string prefix,
           bool optional)
        {
            if (!optional && null == prefix)
                throw new ArgumentException("npdb load required but prefix is null", "prefix");
            if (optional && null == config)
                throw new ArgumentException("npdb load optional but config is null", "resource");

            if (optional)
            {
                target.MaximumThreshold = config.MaximumThreshold;
                target.MinimumThreshold = config.MinimumThreshold;
                target.CaptureTimeWindow = config.CaptureTimeWindow;
                target.ThrottlingSelector = config.ThrottlingSelector;
            }

            if (null != prefix)
                target.ReadNpdbSettings(prefix, optional);

            return target;
        }

        public static FastFailResourceConfig CreateFromConfig(
           FastFailResourceConfig config,
           string prefix,
           bool optional)
        {
            return CreateFromConfig(
               new FastFailResourceConfig(),
               config,
               prefix,
               optional);
        }

        public static FastFailResourceConfig CreateFromConfig(
           FastFailResourceConfig config)
        {
            return CreateFromConfig(config, null, true);
        }

        public FastFailResourceConfig(FastFailResourceConfig config, string prefix, bool optional)
        {
            CreateFromConfig(this, config, prefix, optional);
        }

        public FastFailResourceConfig()
        {
            maximumThreshold = 20;
            minimumThreshold = 20;
            captureTimeWindow = TimeSpan.FromSeconds(30);
            throttlingSelector = new FastFailThrottleSelector();
        }

        private uint GetThreadSetting(string name)
        {
            string Setting = Config.GetSetting(name).Trim();

            if (Setting.EndsWith("%"))
            {
                int Workers, Completion;
                float Percentage;

                System.Threading.ThreadPool.GetMaxThreads(out Workers, out Completion);
                Percentage = float.Parse(Setting.Substring(0, Setting.Length - 1)) / 100.0f;

                return (uint)(Workers * Percentage);
            }
            else
                return uint.Parse(Setting);
        }

        public void ReadNpdbSettings(string prefix, bool allowMissing)
        {
            if (null == prefix)
                throw new ArgumentNullException("prefix");

            try { maximumThreshold = GetThreadSetting(prefix + FastFail.Settings.Setting_ResourceMaxThr); }
            catch (ApplicationException)
            {
                if (!allowMissing)
                    throw;
            }

            try { minimumThreshold = GetThreadSetting(prefix + FastFail.Settings.Setting_ResourceMinThr); }
            catch (ApplicationException)
            {
                if (!allowMissing)
                    throw;
            }

            try { captureTimeWindow = TimeSpan.FromSeconds((uint)Config.GetIntSetting(prefix + FastFail.Settings.Setting_ResourceWindow)); }
            catch (ApplicationException)
            {
                if (!allowMissing)
                    throw;
            }
        }

        #region Properties
        public uint MaximumThreshold
        {
            get { return maximumThreshold; }
            set { maximumThreshold = value; }
        }

        public uint MinimumThreshold
        {
            get { return minimumThreshold; }
            set { minimumThreshold = value; }
        }

        public TimeSpan CaptureTimeWindow
        {
            get { return captureTimeWindow; }
            set { captureTimeWindow = value; }
        }

        public FastFailThrottleSelector ThrottlingSelector
        {
            get { return throttlingSelector; }
            set { throttlingSelector = value; }
        }
        #endregion

        private uint maximumThreshold;
        private uint minimumThreshold;
        private TimeSpan captureTimeWindow;
        private FastFailThrottleSelector throttlingSelector;
    }

    public partial class FastFailResource
    {
        public FastFailResource(string name, FastFailResourceConfig configuration)
        {
            if (null == name)
                throw new ArgumentNullException("name");

            this.name = name.ToLower();
            this.currentThresholdLock = new object();
            this.threadCount = 0;

            this.globalPerformance = FastFailPerformanceCategory.GetPerformanceCategory(this.name);
            if (null != this.globalPerformance)
                this.instancedPerformance = this.globalPerformance[Config.ComponentName];

            Configure(configuration);
        }

        public FastFailResource(string name)
            : this(name, new FastFailResourceConfig()) { }

        #region Exposed Methods
        public void InvalidateThreshold()
        {
            Interlocked.Exchange(ref currentThresholdValid, 0);
        }

        public void IngestEvent(DateTime start, DateTime end, FastFailResult result)
        {
            //Update performance counters
            AdjustEventCounters(start, end, result);

            lock (Statistics.IngestionLock)
            {
                //make sure we are writing to the correct bucket
                Statistics.AdvanceWindow();

                //write to the bucket
                Statistics.AggregatedFeatures.IngestEvent(start, end, result);
            }

            InvalidateThreshold();
        }

        public bool ClaimThread()
        {
            if (Interlocked.Increment(ref threadCount) > CurrentThreshold)
            {
                Interlocked.Decrement(ref threadCount);
                IncrementDenialCounter();
                return false;
            }
            else
            {
                IncrementThreadCounter();
                return true;
            }
        }

        public void ReleaseThread()
        {
            Interlocked.Decrement(ref threadCount);
            DecrementThreadCounter();
        }

        public void Configure(FastFailResourceConfig configuration)
        {
            if (null == configuration)
                throw new ArgumentNullException("configuration");
            if (null == configuration.ThrottlingSelector)
                throw new ArgumentNullException("configuration.ThrottlingSelector");

            // synchronization notes
            lock (this)
            { //only one configuration at a time simultaneously
                lock (currentThresholdLock)
                { //cannot configure and acquire simultaneously
                    object ingestionLock = statistics == null ? null : statistics.IngestionLock;

                    if (null != ingestionLock)
                        Monitor.Enter(ingestionLock); //cannot configure and ingest simultaneously

                    try
                    {
                        maximumThreshold = Math.Max(configuration.MaximumThreshold, configuration.MinimumThreshold);
                        minimumThreshold = Math.Min(configuration.MaximumThreshold, configuration.MinimumThreshold);
                        ThrottlingSelector = configuration.ThrottlingSelector;
                        statistics = new FastFailStatistics(configuration);
                    }
                    finally
                    {
                        if (null != ingestionLock)
                            Monitor.Exit(ingestionLock);
                    }
                }
            }
        }
        #endregion

        #region Private Methods
        private uint CalculateThreshold()
        {
            if (!ThrottlingDisabled)
            {
                float Adjustment;
                int Range;

                Adjustment = ThrottlingSelector.SelectThrottle(Statistics);

                if (float.IsNaN(Adjustment))
                { // invalid operation on NaN LSG:5961
                    throw new InvalidOperationException(
                       string.Format("throttling function {0} returned NaN", ThrottlingSelector.GetType().Name));
                }

                Adjustment = Math.Min(1.0f, Adjustment);
                Adjustment = Math.Max(0.0f, Adjustment);
                Range = (int)MaximumThreshold - (int)MinimumThreshold;

                return (uint)(MinimumThreshold + Range * Adjustment);
            }
            else
                return MaximumThreshold;
        }
        #endregion

        #region Properties
        public string Name
        {
            get { return name; }
        }

        public uint MaximumThreshold
        {
            get { return maximumThreshold; }
        }

        public uint MinimumThreshold
        {
            get { return minimumThreshold; }
        }

        public virtual bool ThrottlingDisabled
        {
            get { return FastFail.Settings.ThrottlingDisabled; }
        }

        public FastFailThrottleSelector ThrottlingSelector
        {
            get { return throttlingSelector; }
            set
            {
                Interlocked.Exchange(ref throttlingSelector, value);
                InvalidateThreshold();
            }
        }

        public FastFailStatistics Statistics
        {
            get { return statistics; }

        }

        public uint ThreadCount
        {
            get { return (uint)threadCount; }
        }

        public uint CurrentThreshold
        {
            get
            {
                uint result = 0;

                lock (currentThresholdLock)
                {
                    if ((0 == Interlocked.Exchange(ref currentThresholdValid, 1)) | statistics.AdvanceWindow())
                        currentThreshold = (int)CalculateThreshold();

                    result = (uint)currentThreshold;
                }

                ChangeUtilizationDenominator(result);

                return result;
            }
        }

        public FastFailPerformanceCategory GlobalPerformance
        {
            get { return globalPerformance; }
        }

        public FastFailPerformanceCategory InstancedPerformance
        {
            get { return instancedPerformance; }
        }
        #endregion

        private string name;
        private uint maximumThreshold;
        private uint minimumThreshold;
        private FastFailThrottleSelector throttlingSelector;
        private FastFailStatistics statistics;
        private int threadCount;
        private int currentThreshold;
        private int currentThresholdValid;
        private object currentThresholdLock;
        private FastFailPerformanceCategory globalPerformance;
        private FastFailPerformanceCategory instancedPerformance;
    }

    public class CriticalFastFailResource : FastFailResource
    {
        public CriticalFastFailResource(string name, FastFailResourceConfig configuration)
            : base(name, configuration) { }

        public CriticalFastFailResource(string name)
            : base(name) { }

        public override bool ThrottlingDisabled
        {
            get { return true; }
        }
    }

    public static class FastFail
    {
        public class FastFailResourceContext
        {
            public FastFailResourceContext(FastFailResource resource)
            {
                if (null == resource)
                    throw new ArgumentNullException("resource");

                _resource = resource;
                _pendingConfigPrefix = null;
            }

            public void InvalidateConfiguration(string prefix)
            {
                Interlocked.Exchange(ref _pendingConfigPrefix, prefix);
            }

            public string GetAndClearConfigPrefix()
            {
                return Interlocked.Exchange(ref _pendingConfigPrefix, null);
            }

            public FastFailResource Resource
            {
                get { return _resource; }
            }

            private FastFailResource _resource;
            private string _pendingConfigPrefix;
        }

        public static class Settings
        {
            public const string Setting_ResourceMaxThr = "_fastFailMaxThreshold";
            public const string Setting_ResourceMinThr = "_fastFailMinThreshold";
            public const string Setting_ResourceWindow = "_fastFailWindow";

            static Settings()
            {
                Config.SettingChange += new SettingChangeEventHandler(SettingChangeEventHandler);
            }

            private static void LoadSettings()
            {
                using (FastFailTracker Npdb = new FastFailTracker(FastFail.NpdbResource))
                {
                    // takes affect immediately
                    try { throttlingDisabled = Config.GetBoolSetting(Setting.fastfail_disableThrottling); }
                    catch (ApplicationException) { }

                    // resources needs to be reconfigured in order for this to take affect
                    try { FastFailFeature.BucketCount = Config.GetUIntSetting(Setting.fastfail_bucketCount); }
                    catch (ApplicationException) { }

                    Npdb.IndicateSuccess();
                }
            }

            private static void InvalidateResourceConfiguration(string resourceName, string prefix)
            {
                if (FastFail.IsResourcePresent(resourceName))
                {
                    FastFailResourceContext context;

                    context = FastFail.GetResourceContext(resourceName);
                    context.InvalidateConfiguration(prefix);
                }
            }

            private static void RegisterSettingListener(string setting, string resourceName, string prefix)
            {
                setting = setting.ToLower();

                if (!SettingMappings.ContainsKey(setting))
                    SettingMappings.Add(setting, new List<KeyValuePair<string, string>>());

                SettingMappings[setting].Add(new KeyValuePair<string, string>(resourceName, prefix));
            }

            public static void RegisterNpdbListener(string resourceName, string prefix)
            {
                if (null == prefix)
                    throw new ArgumentNullException("prefix");
                if (null == resourceName)
                    throw new ArgumentNullException("resourceName");

                if (!ConfiguredResources.ContainsKey(resourceName.ToLower()))
                {
                    ConfiguredResources.Add(resourceName.ToLower(), null);

                    RegisterSettingListener(prefix + Setting_ResourceMaxThr, resourceName, prefix);
                    RegisterSettingListener(prefix + Setting_ResourceMinThr, resourceName, prefix);
                    RegisterSettingListener(prefix + Setting_ResourceWindow, resourceName, prefix);
                }
            }

            private static void SettingChangeEventHandler(object sender, SettingChangeEventArgs args)
            {
                if (args.Setting == Setting.fastfail_bucketCount)
                    LoadSettings();
                else if (SettingMappings.ContainsKey(args.Setting.ToLower()))
                {
                    foreach (KeyValuePair<string, string> item in SettingMappings[args.Setting.ToLower()])
                        InvalidateResourceConfiguration(item.Key, item.Value);
                }
            }

            #region Properties
            public static string ComponentName
            {
                get { return Config.ComponentName; }
            }

            public static bool ThrottlingDisabled
            {
                get
                {
                    if (!throttlingDisabled.HasValue)
                        LoadSettings();

                    return throttlingDisabled.Value;
                }
            }

            private static Dictionary<string, List<KeyValuePair<string, string>>> SettingMappings
            {
                get { return settingMappings ?? (settingMappings = new Dictionary<string, List<KeyValuePair<string, string>>>()); }
            }

            private static Dictionary<string, object> ConfiguredResources
            {
                get { return configuredResources ?? (configuredResources = new Dictionary<string, object>()); }
            }

            private static object SyncObject
            {
                get { return syncObject ?? (syncObject = new object()); }
            }
            #endregion

            private static bool? throttlingDisabled = false;
            private static Dictionary<string, List<KeyValuePair<string, string>>> settingMappings;
            private static Dictionary<string, object> configuredResources;
            private static object syncObject;
        }

        private static readonly CriticalFastFailResource NpdbResource;

        static FastFail()
        {
            // intialize the performance counters (LSG: 6088)
            XomPerformanceCounterCategory.InitPerfCtrs();

            NpdbResource = new CriticalFastFailResource("safenpdb");
        }

        public static void RegisterNpdbListener(string resourceName, string prefix)
        {
            Settings.RegisterNpdbListener(resourceName, prefix);
        }

        public static FastFailResource ConfigureResource(string resourceName, FastFailResourceConfig configuration)
        {
            FastFailResource resource;

            if (null == resourceName)
                throw new ArgumentNullException("resourceName");
            if (null == configuration)
                throw new ArgumentNullException("configuration");

            resourceName = resourceName.ToLower();

            lock (TrackingCache)
            {
                if (TrackingCache.ContainsKey(resourceName))
                {
                    resource = TrackingCache[resourceName].Resource;
                    resource.Configure(configuration);
                }
                else
                {
                    resource = new FastFailResource(resourceName, configuration);
                    TrackingCache.Add(resourceName, new FastFailResourceContext(resource));
                }
            }

            return resource;
        }

        internal static bool IsResourcePresent(string resourceName)
        {
            if (null == resourceName)
                throw new ArgumentNullException("resourceName");

            resourceName = resourceName.ToLower();

            return TrackingCache.ContainsKey(resourceName);
        }

        public static FastFailResourceContext GetResourceContext(string resourceName)
        {
            if (null == resourceName)
                throw new ArgumentNullException("resourceName");

            resourceName = resourceName.ToLower();

            if (TrackingCache.ContainsKey(resourceName))
                return TrackingCache[resourceName];
            else
            {
                Xom.NtEvent(XEvent.Id.FAST_FAIL_MISSING_RESOURCE,
                   "FastFail - " + resourceName + " - " +
                   "resource is not found, may be caused by codebase failure to configure the resource."
                );

                throw new FastFailTrackerMissingException(resourceName);
            }
        }

        public static FastFailResource GetResource(string resourceName)
        {
            FastFailResourceContext context = GetResourceContext(resourceName);

            return context.Resource;
        }

        private static Dictionary<string, FastFailResourceContext> TrackingCache
        {
            get { return trackingCache != null ? trackingCache : trackingCache = new Dictionary<string, FastFailResourceContext>(); }
        }

        private static object SyncBlock
        {
            get { return syncBlock != null ? syncBlock : syncBlock = new object(); }
        }

        private static Dictionary<string, FastFailResourceContext> trackingCache;
        private static object syncBlock;
    }

    public class FastFailTracker : IDisposable
    {
        public FastFailTracker(FastFailResource resource)
        {
            InitializeTracker(resource, null);
        }

        public FastFailTracker(string resourceName)
        {
            FastFail.FastFailResourceContext context;

            context = FastFail.GetResourceContext(resourceName);

            InitializeTracker(
               context.Resource,
               context.GetAndClearConfigPrefix());
        }

        // when a non-null prefix is specified, the resource is configured before claiming a thread
        private void InitializeTracker(FastFailResource resource, string prefix)
        {
            this.result = null;
            this.tracker = resource;

            if (null != prefix)
            {
                resource.Configure(
                   FastFailResourceConfig.CreateFromResource(resource, prefix, true));
            }

            if (!this.tracker.ClaimThread())
                throw new FastFailException(this.tracker.Name);

            this.start = FastFailClock.Clock.Now;
        }

        #region Exposed Methods
        public void IndicateFailure()
        {
            if (result == null || !result.HasValue)
            {
                result = FastFailResult.Failure;
                tracker.IngestEvent(start, FastFailClock.Clock.Now, result.Value);
                tracker.ReleaseThread();
            }
        }

        public void IndicateSuccess()
        {
            if (result == null || !result.HasValue)
            {
                result = FastFailResult.Success;
                tracker.IngestEvent(start, FastFailClock.Clock.Now, result.Value);
                tracker.ReleaseThread();
            }
        }

        public void IndicateTimeout()
        {
            if (result == null || !result.HasValue)
            {
                result = FastFailResult.Timeout;
                tracker.IngestEvent(start, FastFailClock.Clock.Now, result.Value);
                tracker.ReleaseThread();
            }
        }

        public void Dispose()
        {
            IndicateFailure();
        }
        #endregion

        #region Properties
        public FastFailResource Tracker
        {
            get { return tracker; }
        }

        public DateTime StartTime
        {
            get { return this.start; }
        }

        public string ResourceName
        {
            get { return tracker.Name; }
        }
        #endregion

        private FastFailResource tracker;
        private DateTime start;
        private FastFailResult? result;
    }

    public class FastFailThrottleSelector
    {
        public FastFailThrottleSelector(float throttle)
        {
            this.throttle = throttle;
        }

        public FastFailThrottleSelector()
            : this(1.0f) { }

        public virtual float SelectThrottle(FastFailStatistics statistics)
        {
            return throttle;
        }

        private float throttle;
    }

    public class FastFailSquareThrottleSelector : FastFailThrottleSelector
    {
        public FastFailSquareThrottleSelector() : this(0.5f) { }
        public FastFailSquareThrottleSelector(float tolerance)
        {
            Tolerance = tolerance;
        }

        public override float SelectThrottle(FastFailStatistics statistics)
        {
            if (statistics.AggregatedFeatures.TimeoutRatio > tolerance)
                return 0.0f;

            return 1.0f;
        }

        public float Tolerance
        {
            get { return tolerance; }
            set
            {
                if (tolerance > 1 || tolerance < 0)
                    throw new ArgumentOutOfRangeException("value", tolerance, "range must be in [0, 1]");
                tolerance = value;
            }
        }

        private float tolerance;
    }

    [Serializable]
    public class BaseFastFailException : Exception
    {
        public BaseFastFailException() : base("") { }
        public BaseFastFailException(string resourceName) : this(resourceName, "") { }
        public BaseFastFailException(string resourceName, string message) : this(resourceName, message, null) { }
        public BaseFastFailException(string resourceName, string message, Exception inner)
            : base(message, inner)
        {
            this.resourceName = resourceName;
        }
        protected BaseFastFailException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
            resourceName = info.GetString("resourceName");
        }

        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
            info.AddValue("resourceName", resourceName);
        }

        public string ResourceName
        {
            get { return resourceName; }
        }

        protected virtual string DefaultMessage
        {
            get { return string.Format("Encountered error for resource '{0}'.", resourceName ?? "(unnamed)"); }
        }

        public override string Message
        {
            get
            {
                string BaseMessage = base.Message;

                if (string.IsNullOrEmpty(BaseMessage))
                    BaseMessage = DefaultMessage;

                return BaseMessage;
            }
        }

        private string resourceName;
    }

    [Serializable]
    public class FastFailException : BaseFastFailException
    {
        public FastFailException() : base("") { }
        public FastFailException(string resourceName) : this(resourceName, "") { }
        public FastFailException(string resourceName, string message) : this(resourceName, message, null) { }
        public FastFailException(string resourceName, string message, Exception inner) : base(resourceName, message, inner) { }

        protected FastFailException(SerializationInfo info, StreamingContext context)
            : base(info, context) { }

        protected override string DefaultMessage
        {
            get { return string.Format("Resource '{0}' has reached its thread threshold.", ResourceName ?? "(unnamed)"); }
        }
    }

    [Serializable]
    public class FastFailTrackerMissingException : BaseFastFailException
    {
        public FastFailTrackerMissingException() : base("") { }
        public FastFailTrackerMissingException(string resourceName) : this(resourceName, "") { }
        public FastFailTrackerMissingException(string resourceName, string message) : this(resourceName, message, null) { }
        public FastFailTrackerMissingException(string resourceName, string message, Exception inner) : base(resourceName, message, inner) { }

        protected FastFailTrackerMissingException(SerializationInfo info, StreamingContext context)
            : base(info, context) { }

        protected override string DefaultMessage
        {
            get { return string.Format("Configuration not performed for resource '{0}'.", ResourceName ?? "(unnamed)"); }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\FastThreadPool.cs ===
// VxFastThreadPool.cs
//
// Copyright (c) 2010 Microsoft Corporation. All Rights Reserved.
//
// A fast, low-overhead thread pool for all your needs. Spins up threads faster than 
// .Net's ThreadPool class. Uses no locks. Minimizes context switches if you are willing 
// to tolerate some latency. Queue size can be capped. Your callback method is expected to 
// catch all exceptions.
// 
// Author: mattchil (original FastThreadPool)
// Author: kgoodier 7/2010 (adapted from the new XCache FastThreadPool)
//

using System;
using System.Threading;
using System.Diagnostics;
using System.Collections.Generic;

using xonline.common.mgmt;

namespace xonline.common.service
{

    public interface IThreadPool
    {
        bool QueueUserWorkItem(WaitCallback callback, object o);
    }

    public class DotNetThreadPool : IThreadPool
    {
        public static DotNetThreadPool Default = new DotNetThreadPool();

        public bool QueueUserWorkItem(WaitCallback callback, object o)
        {
            return ThreadPool.QueueUserWorkItem(callback, o);
        }
    }

    public class FastThreadPool : IThreadPool
    {
        public FastThreadPool(string instanceName, int poolSize, ThreadPriority priority)
            : this(instanceName, poolSize, poolSize, priority, 0, 0)
        {
        }

        public FastThreadPool(string instanceName, int poolSize, int maxPoolSize, ThreadPriority priority)
            : this (instanceName, poolSize, maxPoolSize, priority, 0, 0)
        {
        }

        public FastThreadPool(string instanceName, int poolSize, int maxPoolSize, ThreadPriority priority, int maxLatencyMs, int maxWorkItemQueueSize)
        {
            // Note: set maxLatencyMs to 0 to disable this feature, and return to "enqueue 
            // item and wake up a thread" model. set maxWorkItemQueueSize to 0 (or maxint) 
            // to allow unbounded growth.

            _counters = FastThreadPoolCounters.Total[instanceName];
            _queueWorkItems = new LockFreeQueue<WorkItem>();
            _event = new AutoResetEvent(false);
            _fAlive = true;
            _priority = priority;

            _numWaitingThreads = 0;
            _numAwakenings = 0;
            _numItemsProcessed = 0;

            // Use properties for setting these things
            MaxThreadCount = maxPoolSize;

            // This will create the threads
            _listThreads = new List<XboxLiveThread>(poolSize);
            ThreadCount = poolSize;

            // This will apply some safety checks
            MaxQueueCount = maxWorkItemQueueSize;

            // This will configure the timer as well
            MaxLatencyMs = maxLatencyMs;
        }

        // 
        // Read/write properties
        //

        public int MaxThreadCount
        {
            get { return _maxPoolSize; }
            set { _maxPoolSize = value; }
        }

        public int ThreadCount
        {
            get 
            { 
                return _listThreads.Count; 
            }
            set 
            {
                // Can't shrink, sorry.
                Grow(value - _listThreads.Count);
            }
        }

        public int MaxLatencyMs
        {
            get 
            { 
                return _maxLatencyMs; 
            }
            set 
            { 
                _maxLatencyMs = value; 
                ConfigureTimer();
            }
        }

        public int MaxQueueCount
        {
            get 
            { 
                return _maxWorkItemQueueSize; 
            }
            set 
            { 
                _maxWorkItemQueueSize = value > 0 ? value : int.MaxValue;
            }
        }

        //
        // Read-only properties
        //

        public int QueueCount
        {
            get { return _queueWorkItems.Count; }
        }

        public int ThreadsWaiting
        {
            get { return _numWaitingThreads; }
        }

        public long NumberOfAwakenings
        {
            get { return _numAwakenings; }
        }

        public long NumberOfItemsProcessed
        {
            get { return _numItemsProcessed; }
        }

        //
        // Public methods
        //

        public bool Grow(int threadCount)
        {
            for (int i = 0; i < threadCount; i++)
            {
                if (!AddThread())
                {
                    return false;
                }
            }
            return true;
        }

        public void Shutdown()
        {
            _fAlive = false;

            for (int iThread = 0; iThread < _listThreads.Count; iThread++)
            {
                _event.Set();
            }
            
            for (int iThread = 0; iThread < _listThreads.Count; iThread++)
            {
                _listThreads[iThread].Interrupt(); // not perfect, Abort() may be better (but meaner)
                _listThreads[iThread].Join();
            }
        }
        
        public bool QueueUserWorkItem(WaitCallback callback, object o)
        {
            if (_queueWorkItems.Count >= _maxWorkItemQueueSize)
            {
                return false;
            }

            WorkItem workItem = new WorkItem(callback, o);

            _queueWorkItems.Enqueue(workItem);
            _counters.QueueLength.Increment();
            if (_maxLatencyMs <= 0)
            {
                _event.Set();
            }
            
            return true;
        }

        // 
        // Private methods
        //

        private void ConfigureTimer()
        {
            if (_maxLatencyMs > 0)
            {
                // Start or change timer
                if (_freshnessTimer == null)
                {
                    _freshnessTimer = new Timer(
                        new TimerCallback(FreshnessCallback),
                        null,
                        _maxLatencyMs,
                        _maxLatencyMs);
                }
                else
                {
                    _freshnessTimer.Change(_maxLatencyMs, _maxLatencyMs);
                }
            }
            else
            {
                // Stop timer
                if (_freshnessTimer != null)
                {
                    _freshnessTimer.Dispose();
                    _freshnessTimer = null;
                }
            }
        }

        private void FreshnessCallback(object state)
        {
            try
            {
                if (_queueWorkItems.Count > 0)
                {
                    _event.Set();
                }
            }
            catch (Exception)
            {
                // Really shouldn't fail, but just in case we don't want this to go
                // unhandled.
            }
        }

        private bool AddThread()
        {
            if (_listThreads.Count >= _maxPoolSize)
            {
                return false;
            }

            XboxLiveThread thread;
            thread = new XboxLiveThread(new ThreadStart(ThreadProc));
            thread.Priority = _priority;
            thread.Start();
            _listThreads.Add(thread);
            return true;
        }


        private class WorkItem
        {
            public WorkItem(WaitCallback callback, object o)
            {
                _callback = callback;
                _o = o;
                _elapsed = new XomRequestTimeElapsed();
            }
            
            public WaitCallback _callback;
            public object _o;
            public XomRequestTimeElapsed _elapsed;
        }
        
        private void ThreadProc()
        {
            while (_fAlive)
            {
                try
                {
                    WorkItem item = null;
                    long processCount = 0;

                    _counters.ThreadsActive.Increment();
                    while (_queueWorkItems.TryDequeue(out item))
                    {
                        processCount++;

                        _counters.QueueLength.Decrement();
                        _counters.WaitTimeAvg.IncrementBy(item._elapsed.MillisecondsElapsed);
                        _counters.WaitTimeAvgBase.Increment();
                        try
                        {
                            item._callback(item._o);
                        }
                        catch (Exception)
                        {
                            // this should never happen.  the callback is expected to catch 
                            // all exceptions.  we're going to swallow it to avoid xmgmt and 
                            // events.
                        }
                        _counters.CompletionRate.Increment();
                    }

                    Interlocked.Increment(ref _numAwakenings);
                    Interlocked.Add(ref _numItemsProcessed, processCount);

                    // nothing on the queue.  go to sleep.
                    Interlocked.Increment(ref _numWaitingThreads);
                    _counters.ThreadsActive.Decrement();
                    _counters.ThreadsIdle.Increment();
                    try
                    {
                        _event.WaitOne();
                    }
                    catch (Exception e)
                    {
                        if (!(e is ThreadInterruptedException))
                        {
                            Xom.NtEvent(XEvent.Id.THREADPOOL_THREAD_EXCEPTION, e, "FastThreadPool::ThreadProc() threw an exception.");
                        }
                    }
                    finally
                    {
                        _counters.ThreadsIdle.Decrement();
                        Interlocked.Decrement(ref _numWaitingThreads);
                    }
                }
                catch (ThreadAbortException)
                {
                }
                catch (ThreadInterruptedException)
                {
                }
                // We use XboxLiveThreads, which will catch and log unhandled exceptions.  Let 
                // it go so we don't have to have an event defined here or take an xmgmt 
                // dependency.
            }
        }

        private List<XboxLiveThread> _listThreads;
        private LockFreeQueue<WorkItem> _queueWorkItems;
        private AutoResetEvent _event;
        private int _maxPoolSize;
        private int _maxLatencyMs;
        private  ThreadPriority _priority;
        private int _maxWorkItemQueueSize;
        private bool _fAlive;
        private Timer _freshnessTimer;
        private FastThreadPoolCounters _counters;

        private int _numWaitingThreads;
        private long _numAwakenings;
        private long _numItemsProcessed;
    }

    [XomPerformanceCounterCategoryAttr( "FastThreadPool", "XBox Live Thread Pool" )]
    public class FastThreadPoolCounters : XomPerformanceCounterCategory
    {
        public FastThreadPoolCounters() : base(true)
        {
        }
        
        public virtual FastThreadPoolCounters this[string instanceName]
        {
            get
            {
                return (FastThreadPoolCounters) GetInstance(instanceName);
            }
        }

        static public FastThreadPoolCounters Total = new FastThreadPoolCounters();
        
        [XomPerformanceCounterAttr(
            "Completion Rate", 
            "Total number of all contexts per second processed by the threadpool.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CompletionRate;

        [XomPerformanceCounterAttr(
            "Threads Active", 
            "Total number of threads in use.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter ThreadsActive;
        
        [XomPerformanceCounterAttr(
            "Threads Idle", 
            "Total number of threads idle.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter ThreadsIdle;

        [XomPerformanceCounterAttr(
            "Queue Length", 
            "Total number of work items waiting to be started.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter QueueLength;

        [XomPerformanceCounterAttr(
            "Context Wait Time (ms)", 
            "Average time (in milliseconds) a context waits to be processed.", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter WaitTimeAvg;
        
        [XomPerformanceCounterAttr(
            "Average Wait Time Base", 
            "Average time (in milliseconds) a context waits to be processed.", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter WaitTimeAvgBase;

    }    

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\HResultAttributes.cs ===
﻿// 
// HResultAttributes.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Attributes that get applied to the HResult struct when
// used from XblCore.dll.
//

using System;
using System.Xml;
using System.Runtime.InteropServices;
using System.Xml.Serialization;

namespace xonline.common.service
{
    /// <summary>
    /// You may be asking yourself why we are doing this?  Well...
    /// The reason is that we want to be able to use the HResult class
    /// by itself without pulling in the rest of the Xbox Live world.
    /// Specifically, the WireInfoAttribute class references Config.
    /// 
    /// This was done originally for Azure Hosted Services that use
    /// XblSamlToken (and HResult by reference), but separating this
    /// out may have other applications in the future.
    /// </summary>
    [ComVisible(false)]
    [XmlSchemaProvider("HResultSchema")]
    [WireInfo(SerializeAs = typeof(uint))]
    public partial struct HResult : IEquatable<HResult>, IXmlSerializable
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\LockFreeStack.cs ===
using System.Threading;

// Suppressing the warning for volatile being used as ref because it is in the allowed situation of being
// used for the Interlocked class.  See http://msdn.microsoft.com/en-us/library/4bw5ewxy.aspx (Compiler Warning CS0420)
#pragma warning disable 420

// Lock free stack implementation.  This implementation only works as managed code, as it relies on the GC memory allocator semantics
//   of not reusing a memory address for an object until it is no longer referenced by any running code.  To understand why
//   this is necessary, perform a search on The ABA problem to see the inherent issues around lock free data structures.  
//   In native implemenations, the recommendation is to use the InterlockedXXSList functions, as they implement the right 
//   lock free semantics in native code.
namespace xonline.common.service
{
    public sealed class LockFreeStack<T>
    {
        volatile Entry _listHead;

        public T Pop()
        {
            Entry head;

            do
            {
                head = _listHead;
                if (head == null)
                {
                    return default(T);
                }
            } while (head != Interlocked.CompareExchange(ref _listHead, head.Next, head));

            return head.Member;
        }

        public void Push(T o)
        {
            Entry head;
            Entry newHead = new Entry(o);

            do
            {
                head = _listHead;
                newHead.Next = head;
            } while (head != Interlocked.CompareExchange(ref _listHead, newHead, head));
        }

        public bool IsEmpty
        {
            get { return _listHead == null; }
        }

        class Entry
        {
            T _member;
            Entry _next;

            public Entry(T o)
            {
                _member = o;
            }

            public T Member
            { get { return _member; } }

            public Entry Next
            {
                get { return _next; }
                set { _next = value; }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\LSAUtil.cs ===
using System;
using System.Runtime.InteropServices;
using System.Text;


namespace xonline.common.service
{
    [ComVisible(false)]
    public class LSAUtil
    {
        private static string szLogonService = "SeServiceLogonRight";

        // Import the LSA functions

        [DllImport("advapi32.dll", PreserveSig = true)]
        private static extern UInt32 LsaOpenPolicy(
            ref LSA_UNICODE_STRING SystemName,
            ref LSA_OBJECT_ATTRIBUTES ObjectAttributes,
            Int32 DesiredAccess,
            out IntPtr PolicyHandle
        );

        [DllImport("advapi32.dll", SetLastError = true, PreserveSig = true)]
        private static extern long LsaAddAccountRights(
            IntPtr PolicyHandle,
            IntPtr AccountSid,
            LSA_UNICODE_STRING[] UserRights,
            long CountOfRights);

        [DllImport("advapi32")]
        public static extern void FreeSid(IntPtr pSid);

        [DllImport("advapi32.dll", SetLastError = true, PreserveSig = true, BestFitMapping = false, ThrowOnUnmappableChar = true)]
        private static extern bool LookupAccountName(
            [MarshalAs(UnmanagedType.LPStr)] string lpSystemName,
            [MarshalAs(UnmanagedType.LPStr)] string lpAccountName,
            IntPtr psid,
            ref int cbsid,
            [MarshalAs(UnmanagedType.LPStr)] StringBuilder domainName,
            ref int cbdomainLength,
            ref int use);

        [DllImport("advapi32.dll")]
        private static extern bool IsValidSid(IntPtr pSid);

        [DllImport("advapi32.dll")]
        private static extern long LsaClose(IntPtr ObjectHandle);

        [DllImport("kernel32.dll")]
        private static extern int GetLastError();

        [DllImport("advapi32.dll")]
        private static extern long LsaNtStatusToWinError(long status);

        // define the structures

        [StructLayout(LayoutKind.Sequential)]
        private struct LSA_UNICODE_STRING
        {
            public UInt16 Length;
            public UInt16 MaximumLength;
            public IntPtr Buffer;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct LSA_OBJECT_ATTRIBUTES
        {
            public int Length;
            public IntPtr RootDirectory;
            public LSA_UNICODE_STRING ObjectName;
            public UInt32 Attributes;
            public IntPtr SecurityDescriptor;
            public IntPtr SecurityQualityOfService;
        }

        // enum all policies

        private enum LSAAccessPolicy : long
        {
            POLICY_VIEW_LOCAL_INFORMATION = 0x00000001L,
            POLICY_VIEW_AUDIT_INFORMATION = 0x00000002L,
            POLICY_GET_PRIVATE_INFORMATION = 0x00000004L,
            POLICY_TRUST_ADMIN = 0x00000008L,
            POLICY_CREATE_ACCOUNT = 0x00000010L,
            POLICY_CREATE_SECRET = 0x00000020L,
            POLICY_CREATE_PRIVILEGE = 0x00000040L,
            POLICY_SET_DEFAULT_QUOTA_LIMITS = 0x00000080L,
            POLICY_SET_AUDIT_REQUIREMENTS = 0x00000100L,
            POLICY_AUDIT_LOG_ADMIN = 0x00000200L,
            POLICY_SERVER_ADMIN = 0x00000400L,
            POLICY_LOOKUP_NAMES = 0x00000800L,
            POLICY_NOTIFICATION = 0x00001000L
        }

        public static long GrantLogonRights(string szAccount)
        {
            IntPtr sid = IntPtr.Zero;
            int iSidSize = 0;

            IntPtr hPolicy = IntPtr.Zero;

            StringBuilder szDomainName = new StringBuilder();
            int iDomainNameSize = 0;
            int iAccountType = 0;

            bool fResult;
            long lErr = 0;
            uint dwLsaRet = 0;
            long lResult = 0;

            LookupAccountName(string.Empty, szAccount, sid, ref iSidSize, szDomainName, ref iDomainNameSize, ref iAccountType);
            szDomainName = new StringBuilder(iDomainNameSize);
            sid = Marshal.AllocHGlobal(iSidSize);

            fResult = LookupAccountName(string.Empty, szAccount, sid, ref iSidSize, szDomainName, ref iDomainNameSize, ref iAccountType);

            if (!fResult)
            {
                lErr = GetLastError();
                goto lDone;
            }

            LSA_UNICODE_STRING szSystemName = new LSA_UNICODE_STRING();
            LSA_OBJECT_ATTRIBUTES oObjectAttributes = new LSA_OBJECT_ATTRIBUTES();
            oObjectAttributes.Length = 0;
            oObjectAttributes.RootDirectory = IntPtr.Zero;
            oObjectAttributes.Attributes = 0;
            oObjectAttributes.SecurityDescriptor = IntPtr.Zero;
            oObjectAttributes.SecurityQualityOfService = IntPtr.Zero;

            int iAccess = (int)(
                LSAAccessPolicy.POLICY_AUDIT_LOG_ADMIN |
                LSAAccessPolicy.POLICY_CREATE_ACCOUNT |
                LSAAccessPolicy.POLICY_CREATE_PRIVILEGE |
                LSAAccessPolicy.POLICY_CREATE_SECRET |
                LSAAccessPolicy.POLICY_GET_PRIVATE_INFORMATION |
                LSAAccessPolicy.POLICY_LOOKUP_NAMES |
                LSAAccessPolicy.POLICY_NOTIFICATION |
                LSAAccessPolicy.POLICY_SERVER_ADMIN |
                LSAAccessPolicy.POLICY_SET_AUDIT_REQUIREMENTS |
                LSAAccessPolicy.POLICY_SET_DEFAULT_QUOTA_LIMITS |
                LSAAccessPolicy.POLICY_TRUST_ADMIN |
                LSAAccessPolicy.POLICY_VIEW_AUDIT_INFORMATION |
                LSAAccessPolicy.POLICY_VIEW_LOCAL_INFORMATION
                );

            dwLsaRet = LsaOpenPolicy(ref szSystemName, ref oObjectAttributes, iAccess, out hPolicy);
            lErr = LsaNtStatusToWinError(dwLsaRet);

            if (0 != lErr)
            {
                goto lDone;
            }

            LSA_UNICODE_STRING[] szUserRights = new LSA_UNICODE_STRING[1];
            szUserRights[0] = new LSA_UNICODE_STRING();
            szUserRights[0].Buffer = Marshal.StringToHGlobalUni(szLogonService);
            szUserRights[0].Length = (UInt16)(szLogonService.Length * UnicodeEncoding.CharSize);
            szUserRights[0].MaximumLength = (UInt16)((szLogonService.Length + 1) * UnicodeEncoding.CharSize);

            lResult = LsaAddAccountRights(hPolicy, sid, szUserRights, 1);
            lErr = LsaNtStatusToWinError(dwLsaRet);

            if (0 != lErr)
            {
                goto lDone;
            }

        lDone:

            if (IntPtr.Zero != hPolicy)
            {
                LsaClose(hPolicy);
            }

            if (IntPtr.Zero != sid)
            {
                FreeSid(sid);
            }

            return lErr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\LockFreeQueue.cs ===
using System;
using System.Threading;

// Suppressing the warning for volatile being used as ref because it is in the allowed situation of being
// used for the Interlocked class.  See http://msdn.microsoft.com/en-us/library/4bw5ewxy.aspx (Compiler Warning CS0420)
#pragma warning disable 420

// Lock free queue implementation.  This implementation only works as managed code, as it relies on the GC memory allocator semantics
//   of not reusing a memory address for an object until it is no longer referenced by any running code.  To understand why
//   this is necessary, perform a search on The ABA problem to see the inherent issues around lock free data structures.  
//   In native implemenations, the recommendation is to use the InterlockedXXSList functions, as they implement the right 
//   lock free semantics in native code.
namespace xonline.common.service
{
    public sealed class LockFreeQueue<T>
    {
        volatile Entry _head;
        volatile Entry _tail;
        bool _fUseExceptions;
        int _count;
        
        public LockFreeQueue() : this(true)
        {
        }
        public LockFreeQueue(bool fUseExceptions)
        {
            _head = new Entry();
            _tail = _head;
            _fUseExceptions = fUseExceptions;
            _count = 0;
        }

        public void Enqueue(T item)
        {
            Entry newNode = new Entry();
            newNode.Member = item;

            while (true)
            {
                Entry oldTail = _tail;
                Entry oldTailNext = oldTail.Next;

                if (_tail == oldTail)
                {
                    if (oldTailNext == null)
                    {
                        if (oldTailNext == Interlocked.CompareExchange(ref oldTail.Next, newNode, oldTailNext))
                        {
                            Interlocked.CompareExchange(ref _tail, newNode, oldTail);
                            Interlocked.Increment(ref _count);
                            return;
                        }
                    }
                    else
                    {
                        Interlocked.CompareExchange(ref _tail, oldTailNext, oldTail);
                    }
                }
            }
        }

        public bool TryDequeue(out T item)
        {
            while (true)
            {
                Entry oldHead = _head;
                Entry oldTail = _tail;
                Entry oldHeadNext = oldHead.Next;

                if (oldHead == _head)
                {
                    if (oldHead == oldTail)
                    {
                        if (oldHeadNext == null)
                        {
                            item = default(T);
                            return false;
                        }
                        
                        Interlocked.CompareExchange(ref _tail, oldHeadNext, oldTail);
                    }
                    else
                    {
                        item = oldHeadNext.Member;
                        if (oldHead == Interlocked.CompareExchange(ref _head, oldHeadNext, oldHead))
                        {
                            Interlocked.Decrement(ref _count);
                            return true;
                        }
                    }
                }
            }
        }

        public T Dequeue()
        {
            T result;
            
            bool fFound = TryDequeue(out result);
            
            if (_fUseExceptions && !fFound)
            {
                throw new InvalidOperationException("queue empty.");
            }
            
            return result;
        }

        public int Count
        {
            get { return _count; }
        }
        
        class Entry
        {
            public T Member;
            public volatile Entry Next;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\HttpContextAdapter.cs ===
// 
// HttpContextAdapter.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Provides a wrapper around either an IIS HttpContext or an HttpListener 
// HttpListenerContext.
// 
// Author: kgoodier 5/2010
//

using System;
using System.IO;
using System.Text;
using System.Web;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Xml;
using System.Xml.Serialization;
using System.Net;
using System.Security.Principal;

// WCF
using System.ServiceModel;
using System.ServiceModel.Channels;


namespace xonline.common.service
{

// --------------------------------------------------------------------------------------
// HttpContextAdapter
//
// Provides a common interface in front of HttpContext and HttpListenerContext objects.  
// This is the bare set of what we need at the moment; please add more as needed.
// --------------------------------------------------------------------------------------
public class HttpContextAdapter : IDisposable
{
    public IHttpRequestAdapter      Request { get; private set; }
    public IHttpResponseAdapter     Response { get; private set; }
    public IDictionary              Items { get; private set; }
    private object                  OriginalContext { get; set; }

    public HttpContextAdapter(HttpContext iisCtx)
    {
        OriginalContext = iisCtx;
        Request = new IisRequestAdapter(iisCtx);
        Response = new IisResponseAdapter(iisCtx);
        Items = iisCtx.Items;
        Current = this;
    }

    public HttpContextAdapter(HttpListenerContext hlCtx)
    {
        OriginalContext = hlCtx;
        Request = new HttpListenerRequestAdapter(hlCtx);
        Response = new HttpListenerResponseAdapter(hlCtx);
        Items = new Hashtable();
        Current = this;
    }

    public HttpContextAdapter(OperationContext opCtx)
    {
        // Note the Wcf adapters are not fully implemented, in particular the Response 
        // interface. We're mostly using it as a bridge to the http headers and remote 
        // endpoint.
        OriginalContext = opCtx;
        Request = new WcfRequestAdapter(opCtx);
        Response = new WcfResponseAdapter(opCtx);
        Items = new Hashtable();
        Current = this;
    }

    public void Dispose()
    {
        Request.Dispose();
        Response.Dispose();
        Request = null;
        Response = null;
        Items = null;
        OriginalContext = null;

        if (_Current == this)
        {
            _Current = null;
        }
    }

    [ThreadStatic]
    private static HttpContextAdapter _Current;

    /// <summary>
    /// Get the current HttpContextAdapter automatically if you are using ASP.Net or
    /// WCF. Does not work for HttpListener.
    /// </summary>
    public static HttpContextAdapter Current
    {
        get
        {
            if (HttpContext.Current != null)
            {
                if (_Current == null || HttpContext.Current != _Current.OriginalContext)
                {
                    _Current = new HttpContextAdapter(HttpContext.Current);
                }
            }
            else if (OperationContext.Current != null)
            {
                if (_Current == null || OperationContext.Current != _Current.OriginalContext)
                {
                    _Current = new HttpContextAdapter(OperationContext.Current);
                }
            }
            return _Current;
        }
        set
        {
            _Current = value;
        }
    }

    // @@@ TODO: add a Current property that is thread static, and is reset upon the start
    // and end of every request. Tricky.

    #region Interfaces

    // {{{ Interfaces 

// --------------------------------------------------------------------------------------
// IHttpRequestAdapter
//
// Provides a common interface in front of HttpRequest and HttpListenerRequest objects.  
// --------------------------------------------------------------------------------------
public interface IHttpRequestAdapter : IDisposable
{
    Uri                 Url { get; }
    string              HttpMethod { get; }
    long                ContentLength { get; }
    IPEndPoint          LocalEP { get; }
    IPEndPoint          RemoteEP { get; }
    NameValueCollection Headers { get; }
    NameValueCollection QueryString { get; }

    Stream              InputStream { get; }
}

// --------------------------------------------------------------------------------------
// IHttpResponseAdapter
//
// Provides a common interface in front of HttpResponse and HttpListenerResponse objects.  
// --------------------------------------------------------------------------------------
public interface IHttpResponseAdapter : IDisposable
{
    // Response
    int                 StatusCode { get; set; }
    string              ContentType { get; set; }
    TextWriter          Output { get; }

    void BinaryWrite(byte[] data);

}

// interfaces }}}

    #endregion

    #region IIS Request/Response Adapters
// {{{ IIS Request / Response adapters

// --------------------------------------------------------------------------------------
// IisRequestAdapter
// --------------------------------------------------------------------------------------
private class IisRequestAdapter : IHttpRequestAdapter
{
    private HttpRequest _req;

    public IisRequestAdapter(HttpContext ctx)
    {
        _req = ctx.Request;
    }

    public void Dispose()
    {
        // nothing to do
    }

    public Uri Url 
    { 
        get 
        {
            return _req.Url;
        }
    }

    public string HttpMethod 
    { 
        get
        {
            return _req.HttpMethod;
        }
    }

    public long ContentLength 
    { 
        get
        {
            return (long)_req.ContentLength;
        }
    }

    public IPEndPoint LocalEP 
    { 
        get
        {
            int localPort;

            // Helper from xrlscan
            string serverPort = _req.Headers[XHttpHdr.SERVERPORT];
            if (serverPort != null)
            {
                // Strangely, while the REMOTE_PORT server variable returns the port in network
                // order, so we have to byte swap it, the SERVER_PORT server variable returns
                // the port in host order, so no byte swap is required. Very confusing.
                localPort = (int)Convert.ToUInt16(serverPort);
            }
            else
            {
                localPort = (int)(_req.Url.Port);
            }

            // kgoodier: I cannot find a way to get the local IP in IIS/ASP.NET. That's 
            // ok, since our code only ever needs the local port anyway.  
            //
            // _req.ServerVariables["SERVER_NAME"]
            // - returns "The server's host name, DNS alias, or IP address as it would 
            // appear in self-referencing URLs."
            return new IPEndPoint(IPAddress.Loopback, localPort);
        }
    }

    public IPEndPoint RemoteEP 
    { 
        get
        {
            IPAddress srcIP;
            int srcPort;
            string sgIPPort = _req.Headers[XHttpHdr.SGIPPORT];
            if (sgIPPort != null)
            {
                // Header added by xrlscan/udpadapter
                int colon = sgIPPort.IndexOf(':');
                if (colon > -1)
                {
                    srcIP = IPAddress.Parse(sgIPPort.Substring(0,colon));
                    srcPort = (int)Convert.ToUInt16(sgIPPort.Substring(colon + 1));
                    return new IPEndPoint(srcIP, srcPort);
                }
            }
            srcIP = IPAddress.Parse(_req.UserHostAddress);
            srcPort = (int)Convert.ToUInt16(_req.ServerVariables.Get("REMOTE_PORT"));
            return new IPEndPoint(srcIP, srcPort);
        }
    }

    public NameValueCollection Headers 
    { 
        get
        {
            return _req.Headers;
        }
    }

    public NameValueCollection QueryString
    {
        get 
        {
            return _req.QueryString;
        }
    }

    public Stream InputStream 
    { 
        get
        {
            return _req.InputStream;
        }
    }

}

// --------------------------------------------------------------------------------------
// IisResponseAdapter
// --------------------------------------------------------------------------------------
private class IisResponseAdapter : IHttpResponseAdapter
{
    private HttpResponse _resp;

    public IisResponseAdapter(HttpContext ctx)
    {
        _resp = ctx.Response;
    }

    public void Dispose()
    {
        // nothing to do
    }

    public int StatusCode
    {
        get { return _resp.StatusCode; }
        set { _resp.StatusCode = value; }
    }

    public string ContentType
    {
        get { return _resp.ContentType; }
        set { _resp.ContentType = value; }
    }

    public TextWriter Output
    {
        get { return _resp.Output; }
    }

    public void BinaryWrite(byte[] data)
    {
        if (data != null)
        {
            // We want to avoid the use of _resp.BinaryWrite since that isn't 
            // allowed by .Net for local instances of HttpContext (i.e., ones constructed 
            // by the tests). So we'll work around it by converting our bytes to UTF8 
            // characters and writing those.
            
            int count = data.Length;
            char[] charData = new char[count];
            MemoryStream ms = new MemoryStream(data, 0, count);
            StreamReader sr = new StreamReader(ms, Encoding.UTF8, true);

            // Read all characters at once. Not ideal, but our stylesheets won't ever be 
            // *that* large. Some notes from Ian:
            //
            // note that according to 
            // http://msdn.microsoft.com/en-us/library/9kstw824(VS.80).aspx there is room 
            // for a performance improvement here by:
            //  1. specifying the size of the internal buffer in the Streamreader 
            //  constructor to some desired block size
            //  2. locking the output charData array to the same size as that internal 
            //  buffer and 
            //  3. repeatedly reading slightly fewer characters than will fit into that 
            //  destination array and writing the data to the response stream in multiple 
            //  passes until all the characters have been read from the StreamReader

            // read out up to count chars (the number of chars cannot exceed count since 
            // chars are at least 1 byte each)
            int charsRead = sr.Read(charData, 0, count);

            // write the retrieved chars out to the resopnse stream, using the real number 
            // of chars found in the UTF-8 stream rather than the number of bytes passed 
            // in initially. This avoid use of the HttpResponse.OutputStream (instead uses 
            // the Writer), and thus no exception for our tests.
            _resp.Write(charData, 0, charsRead);
        }
    }


}

// IIS }}}

    #endregion

    #region HttpListener Request/Response Adapters
// {{{ HttpListener Request / Response adapters

// --------------------------------------------------------------------------------------
// HttpListenerRequestAdapter
// --------------------------------------------------------------------------------------
private class HttpListenerRequestAdapter : IHttpRequestAdapter
{
    private HttpListenerRequest _req;
    private MemoryStream        _OutputStorage;

    public HttpListenerRequestAdapter(HttpListenerContext ctx)
    {
        _req = ctx.Request;
        _OutputStorage = new MemoryStream();
    }

    public void Dispose()
    {
    }

    public Uri Url 
    { 
        get 
        {
            return _req.Url;
        }
    }

    public string HttpMethod 
    { 
        get
        {
            return _req.HttpMethod;
        }
    }

    public long ContentLength 
    { 
        get
        {
            return _req.ContentLength64;
        }
    }

    public IPEndPoint LocalEP 
    { 
        get
        {
            return _req.LocalEndPoint;
        }
    }

    public IPEndPoint RemoteEP 
    { 
        get
        {
            return _req.RemoteEndPoint;
        }
    }

    public NameValueCollection Headers 
    { 
        get
        {
            return _req.Headers;
        }
    }

    public NameValueCollection QueryString
    {
        get 
        {
            return _req.QueryString;
        }
    }

    public Stream InputStream 
    { 
        get
        {
            return _req.InputStream;
        }
    }
}

// --------------------------------------------------------------------------------------
// HttpListenerResponseAdapter
// --------------------------------------------------------------------------------------
private class HttpListenerResponseAdapter : IHttpResponseAdapter
{
    private HttpListenerResponse _resp;
    private MemoryStream         _OutputStorage;

    public HttpListenerResponseAdapter(HttpListenerContext ctx)
    {
        _resp = ctx.Response;
        _OutputStorage = new MemoryStream();
    }

    public void Dispose()
    {
        CloseOutput();
    }

    public int StatusCode
    {
        get { return _resp.StatusCode; }
        set { _resp.StatusCode = value; }
    }

    public string ContentType
    {
        get { return _resp.ContentType; }
        set { _resp.ContentType = value; }
    }

    public TextWriter Output
    {
        get { return new StreamWriter(_OutputStorage); }  //return new StreamWriter(_resp.OutputStream); }
    }

    public void BinaryWrite(byte[] data)
    {
        if (data != null)
        {
            //_resp.OutputStream.Write(data, 0, data.Length);
            BinaryWriter bw = new BinaryWriter(_OutputStorage);
            bw.Write(data);
        }
    }

    // Extra method for annoying outputstream cleanup
    private void CloseOutput()
    {
        byte[] data = _OutputStorage.GetBuffer();
        long dataLength = _OutputStorage.Length;
        // data.Length is probably larger than _OutputStorage.Length, fyi. It represents 
        // the total buffer size.

        _resp.ContentLength64 = dataLength;
        _resp.OutputStream.Write(data, 0, (int)dataLength);
        _resp.OutputStream.Close();
    }

}

    // HttpListener }}}

    #endregion

    #region WCF Request/Response Adapters
// {{{ WCF Request/Response adapters

// --------------------------------------------------------------------------------------
// WcfRequestAdapter
// --------------------------------------------------------------------------------------
private class WcfRequestAdapter : IHttpRequestAdapter
{
    private OperationContext                _ctx;
    private RemoteEndpointMessageProperty   _endpointProperty;
    private HttpRequestMessageProperty      _httpRequestProperty;

    public WcfRequestAdapter(OperationContext ctx)
    {
        _ctx = ctx;
        if (ctx != null)
        {
            MessageProperties messageProperties = ctx.IncomingMessageProperties;
            _endpointProperty = (RemoteEndpointMessageProperty)messageProperties[RemoteEndpointMessageProperty.Name];
            _httpRequestProperty = (HttpRequestMessageProperty)messageProperties[HttpRequestMessageProperty.Name];
        }
    }

    public void Dispose()
    {
    }

    public Uri Url
    {
        get
        {
            return _ctx.IncomingMessageHeaders.To;
        }
    }

    public string HttpMethod
    {
        get
        {
            return _httpRequestProperty.Method;
        }
    }

    public long ContentLength
    {
        get
        {
            throw new NotImplementedException();
        }
    }

    public IPEndPoint LocalEP
    {
        get
        {
            throw new NotImplementedException();
        }
    }

    public IPEndPoint RemoteEP
    {
        get
        {
            return new IPEndPoint(IPAddress.Parse(_endpointProperty.Address), _endpointProperty.Port);
        }
    }

    public NameValueCollection Headers
    {
        get
        {
            return _httpRequestProperty.Headers;
        }
    }

    public NameValueCollection QueryString
    {
        get
        {
            return HttpUtility.ParseQueryString(_httpRequestProperty.QueryString);
        }
    }

    public Stream InputStream
    {
        get
        {
            throw new NotImplementedException();
        }
    }
}

// --------------------------------------------------------------------------------------
// WcfResponseAdapter
// --------------------------------------------------------------------------------------
private class WcfResponseAdapter : IHttpResponseAdapter
{
    private OperationContext    _ctx;

    public WcfResponseAdapter(OperationContext ctx)
    {
        _ctx = ctx;
    }

    public void Dispose()
    {
    }

    public int StatusCode
    {
        get { throw new NotImplementedException(); }
        set { throw new NotImplementedException(); }
    }

    public string ContentType
    {
        get { throw new NotImplementedException(); }
        set { throw new NotImplementedException(); }
    }

    public TextWriter Output
    {
        get { throw new NotImplementedException(); }
    }

    public void BinaryWrite(byte[] data)
    {
        throw new NotImplementedException();
    }
}

    // Wcf }}}

#endregion

}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

XonBdkHResult.cs: TransformXml.js $(XONEXTPATH)\SCS\$(SCS_SDK)\inc\BdkError.xml XonBdkErrorAutoGen.xsl
    @
    cscript /e:jscript /nologo TransformXml.js $(XONEXTPATH)\SCS\$(SCS_SDK)\inc\BdkError.xml XonBdkErrorAutoGen.xsl $@ & \
    if errorlevel 1 echo NMAKE : TransformXml.js: error transforming $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\MasterKey.cs ===
using System;
using System.IO;
using System.Security.Cryptography;

using xonline.common.exceptions;

namespace xonline.common.service
{
    public class MasterKey : IDisposable
    {
        private const int ENCRYPTED_BLOCK_SIZE   = 256;
        private const int UNENCRYPTED_BLOCK_SIZE = 128;

        int _masterKeyVersion;
        RSACryptoServiceProvider _cryptoServiceProvider;

        public MasterKey(int masterKeyVersion)
        {
            _masterKeyVersion = masterKeyVersion;

            CspParameters parameters = new CspParameters();
            parameters.Flags = CspProviderFlags.UseMachineKeyStore | CspProviderFlags.UseExistingKey;
            parameters.KeyContainerName = ContainerName(masterKeyVersion);

            try {
                _cryptoServiceProvider = new RSACryptoServiceProvider(parameters);
            } catch (Exception e) {
                throw new XblException(HResult.XONLINE_E_MASTER_KEY_ERROR, e, "Error getting master key, version = {0}", masterKeyVersion);
            }
        }

        public int MasterKeyVersion
        {
            get { return _masterKeyVersion; }
        }

        public byte[] Decrypt(byte[] encryptedBytes)
        {
            
            byte[] tempBytes;

            using (MemoryStream inputStream = new MemoryStream(encryptedBytes)) {
                using (BinaryReader binaryReader = new BinaryReader(inputStream)) {
                    using (MemoryStream outputStream = new MemoryStream()) {
                        
                        while ((tempBytes = binaryReader.ReadBytes(ENCRYPTED_BLOCK_SIZE)).Length > 0) {

                            // the native code writes bytes in the reverse order
                            // of managed code.  reverse bytes for compatibility

                            Array.Reverse(tempBytes);

                            // decrypt the bytes using the provider and then we
                            // write to the stream so we can get one big  array

                            tempBytes = _cryptoServiceProvider.Decrypt(tempBytes, false);
                            outputStream.Write(tempBytes, 0, tempBytes.Length);
                        }

                        return outputStream.ToArray();
                    }
                }
            }
        }
        
        public byte[] Encrypt(byte[] unencryptedBytes)
        {
            byte[] tempBytes;

            using (MemoryStream inputStream = new MemoryStream(unencryptedBytes)) {
                using (BinaryReader binaryReader = new BinaryReader(inputStream)) {
                    using (MemoryStream outputStream = new MemoryStream()) {

                        while ((tempBytes = binaryReader.ReadBytes(UNENCRYPTED_BLOCK_SIZE)).Length > 0)
                        {
                            tempBytes = _cryptoServiceProvider.Encrypt(tempBytes, false);

                            // the native code writes bytes in the reverse order
                            // of managed code.  reverse bytes for compatibility

                            Array.Reverse(tempBytes);
                            outputStream.Write(tempBytes, 0, tempBytes.Length);
                        }

                        return outputStream.ToArray();
                    }
                }
            }
        }




        public void Dispose()
        {
            _cryptoServiceProvider.Clear();
        }

        private static string ContainerName(int masterKeyVersion)
        {
            return "XOMasterKey" + masterKeyVersion;
        }

        public static byte[] Decrypt(int masterKeyVersion, byte[] buffer)
        {
            using (MasterKey masterKey = new MasterKey(masterKeyVersion))
            {
                return masterKey.Decrypt(buffer);
            }
        }

        public static byte[] Encrypt(int masterKeyVersion, byte[] buffer)
        {
            using (MasterKey masterKey = new MasterKey(masterKeyVersion))
            {
                return masterKey.Encrypt(buffer);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\RsaPublicKey.cs ===
using System;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

namespace xonline.common.service
{
    [ComVisible(false)]
    public class RsaPublicKey : IDisposable
    {
        private RSACryptoServiceProvider _csp = new RSACryptoServiceProvider();
        private int _keyVersion;

        public RsaPublicKey(ServiceKeyType keyType)
        {
            ServiceKey serviceKey = ServiceKey.GetLatest(keyType);

            _keyVersion = serviceKey.KeyVersion;
            _csp.ImportCspBlob(serviceKey.Key);
        }

        public RsaPublicKey(ServiceKeyType keyType, int keyVersion)
        {
            ServiceKey serviceKey = ServiceKey.Get(keyType, keyVersion);

            _keyVersion = serviceKey.KeyVersion;
            _csp.ImportCspBlob(serviceKey.Key);
        }

        public RsaPublicKey(int keyVersion, byte[] cspBlob)
        {
            _keyVersion = keyVersion;
            _csp.ImportCspBlob(cspBlob);
        }

        public byte[] Encrypt(byte[] buffer)
        {
            return _csp.Encrypt(buffer, false);
        }

        public int KeyVersion
        {
            get { return _keyVersion; }
        }

        public void  Dispose()
        {
            _csp.Clear();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\Puid.cs ===
using System;
using System.Runtime.InteropServices;
using System.Globalization;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Schema;

namespace xonline.common.service
{
    [ComVisible(false)]
    [XmlSchemaProvider("PuidSchema")]
    [WireInfo(SerializeAs=typeof(ulong))]
    public partial struct Puid : IEquatable<Puid>, IXmlSerializable
    {
        private ulong _value;

        private Puid(ulong value)
        {
            _value = value;
        }

        public override int GetHashCode()
        {
            return _value.GetHashCode();
        }

        public override string ToString()
        {
            // the one way to display an HResult
            return "0x" + _value.ToString("X016");
        }

        public static implicit operator Puid(ulong value)
        {
            return new Puid(value);
        }

        public static implicit operator ulong(Puid Puid)
        {
            // convert a puid to ulong
            return Puid._value;
        }


        // explicit cast...
        public static explicit operator Puid(long value)
        {
            return new Puid((ulong)value);
        }

        public static explicit operator long(Puid Puid)
        {
            return (long)Puid._value;
        }

        #region IEquatable<Puid> Members

        public bool Equals(Puid other)
        {
            return _value == other._value;
        }

        #endregion

        public static Puid Parse(string s)
        {
            if (s.StartsWith("0x", true, CultureInfo.CurrentCulture)) s = s.Substring(2);
            return new Puid(Convert.ToUInt64(s, 16));
        }

        public static bool TryParse(string s, out Puid Puid)
        {
            try
            {
                Puid = Puid.Parse(s);
                return true;
            }
            catch
            {
                Puid = new Puid(0);
                return false;
            }
        }

        #region IXmlSerializable Members
        
        public void ReadXml(XmlReader reader)
        {
            _value = (ulong) XmlConvert.ToUInt64(reader.ReadElementContentAsString());
        }

        public void WriteXml(XmlWriter writer)
        {
            writer.WriteValue(_value.ToString());
        }

        public XmlSchema GetSchema()
        {
            return (null);
        }

        #endregion
        
        public static XmlQualifiedName PuidSchema(XmlSchemaSet xs)
        {
            return new XmlQualifiedName("unsignedLong", XmlSchema.Namespace);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\RsaPrivateKey.cs ===
using System;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

namespace xonline.common.service
{
    [ComVisible(false)]
    public class RsaPrivateKey : IDisposable
    {
        private RSACryptoServiceProvider _csp = new RSACryptoServiceProvider();

        public RsaPrivateKey(ServiceKeyType keyType) {
            Init(ServiceKey.GetLatest(keyType));
        }

        public RsaPrivateKey(ServiceKeyType keyType, int keyVersion) {
            Init(ServiceKey.Get(keyType, keyVersion));
        }

        private void Init(ServiceKey serviceKey)
        {
            try {
                _csp.ImportCspBlob(serviceKey.Key);
            }
            catch (Exception e)
            {
                throw new XRLException(
                    HResult.XONLINE_E_SERVICE_KEY_IMPORT_ERROR, XEvent.Id.SERVICE_KEY_IMPORT_ERROR,
                    "Error importing service key, keyType = " + ((int) serviceKey.KeyType) +
                    ", keyVersion = " + serviceKey.KeyVersion, e
                );
            }
        }

        public byte[] Decrypt(byte[] buffer)
        {
            return _csp.Decrypt(buffer, false);
        }

        public void  Dispose()
        {
            _csp.Clear();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\OfferId.cs ===
using System;
using System.Runtime.InteropServices;
using System.Globalization;

namespace xonline.common.service
{
    [ComVisible(false)]
    public partial struct OfferId : IEquatable<OfferId>
    {
        private ulong _value;

        private OfferId(ulong value)
        {
            _value = value;
        }

        public override int GetHashCode()
        {
            return _value.GetHashCode();
        }

        public override string ToString()
        {
            // the one way to display an OfferId
            return "0x" + _value.ToString("X016");
        }

        public static implicit operator OfferId(ulong value)
        {
            return new OfferId(value);
        }

        public static implicit operator ulong(OfferId OfferId)
        {
            // convert a OfferId to ulong
            return OfferId._value;
        }

        #region IEquatable<OfferId> Members

        public bool Equals(OfferId other)
        {
            return _value == other._value;
        }

        #endregion

        public static OfferId Parse(string s)
        {
            if (s.StartsWith("0x", true, CultureInfo.CurrentCulture)) s = s.Substring(2);
            return new OfferId(Convert.ToUInt64(s, 16));
        }

        public static bool TryParse(string s, out OfferId offerId)
        {
            try
            {
                offerId = OfferId.Parse(s);
                return true;
            }
            catch
            {
                offerId = new OfferId(0);
                return false;
            }
        }

        public TitleId TitleId
        {
            get
            {
                return (TitleId)(uint) (_value >> 32);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\NativeSocket.cs ===
using System;
using System.Diagnostics.CodeAnalysis;
using System.Net;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Security;

namespace xonline.common.service
{
    // NOTE: This class is incomplete!  Add any additional api wrappers as needed.
    public sealed class NativeSocket : IDisposable
    {
        static NativeSocket()
        {
            // NOTE: There is no matching call to WSACleanup().  If this is a problem, implement and find a good place to call it.
            Int32 iRet = WinApiWSAStartup((UInt16)0x0002, ref _wsaData);
            if (iRet != 0)
            {
                throw new Exception("NativeSocket static constructor: WSAStartup returned " + iRet.ToString());
            }
        }

        public NativeSocket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType)
        {
            // it looks like these enums match up to the winsock constants when casted to ints.
            _socket = WinApiSocket((Int32)addressFamily, (Int32)socketType, (Int32)protocolType);
            if (_socket.ToInt32() == (Int32)(-1))
            {
                Int32 iError = WinApiWSAGetLastError();
                throw new Exception("WinApiSocket() returned INVALID_SOCKET.  WSAGetLastError = " + iError.ToString());
            }
        }

        ~NativeSocket()
        {
            Dispose();
        }

        public void Bind(IPEndPoint localEP)
        {
            byte[] sockaddr_in = BuildSockAddr(localEP);

            Int32 iRet = WinApiBind(_socket, sockaddr_in, (Int32)(sockaddr_in.Length));
            if (iRet == (Int32)(-1))
            {
                Int32 iError = WinApiWSAGetLastError();
                throw new Exception("Bind() returned SOCKET_ERROR.  WSAGetLastError = " + iError.ToString());
            }
        }

        public int SendTo(byte[] buffer, IPEndPoint remoteEP)
        {
            byte[] sockaddr_in = BuildSockAddr(remoteEP);
            Int32 iRet = WinApiSendTo(_socket, buffer, (Int32)(buffer.Length), SocketFlags.None, sockaddr_in, (Int32)(sockaddr_in.Length));

            if (iRet == (Int32)(-1))
            {
                Int32 iError = WinApiWSAGetLastError();
                throw new Exception("SendTo() returned SOCKET_ERROR.  WSAGetLastError = " + iError.ToString());
            }

            return (int)iRet;
        }

        public int ReceiveFrom(byte[] buffer, ref IPEndPoint remoteEP)
        {
            Int32 fromlen = 16;
            byte[] sockaddr_in = new byte[(int)fromlen];
            Int32 iRet = WinApiRecvFrom(_socket, buffer, (Int32)(buffer.Length), SocketFlags.None, sockaddr_in, ref fromlen);

            if (iRet == (Int32)(-1))
            {
                Int32 iError = WinApiWSAGetLastError();
                throw new Exception("ReceiveFrom() returned SOCKET_ERROR.  WSAGetLastError = " + iError.ToString());
            }

            if (fromlen != (Int32)16)
            {
                throw new Exception("ReceiveFrom() unsupported 'from' length.");
            }

            BuildIPEndpoint(sockaddr_in, ref remoteEP);

            return (int)iRet;
        }

        public bool Select(int microseconds, SelectMode mode)
        {
            FileDescriptorSet fd_set = new FileDescriptorSet(1);
            FileDescriptorSet fd_set_empty = new FileDescriptorSet(0);

            fd_set.Array[0] = (IntPtr)_socket.ToInt32();

            // ... but it doesn't JIT
            TimeValue timeval = new TimeValue();

            timeval.Seconds = 0;
            timeval.Microseconds = microseconds;

            Int32 iRet = (Int32)(-1);

            switch (mode)
            {
                case SelectMode.SelectRead:
                    iRet = WinApiSelect((Int32)1, ref fd_set, ref fd_set_empty, ref fd_set_empty, ref timeval);
                    break;

                case SelectMode.SelectWrite:
                    iRet = WinApiSelect((Int32)1, ref fd_set_empty, ref fd_set, ref fd_set_empty, ref timeval);
                    break;

                case SelectMode.SelectError:
                    iRet = WinApiSelect((Int32)1, ref fd_set_empty, ref fd_set_empty, ref fd_set, ref timeval);
                    break;
            }

            if (iRet == (Int32)(-1))
            {
                Int32 iError = WinApiWSAGetLastError();
                throw new Exception("Select() returned SOCKET_ERROR.  WSAGetLastError = " + iError.ToString());
            }

            return (iRet != (Int32)0);
        }

        public void Shutdown(SocketShutdown how)
        {
            Int32 iRet = WinApiShutdown(_socket, (Int32)how);
            if (iRet == (Int32)(-1))
            {
                Int32 iError = WinApiWSAGetLastError();
                throw new Exception("Shutdown() returned SOCKET_ERROR.  WSAGetLastError = " + iError.ToString());
            }
        }

        public void Close()
        {
            Int32 iRet = WinApiCloseSocket(_socket);
            if (iRet == (Int32)(-1))
            {
                Int32 iError = WinApiWSAGetLastError();
                throw new Exception("Close() returned SOCKET_ERROR.  WSAGetLastError = " + iError.ToString());
            }

            _socket = IntPtr.Zero;
        }

        public void Dispose()
        {
            if (_socket != IntPtr.Zero)
            {
                Shutdown(SocketShutdown.Both);
                Close();
            }
        }

        static private void BuildIPEndpoint(byte[] sockaddr_in, ref IPEndPoint ep)
        {
            Int16 sin_family = (Int16)(sockaddr_in[0] + (sockaddr_in[1] << 8));
            UInt16 sin_port = (UInt16)((sockaddr_in[2] << 8) + sockaddr_in[3]);
            string sin_addr =
                sockaddr_in[4].ToString() + "." +
                sockaddr_in[5].ToString() + "." +
                sockaddr_in[6].ToString() + "." +
                sockaddr_in[7].ToString();

            ep.Port = sin_port;
            ep.Address = IPAddress.Parse(sin_addr);
        }

        static private byte[] BuildSockAddr(IPEndPoint ep)
        {
            if (ep.AddressFamily != AddressFamily.InterNetwork)
            {
                throw new Exception("BuildSockAddr(): unsupported Address Family.");
            }

            byte[] sockaddr_in = new byte[16];

            Int16 sin_family = (Int16)ep.AddressFamily;
            UInt16 sin_port = (UInt16)ep.Port;
            byte[] sin_addr = ep.Address.GetAddressBytes();

            sockaddr_in[0] = (byte)(sin_family & 0xFF);
            sockaddr_in[1] = (byte)((sin_family >> 8) & 0xFF);

            sockaddr_in[2] = (byte)((sin_port >> 8) & 0xFF);
            sockaddr_in[3] = (byte)(sin_port & 0xFF);

            for (int i = 0; i < 4; i++)
            {
                sockaddr_in[4 + i] = sin_addr[i];
            }

            // sin_zero
            for (int i = 8; i < 16; i++)
            {
                sockaddr_in[i] = 0;
            }

            return sockaddr_in;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct WSAData
        {
            public Int16 wVersion;
            public Int16 wHighVersion;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 257)]
            public String szDescription;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 129)]
            public String szSystemStatus;
            public Int16 iMaxSockets;
            public Int16 iMaxUdpDg;
            public IntPtr lpVendorInfo;
        }


        [Flags]
        private enum SocketFlags
        {
            None                = 0x0000,
            OutOfBand           = 0x0001,
            Peek                = 0x0002,
            DontRoute           = 0x0004,
            // see: http://as400bks.rochester.ibm.com/pubs/html/as400/v4r5/ic2978/info/apis/recvms.htm
            MaxIOVectorLength   = 0x0010,
            Partial             = 0x8000,
        }; // enum SocketFlags


        // Structure used in select() call, taken from the BSD file sys/time.h.
        [StructLayout(LayoutKind.Sequential)]
        private struct TimeValue
        {
            public int Seconds;
            public int Microseconds;
        } // struct TimeValue


        [StructLayout(LayoutKind.Sequential)]
        private struct FileDescriptorSet
        {
            //
            // how many are set?
            //
            public int Count;
            //
            // an array of Socket handles
            //
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = MaxCount)]
            public IntPtr[] Array;

            public static readonly int Size = Marshal.SizeOf(typeof(FileDescriptorSet));
            public static readonly FileDescriptorSet Empty = new FileDescriptorSet(0);
            public const int MaxCount = 64;

            public FileDescriptorSet(int count)
            {
                Count = count;
                Array = count == 0 ? null : new IntPtr[MaxCount];
            }
        }   // class FileDescriptorSet


        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [SuppressUnmanagedCodeSecurityAttribute]
        [DllImport("ws2_32.dll",
         EntryPoint="WSAStartup",
         SetLastError=true,
         CharSet=CharSet.Auto)]
        static private extern Int32 WinApiWSAStartup(UInt16 wVersion, ref WSAData wsaData);

        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [SuppressUnmanagedCodeSecurityAttribute]
        [DllImport("ws2_32.dll",
         EntryPoint="socket",
         SetLastError=true,
         CharSet=CharSet.Ansi)]
        static private extern IntPtr WinApiSocket(Int32 af, Int32 type, Int32 protocol);

        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [SuppressUnmanagedCodeSecurityAttribute]
        [DllImport("ws2_32.dll",
         EntryPoint="bind",
         SetLastError=true,
         CharSet=CharSet.Ansi)]
        static private extern Int32 WinApiBind(IntPtr socket, byte[] name, Int32 namelen);

        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [SuppressUnmanagedCodeSecurityAttribute]
        [DllImport("ws2_32.dll",
         EntryPoint="sendto",
         SetLastError=true,
         CharSet=CharSet.Ansi)]
        static private extern Int32 WinApiSendTo(IntPtr socket, byte[] buf, Int32 len, SocketFlags flags, byte[] to, Int32 tolen);

        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [SuppressUnmanagedCodeSecurityAttribute]
        [DllImport("ws2_32.dll",
         EntryPoint="recvfrom",
         SetLastError=true,
         CharSet=CharSet.Ansi)]
        static private extern Int32 WinApiRecvFrom(IntPtr socket, byte[] buf, Int32 len, SocketFlags flags, byte[] from, ref Int32 fromlen);

        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [SuppressUnmanagedCodeSecurityAttribute]
        [DllImport("ws2_32.dll",
         EntryPoint="select",
         SetLastError=true,
         CharSet = CharSet.Ansi)]
        static private extern Int32 WinApiSelect(Int32 nfds, ref FileDescriptorSet readfds, ref FileDescriptorSet writefds, ref FileDescriptorSet exceptfds, ref TimeValue timeout);

        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [SuppressUnmanagedCodeSecurityAttribute]
        [DllImport("ws2_32.dll",
         EntryPoint="shutdown",
         SetLastError=true,
         CharSet=CharSet.Ansi)]
        static private extern Int32 WinApiShutdown(IntPtr socket, Int32 how);

        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [SuppressUnmanagedCodeSecurityAttribute]
        [DllImport("ws2_32.dll",
         EntryPoint="closesocket",
         SetLastError=true,
         CharSet=CharSet.Ansi)]
        static private extern Int32 WinApiCloseSocket(IntPtr socket);

        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [SuppressUnmanagedCodeSecurityAttribute]
        [DllImport("ws2_32.dll",
         EntryPoint="WSAGetLastError",
         SetLastError=true,
         CharSet=CharSet.Auto)]
        static private extern Int32 WinApiWSAGetLastError();

        static private WSAData _wsaData = new WSAData();

        private IntPtr _socket = IntPtr.Zero;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\ServiceKeyType.cs ===
namespace xonline.common.service
{
    public enum ServiceKeyType
    {
        KDC_PASSPORT_NET         = 1,
        KDC_XBOX_COM             = 2,
        PASSPORT_DELADMIN        = 3,
        BILLING                  = 4,
        KEY_ENCRYPTION_KEY       = 5,
        SECURITY_GATEWAY         = 6,
        SIGNATURE_SERVER         = 7,
        WMDRM_GROUP_PRIVATE_KEY  = 8,
        KDC_ECHO_DATA            = 9,
        WMRM_EMS_SEED_ID         = 10,
        WMRM_SYNCCAST_AES_KEY    = 11,
        WIREDATA_PRIVATE_KEY     = 12,
        WIREDATA_PUBLIC_KEY      = 13,
        SECP_DB_PRIVATE_KEY      = 14,
        SECP_DB_PUBLIC_KEY       = 15,
        TOKEN_KEY_ENCRYPTION_KEY = 16,
        PLAYREADY_XBOX360_MODEL_PRIVATE_KEY = 17,
        XAUTHDATA_SIGNING_KEY    = 18,
        MUSICNET_AES_KEY         = 20,
        TESTONLY_XKEYMGR         = 999
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\RWLock.cs ===
using System;
using System.Threading;

// Suppressing the warning for volatile being used as ref because it is in the allowed situation of being
// used for the Interlocked class.  See http://msdn.microsoft.com/en-us/library/4bw5ewxy.aspx (Compiler Warning CS0420)
#pragma warning disable 420

namespace xonline.common.service
{
    // IDisposable wrapper for RWLock
    public class RWLockHandle : IDisposable
    {
        public RWLockHandle(RWLock rwLock)
        {
            m_rwLock = rwLock;
            m_rwLock.ReadLock();
        }

        public void UpgradeToWriter()
        {
            // do we already have the write lock?
            if (IsWriter())
            {
                return;
            }

            // drop the read lock, get the write lock.  yes, this means another writer could sneak in here.
            // we have to drop the reader lock, or else there's no way for other writers to succeed.  consider the case where two
            // simultaneous readers both call upgrade.  both upgraders will be stuck waiting for the other to release the reader lock.
            m_rwLock.ReadUnlock();
            m_rwLock.WriteLock();

            // mark that we have the write lock.
            m_fWriteLock = true;
        }

        public bool IsWriter()
        {
            return m_fWriteLock;
        }

        public void Dispose()
        {
            if (m_fWriteLock)
            {
                m_rwLock.WriteUnlock();
            }
            else
            {
                m_rwLock.ReadUnlock();
            }
        }

        protected bool m_fWriteLock;
        protected RWLock m_rwLock;
    }
    
    public class RWLock
    {
        public RWLock()
        {
            m_evtWriter = new ManualResetEvent(false);
        }
        
        public void ReadLock()
        {
            // declare a new reader.
            Interlocked.Increment(ref m_cReaders);

            // check to see if a writer has annouced himself.
            while (m_fWriter)
            {
                // a pending writer exists.  remove ourselves from the reader count and block.
                Interlocked.Decrement(ref m_cReaders);
                m_evtWriter.WaitOne();

                // woke up again.  declare a new reader again and start over.
                Interlocked.Increment(ref m_cReaders);
            }
        }

        public void ReadUnlock()
        {
            // remove the reader.
            Interlocked.Decrement(ref m_cReaders);
        }

        public void WriteLock()
        {
            while (true)
            {
                // lock the write internals.
                lock (this)
                {
                    // check for an existing pending writer
                    if (!m_fWriter)
                    {
                        // none found.  we are the next writer.  set the pending flag and block the event.
                        m_fWriter = true;
                        m_evtWriter.Reset();
                        break;
                    }
                }

                // a previous writer is still active.  we have to wait and try again.
                m_evtWriter.WaitOne();
            }

            // we're scheduled to write.  wait for all the existing readers to exit.                
            while (m_cReaders > 0)
            {
                Thread.Sleep(0);
            }
        }

        public void WriteUnlock()
        {
            // lock the write internals.
            lock (this)
            {
                // clear the writer flag and wake up the event.
                m_fWriter = false;
                m_evtWriter.Set();
            }
        }

        protected volatile int m_cReaders;
        protected volatile bool m_fWriter;
        protected ManualResetEvent m_evtWriter;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\SGAddressValidator.cs ===
//
// SGAddressValidator.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Simple, fast, static class for determining if a request came from a real SG's client ip 
// range or not. 
//
// 7/2007 kgoodier
//

using System;
using System.Collections.Generic;
using System.Net;
using System.Web;

using xonline.common.config;
using xonline.common.mgmt;

namespace xonline.common.service
{

public static class SGAddressValidator
{

    public enum Answer 
    {
        Yes,
        No,
        Unknown
    };

    // -------------------------------------------------------------------------
    // Check - did this request come from a real SG? Note this doesn't work on Xblobs 
    // (returns Unknown) nor does it work for STF requests (FakeSG) -- it will return No 
    // when it should probably return Yes.
    //
    // Returns 
    // Yes if request ip came from real SG
    // No if it didn't
    // Unknown if Xblob or STF or otherwise unknown
    // -------------------------------------------------------------------------
    public static Answer Check(HttpContext ctx)
    {
        return Check(new HttpContextAdapter(ctx));
    }

    public static Answer Check(HttpContextAdapter ctx)
    {
        // Don't blow up if HttpContext is null
        if (ctx == null)
        {
            return Answer.Unknown;
        }

        IPAddress srcIP = null;
        ushort srcPort  = 0;
        GetSourceAddress(ctx, ref srcIP, ref srcPort);
        Answer ans = Check(srcIP, srcPort);

        // We need to check for STF tests, which will use FakeSG to provide SGInfo but 
        // won't come from any known IP address.  The http header that identifies tests is 
        // "Relja: true".
        if (ans == Answer.No && ctx.Request != null && ctx.Request.Headers["Relja"] != null)
        {
            ans = Answer.Unknown;
        }

        return ans;
    }

    // -------------------------------------------------------------------------
    // Check - overload for IPAddress
    // -------------------------------------------------------------------------
    public static Answer Check(IPAddress ipAddr, ushort port)
    {
        UInt32 ip = ConfigUtil.IpAddressToDword(ipAddr);
        return Check(ip, port);
    }

    // -------------------------------------------------------------------------
    // Check - overload for uint32 ip (real implementation)
    // -------------------------------------------------------------------------
    public static Answer Check(UInt32 ip, ushort port)
    {
        // Ensure static initialization complete, see Initialize
        Initialize();
        
        // Grab a local copy of the global
        Dictionary<string, IInterfaceInfo> sgInterfaces = _SgInterfaces;
        if (sgInterfaces == null)
        {
            Xom.Trace(XomAreaName.aainfo, LogLevel.L_LOW, "SGAddressValidator: Check returning Unknown, not initialized");
            return Answer.Unknown;
        }

        // Handy IInterfaceInfo fields:
        //   SgIpAddressBegin (IPAddress)
        //   SgIpAddressBeginDword
        //   SgIpAddressEnd (IPAddress)
        //   SgIpAddressEndDword
        //   SgPortBegin (int)
        //   SgPortEnd (int)
   
        foreach (IInterfaceInfo ifInfo in sgInterfaces.Values)
        {
            if (ip < ifInfo.SgIpAddressBeginDword ||
                ip > ifInfo.SgIpAddressEndDword)
            {
                continue;
            }

            if (port < ifInfo.SgPortBegin ||
                port > ifInfo.SgPortEnd)
            {
                continue;
            }

            Xom.Trace(XomAreaName.aainfo, LogLevel.L_LOW, String.Format(
                    "SGAddressValidator: Check returning Yes for ip 0x{0:X}, port {1}", 
                    ip, port));
            return Answer.Yes;
        }
   
        Xom.Trace(XomAreaName.aainfo, LogLevel.L_LOW, String.Format(
                "SGAddressValidator: Check returning No for ip 0x{0:X}, port {1}", 
                ip, port));
        return Answer.No;
    }
    


    // -------------------------------------------------------------------------
    // SGAddressValidator - static constructor, loads all SG ip settings from NPDB 
    // (t_server_nics).
    // -------------------------------------------------------------------------
    static SGAddressValidator()
    {
        // register for callbacks
        Config.ServerListChange += new ServerListChangeEventHandler(SGAddressValidator.OnServerListChange);
        Config.InterfaceChange += new InterfaceChangeEventHandler(SGAddressValidator.OnInterfaceChange);
    }

    //////////////////////////////////////////////////////////
    // Initialize
    //
    // Public static methods of this class MUST call this method (Initialize) to guarantee
    // all static members are properly initialized before doing any work.
    // Note: Right now this is really limited to just public methods that need to access _SgInterfaces
    private static void Initialize()
    {
        if ( !_fInitialized )
        {
            lock ( _lockInit )
            {
                if ( !_fInitialized )
                {
                    Xom.Trace(XomAreaName.aainfo, LogLevel.L_NORMAL, "SGAddressValidator: Initializing...");

                    // Kick off a fresh refresh
                    string[] servers = Config.GetServerListByInterface(Interface.sgsvc_int);
                    Dictionary<string, IInterfaceInfo> sgInterfaces = new Dictionary<string, IInterfaceInfo>(servers.Length);
                    RefreshServerList(servers, sgInterfaces);
                    
                    // Swap out member with fresh local copy real fast like
                    _SgInterfaces = sgInterfaces;
                    _fInitialized = true;

                    Xom.Trace(XomAreaName.aainfo, LogLevel.L_NORMAL, "SGAddressValidator: Done initializing.");
                }
            }
        }
    }

    // -------------------------------------------------------------------------
    // Callback from Config when server lists change
    // -------------------------------------------------------------------------
    public static void OnServerListChange(
        object sender, 
        ServerListChangeEventArgs args)
    {
        if (args.Interface != Interface.sgsvc_int)
        {
            // we're only concerned with the sg's internal interfaces
            return;
        }

        // Ensure static initialization complete, see Initialize
        Initialize();

        // We're dumb. Maybe only 1 server changed, but we're going to rebuild the whole 
        // thing. Not too expensive, much simpler.
        Dictionary<string, IInterfaceInfo> sgInterfaces = new Dictionary<string, IInterfaceInfo>(args.ValueNew.Length);
        RefreshServerList(args.ValueNew, sgInterfaces);
        
        // Swap out member with fresh local copy real fast like
        _SgInterfaces = sgInterfaces;
    }

    // -------------------------------------------------------------------------
    // Callback from Config when interfaces change
    // -------------------------------------------------------------------------
    public static void OnInterfaceChange(
        object sender,
        InterfaceChangeEventArgs args)
    {
        if (args.Interface != Interface.sgsvc_int)
        {
            // we're only concerned with the sg's internal interfaces
            return;
        }

        // Ensure static initialization complete, see Initialize
        Initialize();

        RefreshInterface(args.ValueNew, _SgInterfaces);
    }

    // -------------------------------------------------------------------------
    // RefreshServerList - reloads the entire list of SG ips
    // -------------------------------------------------------------------------
    private static void RefreshServerList(
        string[] serverList, 
        Dictionary<string, IInterfaceInfo> sgInterfaces)
    {
        foreach (string server in serverList)
        {
            IInterfaceInfo ifInfo = Config.GetInterface(server, Interface.sgsvc_int);
            RefreshInterface(ifInfo, sgInterfaces);
        }
    }

    // -------------------------------------------------------------------------
    // RefreshInterface - reloads only a single SG ip and replaces its entry in the 
    // dictionary.
    // -------------------------------------------------------------------------
    private static void RefreshInterface(
        IInterfaceInfo ifInfo,
        Dictionary<string, IInterfaceInfo> sgInterfaces)
    {
        // nothing fancy... but it could be!
        sgInterfaces[ifInfo.ServerName] = ifInfo;
        Xom.Trace(XomAreaName.aainfo, LogLevel.L_NORMAL, String.Format(
                "SGAddressValidator: Server({0}) Ip({1} - {2}) Port({3} - {4})",
                ifInfo.ServerName, 
                ifInfo.SgIpAddressBeginString, ifInfo.SgIpAddressEndString,
                ifInfo.SgPortBegin, ifInfo.SgPortEnd));
    }

    // -------------------------------------------------------------------------
    // Retrieve the request's IP address and port
    // -------------------------------------------------------------------------
    public static void GetSourceAddress(
        HttpContext ctx,
        ref IPAddress srcIP,
        ref ushort srcPort)
    {
        GetSourceAddress(new HttpContextAdapter(ctx), ref srcIP, ref srcPort);
    }

    public static void GetSourceAddress(
        HttpContextAdapter ctx,
        ref IPAddress srcIP, 
        ref ushort srcPort)
    {
        string sgIPPort = ctx.Request.Headers[XHttpHdr.SGIPPORT];
        if (sgIPPort != null)
        {
            // The UDP adaptor adds this header so the front door attempts to talk back to the
            // correct IP and port.
            // XrlScan also adds this header, because the GetServerVariables() call below
            // is incredibly expensive (for reasons beyond our understanding...)
            int colon = sgIPPort.IndexOf(':');
            if (colon == -1)
            {
                throw new ExceptionWithEventId(XEvent.Id.AUTHDATA_VERIFICATION_ERROR_1, "SGIPPort invalid: " + sgIPPort);
            }
            srcIP = IPAddress.Parse(sgIPPort.Substring(0,colon));
            srcPort = Convert.ToUInt16(sgIPPort.Substring(colon + 1));
        }
        else
        {
            srcIP = ctx.Request.RemoteEP.Address;
            srcPort = (ushort)ctx.Request.RemoteEP.Port;
        }
    }

    private static Dictionary<string, IInterfaceInfo>    _SgInterfaces = null;
    private static volatile bool _fInitialized = false;
    private static object _lockInit = new object();

}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\ServiceKey.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;

namespace xonline.common.service
{
    public class ServiceKey
    {
        private ServiceKeyType _keyType;
        private int            _keyVersion;
        private int            _masterKeyVersion;
        private int?           _siteId;
        private int?           _lifetime;
        private string         _serviceData1;
        private string         _serviceData2;

        private byte[]         _key;
        private Exception      _e;

        private ServiceKey(ServiceKeyType keyType, int keyVersion, int masterKeyVersion, byte[] key)
        {
            _keyType          = keyType;
            _keyVersion       = keyVersion;
            _masterKeyVersion = masterKeyVersion;
            _key              = key;
        }

        private ServiceKey(ServiceKeyType keyType, int keyVersion, int masterKeyVersion, Exception e)
        {
            _keyType          = keyType;
            _keyVersion       = keyVersion;
            _masterKeyVersion = masterKeyVersion;
            _e                = e;
        }

        // all the key fields have only private setters

        public ServiceKeyType KeyType
        {
            get { return _keyType; }
            private set { _keyType = value; }
        }

        public string ServiceData1
        {
            get { return _serviceData1; }
            private set { _serviceData1 = value; }
        }

        public string ServiceData2
        {
            get { return _serviceData2; }
            private set { _serviceData2 = value; }
        }

        public int KeyVersion
        {
            get { return _keyVersion; }
            private set { _keyVersion = value; }
        }

        public int MasterKeyVersion
        {
            get { return _masterKeyVersion; }
        }

        public byte[] Key
        {
            get { return _key; }
        }

        public int? Lifetime
        {
            get { return _lifetime; }
            set { _lifetime = value; }
        }

        public int? SiteId
        {
            get { return _siteId; }
            set { _siteId = value; }
        }

        private Exception Exception
        {
            get { return _e; }
        }

        internal void Save()
        {
            string connectionString = Config.NpdbConnectionString;
            byte[] encryptedKey = MasterKey.Encrypt(_masterKeyVersion, _key);

            try
            {
                using (SqlConnection connection = new SqlConnection(connectionString))
                {
                    using (SqlCommand command = connection.CreateCommand())
                    {
                        command.CommandText = "p_service_keys_set";
                        command.CommandType = CommandType.StoredProcedure;

                        command.Parameters.Add("@i_key_type", SqlDbType.Int).Value           = (int) _keyType;
                        command.Parameters.Add("@i_key_version", SqlDbType.Int).Value        = _keyVersion;
                        command.Parameters.Add("@i_master_key_version", SqlDbType.Int).Value = _masterKeyVersion;
                        command.Parameters.Add("@i_site_id", SqlDbType.Int).Value            = _siteId;
                        command.Parameters.Add("@i_service_data1", SqlDbType.VarChar).Value  = _serviceData1;
                        command.Parameters.Add("@i_service_data2", SqlDbType.VarChar).Value  = _serviceData2;
                        command.Parameters.Add("@bin_key", SqlDbType.Binary).Value           = encryptedKey;

                        connection.Open();
                        command.ExecuteNonQuery();
                    }
                }
            }

            catch (Exception e)
            {
                // everything thrown from the try block above will be
                // a sql or runtime exception. it needs to be wrapped
                
                throw new XRLException(
                    XRLException.ToHResult(e, HResult.XONLINE_E_DATABASE_ERROR), XEvent.Id.SERVICE_KEY_SAVE_ERROR,
                    string.Format("Error saving service key, keyType = {0}, keyVersion = {1}", _keyType, _keyVersion), e
                );
            }
        }

        public override string ToString()
        {
            return GetHashKey(_keyType, _keyVersion);
        }


#region static
        private static Hashtable _cache = null;

        static ServiceKey()
        {
            Config.ServiceKeysChange += new ServiceKeysChangeEventHandler(OnServiceKeysChange);
        }

        private static void OnServiceKeysChange(object sender, EventArgs e)
        {
            _cache = null;
        }

        public static ServiceKey Get(ServiceKeyType keyType, int keyVersion)
        {
            string serviceKeyHash = GetHashKey(keyType, keyVersion);
            ServiceKey serviceKey = (ServiceKey) Cache[serviceKeyHash];

            // the cache contains both valid and invalid keys.  if the key is
            // invalid (then throw the exception explaining why it is invalid)

            if (serviceKey != null)
            {
                if (serviceKey.Exception == null)
                {
                    return serviceKey;
                }

                throw new XblException(
                    HResult.XONLINE_E_SERVICE_KEY_ERROR, serviceKey.Exception, "Error getting service key, type = {0}, version = {1}", keyType, keyVersion
                );
            }

            // if we get here, then there was no entry in the cache  at  all

            throw new XRLException(
                HResult.XONLINE_E_SERVICE_KEY_NOT_FOUND, XEvent.Id.SERVICE_KEY_NOT_FOUND,
                string.Format("Service key not found, keyType = {0} ({1}), keyVersion = {2}", keyType, (int) keyType, keyVersion)
            );
        }

        public static ServiceKey GetLatest(ServiceKeyType keyType)
        {
            return Get(keyType, int.MaxValue);
        }

        private static Hashtable Cache
        {
            get
            {
                Hashtable cache = _cache;
                if (cache != null) return cache;

                lock (typeof(ServiceKey))
                {
                    cache = _cache;
                    if (cache != null) return cache;

                    cache = new Hashtable();

                    try
                    {
                        using (SqlConnection connection = new SqlConnection(Config.NpdbConnectionString))
                        {
                            using (SqlCommand command = connection.CreateCommand())
                            {
                                command.CommandText = "p_service_keys_get";
                                command.CommandType = CommandType.StoredProcedure;

                                connection.Open();

                                using (SqlDataReader reader = command.ExecuteReader())
                                {
                                    int siteIdOrdinal   = reader.GetOrdinal("i_site_id");
                                    int lifetimeOrdinal = reader.GetOrdinal("i_ticket_lifetime_secs");

                                    while (reader.Read()) 
                                    {
                                        // figure out how many bytes  are  in  the  key
                                        // allocate a buffer and read the encrypted key

                                        int ordinal = reader.GetOrdinal("bin_key");
                                        byte[] encryptedBytes = new byte[reader.GetBytes(ordinal, 0, null, 0, 0)];
                                        reader.GetBytes(ordinal, 0, encryptedBytes, 0, encryptedBytes.Length);

                                        // instantiate a new service key  objects  with
                                        // the key fields, then fill  in  other  fields

                                        ServiceKey serviceKey = null;
                                        ServiceKeyType keyType = (ServiceKeyType) reader["i_key_type"];
                                        int keyVersion = (int) reader["i_key_version"];
                                        int masterKeyVersion = (int)reader["i_master_key_version"];

                                        try
                                        {
                                            serviceKey = new ServiceKey(
                                                keyType, keyVersion, masterKeyVersion, MasterKey.Decrypt(masterKeyVersion, encryptedBytes)
                                            );
                                        }
                                        catch (Exception e)
                                        {
                                            Xom.NtEvent(XEvent.Id.SERVICE_KEY_LOAD_ERROR, e,
                                                "Error loading service key, keyType = {0} ({1}), keyVersion = {2}", keyType, (int)keyType, keyVersion
                                            );

                                            // create a poisoned key that will throw an
                                            // exception when someone tries to  get  it

                                            serviceKey = new ServiceKey(keyType, keyVersion, masterKeyVersion, e);
                                        }

                                        // get other key data - even if key is poisoned

                                        serviceKey.ServiceData1 = (string) reader["vc_service_data1"];
                                        serviceKey.ServiceData2 = (string) reader["vc_service_data2"];

                                        // special handling for fields with null values

                                        if (! reader.IsDBNull(siteIdOrdinal))   serviceKey.SiteId   = reader.GetInt32(siteIdOrdinal);
                                        if (! reader.IsDBNull(lifetimeOrdinal)) serviceKey.Lifetime = reader.GetInt32(lifetimeOrdinal);

                                        // add key to cache using a hash key  comprised
                                        // derived from the key type  and  key  version

                                        string serviceKeyHash = GetHashKey(serviceKey);
                                        cache[serviceKeyHash] = serviceKey;

                                        // then check if the latest key exists  and  if
                                        // this version exceeds the version of that one

                                        string latestKeyHash = GetHashKey(serviceKey.KeyType, int.MaxValue);
                                        ServiceKey latestKey = (ServiceKey) cache[latestKeyHash];

                                        if ((latestKey == null) || (serviceKey.KeyVersion > latestKey.KeyVersion))
                                        {
                                            cache[latestKeyHash] = serviceKey;
                                        }
                                    }
                                } // using
                            } // using
                        } // using
                    } // try

                    catch (Exception e)
                    {
                        throw new XRLException(
                            XRLException.ToHResult(e, HResult.XONLINE_E_DATABASE_ERROR),
                            XEvent.Id.SERVICE_KEY_LOAD_ERROR, e, "Error loading service key cache"
                        );
                    }  // catch

                    return _cache = cache;
                } // lock
            }
        }

        private static string GetHashKey(ServiceKey serviceKey)
        {
            return GetHashKey(serviceKey.KeyType, serviceKey.KeyVersion);
        }

        private static string GetHashKey(ServiceKeyType keyType, int keyVersion)
        {
            return ((int) keyType).ToString() + "." + keyVersion.ToString();
        }
        
#endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\SymmetricKey.cs ===
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;

namespace xonline.common.service
{
    [ComVisible(false)]
    public class SymmetricKey : IDisposable
    {
        private Rijndael _rijndael = new RijndaelManaged();

        public SymmetricKey()
        {
            _rijndael.Mode    = CipherMode.CBC;
            _rijndael.KeySize = 128;

            _rijndael.GenerateKey();
            _rijndael.GenerateIV();
        }

        public SymmetricKey(byte[] key, byte[] iv)
        {
            _rijndael.Mode    = CipherMode.CBC;
            _rijndael.KeySize = 128;
            _rijndael.Key     = key;
            _rijndael.IV      = iv;
        }

        public byte[] Key {
            get { return _rijndael.Key; }
        }

        public byte[] IV {
            get { return _rijndael.IV; }
        }

        public string Encrypt(string s)
        {
            return Convert.ToBase64String(Encrypt(Encoding.ASCII.GetBytes(s)));
        }

        public byte[] Encrypt(byte[] buffer)
        {
            using (MemoryStream memoryStream = new MemoryStream())
            {
                using (ICryptoTransform cryptoTransform = _rijndael.CreateEncryptor())
                {
                    using (CryptoStream cryptoStream = new CryptoStream(memoryStream, cryptoTransform, CryptoStreamMode.Write))
                    {
                        cryptoStream.Write(buffer, 0, buffer.Length);
                        cryptoStream.FlushFinalBlock();
                    }
                }

                return memoryStream.ToArray();
            }
        }

        public byte[] Decrypt(byte[] buffer)
        {
            using (MemoryStream memoryStream = new MemoryStream(buffer))
            {
                return Decrypt(memoryStream);
            }
        }

        public byte[] Decrypt(Stream stream)
        {
            using (ICryptoTransform cryptoTransform = _rijndael.CreateDecryptor())
            {
                using (CryptoStream cryptoStream = new CryptoStream(stream, cryptoTransform, CryptoStreamMode.Read))
                {
                    using (MemoryStream memoryStream = new MemoryStream())
                    {
                        int bytesRead;
                        byte[] tempBuffer = new byte[256];

                        while ((bytesRead = cryptoStream.Read(tempBuffer, 0, tempBuffer.Length)) > 0)
                        {
                            memoryStream.Write(tempBuffer, 0, bytesRead);
                        }

                        return memoryStream.ToArray();
                    }
                }
            }
        }

        void IDisposable.Dispose()
        {
            _rijndael.Clear();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\Validator.cs ===
using System;

using xonline.common.utilities2;

namespace xonline.common.service
{
    /// <summary>
    ///     This can be used as a generic validation module. To use this, do the following:
    ///     1)  Make the Validators that you will need (look around for existing ones first
    ///         as there's a chance you can reuse something.
    ///     1a) Implement DoCheckImpl on your new classes, see comment block
    ///         by that function declaration for details.
    ///     2)  Pass a bunch of Validators into MakeValidatorChain, which will return
    ///         a Validator that will do everything for you.
    ///     2a) In addition to the Validators, pass in the "final result" of the chain.
    ///     3)  Call DoCheck
    ///     3a) If this return true, you're good to go.
    ///     3b) If it returns false, we should not generate a certificate.  To get an
    ///         error message suitable for an exception, get the ErrorMessage property.
    /// </summary>
    ///
    /// <remarks>
    ///     Internally, the CertificateRequestChecker is basically a Chain of Responsiblity (GoF, page 233),
    ///     implemented as a linked-list of CertificateRequestGenerators.
    /// </remarks>
    public abstract class Validator
    {
        ///
        /// <summary>
        ///     Makes a Validator chain out of the Validators passed in.
        ///     Note that this alters the validators passed in--it doesn't clone them.
        /// </summary>
        ///
        /// <param name="finalResult">
        ///     Indicates whether the final result, if nothing has an opinion, should be true or false.
        ///     Note that these are modified as they are chained together.
        /// </param>
        /// <param name="validators">An array of validators to chain together, in the order in which they are passed in.</param>
        ///
        /// <returns>The first validator passed in, with the rest chained to it.</returns>
        ///
        public static Validator MakeValidatorChain(bool finalResult, params Validator[] validators)
        {
            if (validators == null || validators.Length <= 0)
            {
                throw new ArgumentException("You must pass in one or more valid Validators to make a Validator chain.", "validators");
            }

            int idx = 0;
            while (idx < validators.Length - 1)
            {
                validators[idx]._next = validators[idx + 1];
                ++idx;
            }
            validators[idx]._next = new EndOfChainValidator(finalResult);

            return validators[0];
        }


        ///
        /// <summary>
        ///     Actually do the check.
        /// </summary>
        ///
        /// <returns>Whether validation passed or failed.</returns>
        ///
        public bool DoCheck()
        {
            // Call the virtual checking function.
            // This is where the subclass gets to do its work.
            DoCheckResults result = DoCheckImpl();

            // If the subclass says this is absolutely a valid request
            // (as in a white-list case), then stop checking and
            // return true.  This indicates that no other check
            // could convince us that this is an invalid request.
            if (result == DoCheckResults.AbsoluteYes)
            {
                return true;
            }

            // If the subclass says this is absolutely not a valid
            // request, then stop checking and return false.  This
            // indicates that no other check could convince us that
            // this is a valid request.
            // Note that if we return false, we *must* have
            // set our ErrorMessage property.
            else if (result == DoCheckResults.AbsoluteNo)
            {
                if (String.IsNullOrEmpty(ErrorMessage))
                {
                    throw new ApplicationException("DoCheck is about to return false but has no error message.");
                }
                return false;
            }

            // If the subclass says "meh" then pass the decision down the list.
            else if (result == DoCheckResults.NoOpinion)
            {
                if (_next != null)
                    {
                    return _next.DoCheck();
                    }
                else
                    {
                    throw new ApplicationException("Use an EndOfChainCertificateChecker do a final yes or no answer.");
                    }
            }

            // This is an unexpected case which indicates that a member
            // has been added to DoCheckResults but hasn't been implemented
            // in this function, which would pretty much be the end
            // of the world.
            else
            {
                throw new ApplicationException(String.Format("Unexpected return value from DoCheckImpl: {0}.", result));
            }
        }


        ///
        /// <summary>
        ///     If DoCheck return false, this will contain an error message.
        /// </summary>
        ///
        /// <remarks>
        ///     Note that DoCheck could have return false because of
        ///     a checker further down in the list.  So if we don't
        ///     have a string and we aren't the last checker, we pass
        ///     the call down the list.
        ///
        ///     Subclasses can set the error message for themselves
        ///     using the protected setter.
        /// </remarks>
        ///
        /// <returns>An error string representing why the validation didn't pass.</returns>
        ///
        public string ErrorMessage
        {
            get
            {
                if (String.IsNullOrEmpty(_error) && _next != null)
                {
                    return _next.ErrorMessage;
                }
                else
                {
                    return _error;
                }
            }
            protected set { _error = value; }
        }


        ///
        /// <summary>
        ///     If DoCheck returns false, this will contain a logging string, which is 
        ///     shorter than the normal error message
        /// </summary>
        ///
        /// <remarks>
        ///     Note that DoCheck could have return false because of
        ///     a checker further down in the list.  So if we haven't
        ///     set the hr and we aren't the last checker, we pass
        ///     the call down the list.
        ///
        ///     Subclasses can set the error message for themselves
        ///     using the protected setter.
        ///
        ///     NOTE: Unlike ErrorMessage, subclasses are not required to set this field 
        ///     on failure. If they don't set this, but have set ErrorMessage, we will 
        ///     generate one for them.
        /// </remarks>
        ///
        /// <returns>A short error string giving a hint to ops and dev as to what 
        /// failed.</returns>
        ///
        public string LogError
        {
            get
            {
                if (String.IsNullOrEmpty(_logError))
                {
                    // If they haven't set the log error, but have set the error, then we 
                    // should use a default. Also, if this is the end of the chain, we 
                    // need a default.
                    if (!String.IsNullOrEmpty(_error) || _next == null)
                    {
                        return this.GetType().Name;
                    }
                    else
                    {
                        return _next.LogError;
                    }
                }
                else
                {
                    return _logError;
                }
            }
            protected set
            {
                if (value.Length > LOG_ERROR_MAX_LEN)
                {
                    throw new ArgumentException(String.Format("Validator.LogError set to {0}, which has length of {1}, which is greater than {2}.",
                                                              value, value.Length, LOG_ERROR_MAX_LEN));
                }
                else
                {
                    _logError = value;
                }
            }
        }


        ///
        /// <summary>
        ///     If DoCheck return false, this will contain an error code.
        /// </summary>
        ///
        /// <remarks>
        ///     Note that DoCheck could have return false because of
        ///     a checker further down in the list.  So if we haven't
        ///     set the hr and we aren't the last checker, we pass
        ///     the call down the list.
        ///
        ///     Subclasses can set the error message for themselves
        ///     using the protected setter.
        /// </remarks>
        ///
        /// <returns>An error code representing why the validation didn't pass.</returns>
        ///
        public HResult Hr
        {
            get
            {
                if (_hrSet)
                {
                    return _hr;
                }
                else if (_next != null)
                {
                    return _next.Hr;
                }
                else
                {
                    return DEFAULT_HRESULT;
                }
            }

            protected set
            {
                _hr = value;
                _hrSet = true;
            }
        }


        ///
        /// <summary>
        ///     Derived classes must implement this function.  The meanings of the
        ///     return values are detailed below.  Take a look at DoCheck to see
        ///     how these are used.
        /// </summary>
        ///
        /// <returns>The result of the validation.</returns>
        public enum DoCheckResults
        {
            AbsoluteYes = 1,    // Absolutely return true from DoCheck.  Stop checking.
            NoOpinion   = 2,    // Don't really care.  Continue checking.
            AbsoluteNo  = 3,    // Absolutely return false from Docheck.  Stop checking.
        }
        protected abstract DoCheckResults DoCheckImpl();


        private string _error = String.Empty;
        private string _logError = String.Empty;
        private Validator _next = null;
        private HResult _hr = 0;
        private bool _hrSet = false;

        // I'd rather not introduce any new dependencies.
        private const uint DEFAULT_HRESULT = HResult.E_ACCESSDENIED;
        private const uint LOG_ERROR_MAX_LEN = 20;
    }


    //
    // From here on down we have Validators that might be of general use.
    //

    //
    // Ensures that the request comes in from a supported client.
    //
    public sealed class PlatformValidator : Validator
    {
        public PlatformValidator(byte[] platforms)
        {
            _platforms = platforms;
        }

        public PlatformValidator(byte allowedPlatform, byte[] platforms)
            : this(platforms)
        {
            _allowedPlatform = allowedPlatform;
        }

        public static PlatformValidator MakeXbox360PlatformValidator()
        {
            return new PlatformValidator(new byte[] {XOn.XPLT_XBOX360} );
        }

        override protected DoCheckResults DoCheckImpl()
        {
            byte platformDetected = GetPlatform();
            if (!Array.Exists(_platforms, delegate(byte platform) { return platform == platformDetected; } ))
            {
                this.ErrorMessage = String.Format(
                    "Request came from an unexpected platform type {0}. The allowed platform types are {1}.",
                    platformDetected,
                    EnumerableFormatter.FormatEnumerable(_platforms));
                return DoCheckResults.AbsoluteNo;
            }

            return DoCheckResults.NoOpinion;
        }

        private byte GetPlatform()
        {
            if (_allowedPlatform.HasValue)
            {
                return _allowedPlatform.Value;
            }
            else
            {
                if (SGInfo.IsActiveAuth())
                {
                    return XOn.XPLT_WEB;
                }
                else
                {
                    return SGInfo.Current.GetPlatformType();
                }
            }
        }

        private readonly byte[] _platforms;
        private readonly byte? _allowedPlatform;
    }


    //
    // A trivial checker that just returns yes or no. This can be used for the end of the chain.
    //
    sealed class EndOfChainValidator : Validator
    {
        public EndOfChainValidator(bool finalResult)
        {
            _finalAnswer = finalResult ? DoCheckResults.AbsoluteYes : DoCheckResults.AbsoluteNo;
        }

        override protected DoCheckResults DoCheckImpl()
        {
            return _finalAnswer;
        }

        private readonly DoCheckResults _finalAnswer;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\TitleId.cs ===
using System;
using System.Runtime.InteropServices;
using System.Globalization;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Schema;

namespace xonline.common.service
{
    [ComVisible(false)]
    [XmlSchemaProvider("TitleIdSchema")]
    [WireInfo(SerializeAs = typeof(uint))]
    public partial struct TitleId : IEquatable<TitleId>, IXmlSerializable
    {
        private uint _value;

        private TitleId(uint value)
        {
            _value = value;
        }

        public override int GetHashCode()
        {
            return _value.GetHashCode();
        }

        public override string ToString()
        {
            // the one way to display an HResult
            return "0x" + _value.ToString("X08");
        }

        public static implicit operator TitleId(uint value)
        {
            return new TitleId(value);
        }

        public static implicit operator uint(TitleId titleId)
        {
            // convert a TitleId to uint
            return titleId._value;
        }

        #region IEquatable<TitleId> Members

        public bool Equals(TitleId other)
        {
            return _value == other._value;
        }

        #endregion

        public static TitleId Parse(string s)
        {
            if (s.StartsWith("0x", true, CultureInfo.CurrentCulture)) s = s.Substring(2);
            return new TitleId(Convert.ToUInt32(s, 16));
        }

        public static bool TryParse(string s, out TitleId titleId)
        {
            try
            {
                titleId = TitleId.Parse(s);
                return true;
            }
            catch
            {
                titleId = new TitleId(0);
                return false;
            }
        }           
        #region IXmlSerializable Members

        public void ReadXml(XmlReader reader)
        {
            _value = (uint) XmlConvert.ToUInt32(reader.ReadElementContentAsString());
        }

        public void WriteXml(XmlWriter writer)
        {
            writer.WriteValue(_value.ToString());
        }

        public XmlSchema GetSchema()
        {
            return (null);
        }

        #endregion

        public static XmlQualifiedName TitleIdSchema(XmlSchemaSet xs)
        {
            return new XmlQualifiedName("unsignedInt", XmlSchema.Namespace);
        }

        public ushort PublisherID
        {
            get { return (ushort)(_value >> 16); }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\testutils.cs ===
using System.Runtime.InteropServices;
using xonline.common.mgmt;


[assembly: XomAreaDefinition(XomAreaName.TestUtilities)]


namespace xonline.common.service 
{
    [ComVisible(false)]
    public class Utils
    {
        //
        // Format binary data in hex and ascii representations
        //
        public static void OutputHexBytes(byte[] data)
        {
            string  line;            

            if (null != data)
            {
                line = "";
                foreach (byte b in data)
                {                
                    System.Console.Write(b.ToString("x2") + " ");
                    if (b >= 0x21 && b <= 0x7e)
                    {
                        line += (char)b;
                    }
                    else
                    {
                        line += '.';
                    }

                    if (line.Length == 16)
                    {
                        System.Console.WriteLine(line);
                        line = "";
                    }
                }                       

                // Need to write the last ascii line
                line = line.PadLeft((16 - line.Length) * 3 + line.Length);
                System.Console.WriteLine(line);
            }
            else
            {
                System.Console.WriteLine("data is null");                
            }           
        }

        //
        // Print a string containing newlines to the console window
        //
        public static void WriteLines(string str)
        {
            string     delimiter = "\n";
            string []  lines = str.Split(delimiter.ToCharArray());

            foreach (string s in lines)
            {
                System.Console.WriteLine(s);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\wiredatacg.cs ===
using System;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;
using System.Xml.Serialization;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.core.wiredata;

namespace xonline.common.service
{

    // Customize the behavior of serialization/deserialization of a field
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Field | AttributeTargets.Struct)]
    public class WireInfoAttribute : Attribute
    {

        public string SizeParam = null;

        // Contains the fixed size of the field annotated by this attribute (which must
        // be an array)
        int size = -1;
        public int ArraySize
        {
            get { return size; }
            set { Debug.Assert(value >= 0); size = value; }
        }

        public bool HexString = false;

        public bool Serialize = true;

        public bool PrintToString = true;

        public bool NullTerminate = false; // For strings, specifies that the on the wire format should be null-terminated

        public bool MaskString = false;

        public bool LimitString = false;   // specifies in ToString() if string length should be limited
                                           // actual limit is defined in the npdb setting wiredata_stringLimit

        public bool BigEndian = false;     // Indicates that the value on the wire is big endian (native for console) and
                                           // needs to be converted to little-endian

        public Type SerializeAs = null;    // Defines that the field or type should be serialized as another well-known wiredata
                                           // type.  The expectation is that the field has an implicit or explicit conversion
                                           // operator to the SerializeAs type.
        public long Max
        {
            get { return _max; }
            set { MaxSet = true; _max = value; }
        }

        public long Min
        {
            get { return _min; }
            set { MinSet = true; _min = value; }
        }

        public static WireInfoAttribute None = new WireInfoAttribute();

        private long _min = 0;
        private long _max = 0;
        public bool MaxSet = false;
        public bool MinSet = false;
        public String MinSchemaVersion
        {
            get { return VersionToString(MinSchemaVersionVal); }
            set { MinSchemaVersionVal = StringToVersion(value); }
        }

        public String MaxSchemaVersion
        {
            get { return VersionToString(MaxSchemaVersionVal); }
            set { MaxSchemaVersionVal = StringToVersion(value); }
        }

        public uint MinSchemaVersionVal = 0;
        public uint MaxSchemaVersionVal = UInt32.MaxValue;

        public static uint StringToVersion(String versionStr)
        {
            String[] split = versionStr.Split('.');
            if (split.Length != 2)
                throw new ArgumentException();

            return UInt32.Parse(split[0]) << 16 | UInt32.Parse(split[1]);
        }

        public static String VersionToString(uint version)
        {
            return String.Format("{0}.{1}", (version & 0xFFFF0000) >> 16, version & 0xFFFF);
        }

    }

    //public delegate void DebugTraceHandler(string field);

    // Subclass this to produce your own WireDataclass. All public fields will be
    // considered for serialization. Be careful to use only supported field types.
    public class WireData
    {
        // How much to indent nested object and array members when converting to a string
        public const byte C_INDENT = 2;

        public static DateTime MinDateTimeValue = DateTime.FromFileTimeUtc(0);

        //public static DebugTraceHandler fieldDelegate;

        //public static event DebugTraceHandler fieldTrace
        //{
        //    [MethodImpl(MethodImplOptions.Synchronized)]
        //    add
        //    {n
        //        fieldDelegate = (DebugTraceHandler)Delegate.Combine(fieldDelegate, value);
        //    }

        //    [MethodImpl(MethodImplOptions.Synchronized)]
        //    remove
        //    {
        //        fieldDelegate = (DebugTraceHandler)Delegate.Remove(fieldDelegate, value);
        //    }
        //}

        //
        // Read a bunch of bytes into a WireData object
        //
        public WireData ReadBytes(byte[] bytes)
        {
            return ReadStream(new MemoryStream(bytes, 0, bytes.Length, true, true));
        }

        //
        // Read a stream into a WireData object
        //
        public virtual WireData ReadStream(Stream stream)
        {
            // Create the reader, uses UTF8 decoding by default
            return ReadStream(new BinaryReader(stream));
        }

        // If set, you will need to manually provide array sizes when writing WireDatas
        protected bool manualArraySize = false;

        public bool ManualArraySize
        {
            get { return manualArraySize; }
        }

        //
        // Override the operator byte[] to allow assigning a WireData object directly to a byte array.
        //
        public static explicit operator byte[](WireData wiredata)
        {
            MemoryStream stream = new MemoryStream();
            wiredata.WriteStream(stream);

            return stream.ToArray();
        }

        // Adding ToArray, as writing an explicit cast looks a little odd.
        public byte[] ToArray()
        {
            return (byte[])this;
        }

        //
        // Serialize the object to obtain its size in bytes. This is SLOW!
        //
        public virtual int Size()
        {
            MemoryStream stream = new MemoryStream();
            WriteStream(stream);

            return (int)stream.Length;
        }

        public virtual int SerializedSize
        {
            get
            {
                WireDataSizeofDelegate sizedel =
                    WireDataSerializerCache.GetSerializerFor<WireDataSizeofDelegate>(this.GetType());
                return sizedel(this);
            }
        }

        public override string ToString()
        {
            return ToString(0);
        }

        public virtual string ToString(int indent)
        {
            StringBuilder sb = new StringBuilder();
            ToString(sb, indent);
            return sb.ToString();
        }

        public void ToString(StringBuilder sb, int indent)
        {
            WireDataToStringDelegate tostrdel =
                WireDataSerializerCache.GetSerializerFor<WireDataToStringDelegate>(this.GetType());
            tostrdel(this, sb, indent);
        }
        //
        // Log to the appropriate log area
        //
        protected string LogBinary(Stream stream)
        {
            string result = "";

            if (stream.CanSeek && stream.CanRead)
            {
                long position = stream.Position;
                long length = stream.Length;

                int bytesToRead = (int)(length - position);
                int bytesRead = 0;

                byte []     bytes = new byte[bytesToRead];

                while (bytesToRead > 0)
                {
                    int n = stream.Read(bytes, bytesRead, bytesToRead);

                    if (n == 0)
                    {
                        break;
                    }

                    bytesRead += n;
                    bytesToRead -=n;
                }

                string[]    lines = ByteConvert.ToFormattedStrings(bytes);

                foreach (string s in lines)
                {
                    Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, s);
                }

                // Put things back the way they were when we started
                stream.Seek(position, SeekOrigin.Begin);

            }
            else
            {
                result = "unsupported stream type.";
            }

            return result;
        }


        //
        // Log to the appropriate log area
        //
        protected string LogText()
        {
            string     delimiter = "\n";
            string []  lines = this.ToString(0).Split(delimiter.ToCharArray());

            foreach (string s in lines)
            {
                Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, s);
            }

            return "";
        }

        public static string GetHrName(HResult hr)
        {
            return hr.Name;
        }

        public static string MaskString(string value)
        {
            return String.IsNullOrEmpty(value) ? value : String.Empty.PadRight(value.Length, '*');
        }

        public static string LimitString(string value)
        {
            if (value == null)
            {
                return " null";
            }

            int length = Config.GetIntSetting(Setting.wiredata_stringLimit);

            if (length > 0 && value.Length > length)
            {
                value = value.Substring(0, length) + " (more ...)";
            }

            return value;
        }

        // This call is to clean up strings that may have
        // ArraySize set on them, which would pad the string with
        // extra nulls at the end of the string.
        public static string TrimNulls(string val)
        {
            if (String.IsNullOrEmpty(val))
            {
                return String.Empty;
            }

            int termPos = val.IndexOf('\0');
            if (termPos >= 0)
            {
                return val.Substring(0, termPos);
            }

            return val;
        }

        // Format a byte array as a hex string
        public static void ByteArrayToString(StringBuilder sb, byte[] bin, int indent, bool limit, bool mask)
        {
            if (bin == null)
            {
                sb.AppendLine(" null");
                return;
            }

            sb.AppendLine("byte[" + bin.Length + "] {");
            uint maxLines = UInt32.MaxValue;
            if (limit)
            {
                // 65 characters per line created by the convert function
                maxLines = (uint)Math.Min(1, Config.GetIntSetting(Setting.wiredata_stringLimit) / (65 + indent + C_INDENT));
            }

            string fill = String.Empty.PadRight(indent + C_INDENT);

            if (mask)
            {
                sb.Append(fill).AppendLine("**masked**");
            }
            else
            {
                Array.ForEach(ByteConvert.ToFormattedStrings(bin, maxLines), delegate(string s) { sb.AppendLine(fill + s); });
                if (maxLines < UInt32.MaxValue)
                {
                    sb.AppendLine(fill + "(more ...)");
                }
            }

            sb.AppendLine(String.Empty.PadRight(indent) + "}");
        }

        public void ValidateSchemaVersion()
        {
            WireDataValidateDelegate validatedel =
                WireDataSerializerCache.GetSerializerFor<WireDataValidateDelegate>(this.GetType());
            validatedel(this);            // Check current SchemaVersion against the one the Class expects
        }
        //
        // Write a WireData object to the given stream
        //
        public virtual void WriteStream(Stream stream)
        {
            // Create the writer, uses UTF8 encoding by default
            WriteStream(new BinaryWriter(stream));
        }

        private bool EncryptionRequired
        {
            get {
                WireDataEncryptionRequiredDelegate encDelegate =
                    WireDataSerializerCache.GetSerializerFor<WireDataEncryptionRequiredDelegate>(this.GetType());
                return encDelegate(this);
            }
        }

        // Serialize class into a BinaryWriter
        public virtual void WriteStream(BinaryWriter binaryWriter)
        {
#if false
            // Log text representation
            Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, "WireData Text Output: ");
            Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, LogText());
#endif
            WireDataWriteDelegate writeDelegate =
                WireDataSerializerCache.GetSerializerFor<WireDataWriteDelegate>(this.GetType());

            if (this.EncryptionRequired)
                WireDataEncrypt.Write(this, writeDelegate, binaryWriter);
            else {
                writeDelegate(this, binaryWriter);
            }

#if false
            // Log the binary output
            Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, "WireData Binary Output: ");
            Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, LogBinary(binaryWriter.BaseStream));
#endif
        }

        // Deserialize class from a BinaryReader
        public virtual WireData ReadStream(BinaryReader binaryReader)
        {
#if false
            // Log the input buffer
            Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, "WireData Binary Input:");
            Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, LogBinary(binaryReader.BaseStream));
#endif
            WireDataReadDelegate readDelegate =
                WireDataSerializerCache.GetSerializerFor<WireDataReadDelegate>(this.GetType());

            try
            {
                if (EncryptionRequired)
                {
                    // decrypt message and replace binary reader
                    binaryReader = WireDataDecrypt.Read(this, readDelegate, binaryReader);
                }

                readDelegate(this, binaryReader);
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.WIREDATA_END_OF_STREAM, "Failed to read enough bytes for type " + GetType().Name, e);
            }
            catch (Exception e)
            {
                if ((e is XRLException) || (e is ExceptionWithoutEvent)) throw;
                HResult hr = XRLException.ToHResult(e, HResult.XONLINE_E_DESERIALIZATION_ERROR);
                throw new XRLException(hr, XEvent.Id.WIREDATA_DESERIALIZATION_ERROR, "Error deserializing request", e);
            }

#if false
            // Log text representation
            Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, "WireData Text Input: ");
            Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, LogText());
#endif
            return this;
        }

        public static uint MakeSchemaVersion(ushort major, ushort minor)
        {
            return (uint)major << 16 | (uint)minor;
        }

        // This is the version number of the latest schema. Must be the same as
        // XLIVE_SCHEMA_VERSION in xonline.xd in the client tree.
        public static readonly uint CurrentSchemaVersion = MakeSchemaVersion(7, 1);

        // Version of the schema to use for serializing/deserializing this object.

        [XmlIgnore]
        public uint SchemaVersion = CurrentSchemaVersion;

        public static uint GetSchemaVersion(HttpRequest req)
        {
            // Assume version 1.0 for back compat
            uint schemaVersion = MakeSchemaVersion(1, 0);

            String schemaVersionStr = req.Headers["X-Schema-Ver"];
            if (schemaVersionStr != null)
            {
                schemaVersion = WireInfoAttribute.StringToVersion(schemaVersionStr);
            }

            return schemaVersion;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\WireDataDecrypt.cs ===
using System;
using System.IO;
using System.Runtime.InteropServices;

using xonline.common.service;

namespace xonline.core.wiredata
{
    [ComVisible(false)]
    public static class WireDataDecrypt
    {
        static WireDataDecrypt()
        {
        }

        public static BinaryReader Read(
            WireData             wireData,
            WireDataReadDelegate readDelegate,
            BinaryReader         binaryReader
        )
        {
            try
            {
                int keyVersion = binaryReader.ReadInt32();

                // after the key version is the encrypted symmetric
                // key components.  use our private key to  decrypt

                byte[] encryptedBuffer = new byte[256];
                binaryReader.Read(encryptedBuffer, 0, 256);

                RsaPrivateKey privateKey = new RsaPrivateKey(ServiceKeyType.WIREDATA_PRIVATE_KEY, keyVersion);
                byte[] unencryptedBuffer = privateKey.Decrypt(encryptedBuffer);

                // take the unencrypted buffer  and  pull  out  the
                // pieces of the symmetric key then instantiate  it

                using (MemoryStream skMemoryStream = new MemoryStream(unencryptedBuffer))
                {
                    using (BinaryReader skBinaryReader = new BinaryReader(skMemoryStream))
                    {
                        int length = skBinaryReader.ReadInt32();

                        byte[] key = new byte[length];
                        if (skBinaryReader.Read(key, 0, length) != length) throw new EndOfStreamException();

                        length = skBinaryReader.ReadInt32();
                        byte[] iv = new byte[length];

                        if (skBinaryReader.Read(iv, 0, length) != length) throw new EndOfStreamException();

                        using (SymmetricKey symmetricKey = new SymmetricKey(key, iv))
                        {
                            unencryptedBuffer = symmetricKey.Decrypt(binaryReader.BaseStream);
                        }
                    }
                }

                MemoryStream wdMemoryStream = new MemoryStream(unencryptedBuffer);
                return new BinaryReader(wdMemoryStream);
            }
            catch (EndOfStreamException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XRLException(
                    HResult.XONLINE_E_DECRYPTION_ERROR,
                    XEvent.Id.WIREDATA_DECRYPTION_ERROR,
                    e, "Error decrypting wiredata buffer"
                );
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\SGInfo.cs ===
//
// SGInfo.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
//  This provides a class that exposes ticket/auth client data from the security gateway.
//
//  To use it, simply instantiate SGInfo in front-door code, and use the gettable properties
//  on this object.  Note that due to current limitations in ASP.NET, this class will NOT
//  be able to get good auth data in environments where the SG is doing port translation.
//
// Xbox Online Common Managed Code
// Xbox Online Service
//
// Author: Ben Zotto (benzotto)
//

using System;
using System.Web;
using System.IO;
using System.Net;
using System.Text;
using System.Net.Sockets;
using System.Threading;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.ServiceModel;
using System.Collections.Generic;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.utilities;
using xonline.common.utilities2;

[assembly: XomAreaDefinition(XomAreaName.sginfotrace)]

namespace xonline.common.service
{
    [ComVisible(false)]
    public class CallSource
    {
        private const string CALL_SOURCE_INFO = "CallSourceInfo";

        public static bool IsVirtualInterfacePort( string viface, ushort port )
        {
            bool isVirtualInterface = false;
            IVirtualInterfaceInfo viinfo;

            viinfo = Config.GetVirtualInterface(viface);
            if (null != viinfo)
            {
                if (viinfo.Port == port)
                {
                    isVirtualInterface = true;
                }
            }

            return isVirtualInterface;
        }

        public static string Check(params string[] virtualInterfaces)
        {
            return Check(HttpContextAdapter.Current, virtualInterfaces);
        }

        public static string Check(HttpContext context, params string[] virtualInterfaces)
        {
            return Check(new HttpContextAdapter(context), virtualInterfaces);
        }

        public static string Check(HttpContextAdapter context, params string[] virtualInterfaces)
        {
            // Check the port the request was sent to
            ushort portUsed = (ushort)context.Request.LocalEP.Port;

            foreach (string virtualInterface in virtualInterfaces)
            {
                if (! IsVirtualInterfacePort(virtualInterface, portUsed)) continue;
                context.Items[CALL_SOURCE_INFO] = virtualInterface;
                return virtualInterface;
            }

            throw new XRLException(
                HResult.XONLINE_E_CALL_SOURCE_INVALID, XEvent.Id.SGINFO_CALL_SOURCE_INVALID,
                string.Format("'{0}' called through invalid port '{1}'", context.Request.Url, portUsed)
            );
        }

        public static ushort GetPort(HttpContext ctx)
        {
            // For some reason, HttpContext.Request.Url is rather slow.
            // To help us out, xrlscan has dropped the request port into an
            // HTTP header, which seems to be quicker than getting the port
            // out of the URL. If the header is there, use it.
            string serverPort = ctx.Request.Headers[XHttpHdr.SERVERPORT];
            if (serverPort != null)
            {
                // Strangely, while the REMOTE_PORT server variable returns the port in network
                // order, so we have to byte swap it, the SERVER_PORT server variable returns
                // the port in host order, so no byte swap is required. Very confusing.
                return Convert.ToUInt16(serverPort);
            }
            else
            {
                return (ushort)(ctx.Request.Url.Port);
            }
        }

        // set the call source directly.   this is used to fake
        // out the SG and is generally only used by INH servers
        public static void Set(HttpContext context, string virtualInterface)
        {
            context.Items[CALL_SOURCE_INFO] = virtualInterface;
        }

        public static void Set(HttpContextAdapter context, string virtualInterface)
        {
            context.Items[CALL_SOURCE_INFO] = virtualInterface;
        }

        public static string Get(HttpContext context)
        {
            return (string)context.Items[CALL_SOURCE_INFO];
        }

        public static string Get(HttpContextAdapter context)
        {
            return (string) context.Items[CALL_SOURCE_INFO];
        }
    }

    [ComVisible(false)]
    public struct XUIDAndTrust : IComparable
    {
        private const uint XONLINE_USER_GUEST_MASK           = 0x00000003;
        private const uint XONLINE_USER_VOICE_NOT_ALLOWED    = 0x00010000;
        private const uint XONLINE_USER_PURCHASE_NOT_ALLOWED = 0x00020000;
        private const uint XONLINE_USER_COUNTRY_MASK         = 0x0000FF00;
        private const uint XONLINE_USER_TIER_MASK            = 0x00F00000;
        private const uint XONLINE_USER_PARENTAL_CONTROLLED  = 0x01000000;
        private const uint XONLINE_USER_LANGUAGE_MASK        = 0x3E000000;

        public ulong    qwUserID;
        public uint     dwUserFlags;
        public float    userTrust;

        public static void SetUserFlagCountry(ref uint flags, uint country)
        {
            flags &= ~XONLINE_USER_COUNTRY_MASK;
            flags |= (country<<8) & XONLINE_USER_COUNTRY_MASK;
        }

        public static void SetUserFlagLanguage(ref uint flags, uint language)
        {
            flags &= ~XONLINE_USER_LANGUAGE_MASK;
            flags |= (language<<25) & XONLINE_USER_LANGUAGE_MASK;
        }

        public static void SetUserFlagTier(ref uint flags, uint tier)
        {
            flags &= ~XONLINE_USER_TIER_MASK;
            flags |= (tier<<20) & XONLINE_USER_TIER_MASK;
        }

        public XUIDAndTrust(ulong userID, uint userFlags, float paramUserTrust)
        {
            qwUserID = userID;
            dwUserFlags = userFlags;
            userTrust = paramUserTrust;
        }

        public int CompareTo(object obj)
        {
            return qwUserID.CompareTo(((XUIDAndTrust) obj).qwUserID);
        }

        public uint GuestNumber()
        {
            return dwUserFlags & XONLINE_USER_GUEST_MASK;
        }

        public bool IsGuest()
        {
            return (GuestNumber() != 0);
        }

        public byte UserCountry()
        {
            return (byte)((dwUserFlags & XONLINE_USER_COUNTRY_MASK) >> 8);
        }

        public byte UserTier()
        {
            return (byte)((dwUserFlags & XONLINE_USER_TIER_MASK) >> 20);
        }

        public byte UserLanguage()
        {
            return (byte)((dwUserFlags & XONLINE_USER_LANGUAGE_MASK) >> 25);
        }

        public bool CanPurchase()
        {
            return ((dwUserFlags & (XONLINE_USER_GUEST_MASK | XONLINE_USER_PURCHASE_NOT_ALLOWED)) == 0);
        }
    }

    [ComVisible(false)]
    public class BundledAuthData
    {
        public const ushort HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION  = 1;
        public const ushort HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION2 = 2;

        // don't use this constructor, please provide a flow token.
        // @@@ TODO deprecate this, and v1, eventually
        public BundledAuthData(uint paramTitleID, XUIDAndTrust[] paramUsers)
        {
            wBundledAuthDataVersion = HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION;
            titleID = paramTitleID;
            users = paramUsers;
        }

        public BundledAuthData(uint paramTitleID, XUIDAndTrust[] paramUsers, Floken paramFlowToken)
        {
            wBundledAuthDataVersion = HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION2;
            titleID = paramTitleID;
            users = paramUsers;
            flowToken = paramFlowToken;
        }

        public BundledAuthData(string base64EncodedString)
        {
            BinaryReader reader = new BinaryReader(new MemoryStream(Convert.FromBase64String(base64EncodedString)));

            wBundledAuthDataVersion = reader.ReadUInt16();
            if(wBundledAuthDataVersion == HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION)
            {
                users = new XUIDAndTrust[reader.ReadUInt16()];
                titleID = reader.ReadUInt32();
                for (int i=0; i<users.Length; ++i)
                {
                    users[i] = new XUIDAndTrust(reader.ReadUInt64(), reader.ReadUInt32(), reader.ReadSingle());
                }
                flowToken = Floken.None;
            }
            else if (wBundledAuthDataVersion == HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION2)
            {
                users = new XUIDAndTrust[reader.ReadUInt16()];
                titleID = reader.ReadUInt32();
                for (int i=0; i<users.Length; ++i)
                {
                    users[i] = new XUIDAndTrust(reader.ReadUInt64(), reader.ReadUInt32(), reader.ReadSingle());
                }
                flowToken = new Floken(reader);
            }
            else
            {
                throw new ExceptionWithEventId(XEvent.Id.AUTHDATA_BAD_BUNDLED_AUTHDATA, "BundledAuthData: Auth data version ("
                    + wBundledAuthDataVersion + ") is incorrect!");
            }
        }

        public string GetBase64EncodedString()
        {
            MemoryStream memStream = new MemoryStream(users.Length * 16 + 8);

            BinaryWriter writer = new BinaryWriter(memStream);

            if (wBundledAuthDataVersion == HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION)
            {
                writer.Write(wBundledAuthDataVersion);
                writer.Write((ushort)users.Length);
                writer.Write(titleID);
                for (int i=0; i<users.Length; ++i)
                {
                    writer.Write(users[i].qwUserID);
                    writer.Write(users[i].dwUserFlags);
                    writer.Write(users[i].userTrust);
                }
            }
            else if (wBundledAuthDataVersion == HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION2)
            {
                writer.Write(wBundledAuthDataVersion);
                writer.Write((ushort)users.Length);
                writer.Write(titleID);
                for (int i=0; i<users.Length; ++i)
                {
                    writer.Write(users[i].qwUserID);
                    writer.Write(users[i].dwUserFlags);
                    writer.Write(users[i].userTrust);
                }
                flowToken.Write(writer);
            }
            else
            {
                throw new ExceptionWithEventId(XEvent.Id.AUTHDATA_BAD_BUNDLED_AUTHDATA, 
                                               "BundledAuthData: Auth data version (" + wBundledAuthDataVersion + ") is incorrect!");
            }

            return Convert.ToBase64String(memStream.ToArray());
        }
 
        public readonly uint    titleID;
        public XUIDAndTrust[]   users;
        public readonly Floken  flowToken;

        private ushort          wBundledAuthDataVersion;

        public void VerifyTitleId(uint titleId)
        {
            if (AuthToggle.Off)
                return;

            if( titleId != titleID )
            {
                throw new ExceptionWithEventId( XEvent.Id.AUTHDATA_VERIFICATION_ERROR, "BundleAuthData.Verify: Title ID *" + titleId.ToString("X") + "* (Bundle says " + titleID.ToString("X") + ") cannot be verified.");
            }
        }


    }

    [ComVisible(false)]
    public class HTTPAuthData : SGInfo
    {
        public const ushort HTTP_HEADER_AUTH_DATA_VERSION = 3;

        // @@@ Note: don't call this function, it's deprecated. please provide a floken.  
        public HTTPAuthData( ) : this( 0, 0, 0, 0, 0, 0, 0, 0 )
        {

        }

        //use this ONLY if you are using XRL common code and won't have SGInfo available (like for tools)
        public HTTPAuthData( Floken flowToken ) : this( flowToken, 0, 0, 0, 0, 0, 0, 0, 0 )
        {

        }

        // @@@ Note: don't call this function, it's deprecated. please provide a floken.  
        public HTTPAuthData(ushort port, uint ip, ulong requestId, ulong userID, uint titleID, uint serviceId1, uint serviceId2)
            : this(Floken.None, port, ip, requestId, 0, userID, titleID, serviceId1, serviceId2)
        {
        }

        public HTTPAuthData(Floken flowToken, ushort port, uint ip, ulong requestId, ulong userID, uint titleID, uint serviceId1, uint serviceId2)
            : this(flowToken, port, ip, requestId, 0, userID, titleID, serviceId1, serviceId2)
        {
        }

        // @@@ Note: don't call this function, it's deprecated. please provide a floken.  
        public HTTPAuthData(ushort port, uint ip, ulong requestId, ulong xboxID, ulong userID, uint titleID, uint serviceId1, uint serviceId2)
            : this(Floken.None, port, ip, requestId, xboxID, userID, titleID, serviceId1, serviceId2)
        {
        }

        public HTTPAuthData(Floken flowToken, ushort port, uint ip, ulong requestId, ulong xboxID, ulong userID, uint titleID, uint serviceId1, uint serviceId2)
            : base(port, ip, requestId)
        {
            // Common code initialization
            Initialize( xboxID, titleID, flowToken);

            // Set the specified user
            xUsers[0] = new XUIDAndTrust(userID, 0, 0.0F);

            // Make sure that the rest of the user array is empty
            for( int i = 1; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                xUsers[i] = new XUIDAndTrust(0, 0, 0.0F);
            }

            // Count the number of users present in the ticket
            if (userID != 0)
            {
                dwNumUsers = 1;
            }

            // Explicitly set the privileges to be cleared
            for ( int i = 0; i < XOn.XONLINE_NUM_PRIVILEGE_DWORDS; i++)
            {
                dwPrivileges[i]       = 0;
                for ( int u = 0; u < XOn.XONLINE_MAX_LOGON_USERS; u++ )
                {
                    dwUserPrivileges[u,i] = 0;
                }
            }

            // Process the supplied services
            SetService( serviceId1 );
            SetService( serviceId2 );

            // Create the alternate title ids
            for( int i = 0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++ )
            {
                dwAltTitleID[i] = 0;
            }

            key = new byte[XOn.XONLINE_KEY_LENGTH];
        }

        // @@@ Note: don't call this function, it's deprecated. please provide a floken.  
        public HTTPAuthData(ushort port, uint ip, ulong requestId, ulong xboxID, XUIDAndTrust[] users, uint titleID, uint serviceId1, uint serviceId2)
            : this(Floken.None, port, ip, requestId, xboxID, users, titleID, serviceId1, serviceId2)
        {
        }

        public HTTPAuthData(Floken flowToken, ushort port, uint ip, ulong requestId, ulong xboxID, XUIDAndTrust[] users, uint titleID, uint serviceId1, uint serviceId2)
            : base(port, ip, requestId)
        {
            // Common Code Initialization
            Initialize( xboxID, titleID, flowToken);

            // Fill in the user array
            for( int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                if (i < users.Length)
                {
                    xUsers[i] = users[i];
                }
                else
                {
                    xUsers[i] = new XUIDAndTrust(0, 0, 0.0F);
                }
                if (xUsers[i].qwUserID != 0)
                {
                    dwNumUsers++;
                }
            }

            // Explicitly set the privileges to be cleared
            for ( int i = 0; i < XOn.XONLINE_NUM_PRIVILEGE_DWORDS; i++)
            {
                dwPrivileges[i] = 0;
                for ( int u = 0; u < XOn.XONLINE_MAX_LOGON_USERS; u++ )
                {
                    dwUserPrivileges[u,i] = 0;
                }
            }

            // Process the supplied services
            SetService( serviceId1 );
            SetService( serviceId2 );

            // Create the alternate title ids
            for( int i = 0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++ )
            {
                dwAltTitleID[i] = 0;
            }

            key = new byte[XOn.XONLINE_KEY_LENGTH];
        }

        // @@@ Note: don't call this function, it's deprecated. please provide a floken.  
        public HTTPAuthData(ushort port, uint ip, ulong requestId, ulong xboxID, XUIDAndTrust[] users, uint titleID, uint serviceId1, uint serviceId2, uint[,] userPrivileges)
            : this(Floken.None, port, ip, requestId, xboxID, users, titleID, serviceId1, serviceId2, userPrivileges)
        {
        }

        public HTTPAuthData(Floken flowToken, ushort port, uint ip, ulong requestId, ulong xboxID, XUIDAndTrust[] users, uint titleID, uint serviceId1, uint serviceId2, uint[,] userPrivileges)
            : base(port, ip, requestId)
        {
            // Common Code Initialization
            Initialize( xboxID, titleID, flowToken );

            // Fill in the user array
            for( int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                if (i < users.Length)
                {
                    xUsers[i] = users[i];
                }
                else
                {
                    xUsers[i] = new XUIDAndTrust(0, 0, 0.0F);
                }
                if (xUsers[i].qwUserID != 0)
                {
                    dwNumUsers++;
                }

                // Did the caller specify privileges for this user?
                if (i >= userPrivileges.GetLength(0))
                {
                    // No, zero out the privileges then
                    for ( int j = 0; j < XOn.XONLINE_NUM_PRIVILEGE_DWORDS; j++)
                    {
                        dwUserPrivileges[i,j] = 0;
                    }
                }
                else
                {
                    // Copy in the specified privileges
                    for ( int j = 0; j < userPrivileges.GetLength(1); j++)
                    {
                        dwUserPrivileges[i,j] = userPrivileges[i,j];
                    }
                    for ( int j = userPrivileges.GetLength(1); j < XOn.XONLINE_NUM_PRIVILEGE_DWORDS; j++)
                    {
                        dwUserPrivileges[i,j] = 0;
                    }

                }

            }

            // Initialize the common privileges
            if (dwNumUsers > 0)
            {
                for (int i = 0; i < XOn.XONLINE_NUM_PRIVILEGE_DWORDS; i++)
                {
                    uint mask = 0xFFFFFFFF;

                    for (int j = 0; i < XOn.XONLINE_MAX_LOGON_USERS; j++)
                    {
                        if (xUsers[j].qwUserID == 0)
                        {
                            continue;
                        }
                        mask &= dwUserPrivileges[j,i];
                    }
                    dwPrivileges[i] = mask;
                }
            }

            // Process the supplied services
            SetService( serviceId1 );
            SetService( serviceId2 );

            // Create the alternate title ids
            for( int i = 0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++ )
            {
                dwAltTitleID[i] = 0;
            }

            key = new byte[XOn.XONLINE_KEY_LENGTH];
        }

        // Worker function
        private void Initialize(ulong xboxID, uint titleID, Floken flowtok)
        {
            // @@@ kgoodier This is highly redundant, since we called the base constructor 
            // already. It in turn calls CreateSGInfoData(), which does all of this.  
            // Should clean it up after debugging to verify this hypothesis is true.

            qwXboxID              = xboxID;
            dwTitleID             = titleID;
            wAuthDataSize         = 0;
            wMajorVersion         = 0;
            wMinorVersion         = 0;
            wBuildNumber          = 0;
            wQFENumber            = 0;
            dwTitleVersion        = 0;
            dwTitleRegion         = 0;
            dwConsoleRegion       = 0;
            dwMediaID             = 0;
            wLanguageID           = 0;
            dwAuthDataFlags       = 0;
            wNumPrivileges        = 0;
            wNumDwordServices     = 0;
            fltConsoleTrustRating = 0.0F;
            dwNumUsers            = 0;
            dwPrivileges          = new uint[XOn.XONLINE_NUM_PRIVILEGE_DWORDS];
            dwUserPrivileges      = new uint[XOn.XONLINE_MAX_LOGON_USERS,XOn.XONLINE_NUM_PRIVILEGE_DWORDS];
            dwServiceIds          = new uint[XOn.XONLINE_MAX_DWORD_SERVICEIDS];
            xUsers                = new XUIDAndTrust[XOn.XONLINE_MAX_LOGON_USERS];
            dwAltTitleID          = new uint[XOn.XONLINE_MAX_ALTERNATE_TITLE_ID];
            flowToken             = flowtok;

            // Initialize empty global privileges
            for ( int i = 0; i < XOn.XONLINE_NUM_PRIVILEGE_DWORDS; i++)
            {
                dwPrivileges[i] = 0;

                // Initialize empty user privileges
                for ( int j = 0; j < XOn.XONLINE_MAX_LOGON_USERS; j++)
                {
                    dwUserPrivileges[j,i] = 0;
                }
            }
        }

        // This only sets the privilege when it is within XONLINE_MAX_PRIVILEGE_ID - enforced by casting to byte
        public void SetPrivilege(byte privilegeId)
        {
            int nIndex    = privilegeId / 32;
            int nbitIndex = privilegeId % 32;
            uint mask    = ((uint)1) << nbitIndex;

            // Only incremement the privilege count if he hadn't seen it before
            if ((dwPrivileges[nIndex] & mask) == 0)
            {
                wNumPrivileges++;
            }

            // Set the privilege across all the users.
            dwPrivileges[nIndex] |= mask;

            // Only set per-user privileges if the user is actually present
            // No privileges to be granted to empty slots
            for (int u = 0; u < XOn.XONLINE_MAX_LOGON_USERS; u++)
            {
                if (xUsers[u].qwUserID != 0)
                {
                    dwUserPrivileges[u,nIndex] |= mask;
                }
            }
        }

        // This only sets the for a specific user slot privilege when it is
        // within XONLINE_MAX_PRIVILEGE_ID - enforced by casting to byte
        public void SetUserPrivilege(uint userSlot, byte privilegeId)
        {
            int nIndex    = privilegeId / 32;
            int nbitIndex = privilegeId % 32;
            uint mask    = ((uint)1) << nbitIndex;

            if (userSlot >= XOn.XONLINE_MAX_LOGON_USERS)
            {
                return;
            }

            // Set this privilege for the user
            dwUserPrivileges[userSlot,nIndex] |= mask;

            // If the privilege is present between all the users
            if ((dwPrivileges[nIndex] & mask) != 0)
            {
                // The top level privilege mask has this bit set so
                // de won't have to do any more work
                return;
            }

            // Build the mask of all the bit across all the present users
            for (int u = 0; u < XOn.XONLINE_MAX_LOGON_USERS; u++)
            {
                if (xUsers[u].qwUserID != 0)
                {
                    mask &= dwUserPrivileges[u,nIndex];
                }
            }

            // Finally determine if we should set that bit in the top level
            // privilege bit mask
            if (mask != 0)
            {
                dwPrivileges[nIndex] |= mask;
                wNumPrivileges++;
            }
        }

        // This will set a service id or privlege depending on where it should
        // live in the ticket
        public void SetService( uint ServiceId )
        {
            // Simple No-Op Case
            if (ServiceId == 0)
            {
                return;
            }

            // If the service is within the PRIVILEGE_ID space, set the
            // service via that mechanism
            if (ServiceId < XOn.XONLINE_MAX_PRIVILEGE_ID)
            {
                SetPrivilege( (byte) ServiceId );
                return;
            }

            // Do we have any space left in the extended services location?
            if (wNumDwordServices >= XOn.XONLINE_MAX_DWORD_SERVICEIDS)
            {
                throw new ExceptionWithEventId(XEvent.Id.AUTHDATA_NO_MORE_SERVICES_ERROR, "Too many requested services" );
            }

            // Set the service and keep track of the total
            dwServiceIds[ wNumDwordServices ] = ServiceId;
            wNumDwordServices++;
        }

        public string GetBase64EncodedString()
        {
            return ConstructBase64String();
        }
    }

    [ComVisible(false)]
    [XomPerformanceCounterCategoryAttr( "SGInfo", "XBox Online CLR Auth check component", true )]
    public class SGInfoCounters : XomPerformanceCounterCategory
    {
        [XomPerformanceCounterAttr(
            "Auth requests per second",
            "Auth requests per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter AuthRequestsPerSecond;

        [XomPerformanceCounterAttr(
            "Auth requests total",
            "Auth requests total",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter AuthRequestsTotal;

        [XomPerformanceCounterAttr(
            "Retries per second",
            "Retries per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RetriesPerSecond;

        [XomPerformanceCounterAttr(
            "Retries total",
            "Retries total",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RetriesTotal;

        [XomPerformanceCounterAttr(
            "Failed requests per second",
            "Failed requests per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailedRequestsPerSecond;

        [XomPerformanceCounterAttr(
            "Failed requests total",
            "Failed requests total",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailedRequestsTotal;

        [XomPerformanceCounterAttr(
            "Avg waiting time",
            "Average waiting time spent in auth request",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AvgWaitingTime;

        [XomPerformanceCounterAttr(
            "Avg waiting time base",
            "Avg waiting time base",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AvgWaitingTimeBase;

        static public SGInfoCounters Counters = new SGInfoCounters();
    }


    //
    //  AuthToggle: Wraps the guts of turning on/off SG auth checking by config file.
    //
    [ComVisible(false)]
    public class AuthToggle
    {
        private static bool mGotSetting = false;

        // static toggle saying whether to ignore auth data from SG
        // default to TRUE
        //
        private static bool mVerifyAuthData = true;

        // static constructor to get config settings for XBOS.
        private static void GetAuthToggle()
        {
            string r = Config.GetSetting(Setting.sginfo_verifyAuth);
            if(r != null)
            {
                r = r.ToUpper();
                if( r == "FALSE" || r == "NO" || r == "OFF" )
                {
                    // have to tell EventBuilder to not get SGInfo, or else we'll cause
                    // infinite recursion!
                    EventBuilder.ShowSGInfo = false;
                    Xom.NtEvent( XEvent.Id.MC_SGINFO_IS_OFF,
                        "SG AUTH DATA VERIFICATION HAS BEEN TURNED OFF. This should NEVER happen in production." );

                    mVerifyAuthData = false;
                }
            }
            mGotSetting = true;
        }

        public static bool On
        {
            get
            {
                if(mGotSetting == false)
                {
                    GetAuthToggle();
                }
                return (mVerifyAuthData == true);
            }
        }

        public static bool Off
        {
            get
            {
                if(mGotSetting == false)
                {
                    GetAuthToggle();
                }
                return (mVerifyAuthData == false);
            }
        }

    }

    [ComVisible(false)]
    public class SGInfo
    {
        private enum SgInfoSource
        {
            RealSg,         // From a "real" SG 
            FakeSg,         // From the FakeSgService, i.e. STF test
            HttpAuthData,   // From HTTP headers
            Placeholder,    // No headers, so a bogus local copy
            Local,          // Constructed locally
            Unknown         // Total mystery
        }

        private SgInfoSource _sgInfoSource = SgInfoSource.Unknown;  // Where did this sginfo come from?

        public bool IsSgInfoSourceInternal
        {
            get 
            { 
                return _sgInfoSource != SgInfoSource.RealSg &&
                       _sgInfoSource != SgInfoSource.FakeSg;
            }
        }

        // the following structures are defined in xonline.x for the XSGInfo stuff.
        // they are mirrored here.
        //
        private struct sgMessageHeader
        {
            public ushort _wType;
            public ushort _cbEnt;
        }
        const int sizeMessageHeader = 4;

        private struct sgMessageSpiRequest
        {
            public uint   _dwReqNum;    // request number from requester
            public uint   _ipaZ;        // this is an IN_ADDR with just the "long" part exposed
            public ushort _ipportZ;     // IP port of client on DMZ
        }
        const int sizeMessageSpiRequest = 10;

        // Unused, for reference only. sgprot.cs is a better bet.
//         private struct sgMessageSpiRequest2
//         {
//             public uint   _dwReqNum;    // request number from requester
//             public uint   _ipaZ;        // this is an IN_ADDR with just the "long" part exposed
//             public ushort _ipportZ;     // IP port of client on DMZ
//             public ushort _dwAuthDataVersion; // Maximum supported authdata version
//         }
        const int sizeMessageSpiRequest2 = 12;

        private struct sgMessageSpiResponse
        {
            public uint   _dwReqNum;
            public uint   _ipaZ;
            public ushort _ipportZ;
            public byte   _fNotFound;
        }
        const int sizeMessageSpiResponse = 11;

        protected const int XONLINE_MAX_NUMBER_SERVICE_PER_TICKET = 12;

        protected const int XONLINE_SG_MESSAGE_PORT       = 0xFFFF;
        protected const int XONLINE_SG_REQ_RETRIES        = 4;        // Number of retries. Each retry doubles prevous timeout.
        protected const int XONLINE_SG_REQ_TIMEOUT        = 200000;   // 200 milliseconds timeout for first request, doubled every subsequent request
                                                                      // Net result is 4 requests with timeouts of 200, 400, 800, and 1600 milliseconds
        public const ushort XONLINE_AUTHDATA_VERSION        = 0x02 ;
        public const ushort XONLINE_XENON_AUTHDATA_VERSION  = 0x03 ;
        public const ushort XONLINE_XENON2_AUTHDATA_VERSION = 0x04 ;

        // Not really a good namespace for this number, so we'll set the high bit.
        public const ushort XONLINE_V4V3DIFF_AUTHDATA_VERSION = 0x8004 ;

        const ushort sizeXenonAuthData = 194; // sizeof(XKERB_AD_XENON)
        const ushort sizeXenon2AuthData = 256; // sizeof(XKERB_AD_XENON2)
        const ushort sizeXenon2AuthDataReserved = 16; // sizeof(XKERB_AD_XENON2.abReserved)
        const ushort sizeV4V3DiffAuthData = 64;  // diff fields plus headers

        protected const ushort SGMSG_TYPE_SPIDATA_REQ     = 0x4710;  // CSgMsgSpiReq2
        protected const ushort SGMSG_TYPE_SPIDATA_REQ2    = 0x4716;  // CSgMsgSpiReq2
        protected const ushort SGMSG_TYPE_SPIDATA_REP     = 0x4711;  // CSgMsgSpiRep2

        protected const ushort SGMSG_TYPE_SPIDATA         = 0x4782;  // CSgMsgSpiData in the payload
        protected const ushort SGMSG_TYPE_AUTHDATA        = 0x4783;  // AuthData in the payload

        //  the following fields are in the SG Info structure. (XKERB_AD_XENON)
        //

        protected ushort    wAuthDataVersion;
        protected ushort    wAuthDataSize;        // Size of this struct in bytes

        // XBOX_LIBRARY_VERSION     clientVersion;
        protected ushort    wMajorVersion;
        protected ushort    wMinorVersion;
        protected ushort    wBuildNumber;
        protected ushort    wQFENumber;
        //

        protected uint      dwTitleID;
        protected uint      dwTitleVersion;
        protected uint      dwTitleRegion;
        protected uint      dwConsoleRegion;
        protected uint      dwMediaID;
        protected ushort    wLanguageID;

        // authdata flags
        public const uint XONLINE_AUTHDATA_FLAGS_ISXENON_MASK      = 0x01;  // Deprecated!
        public const uint XONLINE_AUTHDATA_FLAGS_ISXENONBACKCOMPAT = 0x02;
        public const uint XONLINE_AUTHDATA_FLAGS_ISDEVKIT          = 0x04;
        public const uint XONLINE_AUTHDATA_FLAGS_ISTESTKIT         = 0x08;
        public const uint XONLINE_AUTHDATA_FLAGS_ISBETAMACHINE     = 0x10;
        public const uint XONLINE_AUTHDATA_FLAGS_ISLIMITEDMACHINE  = 0x20;

        protected uint      dwAuthDataFlags;

        protected ushort    wNumPrivileges;
        protected uint[]    dwPrivileges;
        protected uint[,]   dwUserPrivileges;

        protected ulong     qwXboxID;
        protected float     fltConsoleTrustRating;

        //List of alternate title IDs
        //DWORD dwAltTitleID[XONLINE_MAX_ALTERNATE_TITLE_ID]
        protected uint[]    dwAltTitleID;

        // The flowtoken in v4 tickets
        protected Floken    flowToken;

        // Key used for signing data within a session
        protected byte[]    key;

        // The high 16 bits of dwUserFlags should come from the UODB User Table.

        protected XUIDAndTrust[]   xUsers;
        protected uint             dwNumUsers;

        // user guest range
        public const ulong XONLINE_GUEST_XUID_START                = 0x0040000000000000;
        public const ulong XONLINE_GUEST_XUID_END                  = 0x004fffffffffffff;


        protected uint     dwNumServices;
        protected ushort   wNumDwordServices;

        //DWORD dwServiceID[XONLINE_MAX_NUMBER_SERVICE_PER_TICKET];
        protected uint[]   dwServiceIds;
        //

        // the rest of the spidata structure (CSgMsgSpiData)

        protected ushort  _ipportI;                   // IP port of the client on the Internet
        protected uint    _ipaI;                      // IP address of the client on the Internet
        protected byte[]  _sgaddr;                    // SGADDR of the client
        protected ushort  _wVersionKeyEx;             // KeyEx version of the client
        protected ushort  _wFlagsKeyEx;               // Flags sent in KeyEx initiator
        protected ulong   _liNonce;                   // A random nonce associated with this session
        protected ulong   _liTimeInit;                // FILETIME marking session initiation
        protected uint    _fCs;                       // TRUE if SG is providing connection services

        // size of the spidata structure
        protected const int sizeSpiData = 54;


        // the following is the STATIC request number.  it is initialized to 0, and
        // should only be used with the Interlocked.Increment protection
        //
        protected static int staticRequestNumber = 0;

        // the instance reqnum, set when a request is first made.
        protected int thisRequestNumber;

        // config settings
        //
        protected static int _maxRetries;
        protected static int _sgTimeout;
        protected static bool _verifyTestTitleVersion;
        protected static bool _useOldProtocol;
        protected static int _supportedHttpAuthDataVersion;

        // SG ip
        protected IPAddress _srcIP;
        protected ushort    _srcPort;


        public static SGInfo Current
        {
            get
            {
                if (AuthToggle.Off)
                    return null;

                SGInfo sg = null;
                if (HttpContextAdapter.Current != null)
                {
                    sg = (SGInfo)HttpContextAdapter.Current.Items["SGInfo"];
                }

                if (sg == null)
                {
                    sg = new SGInfo();
                    if (HttpContextAdapter.Current != null)
                    {
                        HttpContextAdapter.Current.Items["SGInfo"] = sg;
                    }
                }

                return sg;
            }
        }

        // Toggle forceful retrieval of SGInfo for a flow token
        public static bool RetrieveSgInfoForFlowToken { get; set; }

        public static bool IsCached
        {
            get 
            {
                try
                {
                    return IsCachedInContext(HttpContextAdapter.Current);
                }
                catch (Exception)
                {
                    return false;
                }
            }
        }

        public static bool IsAvailable
        {
            get
            {
                try 
                {
                    return IsAvailableInContext(HttpContextAdapter.Current);
                }
                catch (Exception)
                {
                    return false;
                }
            }
        }

        public static bool IsCachedInContext(HttpContext ctx)
        {
            return IsCachedInContext(new HttpContextAdapter(ctx));
        }

        public static bool IsCachedInContext(HttpContextAdapter ctx)
        {
            try
            {
                if (ctx == null)
                {
                    return false;
                }
                return ctx.Items["SGInfo"] != null;
            }
            catch (Exception)
            {
                return false;
            }
        }

        public static bool IsAvailableInContext(HttpContext ctx)
        {
            return IsAvailableInContext(new HttpContextAdapter(ctx));
        }

        public static bool IsAvailableInContext(HttpContextAdapter ctx)
        {
            if (ctx == null)
            {
                return false;
            }

            if (IsCachedInContext(ctx))
            {
                return true;
            }

            // If request definitely came from an SG, say yes. If request did not come 
            // from an SG and there is httpauthdata available, say yes. Otherwise say no. 
            //
            // What matters is we get close to the right answer.

            try 
            {
                if (ctx.Request == null)
                {
                    return false;
                }

                // Need to be an internal interface for HttpAuthData to be valid.
                if (CallSource.Get(ctx) != null)
                {
                    string viface = CallSource.Get(ctx);
                    if (viface != VirtualInterface.None)
                    {
                        IVirtualInterfaceInfo viinfo = Config.GetVirtualInterface(viface);
                        // Interface configured for SG SGInfo or HttpAuthData SGInfo?
                        if (null != viinfo && !viinfo.NeedSGInfo)
                        {
                            // SGInfo is available if header is present, otherwise no
                            return (null != ctx.Request.Headers[XHttpHdr.HTTPAUTHDATA]);
                        }
                    }
                }

                // Looks like a real SG. So let's check the source IP/port with known 
                // SG client ranges.
                //
                // @@@ Treat Unknown as yes or no? basically means no httpcontext (not 
                // true here), no interface info (errr), or from an STF test. I think 
                // we should go with yes.
                //
                SGAddressValidator.Answer ans = SGAddressValidator.Check(ctx);
                switch (ans)
                {
                case SGAddressValidator.Answer.Yes:
                case SGAddressValidator.Answer.Unknown:
                    return true;
                case SGAddressValidator.Answer.No:
                    return false;
                default:
                    return false;
                }
            }
            catch (Exception)
            {
                return false;
            }
        }

        private static LockFreeStack<SGSocket> _socketPool = new LockFreeStack<SGSocket>();

        class SGSocket
        {
            public NativeSocket _socket;
            public byte[] _buffer;

            public SGSocket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType, int cbBuffer)
            {
                _socket = new NativeSocket(addressFamily, socketType, protocolType);
                _buffer = new byte[cbBuffer];
            }
        }

        static SGInfo()
        {
            // load config settings
            Config.SettingChange += new SettingChangeEventHandler(SettingChangeEventHandler);

            _maxRetries = Config.GetIntSetting(Setting.sginfo_maxRetries);
            _sgTimeout = Config.GetIntSetting(Setting.sginfo_timeout);
            _verifyTestTitleVersion = Config.GetBoolSetting(Setting.sginfo_verifyTestTitleVersion);

            try
            {
                _useOldProtocol = Config.GetBoolSetting(Setting.sginfo_useOldProtocol);
            }
            catch (Exception)
            {
                _useOldProtocol = true;
            }

            try
            {
                // Basically just a chicken switch
                _supportedHttpAuthDataVersion = Config.GetIntSetting(Setting.sginfo_supportedHttpAuthDataVersion);
            }
            catch (Exception)
            {
                _supportedHttpAuthDataVersion = XONLINE_XENON_AUTHDATA_VERSION;  // v3
            }

            try
            {
                RetrieveSgInfoForFlowToken = Config.GetBoolSetting(Setting.sginfo_retrieveForFlowToken);
            }
            catch (Exception)
            {
                RetrieveSgInfoForFlowToken = false;
            }
        }

        private static void SettingChangeEventHandler(object sender, SettingChangeEventArgs args)
        {
            string valueNew = args.ValueNew.ToLower();

            if (args.Setting == Setting.sginfo_maxRetries)
            {
                _maxRetries = Int32.Parse(valueNew);
            }
            else if (args.Setting == Setting.sginfo_timeout)
            {
                _sgTimeout = Int32.Parse(valueNew);
            }
            else if (args.Setting == Setting.sginfo_verifyTestTitleVersion)
            {
                _verifyTestTitleVersion = (valueNew == "1" || valueNew == "yes" || valueNew == "true" || valueNew == "on");
            }
            else if (args.Setting == Setting.sginfo_useOldProtocol)
            {
                _useOldProtocol = (valueNew == "1" || valueNew == "yes" || valueNew == "true" || valueNew == "on");
            }
            else if (args.Setting == Setting.sginfo_supportedHttpAuthDataVersion)
            {
                _supportedHttpAuthDataVersion = Int32.Parse(valueNew);
            }
            else if (args.Setting == Setting.sginfo_retrieveForFlowToken)
            {
                RetrieveSgInfoForFlowToken = (valueNew == "1" || valueNew == "yes" || valueNew == "true" || valueNew == "on");
            }
        }


        // This is a special constructor for HTTPAuthData construction
        public SGInfo(ushort port, uint ip, ulong requestId)
        {
            _sgInfoSource = SgInfoSource.Local;
            CreateSGInfoData(port, ip, requestId);
        }

        /// <summary>
        /// The default constructor will create a new SGInfo with all the current information from
        /// the security gateway.
        /// </summary>
        public SGInfo()
            : this(HttpContextAdapter.Current)
        {
        }

        public SGInfo(HttpContext ctx)
            : this(new HttpContextAdapter(ctx))
        {
        }

        public SGInfo(string sIPPort)
        {
            int colon = sIPPort.IndexOf(':');
            if (colon == -1)
            {
                throw new ExceptionWithEventId(XEvent.Id.AUTHDATA_VERIFICATION_ERROR_1, "SGIPPort invalid: " + sIPPort);
            }
            _srcIP = IPAddress.Parse(sIPPort.Substring(0,colon));
            _srcPort = (ushort)IPAddress.HostToNetworkOrder((short)Convert.ToUInt16(sIPPort.Substring(colon + 1)));

            GetInfoFromSG();
        }

        public SGInfo(IPAddress ipAddr, ushort wPort)
        {
            _srcIP = ipAddr;
            _srcPort = (ushort)IPAddress.HostToNetworkOrder((short)wPort);

            GetInfoFromSG();
        }

        public SGInfo(HttpContextAdapter ctx)
        {
            // Useful for local testing without an HttpContext.
            if (ctx == null)
            {
                return;
            }

            string httpAuthData = ctx.Request.Headers[XHttpHdr.HTTPAUTHDATA];
            string viface = VirtualInterface.None;
            bool fGetSGInfo = true;

            if (CallSource.Get(ctx) != null)
            {
                viface = CallSource.Get(ctx);
            }

            string sgIPPort = ctx.Request.Headers[XHttpHdr.SGIPPORT];
            if (sgIPPort != null)
            {
                // The UDP adaptor adds this header so the front door attempts to talk back to the
                // correct IP and port.
                // XrlScan also adds this header, because the GetServerVariables() call below
                // is incredibly expensive (for reasons beyond our understanding...)
                Xom.Trace(XomAreaName.sginfotrace, LogLevel.L_LOW, "SGIPPort header detected, value: " + sgIPPort + " (note port value is in network order)");
                // USe the last index because the address could be an IPv6 addr if running on xblob.
                int colon = sgIPPort.LastIndexOf(':');
                if (colon == -1)
                {
                    throw new ExceptionWithEventId(XEvent.Id.AUTHDATA_VERIFICATION_ERROR_1, "SGIPPort invalid: " + sgIPPort);
                }
                _srcIP = IPAddress.Parse(sgIPPort.Substring(0,colon));
                _srcPort = (ushort)IPAddress.HostToNetworkOrder((short)Convert.ToUInt16(sgIPPort.Substring(colon + 1)));
            }
            else
            {
                _srcIP = ctx.Request.RemoteEP.Address;
                _srcPort = (ushort)IPAddress.HostToNetworkOrder((short)ctx.Request.RemoteEP.Port);
            }

            if (viface != VirtualInterface.None)
            {
                IVirtualInterfaceInfo viinfo = Config.GetVirtualInterface(viface);
                if (null != viinfo)
                {
                    if (!viinfo.NeedSGInfo)
                    {
                        fGetSGInfo = false;
                    }
                }

            }

            if (fGetSGInfo)
            {
                GetInfoFromSG();

                // check this after getting the SGInfo, because we log out the info on the error.
                if (httpAuthData != null)
                {
                    throw new ExceptionWithEventId(XEvent.Id.AUTHDATA_VERIFICATION_ERROR_2, "SGInfo: This SG("+_srcIP+") tried to send us fake HTTP AuthData: " + ToString());
                }
            }
            else
            {
                GetInfoFromHttp(httpAuthData);
            }
        }

        protected void GetInfoFromSG()
        {
            // Determine source. This class stores _srcPort in network order, but 
            // SGAddressValidator requires host order.
            SGAddressValidator.Answer ans = SGAddressValidator.Check(
                _srcIP, 
                (ushort)IPAddress.NetworkToHostOrder((short)_srcPort));
            switch (ans)
            {
            case SGAddressValidator.Answer.Yes:
                _sgInfoSource = SgInfoSource.RealSg;
                break;
            case SGAddressValidator.Answer.Unknown:
            case SGAddressValidator.Answer.No:
            default:
                // with HttpContext, SGAddressValidator would report "unknown" for the 
                // fakesg (test) case. but since we're only giving it an ip address, it 
                // can't make this determination and so only returns yes/no. Thus we have 
                // to assume "no" means FakeSg, even though it could be wrong. :(
                _sgInfoSource = SgInfoSource.FakeSg;
                break;
            }

            BinaryReader sgInfo = null;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
            SGSocket sgsock;
            byte[] sgRequest;
            byte[] sgResponse = null;
            bool haveData = false;
            int recBytes = 0;
            bool fRetry = true;


            lRetry:

            try
            {
                SGInfoCounters.Counters.AuthRequestsPerSecond.Increment();
                SGInfoCounters.Counters.AuthRequestsTotal.Increment();

                Xom.Trace(XomAreaName.sginfotrace, LogLevel.L_LOW, "Requesting auth data from security gateway for user at "
                    + _srcIP.ToString() + ":" + _srcPort + "..." );

                sgsock = _socketPool.Pop();

                if (sgsock == null)
                {
                    sgsock = new SGSocket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp, 1500);
                    // removed:  is this important here?
                    // sock.Blocking = false;
                    IPEndPoint epLocal = new IPEndPoint(IPAddress.Any, 0);
                    sgsock._socket.Bind(epLocal);
                }

                // build SG request.
                sgRequest = BuildRequest(_srcIP, _srcPort);

                IPEndPoint SgMsgPort = new IPEndPoint(_srcIP, XONLINE_SG_MESSAGE_PORT);

                try
                {
                    IPEndPoint ep = new IPEndPoint(IPAddress.Any, 0);

                    // first clear any remaining traffic sitting on this old socket.
                    while (sgsock._socket.Select(0, SelectMode.SelectRead))
                    {
                        sgsock._socket.ReceiveFrom(sgsock._buffer, ref ep);
                    }

                    for(int i=0; i < _maxRetries; i++ )
                    {
                        //send the request
                        sgsock._socket.SendTo(sgRequest, SgMsgPort);

                        if(sgsock._socket.Select(_sgTimeout * 1000 * (1 << i), SelectMode.SelectRead))
                        {
                            sgResponse = sgsock._buffer;

                            recBytes = sgsock._socket.ReceiveFrom(sgResponse, ref ep);

                            if(sgResponse != null && recBytes > 0)
                            {
                                sgInfo = new BinaryReader(new MemoryStream(sgResponse));

                                // we've succeeded in getting results if we're here.
                                // see if they're meaningful.
                                haveData = VerifyResponse(sgInfo, true);

                                if (haveData)
                                {
                                    break;
                                }
                                else
                                {
                                    haveData = false;
                                    sgInfo = null;
                                    sgResponse = null;
                                    recBytes = 0;
                                }
                            }
                        }

                        SGInfoCounters.Counters.RetriesPerSecond.Increment();
                        SGInfoCounters.Counters.RetriesTotal.Increment();
                    }

                    _socketPool.Push(sgsock);
                }
                catch(Exception e)
                {
                    sgsock._socket.Shutdown(SocketShutdown.Both);
                    sgsock._socket.Close();
                    sgsock._socket = null;
                    sgsock._buffer = null;
                    sgsock = null;

                    if (fRetry == false)
                    {
                        throw new ExceptionWithEventId(XEvent.Id.AUTHDATA_SG_COMMUNICATION_ERROR, "SG("+_srcIP+"): " + e);
                    }
                    else
                    {
                        fRetry = false;
                        goto lRetry;
                    }
                }

                if(sgResponse != null && recBytes > 0)
                {
                    // @@@ kgoodier Why are we doing this twice?!

                    sgInfo = new BinaryReader(new MemoryStream(sgResponse));

                    // we've succeeded in getting results if we're here.
                    // see if they're meaningful.
                    haveData = VerifyResponse(sgInfo, true);
                }
                else
                {
                    // @@@ kgoodier better event here - maybe print out the received 
                    // response and/or received req num
                    throw new ExceptionWithEventId(XEvent.Id.COMMON_COMM_31, "SGInfo: Can't talk to SG("+_srcIP+"). Timed out after " + _maxRetries
                        + " attempts! (req #" + thisRequestNumber + "). Using old protocol: " + _useOldProtocol);

                    // @@@ if this happens too often and _useOldProtocol=false, maybe fall 
                    // back to using the old protocol?
                }

                // make sure we have valid data.
                if (haveData == false)
                {
                    throw new ExceptionWithEventId(XEvent.Id.AUTHDATA_SG_COMMUNICATION_ERROR_1, "SGInfo: can't successfully contact SG("+_srcIP
                        + ") for auth data. Using old protocol: " + _useOldProtocol);
                }

                ReadSgInfo(sgInfo, false);
            }
            catch(Exception)
            {
                SGInfoCounters.Counters.FailedRequestsPerSecond.Increment();
                SGInfoCounters.Counters.FailedRequestsTotal.Increment();

                throw;
            }
            finally
            {
                long elapsed = timeElapsed.TimeElapsed;

                SGInfoCounters.Counters.AvgWaitingTime.IncrementBy(elapsed);
                SGInfoCounters.Counters.AvgWaitingTimeBase.Increment();
            }
        }

        protected void GetInfoFromHttp(string httpAuthData)
        {
            BinaryReader sgInfo = null;

            if (httpAuthData == null)
            {
                _sgInfoSource = SgInfoSource.Placeholder;
                // This is a datacenter call, but the header is missing, so create a placeholder
                // @@@ kgoodier WHY ARE WE DOING THIS?!
                CreateSGInfoData(_srcPort, 0, 0);
            }
            else
            {
                _sgInfoSource = SgInfoSource.HttpAuthData;

                byte[] httpBytes = Convert.FromBase64String(httpAuthData);
                sgInfo = new BinaryReader(new MemoryStream(httpBytes));

                ushort version = sgInfo.ReadUInt16();
                if (version == SGMSG_TYPE_SPIDATA_REP)
                {
                    // auth data from an SG, treat it like normal sg information
                    sgInfo.BaseStream.Seek(0, SeekOrigin.Begin);

                    VerifyResponse(sgInfo, false);
                    ReadSgInfo(sgInfo, false);
                }
                else if (version == HTTPAuthData.HTTP_HEADER_AUTH_DATA_VERSION)
                {
                    _ipportI         = sgInfo.ReadUInt16();
                    _ipaI            = sgInfo.ReadUInt32();
                    _sgaddr          = null;
                    _wVersionKeyEx   = 0;
                    _wFlagsKeyEx     = 0;
                    _liNonce         = sgInfo.ReadUInt64();
                    _liTimeInit      = (ulong)DateTime.Now.Ticks;
                    _fCs             = 0;

                    ReadSgInfo(sgInfo, true);

                    // More bytes? Maybe there's a diff structure here
                    if (_supportedHttpAuthDataVersion > XONLINE_XENON_AUTHDATA_VERSION)
                    {
                        ushort wDiffVersion;
                        long bytesRemaining = sgInfo.BaseStream.Length - sgInfo.BaseStream.Position;
                        if (bytesRemaining > 2)
                        {
                            wDiffVersion = sgInfo.ReadUInt16();
                            if (wDiffVersion == XONLINE_V4V3DIFF_AUTHDATA_VERSION)
                            {
                                ReadAuthDataV4V3Diff(sgInfo);
                            }
                        }
                        // Ignore any unknown versions
                    }
                }
                else
                {
                    throw new ExceptionWithEventId(XEvent.Id.AUTHDATA_BAD_HTTP_AUTHDATA, "SGInfo: HTTP AuthData has bad version: " + version.ToString() );
                }
            }
        }

        // This is a special constructor for HTTPAuthData construction
        public void CreateSGInfoData(ushort port, uint ip, ulong requestId)
        {
            wAuthDataVersion      = XONLINE_XENON2_AUTHDATA_VERSION;
            _ipportI              = port;
            _ipaI                 = ip;
            _liNonce              = requestId;

            _sgaddr               = null;
            _wVersionKeyEx        = 0;
            _wFlagsKeyEx          = 0;
            _liTimeInit           = (ulong)DateTime.Now.Ticks;
            _fCs                  = 0;

            wMajorVersion         = 0;
            wMinorVersion         = 0;
            wBuildNumber          = 0;
            wQFENumber            = 0;
            dwTitleID             = 0;
            dwTitleVersion        = 0;
            dwTitleRegion         = 0;
            dwConsoleRegion       = 0;
            dwMediaID             = 0;
            wLanguageID           = 0;
            dwAuthDataFlags       = 0;

            wNumPrivileges        = 0;
            dwPrivileges          = new uint[XOn.XONLINE_NUM_PRIVILEGE_DWORDS];
            dwUserPrivileges      = new uint[XOn.XONLINE_MAX_LOGON_USERS,XOn.XONLINE_NUM_PRIVILEGE_DWORDS];

            wNumDwordServices     = 0;
            dwServiceIds          = new uint[XOn.XONLINE_MAX_DWORD_SERVICEIDS];

            qwXboxID              = 0;
            fltConsoleTrustRating = 0.0F;

            // users (XUIDAndTrust)
            xUsers                = new XUIDAndTrust[XOn.XONLINE_MAX_LOGON_USERS];
            dwNumUsers            = 0;

            dwAltTitleID          = new uint[XOn.XONLINE_MAX_ALTERNATE_TITLE_ID];

            // Fill in the empty users
            for( int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                xUsers[i] = new XUIDAndTrust(0, 0, 0.0F);
            }

            // Explicitly set the privileges to be cleared
            for ( int i = 0; i < XOn.XONLINE_NUM_PRIVILEGE_DWORDS; i++)
            {
                dwPrivileges[i] = 0;
                for ( int u = 0; u < XOn.XONLINE_MAX_LOGON_USERS; u++ )
                {
                    dwUserPrivileges[u,i] = 0;
                }
            }

            // Create the alternate title ids
            for( int i = 0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++ )
            {
                dwAltTitleID[i] = 0;
            }

            key = new byte[XOn.XONLINE_KEY_LENGTH];
        }

#region Serializers / deserializers
        // {{{

        private void ReadSgInfo(BinaryReader reader, bool onlyAuthData)
        {
            sgMessageHeader authHdr;
            authHdr._wType = SGMSG_TYPE_AUTHDATA;
            authHdr._cbEnt = 0;

            // if we're getting more than authdata then get ready to read the spi data.
            if (!onlyAuthData)
            {
                _ipportI         = reader.ReadUInt16();
                _ipaI            = reader.ReadUInt32();
                _sgaddr          = reader.ReadBytes(20);
                _wVersionKeyEx   = reader.ReadUInt16();
                _wFlagsKeyEx     = reader.ReadUInt16();
                _liNonce         = reader.ReadUInt64();
                _liTimeInit      = reader.ReadUInt64();
                _fCs             = reader.ReadUInt32();

                // read the spi header.
                authHdr._wType   = reader.ReadUInt16();
                authHdr._cbEnt   = reader.ReadUInt16();
            }

            wAuthDataVersion = reader.ReadUInt16();
            if ( wAuthDataVersion == XONLINE_XENON2_AUTHDATA_VERSION )
            {
                ReadXenonV2SgInfo( reader, authHdr, onlyAuthData );
            }
            else if ( wAuthDataVersion == XONLINE_XENON_AUTHDATA_VERSION )
            {
                ReadXenonSgInfo( reader, authHdr, onlyAuthData );
            }
            else if ( wAuthDataVersion == XONLINE_AUTHDATA_VERSION )
            {
                ReadV2SgInfo( reader, authHdr, onlyAuthData );
            }
            else
            {
                throw new ExceptionWithEventId(
                    XEvent.Id.AUTHDATA_BAD_SG_AUTHDATA,
                    "SGInfo: Auth data from SG("+_srcIP+") version ("
                    + wAuthDataVersion + ") is incorrect!"
                    );
            }

        }

        private void ReadXenonSgInfo(BinaryReader reader, sgMessageHeader authHdr, bool onlyAuthData)
        {

            wAuthDataSize         = reader.ReadUInt16();
            wMajorVersion         = reader.ReadUInt16();
            wMinorVersion         = reader.ReadUInt16();
            wBuildNumber          = reader.ReadUInt16();
            wQFENumber            = reader.ReadUInt16();
            dwTitleID             = reader.ReadUInt32();
            dwTitleVersion        = reader.ReadUInt32();
            dwTitleRegion         = reader.ReadUInt32();
            dwConsoleRegion       = reader.ReadUInt32();
            dwMediaID             = reader.ReadUInt32();
            wLanguageID           = reader.ReadUInt16();
            dwAuthDataFlags       = reader.ReadUInt32();
            wNumPrivileges        = reader.ReadUInt16();

            dwNumUsers            = 0;
            fltConsoleTrustRating = 0.0F;
            dwPrivileges          = new uint[XOn.XONLINE_NUM_PRIVILEGE_DWORDS];
            dwUserPrivileges      = new uint[XOn.XONLINE_MAX_LOGON_USERS,XOn.XONLINE_NUM_PRIVILEGE_DWORDS];
            xUsers                = new XUIDAndTrust[XOn.XONLINE_MAX_LOGON_USERS];
            dwServiceIds          = new uint[XOn.XONLINE_MAX_DWORD_SERVICEIDS];
            dwAltTitleID          = new uint[XOn.XONLINE_MAX_ALTERNATE_TITLE_ID];

            // read in the privileges
            for( int i = 0; i < XOn.XONLINE_NUM_PRIVILEGE_DWORDS; i++ )
            {
                dwPrivileges[i] = reader.ReadUInt32();
            }

            // read Xbox puid
            qwXboxID = reader.ReadUInt64();

            // read users (XUIDAndTrust)
            for( int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                xUsers[i] = new XUIDAndTrust(reader.ReadUInt64(), reader.ReadUInt32(), 0.0F);

                if (xUsers[i].qwUserID == 0)
                {
                    continue;
                }
                dwNumUsers++;

                // Make a per-user privilege table
                for ( int j = 0; j < XOn.XONLINE_NUM_PRIVILEGE_DWORDS; j++)
                {
                    dwUserPrivileges[i,j] = dwPrivileges[j];
                }
            }
            Xom.Trace(
                XomAreaName.sginfotrace,
                LogLevel.L_NORMAL,
                string.Format(
                    "Users:({0},{1},{2},{3})",
                    xUsers[0].qwUserID,
                    xUsers[1].qwUserID,
                    xUsers[2].qwUserID,
                    xUsers[3].qwUserID
                    )
                );

            // read user trust factors.
            for( int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                // set the user trust factor.
                xUsers[i].userTrust = reader.ReadSingle();
            }

            // read the number of extended services. Should we throw something
            // if we get more than XONLINE_MAX_DWORD_SERVICEIDS here?
            wNumDwordServices = reader.ReadUInt16();

            // read DWORD service ids
            for( int i = 0; i < XOn.XONLINE_MAX_DWORD_SERVICEIDS; i++ )
            {
                uint serviceID = reader.ReadUInt32();
                if ( serviceID != 0 )
                {
                    dwServiceIds[dwNumServices++] = serviceID;
                }
            }

            // Calculate the total number of services present
            dwNumServices = (uint)(wNumPrivileges + wNumDwordServices);

            // read alternate title IDs
            for( int i = 0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++ )
            {
                dwAltTitleID[i] = reader.ReadUInt32();
            }

            // read ticket key
            key = reader.ReadBytes((int)XOn.XONLINE_KEY_LENGTH);
        }

        private void ReadXenonV2SgInfo(BinaryReader reader, sgMessageHeader authHdr, bool onlyAuthData)
        {

            wAuthDataSize         = reader.ReadUInt16();
            wMajorVersion         = reader.ReadUInt16();
            wMinorVersion         = reader.ReadUInt16();
            wBuildNumber          = reader.ReadUInt16();
            wQFENumber            = reader.ReadUInt16();
            dwAuthDataFlags       = reader.ReadUInt32();
            qwXboxID              = reader.ReadUInt64();
            fltConsoleTrustRating = reader.ReadSingle();
            dwTitleID             = reader.ReadUInt32();
            dwTitleVersion        = reader.ReadUInt32();
            dwTitleRegion         = reader.ReadUInt32();
            dwConsoleRegion       = reader.ReadUInt32();
            dwMediaID             = reader.ReadUInt32();
            wLanguageID           = reader.ReadUInt16();
            wNumDwordServices     = reader.ReadUInt16();
            dwServiceIds          = new uint[XOn.XONLINE_MAX_DWORD_SERVICEIDS];
            dwAltTitleID          = new uint[XOn.XONLINE_MAX_ALTERNATE_TITLE_ID];
            xUsers                = new XUIDAndTrust[XOn.XONLINE_MAX_LOGON_USERS];
            dwNumUsers            = 0;
            dwPrivileges          = new uint[XOn.XONLINE_NUM_PRIVILEGE_DWORDS];
            dwUserPrivileges      = new uint[XOn.XONLINE_MAX_LOGON_USERS,XOn.XONLINE_NUM_PRIVILEGE_DWORDS];

            int i, j;

            // read DWORD service ids
            for( i = 0; i < XOn.XONLINE_MAX_DWORD_SERVICEIDS; i++ )
            {
                uint serviceID = reader.ReadUInt32();
                if ( serviceID != 0 )
                {
                    dwServiceIds[dwNumServices++] = serviceID;
                }
            }

            // read users (XUIDAndTrust)
            for( i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                xUsers[i] = new XUIDAndTrust(reader.ReadUInt64(), reader.ReadUInt32(), 0.0F);
                if (xUsers[i].qwUserID != 0)
                {
                    dwNumUsers++;
                }
            }
            Xom.Trace(
                XomAreaName.sginfotrace,
                LogLevel.L_NORMAL,
                string.Format(
                    "Users:({0},{1},{2},{3})",
                    xUsers[0].qwUserID,
                    xUsers[1].qwUserID,
                    xUsers[2].qwUserID,
                    xUsers[3].qwUserID
                    )
                );

            // read user trust factors.
            for( i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                // set the user trust factor.
                xUsers[i].userTrust = reader.ReadSingle();
            }

            // Read in privileges
            for( i = 0; i < XOn.XONLINE_NUM_BASE_SERVICES_DWORDS; i++ )
            {
                dwPrivileges[i] = reader.ReadUInt32();
            }

            // Read in machine privileges
            dwPrivileges[XOn.XONLINE_NUM_BASE_SERVICES_DWORDS] = reader.ReadUInt32();

            // Read in per-user privileges
            for ( i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                for ( j = XOn.XONLINE_NUM_COMMON_PRIVILEGES_DWORDS;
                      j < XOn.XONLINE_NUM_PRIVILEGE_DWORDS;
                      j++ )
                {
                    dwUserPrivileges[i,j] = reader.ReadUInt32();
                }

                // Was there a user present in this slot?
                if (xUsers[i].qwUserID == 0)
                {
                    continue;
                }

                // Since there is a user at this slot, copy in the base services and
                // machine privileges for this user.
                for ( j = 0;
                      j < XOn.XONLINE_NUM_COMMON_PRIVILEGES_DWORDS;
                      j++ )
                {
                    dwUserPrivileges[i,j] = dwPrivileges[j];
                }
            }

            // Are there users present?
            if (dwNumUsers > 0)
            {
                // Yes. Figure out what the least common demonimator for the
                // per-user privileges are
                for ( j = XOn.XONLINE_NUM_COMMON_PRIVILEGES_DWORDS;
                      j < XOn.XONLINE_NUM_PRIVILEGE_DWORDS;
                      j++ )
                {
                    uint mask = 0xFFFFFFFF;
                    for ( i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
                    {
                        if (xUsers[i].qwUserID == 0)
                        {
                            continue;
                        }
                        mask &= dwUserPrivileges[i,j];
                    }
                    dwPrivileges[j] = mask;
                }
            }

            // Finally, count how many privileges are set
            wNumPrivileges = 0;
            for ( i = 0; i < XOn.XONLINE_NUM_PRIVILEGE_DWORDS; i++ )
            {
                uint mask = dwPrivileges[i];

                while (mask != 0)
                {
                    mask &= (mask -1);
                    wNumPrivileges++;
                }
            }

            dwNumServices = (uint)(wNumPrivileges + wNumDwordServices);

            // read alternate title IDs
            for( i = 0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++ )
            {
                dwAltTitleID[i] = reader.ReadUInt32();
            }

            flowToken = new Floken(reader);

            // Throw away this info for now
            reader.ReadBytes( sizeXenon2AuthDataReserved );

            // read ticket key
            key = reader.ReadBytes((int)XOn.XONLINE_KEY_LENGTH);
        }

        private void ReadV2SgInfo(BinaryReader reader, sgMessageHeader authHdr, bool onlyAuthData)
        {

            wAuthDataSize         = reader.ReadUInt16();
            wMajorVersion         = reader.ReadUInt16();
            wMinorVersion         = reader.ReadUInt16();
            wBuildNumber          = reader.ReadUInt16();
            wQFENumber            = reader.ReadUInt16();
            dwTitleID             = reader.ReadUInt32();
            dwTitleVersion        = reader.ReadUInt32();
            dwTitleRegion         = reader.ReadUInt32();
            qwXboxID              = reader.ReadUInt64();
            wNumPrivileges        = 0;
            dwNumUsers            = 0;
            fltConsoleTrustRating = 0.0F;
            dwPrivileges          = new uint[XOn.XONLINE_NUM_PRIVILEGE_DWORDS];
            dwUserPrivileges      = new uint[XOn.XONLINE_MAX_LOGON_USERS,XOn.XONLINE_NUM_PRIVILEGE_DWORDS];
            xUsers                = new XUIDAndTrust[XOn.XONLINE_MAX_LOGON_USERS];
            dwServiceIds          = new uint[XOn.XONLINE_MAX_DWORD_SERVICEIDS];
            dwAltTitleID          = new uint[XOn.XONLINE_MAX_ALTERNATE_TITLE_ID];


            // read users (XUIDAndTrust)
            for( int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                xUsers[i] = new XUIDAndTrust(reader.ReadUInt64(), reader.ReadUInt32(), 0.0F);
                if (xUsers[i].qwUserID != 0)
                {
                    dwNumUsers++;
                }
            }
            Xom.Trace(
                XomAreaName.sginfotrace,
                LogLevel.L_NORMAL,
                string.Format(
                    "Users:({0},{1},{2},{3})",
                    xUsers[0].qwUserID,
                    xUsers[1].qwUserID,
                    xUsers[2].qwUserID,
                    xUsers[3].qwUserID
                    )
                );

            // read services
            dwNumServices = reader.ReadUInt32();
            for( int i = 0; i < XONLINE_MAX_NUMBER_SERVICE_PER_TICKET; i++ )
            {
                dwServiceIds[i]  = reader.ReadUInt32();
            }

            //  read additional auth data information for later auth data structures.
            if ( authHdr._wType  == SGMSG_TYPE_AUTHDATA )
            {
                // read user truct factors.
                for( int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
                {
                    // set the user trust factor.
                    xUsers[i].userTrust = reader.ReadSingle();
                }

                // read alternate title IDs
                for( int i = 0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++ )
                {
                    dwAltTitleID[i] = reader.ReadUInt32();
                }

                // read ticket key
                key = reader.ReadBytes((int)XOn.XONLINE_KEY_LENGTH);
            }
            else
            {
                for( int i = 0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++ )
                {
                    dwAltTitleID[i] = 0;
                }
                key = new byte[XOn.XONLINE_KEY_LENGTH];
            }

            // dummy data from v3 privs
            for ( int i = 0; i < XOn.XONLINE_NUM_PRIVILEGE_DWORDS; i++)
            {
                dwPrivileges[i] = 0;
                for ( int u = 0; u < XOn.XONLINE_MAX_LOGON_USERS; u++ )
                {
                    dwUserPrivileges[u,i] = 0;
                }
            }
        }

        private void ReadAuthDataV4V3Diff(BinaryReader reader)
        {
            // Note: see WriteAuthDataV4V3Diff for layout description.

            ushort wDiffSize;

            wDiffSize = reader.ReadUInt16();
            if (wDiffSize != sizeV4V3DiffAuthData)
            {
                throw new ExceptionWithEventId(
                    XEvent.Id.AUTHDATA_BAD_SG_AUTHDATA,
                    "SGInfo: Auth data from SG("+_srcIP+") version ("
                    + wAuthDataVersion + ") is incorrect! Found V4V3Diff blob "
                    + "but size is " + wDiffSize + ", expected " 
                    + sizeV4V3DiffAuthData + "."
                    );
            }

            fltConsoleTrustRating = reader.ReadSingle();
            flowToken = new Floken(reader);

            if (dwUserPrivileges == null)
            {
                dwUserPrivileges = new uint[XOn.XONLINE_MAX_LOGON_USERS,XOn.XONLINE_NUM_PRIVILEGE_DWORDS];
            }

            // Read in per-user privileges
            int i, j;
            for ( i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                for ( j = XOn.XONLINE_NUM_COMMON_PRIVILEGES_DWORDS;
                      j < XOn.XONLINE_NUM_PRIVILEGE_DWORDS;
                      j++ )
                {
                    dwUserPrivileges[i,j] = reader.ReadUInt32();
                }

                // Was there a user present in this slot?
                if (xUsers[i].qwUserID == 0)
                {
                    continue;
                }

                // Since there is a user at this slot, copy in the base services and
                // machine privileges for this user.
                for ( j = 0;
                      j < XOn.XONLINE_NUM_COMMON_PRIVILEGES_DWORDS;
                      j++ )
                {
                    dwUserPrivileges[i,j] = dwPrivileges[j];
                }
            }

            // This is actually a V4 Authdata, not a V3, so promote it.
            wAuthDataVersion = XONLINE_XENON2_AUTHDATA_VERSION;
            wAuthDataSize = sizeXenon2AuthData;
        }

        private void WriteXenonSgInfo(BinaryWriter w)
        {
            long startPosition = w.BaseStream.Position;

            int i;

            w.Write(XONLINE_XENON_AUTHDATA_VERSION);
            w.Write( (ushort) sizeXenonAuthData);
            w.Write(wMajorVersion);
            w.Write(wMinorVersion);
            w.Write(wBuildNumber);
            w.Write(wQFENumber);
            w.Write(dwTitleID);
            w.Write(dwTitleVersion);
            w.Write(dwTitleRegion);
            w.Write(dwConsoleRegion);
            w.Write(dwMediaID);
            w.Write(wLanguageID);
            w.Write(dwAuthDataFlags);

            w.Write(wNumPrivileges);
            Debug.Assert( dwPrivileges.Length == XOn.XONLINE_NUM_PRIVILEGE_DWORDS );
            for (i=0; i < dwPrivileges.Length; i++)
            {
                w.Write(dwPrivileges[i]);
            }

            w.Write(qwXboxID);
            for (i=0; i < xUsers.Length; i++)
            {
                w.Write(xUsers[i].qwUserID);
                w.Write(xUsers[i].dwUserFlags);
            }

            for (i=0; i < xUsers.Length; i++)
            {
                w.Write(xUsers[i].userTrust);
            }

            w.Write(wNumDwordServices);

            for (i=0; i < XOn.XONLINE_MAX_DWORD_SERVICEIDS; i++)
            {
                w.Write(dwServiceIds[i]);
            }

            for (i=0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++)
            {
                w.Write(dwAltTitleID[i]);
            }

            w.Write(key);
            long endPosition = w.BaseStream.Position;

            Debug.Assert( sizeXenonAuthData == (endPosition - startPosition) );
        }

        private void WriteXenonV2SgInfo(BinaryWriter w)
        {
            long startPosition = w.BaseStream.Position;

            int i,j;

            w.Write(XONLINE_XENON2_AUTHDATA_VERSION);
            w.Write( (ushort) sizeXenon2AuthData);

            w.Write(wMajorVersion);
            w.Write(wMinorVersion);
            w.Write(wBuildNumber);
            w.Write(wQFENumber);
            w.Write(dwAuthDataFlags);
            w.Write(qwXboxID);
            w.Write(fltConsoleTrustRating);
            w.Write(dwTitleID);
            w.Write(dwTitleVersion);
            w.Write(dwTitleRegion);
            w.Write(dwConsoleRegion);
            w.Write(dwMediaID);
            w.Write(wLanguageID);

            w.Write(wNumDwordServices);
            for (i=0; i < XOn.XONLINE_MAX_DWORD_SERVICEIDS; i++)
            {
                w.Write(dwServiceIds[i]);
            }

            for (i=0; i < xUsers.Length; i++)
            {
                w.Write(xUsers[i].qwUserID);
                w.Write(xUsers[i].dwUserFlags);
            }

            for (i=0; i < xUsers.Length; i++)
            {
                w.Write(xUsers[i].userTrust);
            }

            for (i=0; i < XOn.XONLINE_NUM_BASE_SERVICES_DWORDS; i++)
            {
                w.Write(dwPrivileges[i]);
            }
            w.Write(dwPrivileges[XOn.XONLINE_NUM_BASE_SERVICES_DWORDS]);

            for (i=0; i < xUsers.Length; i++)
            {
                for (j = XOn.XONLINE_NUM_COMMON_PRIVILEGES_DWORDS;
                     j < XOn.XONLINE_NUM_PRIVILEGE_DWORDS;
                     j++)
                {
                    w.Write( dwUserPrivileges[i,j] );
                }
            }

            for (i=0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++)
            {
                w.Write(dwAltTitleID[i]);
            }

            flowToken.Write(w);

            w.Write( new byte[sizeXenon2AuthDataReserved] );
            w.Write(key);

            Debug.Assert( sizeXenon2AuthData == (w.BaseStream.Position - startPosition) );
        }

        private void WriteAuthDataV4V3Diff(BinaryWriter w)
        {
            // What's new?
            //   console trust rating (4 bytes)
            //   flow token (8 bytes)
            //   per-user privileges (12 DWORDS, 48 bytes)

            long startPosition = w.BaseStream.Position;
            int i,j;

            w.Write((ushort)XONLINE_V4V3DIFF_AUTHDATA_VERSION);
            w.Write((ushort)sizeV4V3DiffAuthData);
            w.Write(fltConsoleTrustRating);
            flowToken.Write(w);

            // 96 bits, or 3 DWORDS, per user
            for (i=0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                for (j = XOn.XONLINE_NUM_COMMON_PRIVILEGES_DWORDS;
                     j < XOn.XONLINE_NUM_PRIVILEGE_DWORDS;
                     j++)
                {
                    w.Write( dwUserPrivileges[i,j] );
                }
            }

            Debug.Assert( sizeV4V3DiffAuthData == (w.BaseStream.Position - startPosition) );
        }

        // }}}
#endregion

        private byte[] BuildRequest(IPAddress ip, ushort port)
        {
            byte[] addr = ip.GetAddressBytes();
            uint ipaZ   = ((uint)addr[0]) + ((uint)addr[1] << 8) + ((uint)addr[2] << 16) + ((uint)addr[3] << 24);
            thisRequestNumber = Interlocked.Increment(ref staticRequestNumber);

            if (_useOldProtocol)
            {
                MemoryStream ms = new MemoryStream();
                BinaryWriter wr = new BinaryWriter(ms);
                sgMessageHeader header;
                sgMessageSpiRequest req;
                byte[] reqSize;

                // build the data into structs for clean maintenance
                header._wType = SGMSG_TYPE_SPIDATA_REQ;
                header._cbEnt = sizeMessageHeader + sizeMessageSpiRequest;
                req._dwReqNum = (uint)thisRequestNumber;
                req._ipaZ     = ipaZ;
                req._ipportZ  = port;

                // now stream the structs out into a byte array.
                wr.Write(header._wType);
                wr.Write(header._cbEnt);
                wr.Write(req._dwReqNum);
                wr.Write(req._ipaZ);
                wr.Write(req._ipportZ);
                reqSize = ms.ToArray();
                Debug.Assert (reqSize.Length == header._cbEnt);

                return reqSize;

            }
            else
            {
#if USEPROTOCOL
                // Not available at the moment due to XLUSE and configsn build issues. But 
                // this is the better way to do this.
                CSgMsgSpiReq2 req = new CSgMsgSpiReq2();
                req._dwReqNum = (uint)thisRequestNumber;
                req._ipaZ = ipaZ;
                req._ipportZ = port;
                req._wAuthDataVersion = XONLINE_XENON2_AUTHDATA_VERSION;
                byte[] reqBytes = req.ToArray();

                Debug.Assert(reqBytes.Length == req.header._cbEnt);
                return reqBytes;
#else
                MemoryStream ms = new MemoryStream(sizeMessageHeader + sizeMessageSpiRequest);
                BinaryWriter wr = new BinaryWriter(ms);
                ushort cbEnt = sizeMessageHeader + sizeMessageSpiRequest2;
                wr.Write((ushort)SGMSG_TYPE_SPIDATA_REQ2);
                wr.Write((ushort)cbEnt);
                wr.Write((uint)thisRequestNumber);
                wr.Write((uint)ipaZ);
                wr.Write((ushort)port);
                wr.Write((ushort)XONLINE_XENON2_AUTHDATA_VERSION);  // this is the version we want, but we'll accept older

                byte[] reqBytes = ms.ToArray();
                Debug.Assert(reqBytes.Length == cbEnt);
                return reqBytes;
#endif
            }
        }

        bool VerifyResponse(BinaryReader br, bool verifyRequestNum)
        {
            sgMessageHeader header;
            sgMessageSpiResponse reply;

            header._wType = br.ReadUInt16();
            if (header._wType != SGMSG_TYPE_SPIDATA_REP)
            {
                throw new ExceptionWithEventId (XEvent.Id.AUTHDATA_BAD_SG_AUTHDATA_1, "SGInfo: Unhandleable response type 0x" + header._wType.ToString("x"));
            }

            header._cbEnt = br.ReadUInt16();
            if (header._cbEnt != (sizeMessageHeader + sizeMessageSpiResponse))
            {
                throw new ExceptionWithEventId (XEvent.Id.AUTHDATA_BAD_SG_AUTHDATA_2, "SGInfo: Unexpected SG reply size (" + header._cbEnt + ")."
                    + " Expected size is " + (sizeMessageHeader + sizeMessageSpiResponse));
            }

            reply._dwReqNum = br.ReadUInt32();
            reply._ipaZ = br.ReadUInt32();
            reply._ipportZ = br.ReadUInt16();
            reply._fNotFound = br.ReadByte();

            // make sure reqnum is the same as the request we sent.
            if (verifyRequestNum && reply._dwReqNum != (uint)thisRequestNumber)
            {
                return false;
            }

            if (reply._fNotFound != 0)
            {
                IPAddress ipZ = new IPAddress (reply._ipaZ);
                throw new ExceptionWithEventId (XEvent.Id.AUTHDATA_BAD_SG_AUTHDATA_3, "SGInfo: SG replies saying auth data NOT FOUND for " +
                    ipZ.ToString() + ":" + reply._ipportZ + " (DMZ)");
            }

            // next reade the header on the auth data itself (as distinct from the
            // header on the SG reply, which is read above).
            header._wType = br.ReadUInt16();
            if (header._wType != SGMSG_TYPE_SPIDATA)
            {
                throw new ExceptionWithEventId (XEvent.Id.AUTHDATA_BAD_SG_AUTHDATA_4, "SGInfo: Unexpected auth payload type 0x" + header._wType.ToString("x")
                    + "... Expected type SGMSG_TYPE_SPIDATA" );
            }

            header._cbEnt = br.ReadUInt16();
            if ( header._cbEnt != sizeSpiData )
            {
                throw new ExceptionWithEventId (XEvent.Id.AUTHDATA_BAD_SG_AUTHDATA_5, "SGInfo: Unexpected SG auth data size (" + header._cbEnt + ")."
                    + " Expected size is " + sizeSpiData);
            }

            // if we made it this far, we should be ready to roll.
            return true;
        }


        public override string ToString()
        {
            try
            {
                int i;
                int count;
                StringBuilder bldr = new StringBuilder();

                if (wAuthDataVersion != XONLINE_XENON2_AUTHDATA_VERSION)
                {
                    // Only log version if not the latest
                    bldr.AppendFormat("Version: {0}\r\n", wAuthDataVersion);
                }

                // The SGIPPORT header, basically
                bldr.AppendFormat("Source: {0}:{1} ({2})\r\n",
                                  _srcIP, (ushort)IPAddress.NetworkToHostOrder((short)_srcPort),
                                  _sgInfoSource);

                // From inside the SGInfo data, presumably the Internet IP of the client.
                // Little fuzzier for HTTPAuthData.
                bldr.AppendFormat("ExternalIP: {0}:{1}\r\n",
                                  ClientIP, (ushort)IPAddress.NetworkToHostOrder((short)ClientPort));

                bldr.AppendFormat("Nonce: {0:X16}\r\n", _liNonce);
                bldr.AppendFormat("KeyExFlags: 0x{0:X}\r\n", _wFlagsKeyEx);
                bldr.Append("TitleId: 0x");
                bldr.Append(TitleId.ToString("X"));
                bldr.Append("\r\nTitleVer: 0x");
                bldr.Append(dwTitleVersion.ToString("X"));
                bldr.Append("\r\nTitleRgn: 0x");
                bldr.Append(dwTitleRegion.ToString("X"));
                bldr.Append("\r\nConsoleRgn: 0x");
                bldr.Append(dwConsoleRegion.ToString("X"));
                bldr.Append("\r\nMediaID: 0x");
                bldr.Append(dwMediaID.ToString("X"));
                bldr.Append("\r\nLanguageID: ");
                bldr.Append(wLanguageID);
                bldr.Append("\r\nAuthDataFlags: 0x");
                bldr.Append(dwAuthDataFlags.ToString("X"));

                bldr.AppendFormat("\r\nXboxLibVer: {0}.{1}.{2}.{3}", wMajorVersion, wMinorVersion, wBuildNumber, wQFENumber);
                bldr.AppendFormat("\r\nMachineId: 0x{0:X16}", MachineId);
                bldr.AppendFormat("\r\nPlatform: {0}", GetPlatformType());

                count = 0;
                for (i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++)
                {
                    if (xUsers != null && xUsers[i].qwUserID != 0)
                    {
                        bldr.Append("\r\nU" + i.ToString() + ": 0x" + xUsers[i].qwUserID.ToString("X") + " (" + xUsers[i].dwUserFlags.ToString("X") + "," + xUsers[i].userTrust.ToString() + ")");
                        ++count;
                    }

                }
                if (count == 0)
                {
                    bldr.Append("\r\nno users present.");
                }

                count = 0;
                bldr.Append("\r\nServices: ");
                for (i = 0; i < XOn.XONLINE_MAX_PRIVILEGE_ID / 2; i++)
                {
                    if ( dwPrivileges != null && IsServicePresent(i) )
                    {
                        if (++count > 1)
                            bldr.Append(",");
                        bldr.Append(i.ToString());
                    }
                }
                for (i = 0; i < XOn.XONLINE_MAX_DWORD_SERVICEIDS; i++)
                {
                    if (dwServiceIds != null && dwServiceIds[i] != 0)
                    {
                        if (++count > 1)
                            bldr.Append(",");
                        bldr.Append("0x" + dwServiceIds[i].ToString("X"));
                    }
                }
                if (count == 0)
                {
                    bldr.Append("no services present (WARNING: TEST ONLY!)");
                }

                count = 0;
                bldr.Append("\r\nPrivileges: ");
                for (i = XOn.XONLINE_MAX_PRIVILEGE_ID / 2; i < XOn.XONLINE_MAX_PRIVILEGE_ID; i++)
                {
                    if ( IsPrivilegePresent(i) )
                    {
                        if (++count > 1)
                            bldr.Append(",");
                        bldr.Append(i.ToString());
                    }
                }

                count = 0;
                for (i = 0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++)
                {
                    if (dwAltTitleID != null && dwAltTitleID[i] != 0)
                    {
                        bldr.Append("\r\nAltTitleID" + i.ToString() + ": 0x" + dwAltTitleID[i].ToString("X"));
                        ++count;
                    }
                }
                if (count == 0)
                {
                    bldr.Append("\r\nno AltTitleID present");
                }

                return bldr.ToString();
            }
            catch(Exception e)
            {
                return "Error building SGInfo.ToString(): " + e.ToString();
            }
        }


        public string ToXomLogString()
        {
            try
            {
                StringBuilder bldr = new StringBuilder();

                bldr.Append(TitleId.ToString("X8")+"|");
                bldr.Append(dwTitleVersion.ToString("X8")+"|");
                bldr.Append(dwTitleRegion.ToString("X8")+"|");
                bldr.Append(ClientIP.ToString() + "|");
                bldr.Append(MachineId.ToString("X16")+"|");

                for (int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++)
                {
                    if (xUsers != null && xUsers[i].qwUserID != 0)
                    {
                        bldr.Append(xUsers[i].qwUserID.ToString("X16") + "|" );
                    }
                    else
                    {
                        bldr.Append("0|");
                    }

                }

                return bldr.ToString();
            }
            catch(Exception e)
            {
                return "Error building SGInfo.ToXomLogString(): " + e.ToString();
            }
        }


        // public accessors and helper methods
        public ushort AuthDataVersion { get { return wAuthDataVersion; } }
        public ushort AuthDataSize { get { return wAuthDataSize; } }

        public ushort MajorVersion { get { return wMajorVersion; } }
        public ushort MinorVersion { get { return wMinorVersion; } }
        public ushort BuildNumber { get { return wBuildNumber; } }
        public ushort QFENumber { get { return wQFENumber; } }

        public uint ClientVersion
        {
            get {
                return (uint) ((MajorVersion &    0xF) << 28) |
                       (uint) ((MinorVersion &    0xF) << 24) |
                       (uint) ((BuildNumber  & 0xFFFF) <<  8) |
                       (uint)  (QFENumber    &   0xFF);
            }
        }

        public uint AltTitleId1 { get { return dwAltTitleID[ 0 ]; } }
        public uint AltTitleId2 { get { return dwAltTitleID[ 1 ]; } }
        public uint AltTitleId3 { get { return dwAltTitleID[ 2 ]; } }
        public uint AltTitleId4 { get { return dwAltTitleID[ 3 ]; } }
        public uint TitleRegion { get { return dwTitleRegion; } }
        public ushort ClientPort { get { return _ipportI; } }

        public uint TitleId
        {
            get { return dwTitleID; }
        }

        public uint TitleVersion
        {
            get { return dwTitleVersion; }
        }

        public uint ConsoleRegion
        {
            get { return dwConsoleRegion; }
        }

        public uint MediaID
        {
            get { return dwMediaID; }
        }

        public ushort LanguageID
        {
            get { return wLanguageID; }
        }

        public uint AuthDataFlags
        {
            get { return dwAuthDataFlags; }
        }

        public ulong MachineId
        {
            get { return qwXboxID; }
        }

        public IPAddress ClientIP
        {
            get { return new IPAddress(_ipaI); }
        }

        public ulong TimeSessionStarted
        {
            get { return _liTimeInit; }
        }

        public XUIDAndTrust[] LogonUsers
        {
            get { return xUsers; }
        }

        public ulong PrimaryUserXuid
        {
            get 
            {
                // Return first signed-in users. This is consistent with how we've been 
                // doing this for the BI team, but is still somewhat arbitrary.
                int userIndex = PrimaryUserIndex;
                if (userIndex >= 0)
                {
                    return xUsers[userIndex].qwUserID;
                }
                return 0;
            }
        }

        public int PrimaryUserIndex
        {
            get 
            {
                // Return first signed-in users. This is consistent with how we've been 
                // doing this for the BI team, but is still somewhat arbitrary.
                for (int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++)
                {
                    if (xUsers[i].qwUserID != 0 && !xUsers[i].IsGuest())
                    {
                        return i;
                    }
                }
                return -1;
            }
        }

        public ulong Nonce
        {
            get { return _liNonce; }
        }

        public Floken FlowToken
        {
            get { return flowToken; }
        }

        public float ConsoleTrustRating
        {
            get { return fltConsoleTrustRating; } 
        }

        public byte[] SGAddr 
        {
            get
            {
                byte[] copy = null;
                if (_sgaddr != null)
                {
                    copy = new byte[_sgaddr.Length];
                    for (int i = 0; i < _sgaddr.Length; ++i)
                    {
                        copy[i] = _sgaddr[i];
                    }
                }
                
                return copy;
            }
        }

        public bool IsUserPresent(ulong xuid)
        {
            int i;

            if (xuid != 0)
            {
                for(i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
                {
                    if(xUsers[i].qwUserID == xuid && !xUsers[i].IsGuest())
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        public bool CanUserPurchase(ulong xuid)
        {
            int i;

            if (xuid != 0)
            {
                for(i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
                {
                    if(xUsers[i].qwUserID == xuid)
                    {
                        if(xUsers[i].CanPurchase())
                        {
                            return true;
                        }
                    }
                }
            }

            // user not found, or can't purchase
            return false;
        }

        public byte GetUserCountry(ulong xuid)
        {
            int i;

            if (xuid != 0)
            {
                for(i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
                {
                    if(xUsers[i].qwUserID == xuid && !xUsers[i].IsGuest())
                    {
                        return (xUsers[i].UserCountry());
                    }
                }
            }

            // user not found
            return 0;
        }

        public byte GetUserLanguage(ulong userId)
        {
            int i;

            if (userId != 0)
            {
                for(i=0; i < XOn.XONLINE_MAX_LOGON_USERS; i++)
                {
                    if(xUsers[i].qwUserID == userId && !xUsers[i].IsGuest())
                    {
                        return xUsers[i].UserLanguage();
                    }
                }
            }

            // user not found
            return 0;
        }

        public byte GetUserTier(ulong xuid)
        {
            int i;

            if (xuid != 0)
            {
                for(i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
                {
                    if(xUsers[i].qwUserID == xuid && !xUsers[i].IsGuest())
                    {
                        return (xUsers[i].UserTier());
                    }
                }
            }

            // user not found
            return 0;
        }

        public float GetUserTrust(ulong xuid)
        {
            int i;

            if (xuid != 0)
            {
                for(i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
                {
                    if(xUsers[i].qwUserID == xuid && !xUsers[i].IsGuest())
                    {
                        return (xUsers[i].userTrust);
                    }
                }
            }

            // user not found
            return Single.NaN;
        }

        public bool IsServicePresent(XOService serviceId)
        {
            return IsServicePresent((int) serviceId);
        }

        public bool IsServicePresent(int serviceId)
        {
            // base services are represented using the privilege bits
            // dword services are stored in a separate four element array
            if ( serviceId < XOn.XONLINE_MAX_PRIVILEGE_ID )
            {
                // We explicitly don't allow the caller to determine if
                // anything other than a service is present
                if (serviceId >= XOn.MPRIVILEGE_MIN)
                {
                    return false;
                }

                // find the DWORD containing this bit
                int dwordIndex = serviceId / 32;

                // find the bit offset within the DWORD
                int bitIndex = serviceId - dwordIndex*32;

                // create the mask
                uint mask = ((uint)1) << bitIndex;

                if ( (dwPrivileges[dwordIndex] & mask) == mask )
                {
                    return true;
                }
            }
            else
            {
                for (int i=0; i < dwServiceIds.Length; i++)
                {
                    if ( dwServiceIds[i] == (uint)serviceId )
                    {
                        return true;
                    }
                }
            }

            // service not found
            return false;
        }

        public bool IsPrivilegePresent(int privilegeId)
        {
            // Explicitly don't allow the calller to check for anything
            // other than privileges
            if (privilegeId < XOn.MPRIVILEGE_MIN || 
                privilegeId >= XOn.XONLINE_MAX_PRIVILEGE_ID)
            {
                return false;
            }

            // find the DWORD containing this bit
            int dwordIndex = privilegeId / 32;

            // find the bit offset within the DWORD
            int bitIndex = privilegeId - dwordIndex*32;

            // create the mask
            uint mask = ((uint)1) << bitIndex;

            return ((dwPrivileges[dwordIndex] & mask) == mask);
        }

        public bool IsPrivilegePresent(ulong xuid, int privilegeId)
        {
            // Explicitly don't allow the calller to check for anything
            // other than privileges
            if (privilegeId < XOn.MPRIVILEGE_MIN || 
                privilegeId >= XOn.XONLINE_MAX_PRIVILEGE_ID ||
                xuid == 0)
            {
                return false;
            }

            // find the DWORD containing this bit
            int dwordIndex = privilegeId / 32;

            // find the bit offset within the DWORD
            int bitIndex = privilegeId - dwordIndex*32;

            // create the mask
            uint mask = ((uint)1) << bitIndex;

            int i;

            for (i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++)
            {
                if (xUsers[i].qwUserID == xuid && !xUsers[i].IsGuest())
                {
                    return ((dwUserPrivileges[i,dwordIndex] & mask) == mask);
                }
            }
            return false;
        }

        public byte[] GetMachinePrivileges()
        {
            List<byte> retServices = new List<byte>(64);
            for (int i = XOn.MPRIVILEGE_MIN; i < XOn.MPRIVILEGE_MAX; i++)
            {
                if (dwPrivileges != null && IsPrivilegePresent(i))
                {
                    retServices.Add((byte)i);
                }
            }
            return retServices.ToArray();
        }

        public byte[] GetUserPrivileges(ulong xuid)
        {
            List<byte> retPrivs = new List<byte>(64);
            for (int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++)
            {
                if (xUsers[i].qwUserID == xuid && !xUsers[i].IsGuest())
                {
                    for (int privilegeId = XOn.MPRIVILEGE_MAX; privilegeId < XOn.XONLINE_MAX_PRIVILEGE_ID; privilegeId++)
                    {
                        // find the DWORD containing this bit
                        int dwordIndex = privilegeId / 32;

                        // find the bit offset within the DWORD
                        int bitIndex = privilegeId - dwordIndex * 32;

                        // create the mask
                        uint mask = ((uint)1) << bitIndex;

                        bool hasPrivilege = ((dwUserPrivileges[i, dwordIndex] & mask) == mask);
                        if (hasPrivilege)
                        {
                            retPrivs.Add((byte)privilegeId);
                        }
                    }
                }
            }
            return retPrivs.ToArray();
        }

        public uint[] GetServices()
        {
            List<uint> retServices = new List<uint>(64);
            int i;
            for (i = 0; i < XOn.MPRIVILEGE_MIN; i++)
            {
                if (dwPrivileges != null && IsServicePresent(i))
                {
                    retServices.Add((uint)i);
                }
            }
            for (i = 0; i < XOn.XONLINE_MAX_DWORD_SERVICEIDS; i++)
            {
                if (dwServiceIds != null && dwServiceIds[i] != 0)
                {
                    retServices.Add(dwServiceIds[i]);
                }
            }
            return retServices.ToArray();
        }

        // PlatformType
        // Returns the client's platform type. Returns one of the XOn.XPLT_* constants.
        public byte GetPlatformType()
        {
            return GetPlatformType(HttpContextAdapter.Current);
        }

        public byte GetPlatformType(HttpContextAdapter ctx)
        {
            // Find out what sort of machine the client is. Each platform type has
            // its own range of ids so that's easy to figure out. The only trick is
            // that an Xbox 360 running in backcompat mode should be treated as an
            // Xbox 1.

            if(IsSgInfoSourceInternal)
            {
                string h = null;
                try
                {
                    if (ctx != null)
                    {
                        h = ctx.Request.Headers[XHttpHdr.XPLT];
                    }
                } catch (Exception) {}

                if (h == null)
                {
                    // generic bucket
                    return XOn.XPLT_INTERNAL;
                }
                // Expected to be: XPLT_INTERNAL_*
                byte plat = byte.Parse(h);
                return plat;
            }
            else if((this.AuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISXENONBACKCOMPAT) != 0)
            {
                return XOn.XPLT_XBOX1;
            }
            else
            {
                try
                {
                    return XOn.XboxId.GetPlatformType(this.MachineId);
                }
                catch (Exception e)
                {
                    throw new Exception(
                        string.Format("Invalid platform type. Machine-id=0x{0}, Flags=0x{1}",
                                  this.MachineId,
                                  this.AuthDataFlags), e);
                }
            }
        }

        // IsXbox360
        // Returns whether the client is Xbox360
        public bool _IsXbox360()
        {
            return GetPlatformType() == XOn.XPLT_XBOX360;
        }

        // IsXbox
        // Returns whether the client is an original Xbox
        public bool _IsXbox()
        {
            return GetPlatformType() == XOn.XPLT_XBOX1;
        }

        // IsPc
        // Returns whether the client is a PC (Panorama)
        public bool _IsPc()
        {
            return GetPlatformType() == XOn.XPLT_PC;
        }

        public static void VerifyPlatformType(params byte[] xplts)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            byte xpltFromSg = sg.GetPlatformType();
            if (!Array.Exists(xplts, delegate(byte b) { return b == xpltFromSg; }))
            {
                throw new ExceptionWithEventId(XEvent.Id.AUTHDATA_VERIFICATION_ERROR_10,
                    String.Format(
                    EnumerableFormatter.Instance,
                    "SGInfo.Verify: None of the platform types in {0:ef} can be verified (SG says {1}).",
                    xplts, xpltFromSg));
            }
        }

        // IsInternal
        // Returns whether the client is internal (cross-service communication, webcache,
        // etc.)
        public bool _IsInternal()
        {
            byte plat = GetPlatformType();
            return
                plat == XOn.XPLT_INTERNAL ||
                plat == XOn.XPLT_INTERNAL_XBOXCOM ||
                plat == XOn.XPLT_INTERNAL_ZUNE ||
                plat == XOn.XPLT_INTERNAL_XNA ||
                plat == XOn.XPLT_INTERNAL_WGX ||
                plat == XOn.XPLT_INTERNAL_LIVEN;
        }

        // IsFromLiveCache
        // Returns whether the is being made through LiveCache.
        public bool _IsFromLiveCache()
        {
            byte plat = GetPlatformType();
            return
                plat == XOn.XPLT_INTERNAL_XBOXCOM ||
                plat == XOn.XPLT_INTERNAL_ZUNE ||
                plat == XOn.XPLT_INTERNAL_XNA ||
                plat == XOn.XPLT_INTERNAL_WGX ||
                plat == XOn.XPLT_INTERNAL_LIVEN;
        }

        // IsLimited
        // Returns whether the client is marked with the Limited Machine flag
        public bool _IsLimited()
        {
            return ((this.AuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISLIMITEDMACHINE) != 0);
        }

        // IsBeta
        // Returns whether the client has the beta bit set
        public bool _IsBeta()
        {
            return ((this.dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISBETAMACHINE) != 0);
        }

        public byte[] SignWithKey( byte[] data, int offset, int count )
        {
            HMACSHA1 shaM = new HMACSHA1(key);

            shaM.ComputeHash(data, offset, count);

            return shaM.Hash;
        }

        //
        // Set of public functions to perform verification on users, machines, and titles.
        //  All of these functions will throw exceptions if data doesn't match.
        //

        public static void VerifyMachineId(ulong machineId)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            if( sg.MachineId != machineId )
            {
                throw new ExceptionWithEventId( XEvent.Id.AUTHDATA_VERIFICATION_ERROR_3, "SGInfo.Verify: Machine " + machineId.ToString("X") + " cannot be verified "
                    + "(SG says " + sg.MachineId.ToString("X") + ")");
            }
        }

        public void VerifyMachineId2(ulong machineId)
        {
            if (AuthToggle.Off)
                return;

            if( this.MachineId != machineId )
            {
                throw new ExceptionWithEventId( XEvent.Id.COMMON_HACK_61, "SGInfo.Verify: Machine " + machineId.ToString("X") + " cannot be verified "
                    + "(SG says " + this.MachineId.ToString("X") + ")");
            }
        }

        public static void VerifyServiceId(XOService serviceId)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            if( !sg.IsServicePresent(serviceId) )
            {
                throw new ExceptionWithEventId( XEvent.Id.AUTHDATA_VERIFICATION_ERROR_4, "SGInfo.Verify: Machine " + sg.MachineId.ToString("X") +
                    " is not supposed to have access to this service ("+ (int)serviceId + ")");
            }
        }

        public static void VerifyTitleId(uint titleId)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            if( titleId != sg.TitleId )
            {
                throw new ExceptionWithEventId( XEvent.Id.AUTHDATA_VERIFICATION_ERROR_5, "SGInfo.Verify: Title ID *" + titleId.ToString("X") + "* (SG says " + sg.TitleId.ToString("X")
                    + ") cannot be verified [" + "machine " + sg.MachineId.ToString("X") + "]");
            }
        }

        public void VerifyTitleId2(uint titleId)
        {
            if (AuthToggle.Off)
                return;

            if( titleId != this.TitleId )
            {
                throw new ExceptionWithEventId( XEvent.Id.COMMON_HACK_64, "SGInfo.Verify: Title ID *" + titleId.ToString("X") + "* (SG says " + this.TitleId.ToString("X")
                    + ") cannot be verified [" + "machine " + this.MachineId.ToString("X") + "]");
            }
        }

        // Returns true if the title id in the authdata is the title id of either
        // xbox dashboard, xenon dashboard or xbox.com
        public static bool IsDashboardTitleId()
        {
            if(AuthToggle.Off)
                return true;

            SGInfo sg = SGInfo.Current;

            if(sg.TitleId == XOn.DASH_TITLE_ID)
            {
                if((sg.dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISXENON_MASK) != 0)
                {
                    throw new ExceptionWithEventId(XEvent.Id.COMMON_HACK_65, string.Format(
                        "Detected xbox dashboard title id running on a xenon console. "+
                        "MachineId: 0x{0} Client-Ip: {1}",
                        sg.MachineId.ToString("X"), sg.ClientIP.ToString()));
                }

                return true;
            }
            else if(sg.TitleId == XOn.XENON_DASH_TITLE_ID)
            {
                if((sg.dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISXENON_MASK) == 0)
                {
                    throw new ExceptionWithEventId(XEvent.Id.COMMON_HACK_66, string.Format(
                        "Detected xenon dashboard title id running on a xbox console. "+
                        "MachineId: 0x{0} Client-Ip: {1}",
                        sg.MachineId.ToString("X"), sg.ClientIP.ToString()));
                }

                return true;
            }
            else if(sg.TitleId == XOn.XENON_LIVE_SIGNUP_TITLE_ID)
            {
                if((sg.dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISXENON_MASK) == 0)
                {
                    throw new ExceptionWithEventId(XEvent.Id.COMMON_HACK_67, string.Format(
                        "Detected Xenon Live Signup title id running on an Xbox console. "+
                        "MachineId: 0x{0} Client-Ip: {1}",
                        sg.MachineId.ToString("X"), sg.ClientIP.ToString()));
                }

                return true;
            }
            else if(sg.TitleId == XOn.WEB_TITLE_ID)
            {
                return true;
            }

            return false;
        }

        // Returns true if the title id in the authdata is the title id of xbox.com or zune.net
        public static bool IsWebTitleId()
        {
            if(AuthToggle.Off)
                return true;

            return (SGInfo.Current.TitleId == XOn.WEB_TITLE_ID || SGInfo.Current.TitleId == XOn.ZUNE_TITLE_ID);
        }

        // IsXbox360
        // Returns whether the client is Xbox360
        public static bool IsXbox360()
        {
            return SGInfo.Current._IsXbox360();
        }

        // IsXbox
        // Returns whether the client is an original Xbox
        public static bool IsXbox()
        {
            return SGInfo.Current._IsXbox();
        }

        // IsPc
        // Returns whether the client is a PC (Panorama)
        public static bool IsPc()
        {
            return SGInfo.Current._IsPc();
        }

        // IsInternal
        // Returns whether the client is internal (cross-service communication, webcache,
        // etc.)
        public static bool IsInternal()
        {
            return SGInfo.Current._IsInternal();
        }

        // IsFromLiveCache
        // Returns whether the call is being made through LiveCache.
        public static bool IsFromLiveCache()
        {
            return SGInfo.Current._IsFromLiveCache();
        }

        // IsLimited
        // Returns whether the client is marked with the Limited Machine flag
        public static bool IsLimited()
        {
            return SGInfo.Current._IsLimited();
        }

        // IsBeta
        // Returns whether the client is marked with the Beta Machine flag
        public static bool IsBeta()
        {
            return SGInfo.Current._IsBeta();
        }

        // IsActiveAuth
        // Returns whether this client came from the ActiveAuth module / gateway. If so,
        // SGInfo really doesn't apply, and you should be using AAInfo instead.
        public static bool IsActiveAuth()
        {
            // 1. Check context (from aamodule on local machine).
            // 2. Check headers (from authsg remotely).
            return AAInfo.IsActiveAuthAvailable;
        }

        // PlatformType
        // Returns the client's platform type. Returns one of the XOn.XPLT_* constants.
        public static byte GetPlatform()
        {
            return SGInfo.Current.GetPlatformType();
        }

        // VerifyDashboardTitleId
        // This method started out just checking the title-id but at some point it
        // started doing way more stuff. Its core goal remains, which is to restrict
        // access to account management / PII / billing APIs.
        public static void VerifyDashboardTitleId()
        {
            if(IsXbox() && IsDashboardTitleId())
            {
                // Original Xbox can only access using dashboard title id
                return;
            }

            if(IsXbox360() || IsInternal())
            {
                // Xbox 360 and internal calls have access using whatever title-id.
                // Original comment for historical purposes:
                // Xenon calls lots of account/marketplace SPIs from the HUD which uses
                // the "identity" of whatever title id it's running under. And this check
                // is breaking a bunch of scenarios. We could just remove the check from
                // all of those SPIs except that some of them are also called by Xbox and
                // we've got more confidence on xenon's security than we have on xbox's.
                // Not that this check is going to prevent much, it was more a kind of
                // assert for us anyways.
                return;
            }

            if(IsPc() && Config.GetBoolSetting(Setting.global_enableTestApis))
            {
                // PCs have access only if test APIs are enabled globally
                return;
            }

            // Access is denied to any other configuration

            throw new ExceptionWithEventId(XEvent.Id.COMMON_HACK_68, string.Format(
                    "SGInfo.VerifyDashboardTitleId: Access denied to title-id (0x{0}) / "+
                    "platform ({1}) configuration.",
                    SGInfo.Current.TitleId.ToString("X8"), SGInfo.GetPlatform().ToString()));
        }

        // Verifies if the title id in the authdata is the title id of xbox.com
        // Throws an exception if not
        public static void VerifyWebTitleId()
        {
            if(!IsWebTitleId())
            {
                throw new ExceptionWithEventId(XEvent.Id.COMMON_HACK_69, string.Format(
                    "SGInfo.VerifyDashboardTitleId: xbox.com title Id expected. Instead we got: 0x{0}",
                    SGInfo.Current.TitleId.ToString("X8")));
            }
        }

        public static void VerifyFamilyTitleId(uint titleId)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            if((titleId & XOn.TITLE_FAMILY_MASK) != (sg.TitleId & XOn.TITLE_FAMILY_MASK))
            {
                throw new ExceptionWithEventId( XEvent.Id.COMMON_HACK_70, "SGInfo.Verify: Title ID *" + titleId.ToString("X") + "* (SG says " + sg.TitleId.ToString("X")
                    + ") is not in the same family!");
            }
        }


        public static void VerifyTitleIdOrAlternate(uint titleId)
        {
            if (AuthToggle.Off)
            {
                return;
            }

            SGInfo sg = SGInfo.Current;

            if( titleId == sg.TitleId )
            {
                return;
            }

            for (int i=0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++)
            {
                if (titleId == sg.dwAltTitleID[i])
                {
                    return;
                }
            }

            throw new XRLException(HResult.XONLINE_E_INVALID_TITLE_ID, XEvent.Id.AUTHDATA_VERIFICATION_ERROR_6, "SGInfo.VerifyTitleIdOrAlternate: Title ID *" + titleId.ToString("X") + "* (SG says " + sg.TitleId.ToString("X")
                + "," + sg.dwAltTitleID[0].ToString("X")
                + "," + sg.dwAltTitleID[1].ToString("X")
                + "," + sg.dwAltTitleID[2].ToString("X")
                + "," + sg.dwAltTitleID[3].ToString("X")
                + ") cannot be verified [" + "machine " + sg.MachineId.ToString("X") + "]");
        }

        public void VerifyTitleIdOrAlternate2(uint titleId)
        {
            if (AuthToggle.Off)
            {
                return;
            }

            if( titleId == this.TitleId )
            {
                return;
            }

            for (int i=0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++)
            {
                if (titleId == this.dwAltTitleID[i])
                {
                    return;
                }
            }

            throw new XRLException(HResult.XONLINE_E_INVALID_TITLE_ID, XEvent.Id.COMMON_HACK_72, "SGInfo.VerifyTitleIdOrAlternate: Title ID *" + titleId.ToString("X") + "* (SG says " + this.TitleId.ToString("X")
                + "," + this.dwAltTitleID[0].ToString("X")
                + "," + this.dwAltTitleID[1].ToString("X")
                + "," + this.dwAltTitleID[2].ToString("X")
                + "," + this.dwAltTitleID[3].ToString("X")
                + ") cannot be verified [" + "machine " + this.MachineId.ToString("X") + "]");
        }

        public static void VerifyTitleVersion(uint titleVersion)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            // only applies to test environments when your sginfo version is 0xFFFFFFFF.
            // This is the special and hopefully temporary hack for the NULL cipher
            // scenarios.
            if (!_verifyTestTitleVersion && sg.TitleVersion == 0xFFFFFFFF)
            {
                return;
            }

            if( titleVersion != sg.TitleVersion )
            {
                throw new ExceptionWithEventId( XEvent.Id.AUTHDATA_VERIFICATION_ERROR_7, "SGInfo.Verify: Title Version *" + titleVersion.ToString("x") + "* (SG says " + sg.TitleVersion.ToString("x")
                    + ") cannot be verified [" + "machine " + sg.MachineId + "]");
            }
        }

        public static void VerifyUserId(ulong xuid)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            if( !sg.IsUserPresent(xuid) )
            {
                throw new ExceptionWithEventId( XEvent.Id.AUTHDATA_VERIFICATION_ERROR_8, "SGInfo.Verify: *User " + xuid.ToString("X") + "* cannot be verified ["
                    + "machine " + sg.MachineId.ToString("X") + "; title " + sg.TitleId.ToString("X") + "]");
            }
        }

        public static void VerifyUserCountryId(ulong xuid, byte countryId)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            if ( countryId != sg.GetUserCountry(xuid) )
            {
                throw new ExceptionWithEventId( XEvent.Id.AUTHDATA_VERIFICATION_ERROR_9,
                    "SGInfo.Verify: User country (" + xuid.ToString("x") +
                    ";" + countryId + ") cannot be verified [countryId " +
                    sg.GetUserCountry(xuid) + "]");
            }
        }

        public static void VerifyUserTier(ulong xuid, byte tier)
        {
            if (AuthToggle.Off)
                return;

            SGInfo sg = SGInfo.Current;

            if ( tier != sg.GetUserTier(xuid) )
            {
                throw new ExceptionWithEventId( XEvent.Id.COMMON_HACK_76,
                    "SGInfo.Verify: User tier (" + xuid.ToString("x") +
                    ";" + tier + ") cannot be verified [tier " +
                    sg.GetUserTier(xuid) + "]");
            }
        }


        public static void VerifyPrivilege(params byte[] privileges)
        {
            foreach (byte privilege in privileges)
            {
                if (! HasPrivilege(privilege))
                {
                    SGInfo sg = SGInfo.Current;

                    throw new XRLException(
                        HResult.XONLINE_E_ACCESS_DENIED, XEvent.Id.SGINFO_VERIFY_PRIVILEGE,
                        "SGInfo.Verify: User privilege *" + privilege.ToString() + "* cannot be verified, " +
                        "[ machine " + sg.MachineId.ToString("X") + "]"
                    );
                }
            }
        }

        public static void VerifyPrivilege(ulong xuid, params byte[] privileges)
        {
            foreach (byte privilege in privileges)
            {
                if (! HasPrivilege(xuid, privilege))
                {
                    SGInfo sg = SGInfo.Current;

                    throw new XRLException(
                        HResult.XONLINE_E_ACCESS_DENIED, XEvent.Id.SGINFO_VERIFY_PRIVILEGE,
                        "SGInfo.Verify: User privilege *" + privilege.ToString() + "* cannot be verified, " +
                        "[ user " + xuid.ToString("x") +"] " +
                        "[ machine " + sg.MachineId.ToString("X") + "]"
                    );
                }
            }

        }

        public static bool HasPrivilege(byte priv)
        {
            if (AuthToggle.Off)
                return true;

            SGInfo sg = SGInfo.Current;

            return sg.IsPrivilegePresent((int)priv);
        }

        public static bool HasPrivilege(ulong xuid, byte priv)
        {
            if (AuthToggle.Off)
                return true;

            SGInfo sg = SGInfo.Current;

            return sg.IsPrivilegePresent(xuid, (int)priv);
        }

        // GetUserLocaleList
        // Returns a list of locales for a user sorted by priority. If
        // useUserLanguage==true, the user's live language will be considered
        // and given priority to.
        public static string[] GetUserLocaleList(ulong xuid, bool useUserLanguage)
        {
            string[] list = null;

            try
            {
                if (AuthToggle.Off)
                {
                    return null;
                }

                return SGInfo.Current.GetUserLocaleList2(xuid, useUserLanguage);
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.COMMON_CODE_58, e, "Attempt to build locale threw exception.");
                list = null;
            }

            return list;
        }

        public string[] GetUserLocaleList2(ulong xuid, bool useUserLanguage)
        {
            string[] list = null;

            try
            {
                if (AuthToggle.Off)
                {
                    return null;
                }

                byte    countryId           = xuid != 0 ? this.GetUserCountry(xuid) : (byte)0;
                ushort  userLanguageId      = xuid != 0 ? this.GetUserLanguage(xuid) : (ushort)0;
                ushort  consoleLanguageId   = this.LanguageID;
                string  countryCode         = CountryDictionary.CountryCode(countryId);

                // User language takes precedent over console language
                list = Locale.BuildValidLocaleList(
                    useUserLanguage ? userLanguageId : consoleLanguageId,
                    consoleLanguageId,
                    countryCode);
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.COMMON_CODE_59, e, "Attempt to build locale threw exception.");
                list = null;
            }

            return list;
        }

        // GetPrimaryUserLocale
        // Get a locale string based on the user's country, the console's
        // language and optionally on the user's language (stored on live)
        public string GetPrimaryUserLocale()
        {
            string[] list;

            list = GetUserLocaleList2(PrimaryUserXuid, true);

            if ( (null == list) || (list.Length == 0) )
            {
                return "en-US";  // @@@ Which default?  "en-US" or String.Empty?
            }

            return list[0];
        }


        public static bool IsGuestXuid(ulong xuid)
        {
            return (xuid >= XONLINE_GUEST_XUID_START && xuid <= XONLINE_GUEST_XUID_END);
        }


        public static string ToStr()
        {
            try
            {
                return Current != null ? Current.ToString() : "(sgauth=off)";
            }
            catch(Exception e)
            {
                return "Error from SGInfo.ToString(). Exception:\n"+e.ToString();
            }
        }

        public byte[] ConstructAuthData()
        {
            return ConstructAuthData(wAuthDataVersion);
        }

        protected byte[] ConstructAuthData(ushort authdataVersion)
        {
            MemoryStream m      = new MemoryStream(300);
            BinaryWriter writer = new BinaryWriter(m);

            // Construct either a V3 or V4 authdata response based
            // upon what authdata we were passed
            if (authdataVersion == XONLINE_XENON2_AUTHDATA_VERSION)
            {
                WriteXenonV2SgInfo( writer );
            }
            else
            {
                WriteXenonSgInfo( writer );
            }
            return m.ToArray();
        }

        public static string ToBase64String()
        {
            SGInfo sg;
            if (AuthToggle.Off)
            {
                //return "Auth Data is turned off!";
                sg = new SGInfo(0, 0, 0);
            }
            else
            {
                sg = SGInfo.Current;
            }

            return sg.ConstructBase64String();
        }

        public string ConstructBase64String()
        {
            MemoryStream m = new MemoryStream(400);
            BinaryWriter w = new BinaryWriter(m);
            w.Write(HTTPAuthData.HTTP_HEADER_AUTH_DATA_VERSION);
            w.Write(_ipportI);
            w.Write(_ipaI);
            w.Write(_liNonce);

            // Always do v3 for back-compat purposes
            w.Write(ConstructAuthData(XONLINE_XENON_AUTHDATA_VERSION));

            // Append the differential to the end for modern consumers
            if (_supportedHttpAuthDataVersion > XONLINE_XENON_AUTHDATA_VERSION)
            {
                if (wAuthDataVersion == XONLINE_XENON2_AUTHDATA_VERSION)
                {
                    WriteAuthDataV4V3Diff(w);
                }
            }

            return Convert.ToBase64String(m.ToArray());
        }

        public ushort OverrideMajorVersion
        {
            get { return wMajorVersion; }
            set { wMajorVersion = value; }
        }

        public ushort OverrideMinorVersion
        {
            get { return wMinorVersion; }
            set { wMinorVersion = value; }
        }

        public ushort OverrideBuildNumber
        {
            get { return wBuildNumber; }
            set { wBuildNumber = value; }
        }

        public ushort OverrideQFENumber
        {
            get { return wQFENumber; }
            set { wQFENumber = value; }
        }


        public uint OverrideTitleID
        {
            get { return dwTitleID; }
            set { dwTitleID = value; }
        }

        public uint OverrideTitleVersion
        {
            get { return dwTitleVersion; }
            set { dwTitleVersion = value; }
        }

        public uint OverrideTitleRegion
        {
            get { return dwTitleRegion; }
            set { dwTitleRegion = value; }
        }

        public uint OverrideConsoleRegion
        {
            get { return dwConsoleRegion; }
            set { dwConsoleRegion = value; }
        }

        public uint OverrideMediaID
        {
            get { return dwMediaID; }
            set { dwMediaID = value; }
        }

        public ushort OverrideLanguageID
        {
            get { return wLanguageID; }
            set { wLanguageID = value; }
        }

        public uint OverrideAuthDataFlags
        {
            get { return dwAuthDataFlags; }
            set { dwAuthDataFlags = value; }
        }

        public ushort OverrideNumPrivileges
        {
            get { return wNumPrivileges; }
            set { wNumPrivileges = value; }
        }

        public uint[] OverridePrivileges
        {
            get { return dwPrivileges; }
            set { dwPrivileges = value; }
        }

        public uint[,] OverrideUserPrivileges
        {
            get { return dwUserPrivileges; }
            set { dwUserPrivileges = value; }
        }

        public ulong OverrideXboxID
        {
            get { return qwXboxID; }
            set { qwXboxID = value; }
        }

        public byte[] OverrideKey
        {
            get { return key; }
            set { key = value; }
        }

        public uint[] OverrideAltTitleID
        {
            get { return dwAltTitleID; }
            set { dwAltTitleID = value; }
        }

        public XUIDAndTrust[] OverrideXUsers
        {
            get { return xUsers; }
            set { xUsers = value; }
        }

        public uint[] OverrideServiceIds
        {
            get { return dwServiceIds; }
            set { dwServiceIds = value; }
        }

        public float OverrideConsoleTrustRating
        {
            get { return fltConsoleTrustRating; }
            set { fltConsoleTrustRating = value; }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\WireDataEncrypt.cs ===
using System.IO;
using System.Runtime.InteropServices;

using xonline.common.service;

namespace xonline.core.wiredata
{
    [ComVisible(false)]
    public static class WireDataEncrypt
    {
        static WireDataEncrypt()
        {
        }

        public static void Write(
            WireData              wireData,
            WireDataWriteDelegate writeDelegate,
            BinaryWriter          binaryWriter
        )
        {
            using (RsaPublicKey publicKey = new RsaPublicKey(ServiceKeyType.WIREDATA_PUBLIC_KEY))
            {
                Write(wireData, writeDelegate, binaryWriter, publicKey);
            }
        }

        public static void Write(
            WireData              wireData,
            WireDataWriteDelegate writeDelegate,
            BinaryWriter          binaryWriter,
            RsaPublicKey          publicKey
        )
        {
            binaryWriter.Write(publicKey.KeyVersion);

            // create a memory stream and write  the  symmetric
            // key components into it before encrypting it  all

            using (SymmetricKey symmetricKey = new SymmetricKey())
            {
                using (MemoryStream skMemoryStream = new MemoryStream())
                {
                    using (BinaryWriter skBinaryWriter = new BinaryWriter(skMemoryStream))
                    {
                        skBinaryWriter.Write(symmetricKey.Key.Length);
                        skBinaryWriter.Write(symmetricKey.Key);
                        skBinaryWriter.Write(symmetricKey.IV.Length);
                        skBinaryWriter.Write(symmetricKey.IV);
                    }

                    // using the latest public key, we encrypt the
                    // memory stream containing our symmetric  key

                    binaryWriter.Write(publicKey.Encrypt(skMemoryStream.ToArray()));
                }

                // now use the symmetric key to write  out  the
                // original wiredata request/respsonse  message

                using (MemoryStream wdMemoryStream = new MemoryStream())
                {
                    using (BinaryWriter wdBinaryWriter = new BinaryWriter(wdMemoryStream))
                    {
                        writeDelegate(wireData, wdBinaryWriter);
                    }

                    binaryWriter.Write(symmetricKey.Encrypt(wdMemoryStream.ToArray()));
                }
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\WireDataEncryptionAttribute.cs ===
using System;
using System.Runtime.InteropServices;

namespace xonline.core.wiredata
{
    // Attribute to place on classes to control encryption parameters

    [ComVisible(false)]
    [AttributeUsage(AttributeTargets.Class)]
    public class WireDataEncryptionAttribute : Attribute
    {
        private uint?  _version  = null;

        public static WireDataEncryptionAttribute None = new WireDataEncryptionAttribute();

        public String AsOfSchemaVersion
        {
            get { return VersionToString(_version); }
            set { _version = StringToVersion(value); }
        }

        public static uint? StringToVersion(String versionStr)
        {
            String[] split = versionStr.Split('.');
            if (split.Length != 2) throw new ArgumentException();
            return UInt32.Parse(split[0]) << 16 | UInt32.Parse(split[1]);
        }

        public static String VersionToString(uint? version)
        {
            return String.Format("{0}.{1}", ( version & 0xFFFF0000 ) >> 16, version & 0xFFFF);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\wiredata.cs ===
using System;
using System.Reflection;
using System.Collections;
using System.IO;
using System.Text;
using System.Threading;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Web;
using System.Xml.Serialization;

using xonline.common.config;
using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.WireDataBin)]
[assembly: XomAreaDefinition(XomAreaName.WireDataTxt)]

namespace xonline.common.service.reflection
{

    //
    // Attribute placed on fields of a class derived from WireData to add context to the field in order to serialize it
    //
    [ComVisible(false)]
    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Field)]
    public class WireInfoAttribute : Attribute
    {
        public int      ArraySize = -1;

        public string   SizeParam = null;

        public bool     HexString = false;

        public bool     Serialize = true;

        public bool     NullTerminate = false; // For strings, specifies that the on the wire format should be null-terminated

        public bool     MaskString = false;

        public bool     LimitString = false;   // specifies in ToString() if string length should be limited
                                               // actual limit is defined in the npdb setting wiredata_stringLimit

        public long Max
        {
            get { return _max; }
            set { MaxSet = true; _max = value; }
        }

        public long Min
        {
            get { return _min; }
            set { MinSet = true; _min = value; }
        }

        public static WireInfoAttribute None = new WireInfoAttribute();


        private long   _min       = 0;
        private long   _max       = 0;
        public bool   MaxSet      = false;
        public bool   MinSet      = false;

        public String   MinSchemaVersion
        {
            get { return VersionToString(MinSchemaVersionVal); }
            set { MinSchemaVersionVal = StringToVersion(value); }
        }

        public String   MaxSchemaVersion
        {
            get { return VersionToString(MaxSchemaVersionVal); }
            set { MaxSchemaVersionVal = StringToVersion(value); }
        }

        public uint     MinSchemaVersionVal = 0;
        public uint     MaxSchemaVersionVal = UInt32.MaxValue;

        public static uint StringToVersion(String versionStr)
        {
            String[] split = versionStr.Split('.');
            if (split.Length != 2)
                throw new ArgumentException();

            return UInt32.Parse(split[0]) << 16 | UInt32.Parse(split[1]);
        }

        public static String VersionToString(uint version)
        {
            return String.Format("{0}.{1}", ( version & 0xFFFF0000 ) >> 16, version & 0xFFFF);
        }
    }


    //
    // Wire Protocol objects should inherit from WireData to assume serialization and deserialization properties
    //
    [ComVisible(false)]
    public class WireData
    {
        // Setting this to true will dump WireData info as it's being written to a stream
        public static bool  DumpDiagnosticInfo = false;

        public static uint MakeSchemaVersion(ushort major, ushort minor)
        {
            return (uint)major << 16 | (uint)minor;
        }

        // DO NOT CHANGE THIS VALUE MANUALLY!
        //
        // It is derived from the version in wiredatacg.cs now, so please change that value only when
        // updating it to be the latest version.
        //
        public static readonly uint CurrentSchemaVersion = xonline.common.service.WireData.CurrentSchemaVersion;

        // Version of the schema to use for serializing/deserializing this object.
        [XmlIgnore]
        public uint SchemaVersion = CurrentSchemaVersion;

        // If set, you will need to manually provide array sizes when writing WireDatas
        protected bool      ManualArraySize = false;


        //
        // When going through the reflection data for a type, we downconvert the type data
        //  from the native object format to an integer representation so that we can use
        //  switch statements during serialization and deserialization.
        //
        enum TypeData
        {
            TD_BOOLEAN,
            TD_BYTE,
            TD_BYTE_ARRAY,
            TD_CHAR,
            TD_DECIMAL,
            TD_DOUBLE,
            TD_SHORT,
            TD_INT,
            TD_LONG,
            TD_SBYTE,
            TD_FLOAT,
            TD_USHORT,
            TD_UINT,
            TD_ULONG,
            TD_STRING,
            TD_DATETIME,
            TD_WIREDATA,
            TD_GUID,
            TD_UNSUPPORTED
        };


        //
        // The WireTypeInfo
        //
        private class WireTypeInfo
        {
            // Convert the type data to a friendly enum for perf
            public TypeData[]   fieldType = null;
            public FieldInfo[]  fields = null;
            public WireInfoAttribute[] wireInfo = null;
            public WireInfoAttribute myWireInfo = null;

            // Cache which fields are arrays for perf
            public bool[]       fIsArray = null;

            // These values are used to connect array types
            //  to the field that specifies the length of the field
            //  use forward to find the length field from the array field
            //  use reverse to fine the array field from the length field
            public int[]        forward = null;
            public int[]        reverse = null;

            public WireTypeInfo(int size)
            {
                fieldType = new TypeData[size];

                wireInfo = new WireInfoAttribute[size];

                fIsArray = new bool[size];

                forward = new int[size];
                reverse = new int[size];

                for (int i = 0; i < size; i++)
                {
                    fieldType[i] = TypeData.TD_UNSUPPORTED;

                    fIsArray[i] = false;

                    forward[i] = -1;
                    reverse[i] = -1;
                }
            }
        }

        private static void ListFieldsInSubclasses(Type type, ArrayList outlist)
        {
            if (type == typeof(WireData))
            {
                return;
            }

            ListFieldsInSubclasses(type.BaseType, outlist);

            FieldInfo[] fieldsRaw = type.GetFields(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);

            for (int i = 0; i < fieldsRaw.Length; i++)
            {
                outlist.Add(fieldsRaw[i]);
            }
        }

        //
        // The actual WireTypeInfo cache of all WireData types in the current assembly
        //
        private static Hashtable wireTypeInfoCache = new Hashtable();
        private static ReaderWriterLock rwlWireTypeInfoCache = new ReaderWriterLock();
        private const int LockTimeout = 30000;

        //
        // We do all the reflection processing once per type and cache
        // it in the wireTypeInfoCache hash table above.
        //
        private WireTypeInfo GetWireTypeInfo()
        {
            WireTypeInfo index = null;
            Type t = GetType();
            rwlWireTypeInfoCache.AcquireReaderLock(LockTimeout);
            try
            {
                // Do the quick check first to see if this type has already been initialized
                index = (WireTypeInfo)wireTypeInfoCache[t];
                if (index != null)
                {
                    return index;
                }

                // upgrade to a writer lock
                LockCookie lc = rwlWireTypeInfoCache.UpgradeToWriterLock(LockTimeout);
                try
                {
                    // Check to see if this WireData has already been initialized.
                    // If we blocked on the lock, the first thread to
                    // finish the operation makes the rest irrelevant.
                    index = (WireTypeInfo)wireTypeInfoCache[t];
                    if (index != null)
                    {
                        return index;
                    }

                    ArrayList fieldsList = new ArrayList();
                    ListFieldsInSubclasses(GetType(), fieldsList);
                    FieldInfo[] fields = fieldsList.ToArray(typeof(FieldInfo)) as FieldInfo[];

                    // Index this WireData derivative
                    index = new WireTypeInfo(fields.Length);

                    // Cache fields for later
                    index.fields = fields;

                    // Cache 'my' WireInfo, of this type, for later
                    index.myWireInfo = GetWireInfo(GetType());

                    for (int i = 0; i < index.fields.Length; i++)
                    {
                        FieldInfo           field = index.fields[i];
                        Type                type = field.FieldType;

                        index.wireInfo[i] = GetWireInfo(field);

                        if (type.IsArray || type == typeof(string))
                        {
                            index.fIsArray[i] = true;

                            // Get the base type of the array
                            if (type.IsArray)
                            {
                                type = type.GetElementType();
                            }

                            // Find the length specifier and setup the forward/reverse indexers
                            // but only if we actually intend to serialize this field at some
                            // point in the future
                            if (index.wireInfo[i].Serialize == true)
                            {
                                if (index.wireInfo[i].ArraySize == -1)
                                {
                                    string sizeParamName = index.wireInfo[i].SizeParam;
                                    if (sizeParamName == null)
                                    {
                                        sizeParamName = field.Name + "Len";
                                    }

                                    int j;
                                    for (j = 0; j < i; j++)
                                    {
                                        if (index.fields[j].Name == sizeParamName)
                                        {
                                            break;
                                        }
                                    }

                                    if (j == i)
                                    {
                                        throw new Exception("Field \"" + field.Name + "\" must have either an ArraySize, a SizeParam or there must be a field named \"" + field.Name + "Len\".");
                                    }

        // Something we should enable post-tsunami..
        //#if DEBUG
        //                            if (index.wireInfo[j].MaxSet == false)
        //                            {
        //                            }
        //#endif


                                    index.forward[i] = j;
                                    index.reverse[j] = i;
                                }
                                else
                                {
                                    if (index.wireInfo[i].SizeParam != null)
                                    {
                                        throw new Exception("Field \"" + field.Name + "\" can not have both a SizeParam and an ArraySize.");
                                    }
                                }
                            }
                        }

                        // Convert the FieldType info into our private enum
                        TypeData    td = TypeData.TD_UNSUPPORTED;
                        bool        fHex = false;

                        if (type.IsSubclassOf(typeof(Enum)))
                        {
                            type = Enum.GetUnderlyingType(type);
                        }

                        if (type == typeof(bool))
                        {
                            td = TypeData.TD_BOOLEAN;
                        }
                        else if (type == typeof(byte))
                        {
                            if(index.fIsArray[i])
                            {
                                td = TypeData.TD_BYTE_ARRAY;
                            }
                            else
                            {
                                td = TypeData.TD_BYTE;
                                fHex = index.wireInfo[i].HexString;
                            }
                        }
                        else if (type == typeof(char))
                        {
                            td = TypeData.TD_CHAR;
                        }
                        else if (type == typeof(decimal))
                        {
                            td = TypeData.TD_DECIMAL;
                        }
                        else if (type == typeof(double))
                        {
                            td = TypeData.TD_DOUBLE;
                        }
                        else if (type == typeof(short))
                        {
                            td = TypeData.TD_SHORT;
                            fHex = index.wireInfo[i].HexString;
                        }
                        else if (type == typeof(int))
                        {
                            td = TypeData.TD_INT;
                            fHex = index.wireInfo[i].HexString;
                        }
                        else if (type == typeof(long))
                        {
                            td = TypeData.TD_LONG;
                            fHex = index.wireInfo[i].HexString;
                        }
                        else if (type == typeof(sbyte))
                        {
                            td = TypeData.TD_SBYTE;
                        }
                        else if (type == typeof(float))
                        {
                            td = TypeData.TD_FLOAT;
                        }
                        else if (type == typeof(ushort))
                        {
                            td = TypeData.TD_USHORT;
                            fHex = index.wireInfo[i].HexString;
                        }
                        else if (type == typeof(uint))
                        {
                            td = TypeData.TD_UINT;
                            fHex = index.wireInfo[i].HexString;
                        }
                        else if (type == typeof(ulong))
                        {
                            td = TypeData.TD_ULONG;
                            fHex = index.wireInfo[i].HexString;
                        }
                        else if (type == typeof(string))
                        {
                            td = TypeData.TD_STRING;
                        }
                        else if (type == typeof(DateTime))
                        {
                            td = TypeData.TD_DATETIME;
                        }
                        else if (type == typeof(Guid))
                        {
                            td = TypeData.TD_GUID;
                        }
                        else if (type.IsSubclassOf(typeof(WireData)))
                        {
                            td = TypeData.TD_WIREDATA;
                        }

                        if (td == TypeData.TD_UNSUPPORTED)
                        {
                            throw new Exception("Type \"" + type.ToString() + "\" not supported.");
                        }

                        index.fieldType[i] = td;

                        if (fHex != index.wireInfo[i].HexString)
                        {
                            throw new Exception("Type \"" + type.ToString() + "\" cannot be output in hexadecimal.");
                        }

                    }

                    wireTypeInfoCache.Add(GetType(), index);
                    return index;
                }
                finally
                {
                    rwlWireTypeInfoCache.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                rwlWireTypeInfoCache.ReleaseReaderLock();
            }
        }

        //
        // Retrieve the WireInfo attributes from the memberinfo specified
        //
        private WireInfoAttribute GetWireInfo(MemberInfo info)
        {
            object[] attribs = info.GetCustomAttributes(typeof(WireInfoAttribute), false);
            int len = attribs.Length;

            Debug.Assert(len == 0 || len == 1);

            if (len == 1)
            {
                return (WireInfoAttribute)attribs[0];
            }
            else
            {
                return WireInfoAttribute.None;
            }
        }

        // How much to indent nested object and array members when converting to a string
        private const int C_INDENT = 2;

        //
        // Provide a formatted ToString method so that we can get good debug output in exceptions/events/logs
        //  this method uses reflection, and will be SLOW! Only use in exceptional cases, not in
        //  high performance codepaths.
        //
        public virtual string ToString(int indent)
        {
            Type type = GetType();
            WireTypeInfo index = GetWireTypeInfo();

            StringBuilder str = new StringBuilder();
            str.Append(type.Name + " {\n");

            for (int i = 0; i < index.fields.Length; i++)
            {
                FieldInfo       field = index.fields[i];
                object          o = field.GetValue(this);

                if ((o != null) && (index.fIsArray[i]) && (index.fieldType[i] != TypeData.TD_STRING) && (index.fieldType[i] != TypeData.TD_BYTE_ARRAY))
                {
                    int actualArraySize = (o as Array).Length;

                    str.Append("".PadLeft(indent + C_INDENT) + field.Name + " is an array of length " + actualArraySize + "\n");

                    for (int j = 0; j < actualArraySize; j++)
                    {
                        object val = (o as Array).GetValue(j);

                        str.Append("".PadLeft(indent + C_INDENT) + field.Name + "[" + j + "]");

                        // Check for array of complex type
                        if (index.fieldType[i] == TypeData.TD_WIREDATA)
                        {
                            str.Append("=" + (val as WireData).ToString(indent + C_INDENT) + "\n");
                        }
                        else
                        {
                            str.Append("=" + PrintValue(val, index.fieldType[i], index.wireInfo[i].HexString, index.wireInfo[i].LimitString, index.wireInfo[i].MaskString) + "\n");
                        }
                    }
                }
                else
                {
                    str.Append("".PadLeft(indent + C_INDENT) + field.Name);

                    if (o == null)
                    {
                        str.Append("= null\n");
                    }
                    // Check for complex type
                    else if (index.fieldType[i] == TypeData.TD_WIREDATA)
                    {
                        str.Append("=" + (o as WireData).ToString(indent + C_INDENT) + "\n");
                    }
                    else
                    {
                        str.Append("=" + PrintValue(o, index.fieldType[i], index.wireInfo[i].HexString, index.wireInfo[i].LimitString, index.wireInfo[i].MaskString) + "\n");
                    }
                }
            }

            str.Append("".PadLeft(indent) + "}");

            return str.ToString();
        }

        // Format a byte array as a hex string
        static protected string ByteArrayToString(byte[] bin)
        {
            StringBuilder str = new StringBuilder(bin.Length * 2 + 1);
            for(int i=0; i < bin.Length; i++)
            {
                str.Append(bin[i].ToString("x2"));
            }

            return str.ToString();
        }


        //
        // Override the ToString method so that we can get good debug output in exceptions/events/logs
        //  this method uses reflection, and will be SLOW! Only use in exceptional cases, not in
        //  high performance codepaths.
        //
        public override string ToString()
        {
            return ToString(0);
        }


        //
        // Log to the appropriate log area
        //
        protected string LogBinary(Stream stream)
        {
            string result = "";

            if (stream.CanSeek && stream.CanRead)
            {
                long position = stream.Position;
                long length = stream.Length;

                int bytesToRead = (int)(length - position);
                int bytesRead = 0;

                byte []     bytes = new byte[bytesToRead];

                while (bytesToRead > 0)
                {
                    int n = stream.Read(bytes, bytesRead, bytesToRead);

                    if (n == 0)
                    {
                        break;
                    }

                    bytesRead += n;
                    bytesToRead -=n;
                }

                string[]    lines = ByteConvert.ToFormattedStrings(bytes);

                foreach (string s in lines)
                {
                    Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, s);
                }

                // Put things back the way they were when we started
                stream.Seek(position, SeekOrigin.Begin);

            }
            else
            {
                result = "unsupported stream type.";
            }

            return result;
        }


        //
        // Log to the appropriate log area
        //
        protected string LogText()
        {
            string     delimiter = "\n";
            string []  lines = this.ToString(0).Split(delimiter.ToCharArray());

            foreach (string s in lines)
            {
                Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, s);
            }

            return "";
        }


        //
        // Read a bunch of bytes into a WireData object
        //
        public WireData ReadBytes(byte[] bytes)
        {
            return ReadStream(new MemoryStream(bytes));
        }

        //
        // Read a stream into a WireData object
        //
        public virtual WireData ReadStream(Stream stream)
        {
            // Create the reader, uses UTF8 decoding by default
            return ReadStream(new BinaryReader(stream));
        }

        //
        // Read from a BinaryReader into a WireData object
        //  Strings are decoded with UTF8.
        //  DateTime is converted from a 64 bit systime and is represented in LocalTime
        //
        public virtual WireData ReadStream(BinaryReader binaryReader)
        {
            WireTypeInfo index = GetWireTypeInfo();

            // Log the input buffer
            Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, "WireData Binary Input:");
            Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, LogBinary(binaryReader.BaseStream));

            for (int i = 0; i < index.fields.Length; i++)
            {
                FieldInfo    field = index.fields[i];

                object       o = null;

                if (index.wireInfo[i].Serialize == false ||
                        this.SchemaVersion < index.wireInfo[i].MinSchemaVersionVal ||
                        this.SchemaVersion > index.wireInfo[i].MaxSchemaVersionVal)
                {
                    continue;
                }

                try
                {
                    // Handle arrays
                    if (index.fIsArray[i])
                    {
                        int size = index.wireInfo[i].ArraySize;

                        if (size == -1)
                        {
                            try
                            {
                                size = Convert.ToInt32(index.fields[index.forward[i]].GetValue(this));
                            }
                            catch(InvalidCastException e)
                            {
                                throw new Exception("Field \"" + field.Name + "\" is not an index (numeric) type.", e);
                            }
                        }

                        if (field.FieldType == typeof(string))
                        {
                            string s = new UTF8Encoding().GetString(binaryReader.ReadBytes(size));
                            int termPos = s.IndexOf((char)0);

                            if (termPos > 0)
                            {
                                o = s.Substring(0, s.IndexOf((char)0));
                            }
                            else if (termPos == -1)
                            {
                                o = s;
                            }
                            else
                            {
                                o = "";
                            }
                        }
                        else if(index.fieldType[i] == TypeData.TD_BYTE_ARRAY)
                        {
                            o = binaryReader.ReadBytes(size);
                            // bugs 24888, 31444
                            // Win2k SP2 doesn't throw if size bytes can't be read, it just quietly ignores it..
                            if (((byte[])o).Length < size)
                            {
                                throw new EndOfStreamException("Unable to read " + size + " bytes from stream; only found " + ((byte[])o).Length);
                            }
                        }
                        else
                        {
                            Type[] types = {typeof(int)};
                            object[] param = {size};

                            o = field.FieldType.GetConstructor(types).Invoke(param);

                            for (int j = 0; j < size; j++)
                            {
                                (o as Array).SetValue(ReadValue(binaryReader, index.fieldType[i], field.FieldType.GetElementType(), null), j);
                            }
                        }
                    }
                    else
                    {
                        // For nested WireData objects, default constructors may have already initialized child objects
                        //  with valid state. An example of this is Presence protocol structures that set up a container
                        //  reference to the parent object at construction. In these cases, we want to just use the
                        //  already created object and fill in the values rather than constructing a new one.
                        if (index.fieldType[i] == TypeData.TD_WIREDATA)
                        {
                            o = field.GetValue(this);
                        }

                        o = ReadValue(binaryReader, index.fieldType[i], field.FieldType, o);

                        // check max/min range
                        CheckRange(o, index.wireInfo[i], index.fieldType[i], field.Name);
                    }
                }
                catch (EndOfStreamException e)
                {
                    throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.WIREDATA_END_OF_STREAM, "Reached end of stream trying to read " + field.Name, e);
                }


                field.SetValue(this, o);
            }

            // Log text representation
            Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, "WireData Text Input: ");
            Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, LogText());

            return this;
        }

        private void CheckRange(object o, WireInfoAttribute wireInfo, TypeData typeData, string name)
        {
            long val;

            switch (typeData)
            {
            case TypeData.TD_BYTE:
                val = (long)(byte)o;
                break;

            case TypeData.TD_SHORT:
                val = (long)(short)o;
                break;

            case TypeData.TD_INT:
                val = (long)(int)o;
                break;

            case TypeData.TD_LONG:
                val = (long)(long)o;
                break;

            case TypeData.TD_SBYTE:
                val = (long)(sbyte)o;
                break;

            case TypeData.TD_FLOAT:
                val = (long)(float)o;
                break;

            case TypeData.TD_USHORT:
                val = (long)(ushort)o;
                break;

            case TypeData.TD_UINT:
                val = (long)(uint)o;
                break;

            case TypeData.TD_ULONG:
                val = (long)(ulong)o;
                break;

            default:
                // numeric type, nothing to do
                return;
            }


            if (wireInfo.MaxSet == true && val > wireInfo.Max)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MC_BAD_PARAMETER,
                    "The value specified for field "  + name + " (" + val + ") exceeds the Max allowed value (" + wireInfo.Max + ") !");
            }

            if (wireInfo.MinSet == true && val < wireInfo.Min)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MC_BAD_PARAMETER_1,
                    "The value specified for field "  + name + " (" +  val + ") is less than the Min allowed value (" + wireInfo.Min + ") !");
            }
        }

        //
        // Override the operator byte[] to allow assigning a WireData object directly to a byte array.
        //
        public static explicit operator byte[](WireData wiredata)
        {
            MemoryStream stream = new MemoryStream();
            wiredata.WriteStream(stream);

            return stream.ToArray();
        }

        // Adding ToArray, as writing an explicit cast looks a little odd.
        public byte[] ToArray()
        {
            return (byte[])this;
        }

        //
        // Write a WireData object to the given stream
        //
        public virtual void WriteStream(Stream stream)
        {
            // Create the writer, uses UTF8 encoding by default
            WriteStream(new BinaryWriter(stream));
        }


        //
        // Write a WireData object to the given binaryWriter
        //  Strings are encoded with UTF8.
        //  DateTime is converted to a 64 bit systime in UTC
        //
        public virtual void WriteStream(BinaryWriter binaryWriter)
        {
            WireTypeInfo index = GetWireTypeInfo();

            // Log text representation
            Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, "WireData Text Output: ");
            Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_NORMAL, LogText());

            for (int i = 0; i < index.fields.Length; i++)
            {
                FieldInfo field = index.fields[i];

                if (index.wireInfo[i].Serialize == false ||
                        this.SchemaVersion < index.wireInfo[i].MinSchemaVersionVal ||
                        this.SchemaVersion > index.wireInfo[i].MaxSchemaVersionVal)
                {
                    continue;
                }

                if (WireData.DumpDiagnosticInfo)
                {
                    Xom.Trace(XomAreaName.WireDataTxt, LogLevel.L_HIGH, field.Name);
                }

                object o = field.GetValue(this);

                if (index.fIsArray[i])
                {
                    int actualArraySize = 0;

                    // Define edge case where wiredata would serialize different value with null vs. empty string. Define output
                    // to match the empty string path.
                    if (o == null && index.wireInfo[i].NullTerminate && index.wireInfo[i].ArraySize != -1)
                    {
                        o = String.Empty;
                    }

                    if (o != null)
                    {
                        actualArraySize = index.fieldType[i] == TypeData.TD_STRING ? Encoding.UTF8.GetByteCount((string)o) : (o as Array).Length;

                        if (!ManualArraySize)
                        {
                            // The size of the array or string should not be greater than the ArraySize attribute
                            if (index.wireInfo[i].ArraySize != -1 && actualArraySize > index.wireInfo[i].ArraySize)
                            {
                                throw new Exception("Field \"" + field.Name + "\" contains too many items for it's ArraySize.");
                            }
                        }

                        if (index.fieldType[i] == TypeData.TD_STRING)
                        {
                            byte[] b = new UTF8Encoding().GetBytes((string)o);

                            //
                            // In .Net 2.0, attempting to write a 0 byte
                            // array to the HttpResponse stream results
                            // in an ArgumentOutOfRangeException thrown.
                            // As a result, a WireData object with an empty
                            // string as a member would fail to be written.
                            //
                            if ( b.Length > 0 )
                            {
                                binaryWriter.Write(b);
                            }

                            if( index.wireInfo[i].NullTerminate )
                            {
                                binaryWriter.Write( (byte)0 ); // Write out the null if requested
                            }
                        }
                        else if(index.fieldType[i] == TypeData.TD_BYTE_ARRAY)
                        {
                            byte[] b = (byte[]) o;
                            //
                            // In .Net 2.0, attempting to write a 0 byte
                            // array to the HttpResponse stream results
                            // in an ArgumentOutOfRangeException thrown.
                            // As a result, a WireData object with an empty
                            // byte array as a member would fail to be written.
                            //
                            if ( b.Length > 0 )
                            {
                                binaryWriter.Write(b);
                            }
                        }
                        else
                        {
                            for (int j = 0; j < actualArraySize; j++)
                            {
                                object val = (o as Array).GetValue(j);
                                WriteValue(binaryWriter, val, index.fieldType[i]);
                            }
                        }
                    }

                    if (!ManualArraySize)
                    {
                        // Pad the end of the array/string with 0's if nescessary
                        if ((index.wireInfo[i].ArraySize != -1) && (index.wireInfo[i].ArraySize > actualArraySize))
                        {
                            if (index.fieldType[i] == TypeData.TD_STRING || index.fieldType[i] == TypeData.TD_BYTE_ARRAY)
                            {
                                // this must be a string so ArraySize is in bytes
                                binaryWriter.Write(new byte[index.wireInfo[i].ArraySize - actualArraySize]);
                            }
                            else
                            {
                                if (index.fieldType[i] == TypeData.TD_WIREDATA)
                                {
                                    throw new Exception("WireData(): for type " + GetType().Name + "." + field.FieldType.GetElementType().Name + " -- The number of elements in the array must equal the ArraySize. No padding can be done for complex types.");
                                }
                                else
                                {
                                    for (int j = actualArraySize; j < index.wireInfo[i].ArraySize; j++)
                                    {
                                        WriteValue(binaryWriter, 0, index.fieldType[i]);
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    if (index.reverse[i] != -1)
                    {
                        if (!ManualArraySize)
                        {
                            int iArray = index.reverse[i];

                            object oT = index.fields[iArray].GetValue(this);
                            if (oT == null)
                            {
                                o = 0;
                            }
                            else if (index.fieldType[iArray] == TypeData.TD_STRING)
                            {
                                int iSize = Encoding.UTF8.GetByteCount((string)oT);
                                if( index.wireInfo[iArray].NullTerminate )
                                {
                                    iSize += 1; // Add the null onto the size
                                }
                                o = iSize;
                            }
                            else
                            {
                                o = ((Array)oT).Length;
                            }
                        }
                    }

                    WriteValue(binaryWriter, o, index.fieldType[i]);
                }
            }

            // Log the binary output
            Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, "WireData Binary Output: ");
            Xom.Trace(XomAreaName.WireDataBin, LogLevel.L_NORMAL, LogBinary(binaryWriter.BaseStream));
        }

        //
        // Serialize the object to obtain its size in bytes. This is SLOW!
        //
        public virtual int Size()
        {
            MemoryStream stream = new MemoryStream();
            WriteStream(stream);

            return (int)stream.Length;
        }

        #region Read/Write Converters
        //
        // Read a value of the provided type from the binaryReader
        //
        private object ReadValue(BinaryReader reader, TypeData typeData, Type type, object o)
        {
            switch (typeData)
            {
            case TypeData.TD_BOOLEAN:
                o = reader.ReadBoolean();
                break;

            case TypeData.TD_BYTE:
                o = reader.ReadByte();
                break;

            case TypeData.TD_CHAR:
                o = reader.ReadChar();
                break;

            case TypeData.TD_DECIMAL:
                o = reader.ReadDecimal();
                break;

            case TypeData.TD_DOUBLE:
                o = reader.ReadDouble();
                break;

            case TypeData.TD_SHORT:
                o = reader.ReadInt16();
                break;

            case TypeData.TD_INT:
                o = reader.ReadInt32();
                break;

            case TypeData.TD_LONG:
                o = reader.ReadInt64();
                break;

            case TypeData.TD_SBYTE:
                o = reader.ReadSByte();
                break;

            case TypeData.TD_FLOAT:
                o = reader.ReadSingle();
                break;

            case TypeData.TD_USHORT:
                o = reader.ReadUInt16();
                break;

            case TypeData.TD_UINT:
                o = reader.ReadUInt32();
                break;

            case TypeData.TD_ULONG:
                o = reader.ReadUInt64();
                break;

            case TypeData.TD_DATETIME:
                o = DateTime.FromFileTimeUtc(reader.ReadInt64());
                break;

            case TypeData.TD_WIREDATA:
                Debug.Assert(type.IsSubclassOf(typeof(WireData)));
                if (o == null)
                {
                    ConstructorInfo ci = type.GetConstructor(Type.EmptyTypes);
                    if (ci == null)
                    {
                        throw new Exception(String.Format("Type {0} must have a public default (parameterless) constructor.", type.ToString()));
                    }
                    else
                    {
                        o = ci.Invoke(null);
                    }
                }

                WireData wd = (WireData)o;
                wd.SchemaVersion = this.SchemaVersion;
                o = wd.ReadStream(reader) ?? o;
                break;

            case TypeData.TD_GUID:
                o = new Guid(reader.ReadBytes(16));
                break;

            default:
                throw new Exception("Type \"" + type.ToString() + "\" not supported.");

            }

            return o;
        }

        //
        // Write a value of the provided type to the binaryWriter
        //
        private void WriteValue(BinaryWriter writer, object o, TypeData typeData)
        {
            switch (typeData)
            {
            case TypeData.TD_BOOLEAN:
                writer.Write(Convert.ToBoolean(o));
                break;

            case TypeData.TD_BYTE:
                writer.Write(Convert.ToByte(o));
                break;

            case TypeData.TD_CHAR:
                writer.Write(Convert.ToChar(o));
                break;

            case TypeData.TD_DECIMAL:
                writer.Write(Convert.ToDecimal(o));
                break;

            case TypeData.TD_DOUBLE:
                writer.Write(Convert.ToDouble(o));
                break;

            case TypeData.TD_SHORT:
                writer.Write(Convert.ToInt16(o));
                break;

            case TypeData.TD_INT:
                writer.Write(Convert.ToInt32(o));
                break;

            case TypeData.TD_LONG:
                writer.Write(Convert.ToInt64(o));
                break;

            case TypeData.TD_SBYTE:
                writer.Write(Convert.ToSByte(o));
                break;

            case TypeData.TD_FLOAT:
                writer.Write(Convert.ToSingle(o));
                break;

            case TypeData.TD_USHORT:
                writer.Write(Convert.ToUInt16(o));
                break;

            case TypeData.TD_UINT:
                writer.Write(Convert.ToUInt32(o));
                break;

            case TypeData.TD_ULONG:
                writer.Write(Convert.ToUInt64(o));
                break;

            case TypeData.TD_DATETIME:
                writer.Write(Convert.ToDateTime(o).ToFileTimeUtc());
                break;

            case TypeData.TD_WIREDATA:
                WireData wd = (WireData)o;
                wd.SchemaVersion = this.SchemaVersion;
                wd.WriteStream(writer);
                break;

            case TypeData.TD_GUID:
                writer.Write(((Guid)o).ToByteArray());
                break;

            default:
                throw new Exception("Type \"" + o.GetType().ToString() + "\" not supported.");

            }
        }

        public void SerializeArray(WireData [] arrObject, int nLength, BinaryWriter binaryWriter)
        {
             for (int i=0;i<nLength;i++)
             {
                arrObject[i].SchemaVersion = this.SchemaVersion;
                arrObject[i].WriteStream(binaryWriter);
             }
        }

        //
        // Write a value of the provided type to a string
        //
        private string PrintValue(object o, TypeData typeData, bool fHex, bool fLimit, bool fMask)
        {
            string str;

            switch (typeData)
            {
            case TypeData.TD_BOOLEAN:
                str = (Convert.ToBoolean(o)).ToString();
                break;

            case TypeData.TD_BYTE:
                str = fHex ? "0x" + (Convert.ToByte(o)).ToString("X2") : (Convert.ToByte(o)).ToString();
                break;

            case TypeData.TD_BYTE_ARRAY:
                str = ByteArrayToString((byte[])o);
                break;

            case TypeData.TD_CHAR:
                str = (Convert.ToChar(o)).ToString();
                break;

            case TypeData.TD_DECIMAL:
                str = (Convert.ToDecimal(o)).ToString();
                break;

            case TypeData.TD_DOUBLE:
                str = (Convert.ToDouble(o)).ToString();
                break;

            case TypeData.TD_SHORT:
                str = fHex ? "0x" + (Convert.ToInt16(o)).ToString("X4") : (Convert.ToInt16(o)).ToString();
                break;

            case TypeData.TD_INT:
                str = fHex ? "0x" + (Convert.ToInt32(o)).ToString("X8") : (Convert.ToInt32(o)).ToString();
                break;

            case TypeData.TD_LONG:
                str = fHex ? "0x" + (Convert.ToInt64(o)).ToString("X16") : (Convert.ToInt64(o)).ToString();
                break;

            case TypeData.TD_SBYTE:
                str = (Convert.ToSByte(o)).ToString();
                break;

            case TypeData.TD_FLOAT:
                str = (Convert.ToSingle(o)).ToString();
                break;

            case TypeData.TD_USHORT:
                str = fHex ? "0x" + (Convert.ToUInt16(o)).ToString("X4") : (Convert.ToUInt16(o)).ToString();
                break;

            case TypeData.TD_UINT:
                str = fHex ? "0x" + (Convert.ToUInt32(o)).ToString("X8") : (Convert.ToUInt32(o)).ToString();
                break;

            case TypeData.TD_ULONG:
                str = fHex ? "0x" + (Convert.ToUInt64(o)).ToString("X16") : (Convert.ToUInt64(o)).ToString();
                break;

            case TypeData.TD_DATETIME:
                str = (Convert.ToDateTime(o).ToFileTimeUtc()).ToString();
                break;

            case TypeData.TD_STRING:
                str = (string)o;
                break;

            case TypeData.TD_GUID:
                str = ((Guid)o).ToString();
                break;

            default:
                throw new Exception("Type \"" + o.GetType().ToString() + "\" not supported.");

            }

            // If the field is masked, replace all of the characters with an
            // asterisk ('*').  This will likely only be used for fields which
            // contain credit card or direct debit account numbers or other
            // equally sensitive data.
            if ( fMask && !String.IsNullOrEmpty(str) )
            {
                str = String.Empty.PadRight(str.Length, '*');
            }

            if (fLimit)
            {
                int length = Config.GetIntSetting("wiredata_stringLimit");

                if (length > 0)
                {
                    if (str.Length > length)
                    {
                        str = str.Substring(0, length) + " (more ...)";
                    }
                }
            }

            return str;
        }

        //
        // Return the size for a given type (only supports types used by ReadValue)
        //
        private uint SizeOfType(TypeData typeData)
        {
            switch (typeData)
            {
            case TypeData.TD_DECIMAL:
            case TypeData.TD_GUID:
                return 16;

            case TypeData.TD_DATETIME:
            case TypeData.TD_DOUBLE:
            case TypeData.TD_LONG:
            case TypeData.TD_ULONG:
                return 8;

            case TypeData.TD_FLOAT:
            case TypeData.TD_INT:
            case TypeData.TD_UINT:
                return 4;

            case TypeData.TD_SHORT:
            case TypeData.TD_USHORT:
                return 2;

            case TypeData.TD_BOOLEAN:
            case TypeData.TD_BYTE:
            case TypeData.TD_CHAR:
            case TypeData.TD_SBYTE:
                return 1;

            case TypeData.TD_WIREDATA:
                return 0;

            default:
                throw new Exception("Type \"" + typeData.ToString() + "\" not supported by SizeOfType.");
            }
        }

        public static uint GetSchemaVersion(HttpRequest req)
        {
            // Assume version 1.0 for back compat
            uint schemaVersion = MakeSchemaVersion(1,0);

            String schemaVersionStr = req.Headers["X-Schema-Ver"];
            if (schemaVersionStr != null)
            {
                schemaVersion = WireInfoAttribute.StringToVersion(schemaVersionStr);
            }

            return schemaVersion;
        }

        public void ValidateSchemaVersion()
        {
            // Check current SchemaVersion against the one the Class expects
            WireTypeInfo myInfo = GetWireTypeInfo();

            if( this.SchemaVersion < myInfo.myWireInfo.MinSchemaVersionVal ||
                this.SchemaVersion > myInfo.myWireInfo.MaxSchemaVersionVal)
            {
                throw new XRLException(HResult.XONLINE_E_UNSUPPORTED_METHOD, XEvent.Id.COMMON_HACK_81,
                    "Wiredata Request SchemaVersion " + WireInfoAttribute.VersionToString(this.SchemaVersion) + " not allowed: " + this.GetType().ToString());
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\XBancProxyProt.cs ===
using System;
using System.IO;

namespace xonline.common.service
{
    public class XBancDefs
    {
        public const uint XBANC_PROTOCOL_VERSION_CURRENT = 1;
        public const uint XBANC_MESSAGE_HEADER_SIZE = 16;
        public const uint XBANC_MAX_PACKET_SIZE = 16384;
        public const uint XBANC_INCREMENT_HALFLIFE_INFINITE = 0xFFFFFFFF;
    }

    public enum XBANC_MSG_TYPES
    {
        // request types:
        XBMSG_MIN_REQ                    = 1000,
        XBMSG_QUERY_REQ                  = 1000,
        XBMSG_INSERT_REQ                 = 1001,
        XBMSG_REMOVE_REQ                 = 1002,
        XBMSG_SET_DATA_REQ               = 1003,
        XBMSG_CONTINUATION_REQ           = 1004,
        XBMSG_INCREMENT_REQ              = 1005,
        XBMSG_MAX_REQ                    = 1005,

        // response types:
        XBMSG_MIN_RESP                   = 1100,
        XBMSG_EMPTY_RESP                 = 1100,
        XBMSG_QUERY_RESP                 = 1101,
        XBMSG_INSERT_RESP                = 1102,
        XBMSG_REMOVE_RESP                = 1103,
        XBMSG_SET_DATA_RESP              = 1104,
        XBMSG_INCREMENT_RESP             = 1105,
        XBMSG_MAX_RESP                   = 1105,
    };
    
    public class XBancMessageHeader : WireData
    {
        public uint dwProtocolVersion;
        public uint dwMsgType;
        public uint dwMsgLen;
        public uint dwSeqNum;

        public XBancMessageHeader()
        {
        }

        public XBancMessageHeader(XBANC_MSG_TYPES eType)
        {
            dwProtocolVersion = XBancDefs.XBANC_PROTOCOL_VERSION_CURRENT;
            dwMsgType = (uint)eType;
        }

        public override int Size()
        {
            return (int)XBancDefs.XBANC_MESSAGE_HEADER_SIZE;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - XBancMessageHeader::WriteStream binaryWriter is null");
            }

            if ((dwMsgType < (uint)XBANC_MSG_TYPES.XBMSG_MIN_REQ) ||
                (dwMsgType > (uint)XBANC_MSG_TYPES.XBMSG_MAX_REQ))
            {
                throw new Exception("Fatal Error - XBancMessageHeader::WriteStream dwMsgType not a valid request type.");                
            }

            dwMsgLen = (uint)Size();
            
            binaryWriter.Write(dwProtocolVersion);
            binaryWriter.Write(dwMsgType);
            binaryWriter.Write(dwMsgLen);
            binaryWriter.Write(dwSeqNum);
        }
    
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - XBancMessageHeader::ReadStream binaryReader is null");
            }

            try
            {
                dwProtocolVersion = binaryReader.ReadUInt32();
                dwMsgType = binaryReader.ReadUInt32();
                dwMsgLen = binaryReader.ReadUInt32();
                dwSeqNum = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.XBANC_END_OF_STREAM, "Reached end of stream trying to read response object header", e);
            }
            
            if ((dwMsgType < (uint)XBANC_MSG_TYPES.XBMSG_MIN_RESP) ||
                (dwMsgType > (uint)XBANC_MSG_TYPES.XBMSG_MAX_RESP))
            {
                throw new Exception("Fatal Error - XBancMessageHeader::ReadStream dwMsgType not a valid response type.");                
            }
            
            return this;
        }
    }

    public class XBancQueryRequest : XBancMessageHeader
    {
        public uint dwKeySize;
        public byte[] rgbKey;

        public XBancQueryRequest() : base(XBANC_MSG_TYPES.XBMSG_QUERY_REQ)
        {
        }

        public override int Size()
        {
            return base.Size() + 4 + ((rgbKey == null) ? 0 : rgbKey.Length);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - XBancQueryRequest::WriteStream binaryWriter is null");
            }

            dwKeySize = (rgbKey == null) ? 0 : (uint)rgbKey.Length;
            base.WriteStream(binaryWriter);
            
            binaryWriter.Write(dwKeySize);

            if (rgbKey != null)
            {
                binaryWriter.Write(rgbKey);
            }
        }
    }

    public class XBancQueryResponse : XBancMessageHeader
    {
        public HResult hr;
        public uint dwValueSize;
        public uint dwValidSeconds;
        public byte[] rgbValue;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - XBancQueryResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
                dwValueSize = binaryReader.ReadUInt32();
                dwValidSeconds = binaryReader.ReadUInt32();
                rgbValue = binaryReader.ReadBytes((int)dwValueSize);
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.XBANC_END_OF_STREAM, "Reached end of stream trying to read query response object", e);
            }

            return this;
        }
    }

    public class XBancInsertRequest : XBancMessageHeader
    {
        public uint dwKeySize;
        public uint dwValueSize;
        public uint dwAbsoluteSeconds;
        public uint dwSlidingSeconds;
        public byte[] rgbKey;
        public byte[] rgbValue;

        public XBancInsertRequest() : base(XBANC_MSG_TYPES.XBMSG_INSERT_REQ)
        {
        }

        public override int Size()
        {
            return base.Size() + 16 + ((rgbKey == null) ? 0 : rgbKey.Length) + ((rgbValue == null) ? 0 : rgbValue.Length);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - XBancInsertRequest::WriteStream binaryWriter is null");
            }

            dwKeySize = (rgbKey == null) ? 0 : (uint)rgbKey.Length;
            dwValueSize = (rgbValue == null) ? 0 : (uint)rgbValue.Length;
            base.WriteStream(binaryWriter);
            
            binaryWriter.Write(dwKeySize);
            binaryWriter.Write(dwValueSize);
            binaryWriter.Write(dwAbsoluteSeconds);
            binaryWriter.Write(dwSlidingSeconds);

            if (rgbKey != null)
            {
                binaryWriter.Write(rgbKey);
            }

            if (rgbValue != null)
            {
                binaryWriter.Write(rgbValue);
            }
        }
    }

    public class XBancInsertResponse : XBancMessageHeader
    {
        public HResult hr;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - XBancInsertResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.XBANC_END_OF_STREAM, "Reached end of stream trying to read insert response object", e);
            }
            
            return this;
        }
    }

    public class XBancRemoveRequest : XBancMessageHeader
    {
        public uint dwKeySize;
        public bool fMatchExact;
        public byte[] rgbKey;

        public XBancRemoveRequest() : base(XBANC_MSG_TYPES.XBMSG_REMOVE_REQ)
        {
        }

        public override int Size()
        {
            return base.Size() + 8 + ((rgbKey == null) ? 0 : rgbKey.Length);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - XBancRemoveRequest::WriteStream binaryWriter is null");
            }

            dwKeySize = (rgbKey == null) ? 0 : (uint)rgbKey.Length;
            base.WriteStream(binaryWriter);
            
            binaryWriter.Write(dwKeySize);
            binaryWriter.Write(fMatchExact ? (uint)1 : (uint)0);            

            if (rgbKey != null)
            {
                binaryWriter.Write(rgbKey);
            }
        }
    }

    public class XBancRemoveResponse : XBancMessageHeader
    {
        public HResult hr;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - XBancRemoveResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.XBANC_END_OF_STREAM, "Reached end of stream trying to read remove response object", e);
            }

            return this;
        }
    }

    public class XBancSetDataRequest : XBancMessageHeader
    {
        public uint dwKeySize;
        public uint dwValueSize;
        public uint dwAbsoluteSeconds;
        public uint dwSlidingSeconds;
        public byte[] rgbKey;
        public byte[] rgbValue;

        public XBancSetDataRequest() : base(XBANC_MSG_TYPES.XBMSG_SET_DATA_REQ)
        {
        }

        public override int Size()
        {
            return base.Size() + 16 + ((rgbKey == null) ? 0 : rgbKey.Length) + ((rgbValue == null) ? 0 : rgbValue.Length);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - XBancSetDataRequest::WriteStream binaryWriter is null");
            }

            dwKeySize = (rgbKey == null) ? 0 : (uint)rgbKey.Length;
            dwValueSize = (rgbValue == null) ? 0 : (uint)rgbValue.Length;
            base.WriteStream(binaryWriter);
            
            binaryWriter.Write(dwKeySize);
            binaryWriter.Write(dwValueSize);
            binaryWriter.Write(dwAbsoluteSeconds);
            binaryWriter.Write(dwSlidingSeconds);

            if (rgbKey != null)
            {
                binaryWriter.Write(rgbKey);
            }

            if (rgbValue != null)
            {
                binaryWriter.Write(rgbValue);
            }
        }
    }

    public class XBancSetDataResponse : XBancMessageHeader
    {
        public HResult hr;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - XBancSetDataResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.XBANC_END_OF_STREAM, "Reached end of stream trying to read setdata response object", e);
            }

            return this;
        }
    }

    public class XBancIncrementRequest : XBancMessageHeader
    {
        public uint dwKeySize;
        public ulong qwIncrementAmount;
        public uint dwHalfLifeSeconds;
        public uint dwAbsoluteSeconds;
        public uint dwSlidingSeconds;
        public byte[] rgbKey;

        public XBancIncrementRequest() : base(XBANC_MSG_TYPES.XBMSG_INCREMENT_REQ)
        {
        }

        public override int Size()
        {
            return base.Size() + 24 + ((rgbKey == null) ? 0 : rgbKey.Length);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - XBancIncrementRequest::WriteStream binaryWriter is null");
            }

            dwKeySize = (rgbKey == null) ? 0 : (uint)rgbKey.Length;
            base.WriteStream(binaryWriter);
            
            binaryWriter.Write(dwKeySize);
            binaryWriter.Write(qwIncrementAmount);
            binaryWriter.Write(dwHalfLifeSeconds);
            binaryWriter.Write(dwAbsoluteSeconds);
            binaryWriter.Write(dwSlidingSeconds);

            if (rgbKey != null)
            {
                binaryWriter.Write(rgbKey);
            }
        }
    }

    public class XBancIncrementResponse : XBancMessageHeader
    {
        public HResult hr;
        public ulong qwResult;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - XBancIncrementResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
                qwResult = binaryReader.ReadUInt64();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.XBANC_END_OF_STREAM, "Reached end of stream trying to read increment response object", e);
            }
            
            return this;
        }
    }

    public class XBancEmptyResponse : XBancMessageHeader
    {
        public HResult hr;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - XBancEmptyResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.XBANC_END_OF_STREAM, "Reached end of stream trying to read empty response object", e);
            }
            
            return this;
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\XblSamlSecurityTokenAuthenticator.cs ===
// 
// XblSamlSecurityTokenAuthenticator.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// SamlSecurityTokenAuthenticator derived class for Saml Token authentication
//

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.IdentityModel.Selectors;
using System.IdentityModel.Tokens;
using System.Security.Cryptography.X509Certificates;
using System.ServiceModel.Security;
using System.Text;
using System.Xml;

using xonline.common.exceptions;

namespace xonline.common.service
{

internal class XblSamlSecurityTokenAuthenticator : SamlSecurityTokenAuthenticator
{
    internal XblSamlSecurityTokenAuthenticator( string[] allowedThumbprints ) : base (new SecurityTokenAuthenticator[1] { new X509SecurityTokenAuthenticator(new XblX509CertificateValidator(allowedThumbprints)) }, new TimeSpan(0,5,0) )
    {
        AudienceUriMode = AudienceUriMode.Always;
        IList<string> allowedUris = AllowedAudienceUris;
        allowedUris.Add( XblSamlToken.xbl10_samlissuer );
    }
    
    // -------------------------------------------------------------------------------
    // Implementation public
    // -------------------------------------------------------------------------------

    /// <summary>
    /// General SAML token validation entry point.
    /// </summary>
    /// <param name="allowedThumbprints"></param>
    /// <param name="certDeviceId"></param>
    public void ValidateToken(XblSamlToken xblSamlToken, string certDeviceId)
    {
        SamlSecurityToken samlSecurityToken = xblSamlToken.SecurityToken;
        
        base.ValidateToken(samlSecurityToken);
        
        // Does the client connection certificate match the device for which the token was issued
        string deviceId;
        if (!string.IsNullOrEmpty(certDeviceId) && xblSamlToken.TryGetAttributeValue(XblSamlToken.name_attribute_deviceid, out deviceId))
        {
            if (deviceId != certDeviceId)
            {
                throw new XblException(HResult.XONLINE_E_XBOXLIVETOKEN_INVALID_CLIENTTHUMBPRINT, "; SAML Claim DeviceID does not match client certificate DeviceId. The token was not issued for this connection certificate. DeviceID {0} Cert DeviceId {1}", deviceId, certDeviceId);
            }
        }

        //general saml validation
        if (XblSamlToken.xbl10_samlmajorversion != xblSamlToken.MajorVersion)
        {
            throw new XblException(HResult.XONLINE_E_XBOXLIVETOKEN_INVALID_VERSION, "; SAML MajorVersion attribute is {0}, but {1} is expected.", xblSamlToken.MajorVersion, XblSamlToken.xbl10_samlmajorversion);
        }

        if (XblSamlToken.xbl10_samlminorversion != xblSamlToken.MinorVersion)
        {
            throw new XblException(HResult.XONLINE_E_XBOXLIVETOKEN_INVALID_VERSION, "; SAML MinorVersion attribute is {0}, but {1} is expected.", xblSamlToken.MinorVersion, XblSamlToken.xbl10_samlminorversion);
        }

        if (XblSamlToken.xbl10_samlissuer != xblSamlToken.Issuer)
        {
            throw new XblException(HResult.XONLINE_E_XBOXLIVETOKEN_INVALID_ISSUER, "; SAML Issuer attribute is {0}, but {1} is expected.", xblSamlToken.Issuer, XblSamlToken.xbl10_samlissuer);
        }

        // There should be only one SamlStatement
        if (1 != samlSecurityToken.Assertion.Statements.Count)
        {
            throw new XblException(HResult.XONLINE_E_XBOXLIVETOKEN_INVALID_STATEMENT_COUNT, "; SAML Statement count is {0}, but 1 is expected.", samlSecurityToken.Assertion.Statements.Count);
        }

        // It should be of type SamlAttributeStatement
        if (!(samlSecurityToken.Assertion.Statements[0] is System.IdentityModel.Tokens.SamlAttributeStatement))
        {
            throw new XblException(HResult.XONLINE_E_XBOXLIVETOKEN_INVALID_STATEMENT_TYPE, "; SAML Statement type is {0}, but Type:System.IdentityModel.Tokens.SamlAttributeStatement is expected.", samlSecurityToken.Assertion.Statements[0].GetType());
        }
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\XBancProxy.cs ===
using System;
using System.IO;
using System.Collections;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Diagnostics;

using xonline.common.config;
using xonline.common.mgmt;


[assembly: XomAreaDefinition(XomAreaName.XBancProxy)]
    
namespace xonline.common.service
{
    public class XBanc
    {
        protected bool m_fUseLocalCache = false;
        protected static bool m_fInitialized = false;
        protected static volatile CacheTable<ByteArray, XBancLocalCacheValue> m_cache = new CacheTable<ByteArray, XBancLocalCacheValue>("XBanc Proxy - " + Config.ComponentName, Config.GetUIntSetting(Setting.xbanc_localCacheMaxSize));
        protected static CacheTableCounters m_CacheTableCounters = null;
        
        static XBanc()
        {
            // config setting change handler.
            Config.SettingChange += new SettingChangeEventHandler(XBanc.ChangeSetting);
            m_CacheTableCounters = CacheTableCounters.GetCounter("XBanc Proxy - " + Config.ComponentName);
        }

        public XBanc() : this(false)
        {
        }

        public XBanc(bool fUseLocalCache)
        {
            m_fUseLocalCache = fUseLocalCache;
        }

        public static void Init()
        {
            // this forces XBancConnection to run its static constructor.
            uint iStartup = XBancConnection.GetNumBuckets();
            m_fInitialized = true;
        }
                
        public static bool CompareByteArrays(byte[] array1, byte[] array2)
        {
            if (array1 == null) return (array2 == null);
            if (array2 == null) return false;
            if (array1.Length != array2.Length) return false;
            for (int i = 0; i < array1.Length; i++)
            {
                if (array1[i] != array2[i]) return false;
            }
            return true;
        }

        public bool IsLocalCachingEnabled()
        {
            return (m_fUseLocalCache && (m_cache.MaxSize > 0));
        }
        
        public bool ValidateKey(byte[] key)
        {
            /* TODO: add this to enforce that users call Init() before anything else.
            if (!m_fInitialized)
            {
                Xom.NtEvent(XEvent.Id.XBANC_PROXY_NOT_INITIALIZED, "XBancProxy accessed without being initialized.  Did you forget to call XBanc.Init() in your startup code?");
                return false;
            }
            */
            
            if ((key == null) ||
                (key.Length == 0) ||
                (key.Length > Config.GetUIntSetting(Setting.xbanc_max_key_length)))
            {
                return false;
            }

            return true;
        }

        public bool ValidateValue(byte[] value)
        {
            if ((value == null) ||
                (value.Length == 0))
            {
                return false;
            }

            return true;
        }
        
        protected uint HashKeyToBucket(byte[] key)
        {
            uint sum = 0;
            for (int i = 0; i < key.Length; i++)
            {
                sum += (uint)key[i];
            }

            return sum % XBancConnection.GetNumBuckets();
        }

        public static uint GetExtendedError(Exception e, byte[] rgbStream)
        {
            if (e is XRLException)
            {
                XRLException xrle = (XRLException)e;
                
                // check for a failure code from the inh server.
                if ((xrle.HResult == HResult.XONLINE_E_END_OF_STREAM) &&
                    (rgbStream != null))
                {
                    try
                    {
                        XBancEmptyResponse response = new XBancEmptyResponse();
                        response.ReadBytes(rgbStream);

                        // return the hr from the server.
                        return response.hr;
                    }
                    catch (Exception)
                    {
                        // couldnt get anything more.  we can eat this exception.
                    }
                }

                Xom.NtEvent(XEvent.Id.XBANC_CODE_21, xrle, "XBanc.Query() caught exception");

                // return exception failure.
                return xrle.HResult;
            }
            else
            {
                Xom.NtEvent(XEvent.Id.XBANC_CODE_21, e, "XBanc.Query() caught exception");
                
                // generic send failure.
                return HResult.E_ABORT;
            }
        }
        
        public uint Query(byte[] key, out byte[] value)
        {
            uint validSeconds;
            return Query(key, out value, out validSeconds);
        }

        public uint Query(byte[] key, out byte[] value, out uint validSeconds)
        {
            uint[] rgValidSeconds;
            byte[][] values;
            uint[] retVals;

            retVals = Query(new byte[][]{key}, out values, out rgValidSeconds);

            value = values[0];
            validSeconds = rgValidSeconds[0];
            return retVals[0];
         }

        public uint[] Query(byte[][] keys, out byte[][] values, out uint[] validSeconds)
        {
            values = null;
            validSeconds = null;
            
            if ((keys == null) || (keys.Length == 0))
            {
                return null;
            }

            uint[] retVals = new uint[keys.Length];
            validSeconds = new uint[keys.Length];
            values = new byte[keys.Length][];

            ByteArray[] baKeys = null;
            XBancLocalCacheValue[] expiredItems = null;
            if (IsLocalCachingEnabled())
            {
                baKeys = new ByteArray[keys.Length];
                expiredItems = new XBancLocalCacheValue[keys.Length];
            }

            // If the client has requested that all xbanc queries fail,
            // then don't even bother with the real query.
            if (XbancMiss.HandleBehaviorInjectionQuery(retVals))
            {
                return retVals;
            }

            XBancContext context = new XBancContext(keys.Length);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                // assume failure for each key until proven otherwise.
                // default is failfast, as any other failure is explicitly set
                retVals[iKey] = HResult.XONLINE_E_RESOURCE_UNAVAILABLE;
                
                if (!ValidateKey(keys[iKey]))
                {
                    retVals[iKey] = HResult.E_INVALIDARG;
                    continue;
                }

                // check the local cache
                if (IsLocalCachingEnabled())
                {
                    XBancLocalCacheValue localValue = null;
                    bool fCacheHit = true;
                    try
                    {
                        baKeys[iKey] = new ByteArray(keys[iKey]); 
                        localValue = m_cache[baKeys[iKey]];
                    }
                    catch (Exception)
                    {
                        // eat any exception.
                        fCacheHit = false;
                    }
                    
                    if ((localValue != null) && (!localValue.IsExpired()))
                    {
                        retVals[iKey] = HResult.S_OK;
                        values[iKey] = localValue.GetValue();
                        validSeconds[iKey] = (uint)localValue.GetRemainingSeconds();

                        // skip server trip for this key.
                        continue;
                    }
                    else if (fCacheHit)
                    {
                        // what we got was actually expired.  Lets call it a miss instead.
                        m_CacheTableCounters.UnMarkCacheHit();
                        m_CacheTableCounters.MarkCacheMiss();

                        // save the container for reuse.
                        expiredItems[iKey] = localValue;
                    }
                }
                
                XBancQueryRequest request = new XBancQueryRequest();
                request.rgbKey = keys[iKey];
                context.AddRequest(iKey, HashKeyToBucket(keys[iKey]), request);
            }

            XBancConnection.SendContext(context);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if (context._wtObjects[iKey] == null)
                {
                    // we never sent this key to xbanc.  it likely has a prior success/error code from above.
                    continue;
                }
                else if (context._wtObjects[iKey]._response == null)
                {
                    // we got nothing back from xbanc.
                    retVals[iKey] = HResult.E_ABORT;
                }
                else
                {
                    try
                    {
                        // parse the response.
                        XBancQueryResponse response = new XBancQueryResponse();
                        response.ReadBytes(context._wtObjects[iKey]._response);

                        values[iKey] = response.rgbValue;
                        validSeconds[iKey] = response.dwValidSeconds;
                        retVals[iKey] = response.hr;

                        // populate local cache.
                        // only populate if a real value was returned.
                        if (IsLocalCachingEnabled() && (response.hr == HResult.S_OK))
                        {
                            try
                            {
                                // try to reuse any old key or data container.
                                XBancLocalCacheValue newValue = expiredItems[iKey];
                                if (newValue == null)
                                {
                                    newValue = new XBancLocalCacheValue(baKeys[iKey], response.rgbValue);
                                }
                                else
                                {
                                    newValue.Init(response.rgbValue);
                                }
                                
                                m_cache[newValue.GetKey()] = newValue;
                            }
                            catch (Exception)
                            {
                                // eat any exception.
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        retVals[iKey] = GetExtendedError(e, context._wtObjects[iKey]._response);
                    }
                }
            }
            
            return retVals;
        }

        public uint Insert(byte[] key, byte[] value)
        {
            uint[] retVals = Insert(new byte[][]{key}, new byte[][]{value}, new uint[]{0}, new uint[]{0});
            return retVals[0];
        }

        public uint Insert(byte[] key, byte[] value, uint absoluteSeconds, uint slidingSeconds)
        {
            uint[] retVals = Insert(new byte[][]{key}, new byte[][]{value}, new uint[]{absoluteSeconds}, new uint[]{slidingSeconds});
            return retVals[0];
        }

        public uint[] Insert(byte[][] keys, byte[][] values, uint[] absoluteExpiries, uint[] slidingExpiries)
        {
            if ((keys == null) || (values == null) || (absoluteExpiries == null) || (slidingExpiries == null) ||
                (keys.Length == 0) || (values.Length != keys.Length) || (absoluteExpiries.Length != keys.Length) ||(slidingExpiries.Length != keys.Length))
            {
                return null;
            }

            uint[] retVals = new uint[keys.Length];

            // If the client has requested that all Xbanc queries for this request
            // are missed, we also short-circuit inserts because we don't want the
            // caller to be confused.
            if (XbancMiss.ForceMissOn)
            {
                return retVals;
            }

            XBancContext context = new XBancContext(keys.Length);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if (!ValidateKey(keys[iKey]) || !ValidateValue(values[iKey]))
                {
                    retVals[iKey] = HResult.E_INVALIDARG;
                }
                else
                {
                    XBancInsertRequest request = new XBancInsertRequest();
                    request.rgbKey = keys[iKey];
                    request.rgbValue = values[iKey];
                    request.dwAbsoluteSeconds = absoluteExpiries[iKey];
                    request.dwSlidingSeconds = slidingExpiries[iKey];
                    context.AddRequest(iKey, HashKeyToBucket(keys[iKey]), request);
                }
            }

            XBancConnection.SendContext(context);
            
            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if ((context._wtObjects[iKey] == null) ||
                    (context._wtObjects[iKey]._response == null))
                {
                    // prior error?
                    if (retVals[iKey] == 0)
                    {
                        // If the key is null, request never got sent, an indicator of fastfail
                        retVals[iKey] = (context._wtObjects[iKey] == null) ? HResult.XONLINE_E_RESOURCE_UNAVAILABLE : HResult.E_ABORT;
                    }
                }
                else
                {
                    try
                    {
                        // parse the response.
                        XBancInsertResponse response = new XBancInsertResponse();
                        response.ReadBytes(context._wtObjects[iKey]._response);

                        retVals[iKey] = response.hr;
                    }
                    catch (Exception e)
                    {
                        retVals[iKey] = GetExtendedError(e, context._wtObjects[iKey]._response);
                    }
                }
            }
            
            return retVals;
        }

        public uint Remove(byte[] key)
        {
            uint[] retVals = Remove(new byte[][]{key});
            return retVals[0];
        }

        public uint[] Remove(byte[][] keys)
        {
            if ((keys == null) || (keys.Length == 0))
            {
                return null;
            }

            uint[] retVals = new uint[keys.Length];

            XBancContext context = new XBancContext(keys.Length);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if (!ValidateKey(keys[iKey]))
                {
                    retVals[iKey] = HResult.E_INVALIDARG;
                }
                else
                {
                    XBancRemoveRequest request = new XBancRemoveRequest();
                    request.rgbKey = keys[iKey];
                    request.fMatchExact = true;
                    context.AddRequest(iKey, HashKeyToBucket(keys[iKey]), request);
                }
            }

            XBancConnection.SendContext(context);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if ((context._wtObjects[iKey] == null) ||
                    (context._wtObjects[iKey]._response == null))
                {
                    // prior error?
                    if (retVals[iKey] == 0)
                    {
                        // If the key is null, request never got sent, an indicator of fastfail
                        retVals[iKey] = (context._wtObjects[iKey] == null) ? HResult.XONLINE_E_RESOURCE_UNAVAILABLE : HResult.E_ABORT;
                    }
                }
                else
                {
                    try
                    {
                        // parse the response.
                        XBancRemoveResponse response = new XBancRemoveResponse();
                        response.ReadBytes(context._wtObjects[iKey]._response);

                        retVals[iKey] = response.hr;
                    }
                    catch (Exception e)
                    {
                        retVals[iKey] = GetExtendedError(e, context._wtObjects[iKey]._response);
                    }
                }
            }
            
            return retVals;
        }

        public uint Remove(byte[] key, bool matchExact)
        {
            if (matchExact == true)
            {
                return Remove(key);
            }
            
            if (!ValidateKey(key))
            {
                return HResult.E_INVALIDARG;
            }
            
            // make a request copy for each server.
            uint cServers = XBancConnection.GetNumServers();
            XBancRemoveRequest[] requests = new XBancRemoveRequest[cServers];            
            for (uint iServer = 0; iServer < cServers; iServer++)
            {
                requests[iServer] = new XBancRemoveRequest();
                requests[iServer].rgbKey = key;
                requests[iServer].fMatchExact = false;
            }

            try
            {
                // we treat these sends as fire and forget.
                XBancConnection.SendToAllServers(requests);
                return HResult.S_OK;
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.XBANC_CODE_21, e, "XBanc.Remove() caught exception");

                return HResult.E_ABORT;
            }
        }

        public uint SetData(byte[] key, byte[] value, uint absoluteSeconds, uint slidingSeconds)
        {
            uint[] retVals = SetData(new byte[][]{key}, new byte[][]{value}, new uint[]{absoluteSeconds}, new uint[]{slidingSeconds});
            return retVals[0];
        }

        public uint[] SetData(byte[][] keys, byte[][] values, uint[] absoluteExpiries, uint[] slidingExpiries)
        {
            if ((keys == null) || (values == null) || (absoluteExpiries == null) || (slidingExpiries == null) ||
                (keys.Length == 0) || (values.Length != keys.Length) || (absoluteExpiries.Length != keys.Length) ||(slidingExpiries.Length != keys.Length))
            {
                return null;
            }

            uint[] retVals = new uint[keys.Length];

            XBancContext context = new XBancContext(keys.Length);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if (!ValidateKey(keys[iKey]) || !ValidateValue(values[iKey]))
                {
                    retVals[iKey] = HResult.E_INVALIDARG;
                }
                else
                {
                    XBancSetDataRequest request = new XBancSetDataRequest();
                    request.rgbKey = keys[iKey];
                    request.rgbValue = values[iKey];
                    request.dwAbsoluteSeconds = absoluteExpiries[iKey];
                    request.dwSlidingSeconds = slidingExpiries[iKey];
                    context.AddRequest(iKey, HashKeyToBucket(keys[iKey]), request);
                }
            }

            XBancConnection.SendContext(context);
            
            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if ((context._wtObjects[iKey] == null) ||
                    (context._wtObjects[iKey]._response == null))
                {
                    // prior error?
                    if (retVals[iKey] == 0)
                    {
                        retVals[iKey] = HResult.E_ABORT;
                    }
                }
                else
                {
                    try
                    {
                        // parse the response.
                        XBancSetDataResponse response = new XBancSetDataResponse();
                        response.ReadBytes(context._wtObjects[iKey]._response);

                        retVals[iKey] = response.hr;
                    }
                    catch (Exception e)
                    {
                        retVals[iKey] = GetExtendedError(e, context._wtObjects[iKey]._response);
                    }
                }
            }
            
            return retVals;
        }

        public uint Increment(byte[] key, ulong amount, out ulong result)
        {
            return Increment(key, amount, XBancDefs.XBANC_INCREMENT_HALFLIFE_INFINITE, 0, 0, out result);
        }

        public uint Increment(byte[] key, ulong amount, uint halfLifeSeconds, out ulong result)
        {
            return Increment(key, amount, halfLifeSeconds, 0, 0, out result);
        }

        public uint Increment(byte[] key, ulong amount, uint halfLifeSeconds, uint absoluteSeconds, uint slidingSeconds, out ulong result)
        {
            ulong[] results;
            uint[] retVals = Increment(new byte[][]{key}, new ulong[]{amount}, new uint[]{halfLifeSeconds}, new uint[]{absoluteSeconds}, new uint[]{slidingSeconds}, out results);
            
            result = results[0];
            return retVals[0];
        }

        public uint[] Increment(byte[][] keys, ulong[] amounts, out ulong[] results)
        {
            uint[] halfLives = new uint[keys.Length];
            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                halfLives[iKey] = XBancDefs.XBANC_INCREMENT_HALFLIFE_INFINITE;
            }
            return Increment(keys, amounts, halfLives, new uint[keys.Length], new uint[keys.Length], out results);
        }
        
        public uint[] Increment(byte[][] keys, ulong[] amounts, uint[] halfLives, uint[] absoluteExpiries, uint[] slidingExpiries, out ulong[] results)
        {
            results = null;
            
            if ((keys == null) || (amounts == null) || (halfLives == null) || (absoluteExpiries == null) || (slidingExpiries == null) ||
                (keys.Length == 0) || (amounts.Length != keys.Length) || (halfLives.Length != keys.Length) || (absoluteExpiries.Length != keys.Length) ||(slidingExpiries.Length != keys.Length))
            {
                return null;
            }

            uint[] retVals = new uint[keys.Length];
            results = new ulong[keys.Length];

            XBancContext context = new XBancContext(keys.Length);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if (!ValidateKey(keys[iKey]) || (halfLives[iKey] == 0))
                {
                    retVals[iKey] = HResult.E_INVALIDARG;
                }
                else
                {
                    XBancIncrementRequest request = new XBancIncrementRequest();
                    request.rgbKey = keys[iKey];
                    request.qwIncrementAmount = amounts[iKey];
                    request.dwHalfLifeSeconds = halfLives[iKey];
                    request.dwAbsoluteSeconds = absoluteExpiries[iKey];
                    request.dwSlidingSeconds = slidingExpiries[iKey];
                    context.AddRequest(iKey, HashKeyToBucket(keys[iKey]), request);
                }
            }

            XBancConnection.SendContext(context);
            
            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if ((context._wtObjects[iKey] == null) ||
                    (context._wtObjects[iKey]._response == null))
                {
                    // prior error?
                    if (retVals[iKey] == 0)
                    {
                        // If the key is null, request never got sent, an indicator of fastfail
                        retVals[iKey] = (context._wtObjects[iKey] == null) ? HResult.XONLINE_E_RESOURCE_UNAVAILABLE : HResult.E_ABORT;
                    }
                }
                else
                {
                    try
                    {
                        // parse the response.
                        XBancIncrementResponse response = new XBancIncrementResponse();
                        response.ReadBytes(context._wtObjects[iKey]._response);

                        results[iKey] = response.qwResult;
                        retVals[iKey] = response.hr;
                    }
                    catch (Exception e)
                    {
                        retVals[iKey] = GetExtendedError(e, context._wtObjects[iKey]._response);
                    }
                }
            }
            
            return retVals;
        }

        public uint[] Health()
        {            
            // make a request copy for each server.
            uint cServers = XBancConnection.GetNumServers();
            XBancRemoveRequest[] requests = new XBancRemoveRequest[cServers];            
            for (uint iServer = 0; iServer < cServers; iServer++)
            {
                requests[iServer] = new XBancRemoveRequest();
                requests[iServer].rgbKey = System.Text.Encoding.ASCII.GetBytes("Health");
                requests[iServer].fMatchExact = true;
            }

            uint[] hrs = XBancConnection.SendToAllServers(requests, true);

            return hrs;
        }

        public static void ChangeSetting(object sender, SettingChangeEventArgs e)
        {
            if (e.Setting == Setting.xbanc_localCacheMaxSize)
            {
                uint size = UInt32.Parse(e.ValueNew);
                if (size == 0)
                {
                    // dont bother deleting everything from the old cache.  just create a new empty one.
                    m_cache = new CacheTable<ByteArray, XBancLocalCacheValue>("XBanc Proxy - " + Config.ComponentName, 0);
                }
                else
                {
                    m_cache.MaxSize = UInt32.Parse(e.ValueNew);
                }
            }
        }

    }

    public class XBancLocalCacheValue : IMeasurable
    {
        protected ByteArray _baKey;
        protected byte[] _value;
        protected long _expireTime;

        uint IMeasurable.GetSize()
        {
            return (uint)((_value == null) ? 0 : _value.Length) + (uint)((_baKey == null) ? 0 : (_baKey.Bytes == null) ? 8 : _baKey.Bytes.Length) + 16;
        }

        public XBancLocalCacheValue(ByteArray baKey, byte[] value)
        {
            _baKey = baKey;
            Init(value);
        }
        
        public void Init(byte[] value)
        {
            _value = value;
            _expireTime = (Config.GetLongSetting(Setting.xbanc_localCacheItemDuration) * 10 * 1000 * 1000) + DateTime.Now.Ticks;
        }

        public ByteArray GetKey()
        {
            return _baKey;
        }
        
        public byte[] GetValue()
        {
            return _value;
        }
        
        public long GetRemainingSeconds()
        {
            // only valid if IsExpired() is false.
            return (_expireTime - DateTime.Now.Ticks) / (10 * 1000 * 1000);
        }

        public bool IsExpired()
        {
            return (_expireTime <= DateTime.Now.Ticks);
        }
    }

    internal class XBancContext
    {
        public XBancWaitTableObject[] _wtObjects;
        public int _keysRemaining;
        public ManualResetEvent _event = null;

        public XBancContext(int numRequests)
        {
            _keysRemaining = 0;
            _wtObjects = new XBancWaitTableObject[numRequests];
            _event = new ManualResetEvent(false);
        }

        public void AddRequest(uint keyIndex, uint bucket, XBancMessageHeader request)
        {
            _wtObjects[keyIndex] = new XBancWaitTableObject(this, keyIndex, bucket, request);
            _keysRemaining++;
        }
    }

    internal class XBancWaitTableObject
    {
        public XBancContext _context;
        public XBancMessageHeader _request;
        public byte[] _response;
        public uint _keyIndex;
        public uint _seqnum;
        public uint _bucket;

        public XomRequestTimeElapsed _waitTime;

        public XBancWaitTableObject(XBancContext context, uint keyIndex, uint bucket, XBancMessageHeader request)
        {
            _context = context;
            _keyIndex = keyIndex;
            _bucket = bucket;
            _request = request;
            _seqnum = 0;
        }
    }

    internal class XBancConnection
    {
        private const int LOCK_TIMEOUT = 30000;
        private const int SEND_QUEUE_TIMEOUT = 1000;
        private const int REPLY_TIMEOUT = 3000;

        // an array of InhConnection objects, use
        // GetInhConnection to access it.
        private static ReaderWriterLock _rwlConnections = null;
        private static int[] _bucketMap = null;
        private static XBancConnection[] _connections = null;

        private static volatile bool _fInitialized = false;
        private static object _lockInit = new object();

        // fast fail
        private static FastFailHelper _fastFailHelper = null;

        private Socket _socket;
        private IInterfaceInfo _interfaceInfo;
        private string _serverName;
        private int _seqNum = 1;

        // asynch send stuff
        private bool _shutdown;
        private FastQueue _sendQueue;
        private AutoResetEvent _sendQueueEvent;
        private Hashtable _waitTable;
        private XboxLiveThread _sendThread;
        private XboxLiveThread _receiveThread;

        // perf counter instance specific to this connection
        private XBancConnectionCounters _instanceCounters;
        
        // Create the _connections
        static XBancConnection()
        {
            // setup config change handlers.
            Config.InterfaceBucketChange += new InterfaceBucketChangeEventHandler(XBancConnection.ChangeBucketMap);
            Config.ServerListChange += new ServerListChangeEventHandler(XBancConnection.ChangeServerList);

            // create a fast fail helper.
            _fastFailHelper = new FastFailHelper(
                Setting.xbanc_fastFailTimeoutThresholdCount, 
                Setting.xbanc_fastFailTimeoutTimespanSeconds, 
                Setting.xbanc_fastFailBlockIntervalSeconds);

            // create reader/writer lock for static connection management.
            _rwlConnections = new ReaderWriterLock();
        }

        //////////////////////////////////////////////////////////
        // Initialize
        //
        // Public static methods of this class MUST call this method (Initialize) to guarantee
        // all static members are properly initialized before doing any work
        // NOTE: This Initializes _connections and _bucketMap which are only used by public static members of this class
        private static void Initialize()
        {
            if ( !_fInitialized )
            {
                lock ( _lockInit )
                {
                    if ( !_fInitialized )
                    {
                        _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
                        try
                        {
                            LockCookie lc = _rwlConnections.UpgradeToWriterLock(LOCK_TIMEOUT);
                            try
                            {
                                // first get the servers.
                                string[] serverList = Config.GetServerListByInterface(Interface.xbanc);
                                _connections = new XBancConnection[serverList.Length];

                                for (int iServer = 0; iServer < _connections.Length; iServer++)
                                {
                                    IInterfaceInfo iface = Config.GetInterface(serverList[iServer], Interface.xbanc);

                                    // create the new InhConnection object
                                    Xom.Trace(
                                        "XBancProxy",
                                        LogLevel.L_NORMAL,
                                        "XBancConnection.InitConnections: creating new InhConnection to Inh server "
                                        + iServer.ToString()
                                        + ", IP address "
                                        +iface.IPAddressString);
                                    
                                    _connections[iServer] = new XBancConnection(iface, serverList[iServer]);
                                }
                                
                                // now we have to make the bucket map. 
                                uint numBuckets = Config.GetBucketCount(Interface.xbanc);
                                _bucketMap = new int[numBuckets];
                               
                                for (int iBucket = 0; iBucket < numBuckets; iBucket++)
                                {
                                    _bucketMap[iBucket] = -1;
                                    
                                    IBucketServer b = Config.GetBucketServer(Interface.xbanc, (uint)iBucket);

                                    // find this bucket's server in the list of servers
                                    for (int iServer = 0; iServer < serverList.Length; iServer++)
                                    {
                                        if (0 == String.Compare(b.CurrentServerName, serverList[iServer], StringComparison.OrdinalIgnoreCase))
                                        {
                                            // found it.
                                            _bucketMap[iBucket] = iServer;
                                            break;
                                        }
                                    }

                                    if (_bucketMap[iBucket] == -1)
                                    {
                                        Xom.NtEvent(XEvent.Id.XBANC_CODE_15, "Could not map bucket " + iBucket.ToString() + "to server " + b.CurrentServerName);
                                    }
                                }
                            }
                            finally
                            {
                                _rwlConnections.DowngradeFromWriterLock(ref lc);
                            }
                        }
                        finally
                        {
                            _rwlConnections.ReleaseReaderLock();
                        }
                        
                        _fInitialized = true;
                    }
                }
            }
        }
        
        public static void ChangeBucketMap(object sender, InterfaceBucketChangeEventArgs e)
        {
            if (e.Interface != Interface.xbanc)
            {
                // we're only concerned with xbanc's buckets.
                return;
            }
            
            if (0 == String.Compare(e.ValueNew.CurrentServerName, e.ValueOld.CurrentServerName, StringComparison.OrdinalIgnoreCase))
            {
                // no change that we care about.
                return;
            }
            
            bool fChanged = false;

            // Ensure static initialization complete, see Initialize
            Initialize();
            
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                LockCookie lc = _rwlConnections.UpgradeToWriterLock(LOCK_TIMEOUT);
                try
                {            
                    for (int iServer = 0; iServer < _connections.Length; iServer++)
                    {
                        if (0 == String.Compare(e.ValueNew.CurrentServerName, _connections[iServer].GetServerName(), StringComparison.OrdinalIgnoreCase))
                        {
                            _bucketMap[e.Bucket] = iServer;
                            fChanged = true;
                            break;
                        }
                    }
                }
                finally
                {
                    _rwlConnections.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                _rwlConnections.ReleaseReaderLock();
            }

            if (!fChanged)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.XBANC_CODE_16, "XBancConnection::ChangeBucketMap() could not find a connection to server " + e.ValueNew.CurrentServerName);
            }
        }

        public static void ChangeServerList(object sender, ServerListChangeEventArgs e)
        {
            if (e.Interface != Interface.xbanc)
            {
                // we're only concerned with xbanc's servers.
                return;
            }

            // Ensure static initialization complete, see Initialize
            Initialize();
            
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                // build a translation map for the indices.
                int[] iIndexMap = new int[_connections.Length];

                for (int iOldServer = 0; iOldServer < _connections.Length; iOldServer++)
                {
                    iIndexMap[iOldServer] = -1;
                    for (int iNewServer = 0; iNewServer < e.ValueNew.Length; iNewServer++)
                    {
                        if (0 == String.Compare(_connections[iOldServer].GetServerName(), e.ValueNew[iNewServer], StringComparison.OrdinalIgnoreCase))
                        {
                            iIndexMap[iOldServer] = iNewServer;
                        }
                    }
                }

                LockCookie lc = _rwlConnections.UpgradeToWriterLock(LOCK_TIMEOUT);
                try
                {
                    // make a new connection list and copy over any old connections that still remain.
                    XBancConnection[] newConnections = new XBancConnection[e.ValueNew.Length];
                    for (int iOldServer = 0; iOldServer < _connections.Length; iOldServer++)
                    {
                        if (iIndexMap[iOldServer] == -1)
                        {
                            // not in the map -- we dont need this one anymore.
                            _connections[iOldServer].Shutdown(false);
                        }
                        else
                        {
                            newConnections[iIndexMap[iOldServer]] = _connections[iOldServer];
                        }                

                        _connections[iOldServer] = null;
                    }

                    // make new connections
                    for (int iNewServer = 0; iNewServer < newConnections.Length; iNewServer++)
                    {
                        if (newConnections[iNewServer] == null)
                        {
                            IInterfaceInfo iface = Config.GetInterface(e.ValueNew[iNewServer], Interface.xbanc);

                            // create the new InhConnection object
                            Xom.Trace(
                                "XBancProxy",
                                LogLevel.L_NORMAL,
                                "XBancConnection.ChangeServerList: creating new InhConnection to Inh server "
                                + iNewServer.ToString()
                                + ", IP address "
                                +iface.IPAddressString);
                            
                            newConnections[iNewServer] = new XBancConnection(iface, e.ValueNew[iNewServer]);
                        }
                    }

                    // switch to the new connection list
                    _connections = newConnections;

                    // rearrange the bucket map
                    for (int iBucket = 0; iBucket < _bucketMap.Length; iBucket++)
                    {
                        _bucketMap[iBucket] = iIndexMap[_bucketMap[iBucket]];
                        if (_bucketMap[iBucket] == -1)
                        {
                            Xom.NtEvent(XEvent.Id.XBANC_CODE_17, "Could not map bucket " + iBucket.ToString() + "to server.  Check config for consistency.");
                        }
                    }
                }
                finally
                {
                    _rwlConnections.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                _rwlConnections.ReleaseReaderLock();
            }
        }

        public static uint GetNumBuckets()
        {
            // Ensure static initialization complete, see Initialize
            Initialize();
            
            uint cBuckets = 0;
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            cBuckets = (uint)_bucketMap.Length;
            _rwlConnections.ReleaseReaderLock();
            return cBuckets;
        }

        public static uint GetNumServers()
        {
            // Ensure static initialization complete, see Initialize
            Initialize();
            
            uint cServers = 0;
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            cServers = (uint)_connections.Length;
            _rwlConnections.ReleaseReaderLock();
            return cServers;
        }

        public string GetServerName()
        {
            return _serverName;
        }

        public static XBancConnection GetInhConnection(uint bucketNum)
        {
            XBancConnection xbcRet = null;
            
            // Ensure static initialization complete, see Initialize
            Initialize();
            
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                int iServer = _bucketMap[bucketNum];
                if (iServer != -1)
                {
                    xbcRet = _connections[iServer];
                }
            }
            finally
            {
                _rwlConnections.ReleaseReaderLock();
            }

            return xbcRet;
        }

        public static void ShutdownAll()
        {
            // Ensure static initialization complete, see Initialize
            Initialize();
            
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                LockCookie lc = _rwlConnections.UpgradeToWriterLock(LOCK_TIMEOUT);
                try
                {
                    Xom.Trace(XomAreaName.XBancProxy, LogLevel.L_NORMAL, "XBancConnection.ShutdownAll: called");
                    foreach (XBancConnection inhConnection in _connections)
                    {
                        inhConnection.Shutdown(true);
                    }
                    Xom.Trace(XomAreaName.XBancProxy, LogLevel.L_NORMAL, "XBancConnection.ShutdownAll: complete");
                }
                finally
                {
                    _rwlConnections.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                _rwlConnections.ReleaseReaderLock();
            }
        }

        public XBancConnection(IInterfaceInfo interfaceInfo, string serverName)
        {
            // This contains the IP:port info we need to connect to the
            // INH server.
            _interfaceInfo = interfaceInfo;

            // we use the server name to match connections to buckets.
            _serverName = serverName;

            // Get a perf counter instance for this particular connection
            _instanceCounters = XBancConnectionCounters.Total[Config.ComponentName + " - " + _interfaceInfo.IPAddressString];

            // We call Connect() here to create the initial socket and connect
            // it to the INH server. That way, if there are any fundamental
            // communications problems, this thread will see the SocketException
            // right away, and won't have to wait until a Send attempt fails.
            try
            {
                Connect();
            }
            catch (SocketException)
            {
                // dont puke here if the server isnt up yet.
            }

            _shutdown = false;

            // This is a queue of requests to be sent to the INH server.
            _sendQueue = new FastQueue(10000, false);

            // When a new item is put into the queue, this event is signaled,
            // which will wake up the SendThread if it has gone to sleep
            _sendQueueEvent = new AutoResetEvent(false);

            // This is a table of requests which have been sent to the INH
            // server, and are waiting on a response from the INH server
            // It is syncronized because it is shared between the SendThread,
            // the ReceiveThread, and the calling thread (via the Timeout method)
            _waitTable = Hashtable.Synchronized(new Hashtable());

            // Start the send thread
            _sendThread = new XboxLiveThread(new ThreadStart(this.SendThread));
            _sendThread.IsBackground = true;
            _sendThread.Start();

            // Start the receive thread
            _receiveThread = new XboxLiveThread(new ThreadStart(this.ReceiveThread));
            _receiveThread.IsBackground = true;
            _receiveThread.Start();

            Xom.Trace(
                "XBancProxy",
                LogLevel.L_NORMAL,
                "XBancConnection.ctor: XBancConnection creation successful for "
                + _interfaceInfo.IPAddressString);
        }

        public void Shutdown()
        {
            Shutdown(true);
        }
        public void Shutdown(bool fWait)
        {
            Xom.Trace(XomAreaName.XBancProxy, LogLevel.L_NORMAL,
                "XBanc.Shutdown: Shutdown called for InhConnection to "
                + _interfaceInfo.IPAddressString);

            // set the shutdown flag, which will tell the send and receive
            // threads to begin shutting down
            _shutdown = true;

            if (fWait)
            {
                // wait for the send and receive threads to shutdown
                _sendThread.Join();
                _receiveThread.Join();
            }

            Xom.Trace(XomAreaName.XBancProxy, LogLevel.L_LOW,
                "XBanc.Shutdown: InhConnection successfully shutdown for  "
                + _interfaceInfo.IPAddressString);
        }

        public bool IsValidConnection()
        {
            return (_socket != null && _socket.Connected);
        }

        public bool IsInFastFail()
        {
            return _fastFailHelper.InFastFailState(_interfaceInfo.IPAddressString);
        }

        // Gets the current socket connection, verifying the health of the socket
        // and (re)connecting it if required
        public void Connect()
        {
            if (IsValidConnection())
            {
                return;
            }
            
            try
            {
                _instanceCounters.ConnectionAttempts.Increment();
                XBancConnectionCounters.Total.ConnectionAttempts.Increment();
                
                // create a new socket
                Xom.Trace(XomAreaName.XBancProxy, LogLevel.L_NORMAL,
                    "XPNFD.InhConnection.GetSocket: creating new socket connection to "
                    + _interfaceInfo.IPAddressString);
                
                _socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream,
                    ProtocolType.Tcp);

                // connect to the specified INH server
                IPEndPoint ipEndPoint =
                    new IPEndPoint(_interfaceInfo.IPAddress, _interfaceInfo.Port);
                _socket.Connect(ipEndPoint);
            }
            catch (SocketException se)
            {
                Disconnect();
                Xom.NtEvent(XEvent.Id.XBANC_CODE_18, se, "Could not establish socket to " + _serverName + ".  The server is probably not running yet.");
            }
        }
        
        public void Disconnect()
        {
            lock (this)
            {
                if (_socket != null)
                {
                    try
                    {
                        _socket.Shutdown(SocketShutdown.Both);
                        _socket.Close();
                    }
                    catch (SocketException)
                    {
                        // eat any exception here.  we're closing anyway.
                    }
                    
                    _socket = null;
                }
            }
        }

        public bool Send(byte[] msg, uint seqNum)
        {
            bool fRetry = true;
            
            while ( IsValidConnection() )
            {
                try
                {
                    // break up msg into packets small enough to be received by the server.
                    int cbStart = 0;
                    int cbLeft = msg.Length;
                    while (cbLeft > 0)
                    {
                        int maxSize = (int)XBancDefs.XBANC_MAX_PACKET_SIZE;
                        
                        if (cbStart > 0)
                        {
                            // this isnt the first packet.  make a continuation header to send first.
                            XBancMessageHeader header = new XBancMessageHeader(XBANC_MSG_TYPES.XBMSG_CONTINUATION_REQ);

                            // the header contribuites to the packet size.
                            maxSize -= header.Size();
                            
                            header.dwMsgLen = (cbLeft > maxSize) ? XBancDefs.XBANC_MAX_PACKET_SIZE : (uint)(cbLeft + header.Size());
                            header.dwSeqNum = seqNum;

                            // cant use header.WriteStream() here because it overwrites dwMsgLen.
                            MemoryStream stream = new MemoryStream();
                            BinaryWriter writer = new BinaryWriter(stream);
                            writer.Write(header.dwProtocolVersion);
                            writer.Write(header.dwMsgType);
                            writer.Write(header.dwMsgLen);
                            writer.Write(header.dwSeqNum);

                            // send the header
                            _socket.Send(stream.ToArray());
                        }
                        
                        int cbSent = _socket.Send(
                            msg, 
                            cbStart, 
                            (cbLeft > maxSize) ? maxSize : cbLeft,
                            SocketFlags.None);

                        cbStart += cbSent;
                        cbLeft -= cbSent;
                    }
                    
                    return true;
                }
                catch (SocketException se)
                {
                    Xom.NtEvent(XEvent.Id.XBANC_CODE_19, se, "Unexpected exception caught " + (fRetry ? " Will attempt 1 retry." : ""));
                    
                    if (fRetry)
                    {
                        fRetry = false;
                        Disconnect();
                        Connect();
                    }
                    else
                    {
                        throw;
                    }
                }
            }
            
            Disconnect();
            return false;
        }

        public byte[] Recv()
        {
            if( IsValidConnection() )
            {
                try
                {
                    // buffer to receive header.
                    byte[] headerBuf = new byte[XBancDefs.XBANC_MESSAGE_HEADER_SIZE];

                    int cTotalBytes = 0;
                    while (cTotalBytes < headerBuf.Length)
                    {
                        int cBytes = _socket.Receive(headerBuf, cTotalBytes, headerBuf.Length - cTotalBytes, SocketFlags.None);
                        if (cBytes == 0)
                        {
                            throw new ApplicationException( "XBancConnection.Read(): Received 0 bytes");
                        }
                        else
                        {
                            cTotalBytes += cBytes;
                        }
                    }

                    XBancMessageHeader msgHeader = new XBancMessageHeader();
                    msgHeader.ReadBytes(headerBuf);
                    
                    // make a new buffer for header + data
                    byte[] buf = new byte[msgHeader.dwMsgLen];

                    // copy the header
                    for (int iHeader = 0; iHeader < headerBuf.Length; iHeader++)
                    {
                        buf[iHeader] = headerBuf[iHeader];
                    }
                    
                    while (cTotalBytes < buf.Length)
                    {
                        int cBytes = _socket.Receive(buf, cTotalBytes, buf.Length - cTotalBytes, SocketFlags.None);
                        if (cBytes == 0)
                        {
                            throw new ApplicationException( "XBancConnection.Read(): Received 0 bytes");
                        }
                        else
                        {
                            cTotalBytes += cBytes;
                        }
                    }

                    return buf;
                }
                catch(Exception e)
                {
                    Xom.NtEvent(XEvent.Id.XBANC_CODE_20, e, "Unexpected exception caught");
                }
            }
            
            Disconnect();
            return null;
        }

        protected uint GetNextSequenceNumber()
        {
            return (uint)Interlocked.Increment(ref _seqNum);
        }

        public static void SendToAllServers(XBancMessageHeader[] requests)
        {
            SendToAllServers(requests, false);
        }
        
        public static uint[] SendToAllServers(XBancMessageHeader[] requests, bool fWait)
        {
            int timeout = REPLY_TIMEOUT;
            uint[] retVals = null;
            
            // Ensure static initialization complete, see Initialize
            Initialize();
            
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                // need a copy per server.
                if (requests.Length != _connections.Length)
                {
                    throw new ApplicationException( "XBancConnection.SendToAllServers(): incorrect number of servers specified.  This should only happen during an XBanc INH server list change.");
                }
                
                XBancContext context = new XBancContext(_connections.Length);

                // add all requests before sending any.
                for (uint iServer = 0; iServer < _connections.Length; iServer++)
                {
                    context.AddRequest(iServer, 0, requests[iServer]);
                }

                // now send the requests.
                for(uint iServer = 0; iServer < _connections.Length; iServer++)
                {
                    if (!(_connections[iServer].SendToServer(context._wtObjects[iServer])))
                    {
                        // failed to send this object.
                        Interlocked.Decrement(ref context._keysRemaining);
                        context._wtObjects[iServer] = null;
                    }
                }

                if (fWait)
                {
                    if ((context._keysRemaining > 0) && !(context._event.WaitOne(timeout, false)))
                    {
                        // timed out.  find all the missing replies and remove from waittables.
                        for (uint iServer = 0; iServer < context._wtObjects.Length; iServer++)
                        {
                            if ((context._wtObjects[iServer] != null) && (context._wtObjects[iServer]._response == null))
                            {
                                _connections[iServer].TimeoutWaitTableObject(context._wtObjects[iServer]);
                            }
                        }
                    }

                    retVals = new uint[_connections.Length];
                    for (uint iResponse = 0; iResponse < _connections.Length; iResponse++)
                    {
                        if ((context._wtObjects[iResponse] == null) || 
                            (context._wtObjects[iResponse]._response == null))
                        {
                            // If the key is null, request never got sent, an indicator of fastfail
                            retVals[iResponse] = (context._wtObjects[iResponse] == null) ? HResult.XONLINE_E_RESOURCE_UNAVAILABLE : HResult.E_ABORT;
                        }
                        else
                        {
                            try
                            {
                                // parse the response.
                                XBancEmptyResponse response = new XBancEmptyResponse();
                                response.ReadBytes(context._wtObjects[iResponse]._response);

                                retVals[iResponse] = response.hr;
                            }
                            catch (Exception)
                            {
                                retVals[iResponse] = HResult.E_ABORT;
                            }                            
                        }
                    }
                }
            }
            finally
            {
                _rwlConnections.ReleaseReaderLock();
            }

            return retVals;
        }

        public static void SendContext(XBancContext context)
        {
            int timeout = REPLY_TIMEOUT;
            try
            {
                timeout = Config.GetIntSetting(Setting.xbanc_replyTimeout);
                if (timeout == 0)
                {
                    // this means xbanc is disabled.  dont bother trying to send anything.
                    return;
                }
            }
            catch (Exception)
            {
                // eat this is if the setting doesnt exist.
            }
            
            // Ensure static initialization complete, see Initialize
            Initialize();
            
            for (uint iKey = 0; iKey < context._wtObjects.Length; iKey++)
            {
                if (context._wtObjects[iKey] != null)
                {
                    XBancConnection xbc = GetInhConnection(context._wtObjects[iKey]._bucket);
                    if (!(xbc.SendToServer(context._wtObjects[iKey])))
                    {
                        // failed to send this object.
                        Interlocked.Decrement(ref context._keysRemaining);
                        context._wtObjects[iKey] = null;
                    }
                }
            }

            if ((context._keysRemaining > 0) && !(context._event.WaitOne(timeout, false)))
            {
                // timed out.  find all the missing replies and remove from waittables.
                for (uint iKey = 0; iKey < context._wtObjects.Length; iKey++)
                {
                    if ((context._wtObjects[iKey] != null) && (context._wtObjects[iKey]._response == null))
                    {
                        XBancConnection xbc = GetInhConnection(context._wtObjects[iKey]._bucket);
                        xbc.TimeoutWaitTableObject(context._wtObjects[iKey]);
                    }
                }
            }
        }

        public bool SendToServer(XBancWaitTableObject wto)
        {
            // check fast fail first.
            if (IsInFastFail())
            {
                return false;
            }
            
            _instanceCounters.RequestRate.Increment();
            XBancConnectionCounters.Total.RequestRate.Increment();
            wto._waitTime = new XomRequestTimeElapsed();

            wto._seqnum = GetNextSequenceNumber();
            wto._request.dwSeqNum = wto._seqnum;
            _sendQueue.Enqueue(wto);
            _sendQueueEvent.Set();

            _instanceCounters.EnqueueRate.Increment();
            _instanceCounters.QueueSize.Increment();
            XBancConnectionCounters.Total.EnqueueRate.Increment();
            XBancConnectionCounters.Total.QueueSize.Increment();

            return true;
        }

        public void TimeoutWaitTableObject(XBancWaitTableObject wto)
        {
            // timed out waiting for a response.  remove it from the wait table.
            XBancWaitTableObject wtoRemoved;
            lock (_waitTable.SyncRoot)
            {
                wtoRemoved = (XBancWaitTableObject)_waitTable[wto._seqnum];
                _waitTable.Remove(wto._seqnum);
            }
            if (wtoRemoved != null)
            {
                _instanceCounters.WaitTableSize.Decrement();
                XBancConnectionCounters.Total.WaitTableSize.Decrement();
                _instanceCounters.ConcurrentRequests.Decrement();
                XBancConnectionCounters.Total.ConcurrentRequests.Decrement();
            }

            // report failure to fail fast.
            _fastFailHelper.ReportFailure(_interfaceInfo.IPAddressString, "Timed out.");

            _instanceCounters.RequestTimeAvg.IncrementBy(wto._waitTime.TimeElapsed);
            _instanceCounters.RequestTimeAvgBase.Increment();
            XBancConnectionCounters.Total.RequestTimeAvg.IncrementBy(wto._waitTime.TimeElapsed);
            XBancConnectionCounters.Total.RequestTimeAvgBase.Increment();
        }            

        public void DrainSendQueue()
        {
            // loop until queue is empty
            while (true)
            {
                XBancWaitTableObject wto = (XBancWaitTableObject)_sendQueue.Dequeue();
                if (wto != null)
                {
                    bool fSent = false;
                    // queue is syncronized
                    try
                    {                        
                        // update the queue wait perf counters
                        long elapsed = wto._waitTime.TimeElapsed;
                        XBancConnectionCounters.Total.QueueWaitTimeAvg.IncrementBy(elapsed);
                        XBancConnectionCounters.Total.QueueWaitTimeAvgBase.Increment();
                        _instanceCounters.QueueWaitTimeAvg.IncrementBy(elapsed);
                        _instanceCounters.QueueWaitTimeAvgBase.Increment();

                        XBancConnectionCounters.Total.QueueSize.Decrement();
                        _instanceCounters.QueueSize.Decrement();

                        _instanceCounters.ConcurrentRequests.Increment();
                        XBancConnectionCounters.Total.ConcurrentRequests.Increment();
                        // if we are supposed to wait for a response from the
                        // INH server, then put this context into the wait
                        // table.
                        // We want to so this *before* we actually send,
                        // because the INH server could respond before we've 
                        // finished adding the context to the wait table.

                        // store the current time in the context
                        wto._waitTime = new XomRequestTimeElapsed();

                        _waitTable.Add(wto._seqnum, wto);

                        // update perf counters
                        XBancConnectionCounters.Total.WaitTableSize.Increment();
                        _instanceCounters.WaitTableSize.Increment();

                        // now do the send
                        Connect();
                        fSent = Send((byte[])(wto._request), wto._seqnum);
                    }
                    finally
                    {
                        if (!fSent)
                        {
                            _instanceCounters.ConcurrentRequests.Decrement();
                            XBancConnectionCounters.Total.ConcurrentRequests.Decrement();
                            
                            // removes the item from the wait table, regardless of if it's there or not.
                            XBancWaitTableObject wtoRemoved;
                            lock (_waitTable.SyncRoot)
                            {
                                wtoRemoved = (XBancWaitTableObject)_waitTable[wto._seqnum];
                                _waitTable.Remove(wto._seqnum);
                            }
                            if (wtoRemoved != null)
                            {
                                _instanceCounters.WaitTableSize.Decrement();
                                XBancConnectionCounters.Total.WaitTableSize.Decrement();
                            }

                            if (0 == Interlocked.Decrement(ref wto._context._keysRemaining))
                            {
                                wto._context._event.Set();
                            }
                        }
                    }
                }
                else
                {
                    // queue is empty, break out of the loop and go back to sleep.
                    break;
                }
            }
        }

        public void SendThread()
        {
            try
            {
                // keep processing work items on the queue until we break out of
                // this loop because the _shutdown flag is set
                while (!_shutdown)
                {
                    try
                    {
                        // Wait for an item to be put on the queue
                        if (_sendQueueEvent.WaitOne(SEND_QUEUE_TIMEOUT, false))
                        {
                            // we have work to do
                            DrainSendQueue();
                        }
                    }
                    catch (Exception e)
                    {
                        try
                        {
                            // we don't want an exception to cause this thread to
                            // terminate, so we catch it, log it, and move along
                            Xom.NtEvent(XEvent.Id.XBANC_CODE_19, e,
                                "Unexpected Exception thrown in SendThread for connection to INH at {0}",
                                _interfaceInfo.IPAddressString
                            );
                        }
                        catch (Exception)
                        {
                            // eat anything else that could possibly go wrong.
                        }
                    }
                }
            }
            finally
            {
                try
                {
                    // kill the socket. If we don't do this, the receive
                    // thread will never exit.
                    Disconnect();
                }
                catch (Exception)
                {
                    // eat anything else that could possibly go wrong.
                }
            }            
        }

        public void ReceiveMessage()
        {
            try
            {
                // read a response.
                byte[] rgbResp = Recv();
                if (rgbResp == null)
                {
                    return;
                }

                // get the sequence number
                XBancMessageHeader response = new XBancMessageHeader();
                response.ReadBytes(rgbResp);

                // find the matching Context in the wait table.
                XBancWaitTableObject wto;
                lock (_waitTable.SyncRoot)
                {
                    wto = (XBancWaitTableObject)_waitTable[response.dwSeqNum];
                    _waitTable.Remove(response.dwSeqNum);
                }

                if (wto == null)
                {
                    // this is expected for contexts that werent waiting (e.g. multi-server remove requests).  do nothing.
                }
                else
                {
                    _instanceCounters.ConcurrentRequests.Decrement();
                    XBancConnectionCounters.Total.ConcurrentRequests.Decrement();

                    wto._response = rgbResp;

                    // Update perf counters
                    long elapsed = wto._waitTime.TimeElapsed;
                    XBancConnectionCounters.Total.WaitTableSize.Decrement();
                    XBancConnectionCounters.Total.WaitTableWaitTimeAvg.IncrementBy(elapsed);
                    XBancConnectionCounters.Total.WaitTableWaitTimeAvgBase.Increment();
                    _instanceCounters.WaitTableSize.Decrement();
                    _instanceCounters.WaitTableWaitTimeAvg.IncrementBy(elapsed);
                    _instanceCounters.WaitTableWaitTimeAvgBase.Increment();
                    
                    _fastFailHelper.ReportSuccess(_interfaceInfo.IPAddressString);

                    if (0 == Interlocked.Decrement(ref wto._context._keysRemaining))
                    {
                        wto._context._event.Set();
                    }
                }
            }
            catch (Exception)
            {
                // Any exceptions at all leave the stream in a bad state. We could be half way
                // through a message, or the socket could have failed, or ?
                // In any of these situations, we invalidate the socket, so we will 
                // reconnect. If there are messages already in the receive buffer,
                // they are going to be lost.
                // Any affected contexts will eventually be timed out and removed from the wait
                // table. Since we didn't successfully receive a complete message
                // we don't really trust the sequence number enough to associate this
                // exception with any particular context, so we don't do anything
                // with the exception except log it.
                // However, during a shutdown, the send thread kills the socket for us,
                // so if we are shutting down, we just eat the exception and move merrily
                // along
                if (!_shutdown)
                {
                    Disconnect();
                    throw;
                }
            }
        }

        public void ReceiveThread()
        {
            // keep receiving messages from the INH server until we break out of
            // this loop because the _shutdown flag is set
            while (!_shutdown)
            {
                try
                {
                    // dont try to receive if the socket is dead.
                    if (IsValidConnection())
                    {
                        ReceiveMessage();
                    }
                    else
                    {
                        Thread.Sleep(1000);
                    }
                }
                catch (Exception e)
                {
                    // we don't want an exception to cause this thread to
                    // terminate, so we catch it, log it, and move along
                    try
                    {
                        Xom.NtEvent(XEvent.Id.XBANC_CODE_20, e,
                            "Unexpected Exception thrown in ReceiveThread for InhConnection to {0}",
                            _interfaceInfo.IPAddressString
                        );
                    }
                    catch (Exception)
                    {
                        // eat anything else that could possibly go wrong.
                    }
                }
            }
        }

    }
    
    [XomPerformanceCounterCategoryAttr( "XBanc Proxy", "XBox Live XBanc Service Proxy: Connections to XBanc INH Servers", true )]
    public class XBancConnectionCounters : XomPerformanceCounterCategory
    {
        public virtual XBancConnectionCounters this[string instanceName]
        {
            get
            {
                return (XBancConnectionCounters) GetInstance(instanceName);
            }
        }

        static public XBancConnectionCounters Total = new XBancConnectionCounters();

        public XBancConnectionCounters() : base()
        {
            RequestRate.RawValue = 0;
            RequestTimeAvg.RawValue = 0;
            RequestTimeAvgBase.RawValue = 0;
            ConnectionAttempts.RawValue = 0;
            ConcurrentRequests.RawValue = 0;
            EnqueueRate.RawValue = 0;
            QueueSize.RawValue = 0;
            QueueWaitTimeAvg.RawValue = 0;
            QueueWaitTimeAvgBase.RawValue = 0;
            WaitTableSize.RawValue = 0;
            WaitTableWaitTimeAvg.RawValue = 0;
            WaitTableWaitTimeAvgBase.RawValue = 0;
        }

        [XomPerformanceCounterAttr(
            "Request Rate", 
            "Number of requests per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestRate;

        [XomPerformanceCounterAttr(
            "Request Time Average", 
            "Average time taken per request.", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter RequestTimeAvg;
        
        [XomPerformanceCounterAttr(
            "Request Time Average Base", 
            "Base for average time taken per request.", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter RequestTimeAvgBase;

        [XomPerformanceCounterAttr(
            "Connection attempts", 
            "Total number of attempts to connect this socket.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter ConnectionAttempts;

        [XomPerformanceCounterAttr(
            "Concurrent requests", 
            "Total number of requests waiting for a response.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter ConcurrentRequests;

        [XomPerformanceCounterAttr(
            "Enqueue Rate", 
            "Number of requests per second added to send queue waiting to be sent to the INH server", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter EnqueueRate;

        [XomPerformanceCounterAttr(
            "Queue Size", 
            "Total number of requests in the send queue waiting to be sent to the INH server", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter QueueSize;

        [XomPerformanceCounterAttr(
            "Queue Wait Time Average", 
            "Average time a request is in the send queue waiting to be sent to the INH server", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter QueueWaitTimeAvg;
        
        [XomPerformanceCounterAttr(
            "Queue Wait Time Average Base", 
            "Base for average time a request is in the send queue waiting to be sent to the INH server", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter QueueWaitTimeAvgBase;

        [XomPerformanceCounterAttr(
            "Wait Table Size", 
            "Total number of requests waiting in the wait table for a response from the INH server", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter WaitTableSize;

        [XomPerformanceCounterAttr(
            "Wait Table Wait Time Average", 
            "Average time a request is waiting in the wait table waiting for a response from the INH server", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter WaitTableWaitTimeAvg;
        
        [XomPerformanceCounterAttr(
            "Wait Table Wait Time Average Base", 
            "Base for average time a request is waiting in the wait table waiting for a response from the INH server", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter WaitTableWaitTimeAvgBase;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\XblX509CertificateValidator.cs ===
// 
// XblX509CertificateValidator.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// X509CertificateValidator derived class for Saml Token certificate validation
//

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.IdentityModel.Selectors;
using System.IdentityModel.Tokens;
using System.Security.Cryptography.X509Certificates;
using System.ServiceModel.Security;
using System.Text;
using System.Xml;

using xonline.common.exceptions;

namespace xonline.common.service
{

internal class XblX509CertificateValidator : X509CertificateValidator
{
    protected string[] _allowedThumbprints;
    
    public XblX509CertificateValidator(string[] allowedThumbprints)
    {
        _allowedThumbprints = allowedThumbprints;
    }
    
    // -------------------------------------------------------------------------------
    // Implementation public
    // -------------------------------------------------------------------------------

    public override void Validate(X509Certificate2 certificate)
    {
        // Is this token signed with the right certificate?
        bool isValid = false;
        foreach (string thumbprint in _allowedThumbprints)
        {
            if (0 == string.Compare(thumbprint, certificate.Thumbprint, true))
            {
                isValid = true;
                break;
            }
        }

        if (!isValid)
        {
            StringBuilder message = new StringBuilder();

            message.AppendFormat("; SAML Assertion SigningToken was {0}, but one of the following was expected:", certificate.Thumbprint);
            foreach(string thumbprint in _allowedThumbprints)
            {
                message.AppendFormat("\r\n\t{0}", thumbprint);
            }

            throw new SecurityTokenValidationException(message.ToString());
        }
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\XblSamlToken.cs ===
// 
// XblSamlToken.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Wrapper class for Xbl1.0 Saml Token
//

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.IdentityModel.Selectors;
using System.IdentityModel.Tokens;
using System.Security.Cryptography.X509Certificates;
using System.ServiceModel.Security;
using System.Text;
using System.Xml;

using xonline.common.exceptions;

namespace xonline.common.service
{

public class XblSamlToken
{
    public const int xbl10_samlmajorversion     = 1;
    public const int xbl10_samlminorversion     = 1;
    public const string xbl10_samlissuer        = "http://sts.xboxlive.com";
    public const string ns_attribute_claims     = "http://xboxlive.com/claims";

    public const string subject_name_machine    = "XboxLive Machine security ticket";
    public const string subject_name_partner    = "XboxLive Partner security ticket";
    public const string subject_name_user       = "XboxLive User security ticket";
    
    public const string name_attribute_platformtype     = "PlatformType";
    public const string name_attribute_machineid        = "MachineID";
    public const string name_attribute_deviceid         = "DeviceID";
    public const string name_attribute_clientversion    = "ClientVersion";
    public const string name_attribute_titleid          = "TitleID";
    public const string name_attribute_titleversion     = "TitleVersion";
    public const string name_attribute_puid0 = "Puid0";
    public const string name_attribute_cid0 = "CID0";
    public const string name_attribute_xuid0 = "Xuid0";
    public const string name_attribute_gamertag0 = "Gamertag0";
    public const string name_attribute_tier0 = "Tier0";
    public const string name_attribute_country0 = "Country0";
    public const string name_attribute_privileges0 = "Privileges0";
    public const string name_attribute_partnerid0 = "PartnerID0";

    // Base strings, for iterating over all slots.
    public const string name_attribute_puid = "Puid{0}";
    public const string name_attribute_cid = "CID{0}";
    public const string name_attribute_xuid = "Xuid{0}";
    public const string name_attribute_gamertag = "Gamertag{0}";
    public const string name_attribute_tier = "Tier{0}";
    public const string name_attribute_country = "Country{0}";
    public const string name_attribute_privileges = "Privileges{0}";
    public const string name_attribute_partnerid = "PartnerID{0}";

    // Attributes
    protected SamlSecurityToken _samlSecurityToken;
    protected Dictionary<string, string> _claims = new Dictionary<string, string>();
    
    // Constructor
    public XblSamlToken( string samlToken )
    {
        _samlSecurityToken = XblSamlToken.GetTokenFromString(samlToken);

        // Populate the dictionary from token Attributes
        IList<SamlAttribute> samlAttributes = ((SamlAttributeStatement)_samlSecurityToken.Assertion.Statements[0]).Attributes;
        
        foreach ( SamlAttribute samlAttribute in samlAttributes )
        {
            _claims.Add(samlAttribute.Name, samlAttribute.AttributeValues[0]);
        }
        
    }

    // Properties
    public IList<SamlAttribute> Attributes
    {
        get {
            return ((SamlAttributeStatement)_samlSecurityToken.Assertion.Statements[0]).Attributes;
        }
    }

    public bool IsMachineTicket
    {
        get { 
            return (subject_name_machine==SubjectName);
        }
    }

    public bool IsPartnerTicket
    {
        get { 
            return (subject_name_partner==SubjectName);
        }
    }
    
    public bool IsUserTicket
    {
        get { 
            return (subject_name_user==SubjectName);
        }
    }
    
    public string Issuer
    {
        get {
            return _samlSecurityToken.Assertion.Issuer;
        }
    }
    
    public int MajorVersion
    {
        get {
            return _samlSecurityToken.Assertion.MajorVersion;
        }
    }
    
    public int MinorVersion
    {
        get {
            return _samlSecurityToken.Assertion.MinorVersion;
        }
    }
    
    public DateTime NotBefore
    {
        get {
            return _samlSecurityToken.Assertion.Conditions.NotBefore;
        }
    }

    public SamlSecurityToken SecurityToken
    {
        get {
            return _samlSecurityToken;
        }
    }
    
    public SamlSubject Subject
    {
        get {
            return ((SamlSubjectStatement)_samlSecurityToken.Assertion.Statements[0]).SamlSubject;
        }
    }

    public string SubjectName
    {
        get {
            return ((SamlSubjectStatement)_samlSecurityToken.Assertion.Statements[0]).SamlSubject.Name;
        }
    }
    
    public DateTime ValidTo
    {
        get {
            return _samlSecurityToken.ValidTo;
        }
    }

    // -------------------------------------------------------------------------------
    // Implementation static public
    // -------------------------------------------------------------------------------

    // -------------------------------------------------------------------------------
    // GetCertificateBySubjectName
    //
    // Used for SAML Token signing
    // -------------------------------------------------------------------------------
    static public X509Certificate2Collection GetCertificateBySubjectName(string certSubject, bool isPrivateKeyRequired, bool thereCanBeOnlyOne)
    {
        X509Certificate2Collection certificates;
        X509Store store = new X509Store(StoreName.My, StoreLocation.LocalMachine);
        
        store.Open(OpenFlags.ReadOnly);
        
        try
        {
            // Find the certificate that matches the subject
            certificates = store.Certificates.Find(X509FindType.FindBySubjectName, certSubject, false);
            // Make sure this list doesn't include any "near" matches
            for (int i = 0; i < certificates.Count; )
            {
                X509Certificate2 cert = certificates[i];
                string name = cert.SubjectName.Name;
                string commonName;

                int startCommonName = name.IndexOf("CN=") + 3;
                int endCommonName = name.IndexOf(",", startCommonName);
                if (-1 == endCommonName)
                {
                    commonName = name.Substring(startCommonName);
                }
                else
                {
                    commonName = name.Substring(startCommonName, endCommonName - startCommonName);
                }

                // Now check for an exact match on the name
                if (!string.Equals(certSubject, commonName, StringComparison.OrdinalIgnoreCase))
                {
                    certificates.RemoveAt(i);
                    cert.Reset();
                }
                else
                {
                    i++;
                }
            }
        }
        finally
        {
            store.Close();
        }
        if (certificates == null || certificates.Count == 0)
            throw new XblException(HResult.XONLINE_E_XBOXLIVETOKEN_CERT_CONFIG, "No certificates with subject {0} were found in the specified store ", certSubject);
        if (certificates.Count > 1 && thereCanBeOnlyOne)
            throw new XblException(HResult.XONLINE_E_XBOXLIVETOKEN_CERT_CONFIG, "Multiple certificates with subject {0} were found in the specified store ", certSubject);
        if (isPrivateKeyRequired)
        {
            foreach (X509Certificate2 certificate in certificates)
            {
                if (!certificate.HasPrivateKey)
                {
                    throw new XblException(HResult.XONLINE_E_XBOXLIVETOKEN_CERT_CONFIG, "Certificate with subject {0} doesn't have a private key", certSubject);
                }
            }
        }

        return certificates;
    }
    
    // -------------------------------------------------------------------------------
    // GetTokenFromString 
    //
    // Validates a string is in fact a SAML Token and returns the Token as read from 
    // the string.
    // -------------------------------------------------------------------------------
    public static SamlSecurityToken GetTokenFromString(
        string samlToken)
    {
        //SamlUtilInit();
        SecurityTokenResolver outOfBandTokenResolver = SecurityTokenResolver.CreateDefaultSecurityTokenResolver(new ReadOnlyCollection<SecurityToken>( new List<SecurityToken>() ), false);
        SamlSerializer serializer = new SamlSerializer();

        using (XmlReader reader = XmlReader.Create(new StringReader(samlToken)))
        {
            //this validates the signature and time windows, as well as format of conditions and attributes
            return serializer.ReadToken(reader, WSSecurityTokenSerializer.DefaultInstance, outOfBandTokenResolver);
        }
    }

    // -------------------------------------------------------------------------------
    // Implementation public
    // -------------------------------------------------------------------------------

    public string GetAttributeValue( string name )
    {
        return _claims[name];
    }

    // -------------------------------------------------------------------------------
    // TryGetAttributeValue 
    //
    // Gets the value associated with the specified key.
    // -------------------------------------------------------------------------------
    public bool TryGetAttributeValue( string name, out string value )
    {
        return _claims.TryGetValue(name, out value);
    }

    /// <summary>
    /// General SAML token validation entry point.
    /// </summary>
    /// <param name="allowedThumbprints"></param>
    /// <param name="clientCertThumbprint"></param>
    public void Validate(string[] allowedThumbprints, string certDeviceId)
    {
        XblSamlSecurityTokenAuthenticator xblSamlSecurityTokenAuthenticator = new XblSamlSecurityTokenAuthenticator( allowedThumbprints );
        
        xblSamlSecurityTokenAuthenticator.ValidateToken(this, certDeviceId);
    }

    /// <summary>
    /// This Validate entry point is specific to WM7 traffic through the AuthSG.
    /// </summary>
    /// <param name="certificateAuthority"></param>
    /// <param name="clientCertThumbprint"></param>
    public void Validate(X509Certificate2Collection certificateAuthorities, string certDeviceId )
    {
        string[] allowedThumbprints = new string[certificateAuthorities.Count];
        int i=0;
        foreach (X509Certificate2 certificateAuthority in certificateAuthorities)
        {
            allowedThumbprints[i] = certificateAuthority.Thumbprint;
            i++;
        }

        Validate( allowedThumbprints, certDeviceId);
        
        // Make sure the platform type is consistent with the claims
        if (XOn.XPLT_MOBILE != byte.Parse(GetAttributeValue(XblSamlToken.name_attribute_platformtype)))
        {
            string value;
            if (TryGetAttributeValue(XblSamlToken.name_attribute_machineid, out value))
            {
                throw new XblException(HResult.XONLINE_E_XBOXLIVETOKEN_INVALID_PLATFORMTYPE, "; SAML Claim MachineID found PlatformType claim must be MOBILE.  MachineID {0} PlatformType {1}", value, GetAttributeValue(XblSamlToken.name_attribute_platformtype));
            }
            if (TryGetAttributeValue(XblSamlToken.name_attribute_deviceid, out value))
            {
                throw new XblException(HResult.XONLINE_E_XBOXLIVETOKEN_INVALID_PLATFORMTYPE, "; SAML Claim DeviceID found PlatformType claim must be MOBILE.  DeviceID {0} PlatformType {1}", value, GetAttributeValue(XblSamlToken.name_attribute_platformtype));
            }
        }
    }
    
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\XCacheProxy.cs ===
using System;
using System.IO;
using System.Net;
using System.Net.Sockets;

using xonline.common.config;
using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.XCacheProxy)]

namespace xonline.common.service
{
	
    internal class XCacheConnection
    {
        protected Socket _sock = null;
        
        const int XCACHE_BUFFER_SIZE = 10000; //equals to xcache buffer size, any request/response should fit into that buffer

        protected DateTime _dtConnect;
        protected DateTime _dtExpire;

        [ThreadStatic]
        static protected Random _rand = null;
        
        public bool IsValidConnection()
        {
            return (_sock != null && _sock.Connected);
        }

        public bool IsExpired()
        {
            // re-query the config setting in case it has changed since we calculated the expire time.  use the maximum possible time in this case.
            DateTime dtExpire = _dtConnect.AddSeconds(1.5 * Config.GetDoubleSetting(Setting.xcache_connectionTimeoutSeconds));
            return ((_dtExpire.CompareTo(DateTime.Now) < 0) || (dtExpire.CompareTo(DateTime.Now) < 0));
        }

        public void Send ()
        {
            // do nothing
        }
        
        public bool Write (byte[] msg)
        {
            if ( IsValidConnection() )
            {
                _sock.Send(msg);
                return true;
            }
            
            Close();    

            throw new ApplicationException("XCacheConnection.Write(): connection not valid.");
        }
         
        public int ReceiveTimeoutMilliseconds
        {
            get
            {
                const int DefaultXCacheConnectionReceiveTimeoutMilliseconds = 10000; // 10 seconds
                int timeoutMs = 0;

                try
                {
                    timeoutMs = Config.GetIntSetting(Setting.xcache_connection_receive_timeout_milliseconds);
                }
                catch(Exception e) // log exception, use the default timeout instead
                {
                    Xom.NtEvent(XEvent.Id.XCACHECONNECTION_NO_RECEIVETIMEOUT_SETTING, e, "Cannot obtain xcache_connection_receive_timeout_milliseconds config setting, reverting to {0} ms default value instead.", DefaultXCacheConnectionReceiveTimeoutMilliseconds);
                    timeoutMs = DefaultXCacheConnectionReceiveTimeoutMilliseconds;
                }
                
                return timeoutMs;
            }
        }

        public int SendTimeoutMilliseconds
        {
            get
            {
                const int DefaultXCacheConnectionSendTimeoutMilliseconds = 10000; // 10 seconds
                int timeoutMs = 0;

                try
                {
                    timeoutMs = Config.GetIntSetting(Setting.xcache_connection_send_timeout_milliseconds);
                }
                catch(Exception e) // log exception, use the default timeout instead
                {
                    Xom.NtEvent(XEvent.Id.XCACHECONNECTION_NO_SENDTIMEOUT_SETTING, e, "Cannot obtain xcache_connection_send_timeout_milliseconds config setting, reverting to {0} ms default value instead.", DefaultXCacheConnectionSendTimeoutMilliseconds);
                    timeoutMs = DefaultXCacheConnectionSendTimeoutMilliseconds;
                }
                
                return timeoutMs;
            }
        }

        public void Init()
        {
            if (IsValidConnection())
            {
                return;
            }
            try
            {
                if (_rand == null)
                {
                    _rand = new Random();
                }
                
                _sock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

                IVirtualInterfaceInfo ivii = Config.GetVirtualInterface(VirtualInterface.xcache);
               
                _sock.Connect(ivii.IPAddressString, ivii.PortEnd);

                _sock.ReceiveTimeout = ReceiveTimeoutMilliseconds;
                _sock.SendTimeout = SendTimeoutMilliseconds;

                _dtConnect = DateTime.Now;

                // set the expiry time to be a random value in a window centered around the config setting time.  this prevents all connections from
                // timing out at the same time.
                _dtExpire = _dtConnect.AddSeconds((0.5 + _rand.NextDouble()) * Config.GetDoubleSetting(Setting.xcache_connectionTimeoutSeconds));
            }
            catch (Exception e)
            {
                Close();
                Xom.NtEvent(XEvent.Id.XCACHE_CLIENT_BROKEN_PIPE_2, e, "Cannot establish connection with Xcache server.");
            }
        }

        public byte[] Read()
        {
            if( IsValidConnection() )
            {
                // 4 bytes for size
                // NOTE: this only works because the first 4 bytes of XCacheResponseMsg is the total size of the message.
                byte[] headerBuf = new byte[4];

                int cTotalBytes = 0;
                while (cTotalBytes < 4)
                {
                    int cBytes = _sock.Receive(headerBuf, cTotalBytes, 4 - cTotalBytes, SocketFlags.None);
                    if (cBytes == 0)
                    {
                        throw new ApplicationException( "XCacheConnection.Read(): Received 0 bytes");
                    }
                    else
                    {
                        cTotalBytes += cBytes;
                    }
                }

                int dataSize = headerBuf[0]+ (headerBuf[1]<<8) + (headerBuf[2]<<16) + (headerBuf[3]<<24);
                
                // make a new buffer for header + data
                byte[] buf = new byte[dataSize];

                // copy the header
                for (int iHeader = 0; iHeader < 4; iHeader++)
                {
                    buf[iHeader] = headerBuf[iHeader];
                }
                
                while (cTotalBytes < dataSize)
                {
                    int cBytes = _sock.Receive(buf, cTotalBytes, dataSize - cTotalBytes, SocketFlags.None);
                    if (cBytes == 0)
                    {
                        throw new ApplicationException( "XCacheConnection.Read(): Received 0 bytes");
                    }
                    else
                    {
                        cTotalBytes += cBytes;
                    }
                }

                return buf;
            }

            Close();

            throw new ApplicationException("XCacheConnection.Read(): connection not valid.");
        }
       
        
        public void Close()
        {
            if (_sock != null)
            {
                try
                {
                    _sock.Shutdown(SocketShutdown.Both);
                    _sock.Close();
                }
                catch (SocketException)
                {
                    // eat any exception here.  we're closing anyway.
                }
                
                _sock = null;
            }
        }
    };

    internal class XCacheConnectionsPool
    {
 
        public static XCacheConnectionsPool Instance
        {
            get
            {
                if (instance == null)
                {
                    lock (typeof(XCacheConnectionsPool))
                    {
                        if (instance == null)
                            instance = new XCacheConnectionsPool();
                    }                            
                }
                return instance;
            }
        }

        
        public void Shutdown()
        {
            // we should have _maxInst connections to close.
            for (int i =0 ; i< _maxInst; i++)
            {
                XCacheConnection xcc = null;
                do
                {
                    xcc = (XCacheConnection)_pool.Obtain();
                    if (xcc == null)
                    {
                        // wait for the connection to find its way back to the pool.
                        System.Threading.Thread.Sleep(100);
                    }
                }
                while (xcc == null);
                
                xcc.Close();
                xcc = null;
            }

            _pool = null;
        }
        
        public void ReleaseConnection(XCacheConnection xcc)
        {
            if (xcc.IsExpired())
            {
                xcc.Close();
            }
            _pool.Insert(xcc);
        }

        public XCacheConnection GetConnection()
        {
            XCacheConnection xcc = (XCacheConnection)_pool.Obtain();
            if (xcc != null)
            {
                if (xcc.IsExpired())
                {
                    xcc.Close();
                }
                xcc.Init();
            }
            
            return xcc;
        }

        private XCacheConnectionsPool()
        {
            Init();
        }
        private void Init()
        {
            _maxInst = Config.GetIntSetting(Setting.xcache_maxPipeConnections);            
            _pool = new FastPool(_maxInst * 2, false);

            for (int i =0 ; i< _maxInst; i++)
            {
                _pool.Insert(new XCacheConnection());
            }
        }        
        
        private static volatile XCacheConnectionsPool instance = null;
        private FastPool _pool = null;
        private int _maxInst;

    };
    
    public enum CacheType { StatChunk, FriendsPresence, UserSettings }

    public struct PUIDAndOwner
    {
        public PUIDAndOwner(ulong PUID, bool owner)
        {
            if (owner)
            {
                // Encode the fact that this is the owner in the high PUID bit
                _PUID = PUID | 0x8000000000000000;
            }
            else
            {
                _PUID = PUID;
            }
        }
        
        public bool Owner
        {
            get { return (_PUID & 0x8000000000000000) != 0; }
            set
            {
                if (value)
                {
                    _PUID = _PUID | 0x8000000000000000;
                }
                else
                {
                    _PUID = _PUID & 0x7fffffffffffffff;
                }
            }
        }
    
        public ulong PUID
        {
            get { return _PUID & 0x7fffffffffffffff; }
        }
    
        public ulong _PUID;
    }

    public static class XCache
    {    
        
        public const int _gamerTagLen = (int)XOn.XONLINE_GAMERTAG_SIZE;
        public const int _maxRecordsPerRequest = 1000;
        public const int _credentialTypePassport = 1;

        public static readonly string InvalidGamertag = "??????";

        private static XCacheResponseMsg SendXCacheRequest (XCacheRequestMsg request)
        {
            XCacheResponseMsg response;
            byte [] res = null;

            XCacheConnection pp = XCacheConnectionsPool.Instance.GetConnection();
            if ( null == pp )
            {
                throw new Exception( "XCacheProxy: Cannot perform an XCache lookup. No connections currently available. ");
            }

            try
            {
                bool fRetry = true;
                while (true)
                {    
                    try
                    {
                        MemoryStream ms = new MemoryStream();
                        request.WriteStream(ms);
                        
                        pp.Write(ms.ToArray());
                        pp.Send();
                        res = pp.Read();
                        ms.Flush();
                        ms.Position = 0;

                        response = new XCacheResponseMsg();
                        response.ReadBytes(res);

                        return response;
                    }
                    catch (Exception e)
                    {
                        pp.Close();

                        if (fRetry)
                        {
                            fRetry = false;
                            pp.Init();
                            continue;
                        }

                        Xom.NtEvent(XEvent.Id.XCACHE_SERVER_BUSY, e, "Exception occured");
                        throw;
                    }
                }
            }
            finally
            {
                XCacheConnectionsPool.Instance.ReleaseConnection(pp);
            }
        }

        public static bool IsInvalidGamertag(string gamertag)
        {
            return String.IsNullOrEmpty(gamertag) || InvalidGamertag.Equals(gamertag);
        }

        public static XCacheUserResponseData LookupUserByXUID(ulong xuid)
        {
            return LookupUsersByXUID(new ulong []{xuid})[0];
        }

        public static XCacheUserResponseData LookupUserByPassport(ulong passport)
        {
            return LookupUsersByPassport(new ulong []{passport})[0];
        }

        public static XCacheUserResponseData LookupUserByGamertag(string gamertag)
        {
            return LookupUsersByGamertag(new string []{gamertag})[0];
        }

        public static XCacheUserResponseData[] LookupUsersByXUID(ulong[] xuids)
        {
            XCacheRequestMsg request = new XCacheRequestMsg();
            XCacheXUIDLookupRequest lookup = new XCacheXUIDLookupRequest();
            request.rgRequests = new XCacheLookupRequestHeader[]{lookup};
            lookup.rgqwXUIDs = xuids;

            XCacheResponseMsg response = SendXCacheRequest(request);
            XCacheUserLookupResponse userResponse = (XCacheUserLookupResponse)response.rgResponses[0];

            foreach(XCacheUserResponseData xcurd in userResponse.rgUsers)
            {
                if(xcurd.szGamertag == null || xcurd.szGamertag.Length == 0)
                    xcurd.szGamertag = InvalidGamertag;
            }

            return userResponse.rgUsers;
        }

        public static XCacheUserResponseData[] LookupUsersByPassport(ulong[] passports)
        {
            XCacheRequestMsg request = new XCacheRequestMsg();
            XCachePassportLookupRequest lookup = new XCachePassportLookupRequest();
            request.rgRequests = new XCacheLookupRequestHeader[]{lookup};
            lookup.rgqwPassportPUIDs = passports;

            XCacheResponseMsg response = SendXCacheRequest(request);
            XCacheUserLookupResponse userResponse = (XCacheUserLookupResponse)response.rgResponses[0];

            foreach(XCacheUserResponseData xcurd in userResponse.rgUsers)
            {
                if(xcurd.szGamertag == null || xcurd.szGamertag.Length == 0)
                    xcurd.szGamertag = InvalidGamertag;
            }

            return userResponse.rgUsers;
        }

        public static XCacheUserResponseData[] LookupUsersByGamertag(string[] gamertags)
        {
            for (int i = 0; i < gamertags.Length; i++ )
            {                
                if ( gamertags[i].Length >= _gamerTagLen)
                {
                    throw new ArgumentException("GamerTag passed " + gamertags[i] + " ( index = " + i +") is too long");
                }
            }

            XCacheRequestMsg request = new XCacheRequestMsg();
            XCacheGamertagLookupRequest lookup = new XCacheGamertagLookupRequest();
            request.rgRequests = new XCacheLookupRequestHeader[]{lookup};
            lookup.rgszGamertags = gamertags;

            XCacheResponseMsg response = SendXCacheRequest(request);
            XCacheUserLookupResponse userResponse = (XCacheUserLookupResponse)response.rgResponses[0];

            foreach(XCacheUserResponseData xcurd in userResponse.rgUsers)
            {
                if(xcurd.szGamertag == null || xcurd.szGamertag.Length == 0)
                    xcurd.szGamertag = InvalidGamertag;
            }

            return userResponse.rgUsers;
        }

        public static ulong LookupPUID(string gamerTag)
        {
            if ( gamerTag == null || gamerTag.Length == 0 )
            {
                return 0;
            }
            
            string[] gamerTags = new string[1];
            gamerTags[0] = String.Copy( gamerTag );
            return (LookupPUIDs(gamerTags))[0];
        }
            
        public static ulong LookupPUID(ulong passportPuid)
        {
            if ( passportPuid == 0 )
            {
                return 0;
            }
            
            ulong[] passportPuids = new ulong[1];
            passportPuids[0] = passportPuid;
            return (LookupPUIDs(passportPuids))[0];
        }
            
        public static string LookupGamerTag(ulong puid)
        {
            if ( puid == 0 )
            {
                return InvalidGamertag;
            }

            ulong [] puids = new ulong[1];
            puids[0] = puid;
            return (LookupGamerTags( puids ))[0];
        }

        public static ulong ConvertWebIDToPassportPUID(byte[] webID)
        {
            return ((ulong)webID[0] |
                ((ulong)webID[1] << 8) |
                ((ulong)webID[2] << 16) |
                ((ulong)webID[3] << 24) |
                ((ulong)webID[4] << 32) |
                ((ulong)webID[5] << 40) |
                ((ulong)webID[6] << 48) |
                ((ulong)webID[7] << 56));
        }

        public static PUIDAndOwner[] LookupWebID(byte[] webID, uint credType, out uint[] rgdwUserFlags)
        {
            PUIDAndOwner[] puids = LookupWebID(webID, credType);
            
            rgdwUserFlags = new uint[puids.Length];
            for (int iPuid = 0; iPuid < puids.Length; iPuid++)
            {
                rgdwUserFlags[iPuid] = 0;
                XUIDAndTrust.SetUserFlagCountry(ref rgdwUserFlags[iPuid], XOn.XONLINE_COUNTRY_UNITED_STATES);
                XUIDAndTrust.SetUserFlagLanguage(ref rgdwUserFlags[iPuid], XOn.XC_LANGUAGE_ENGLISH);
                XUIDAndTrust.SetUserFlagTier(ref rgdwUserFlags[iPuid], XOn.XONLINE_TIER_GOLD);
            }

            return puids;
        }
        
        public static PUIDAndOwner[] LookupWebID(byte[] webID, uint credType)
        {
            XCacheRequestMsg request = new XCacheRequestMsg();
            XCachePassportLookupRequest lookup = new XCachePassportLookupRequest();
            request.rgRequests = new XCacheLookupRequestHeader[]{lookup};
            lookup.rgqwPassportPUIDs = new ulong[] {ConvertWebIDToPassportPUID(webID)};

            XCacheResponseMsg response = SendXCacheRequest(request);
            XCacheUserLookupResponse userResponse = (XCacheUserLookupResponse)response.rgResponses[0];

            if (userResponse.rgUsers[0].qwUserID != 0)
            {
                PUIDAndOwner[] puids = new PUIDAndOwner[1];
                puids[0]._PUID = userResponse.rgUsers[0].qwUserID;
                puids[0].Owner = true;
                                
                Xom.Trace(XomAreaName.XCacheProxy, LogLevel.L_LOW, "LookupWebID for WebId = " + ByteConvert.ToReverseString(webID) + " Result = " + puids[0]._PUID);
                return puids;
            }
            
            return new PUIDAndOwner[0];
      }

        public static PUIDAndOwner LookupWebID(byte[] webID, string GamerTag, uint credType)
        {
            PUIDAndOwner puid = new PUIDAndOwner(0, false);
            if (GamerTag.Length >= _gamerTagLen)
            {
                throw new ArgumentException("GamerTag passed " + GamerTag + " is too long");
            }

            XCacheRequestMsg request = new XCacheRequestMsg();
            XCacheGamertagLookupRequest gamertagLookup = new XCacheGamertagLookupRequest();
            XCachePassportLookupRequest passportLookup = new XCachePassportLookupRequest();
            request.rgRequests = new XCacheLookupRequestHeader[]{gamertagLookup, passportLookup};
            gamertagLookup.rgszGamertags = new string[]{GamerTag};
            passportLookup.rgqwPassportPUIDs = new ulong[]{ConvertWebIDToPassportPUID(webID)};

            XCacheResponseMsg response = SendXCacheRequest(request);

            // responses come back in the order they were sent.  see XCacheRequestMsg.WriteStream() .
            XCacheUserLookupResponse gamertagResponse = (XCacheUserLookupResponse)response.rgResponses[0];
            XCacheUserLookupResponse passportResponse = (XCacheUserLookupResponse)response.rgResponses[1];
            if (gamertagResponse.rgUsers[0].qwUserID == passportResponse.rgUsers[0].qwUserID)
            {
                puid._PUID = gamertagResponse.rgUsers[0].qwUserID;
                puid.Owner = true;
            }

            Xom.Trace(XomAreaName.XCacheProxy, LogLevel.L_LOW, "LookupWebID for WebId = " + (ByteConvert.ToReverseString(webID)) + " gamerTag = [" + GamerTag + "] Result = [" + puid._PUID + "]");

            return puid;
        }
         
        public static ulong[] LookupPUIDs(string[] gamerTags)
        {
            ulong[] puids = null;
            if ( gamerTags == null || gamerTags.Length == 0 )
            {
                throw new ArgumentException("gamerTags == null or gamerTags.Length == 0");
            }

            if ( gamerTags.Length > _maxRecordsPerRequest )
            {
                Xom.NtEvent(XEvent.Id.XCACHE_INVALID_MESSAGE_1, "Number of input parameters " + gamerTags.Length + " exceeds maximum allowed (" +  _maxRecordsPerRequest + ")");
                throw new ArgumentException("Number of input parameters " + gamerTags.Length + " exceeds maximum allowed (" +  _maxRecordsPerRequest + ")");
            }
            
            for (int i = 0; i < gamerTags.Length; i++ )
            {                
                if ( gamerTags[i].Length >= _gamerTagLen)
                {
                    throw new ArgumentException("GamerTag passed " + gamerTags[i] + " ( index = " + i +") is too long");
                }
            }

            XCacheRequestMsg request = new XCacheRequestMsg();
            XCacheGamertagLookupRequest lookup = new XCacheGamertagLookupRequest();
            request.rgRequests = new XCacheLookupRequestHeader[]{lookup};
            lookup.rgszGamertags = gamerTags;

            XCacheResponseMsg response = SendXCacheRequest(request);
            XCacheUserLookupResponse userResponse = (XCacheUserLookupResponse)response.rgResponses[0];

            puids = new ulong[userResponse.cdwResponses];
            for (int iResult = 0; iResult < userResponse.cdwResponses; iResult++)
            {
                puids[iResult] = userResponse.rgUsers[iResult].qwUserID;
                Xom.Trace(XomAreaName.XCacheProxy, LogLevel.L_LOW, "LookupPUIDs " + iResult + ": " + gamerTags[iResult] + " - " + puids[iResult]);
            }
            
            return puids;
        }
     
        public static ulong[] LookupPUIDs(ulong[] passportPuids)
        {
            ulong[] puids = null;

            if ( passportPuids == null || passportPuids.Length == 0 )
            {
                throw new ArgumentException("passportPuids == null or passportPuids.Length == 0");
            }

            if ( passportPuids.Length > _maxRecordsPerRequest )
            {
                Xom.NtEvent(XEvent.Id.XCACHE_INVALID_MESSAGE_7, "Number of input parameters " + passportPuids.Length + " exceeds maximum allowed (" +  _maxRecordsPerRequest + ")");
                throw new ArgumentException("Number of input parameters " + passportPuids.Length + " exceeds maximum allowed (" +  _maxRecordsPerRequest + ")");
            }

            XCacheRequestMsg request = new XCacheRequestMsg();
            XCachePassportLookupRequest lookup = new XCachePassportLookupRequest();
            request.rgRequests = new XCacheLookupRequestHeader[]{lookup};
            lookup.rgqwPassportPUIDs = passportPuids;

            XCacheResponseMsg response = SendXCacheRequest(request);
            XCacheUserLookupResponse userResponse = (XCacheUserLookupResponse)response.rgResponses[0];

            puids = new ulong[userResponse.cdwResponses];
            for (int iResult = 0; iResult < userResponse.cdwResponses; iResult++)
            {
                puids[iResult] = userResponse.rgUsers[iResult].qwUserID;
                Xom.Trace(XomAreaName.XCacheProxy, LogLevel.L_LOW, "LookupPUIDs " + iResult + ": " + passportPuids[iResult] + " - " + puids[iResult]);
            }
            
            return puids;
        }
     
        public static string[] LookupGamerTags(ulong[] puids)
        {
            string[] gamerTags = null;
            if ( puids == null || puids.Length == 0 )
            {
                throw new ArgumentException("puids == null or puids.Length == 0");
            }

            if ( puids.Length > _maxRecordsPerRequest )
            {
                Xom.NtEvent(XEvent.Id.XCACHE_INVALID_MESSAGE_3, "Number of input parameters " + puids.Length + " exceeds maximum allowed (" +  _maxRecordsPerRequest + ")");
                throw new ArgumentException("Number of input parameters " + puids.Length + " exceeds maximum allowed (" +  _maxRecordsPerRequest + ")");
            }

            gamerTags = new string[puids.Length];
            for ( int i = 0; i < puids.Length; i++ )
            {
                gamerTags[i] = InvalidGamertag;
            }

            XCacheRequestMsg request = new XCacheRequestMsg();
            XCacheXUIDLookupRequest lookup = new XCacheXUIDLookupRequest();
            request.rgRequests = new XCacheLookupRequestHeader[]{lookup};
            lookup.rgqwXUIDs = puids;

            XCacheResponseMsg response = SendXCacheRequest(request);
            XCacheUserLookupResponse userResponse = (XCacheUserLookupResponse)response.rgResponses[0];

            for (int iResult = 0; iResult < userResponse.cdwResponses; iResult++)
            {
                if (userResponse.rgUsers[iResult].szGamertag != null && userResponse.rgUsers[iResult].szGamertag.Length > 0)
                {
                    gamerTags[iResult] =  userResponse.rgUsers[iResult].szGamertag;
                }
                Xom.Trace(XomAreaName.XCacheProxy, LogLevel.L_LOW, "LookupGamerTags " + iResult + ": " + puids[iResult] + " - " + gamerTags[iResult]);
            }
            
            return gamerTags;
        }
     
        public static ulong LookupTeamPUID( uint titleId, string teamName )
        {
            if ( teamName == null || teamName.Length == 0 )
            {
                return 0;
            }
            string[] teamNames = new string[1];
            teamNames[0] = String.Copy( teamName );
            return (LookupTeamPUIDs( titleId, teamNames ))[0];
        }
            
            
        public static string LookupTeamName(uint titleId, ulong puid)
        {
            if ( puid == 0 )
            {
                return "";
            }
            ulong[] puids = new ulong[1];
            puids[0] = puid;
            return (LookupTeamNames(titleId, puids)[0]);
        }

        public static ulong[] LookupTeamPUIDs(uint titleId, string[] teamNames)
        {
            ulong[] puids = null;
            if ( teamNames == null || teamNames.Length == 0 )
            {
                throw new ArgumentException("teamNames == null or teamNames.Length == 0");
            }

            if ( teamNames.Length > _maxRecordsPerRequest )
            {
                Xom.NtEvent(XEvent.Id.XCACHE_INVALID_MESSAGE_4, "Number of input parameters " + teamNames.Length + " exceeds maximum allowed (" +  _maxRecordsPerRequest + ")");
                throw new ArgumentException("Number of input parameters " + teamNames.Length + " exceeds maximum allowed (" +  _maxRecordsPerRequest + ")");
            }
            
            for (int i = 0; i < teamNames.Length; i++ )
            {                
                if ( teamNames[i].Length >= _gamerTagLen)
                {
                    throw new ArgumentException("team name passed " + teamNames[i] + " ( index = " + i +") is too long");
                }
            }

            XCacheRequestMsg request = new XCacheRequestMsg();
            XCacheTeamNameLookupRequest lookup = new XCacheTeamNameLookupRequest();
            request.rgRequests = new XCacheLookupRequestHeader[]{lookup};
            lookup.rgTeams = new XCacheTeamNameLookupKey[teamNames.Length];
            for (int iTeam = 0; iTeam < teamNames.Length; iTeam++)
            {
                lookup.rgTeams[iTeam] = new XCacheTeamNameLookupKey();
                lookup.rgTeams[iTeam].dwTitleID = titleId;
                lookup.rgTeams[iTeam].wszTeamName = teamNames[iTeam];
            }

            XCacheResponseMsg response = SendXCacheRequest(request);
            XCacheTeamLookupResponse teamResponse = (XCacheTeamLookupResponse)response.rgResponses[0];

            puids = new ulong[teamResponse.cdwResponses];
            for (int iResult = 0; iResult < puids.Length; iResult++)
            {
                puids[iResult] = teamResponse.rgTeams[iResult].qwTeamID;
                Xom.Trace(XomAreaName.XCacheProxy, LogLevel.L_LOW, "LookupTeamPUIDs " + iResult + ": " + teamNames[iResult] + " - " + puids[iResult]);
            }
            
            return puids;
        }


        public static string[] LookupTeamNames(uint titleId, ulong[] puids)
        {
            string[] teamNames = null;
            if ( puids == null || puids.Length == 0 )
            {
                throw new ArgumentException("puids == null or puids.Length == 0");
            }

            if ( puids.Length > _maxRecordsPerRequest )
            {
                Xom.NtEvent(XEvent.Id.XCACHE_INVALID_MESSAGE_6, "Number of input parameters " + puids.Length + " exceeds maximum allowed (" +  _maxRecordsPerRequest + ")");
                throw new ArgumentException("Number of input parameters " + puids.Length + " exceeds maximum allowed (" +  _maxRecordsPerRequest + ")");
            }

            teamNames = new string[puids.Length];

            XCacheRequestMsg request = new XCacheRequestMsg();
            XCacheTeamIDLookupRequest lookup = new XCacheTeamIDLookupRequest();
            request.rgRequests = new XCacheLookupRequestHeader[]{lookup};
            lookup.rgTeams = new XCacheTeamIDLookupKey[puids.Length];
            for (int iTeam = 0; iTeam < puids.Length; iTeam++)
            {
                lookup.rgTeams[iTeam] = new XCacheTeamIDLookupKey();
                lookup.rgTeams[iTeam].dwTitleID = titleId;
                lookup.rgTeams[iTeam].qwTeamID = puids[iTeam];
                teamNames[iTeam] = String.Copy("");
            }

            XCacheResponseMsg response = SendXCacheRequest(request);
            XCacheTeamLookupResponse teamResponse = (XCacheTeamLookupResponse)response.rgResponses[0];

            for (int iResult = 0; iResult < teamResponse.cdwResponses; iResult++)
            {
                if (teamResponse.rgTeams[iResult].wszTeamName != null && teamResponse.rgTeams[iResult].wszTeamName.Length > 0)
                {
                    teamNames[iResult] =  teamResponse.rgTeams[iResult].wszTeamName;
                }
                Xom.Trace(XomAreaName.XCacheProxy, LogLevel.L_LOW, "LookupTeamName " + iResult + ":titleId = " + titleId + "teamPUID = " + puids[iResult] + " teamName = " + teamNames[iResult]);
            }

            return teamNames;
        }
    
    };

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\WireDataSerializer.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Text;
using System.Reflection;
using System.Reflection.Emit;

using xonline.core.wiredata;
using xonline.common.exceptions;

namespace xonline.common.service
{
    using TypeSerializers = Dictionary<Type, Delegate>;

    // Thrown during WireDatainitialization for bad field types, bad attributes, etc.
    public sealed class WireInfoInitException : Exception
    {
        public WireInfoInitException(Type type, FieldInfo field, string message)
            :
            base(string.Format(
                    "Failed to initialize WireData serializer.\nClass: {0}\nField: {1}\nMessage: '{2}'",
                    type != null ? type.Name : "(n/a)",
                    field != null ? field.Name : "(n/a)",
                    message)) { }
    }

    internal sealed class RetvalBinder : Binder
    {
        Type _type;
        internal RetvalBinder(Type t)
        {
            _type = t;
        }

        public override FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, System.Globalization.CultureInfo culture)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        public override MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, ref object[] args, ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] names, out object state)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        public override object ChangeType(object value, Type type, System.Globalization.CultureInfo culture)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        public override void ReorderArgumentArray(ref object[] args, object state)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        public override MethodBase SelectMethod(
                                        BindingFlags bindingAttr,
                                        MethodBase[] match,
                                        Type[] types,
                                        ParameterModifier[] modifiers)
        {
            foreach (MethodBase m in match)
            {
                MethodInfo method = (MethodInfo)m;
                if (method.ReturnType == _type)
                    return m;
            }

            return null;
        }

        public override PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers)
        {
            throw new Exception("The method or operation is not implemented.");
        }
    }


    // The dynamic methods will have this signature.  We  will
    // use the following delegates to invoke and refer to them.

    public delegate void WireDataReadDelegate(WireData o, BinaryReader br);
    public delegate void WireDataWriteDelegate(WireData o, BinaryWriter bw);
    public delegate int WireDataSizeofDelegate(WireData o);
    public delegate void WireDataToStringDelegate(WireData o, StringBuilder sb, int indent);
    public delegate void WireDataValidateDelegate(WireData o);
    public delegate bool WireDataEncryptionRequiredDelegate(WireData o);

    // Generates, stores and provides access to the dynamic serialization methods 
    // generated for each WireDatatype
    public static class WireDataSerializerCache
    {
        // Dictionary of Serializers per WireDatatype
        static volatile Dictionary<Type, TypeSerializers> _typeSerializers = new Dictionary<Type, TypeSerializers>();
        static AssemblyBuilder _asmBdr;
        static ModuleBuilder _modBdr;

        static object _syncRoot = new object();

        sealed class WireDataTypeInfo
        {
            public Type type;
            public Dictionary<string, MethodBuilder> methodBuilders;
        }

        public static void GenerateSerializers(string assemblyName)
        {
            GenerateSerializers(assemblyName, Assembly.GetExecutingAssembly());
        }

        // Generate dynamic serializer methods for WireDatatypes.
        public static void GenerateSerializers(string assemblyName, params Assembly[] assemblies)
        {
            Version ver = typeof(WireDataSerializerCache).Assembly.GetName().Version;
            // Create a new dynamic assembly, a new dynamic module and a new dynamic type 
            // on the current AppDomain. Only one type will be used to hold all the 
            // dynaminc methods.
            string assemblyFileName = assemblyName + ".dll";
            AssemblyBuilder asmBdr = AppDomain.CurrentDomain.DefineDynamicAssembly(
                new AssemblyName(assemblyName) { Version = ver },
                AssemblyBuilderAccess.Save);

            ModuleBuilder modBdr = asmBdr.DefineDynamicModule(assemblyFileName, assemblyFileName);

            // Generate context objects for each WireDatatype in specified assembly. At the 
            // same time generate all method builders for each type. These can 
            // be used to generate calls to these methods before they are finished.
            foreach (Assembly assembly in assemblies)
            {
                foreach (Type type in assembly.GetTypes())
                {
                    if (type.IsSubclassOf(typeof(WireData)))
                    {
                        EmitMethodsForType(modBdr, type, null);
                    }
                }
            }

            asmBdr.Save(assemblyFileName);
        }
        class SerializerMethodOptions
        {
            public string Name;
            public BindingFlags GetMethodFlags = BindingFlags.Default;
            public Action<MethodBuilder, Type, FieldContext[]> EmitMethod;

            public Type DelegateType
            {
                get
                {
                    return _delegate;
                }
                set
                {
                    if (value != null && !value.IsSubclassOf(typeof(Delegate)))
                    {
                        throw new Exception("Type specified must be a delegate type");
                    }
                    _delegate = value;
                    if (_delegate != null)
                    {
                        GenerateTypes();
                    }
                }
            }

            public Type ReturnType
            {
                get; private set;
            }

            public Type[] ParamTypes
            {
                get; private set;
            }

            Type _delegate;

            void GenerateTypes()
            {
                var m = _delegate.GetMethod("Invoke");
                ReturnType = m.ReturnType;
                ParamTypes = m.GetParameters().Select(p => p.ParameterType).ToArray();
            }
        };

        static List<SerializerMethodOptions> _methodsList = new List<SerializerMethodOptions>
        {
            new SerializerMethodOptions
            {
                Name = "Read",
                DelegateType = typeof(WireDataReadDelegate),
                EmitMethod = ReadSerializer.EmitMethod,
            },
            new SerializerMethodOptions
            {
                Name = "Write",
                DelegateType = typeof(WireDataWriteDelegate),
                EmitMethod = WriteSerializer.EmitMethod,
            },
            new SerializerMethodOptions
            {
                Name = "SizeOf",
                DelegateType = typeof(WireDataSizeofDelegate),
                EmitMethod = SizeofSerializer.EmitMethod,
            },
            new SerializerMethodOptions
            {
                Name = "ToString",
                GetMethodFlags = BindingFlags.Public | BindingFlags.Static,
                DelegateType = typeof(WireDataToStringDelegate),
                EmitMethod = ToStringSerializer.EmitMethod,
            },
            new SerializerMethodOptions
            {
                Name = "Validate",
                DelegateType = typeof(WireDataValidateDelegate),
                EmitMethod = EmitMethodValidate,
            },
            new SerializerMethodOptions
            {
                Name = "IsEncryptionRequired",
                DelegateType = typeof(WireDataEncryptionRequiredDelegate),
                EmitMethod = EncryptionRequiredSerializer.EmitMethod,
            },
        };

        static void EmitMethodsForType(ModuleBuilder modBdr, Type type, Dictionary<Type, TypeSerializers> dict)
        {
            TypeBuilder typeBdr = modBdr.DefineType(
                type.FullName + "Serializer",
                TypeAttributes.AutoClass | TypeAttributes.Class | TypeAttributes.Public | TypeAttributes.Sealed | TypeAttributes.Abstract | TypeAttributes.BeforeFieldInit);

            WireDataTypeInfo wdtype = new WireDataTypeInfo();
            wdtype.type = type;

            wdtype.methodBuilders = _methodsList
                            .Select(m => typeBdr.DefineMethod(m.Name, MethodAttributes.Public | MethodAttributes.Static, m.ReturnType, m.ParamTypes))
                            .ToDictionary(m => m.Name);

            // This is where most of the magic happens. Emit the IL for Read, Write and 
            // ToString methods.
            EmitMethods(wdtype);

            // All methods are done. Call CreateType() to finish generating the type.  
            // After this the methods are ready to be used.
            Type dynamicType = typeBdr.CreateType();

            if (dict != null)
            {
                // Store method delegates in order to be retrieved for later use.
                TypeSerializers serializers = (from m in _methodsList
                               let minfo = m.GetMethodFlags == BindingFlags.Default ? dynamicType.GetMethod(m.Name) : dynamicType.GetMethod(m.Name, m.GetMethodFlags)
                               select Delegate.CreateDelegate(m.DelegateType, minfo))
                              .ToDictionary(d => d.GetType());

                dict.Add(type, serializers);
            }
        }

        static void EnsureSerializersFor(Type t)
        {
            if (!_typeSerializers.ContainsKey(t))
            {
                lock (_syncRoot)
                {
                    if (!_typeSerializers.ContainsKey(t))
                    {
                        if (_asmBdr == null)
                        {
                            Version ver = typeof(WireDataSerializerCache).Assembly.GetName().Version;

                            _asmBdr = AppDomain.CurrentDomain.DefineDynamicAssembly(
                                new AssemblyName("WireDataSerializerAssembly") { Version = ver },
                                AssemblyBuilderAccess.Run);
                        }

                        if (_modBdr == null)
                        {
                            _modBdr = _asmBdr.DefineDynamicModule("WireDataSerializerModule");
                        }

                        Dictionary<Type, TypeSerializers> newSerializers = new Dictionary<Type, TypeSerializers>(_typeSerializers);
                        EmitMethodsForType(_modBdr, t, newSerializers);

                        // Since there is no single-writer semantic guaranteed by the dictionary, replacing the whole dictionary
                        // in one swoop.  volatile _typeSerializers guarantees that assignment is after object is complete.
                        _typeSerializers = newSerializers;
                    }
                }
            }
        }

        // Retrieve the serializer given the delegate type
        static internal T GetSerializerFor<T>(Type t)
            where T : class
        {
            EnsureSerializersFor(t);
            return (T)(object)_typeSerializers[t][typeof(T)];
        }

        // Store context about a field while a field is being processed.
        class FieldContext
        {
            public WireInfoAttribute wdattr = null;
            public FieldInfo field = null;
            public FieldContext sizeParam = null;
            public FieldContext sizeOf = null;
            public LocalBuilder encodedBlob = null;
        }

        private static void ListFieldsInSubclasses(Type type, List<FieldInfo> outlist)
        {
            if (type == typeof(WireData))
            {
                return;
            }

            ListFieldsInSubclasses(type.BaseType, outlist);

            FieldInfo[] fieldsRaw = type.GetFields(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);

            for (int i = 0; i < fieldsRaw.Length; i++)
            {
                outlist.Add(fieldsRaw[i]);
            }
        }

        static MethodInfo GetConversionMethod(Type fromType, Type toType)
        {
            // Allow for conversion to exist on either class, source or destination.
            // Prefer explicit conversion to implicit conversion.
            return
                // class fromType { public static operator explicit toType(fromType); }
                fromType.GetMethod("op_Explicit", BindingFlags.Static | BindingFlags.Public,
                             new RetvalBinder(toType), new Type[] { fromType }, null) ??
                // class toType { public static operator explicit toType(fromType); }
                toType.GetMethod("op_Explicit", new Type[] { fromType }) ??
                // class fromType { public static operator implicit toType(fromType); }
                fromType.GetMethod("op_Implicit", BindingFlags.Static | BindingFlags.Public,
                             new RetvalBinder(toType), new Type[] { fromType }, null) ??
                // class toType { public static operator implicit toType(fromType); }
                toType.GetMethod("op_Implicit", new Type[] { fromType });
        }

        // Emit IL for the Reader and Writer method for a WireDatatype.
        static void EmitMethods(
            WireDataTypeInfo wdtype)
        {
            try
            {
                //
                //if (wdtype.type.IsAbstract)
                //{
                //    throw new WireInfoInitException(wdtype.type, null, "Cannot directly serialize an abstract class");
                //}

                // Make a list of fields and do some preliminary checking.
                List<FieldContext> fields = new List<FieldContext>();
                List<FieldInfo> fieldsList = new List<FieldInfo>();
                ListFieldsInSubclasses(wdtype.type, fieldsList);
                foreach (FieldInfo fieldInfo in fieldsList)
                {
                    object[] customAttrs = fieldInfo.GetCustomAttributes(
                        typeof(WireInfoAttribute),
                        false);

                    WireInfoAttribute wdattr = customAttrs.Length == 1 ?
                        (WireInfoAttribute)customAttrs[0] :
                        WireInfoAttribute.None;

                    if (wdattr.Serialize)
                    {
                        bool supportedType =
                            (!fieldInfo.FieldType.IsArray && WireDataGenerator.IsSupportedFieldType(fieldInfo.FieldType)) ||
                            (fieldInfo.FieldType.IsArray && WireDataGenerator.IsSupportedFieldType(fieldInfo.FieldType.GetElementType()) && fieldInfo.FieldType != typeof(string[]));

                        // Determine if the field has a SerializeAs parameter that can be used to convert the datatype
                        Type fieldType = fieldInfo.FieldType.IsArray ? fieldInfo.FieldType.GetElementType() : fieldInfo.FieldType;
                        customAttrs = fieldType.GetCustomAttributes(typeof(WireInfoAttribute), false);
                        WireInfoAttribute fieldAttr = customAttrs.Length == 1 ? (WireInfoAttribute)customAttrs[0] : WireInfoAttribute.None;

                        if (!supportedType)
                        {
                            // If there is another type used for serialization, use that.
                            if (wdattr.SerializeAs == null && fieldAttr.SerializeAs == null)
                            {
                                throw new WireInfoInitException(wdtype.type,
                                    fieldInfo,
                                    "Type '" + fieldInfo.FieldType.FullName + "' not supported.");
                            }
                            else
                            {
                                // Going to stomp over the default, so allocate a new object.
                                if (wdattr == WireInfoAttribute.None && fieldAttr.SerializeAs != null)
                                {
                                    wdattr = new WireInfoAttribute();
                                }
                                wdattr.SerializeAs = wdattr.SerializeAs ?? fieldAttr.SerializeAs;

                                // Now that we know the type has a serializer, confirm that there are implicit conversion operators to the desired type.
                                if (!WireDataGenerator.IsSupportedFieldType(wdattr.SerializeAs) ||
                                    (WireDataGenerator.IsSupportedFieldType(wdattr.SerializeAs) && wdattr.SerializeAs == typeof(string)))
                                {
                                    throw new WireInfoInitException(wdtype.type,
                                        fieldInfo,
                                        "Type '" + fieldInfo.FieldType.FullName + "' which has SerializeAs type '" + wdattr.SerializeAs.FullName + "' which is not supported.");
                                }

                                if ( GetConversionMethod(fieldType, wdattr.SerializeAs) == null || GetConversionMethod(wdattr.SerializeAs, fieldType) == null )
                                {
                                    throw new WireInfoInitException(wdtype.type,
                                        fieldInfo,
                                        "Type '" + fieldInfo.FieldType.FullName + "' does not have conversion operators to and from SerializeAs type '" + wdattr.SerializeAs.FullName + "'.");
                                }
                            }
                        }
                        else if (wdattr.SerializeAs != null || fieldAttr.SerializeAs != null)
                        {
                            throw new WireInfoInitException(wdtype.type,
                                fieldInfo,
                                "Native Wiredata type " + fieldInfo.FieldType.FullName + " does not support SerializeAs");
                        }
                        else if (wdattr.NullTerminate && fieldInfo.FieldType != typeof(string))
                        {
                            throw new WireInfoInitException(wdtype.type,
                                fieldInfo,
                                "NullTerminate is only supported for string field types");
                        }
                    }

                    FieldContext fieldContext = new FieldContext();
                    fieldContext.wdattr = wdattr;
                    fieldContext.field = fieldInfo;
                    fields.Add(fieldContext);
                }

                // XB360CS 27492: TODO Still think this is not right, but can't change entire tree yet.  Code will do correct thing
                //if (fields.Count == 0)
                //{
                //    throw new WireInfoInitException(wdtype.type, null, "There are no fields to serialize");
                //}

                // Fill out dependencies. Fields with the SizeParam attribute are dependent on the 
                // field with that name. Fields in the SizeParam attribute must be defined before 
                // their dependents.
                for (int i = 0; i < fields.Count; i++)
                {
                    FieldContext fieldContext = fields[i];

                    if (!fieldContext.wdattr.Serialize)
                    {
                        continue;
                    }

                    if (fieldContext.wdattr.BigEndian)
                    {
                        Type typeParam = fieldContext.field.FieldType;
                        if (
                            !(
                              WireDataGenerator.IsSupportedBigEndianType(typeParam) ||
                              (typeParam.IsArray && WireDataGenerator.IsSupportedBigEndianType(typeParam.GetElementType())) ||
                              (typeParam.IsEnum && WireDataGenerator.IsSupportedBigEndianType(Enum.GetUnderlyingType(typeParam))) ||
                              (fieldContext.wdattr.SerializeAs != null && WireDataGenerator.IsSupportedBigEndianType(fieldContext.wdattr.SerializeAs)) 
                             )
                           )
                        {
                            throw new WireInfoInitException(
                                wdtype.type, fieldContext.field,
                                "Field specifies a 'BigEndian' attribute has an unsupported " +
                                    "type. Valid types are: {short, ushort, int, uint, long, ulong (and enums based on those types), float, double, DateTime, or Guid, and arrays of the referenced types}."
                                   );
                        }
                    }

                    if (fieldContext.wdattr.SizeParam != null)
                    {
                        if (fieldContext.wdattr.ArraySize != -1)
                        {
                            throw new WireInfoInitException(
                                wdtype.type, fieldContext.field,
                                String.Format("Field '{0}' can not have both a SizeParam and an ArraySize", fieldContext.field.Name));
                        }

                        for (int j = i - 1; j >= 0; j--)
                        {
                            if (fields[j].field.Name == fieldContext.wdattr.SizeParam)
                            {
                                Type typeSizeParam = fields[j].field.FieldType;
                                if (typeSizeParam != typeof(Byte) &&
                                   // typeSizeParam != typeof(SByte) &&
                                   typeSizeParam != typeof(Int16) &&
                                   typeSizeParam != typeof(UInt16) &&
                                   typeSizeParam != typeof(Int32) &&
                                   typeSizeParam != typeof(UInt32) &&
                                   typeSizeParam != typeof(Int64) &&
                                   typeSizeParam != typeof(UInt64))
                                {
                                    throw new WireInfoInitException(
                                        wdtype.type, fieldContext.field,
                                        string.Format(
                                            "Field '{0}' specified in 'SizeParam' attribute has an unsupported " +
                                            "type. Valid types are: {byte, short, ushort, int, uint, long, ulong}.",
                                            fieldContext.wdattr.SizeParam));
                                }

                                fieldContext.sizeParam = fields[j];
                                fields[j].sizeOf = fieldContext;
                                break;
                            }
                        }

                        if (fieldContext.sizeParam == null)
                        {
                            throw new WireInfoInitException(
                                wdtype.type, fieldContext.field,
                                string.Format("Field '{0}' specified in 'SizeParam' attribute does not exist",
                                              fieldContext.wdattr.SizeParam));
                        }
                    }

                    if (fieldContext.wdattr.SizeParam == null && fieldContext.wdattr.ArraySize == -1
                        && (fieldContext.field.FieldType == typeof(string) || fieldContext.field.FieldType.IsArray))
                    {
                        for (int j = i - 1; j >= 0; j--)
                        {
                            if (fields[j].field.Name == fieldContext.field.Name + "Len")
                            {
                                Type typeSizeParam = fields[j].field.FieldType;
                                if (typeSizeParam != typeof(Byte) &&
                                   // typeSizeParam != typeof(SByte) &&
                                   typeSizeParam != typeof(Int16) &&
                                   typeSizeParam != typeof(UInt16) &&
                                   typeSizeParam != typeof(Int32) &&
                                   typeSizeParam != typeof(UInt32) &&
                                   typeSizeParam != typeof(Int64) &&
                                   typeSizeParam != typeof(UInt64))
                                {
                                    throw new WireInfoInitException(
                                        wdtype.type, fieldContext.field,
                                        string.Format(
                                            "Field '{0}' as length for field '{1}' has an unsupported " +
                                            "type. Valid types are: {byte, short, ushort, int, uint, long, ulong}.",
                                            fields[j].field.Name, fields[i].field.Name));
                                }

                                fieldContext.sizeParam = fields[j];
                                fields[j].sizeOf = fieldContext;
                                break;
                            }
                        }
                    }

                    if ((fieldContext.field.FieldType.IsArray || fieldContext.field.FieldType == typeof(string)) &&
                            fieldContext.sizeParam == null && fieldContext.wdattr.ArraySize == -1)
                    {
                        throw new WireInfoInitException(
                            wdtype.type, fieldContext.field,
                            String.Format("Field '{0}' must have either an ArraySize, a SizeParam or there must be a field named '{0}Len'.",
                                            fieldContext.field.Name));
                    }
                }

                // Emit the Reader and Writer methods
                FieldContext[] fieldsArray = fields.ToArray();

                foreach (var m in _methodsList)
                {
                    m.EmitMethod(wdtype.methodBuilders[m.Name], wdtype.type, fieldsArray);
                }
            }
            catch (WireInfoInitException e)
            {
                // An exception had occurred during initialization, but we can't report it now.  There is a possiblity that the method
                // will never be called, so there is no reason to throw the exception early.  Instead, emit throwing the exception in the
                // methods.

                foreach (var bdr in wdtype.methodBuilders.Values)
                {
                    new WireDataGenerator(bdr).EmitThrowException(e.Message);
                }
            }
            catch (Exception e)
            {
                throw new Exception("Unable to generate serializers for type '" + wdtype.type.Name + "'", e);
            }
        }

        class SerializerBase : WireDataGenerator
        {
            protected Type rootType { get; private set; }

            public SerializerBase(MethodBuilder builder, Type type) : base(builder)
            {
                rootType = type;
            }


            public void EmitSchemaVersionCheck(
                WireInfoAttribute wdattr,
                Action emitTask
            )
            {
                EmitMinMaxCheck(
                    wdattr.MinSchemaVersionVal, wdattr.MaxSchemaVersionVal,
                    delegate { Emit(OpCodes.Ldfld, typeof(WireData).GetField("SchemaVersion")); },
                    emitTask
                );
            }

            public void EmitArrayLength(
                FieldContext field
            )
            {
                EmitArrayLength(
                    LoadDelegate(field.field),
                    false
                );
            }
        }

        class EncryptionRequiredSerializer : SerializerBase
        {
            private EncryptionRequiredSerializer(MethodBuilder builder, Type type)
            : base (builder, type)
            {}

            private void Emit()
            {
                object[] attributes = rootType.GetCustomAttributes(typeof(WireDataEncryptionAttribute), true);
                if ((attributes == null) || (attributes.Length == 0))
                {
                    EmitZero();
                    Emit(OpCodes.Ret);
                    return;
                }

                EmitMethodHeader(rootType);

                // WireDataEncryptionAttribute.StringToVersion(attribute.AsOfSchemaVersion)
                WireDataEncryptionAttribute attribute = (WireDataEncryptionAttribute)attributes[0];
                uint version = WireDataEncryptionAttribute.StringToVersion(attribute.AsOfSchemaVersion).GetValueOrDefault();
                EmitConst((int)version);

                // this.SchemaVersion
                EmitLoad(typeof(WireData).GetField("SchemaVersion"));

                // WireDataEncryptionAttribute.StringToVersion(attribute.AsOfSchemaVersion) <= this.SchemaVersion
                //   There is no "less than or equals opcode, so doing instead:
                //   (WireDataEncryptionAttribute.StringToVersion(attribute.AsOfSchemaVersion) > this.SchemaVersion) == false
                Emit(OpCodes.Cgt_Un);
                EmitZero();
                Emit(OpCodes.Ceq);
                Emit(OpCodes.Ret);
            }

            internal static void EmitMethod(MethodBuilder builder, Type type, FieldContext[] ignored)
            {
                (new EncryptionRequiredSerializer(builder, type)).Emit();
            }

        }

        class SizeofSerializer : SerializerBase
        {
            bool hdrCreated;
            int constLength;

            private SizeofSerializer(MethodBuilder builder, Type type)
            : base (builder, type)
            {}

            void EnsureHeaderCreated()
            {
                if (hdrCreated)
                    return;

                EmitMethodHeader(rootType);

                DeclareLocal(typeof(int));
                EmitZero();
                Emit(OpCodes.Stloc_1);

                DeclareLocal(typeof(UTF8Encoding));
                Emit(OpCodes.Ldnull);
                Emit(OpCodes.Stloc_2);

                hdrCreated = true;
            }

            static Dictionary<Type, int> serializeLens = new Dictionary<Type, int>
            {
                { typeof(bool), sizeof(bool) },
                { typeof(sbyte), sizeof(sbyte) },
                { typeof(byte), sizeof(byte) },
                { typeof(short), sizeof(short) },
                { typeof(ushort), sizeof(ushort) },
                { typeof(int), sizeof(int) },
                { typeof(uint), sizeof(uint) },
                { typeof(long), sizeof(long) },
                { typeof(ulong), sizeof(ulong) },
                { typeof(float), sizeof(float) },
                { typeof(double), sizeof(double) },
                { typeof(DateTime), sizeof(long) },
                { typeof(Guid), 16 },
                { typeof(decimal), 16 },            
            };

            static bool TryGetConstLengthFromType(
                Type type,
                out int len)
            {
                len = 0;

                if (type.IsEnum)
                {
                    type = Enum.GetUnderlyingType(type);
                }

                return serializeLens.TryGetValue(type, out len);
            }

            void EmitAddToLocalSize(Action loadAddend)
            {
                Emit(OpCodes.Ldloc_1);
                loadAddend();
                Emit(OpCodes.Add);
                Emit(OpCodes.Stloc_1);
            }

            void EmitIfSchemaVersionSensitive(FieldContext field, int len)
            {
                if (IsSchemaVersionSensitive(field))
                {
                    EnsureHeaderCreated();

                    EmitSchemaVersionCheck(
                        field.wdattr,
                        delegate()
                        {
                            EmitAddToLocalSize(
                                delegate()
                                {
                                    EmitConst(len);
                                });
                        });
                }
                else
                {
                    constLength += len;
                }
            }

            Action PrepareFieldForEmit(FieldContext field, out int sizeToAdd)
            {
                Type fieldType = field.field.FieldType;

                if (!fieldType.IsArray && field.wdattr.SerializeAs != null)
                {
                    fieldType = field.wdattr.SerializeAs;
                }

                sizeToAdd = 0;

                if (TryGetConstLengthFromType(fieldType, out sizeToAdd))
                {
                    return null;
                }
                else if (fieldType == typeof(char))
                {
                    return delegate()
                    {
                        EmitAddToLocalSize(
                            delegate()
                            {
                                EmitCall(OpCodes.Call, typeof(Encoding).GetProperty("UTF8").GetGetMethod(), null);
                                Emit(OpCodes.Ldloc_0);
                                if (field.wdattr.SerializeAs != null)
                                {
                                    Emit(OpCodes.Ldfld, field.field);
                                    EmitCall(
                                        OpCodes.Call,
                                        GetConversionMethod(field.field.FieldType, field.wdattr.SerializeAs),
                                        null);
                                    LocalBuilder l = DeclareLocal(field.wdattr.SerializeAs);
                                    Emit(OpCodes.Stloc, l);
                                    Emit(OpCodes.Ldloca, l);
                                }
                                else
                                {
                                    Emit(OpCodes.Ldflda, field.field);
                                }
                                EmitConst(1);
                                EmitCall(
                                    OpCodes.Callvirt,
                                    typeof(Encoding).GetMethod("GetByteCount", new Type[] { typeof(char*), typeof(int) }),
                                    null);
                            });
                    };
                }
                else if (fieldType == typeof(string))
                {
                    if (field.wdattr.ArraySize != -1)
                    {
                        sizeToAdd = field.wdattr.ArraySize;

                        if (field.wdattr.NullTerminate)
                        {
                            sizeToAdd++;
                        }

                        return null;
                    }
                    else
                    {
                        return delegate()
                        {
                            // Emit estimation of string size
                            EmitNullCheck(
                                    LoadDelegate(field.field),
                                    delegate() 
                                    {
                                        EmitAddToLocalSize(
                                        delegate()
                                        {
                                            EmitCall(OpCodes.Call, typeof(Encoding).GetProperty("UTF8").GetGetMethod(), null);
                                            EmitLoad(field.field);
                                            EmitCall(
                                                OpCodes.Callvirt,
                                                typeof(Encoding).GetMethod("GetByteCount", new Type[] { typeof(string) }),
                                                null);
                                            if (field.wdattr.NullTerminate)
                                            {
                                                EmitConst(1);
                                                Emit(OpCodes.Add);
                                            }
                                        });
                                });
                        };
                    }
                }
                else if (fieldType.IsSubclassOf(typeof(WireData)))
                {
                    return delegate()
                    {
                        EmitNullCheck(
                            LoadDelegate(field.field),

                            delegate()
                            {
                                EmitAddToLocalSize(
                                    delegate()
                                    {
                                        EmitLoad(field.field);
                                        if (field.wdattr.SerializeAs != null)
                                        {
                                            EmitCall(OpCodes.Call, GetConversionMethod(field.field.FieldType, field.wdattr.SerializeAs), null);
                                        }
                                        EmitCall(OpCodes.Callvirt, fieldType.GetProperty("SerializedSize").GetGetMethod(), null);
                                    });
                            });
                    };
                }
                else if (fieldType.IsArray)
                {
                    Type elemType = field.wdattr.SerializeAs ?? fieldType.GetElementType();

                    int outLen;
                    if (TryGetConstLengthFromType(elemType, out outLen))
                    {
                        // If there is a static arraysize parameter, then compute total length
                        if (field.wdattr.ArraySize != -1)
                        {
                            sizeToAdd = outLen * field.wdattr.ArraySize;
                            return null;
                        }
                        else
                        {
                            return delegate()
                            {
                                EmitNullCheck(
                                    LoadDelegate(field.field),
                                    delegate()
                                    {
                                        EmitAddToLocalSize(
                                            delegate()
                                            {
                                                EmitArrayLength(field);
                                                if (outLen != 1)
                                                {
                                                    EmitConst(outLen);
                                                    Emit(OpCodes.Mul);
                                                }
                                            });
                                    });
                            };
                        }
                    }
                    else
                    {
                        return delegate()
                        {
                            EmitNullCheck(
                                LoadDelegate(field.field),
                                delegate()
                                {
                                    // Iterate through fields to calculate size
                                    EmitIncrementalLoop(
                                        delegate(LocalBuilder l)
                                        {
                                            if (elemType.IsSubclassOf(typeof(WireData)))
                                            {
                                                EmitNullCheck(
                                                    delegate()
                                                    {
                                                        EmitLoad(field.field);
                                                        Emit(OpCodes.Ldloc, l);
                                                        Emit(OpCodes.Ldelem, elemType);
                                                    },
                                                    delegate()
                                                    {
                                                        EmitAddToLocalSize(
                                                            delegate()
                                                            {
                                                                EmitLoad(field.field);
                                                                Emit(OpCodes.Ldloc, l);
                                                                Emit(OpCodes.Ldelem, elemType);
                                                                if (field.wdattr.SerializeAs != null)
                                                                {
                                                                    EmitCall(OpCodes.Call, GetConversionMethod(fieldType.GetElementType(), field.wdattr.SerializeAs), null);
                                                                }
                                                                EmitCall(OpCodes.Callvirt, elemType.GetProperty("SerializedSize").GetGetMethod(), null);
                                                            });
                                                    },
                                                    null);
                                            }
                                            else
                                            {
                                                throw new Exception("unknown array size serializer: " + elemType.ToString());
                                            }
                                        },
                                        delegate(LocalBuilder l)
                                        {
                                            EmitArrayLength(field);
                                        });
                                });
                        };
                    }
                }
                else
                {
                    throw new Exception("unknown size serialization: " + fieldType.ToString());
                }
            }

            void Emit(FieldContext[] fields)
            {
                for (int i = 0; i < fields.Length; i++)
                {
                    FieldContext field = fields[i];

                    if (!field.wdattr.Serialize)
                    {
                        continue;
                    }

                    int len;
                    Action emitField = PrepareFieldForEmit(field, out len);

                    if (emitField == null)
                    {
                        EmitIfSchemaVersionSensitive(field, len);
                    }
                    else
                    {
                        EnsureHeaderCreated();

                        EmitSchemaVersionCheck(field.wdattr, emitField);
                    }

                }

                if (!hdrCreated)
                {
                    EmitConst(constLength);
                }
                else
                {
                    Emit(OpCodes.Ldloc_1);

                    if (constLength != 0)
                    {
                        EmitConst(constLength);
                        Emit(OpCodes.Add);
                    }
                }

                Emit(OpCodes.Ret);
            }

            internal static void EmitMethod(MethodBuilder builder, Type type, FieldContext[] fields)
            {
                (new SizeofSerializer(builder, type)).Emit(fields);
            }
        }

        class ToStringSerializer : SerializerBase
        {
            ToStringSerializer(MethodBuilder builder, Type type)
                : base (builder, type)
            {}

            internal static void EmitMethod(
                MethodBuilder builder,
                Type type,
                FieldContext[] fields)
            {
                (new ToStringSerializer(builder, type)).Emit(fields);
            }

            void Emit(FieldContext[] fields)
            {
                EmitMethodHeader(rootType);

                DeclareLocal(typeof(string));
                EmitConst(Convert.ToInt32(' '));
                Emit(OpCodes.Ldarg_2);
                Emit(OpCodes.Newobj, typeof(string).GetConstructor(new Type[] { typeof(char), typeof(int) }));
                Emit(OpCodes.Stloc_1);

                DeclareLocal(typeof(string));
                EmitConst(Convert.ToInt32(' '));
                Emit(OpCodes.Ldarg_2);
                EmitConst(WireData.C_INDENT);
                Emit(OpCodes.Add);
                Emit(OpCodes.Newobj, typeof(string).GetConstructor(new Type[] { typeof(char), typeof(int) }));
                Emit(OpCodes.Stloc_2);

                DeclareLocal(typeof(string));
                EmitConst(Convert.ToInt32(' '));
                Emit(OpCodes.Ldarg_2);
                EmitConst(2 * WireData.C_INDENT);
                Emit(OpCodes.Add);
                Emit(OpCodes.Newobj, typeof(string).GetConstructor(new Type[] { typeof(char), typeof(int) }));
                Emit(OpCodes.Stloc_3);

                Emit(OpCodes.Ldarg_1);
                Emit(OpCodes.Ldstr, PrettyPrintTypeName(rootType) + " {");
                EmitCall(OpCodes.Call, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                Emit(OpCodes.Pop);

                for (int i = 0; i < fields.Length; i++)
                {

                    if (!fields[i].wdattr.PrintToString)
                    {
                        continue;
                    }            

                    EmitDelegateCall(fields[i].field.Name);

                    Emit(OpCodes.Ldarg_1);
                    Emit(OpCodes.Ldloc_2);
                    EmitCall(OpCodes.Call, typeof(StringBuilder).GetMethod("Append", new Type[] { typeof(string) }), null);
                    Emit(OpCodes.Ldstr, fields[i].field.Name + "=");
                    EmitCall(OpCodes.Call, typeof(StringBuilder).GetMethod("Append", new Type[] { typeof(string) }), null);
                    EmitField(fields[i],
                        fields[i].field.FieldType,
                        LoadDelegate(fields[i].field),
                        LoadAddressDelegate(fields[i].field),
                        delegate()
                        {
                            Emit(OpCodes.Ldarg_2);
                            EmitConst(WireData.C_INDENT);
                            Emit(OpCodes.Add);
                        });
                }

                Emit(OpCodes.Ldarg_1);

                Emit(OpCodes.Ldloc_1);
                EmitCall(OpCodes.Call, typeof(StringBuilder).GetMethod("Append", new Type[] { typeof(string) }), null);
                Emit(OpCodes.Ldstr, "}");
                EmitCall(OpCodes.Call, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                Emit(OpCodes.Pop);

                Emit(OpCodes.Ret);
            }

            void EmitField(FieldContext field, Type fieldType, Action loadElem, Action loadElemAddr, Action loadIndentSize)
            {
                bool needPop = true;
                if (fieldType == typeof(string))
                {
                    if (field.wdattr.LimitString)
                    {
                        // The call to LimitString will appropriately return "= null"
                        // WireData.LimitString(field)
                        loadElem();
                        if (field.wdattr.MaskString)
                        {
                            EmitCall(OpCodes.Call, typeof(WireData).GetMethod("MaskString", new Type[] { typeof(string) }), null);
                        }
                        EmitCall(OpCodes.Call, typeof(WireData).GetMethod("LimitString", new Type[] { typeof(string) }), null);
                    }
                    else
                    {
                        Label labelExists = DefineLabel();
                        // field ?? " null"
                        loadElem();
                        Emit(OpCodes.Dup);
                        Emit(OpCodes.Brtrue_S, labelExists);
                        Emit(OpCodes.Pop);
                        Emit(OpCodes.Ldstr, " null");
                        MarkLabel(labelExists);
                        if (field.wdattr.MaskString)
                        {
                            EmitCall(OpCodes.Call, typeof(WireData).GetMethod("MaskString", new Type[] { typeof(string) }), null);
                        }
                    }

                    EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                }
                else if (fieldType.IsEnum)
                {
                    loadElem();
                    Emit(OpCodes.Box, fieldType);
                    EmitCall(OpCodes.Callvirt, typeof(object).GetMethod("ToString", Type.EmptyTypes), null);
                    if (field.wdattr.MaskString)
                    {
                        EmitCall(OpCodes.Call, typeof(WireData).GetMethod("MaskString", new Type[] { typeof(string) }), null);
                    }
                    EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                }
                else if (fieldType == typeof(DateTime))
                {
                    loadElemAddr();
                    Emit(OpCodes.Ldstr, "s");
                    EmitCall(OpCodes.Call, typeof(DateTime).GetMethod("ToString", new Type[] { typeof(string) }), null);
                    if (field.wdattr.MaskString)
                    {
                        EmitCall(OpCodes.Call, typeof(WireData).GetMethod("MaskString", new Type[] { typeof(string) }), null);
                    }
                    EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                }
                else if (fieldType == typeof(HResult))
                {
                    loadElem();

                    EmitCall(OpCodes.Call, typeof(WireData).GetMethod("GetHrName"), null);
                    if (field.wdattr.MaskString)
                    {
                        EmitCall(OpCodes.Call, typeof(WireData).GetMethod("MaskString", new Type[] { typeof(string) }), null);
                    }
                    EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                }
                // Handle structs, but not the primitive types (byte, int, etc.)  That case is handled later.
                else if (fieldType.IsValueType && !fieldType.IsPrimitive)
                {
                    // If super-cool ToString(StringBuilder, int) exists, use that.
                    MethodInfo func;

                    func = fieldType.GetMethod("ToString", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public, null, Type.EmptyTypes, null);
                    if (func != null)
                    {
                        loadElemAddr();
                        EmitCall(OpCodes.Callvirt, func, null);
                    }
                    else
                    {
                        // No specific ToString method, calling object.ToString()
                        loadElem();
                        Emit(OpCodes.Box, fieldType);
                        EmitCall(OpCodes.Callvirt, fieldType.GetMethod("ToString", Type.EmptyTypes), null);
                    }
                    if (field.wdattr.MaskString)
                    {
                        EmitCall(OpCodes.Call, typeof(WireData).GetMethod("MaskString", new Type[] { typeof(string) }), null);
                    }
                    EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                }
                else if (fieldType.IsSubclassOf(typeof(WireData)))
                {
                    Emit(OpCodes.Pop);
                    needPop = false;

                    EmitNullCheck(
                        loadElem,
                        delegate()
                        {
                            loadElem();
                            Emit(OpCodes.Ldarg_1);
                            loadIndentSize();
                            EmitCall(OpCodes.Callvirt, fieldType.GetMethod("ToString", new Type[] { typeof(StringBuilder), typeof(int) }), null);
                        },
                        delegate()
                        {
                            Emit(OpCodes.Ldarg_1);
                            Emit(OpCodes.Ldstr, " null");
                            EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                            Emit(OpCodes.Pop);
                        });
                }
                else if (fieldType == typeof(byte[]))
                {
                    needPop = false;

                    loadElem();
                    Emit(OpCodes.Ldarg_2);
                    EmitConst(WireData.C_INDENT);
                    Emit(OpCodes.Add);
                    EmitConst(field.wdattr.LimitString.GetType(), field.wdattr.LimitString ? 1 : 0);
                    EmitConst(field.wdattr.MaskString.GetType(), field.wdattr.MaskString ? 1 : 0);
                    EmitCall(OpCodes.Call, typeof(WireData).GetMethod("ByteArrayToString", new Type[] { typeof(StringBuilder), typeof(byte[]), typeof(int), typeof(bool), typeof(bool) }), null);
                }
                else if (fieldType.IsArray)
                {
                    needPop = false;

                    Emit(OpCodes.Pop);
                    EmitNullCheck(
                        loadElem,
                        delegate()
                        {
                            Emit(OpCodes.Ldarg_1);
                            EmitStringConcat(
                                PrettyPrintTypeName(fieldType.GetElementType()) + "[",
                                new Action(
                                    delegate()
                                    {
                                        EmitArrayLength(loadElem, true);
                                    }),
                                "] {");
                            EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                            Emit(OpCodes.Pop);

                            EmitArray(field, fieldType, loadElem);

                            // Emit closing brace
                            Emit(OpCodes.Ldarg_1);
                            Emit(OpCodes.Ldloc_2);
                            EmitCall(OpCodes.Call, typeof(StringBuilder).GetMethod("Append", new Type[] { typeof(string) }), null);
                            Emit(OpCodes.Ldstr, "}");
                            EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                            Emit(OpCodes.Pop);
                        },
                        delegate()
                        {
                            Emit(OpCodes.Ldarg_1);
                            Emit(OpCodes.Ldstr, " null");
                            EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                            Emit(OpCodes.Pop);
                        });
                }
                else if (field.wdattr.SerializeAs != null && field.wdattr.SerializeAs != fieldType)
                {
                    needPop = false;
                    EmitField(field,
                        field.wdattr.SerializeAs,
                        delegate()
                        {
                            loadElem();
                            EmitCall(OpCodes.Call, GetConversionMethod(fieldType, field.wdattr.SerializeAs), null);
                        },
                        delegate()
                        {
                            LocalBuilder ltemp = DeclareLocal(field.wdattr.SerializeAs);
                            loadElem();
                            EmitCall(OpCodes.Call, GetConversionMethod(fieldType, field.wdattr.SerializeAs), null);
                            Emit(OpCodes.Stloc, ltemp);
                            Emit(OpCodes.Ldloca, ltemp);
                        },
                        loadIndentSize);
                }
                else
                {
                    if (IsSupportedHexStringType(field, fieldType))
                    {
                        EmitStringConcatAllStrings(
                            "0x",
                            new Action(
                                delegate()
                                {
                                    EmitHexValue(field, fieldType, loadElemAddr);
                                }));

                        if (field.wdattr.MaskString)
                        {
                            EmitCall(OpCodes.Call, typeof(WireData).GetMethod("MaskString", new Type[] { typeof(string) }), null);
                        }
                        if (field.wdattr.LimitString)
                        {
                            EmitCall(OpCodes.Call, typeof(WireData).GetMethod("LimitString", new Type[] { typeof(string) }), null);
                        }
                        EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                    }
                    else if (field.wdattr.LimitString)
                    {
                        loadElemAddr();
                        EmitCall(OpCodes.Callvirt, fieldType.GetMethod("ToString", Type.EmptyTypes), null);

                        if (field.wdattr.MaskString)
                        {
                            EmitCall(OpCodes.Call, typeof(WireData).GetMethod("MaskString", new Type[] { typeof(string) }), null);
                        }
                        EmitCall(OpCodes.Call, typeof(WireData).GetMethod("LimitString", new Type[] { typeof(string) }), null);
                        EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                    }
                    else
                    {
                        MethodInfo m = typeof(StringBuilder).GetMethod("Append", new Type[] { fieldType });
                        if (m == null || (m != null && field.wdattr.MaskString))
                        {
                            loadElemAddr();

                            EmitCall(OpCodes.Callvirt, fieldType.GetMethod("ToString", Type.EmptyTypes), null);
                            if (field.wdattr.MaskString)
                            {
                                EmitCall(OpCodes.Call, typeof(WireData).GetMethod("MaskString", new Type[] { typeof(string) }), null);
                            }
                            EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", new Type[] { typeof(string) }), null);
                        }
                        else
                        {
                            loadElem();

                            EmitCall(OpCodes.Callvirt, m, null);
                            EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("AppendLine", Type.EmptyTypes), null);
                        }
                    }
                }

                if (needPop)
                {
                    Emit(OpCodes.Pop);
                }
            }

            static bool IsSupportedHexStringType(FieldContext field, Type fieldType)
            {
                return field.wdattr.HexString &&
                    (fieldType == typeof(byte) || fieldType == typeof(sbyte) ||
                    fieldType == typeof(short) || fieldType == typeof(ushort) ||
                    fieldType == typeof(int) || fieldType == typeof(uint) ||
                    fieldType == typeof(long) || fieldType == typeof(ulong));
            }

            void EmitHexValue(FieldContext field, Type fieldType, Action loadElemAddr)
            {
                string fieldFormat = null;
                if (fieldType == typeof(byte) || fieldType == typeof(sbyte))
                {
                    fieldFormat = "X2";
                }
                else if (fieldType == typeof(short) || fieldType == typeof(ushort))
                {
                    fieldFormat = "X4";
                }
                else if (fieldType == typeof(int) || fieldType == typeof(uint))
                {
                    fieldFormat = "X8";
                }
                else if (fieldType == typeof(long) || fieldType == typeof(ulong))
                {
                    fieldFormat = "X16";
                }

                loadElemAddr();
                Emit(OpCodes.Ldstr, fieldFormat);
                EmitCall(OpCodes.Callvirt, fieldType.GetMethod("ToString", new Type[] { typeof(string) }), null);
            }

            void EmitArray(FieldContext field, Type fieldType, Action loadElem)
            {
                Type elemType = fieldType.GetElementType();

                EmitIncrementalLoop(
                    delegate(LocalBuilder i)
                    {
                        Emit(OpCodes.Ldarg_1);
                        EmitStringConcat(
                            new Action(
                                delegate()
                                {
                                    Emit(OpCodes.Ldloc_3);
                                }),
                            "[",
                            new Action(
                                delegate()
                                {
                                    Emit(OpCodes.Ldloc, i);
                                    Emit(OpCodes.Box, typeof(int));
                                }),
                                "]=");
                        EmitCall(OpCodes.Callvirt, typeof(StringBuilder).GetMethod("Append", new Type[] { typeof(string) }), null);

                        EmitField(field,
                            fieldType.GetElementType(),
                            delegate()
                            {
                                loadElem();
                                Emit(OpCodes.Ldloc, i);
                                Emit(OpCodes.Ldelem, elemType);
                            },
                            delegate()
                            {
                                loadElem();
                                Emit(OpCodes.Ldloc, i);
                                Emit(OpCodes.Ldelema, elemType);
                            },
                            delegate()
                            {
                                Emit(OpCodes.Ldarg_2);
                                EmitConst(2 * WireData.C_INDENT);
                                Emit(OpCodes.Add);
                            });
                    },
                    delegate(LocalBuilder i)
                    {
                        EmitArrayLength(field);
                    });
            }
        }

        static bool IsSchemaVersionSensitive(FieldContext field)
        {
            return field.wdattr.MinSchemaVersionVal > UInt32.MinValue || field.wdattr.MaxSchemaVersionVal < UInt32.MaxValue;
        }

        // Emit the Read method
        class ReadSerializer : SerializerBase
        {
            ReadSerializer(MethodBuilder builder, Type type)
                : base(builder, type)
            { }

            void Emit(FieldContext[] fields)
            {
                EmitMethodHeader(rootType);

                // Emit the value of the UTF8Encoding that will be referenced throughout this method
                DeclareLocal(typeof(UTF8Encoding));
                Emit(OpCodes.Newobj, typeof(UTF8Encoding).GetConstructor(Type.EmptyTypes));
                Emit(OpCodes.Stloc_1);

                // Temp variable for string length comparisons
                DeclareLocal(typeof(int));

                for (int i = 0; i < fields.Length; i++)
                {
                    if (!fields[i].wdattr.Serialize)
                    {
                        continue;
                    }

                    EmitDelegateCall(rootType.Name + "." + fields[i].field.Name);

                    EmitSchemaVersionCheck(
                        fields[i].wdattr, delegate()
                        {
                            EmitField(fields[i],
                                fields[i].field.FieldType,
                                LoadDelegate(fields[i].field),
                                delegate(Action loadValue)
                                {
                                    Emit(OpCodes.Ldloc_0);
                                    loadValue();
                                    Emit(OpCodes.Stfld, fields[i].field);
                                });
                        });
                }

                Emit(OpCodes.Ret);
            }


            void EmitField(
                FieldContext field,
                Type fieldType,
                Action loadField,
                Action<Action> storeField)
            {
                EmitReadField(field, fieldType, true, loadField, storeField);
            }

            void EmitReadField(
                FieldContext field,
                Type fieldType,
                bool checkExists,
                Action loadField,
                Action<Action> storeField)
            {
                if (fieldType == typeof(byte[]))
                {
                    EmitReadBytes(field, field.field.FieldType, loadField, storeField);
                }
                else if (fieldType.IsArray)
                {
                    EmitReadArray(field, fieldType, loadField, storeField);
                }
                else if (field.wdattr.SerializeAs != null && field.wdattr.SerializeAs != fieldType)
                {
                    EmitReadField(
                        field,
                        field.wdattr.SerializeAs,
                        checkExists,
                        delegate()
                        {
                            loadField();
                            EmitCall(OpCodes.Call, GetConversionMethod(fieldType, field.wdattr.SerializeAs), null);
                        },
                        delegate(Action loadValue)
                        {
                            storeField(
                                delegate()
                                {
                                    loadValue();
                                    EmitCall(OpCodes.Call, GetConversionMethod(field.wdattr.SerializeAs, fieldType), null);
                                });
                        });
                }
                else if (fieldType == typeof(string))
                {
                    EmitReadString(field, loadField, storeField);
                }
                else if (fieldType.IsSubclassOf(typeof(WireData)))
                {
                    EmitReadWireInfo(field, fieldType, loadField, checkExists, storeField);
                }
                else if (fieldType == typeof(DateTime))
                {
                    storeField(
                        delegate()
                        {
                            EmitBinaryRead(typeof(long), null, field.wdattr.BigEndian);
                            EmitCall(OpCodes.Call, typeof(DateTime).GetMethod("FromFileTimeUtc", new Type[] { typeof(long) }), null);
                        });
                }
                else if (fieldType == typeof(Guid))
                {
                    storeField(
                        delegate()
                        {
                            EmitBinaryRead(typeof(byte[]),
                                delegate()
                                {
                                    EmitConst(16);
                                },
                                false);
                            if (field.wdattr.BigEndian)
                            {
                                EmitCall(OpCodes.Call, typeof(xonline.common.utilities2.ByteOrder).GetMethod("RevertGuidBytesInline"), null);
                            }
                            Emit(OpCodes.Newobj, typeof(Guid).GetConstructor(new Type[] { typeof(byte[]) }));
                        });
                }
                else if (fieldType.IsEnum)
                {
                    storeField(
                        delegate()
                        {
                            EmitBinaryRead(Enum.GetUnderlyingType(fieldType), null, field.wdattr.BigEndian);
                        });
                }
                else
                {
                    storeField(
                        delegate()
                        {
                            EmitBinaryRead(fieldType, null, field.wdattr.BigEndian);
                        });

                    //check range
                    if (field.wdattr != null && field.wdattr.MaxSet)
                    {
                        Label labelIsGreater = DefineLabel();

                        loadField();
                        EmitConst(typeof(long), (int)field.wdattr.Max);
                        Emit(IsUnsignedFieldType(fieldType) ? OpCodes.Ble_Un_S : OpCodes.Ble_S, labelIsGreater);
                        EmitConst(typeof(uint), unchecked((int)HResult.E_INVALIDARG));
                        EmitCall(OpCodes.Call, GetConversionMethod(typeof(uint), typeof(HResult)), null);
                        var err = String.Format("Field '{0}' has read value [{{0}}] which is greater than max value allowed [{1}]",
                                                    field.field.Name, field.wdattr.Max);
                        Emit(OpCodes.Ldstr, err);
                        EmitConst(1);
                        Emit(OpCodes.Newarr, typeof(object));
                        var arrayLocal = DeclareLocal(typeof(object[]));
                        Emit(OpCodes.Stloc, arrayLocal);
                        Emit(OpCodes.Ldloc, arrayLocal);
                        EmitZero();
                        loadField();
                        Emit(OpCodes.Box, fieldType);
                        Emit(OpCodes.Stelem_Ref);
                        Emit(OpCodes.Ldloc, arrayLocal);
                        Emit(OpCodes.Newobj, typeof(XblException).GetConstructor(new Type[] { typeof(HResult), typeof(string), typeof(object[]) }));
                        Emit(OpCodes.Throw);
                        MarkLabel(labelIsGreater);
                    }

                    if (field.wdattr != null && field.wdattr.MinSet)
                    {
                        Label labelIsLess = DefineLabel();

                        loadField();
                        EmitConst(typeof(long), (int)field.wdattr.Min);
                        Emit(IsUnsignedFieldType(fieldType) ? OpCodes.Bge_Un_S : OpCodes.Bge_S, labelIsLess);
                        EmitConst(typeof(uint), unchecked((int)HResult.E_INVALIDARG));
                        EmitCall(OpCodes.Call, GetConversionMethod(typeof(uint), typeof(HResult)), null);
                        var err = String.Format("Field '{0}' has read value [{{0}}] which is less than min value allowed [{1}]",
                                                    field.field.Name, field.wdattr.Min);
                        Emit(OpCodes.Ldstr, err);
                        EmitConst(1);
                        Emit(OpCodes.Newarr, typeof(object));
                        var arrayLocal = DeclareLocal(typeof(object[]));
                        Emit(OpCodes.Stloc, arrayLocal);
                        Emit(OpCodes.Ldloc, arrayLocal);
                        EmitZero();
                        loadField();
                        Emit(OpCodes.Box, fieldType);
                        Emit(OpCodes.Stelem_Ref);
                        Emit(OpCodes.Ldloc, arrayLocal);
                        Emit(OpCodes.Newobj, typeof(XblException).GetConstructor(new Type[] { typeof(HResult), typeof(string), typeof(object[]) }));
                        Emit(OpCodes.Throw);
                        MarkLabel(labelIsLess);
                    }

                    if (field.sizeOf != null && field.sizeOf.wdattr.ArraySize != -1)
                    {
                        Label labelRead = DefineLabel();

                        loadField();
                        EmitConst(fieldType, field.sizeOf.wdattr.ArraySize);
                        Emit(OpCodes.Beq, labelRead);
                        loadField();
                        EmitZero(fieldType);
                        Emit(OpCodes.Beq, labelRead);
                        EmitThrowException(
                            delegate()
                            {
                                EmitStringConcat(
                                    "Field '" + field.field.Name + "' has read value [",
                                    new Action(
                                        delegate()
                                        {
                                            loadField();
                                            Emit(OpCodes.Box, fieldType);
                                        }
                                    ),
                                    "] that does not match it's ArraySize [" + field.sizeOf.wdattr.ArraySize + "]");
                            });

                        MarkLabel(labelRead);
                    }
                }
            }

            // Emit IL to read a string field
            void EmitReadString(FieldContext field, Action loadField, Action<Action> storeField)
            {
                LocalBuilder bytes = DeclareLocal(typeof(byte[]));

                EmitReadBytes(field, typeof(byte[]),
                    delegate()
                    {
                        Emit(OpCodes.Ldloc, bytes);
                    },
                    delegate(Action loadValue)
                    {
                        loadValue();
                        Emit(OpCodes.Stloc, bytes);
                    });

                storeField(
                    delegate()
                    {
                        EmitUtf8Decode(
                            delegate()
                            {
                                Emit(OpCodes.Ldloc, bytes);
                            });
                    });

                // Don't qualify the SubString() operation for the fields that would by metadata have extra nulls
                // For strings, the xbox360 will send up a null string as length 1 and '\0' as the character, instead
                // of null.  So, need to skip the check until it can be determined under what conditions the console
                // will send this.
                // if (field.wdattr.NullTerminate || field.wdattr.ArraySize != -1)
                // {
                Label labelSkipTask = DefineLabel();

                loadField();
                EmitZero();
                EmitCall(OpCodes.Callvirt, typeof(string).GetMethod("IndexOf", new Type[] { typeof(char) }), null);
                Emit(OpCodes.Stloc_2);
                Emit(OpCodes.Ldloc_2);
                EmitZero();
                Emit(OpCodes.Blt_S, labelSkipTask);

                storeField(
                    delegate()
                    {
                        loadField();
                        EmitZero();
                        Emit(OpCodes.Ldloc_2);
                        EmitCall(OpCodes.Callvirt, typeof(string).GetMethod("Substring", new Type[] { typeof(int), typeof(int) }), null);
                    });

                MarkLabel(labelSkipTask);
            }
            //        }

            // Emit IL to read a byte[] field
            void EmitReadBytes(FieldContext field, Type fieldType, Action loadField, Action<Action> storeField)
            {
                storeField(
                    delegate()
                    {
                        EmitBinaryRead(fieldType, delegate()
                        {
                            EmitFieldSize(field);
                        }, field.wdattr.BigEndian);
                    });

                Label labelValidSize = DefineLabel();

                EmitArrayLength(loadField);
                EmitFieldSize(field);

                if (field.wdattr.ArraySize != -1)
                {
                    Emit(OpCodes.Beq_S, labelValidSize);
                    EmitThrowException(typeof(EndOfStreamException),
                        delegate()
                        {
                            EmitStringConcat(
                                "Unable to read " + field.wdattr.ArraySize + " bytes for field '" + field.field.Name + "' from stream, ",
                                new Action(delegate()
                                {
                                    EmitArrayLength(loadField, true);
                                }),
                                " bytes read.");
                        });
                }
                else
                {
                    Emit(OpCodes.Bge_S, labelValidSize);
                    EmitThrowException(typeof(EndOfStreamException),
                        delegate()
                        {
                            EmitStringConcat(
                                "Unable to read ",
                                new Action(delegate()
                                {
                                    EmitLoad(field.sizeParam.field);
                                    Emit(OpCodes.Box, field.sizeParam.field.FieldType);
                                }),
                                " bytes for field '" + field.field.Name + "' from stream, ",
                                new Action(delegate()
                                {
                                    EmitArrayLength(loadField, true);
                                }),
                                " bytes read.");
                        });
                }
                MarkLabel(labelValidSize);

            }

            // Emit IL to read a array field
            void EmitReadArray(FieldContext field, Type fieldType, Action loadField, Action<Action> storeField)
            {
                // Create array and store it in the field
                Type elemType = fieldType.GetElementType();

                // Initialize the array even if the param is zero.
                storeField(
                    delegate()
                    {
                        EmitFieldSize(field);
                        Emit(OpCodes.Newarr, elemType);
                    });

                // Use loop to read and store each element in the array
                EmitIncrementalLoop(
                    delegate(LocalBuilder i)
                    {
                        EmitDelegateCall(
                            delegate()
                            {
                                EmitStringConcat(
                                    field.field.DeclaringType.Name + "." + field.field.Name,
                                    "[",
                                    new Action(
                                        delegate()
                                        {
                                            Emit(OpCodes.Ldloc, i);
                                            Emit(OpCodes.Box, typeof(int));
                                        }),
                                        "]");
                            });
                        if (elemType.IsSubclassOf(typeof(WireData)))
                        {
                            EmitReadWireInfo(
                                field, elemType,
                                delegate()
                                {
                                    loadField();
                                    Emit(OpCodes.Ldloc, i);
                                    Emit(OpCodes.Ldelem_Ref);
                                },
                                false,
                                delegate(Action loadValue)
                                {
                                    loadField();
                                    Emit(OpCodes.Ldloc, i);
                                    loadValue();
                                    Emit(OpCodes.Stelem_Ref);
                                });
                        }
                        else
                        {
                            // Check to see if element load should use ref -- validation requires that
                            // SerializeAs can only be used with structs or objects (primitives don't have implicit
                            // conversion methods, so can't convert to SerializeAs class)
                            bool useRef = field.wdattr.SerializeAs != null && !elemType.IsValueType;
                            EmitReadField(
                                field,
                                elemType,
                                false,
                                delegate()
                                {
                                    loadField();
                                    Emit(OpCodes.Ldloc, i);
                                    Emit(useRef ? OpCodes.Ldelem_Ref : OpCodes.Ldelem);
                                },
                                delegate(Action loadValue)
                                {
                                    loadField();
                                    Emit(OpCodes.Ldloc, i);
                                    loadValue();
                                    if (useRef)
                                    {
                                        Emit(OpCodes.Stelem_Ref);
                                    }
                                    else
                                    {
                                        Emit(OpCodes.Stelem, elemType);
                                    }
                                });
                        }
                    },
                    delegate(LocalBuilder i)
                    {
                        EmitFieldSize(field);
                    });
            }

            // Emit IL to de-serialize a WireDataobject. The storeObject delegate is used to 
            // store the WireDataobject that was deserialized.
            void EmitReadWireInfo(
                FieldContext field,
                Type fieldType,
                Action loadObject,
                bool checkObjectExists,
                Action<Action> storeObject)
            {
                MethodInfo readMethod = fieldType.GetMethod(
                    "ReadStream",
                    BindingFlags.Public | BindingFlags.ExactBinding | BindingFlags.Instance,
                    null,
                    new Type[] { typeof(BinaryReader) },
                    new ParameterModifier[0]
                    );

                // In some cases, the value is assumed to exist, so there is no need to check and create the object.
                Label labelObjExists = DefineLabel();

                if (checkObjectExists)
                {
                    loadObject();
                    Emit(OpCodes.Dup);
                    Emit(OpCodes.Brtrue_S, labelObjExists);
                    Emit(OpCodes.Pop);
                }

                ConstructorInfo ci = fieldType.GetConstructor(Type.EmptyTypes);
                if (ci == null)
                {
                    throw new Exception(String.Format("Type {0} must have a public default (parameterless) constructor", fieldType.ToString()));
                }

                LocalBuilder lNew = DeclareLocal(fieldType);

                Emit(OpCodes.Newobj, ci);

                MarkLabel(labelObjExists);

                Emit(OpCodes.Stloc, lNew);

                Emit(OpCodes.Ldloc, lNew);
                EmitLoad(typeof(WireData).GetField("SchemaVersion"));
                Emit(OpCodes.Stfld, typeof(WireData).GetField("SchemaVersion"));

                storeObject(
                    delegate()
                    {
                        // ret = var.ReadStream(stream) ?? var;
                        Emit(OpCodes.Ldloc, lNew);
                        Emit(OpCodes.Ldarg_1);

                        EmitCall(OpCodes.Callvirt, readMethod, null);

                        Label returnExists = DefineLabel();
                        Emit(OpCodes.Dup);

                        Emit(OpCodes.Brtrue_S, returnExists);
                        Emit(OpCodes.Pop);
                        Emit(OpCodes.Ldloc, lNew);
                        MarkLabel(returnExists);
                    });
            }

            // Emit IL that pushed the size of a field on the stack. For fields with constant 
            // length, IL to push a constant will be generated. For fields with the SizeParam 
            // attribute, the field referenced by the SizeParam will be pushed and converted to 
            // an int.
            void EmitFieldSize(FieldContext field)
            {
                if (field.wdattr.ArraySize != -1)
                {
                    // Size is a constant
                    EmitConst(field.wdattr.ArraySize + (field.wdattr.NullTerminate ? 1 : 0));
                }
                else if (field.sizeParam != null)
                {
                    // Size comes from another field
                    EmitLoad(field.sizeParam.field);
                    if (field.sizeParam.field.FieldType != typeof(int))
                    {
                        EmitConvert(typeof(int));
                    }
                }
                else
                {
                    throw new Exception();
                }
            }

            // Emit IL to invoke a BinaryReader.Read* method. Which method depends on the 
            // type of the field. For calls that take a parameter (ReadBytes), the fillParam 
            // delegate will be used to generate the code that pushed the parameter on the 
            // stack.
            void EmitBinaryRead(
                Type fieldType,
                Action fillParam,
                bool byteSwap)
            {

                MethodInfo readMethod =
                    fieldType == typeof(bool) ?
                        typeof(BinaryReader).GetMethod("ReadBoolean", Type.EmptyTypes) :
                    fieldType == typeof(char) ?
                        typeof(BinaryReader).GetMethod("ReadChar", Type.EmptyTypes) :
                    fieldType == typeof(byte) ?
                        typeof(BinaryReader).GetMethod("ReadByte", Type.EmptyTypes) :
                    fieldType == typeof(sbyte) ?
                        typeof(BinaryReader).GetMethod("ReadSByte", Type.EmptyTypes) :
                    fieldType == typeof(UInt16) ?
                        typeof(BinaryReader).GetMethod("ReadUInt16", Type.EmptyTypes) :
                    fieldType == typeof(Int16) ?
                        typeof(BinaryReader).GetMethod("ReadInt16", Type.EmptyTypes) :
                    fieldType == typeof(UInt32) ?
                        typeof(BinaryReader).GetMethod("ReadUInt32", Type.EmptyTypes) :
                    fieldType == typeof(Int32) ?
                        typeof(BinaryReader).GetMethod("ReadInt32", Type.EmptyTypes) :
                    fieldType == typeof(UInt64) ?
                        typeof(BinaryReader).GetMethod("ReadUInt64", Type.EmptyTypes) :
                    fieldType == typeof(Int64) ?
                        typeof(BinaryReader).GetMethod("ReadInt64", Type.EmptyTypes) :
                    fieldType == typeof(float) ?
                        typeof(BinaryReader).GetMethod("ReadSingle", Type.EmptyTypes) :
                    fieldType == typeof(double) ?
                        typeof(BinaryReader).GetMethod("ReadDouble", Type.EmptyTypes) :
                    fieldType == typeof(decimal) ?
                        typeof(BinaryReader).GetMethod("ReadDecimal", Type.EmptyTypes) :
                    fieldType == typeof(byte[]) ?
                        typeof(BinaryReader).GetMethod("ReadBytes", new Type[] { typeof(int) }) :
                    null;

                if (readMethod == null)
                {
                    throw new Exception(
                        string.Format("Field type {0} not supported",
                                      fieldType.ToString()));
                }

                Emit(OpCodes.Ldarg_1); // BinaryReader br

                if (fillParam != null)
                {
                    fillParam();
                }

                EmitCall(OpCodes.Callvirt, readMethod, null);

                if (byteSwap)
                {
                    EmitCall(OpCodes.Call, typeof(xonline.common.utilities2.ByteOrder).GetMethod("Revert", new Type[] { fieldType }), null);
                }
            }

            internal static void EmitMethod(
                MethodBuilder builder,
                Type type,
                FieldContext[] fields)
            {
                (new ReadSerializer(builder, type)).Emit(fields);
            }
        }

        // Emit the Write method
        class WriteSerializer : SerializerBase
        {
            WriteSerializer(MethodBuilder builder, Type type)
                : base(builder, type)
            { }

            internal static void EmitMethod(
                MethodBuilder builder,
                Type type,
                FieldContext[] fields)
            {
                (new WriteSerializer(builder, type)).Emit(fields);
            }

            void Emit(FieldContext[] fields)
            {
                EmitMethodHeader(rootType);

                // Emit the value of the UTF8Encoding that will be referenced throughout this method
                DeclareLocal(typeof(UTF8Encoding));
                Emit(OpCodes.Newobj, typeof(UTF8Encoding).GetConstructor(Type.EmptyTypes));
                Emit(OpCodes.Stloc_1);

                // If we have any string fields, we need to encode them to UTF8 before we 
                // start serializing the fields.
                for (int i = 0; i < fields.Length; i++)
                {
                    if (!fields[i].wdattr.Serialize)
                    {
                        continue;
                    }

                    // Emit IL to encode a string field using UTF8 and store it in a local. The 
                    // LocalBuilder is stored in the FieldContext.encodedBlob.
                    if (fields[i].field.FieldType == typeof(string))
                    {
                        fields[i].encodedBlob = DeclareLocal(typeof(byte[]));

                        EmitNullCheck(
                            LoadDelegate(fields[i].field),
                            delegate()
                            {
                                EmitUtf8Encode(
                                    LoadDelegate(fields[i].field)
                                );
                                Emit(OpCodes.Stloc, fields[i].encodedBlob);
                            },
                            fields[i].wdattr.NullTerminate && fields[i].wdattr.ArraySize != -1 ?
                            delegate()
                            {
                                EmitZero();
                                Emit(OpCodes.Newarr, typeof(byte));
                                Emit(OpCodes.Stloc, fields[i].encodedBlob);
                            } :
                            (Action)null);
                    }
                }

                for (int i = 0; i < fields.Length; i++)
                {
                    if (!fields[i].wdattr.Serialize)
                    {
                        continue;
                    }

                    try
                    {
                        EmitSchemaVersionCheck(
                            fields[i].wdattr, delegate()
                            {
                                EmitField(
                                    fields[i],
                                    fields[i].field.FieldType,
                                    LoadDelegate(fields[i].field),
                                    LoadAddressDelegate(fields[i].field)
                                );
                            });
                    }
                    catch (Exception e)
                    {
                        throw new Exception("Unable to serialize field '" + fields[i].field.Name + "'", e);
                    }
                }

                Emit(OpCodes.Ret);
            }

            // Emit IL to serialize field
            void EmitField(
                FieldContext field,
                Type fieldType,
                Action loadField,
                Action loadFieldAddr)
            {
                if (field.encodedBlob != null)
                {
                    // This is an encoded string.
                    EmitFieldString(
                        field,
                        delegate()
                        {
                            Emit(OpCodes.Ldloc, field.encodedBlob);
                        });
                }
                else if (fieldType == typeof(byte[]))
                {
                    EmitFieldBytes(field, loadField);
                }
                else if (fieldType.IsArray)
                {
                    EmitFieldArray(field, fieldType, loadField);
                }
                else if (fieldType.IsSubclassOf(typeof(WireData)))
                {
                    EmitWireInfo(field, fieldType, loadField);
                }
                else if (fieldType == typeof(DateTime))
                {
                    EmitBinaryWrite(
                        typeof(long),
                        delegate()
                        {
                            loadFieldAddr();
                            EmitCall(OpCodes.Call, typeof(DateTime).GetMethod("ToFileTimeUtc", Type.EmptyTypes), null);
                        },
                        field.wdattr.BigEndian);
                }
                else if (fieldType == typeof(Guid))
                {
                    EmitBinaryWrite(
                        typeof(byte[]),
                        delegate()
                        {
                            loadFieldAddr();
                            EmitCall(OpCodes.Call, typeof(Guid).GetMethod("ToByteArray", Type.EmptyTypes), null);
                            if (field.wdattr.BigEndian)
                            {
                                EmitCall(OpCodes.Call, typeof(xonline.common.utilities2.ByteOrder).GetMethod("RevertGuidBytesInline"), null);
                            }
                        },
                        false);
                }
                else if (field.sizeOf != null)
                {
                    EmitFieldArrayLen(field);
                }
                else if (fieldType.IsEnum)
                {
                    EmitBinaryWrite(Enum.GetUnderlyingType(fieldType), loadField, field.wdattr.BigEndian);
                }
                else if (field.wdattr.SerializeAs != null && field.wdattr.SerializeAs != fieldType)
                {
                    EmitField(
                        field,
                        field.wdattr.SerializeAs,
                        delegate()
                        {
                            loadField();
                            EmitCall(OpCodes.Call, GetConversionMethod(fieldType, field.wdattr.SerializeAs), null);
                        },
                        delegate()
                        {
                            LocalBuilder ltemp = DeclareLocal(field.wdattr.SerializeAs);
                            loadField();
                            EmitCall(OpCodes.Call, GetConversionMethod(fieldType, field.wdattr.SerializeAs), null);
                            Emit(OpCodes.Stloc, ltemp);
                            Emit(OpCodes.Ldloca, ltemp);
                        });
                }
                else
                {
                    EmitBinaryWrite(fieldType, loadField, field.wdattr.BigEndian);
                }
            }

            // Emit IL to serialize a WireDataobject. The loadObject delegate is used to 
            // push the WireDataobject to be serialized on the stack.
            void EmitWireInfo(FieldContext field, Type fieldType, Action loadObject)
            {
                MethodInfo writeMethod = fieldType.GetMethod(
                    "WriteStream",
                    BindingFlags.Public | BindingFlags.ExactBinding | BindingFlags.Instance,
                    null,
                    new Type[] { typeof(BinaryWriter) },
                    null
                    );


                Label labelObjExists = DefineLabel();

                loadObject();
                Emit(OpCodes.Brtrue, labelObjExists);
                EmitThrowException("Cannot deserialize null WireData field '" + field.field.Name + "'");
                //EmitThrowValidationException(WireData.ValidationExceptionEnum.WriteNullWireDataField, field.field.Name);


                MarkLabel(labelObjExists);

                LocalBuilder ltemp = null;

                loadObject();
                if (field.wdattr.SerializeAs != null)
                {
                    ltemp = DeclareLocal(fieldType);
                    Emit(OpCodes.Stloc, ltemp);
                    Emit(OpCodes.Ldloc, ltemp);
                }
                
                EmitLoad(typeof(WireData).GetField("SchemaVersion"));
                Emit(OpCodes.Stfld, typeof(WireData).GetField("SchemaVersion"));

                if (field.wdattr.SerializeAs != null)
                {
                    Emit(OpCodes.Ldloc, ltemp);
                }
                else
                {
                    loadObject();
                }

                Emit(OpCodes.Ldarg_1);

                EmitCall(OpCodes.Callvirt, writeMethod, null);
            }

            // Emit IL to serialize a array field
            void EmitFieldArray(FieldContext field, Type fieldType, Action loadField)
            {
                Type elemType = fieldType.GetElementType();

                Label labelSkipWrite = DefineLabel();

                EmitLoad(field.field);
                Emit(OpCodes.Brfalse, labelSkipWrite);

                EmitValidateArraySize(field, elemType, loadField);

                EmitIncrementalLoop(
                    delegate(LocalBuilder i)
                    {
                        EmitField(
                            field,
                            elemType,
                            delegate()
                            {
                                // Load element of field on the stack
                                loadField();
                                Emit(OpCodes.Ldloc, i);
                                Emit(OpCodes.Ldelem, elemType);
                            },
                            delegate()
                            {
                                // Load element of field on the stack
                                loadField();
                                Emit(OpCodes.Ldloc, i);
                                Emit(OpCodes.Ldelema, elemType);
                            });
                    },
                    delegate(LocalBuilder i)
                    {
                        // Load size of array on the stack to be compared against the loop 
                        // index
                        EmitArrayLength(loadField);
                    }
                );

                if (field.wdattr.ArraySize != -1)
                {
                    if (elemType.IsSubclassOf(typeof(WireData)) ||
                        (field.wdattr.SerializeAs != null && field.wdattr.SerializeAs.IsSubclassOf(typeof(WireData))))
                    {
                        Label labelEndThrow = DefineLabel();
                        Emit(OpCodes.Br, labelEndThrow);
                        MarkLabel(labelSkipWrite);

                        EmitThrowException("Cannot serialize null wiredata field '" + field.field.Name + "'");
                        MarkLabel(labelEndThrow);
                    }
                    else
                    {
                        Label labelManualSize = DefineLabel();

                        MarkLabel(labelSkipWrite);
                        Emit(OpCodes.Ldloc_0);
                        Emit(OpCodes.Call, typeof(WireData).GetMethod("get_ManualArraySize", BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Instance));
                        Emit(OpCodes.Brtrue, labelManualSize);

                        // Emit the rest of the values if necessary
                        EmitIncrementalLoop(
                            delegate(LocalBuilder i)
                            {
                                EmitField(
                                    field,
                                    field.wdattr.SerializeAs ?? elemType,
                                    delegate()
                                    {
                                        EmitZero(field.wdattr.SerializeAs ?? elemType, false);
                                    },
                                    delegate()
                                    {
                                        EmitZero(field.wdattr.SerializeAs ?? elemType, true);
                                    });
                            },
                            delegate(LocalBuilder i)
                            {
                                Label labelNullArray = DefineLabel();
                                Label labelNullArrayEnd = DefineLabel();
                                EmitConst(field.wdattr.ArraySize);
                                loadField();
                                Emit(OpCodes.Brfalse, labelNullArray);
                                EmitArrayLength(loadField);
                                Emit(OpCodes.Br, labelNullArrayEnd);
                                MarkLabel(labelNullArray);
                                EmitZero();
                                MarkLabel(labelNullArrayEnd);
                                Emit(OpCodes.Sub);
                            }
                        );

                        MarkLabel(labelManualSize);
                    }
                }
                else
                {
                    MarkLabel(labelSkipWrite);
                }
            }

            void EmitFieldArrayLen(FieldContext field)
            {
                // If manual array size is set, just write the field directly, else write the stated values.

                Label labelElse = DefineLabel();
                Label labelEndIf = DefineLabel();

                Emit(OpCodes.Ldloc_0);
                Emit(OpCodes.Call, typeof(WireData).GetMethod("get_ManualArraySize", BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Instance));
                Emit(OpCodes.Brfalse, labelElse);

                EmitBinaryWrite(
                    field.field.FieldType,
                    LoadDelegate(field.field),
                    field.wdattr.BigEndian);

                Emit(OpCodes.Br, labelEndIf);
                MarkLabel(labelElse);
                // This is a string length parameter, emit the actual length of the array or this field if ManualArraySize is false
                // Need to emit the length of the item the field refers to at this point.

                EmitNullCheck(
                    // Loads field
                    delegate()
                    {
                        // Load the relevent object to check if the object is null
                        if (field.sizeOf.encodedBlob == null)
                        {
                            // This is a non-string array.
                            EmitLoad(field.sizeOf.field);
                        }
                        else
                        {
                            // Get the array that was loaded by the string.
                            Emit(OpCodes.Ldloc, field.sizeOf.encodedBlob);
                        }
                    },
                    // IsNotNull
                    delegate()
                    {
                        EmitBinaryWrite(
                            field.field.FieldType,
                            delegate()
                            {
                                if (field.sizeOf.wdattr.ArraySize == -1)
                                {
                                    // If the object is not null, then get the length
                                    if (field.sizeOf.encodedBlob == null)
                                    {
                                        // This is a non-string array.
                                        EmitLoad(field.sizeOf.field);
                                    }
                                    else
                                    {
                                        // Get the array that was loaded by the string.
                                        Emit(OpCodes.Ldloc, field.sizeOf.encodedBlob);
                                    }

                                    Emit(OpCodes.Ldlen);

                                    // This is to set as a default value assuming the object is null.
                                    // If the type is a string, and the NullTerminate is true, then start with
                                    // a default value of 1.
                                    if (field.sizeOf.encodedBlob != null && field.sizeOf.wdattr.NullTerminate)
                                    {
                                        EmitConst(1);

                                        // Since there actually is a length, add this to the initial
                                        // default value
                                        Emit(OpCodes.Add);
                                    }
                                }
                                else
                                {
                                    // The array will be a fixed size, so just emit that.
                                    EmitConst(field.sizeOf.wdattr.ArraySize);
                                }

                                if (field.field.FieldType != typeof(int))
                                {
                                    EmitClassConvert(typeof(int), field.field.FieldType);
                                }
                            },
                            field.wdattr.BigEndian);
                    },
                    // IsNull
                    delegate()
                    {

                        EmitBinaryWrite(
                            field.field.FieldType,
                            delegate()
                            {
                                EmitZero(field.field.FieldType);
                            },
                            false);
                    });

                MarkLabel(labelEndIf);
            }

            void EmitFieldBytes(
                FieldContext field,
                Action loadField)
            {
                Label labelSkipTask = DefineLabel();

                // Skip emit if the length of the byte array is not greater than 0
                loadField();
                Emit(OpCodes.Brfalse, labelSkipTask);

                EmitArrayLength(loadField);
                EmitZero();
                Emit(OpCodes.Ble, labelSkipTask);

                EmitValidateArraySize(field, typeof(byte), loadField);

                EmitBinaryWrite(typeof(byte[]), loadField, field.wdattr.BigEndian);

                MarkLabel(labelSkipTask);

                EmitFieldBytesEmptyElements(field, loadField);
            }

            // Emit IL to generate call to BinaryWriter.Write(*). The method used will depend 
            // on the type of the field to serialize. The loadField delegate will be used to 
            // push the field on the stack.
            void EmitBinaryWrite(
                Type dataType,
                Action loadField,
                bool byteSwap)
            {

                Emit(OpCodes.Ldarg_1); // BinaryWriter bw
                loadField();

                if (byteSwap)
                {
                    EmitCall(OpCodes.Call, typeof(xonline.common.utilities2.ByteOrder).GetMethod("Revert", new Type[] { dataType }), null);
                }

                EmitCall(
                    OpCodes.Callvirt,
                    typeof(BinaryWriter).GetMethod("Write", new Type[] { dataType }),
                    null);
            }

            // Emit IL to generate call to BinaryWriter.Write(*) for encoded strings.
            void EmitFieldString(
                FieldContext field,
                Action loadField)
            {
                EmitNullCheck(
                    loadField,
                    delegate()
                    {
                        Label labelSkipWrite = DefineLabel();

                        EmitArrayLength(loadField);
                        EmitZero();
                        Emit(OpCodes.Ble, labelSkipWrite);

                        EmitValidateArraySize(field, typeof(byte), loadField);

                        EmitBinaryWrite(typeof(byte[]), loadField, field.wdattr.BigEndian);

                        MarkLabel(labelSkipWrite);

                        if (field.wdattr.NullTerminate)
                        {
                            // Load the null terminating zero if the attributes require null termination
                            EmitBinaryWrite(
                                typeof(byte),
                                delegate()
                                {
                                    EmitZero(typeof(byte));
                                },
                                false);
                        }
                    },
                    null);

                EmitFieldBytesEmptyElements(field, loadField);
            }

            void EmitFieldBytesEmptyElements(FieldContext field, Action loadField)
            {
                // Make sure to emit rest of length if required.
                if (field.wdattr.ArraySize != -1)
                {
                    Label labelManualSize = DefineLabel();

                    Emit(OpCodes.Ldloc_0);
                    Emit(OpCodes.Call, typeof(WireData).GetMethod("get_ManualArraySize", BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Instance));
                    Emit(OpCodes.Brtrue, labelManualSize);

                    Label labelDoBody = DefineLabel();
                    loadField();
                    Emit(OpCodes.Brfalse, labelDoBody);

                    EmitArrayLength(loadField);
                    EmitConst(field.wdattr.ArraySize);
                    Emit(OpCodes.Bge, labelManualSize);

                    MarkLabel(labelDoBody);
                    Label labelNullArray = DefineLabel();
                    Label labelNullArrayEnd = DefineLabel();
                    Emit(OpCodes.Ldarg_1); // BinaryWriter bw
                    EmitConst(field.wdattr.ArraySize);
                    loadField();
                    Emit(OpCodes.Brfalse, labelNullArray);
                    EmitArrayLength(loadField);
                    Emit(OpCodes.Br, labelNullArrayEnd);
                    MarkLabel(labelNullArray);
                    EmitZero();
                    MarkLabel(labelNullArrayEnd);
                    Emit(OpCodes.Sub);
                    Emit(OpCodes.Newarr, typeof(byte));
                    EmitCall(
                        OpCodes.Callvirt,
                        typeof(BinaryWriter).GetMethod("Write", new Type[] { typeof(byte[]) }),
                        null);

                    MarkLabel(labelManualSize);
                }
            }

            void EmitValidateArraySize(FieldContext field, Type elemType, Action loadField)
            {
                if (field.wdattr.ArraySize != -1)
                {
                    Label labelSkip = DefineLabel();
                    string message;

                    Emit(OpCodes.Ldloc_0);
                    Emit(OpCodes.Call, typeof(WireData).GetMethod("get_ManualArraySize", BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Instance));
                    Emit(OpCodes.Brtrue, labelSkip);
                    EmitArrayLength(loadField);
                    EmitConst(field.wdattr.ArraySize);
                    if (elemType.IsSubclassOf(typeof(WireData)) ||
                        (field.wdattr.SerializeAs != null && field.wdattr.SerializeAs.IsSubclassOf(typeof(WireData))))
                    {
                        Emit(OpCodes.Beq, labelSkip);
                        message = "a differing number of elements to it's ArraySize [" + field.wdattr.ArraySize + "]";
                    }
                    else
                    {
                        Emit(OpCodes.Ble, labelSkip);
                        message = "too many items for it's ArraySize [" + field.wdattr.ArraySize + "]";
                    }

                    EmitThrowException(
                        delegate()
                        {
                            EmitStringConcat(
                                "Field '" + field.field.Name + "' contains [",
                                new Action(
                                    delegate
                                    {
                                        EmitArrayLength(loadField, true);
                                    }),
                                "] elements, " + message);
                        });
                    MarkLabel(labelSkip);
                }
            }
        }

        static void EmitMethodValidate(MethodBuilder validateBdr, Type type, FieldContext[] ignored)
        {
            SerializerBase wdgen = new SerializerBase(validateBdr, type);
            object[] attrs = type.GetCustomAttributes(typeof(WireInfoAttribute), false);

            if (attrs.Length == 1)
            {
                WireInfoAttribute wdattr = (WireInfoAttribute)attrs[0];
                if (wdattr.MinSchemaVersionVal > UInt32.MinValue || wdattr.MaxSchemaVersionVal < UInt32.MaxValue)
                {
                    wdgen.EmitMethodHeader(type);
                    wdgen.EmitSchemaVersionCheck(
                        wdattr,
                        delegate()
                        {
                            // If the version checks out, then return
                            wdgen.Emit(OpCodes.Ret);
                        });
                    wdgen.EmitConst(typeof(uint), unchecked((int)HResult.XONLINE_E_UNSUPPORTED_METHOD));
                    wdgen.EmitCall(OpCodes.Call, GetConversionMethod(typeof(uint), typeof(HResult)), null);
                    wdgen.EmitConst(typeof(uint), unchecked((int)XEvent.Id.COMMON_HACK_81));
                    wdgen.EmitStringConcatAllStrings(
                        "WireData Request SchemaVersion ",
                        new Action(
                            delegate()
                            {
                                wdgen.EmitLoad(typeof(WireData).GetField("SchemaVersion"));
                                wdgen.EmitCall(OpCodes.Call, typeof(WireInfoAttribute).GetMethod("VersionToString"), null);
                            }),
                        " not allowed: " + type.ToString());
                    wdgen.Emit(OpCodes.Newobj, typeof(XRLException).GetConstructor(new Type[] { typeof(HResult), typeof(XEvent.Id), typeof(string) }));
                    wdgen.Emit(OpCodes.Throw);
                }
                else
                {
                    // No schema version specific fields in the attribute, nothing to do.
                    wdgen.Emit(OpCodes.Ret);
                }
            }
            else
            {
                // if there is no attribute (since the attribute can only exist once) then there is no
                // restriction on version, and everything is valid
                wdgen.Emit(OpCodes.Ret);
            }

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\XCacheProxyProt.cs ===
/*==========================================================================
 *
 *  XCacheProxyProt.cs -- This module defines the wire protocol for cache service apis
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

using System;
using System.IO;
using System.Text;

namespace xonline.common.service
{

    public enum XCacheLookupType : uint
    {
        eXUIDLookup = 1,
        eGamertagLookup,
        ePassportLookup,
        eTeamIDLookup,
        eTeamNameLookup
    };

    public enum XCacheResponseType : uint
    {
        eUserDataResponse = 1,
        eTeamDataResponse
    };

    public class XCacheDefs
    {
        public const uint XCACHE_PROTOCOL_VERSION_CURRENT = 1;
    }

// ------------------------------------------
//      Request messages
// ------------------------------------------

    public class XCacheRequestMsg : WireData
    {
        public uint dwTotalMsgSize;

        [WireInfo(Min=XCacheDefs.XCACHE_PROTOCOL_VERSION_CURRENT, Max=XCacheDefs.XCACHE_PROTOCOL_VERSION_CURRENT)]
        public uint dwVersion = XCacheDefs.XCACHE_PROTOCOL_VERSION_CURRENT;

        public uint cdwRequests;

        [WireInfo(SizeParam="cdwRequests")]
        public XCacheLookupRequestHeader[] rgRequests;

        public override void WriteStream(BinaryWriter writer)
        {
            WriteStream(writer.BaseStream);
        }
        
        public override void WriteStream(Stream stream)
        {
            // mark the original stream position.
            long startPos = stream.Position;

            // write the object.
            base.WriteStream(new BinaryWriter(stream));

            // calculate the total size of the object.
            dwTotalMsgSize = (uint)(stream.Position - startPos);

            // grab the output stream's internal byte array.
            MemoryStream memoryStream = (MemoryStream)stream;

            // overwrite the size field.  assumes size is 4 bytes and goes at offset 0.
            System.Buffer.BlockCopy(BitConverter.GetBytes(dwTotalMsgSize), 0, memoryStream.GetBuffer(), (int)(startPos + 0), 4);
        }
    };

    public class XCacheLookupRequestHeader : WireData
    {
        public uint dwMsgSize;
        public XCacheLookupType eLookupType;
        public uint cdwLookups;

        public XCacheLookupRequestHeader()
        {
        }
        public XCacheLookupRequestHeader(XCacheLookupType eType)
        {
            eLookupType = eType;
        }

        public override void WriteStream(BinaryWriter writer)
        {
            WriteStream(writer.BaseStream);
        }
        
        public override void WriteStream(Stream stream)
        {
            // mark the original stream position.
            long startPos = stream.Position;

            // write the object.
            base.WriteStream(new BinaryWriter(stream));

            // calculate the total size of the object.
            dwMsgSize = (uint)(stream.Position - startPos);

            // grab the output stream's internal byte array.
            MemoryStream memoryStream = (MemoryStream)stream;

            // overwrite the size field.  assumes size is 4 bytes and goes at offset 0.
            System.Buffer.BlockCopy(BitConverter.GetBytes(dwMsgSize), 0, memoryStream.GetBuffer(), (int)(startPos + 0), 4);
        }

        public override WireData ReadStream(BinaryReader reader)
        {
            return ReadStream(reader.BaseStream);
        }

        public override WireData ReadStream(Stream stream)
        {
            // mark the original stream position.
            long startPos = stream.Position;

            base.ReadStream(new BinaryReader(stream));

            XCacheLookupRequestHeader derived = null;
            
            switch (eLookupType)
            {
            case XCacheLookupType.eXUIDLookup:
                derived = new XCacheXUIDLookupRequest();
                break;
            case XCacheLookupType.eGamertagLookup:
                derived = new XCacheGamertagLookupRequest();
                break;
            case XCacheLookupType.ePassportLookup:
                derived = new XCachePassportLookupRequest();
                break;
            case XCacheLookupType.eTeamIDLookup:
                derived = new XCacheTeamIDLookupRequest();
                break;
            case XCacheLookupType.eTeamNameLookup:
                derived = new XCacheTeamNameLookupRequest();
                break;
            default:
                throw new ApplicationException("XCacheLookupRequestHeader::ReadStream() unknown request type!");
            }

            stream.Position = startPos;
            return derived.ReadStreamInternal(stream);
        }

        public virtual WireData ReadStreamInternal(Stream stream)
        {
            return base.ReadStream(new BinaryReader(stream));
        }
    }

    public class XCacheXUIDLookupRequest : XCacheLookupRequestHeader
    {        
        [WireInfo(SizeParam="cdwLookups")]
        public ulong[] rgqwXUIDs;

        public XCacheXUIDLookupRequest() : base(XCacheLookupType.eXUIDLookup)
        {
        }
    }

    public class XCacheGamertag : WireData
    {
        [WireInfo(ArraySize=(int)XOn.XONLINE_GAMERTAG_SIZE)]
        public string sGamertag;

        public XCacheGamertag()
        {
        }
        
        public XCacheGamertag(string gamertag)
        {
            sGamertag = gamertag;
        }
        
        public static implicit operator XCacheGamertag(string gamertag)
        {
            return  new XCacheGamertag(gamertag);
        }

        public static implicit operator string(XCacheGamertag xcgt)
        {
            return xcgt.sGamertag;
        }
    }

    public class XCacheGamertagLookupRequest : XCacheLookupRequestHeader
    {
        [WireInfo(Serialize=false)]
        public string[] rgszGamertags;

        [WireInfo(SizeParam="cdwLookups")]
        public XCacheGamertag[] rgXCGTs;

        public XCacheGamertagLookupRequest() : base(XCacheLookupType.eGamertagLookup)
        {
        }

        public override void WriteStream(BinaryWriter writer)
        {
            if (rgszGamertags != null)
            {
                rgXCGTs = Array.ConvertAll(rgszGamertags, delegate(string s) { return (XCacheGamertag)s; });
            }

            base.WriteStream(writer);
        }

        public override WireData ReadStreamInternal(Stream stream)
        {
            base.ReadStreamInternal(stream);

            rgszGamertags = Array.ConvertAll(rgXCGTs, delegate(XCacheGamertag xcgt) { return (string)xcgt; });

            return this;
        }
    }

    public class XCachePassportLookupRequest : XCacheLookupRequestHeader
    {        
        [WireInfo(SizeParam="cdwLookups")]
        public ulong[] rgqwPassportPUIDs;

        public XCachePassportLookupRequest() : base(XCacheLookupType.ePassportLookup)
        {
        }
    }

    public class XCacheTeamNameLookupKey : WireData
    {
        [WireInfo(ArraySize=(int)XOn.MAX_TEAM_NAME_SIZE)]
        public string wszTeamName;
        public uint dwTitleID;

        public XCacheTeamNameLookupKey()
        {
        }
    }

    public class XCacheTeamIDLookupKey : WireData
    {
        public ulong qwTeamID;
        public uint dwTitleID;

        public XCacheTeamIDLookupKey()
        {
        }
    }

    public class XCacheTeamIDLookupRequest : XCacheLookupRequestHeader
    {        
        [WireInfo(SizeParam="cdwLookups")]
        public XCacheTeamIDLookupKey[] rgTeams;

        public XCacheTeamIDLookupRequest() : base(XCacheLookupType.eTeamIDLookup)
        {
        }
    }

    public class XCacheTeamNameLookupRequest : XCacheLookupRequestHeader
    {       
        [WireInfo(SizeParam="cdwLookups")]
        public XCacheTeamNameLookupKey[] rgTeams;

        public XCacheTeamNameLookupRequest() : base(XCacheLookupType.eTeamNameLookup)
        {
        }
    }

// ------------------------------------------
//  Response messages
// ------------------------------------------

    public class XCacheResponseMsg : WireData
    {
        public uint dwTotalMsgSize;

        [WireInfo(Min=XCacheDefs.XCACHE_PROTOCOL_VERSION_CURRENT, Max=XCacheDefs.XCACHE_PROTOCOL_VERSION_CURRENT)]
        public uint dwVersion = XCacheDefs.XCACHE_PROTOCOL_VERSION_CURRENT;

        public uint cdwResponses;

        [WireInfo(SizeParam="cdwResponses")]
        public XCacheLookupResponseHeader[] rgResponses;

        public override void WriteStream(BinaryWriter writer)
        {
            WriteStream(writer.BaseStream);
        }
        
        public override void WriteStream(Stream stream)
        {
            // mark the original stream position.
            long startPos = stream.Position;

            // write the object.
            base.WriteStream(new BinaryWriter(stream));

            // calculate the total size of the object.
            dwTotalMsgSize = (uint)(stream.Position - startPos);

            // grab the output stream's internal byte array.
            MemoryStream memoryStream = (MemoryStream)stream;

            // overwrite the size field.  assumes size is 4 bytes and goes at offset 0.
            System.Buffer.BlockCopy(BitConverter.GetBytes(dwTotalMsgSize), 0, memoryStream.GetBuffer(), (int)(startPos + 0), 4);
        }
    }

    public class XCacheLookupResponseHeader : WireData
    {
        public uint dwMsgSize;
        public XCacheResponseType eResponseType;
        public uint cdwResponses;

        public XCacheLookupResponseHeader()
        {
        }
        public XCacheLookupResponseHeader(XCacheResponseType eType)
        {
            eResponseType = eType;
        }

        public override void WriteStream(BinaryWriter writer)
        {
            WriteStream(writer.BaseStream);
        }
        
        public override void WriteStream(Stream stream)
        {
            // mark the original stream position.
            long startPos = stream.Position;

            // write the object.
            base.WriteStream(new BinaryWriter(stream));

            // calculate the total size of the object.
            dwMsgSize = (uint)(stream.Position - startPos);

            // grab the output stream's internal byte array.
            MemoryStream memoryStream = (MemoryStream)stream;

            // overwrite the size field.  assumes size is 4 bytes and goes at offset 0.
            System.Buffer.BlockCopy(BitConverter.GetBytes(dwMsgSize), 0, memoryStream.GetBuffer(), (int)(startPos + 0), 4);
        }

        public override WireData ReadStream(BinaryReader reader)
        {
            return ReadStream(reader.BaseStream);
        }

        public override WireData ReadStream(Stream stream)
        {
            // mark the original stream position.
            long startPos = stream.Position;

            base.ReadStream(new BinaryReader(stream));

            XCacheLookupResponseHeader derived = null;
            
            switch (eResponseType)
            {
            case XCacheResponseType.eUserDataResponse:
                derived = new XCacheUserLookupResponse();
                break;
            case XCacheResponseType.eTeamDataResponse:
                derived = new XCacheTeamLookupResponse();
                break;
            default:
                throw new ApplicationException("XCacheLookupResponseHeader::ReadStream() unknown response type!");
            }

            stream.Position = startPos;
            return derived.ReadStreamInternal(stream);
        }

        public WireData ReadStreamInternal(Stream stream)
        {
            return base.ReadStream(new BinaryReader(stream));
        }
    }

    public class XCacheUserLookupResponse : XCacheLookupResponseHeader
    {       
        [WireInfo(SizeParam="cdwResponses")]
        public XCacheUserResponseData[] rgUsers;

        public XCacheUserLookupResponse() : base(XCacheResponseType.eUserDataResponse)
        {
        }
    }

    public class XCacheTeamLookupResponse : XCacheLookupResponseHeader
    {       
        [WireInfo(SizeParam="cdwResponses")]
        public XCacheTeamResponseData[] rgTeams;

        public XCacheTeamLookupResponse() : base(XCacheResponseType.eTeamDataResponse)
        {
        }
    }

    public class XCacheUserResponseData : WireData
    {
        public ulong qwUserID;

        [WireInfo(ArraySize=(int)XOn.XONLINE_GAMERTAG_SIZE)]
        public string szGamertag;

        public ulong qwPassportPUID;
    }

    public class XCacheTeamResponseData : WireData
    {
        public ulong qwTeamID;

        [WireInfo(ArraySize=(int)XOn.MAX_TEAM_NAME_SIZE)]
        public string wszTeamName;

        public uint dwTitleID;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\XboxLiveThread.cs ===
using System;
using System.Threading;
using System.Runtime.InteropServices;
using System.Globalization;

using xonline.common.mgmt;

namespace xonline.common.service 
{
   [ComVisible(false)]
   public sealed class XboxLiveThread {
      public XboxLiveThread(ParameterizedThreadStart start) {
         if (null == start)
            throw new ArgumentNullException("start");

         innerThread = new Thread(
            new ParameterizedThreadStart(delegate(object obj) { ThreadWrapper(start, obj); })
         );
      }

      public XboxLiveThread(ThreadStart start) {
         if (null == start)
            throw new ArgumentNullException("start");

         innerThread = new Thread(
            new ThreadStart(delegate { ThreadWrapper(start); })
         );
      }
      
      public XboxLiveThread(ParameterizedThreadStart start, int maxStackSize) {
         if (null == start)
            throw new ArgumentNullException("start");

         innerThread = new Thread(
            new ParameterizedThreadStart(delegate(object obj) { ThreadWrapper(start, obj); }), 
            maxStackSize);
      }

      public XboxLiveThread(ThreadStart start, int maxStackSize) {
         if (null == start)
            throw new ArgumentNullException("start");

         innerThread = new Thread(
            new ThreadStart(delegate { ThreadWrapper(start); }), 
            maxStackSize);
      }

      #region Arbitrated Thread Instance Members
      public void Abort() {
         InnerThread.Abort();
      }

      public void Abort(object stateInfo) {
         InnerThread.Abort(stateInfo);
      }

      public ApartmentState GetApartmentState() {
         return InnerThread.GetApartmentState();
      }

      [ObsoleteAttribute("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")]
      public CompressedStack GetCompressedStack() {
         return InnerThread.GetCompressedStack();
      }

      public void Interrupt() {
         InnerThread.Interrupt();
      }

      public void Join() {
         InnerThread.Join();
      }

      public bool Join(int millisecondsTimeout) {
         return InnerThread.Join(millisecondsTimeout);
      }

      public bool Join(TimeSpan timeout) {
         return InnerThread.Join(timeout);
      }

      [ObsoleteAttribute("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)]
      public void Resume() {
         InnerThread.Resume();
      }

      public void SetApartmentState(ApartmentState state) {
         InnerThread.SetApartmentState(state);
      }

      [ObsoleteAttribute("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")]
      public void SetCompressedStack(CompressedStack stack) {
         InnerThread.SetCompressedStack(stack);
      }

      public void Start() {
         InnerThread.Start();
      }

      public void Start(Object parameter) {
         InnerThread.Start(parameter);
      }

      [ObsoleteAttribute("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)]
      public void Suspend() {
         InnerThread.Suspend();
      }

      public bool TrySetApartmentState(ApartmentState state) {
         return InnerThread.TrySetApartmentState(state);
      }

      [ObsoleteAttribute("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", false)]
      public ApartmentState ApartmentState {
         get { return InnerThread.ApartmentState; }
         set { InnerThread.ApartmentState = value; }
      }

      public CultureInfo CurrentCulture {
         get { return InnerThread.CurrentCulture; }
         set { InnerThread.CurrentCulture = value; }
      }

      public CultureInfo CurrentUICulture {
         get { return InnerThread.CurrentUICulture; }
         set { InnerThread.CurrentUICulture = value; }
      }

      public ExecutionContext ExecutionContext {
         get { return InnerThread.ExecutionContext; }
      }

      public bool IsAlive {
         get { return InnerThread.IsAlive; }
      }

      public bool IsBackground {
         get { return InnerThread.IsBackground; }
         set { InnerThread.IsBackground = value; }
      }

      public bool IsThreadPoolThread {
         get { return InnerThread.IsThreadPoolThread; }
      }

      public int ManagedThreadId {
         get { return InnerThread.ManagedThreadId; }
      }

      public string Name {
         get { return InnerThread.Name; }
         set { InnerThread.Name = value; }
      }

      public ThreadPriority Priority {
         get { return InnerThread.Priority; }
         set { InnerThread.Priority = value; }
      }

      public ThreadState ThreadState {
         get { return InnerThread.ThreadState; }
      }
      #endregion

      #region Private Wrapper Members
      private void HandleException(Exception e) {
         try {
            Xom.NtEvent(XEvent.Id.UNHANDLED_THREAD_EXCEPTION, e,
               "XboxLiveThread - unhandled exception"
            );
         }
         catch (Exception) { /* crap */ }
      }

      private void ThreadWrapper(ThreadStart start) {
         try {
            start();
         }
         catch (ThreadAbortException) { throw; }
         catch (Exception e) {
            HandleException(threadException = e);
         }
      }

      private void ThreadWrapper(ParameterizedThreadStart start, object obj) {
         try {
            start(obj);
         }
         catch (ThreadAbortException) { throw; }
         catch (Exception e) {
            HandleException(threadException = e);
         }
      }
      #endregion

      public Thread InnerThread {
         get { return innerThread; }
      }

      public Exception ThreadException {
         get { return threadException; }
         set { threadException = value; }
      }

      private Thread innerThread;
      private Exception threadException;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\xdelay.cs ===
/******************************************************************************
  
  Copyright (c) 2003 Microsoft Corporation
  
  xdelay.cs
  
  Server side support for client throttling. Provides a common way for services
  to add the X-Delay http header to their responses.
  
  
******************************************************************************/ 

using System;
using System.Collections;
using System.Collections.Specialized;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading;
using System.Web;
using System.Xml.XPath;

using xonline.common.config;
using xonline.common.mgmt;


namespace xonline.common.service 
{
    // XDelay
    // Provides a common way for server applications to support client 
    // throttling though the X-Delay header.
    [ComVisible(false)]
    public class XDelay
    {
        
        static XDelay()
        {
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(XDelay.OnControlRequest);
            Config.XdelaySettingsChange += new XdelaySettingsChangeEventHandler(XDelay.OnXdelaySettingsChange);
        }
        
        // AddDelayHeader
        // Add X-Delay header to the application's response. 
        //
        // Normally, this will automatically be called by XRLUtil.SetXRLResponse(), using
        // the current page name as the setting.
        //
        // Call this directly (*after*, or in leiu of, calling SetXRLResponse()) iif you 
        // want to set the delay to some custom setting.  
        //
        static public void AddDelayHeader(HttpResponse resp, uint uiTitleId, string reqType)
        {
            RequestParameters reqparam = null;
            bool usingDefaultParameters = false;
            
            if (_parameters == null)
            {
                lock(typeof(XDelay))
                {
                    if(_parameters == null)
                    {
                        LoadConfiguration();
                    }
                }
            }
            
            if (_parameters != null)        
            {        
                // Look for title specific configuration        
                reqparam = (RequestParameters) _parameters[new TitleIdRequestKey(uiTitleId, reqType)];        
                    
                if (reqparam == null)
                {        
                    // Try default configuration
                    reqparam = (RequestParameters) _parameters[new TitleIdRequestKey(0, reqType)];        
                    usingDefaultParameters = true;
                }        

                if(reqparam != null)
                {
                    if(reqparam.delay != 0)
                    {
                        if(!usingDefaultParameters ||     // Bug 34183 - don't use default delay on xbox 1
                           !SGInfo.IsXbox())
                        {
                            // Add Header        
                            resp.AppendHeader("X-Delay", reqparam.delay.ToString());       
                        }
                    }
                    
                    if(reqparam.sleep != 0 &&           // Bug 41972 - only sleep for xbox 1
                       SGInfo.IsXbox())
                    {
                        Thread.Sleep(reqparam.sleep);
                    }
                }
            }   
        }
        
        // LoadConfiguration
        // Loads or reloads configuration.
        static public void LoadConfiguration()
        {
            try
            {
                _parameters = LoadConfigurationFromNpdb();
            }
            catch(Exception e)
            {
                throw new ExceptionWithEventId(XEvent.Id.COMMON_CONFIG_276,
                    "Failed to process Xdelay settings", e);
            }
        }

        protected static Hashtable LoadConfigurationFromNpdb() 
        {
            SqlConnection sql       = null;
            SqlDataReader reader    = null;
            Hashtable parameters    = new Hashtable();
            StringCollection pages  = GetPageList();
            
            try
            {
                sql = new SqlConnection(Config.NpdbConnectionString);
                sql.Open();
    
                SqlCommand cmd = new SqlCommand("dbo.p_xdelay_get_settings", sql);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_component", SqlDbType.NVarChar).Value = Config.ComponentName;
                reader = cmd.ExecuteReader();
                
                while(reader.Read())
                {
                    UInt32 titleId   = (UInt32) reader.GetInt32(0);
                    string request   = reader.GetString(1).ToLower();
                    
                    RequestParameters reqparam = new RequestParameters();
                    reqparam.delay = reader.GetInt32(2);
                    reqparam.sleep = reader.GetInt32(3);
                    
                    if (!pages.Contains(request))
                    {
                      Xom.NtEvent(XEvent.Id.COMMON_CONFIG_277, "Throttle setting " + request + " does not have a matching URL in web.config!");    
                    }    
                    
                    parameters[new TitleIdRequestKey(titleId, request)] = reqparam;
                }
                
                return parameters;
            }
            finally
            {
                if(reader != null)
                    reader.Close();
                    
                if(sql != null)
                    sql.Close();
            }
        }

        public static StringCollection GetPageList()
        {
            StringCollection pages = new StringCollection();
            XPathDocument doc = new XPathDocument(Path.GetDirectoryName( AppDomain.CurrentDomain.BaseDirectory ) + "\\web.config");
            
            XPathNavigator root = doc.CreateNavigator();
            XPathNodeIterator iter = root.Select("/configuration/system.webServer/handlers/add");
            
            while (iter.MoveNext())
            {
                pages.Add(Path.GetFileNameWithoutExtension(iter.Current.GetAttribute("path", "")).ToLower());
            }
            
            return pages;
            
        }
        
        static volatile protected Hashtable _parameters = null;
        // static public string _configFile = Path.GetDirectoryName( AppDomain.CurrentDomain.BaseDirectory ) + "\\throttling.ini";        

        
        // Common config will notify us when settings change in the database giving
        // us an opportunity to 
        public static void OnXdelaySettingsChange(object sender, EventArgs args)
        {
            LoadConfiguration();  
        }
        
        //
        // Control stuff
        //
    
        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                switch (args.Command)
                {
                case "help":
                    XomControlConnection.SendMessage("Throttling help:\r\n" +
                                " ReloadThrottleConfig (rtc) -- Reloads the throttling config settings.\r\n" +
                                " SetXDelay HexTitleID RequestName DelayInMS -- Manually sets XDelay for titleID/request pair.\r\n" +
                                "   Operations should always modify throttling.ini and use ReloadThrottleConfig.\r\n" +
                                "   SetXDelay is for test team usage only.\r\n",
                                args.RequestId);
                    
                    args.Handled = true;
                    break;
                    
                case "reloadthrottleconfig":
                case "rtc":
                    XomControlConnection.SendMessage(ProcessReloadConfig(args), args.RequestId);
                    args.Handled = true;
                    break;

                case "setxdelay":
                    XomControlConnection.SendMessage(ManuallySetXDelay(args), args.RequestId);
                    args.Handled = true;
                    break;
                }
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }

        public static string ProcessReloadConfig(ControlRequestEventArgs args)
        {
            try
            {
                LoadConfiguration();
                return "Throttling configuration reloaded.";
            }
            catch (Exception e)
            {
                return "Error reloading configuration!\r\n" + e.ToString();
            }    
                
        }
        
        public static string ManuallySetXDelay(ControlRequestEventArgs args)
        {
            try
            {
                if ( args.CommandArgs.Length < 3 )
                {
                    throw new Exception("Usage: SetXDelay HexTitleID RequestName DelayInMS [SleepInMS]");
                }
                
                StringCollection pages = GetPageList();
                    
                uint uiTitleId = 0;
                    
                uiTitleId = Convert.ToUInt32(args.CommandArgs[0], 16);

                string requestName = args.CommandArgs[1].ToLower();
                if (!pages.Contains(requestName))
                {
                    throw new Exception(requestName + " is not a valid URL prefix");
                }    
                
                // find the RequestParameters object for the titleid, 
                // requestName key pair so we can update it. If there is no 
                // such object, create a new one.
                
                TitleIdRequestKey key      = new TitleIdRequestKey(uiTitleId, requestName);
                RequestParameters reqparam  = (RequestParameters) _parameters[key];
                if(reqparam == null)
                {
                    reqparam = new RequestParameters();
                    _parameters[key] = reqparam;
                }

                // update delay
                int iDelay = Convert.ToInt32(args.CommandArgs[2]);
                
                if(iDelay < 0 || iDelay > 20000)
                {
                    throw new Exception("Invalid delay: " + iDelay);
                }

                reqparam.delay = iDelay;

                // update sleep
                if(args.CommandArgs.Length >= 4)
                {
                    int sleep = Convert.ToInt32(args.CommandArgs[3]);

                    if(sleep < 0 || sleep > 20000)
                    {
                        throw new Exception("Invalid sleep: " + sleep);
                    }

                    reqparam.sleep = sleep;
                }
                
                return string.Format("Manually Set XDelay for titleID {0} request {1} to delay {2}, sleep {3}",
                                     uiTitleId.ToString("X"), requestName, reqparam.delay.ToString(), reqparam.sleep.ToString());
            }
            catch (Exception e)
            {
                args.hr = HResult.E_FAIL;
                return "Error Manually Setting XDelay: " + e.ToString();
            }
        }
    
        
        // TitleIdRequestKey
        // Hashtable key made of uiTitleId + requestType
        protected struct TitleIdRequestKey
        {
            public TitleIdRequestKey(uint uiTitleId, string requestType)
            {
                _uiTitleId = uiTitleId;
                _iRequestType = requestType.ToLower().GetHashCode();
            }
            
            public override int GetHashCode() 
            {
                return ((int)_uiTitleId) + ((int)_iRequestType);
            }
    
            public override bool Equals(object obj)
            {
                TitleIdRequestKey otherObj = (TitleIdRequestKey) obj;
                return (otherObj._uiTitleId == _uiTitleId) &&
                    (otherObj._iRequestType == _iRequestType);
            }
            
            public uint     _uiTitleId;
            public int      _iRequestType;
        }

        // RequestParameters
        // Parameters for the request
        protected class RequestParameters
        {
            public int delay = 0;       // delay in milliseconds. Only one request can be made every delay period. the client is required to wait/delay the next request if the required time hasn't passed by.
            public int sleep = 0;       // sleep in milliseconds. The server will sleep for this period of time before returning the response to the request to the client. this only applies to xbox 1 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\XRLException.cs ===
using System;
using System.Runtime.InteropServices;
using System.Text;

namespace xonline.common.service
{
    public interface ExceptionWithHResult {
        HResult HResult { get; set; }
    }

    public interface ExceptionWithoutEvent {
    }

    public interface ExceptionWithEvent {
        XEvent.Id EventId { get; set; }
    }
    
    /// <summary>
    /// This interface identifies retryable errors
    /// </summary>
    public interface IRetryableException
    {
        bool IsRetryable
        {
            get;
        }
    }


    [ComVisible(false)]
    public class XRLExceptionWithoutEvent : Exception, ExceptionWithHResult, ExceptionWithoutEvent,IRetryableException {

       bool _retryable=false;
       
        public XRLExceptionWithoutEvent(HResult hr, Exception innerException, string format, params object[] args)
            : base(String.Format(format, args), innerException)
        {
            HResult = hr;
        }

        public XRLExceptionWithoutEvent(HResult hr, string format, params object[] args)
            : base(String.Format(format, args))
        {
            HResult = hr;
        }
         public XRLExceptionWithoutEvent(HResult hr, Exception innerException, string format, bool isRetryable,params object[] args)
            : base(String.Format(format, args), innerException)
        {
            HResult = hr;
            _retryable=isRetryable;
        }

        public XRLExceptionWithoutEvent(HResult hr, string format, bool isRetryable,params object[] args)
            : base(String.Format(format, args))
        {
            HResult = hr;
            _retryable=isRetryable;
        }

        new public HResult HResult
        {
            get { return (HResult) ((uint) base.HResult); }
            set { base.HResult = (int) ((uint) value); }
        }
        
       public bool IsRetryable
        {
            get {return _retryable;}
            
        }
    }

    [ComVisible(false)]
    public class ExceptionWithEventId : Exception, ExceptionWithEvent,IRetryableException
    {
        XEvent.Id _EventId = XEvent.Id.MC_APPLICATION_ERROR_1;
        
		bool _retryable=false;
        
        public ExceptionWithEventId(XEvent.Id EventId, string message) : base(message)
        {
            _EventId = EventId;
        }


        public ExceptionWithEventId(XEvent.Id EventId, string message, Exception innerException) : base(message, innerException)
        {
            _EventId = EventId;
        }
        
        public ExceptionWithEventId(XEvent.Id EventId, string message, bool isRetryable) : base(message)
        {
            _EventId = EventId;
            _retryable=isRetryable;
        }

        public ExceptionWithEventId(XEvent.Id EventId, string message,bool isRetryable, Exception innerException) : base(message, innerException)
        {
            _EventId = EventId;
            _retryable=isRetryable;
        }

        public XEvent.Id EventId
        {
            get { return _EventId; }
            set { _EventId = value; }
        }

		public bool IsRetryable
        {
            get {return _retryable;}
            
        }
        
        public void AppendInfo(string str)
        {
            _info.Append(str + "\n");
        }

        public override string ToString()
        {
            return base.ToString() + "\nInfo:\n" + _info;
        }

        protected StringBuilder _info = new StringBuilder();
    }

    [ComVisible(false)]
    public class XRLException : ExceptionWithEventId, ExceptionWithHResult,IRetryableException
    {
        
        public XRLException(HResult hr, XEvent.Id EventId, string message) : base(EventId, message)
        {
            HResult = hr;
        }

        public XRLException(HResult hr, XEvent.Id EventId, string message, Exception innerException) : base(EventId, message, innerException)
        {
            HResult = hr;
        }


        public XRLException(HResult hr, XEvent.Id EventId, string format, params object[] args)
            : this(hr, EventId, String.Format(format, args))
        {
        }

        public XRLException(HResult hr, XEvent.Id EventId, Exception innerException, string format, params object[] args)
            : this(hr, EventId, String.Format(format, args), innerException)
        {
        }

		public XRLException(HResult hr, XEvent.Id EventId,bool isRetryable,string message) : base(EventId,message,isRetryable)
        {
            HResult = hr;
        }

        public XRLException(HResult hr, XEvent.Id EventId, string message,bool isRetryable,Exception innerException) : base(EventId, message, isRetryable,innerException)
        {
            HResult = hr;
        }

        public XRLException(HResult hr, XEvent.Id EventId, string format,bool isRetryable, params object[] args)
            : this(hr, EventId, String.Format(format, isRetryable,args))
        {
        }

        public XRLException(HResult hr, XEvent.Id EventId, Exception innerException, string format,bool isRetryable, params object[] args)
            : this(hr, EventId, String.Format(format, args), isRetryable,innerException)
        {

        }

        new public HResult HResult
        {
            get { return (HResult)((uint) base.HResult); }
            set { base.HResult = (int)((uint) value); }
        }

        public static HResult ToHResult(Exception e, HResult hr)
        {
            if (e is ExceptionWithHResult)
            {
                hr = ((ExceptionWithHResult) e).HResult;
            }

            return hr;
        }

        public static HResult DeepToHResult(Exception e, HResult hr)
        {
            if (e is ExceptionWithHResult)
            {
                hr = ((ExceptionWithHResult)e).HResult;
            }
            else
            {
                HResult rawHr = (uint)Marshal.GetHRForException(e);
                if (rawHr.IsFailure())
                {
                    hr = rawHr;
                }
            }

            return hr;
        }

        public static XEvent.Id ToEventId(Exception e, XEvent.Id id)
        {
            if (e is ExceptionWithEventId)
            {
                id = ((ExceptionWithEventId)e).EventId;
            }
            return id;
        }
    }

    //Here is an exception that we would only use to communicate a peek char returning no value
    //This exception ususally would be caught and ignored
    public class PeekCharEndOfStreamException : Exception
    {
        public PeekCharEndOfStreamException() : base()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\xrlobject2.cs ===
using System;
using System.Web;
using System.IO;
using System.Text;
using System.Runtime.InteropServices;
using System.Collections.Specialized;
using System.Diagnostics;

using xonline.common.mgmt;

namespace xonline.common.service
{
    [ComVisible(false)]
    public class XRLObject2 : WireData
    {
        public virtual string ContentType
        {
            get { return null; }
        }

        //-----------------------------------------------------
        // ReadFromRequest
        //
        public virtual void ReadFromRequest(HttpRequest req)
        {
            Type t = this.GetType();

            BinaryReader reader = new BinaryReader(req.InputStream);

            Debug.Assert(req.ContentEncoding is UTF8Encoding, "Unexpected encoding type!");

            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "XRLObject2.ReadFromRequest: Reading " + t.ToString() + " from post buffer..." );

            // Allow the base WireData class to read
            ReadStream(reader);

            // failures here can be ignored, this is just for logging purposes
            try
            {
                if (HttpContext.Current != null && HttpContext.Current.Items["XRLRequest"] == null)
                {
                    HttpContext.Current.Items["XRLRequest"] = this;
                }
            }
            catch (Exception e)
            {
                Xom.Trace(XomAreaName.xrltrace, LogLevel.L_WARNING, "Error setting HttpContext.Current.Items[\"XRLRequest\"]: " + e.ToString());
            }
        }

        public virtual void ReadFromRequest(BinaryReader reader, UTF8Encoding enc, long len, NameValueCollection queryString)
        {
            Type t = this.GetType();

            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "XRLObject2.ReadFromRequest: Reading " + t.ToString() + " from post buffer..." );

            // QueryString reading no longer supported
            if (len == 0 && queryString != null && queryString.Count != 0)
            {
                throw new Exception("XRLObject.ReadFromRequest: Post buffer empty!Read from QueryString no longer supported by XRLObject2");
            }

            // Allow the base WireData class to read
            ReadStream(reader);
        }

        //-----------------------------------------------------
        // WriteToResponse
        //
        //      this overrideable implementation uses reflection
        //      to find any instance fields, and writes
        //      most common types to the response stream in the
        //      order of declaration.
        //
        //      - strings are sent in UTF8.
        //      - DateTime is sent as a SYSTEMTIME struct as
        //      defined by windows.h(?)
        //
        public virtual void WriteToResponse(HttpResponse resp)
        {
            BinaryWriter writer = new BinaryWriter(resp.OutputStream);
            Debug.Assert(resp.ContentEncoding is UTF8Encoding, "Unexpected encoding type!");
            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "XRLObject.WriteToResponse: Writing " + GetType().ToString() + " to response...");
            WriteStream(writer);
        }


        public void WriteToResponse(BinaryWriter writer, UTF8Encoding enc)
        {
            // Allow the base WireData class to write
            Xom.Trace(XomAreaName.xrltrace, LogLevel.L_LOW, "XRLObject.WriteToResponse: Writing " + GetType().ToString() + " to response...");
            WriteStream(writer);
        }

        public virtual string Xrl
        {
            get
            {
                return String.Empty;
            }
        }

        public string GetXRL()
        {
            return Xrl;
        }

        public virtual byte[] GetBytes()
        {
            return (byte[])this;
        }

        public virtual void SetBytes(byte[] buf)
        {
            ReadBytes(buf);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\XonBdkHResult.cs ===
//
// XonBdkErrorAutoGen.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// This is an auto-generated file. Please don't modify directly.
//
// This file defines constants for all of the BDK errors returned by SCS APIs and
// indicates whether the error is retryable and includes the supplied description.
//
// It is generated from the BdkError.xml file contained in public\ext\xonline-ext\SCS\$(SCS_SDK)\inc.
//

using System;

namespace xonline.common.service
{

    public partial struct HResult
    {
        // Null input parameter passed to a "ban" API.
        public const uint XONLINE_E_BILLING_BAN_NULL_INPUT_PARAMETER = 0x80167594;

        // Already banned.
        public const uint XONLINE_E_BILLING_ALREADY_BANNED = 0x80167599;

        // Not banned.
        public const uint XONLINE_E_BILLING_NOT_BANNED = 0x8016759E;

        // This account is banned.
        public const uint XONLINE_E_BILLING_BANNEDPERSON = 0x801675BC;

        // Country/currency/payment instrument type mismatch.
        public const uint XONLINE_E_BILLING_COUNTRY_CURRENCY_PI_MISMATCH = 0x801675C1;

        // Invalid payment instrument type.
        public const uint XONLINE_E_BILLING_INVALID_PAYMENT_INSTRUMENT_TYPE = 0x801675C8;

        // Invalid credit card type.
        public const uint XONLINE_E_BILLING_INVALID_CREDIT_CARD_TYPE = 0x801675CB;

        // Decryption failed. Verify that data is encrypted correctly.
        public const uint XONLINE_E_BILLING_DECRYPTION_FAILURE = 0x801675D0;

        // Payment instrument is banned.
        public const uint XONLINE_E_BILLING_BANNED_PAYMENT_INSTRUMENT = 0x801675C6;

        // Direct debit account validation failed.
        public const uint XONLINE_E_BILLING_INVALID_DD_ACCOUNT = 0x801675E4;

        // Concatenated direct debit account number exceeds 24 characters.
        public const uint XONLINE_E_BILLING_DD_CONCATENATED_STRING_LENGTH_EXCEEDS_24 = 0x801675E9;

        // Invalid credit card number.
        public const uint XONLINE_E_BILLING_INVALID_CREDIT_CARD_NUMBER = 0x80167530;

        // Credit card has already expired.
        public const uint XONLINE_E_BILLING_CREDIT_CARD_EXPIRED = 0x80167531;

        // Address verification failed.
        public const uint XONLINE_E_BILLING_AVS_FAILED = 0x8016760C;

        // Address verification through AVS did not provide a result.
        public const uint XONLINE_E_BILLING_NO_AVS_RESULT = 0x8016760D;

        // Payment Instrument authorization failed.
        public const uint XONLINE_E_BILLING_AUTHORIZATION_FAILED = 0x80167611;

        // Unable to connect to payment provider.
        public const uint XONLINE_E_BILLING_PAYMENT_PROVIDER_CONNECTION_FAILED = 0x8016761B;

        // Invalid country code.
        public const uint XONLINE_E_BILLING_DD_INVALID_COUNTRY = 0x8016762F;

        // Invalid account format.
        public const uint XONLINE_E_BILLING_DD_INVALID_ACCOUNT_FORMAT = 0x80167634;

        // Invalid bank code format.
        public const uint XONLINE_E_BILLING_DD_INVALID_BANKCODE_FORMAT = 0x80167639;

        // Invalid branch code format.
        public const uint XONLINE_E_BILLING_DD_INVALID_BRANCHCODE_FORMAT = 0x8016763E;

        // Invalid check digit format.
        public const uint XONLINE_E_BILLING_DD_INVALID_CHECKDIGIT_FORMAT = 0x80167643;

        // Account missing.
        public const uint XONLINE_E_BILLING_DD_ACCOUNT_MISSING = 0x80167648;

        // Bank code missing.
        public const uint XONLINE_E_BILLING_DD_BANKCODE_MISSING = 0x8016764D;

        // Branch code missing.
        public const uint XONLINE_E_BILLING_DD_BRANCHCODE_MISSING = 0x80167652;

        // Check digit missing.
        public const uint XONLINE_E_BILLING_DD_CHECKDIGIT_MISSING = 0x80167657;

        // Some fields have errors.
        public const uint XONLINE_E_BILLING_DD_ERROR_IN_FIELDS = 0x8016765C;

        // Invalid account code.
        public const uint XONLINE_E_BILLING_DD_INVALID_ACCOUNT_VALUE = 0x80167661;

        // Invalid bank code.
        public const uint XONLINE_E_BILLING_DD_INVALID_BANKCODE_VALUE = 0x80167666;

        // Invalid branch code.
        public const uint XONLINE_E_BILLING_DD_INVALID_BRANCHCODE_VALUE = 0x8016766B;

        // Invalid check digit.
        public const uint XONLINE_E_BILLING_DD_INVALID_CHECKDIGIT_VALUE = 0x80167670;

        // Account holder name not specified or it exceeds 35 characters.
        public const uint XONLINE_E_BILLING_DD_INVALID_ACCOUNT_HOLDER_NAME = 0x8016767A;

        // Soap call to provider failed.
        public const uint XONLINE_E_BILLING_DD_UNKNOWN_PROVIDER_FAILURE = 0x8016771F;

        // Payment provider connection timed out.
        public const uint XONLINE_E_BILLING_PAYMENT_PROVIDER_CONNECTION_TIMEOUT = 0x8016767F;

        // Transaction declined by payment provider.
        public const uint XONLINE_E_BILLING_TRANSACTION_DECLINED_BY_PAYMENT_PROVIDER = 0x80167680;

        // Payment provider error.
        public const uint XONLINE_E_BILLING_INVALID_INITIATE_TRANSACTION_RESULT = 0x80167681;

        // The wholesale partner specified is invalid.
        public const uint XONLINE_E_BILLING_INVALID_WHOLESALE_PARTNER = 0x80167684;

        // PI Not Supported in this version
        public const uint XONLINE_E_BILLING_PI_NOT_SUPPORTED = 0x80167693;

        // A fatal error occured updating the UPS entries for all PUIDs relating to i_billable_acct_id %1. This account should be investigated and the UPS entries for PUIDs attached to it should be updated manually.
        public const uint XONLINE_E_BILLING_UPS_NOT_UPDATED = 0x8016769D;

        // This branch will not support Direct Debit transactions.
        public const uint XONLINE_E_BILLING_DD_UNSUPPORTED = 0x801676A2;

        // Internal error, Return from MPF is not in XML format.
        public const uint XONLINE_E_BILLING_DD_MPF_NON_XML_RESPONSE = 0x801676A7;

        // Internal error, Return XML from MPF is not in correct format.
        public const uint XONLINE_E_BILLING_DD_MPF_INCORRECT_XML_FORMAT = 0x801676AC;

        // Global Collect error, Return from Global Collect is not in XML format.
        public const uint XONLINE_E_BILLING_DD_GC_NON_XML_RESPONSE = 0x801676B1;

        // Global Collect error, Return XML from Global Collect is not in correct format.
        public const uint XONLINE_E_BILLING_DD_GC_INCORRECT_XML_FORMAT = 0x801676B6;

        // Global collect failed to process this request, returned NOT OK result.
        public const uint XONLINE_E_BILLING_DD_GC_RETURNED_NOK_RESULT = 0x801676BB;

        // Direct Debit account Check performed by Global Collect is not complete for this account.
        public const uint XONLINE_E_BILLING_DD_GC_CHECK_INCOMPLETE = 0x801676C0;

        // Global Collect error, Return XML from Global Collect is not in correct format. Error in CHECKSPERFORMED node of the return XML.
        public const uint XONLINE_E_BILLING_DD_OPENING_GC_XML_CHECKSPERFORMED = 0x801676C5;

        // Global Collect error, Return XML from Global Collect is not in correct format. Data within CHECKSPERFORMED nodes are invalid.
        public const uint XONLINE_E_BILLING_DD_GC_XML_INVALID_CHECK_RESULT = 0x801676CA;

        // Global collect returned non null Reformatted Bank Code though the input Bank code was blank.
        public const uint XONLINE_E_BILLING_DD_GC_INVALID_RFBANKCODE = 0x801676CF;

        // Invalid payment instrument details.
        public const uint XONLINE_E_BILLING_INVALID_PAYMENT_INSTRUMENT_DETAILS = 0x801676D9;

        // Invalid ban reason code.
        public const uint XONLINE_E_BILLING_INVALID_BAN_REASON_CODE = 0x801676DE;

        // Invalid encrypted CVM code.
        public const uint XONLINE_E_BILLING_INVALID_CVM_CODE = 0x801676E3;

        // Unexpected CVM response code.
        public const uint XONLINE_E_BILLING_UNEXPECTED_CVM_RESPONSE_CODE = 0x801676E8;

        // CVM check failed.
        public const uint XONLINE_E_BILLING_CVM_FAILED = 0x801676ED;

        // Immediate settlement failed
        public const uint XONLINE_E_BILLING_IMMEDIATE_SETTLEMENT_FAILURE = 0x801676EE;

        // Frequency check failed.
        public const uint XONLINE_E_BILLING_FREQUENCY_CHECK_FAILED = 0x801676F2;

        // Invalid merchant index.
        public const uint XONLINE_E_BILLING_DD_INVALID_MERCHANT_INDEX = 0x801676F7;

        // Duplicate merchant reference.
        public const uint XONLINE_E_BILLING_DD_DUPLICATE_MRN = 0x801676FC;

        // Account validation failed.
        public const uint XONLINE_E_BILLING_DD_UNKNOWN_VALIDATION_FAILURE = 0x80167701;

        // Bank account type may not be specified for this country.
        public const uint XONLINE_E_BILLING_ROR_DD_BANK_ACCOUNT_TYPE_MUST_BE_NULL = 0x80167706;

        // Bank account type is required for this country.
        public const uint XONLINE_E_BILLING_ROR_DD_BANK_ACCOUNT_TYPE_MAY_NOT_BE_NULL = 0x8016770B;

        // Risk check failed.
        public const uint XONLINE_E_BILLING_DD_RISK_DECLINE = 0x80167715;

        // Unable to validate the tax ID.
        public const uint XONLINE_E_BILLING_UNABLE_TO_VALIDATE_TAX_ID = 0x80167724;

        // Number of updates allowed in a period has exceeded the maximum limit.
        public const uint XONLINE_E_BILLING_TAX_ID_UPDATE_ATTEMPTS_EXCEEDED = 0x80167729;

        // External vendor error.
        public const uint XONLINE_E_BILLING_EXTERNAL_VENDOR_ERROR = 0x8016772E;

        // Object is already in the specified state.
        public const uint XONLINE_E_BILLING_ALREADY_IN_SPECIFIED_STATE = 0x80169C41;

        // Required search criteria field missing. Either a phone number or both first name and last name is required.
        public const uint XONLINE_E_BILLING_MISSING_SEARCH_CRITERIA = 0x80169C44;

        // Required field missing.
        public const uint XONLINE_E_BILLING_REQUIRED_FIELD_MISSING = 0x80169C45;

        // The account has subscriptions.
        public const uint XONLINE_E_BILLING_ACTIVE_SUBSCRIPTIONS = 0x80169C46;

        // Unexpected field
        public const uint XONLINE_E_BILLING_UNEXPECTED_FIELD = 0x80169C47;

        // Invalid account source.
        public const uint XONLINE_E_BILLING_INVALID_ACCOUNT_SOUCE = 0x80169C4D;

        // Creation date/time cannot be later than current date/time.
        public const uint XONLINE_E_BILLING_INVALID_CREATION_DATE = 0x80169C4E;

        // No more tax exemptions are allowed for this account.
        public const uint XONLINE_E_BILLING_EXCEEDING_TAX_EXEMPT_LIMITS = 0x80169C55;

        // Generating next ID.
        public const uint XONLINE_E_BILLING_GENERATE_NEXT_ID = 0x80169C59;

        // State invalid for the country.
        public const uint XONLINE_E_BILLING_INVALID_STATE_FOR_COUNTRY = 0x80169C5F;

        // Country for address provided does not match existing country for account.
        public const uint XONLINE_E_BILLING_ADDRESS_COUNTRY_ACCOUNT_MISMATCH = 0x80169C61;

        // The offering requested is not available in the country of this account.
        public const uint XONLINE_E_BILLING_OFFERING_COUNTRY_ACCOUNT_MISMATCH = 0x80169C62;

        // Invalid account.
        public const uint XONLINE_E_BILLING_INVALID_BILLABLE_ACCOUNT_ID = 0x80169CC2;

        // Invalid account status.
        public const uint XONLINE_E_BILLING_INVALID_BILLABLE_ACCOUNT_STATUS_ID = 0x80169CC7;

        // Invalid phone type.
        public const uint XONLINE_E_BILLING_INVALID_PHONE_TYPE = 0x80169CD6;

        // Invalid offering.
        public const uint XONLINE_E_BILLING_INVALID_OFFERING_ID = 0x80169CE5;

        // The combination of data passed to PurchaseOffering is invalid for the scenario.
        public const uint XONLINE_E_BILLING_INVALID_PURCHASE_INPUT_DATA = 0x80169CE6;

        // UPS profile is missing either FirstName, LastName, Country or PMN
        public const uint XONLINE_E_BILLING_PUID_MISSING_ATTRIBUTE = 0x80169CE7;

        // Invalid country code.
        public const uint XONLINE_E_BILLING_INVALID_COUNTRY_CODE = 0x80169CEA;

        // Invalid address ID.
        public const uint XONLINE_E_BILLING_INVALID_ADDRESS_ID = 0x80169CEF;

        // Invalid payment instrument ID.
        public const uint XONLINE_E_BILLING_INVALID_PAYMENT_METHOD_ID = 0x80169CF9;

        // Cannot exceed max ownership for the payment instrument.
        public const uint XONLINE_E_BILLING_PI_EXECEED_MAX_OWNER_SHIP = 0x80169D03;

        // Subscription is already cancelled.
        public const uint XONLINE_E_BILLING_SUBSCRIPTION_ALREADY_CANCELED = 0x80169D08;

        // A delayed expire request is already pending and should not be requested again.
        public const uint XONLINE_E_BILLING_DELAYED_EXPIRE_ALREADY_PENDING = 0x80169D0A;

        // A delayed expire is not pending and cannot be undone.
        public const uint XONLINE_E_BILLING_DELAYED_EXPIRE_NOT_PENDING = 0x80169D0B;

        // A delayed expire is not support unless the subscription is active with no term commits.
        public const uint XONLINE_E_BILLING_DELAYED_EXPIRE_NOT_SUPPORTED = 0x80169D0C;

        // The value specified for the cancel option/date should be DELAYED_EXPIRE, UNDO_DELAYED_EXPIRE, IMMEDIATE_EXPIRE or IMMEDIATE_CANCEL.
        public const uint XONLINE_E_BILLING_INVALID_CANCEL_DATE = 0x80169D09;

        // Invalid subscription ID.
        public const uint XONLINE_E_BILLING_INVALID_SUBSCRIPTION_ID = 0x80169D0D;

        // Invalid period.
        public const uint XONLINE_E_BILLING_INVALID_PERIOD_TO_PROCESS = 0x80169D2B;

        // Invalid subscription status or invalid operation for the status.
        public const uint XONLINE_E_BILLING_INVALID_SUBSCRIPTION_STATUS = 0x80169D3A;

        // Account is inactive.
        public const uint XONLINE_E_BILLING_NON_ACTIVE_ACCOUNT = 0x80169D94;

        // VATIDs do not have an expiration date.
        public const uint XONLINE_E_BILLING_VATID_DOESNOTHAVEEXPDATE = 0x80169D95;

        // Expiration date was not specified.
        public const uint XONLINE_E_BILLING_TAXID_EXPDATE = 0x80169D96;

        // Invalid tax exemption type.
        public const uint XONLINE_E_BILLING_INVALID_TAX_EXEMPT_TYPE = 0x80169D97;

        // Invalid Tax Exempt Billable Account Id specified.
        public const uint XONLINE_E_BILLING_INVALID_TAX_EXEMPT_BILLABLE_ACCOUNT_ID = 0x80169D98;

        // No active subscription for adding a service instance.
        public const uint XONLINE_E_BILLING_NO_ACTIVE_SUBSCRIPTION = 0x80169D99;

        // Invalid service instance for adding a new user.
        public const uint XONLINE_E_BILLING_INVALID_SERVICE_INSTANCE = 0x80169D9E;

        // Failed to add a new user to a service instance.
        public const uint XONLINE_E_BILLING_ADD_USER_TO_SERVICE_INSTANCE = 0x80169DA3;

        // Status change not allowed.
        public const uint XONLINE_E_BILLING_INVALID_BILLABLEACCTSTATUS = 0x80169DA8;

        // No service instances available for the billable account.
        public const uint XONLINE_E_BILLING_SERVICE_INSTANCES_NONE = 0x80169DBC;

        // Account is already closed.
        public const uint XONLINE_E_BILLING_ACCOUNT_CLOSED = 0x80169DD1;

        // Period is already past.
        public const uint XONLINE_E_BILLING_BILLINGPERIOD_PAST = 0x80169DD6;

        // Invalid adjustment GUID.
        public const uint XONLINE_E_BILLING_INVALID_ADJUSTMENTGUID = 0x80169DD7;

        // Adjustment not applicable to the specified period.
        public const uint XONLINE_E_BILLING_INVALID_ADJUSMENT_FOR_PERIOD = 0x80169DD8;

        // Adjustment amount is too large.
        public const uint XONLINE_E_BILLING_ADJUSTMENT_TOOBIG = 0x80169DD9;

        // Adjustment amount is too small.
        public const uint XONLINE_E_BILLING_ADJUSTMENT_TOOSMALL = 0x80169DDB;

        // Invalid locale.
        public const uint XONLINE_E_BILLING_INVALID_LOCALE = 0x80169DE5;

        // Invalid customer type.
        public const uint XONLINE_E_BILLING_INVALID_CUSTOMER_TYPE = 0x80169DE6;

        // Invalid currency.
        public const uint XONLINE_E_BILLING_INVALID_CURRENCY = 0x80169DE7;

        // Date is already expired.
        public const uint XONLINE_E_BILLING_DATE_EXPIRED = 0x80169DE8;

        // GUID already exists.
        public const uint XONLINE_E_BILLING_GUID_EXISTS = 0x80169DEA;

        // Invalid violation ID.
        public const uint XONLINE_E_BILLING_INVALID_VIOLATION_ID = 0x80169DEC;

        // Violation ID is required.
        public const uint XONLINE_E_BILLING_MISSING_VIOLATION_ID = 0x80169DED;

        // De-provision service instances before proceeding.
        public const uint XONLINE_E_BILLING_NEEDTODEPROVISION = 0x80169DEF;

        // Partial conversion is already initiated.
        public const uint XONLINE_E_BILLING_PARTIALCONV_INITIATED = 0x80169DF0;

        // The currency of the account cannot be updated.
        public const uint XONLINE_E_BILLING_CANNOT_UPDATE_CURRENCY = 0x80169DF1;

        // Subscription is expected to be in the partial state.
        public const uint XONLINE_E_BILLING_PARTIALCONV_EXPECTED = 0x80169DF2;

        // Invalid category. Valid category name has a size limit of 50 characters.
        public const uint XONLINE_E_BILLING_INVALID_CATEGORY_NAME = 0x80169DF3;

        // Offering cannot be purchased.
        public const uint XONLINE_E_BILLING_OFFERING_NOT_PURCHASEABLE = 0x80169DF5;

        // Offering currency does not match account currency.
        public const uint XONLINE_E_BILLING_OFFERING_ACCOUNT_CURRENCY_MISMATCH = 0x80169DF6;

        // Offering does not support payment instrument type.
        public const uint XONLINE_E_BILLING_OFFERING_PAYMENT_INSTRUMENT_MISMATCH = 0x80169DF7;

        // Invalid date.
        public const uint XONLINE_E_BILLING_INVALID_DATE = 0x80169DF8;

        // Cannot exceed max ownership for the offering.
        public const uint XONLINE_E_BILLING_CANNOT_EXCEED_MAX_OWNERSHIP = 0x80169DF9;

        // Invalid resource ID.
        public const uint XONLINE_E_BILLING_INVALID_RESOURCE_ID = 0x80169E02;

        // Unit of measure reported in the usage event does not match the one in SPS.
        public const uint XONLINE_E_BILLING_UNIT_OF_MEASURE_MISMATCH = 0x80169E03;

        // Event date is before the subscription purchase date.
        public const uint XONLINE_E_BILLING_EVT_DATE_BEFORE_PURCHASE_DATE = 0x80169E04;

        // Offering invalid for the locale.
        public const uint XONLINE_E_BILLING_INVALID_OFFERING_FOR_LOCALE = 0x80169E05;

        // Offering is not a base offering.
        public const uint XONLINE_E_BILLING_NOT_A_BASE_OFFERING = 0x80169E06;

        // There is a scheduled renewal or pending conversion to an offer that does not support that payment instrument.
        public const uint XONLINE_E_BILLING_FUTURE_OFFERING_PAYMENT_INSTRUMENT_MISMATCH = 0x80169E08;

        // Offering is invalid for Country.
        public const uint XONLINE_E_BILLING_INVALID_OFFERING_FOR_COUNTRY = 0x80169E09;

        // The offering requested conflicts with an existing subscription on this account.
        public const uint XONLINE_E_BILLING_MEG_CONFLICT = 0x80169E0A;

        // Account state does not allow this operation.
        public const uint XONLINE_E_BILLING_INVALID_ACCOUNT_STATUS = 0x80169E16;

        // Payment instrument has active subscriptions.
        public const uint XONLINE_E_BILLING_ACTIVE_SUBSCRIPTIONS_EXIST = 0x80169E1B;

        // The account has billing charges.
        public const uint XONLINE_E_BILLING_EXISTING_BILLING_ACTIVITY = 0x80169E1C;

        // Subscription is in an invalid state for this operation.
        public const uint XONLINE_E_BILLING_INVALID_SUBSCRIPTION_STATUS_FOR_OPERATION = 0x80169E20;

        // Primary phone required for payment instruments.
        public const uint XONLINE_E_BILLING_PRIMARY_PHONE_REQUIRED = 0x80169E25;

        // Account requires an e-mail address for this operation.
        public const uint XONLINE_E_BILLING_EMAIL_REQUIRED = 0x80169E2A;

        // To perform this operation, the account should be closed.
        public const uint XONLINE_E_BILLING_ACCOUNT_NOT_CLOSED = 0x80169E2B;

        // Invalid violation ID.
        public const uint XONLINE_E_BILLING_INVALID_VIOLATION = 0x80169E13;

        // Subscription is cancelled and cannot change status.
        public const uint XONLINE_E_BILLING_SUBSCRIPTION_IS_CANCELLED = 0x80169E14;

        // Subscription has no violations.
        public const uint XONLINE_E_BILLING_NO_VIOLATION = 0x80169E15;

        // Subscription has violations.
        public const uint XONLINE_E_BILLING_EXISTS_VIOLATION = 0x80169E17;

        // Invalid Service Component Id was passed.
        public const uint XONLINE_E_BILLING_INVALID_SERVICE_COMPONENT_ID = 0x80169E32;

        // End date is already past.
        public const uint XONLINE_E_BILLING_END_DATE_IN_THE_PAST = 0x80169E33;

        // End date passed in is later than the latest allowable end date for this subscription.
        public const uint XONLINE_E_BILLING_END_DATE_BEYOND_MAX = 0x80169E34;

        // Violation is already set.
        public const uint XONLINE_E_BILLING_VIOLATION_ALREADY_SET = 0x80169E3E;

        // Violation ID not set.
        public const uint XONLINE_E_BILLING_NO_VIOLATION_SET = 0x80169E43;

        // Either there is no path between the current offering and the target offering or the path does not match the calling mode (Convert or Renew).
        public const uint XONLINE_E_BILLING_INVALID_CONVERSION = 0x80169E4D;

        // Subscription is not in the partial state.
        public const uint XONLINE_E_BILLING_SUBS_NOT_INTERMEDIATE = 0x80169E4E;

        // Offering is not published.
        public const uint XONLINE_E_BILLING_OFFERING_NOT_PUBLISHED = 0x80169E52;

        // Service instances must be de-provisioned to proceed.
        public const uint XONLINE_E_BILLING_CONVERSION_NEEDTODEPROVISION = 0x80169E53;

        // Invalid mandate status.
        public const uint XONLINE_E_BILLING_INVALID_MANDATE_STATUS = 0x80169E57;

        // Payment instrument status is already GOOD.
        public const uint XONLINE_E_BILLING_PI_ALREADY_GOOD = 0x80169E61;

        // Payment instrument status is already DECLINED.
        public const uint XONLINE_E_BILLING_PI_ALREADY_DECLINED = 0x80169E66;

        // Payment instrument status is DISABLED and cannot be changed.
        public const uint XONLINE_E_BILLING_PI_IS_DISABLED = 0x80169E6B;

        // SAP Number is required for Invoice PI.
        public const uint XONLINE_E_BILLING_INVOICEPI_SAP_NUMBER_REQUIRED = 0x80169E70;

        // Invoice XML was invalid.
        public const uint XONLINE_E_BILLING_INVALID_INVOICE_INFO_XML = 0x80169E71;

        // Max Limit for this PI Type within account reached.
        public const uint XONLINE_E_BILLING_MAX_PI_PER_ACCOUNT_REACHED = 0x8016AD81;

        // PI country does not match Account country.
        public const uint XONLINE_E_BILLING_PI_ACCOUNT_COUNTRY_MISMATCH = 0x80169E77;

        // An error occured. Try again later.
        public const uint XONLINE_E_BILLING_ERROR_OCCURRED_TRY_LATER = 0x80169E78;

        // An error occured.
        public const uint XONLINE_E_BILLING_ERROR_OCCURRED = 0x80169E79;

        // Payment instrument exists or the payment instrument status is invalid or does not allow the operation.
        public const uint XONLINE_E_BILLING_INVALID_PAYMENT_INSTRUMENT_STATUS = 0x80169E7F;

        // Invalid offering GUID.
        public const uint XONLINE_E_BILLING_INVALID_OFFERING_GUID = 0x80169E84;

        // Offering requires a payment instrument.
        public const uint XONLINE_E_BILLING_OFFERING_REQUIRES_PI = 0x80169E89;

        // Offering cannot be purchased because it has delayed provisioning components.
        public const uint XONLINE_E_BILLING_DELAYED_PROVISIONING_COMPONENTS_EXIST = 0x80169E93;

        // Invalid currency format.
        public const uint XONLINE_E_BILLING_INVALID_AMOUNT_FOR_CURRENCY = 0x80169E99;

        // Invalid e-mail address.
        public const uint XONLINE_E_BILLING_INVALID_EMAIL_ADDRESS = 0x80169EA2;

        // Invalid tax exemption status.
        public const uint XONLINE_E_BILLING_INVALID_TAX_EXEMPT_STATUS = 0x80169EAC;

        // No valid tax exemption certificates exist for the account.
        public const uint XONLINE_E_BILLING_NO_VALID_TAX_EXEMPTION = 0x80169EAD;

        // Invalid tax exemption status change.
        public const uint XONLINE_E_BILLING_INVALID_TAX_EXEMPT_STATUS_CHANGE = 0x80169EB1;

        // The status of the old payment instrument does not allow this operation.
        public const uint XONLINE_E_BILLING_INVALID_OLD_PAYMENT_INSTRUMENT_STATUS = 0x80169EB6;

        // The specified start period is invalid.
        public const uint XONLINE_E_BILLING_INVALID_START_PERIOD = 0x80169EC4;

        // The specified end period is invalid.
        public const uint XONLINE_E_BILLING_INVALID_END_PERIOD = 0x80169EC5;

        // The specified Detailed level is invalid.
        public const uint XONLINE_E_BILLING_INVALID_DETAILEDLEVEL = 0x80169EC6;

        // Difference between BeginDate and EndDate is more than 6 months
        public const uint XONLINE_E_BILLING_EXCEED_DATERANGE_LIMIT = 0x80169EC7;

        // Begin Date can never be greater than EndDate
        public const uint XONLINE_E_BILLING_WRONG_DATERANGE = 0x80169EC8;

        // Begin date is not valid
        public const uint XONLINE_E_BILLING_INVALID_BEGIN_DATE = 0x80169EC9;

        // End date is not valid
        public const uint XONLINE_E_BILLING_INVALID_END_DATE = 0x80169ECB;

        // End date is greater than the current date
        public const uint XONLINE_E_BILLING_END_DATE_GREATER_THAN_CURRENT_DATE = 0x80169ECC;

        // SPS is in compute-only mode.
        public const uint XONLINE_E_BILLING_COMPUTE_ONLY = 0x80169ECA;

        // Detected that month(s) were missed in periodic processing.
        public const uint XONLINE_E_BILLING_MISSED_PROCESSING_PERIOD = 0x80169F33;

        // Subscription is not expired.
        public const uint XONLINE_E_BILLING_SUBSCRIPTION_NOT_EXPIRED = 0x80169F43;

        // Subscription can no longer be reinstated.
        public const uint XONLINE_E_BILLING_TOOLATE_REINSTATE = 0x80169F44;

        // Only a single Referral node may be passed in to this API.
        public const uint XONLINE_E_BILLING_EXTRA_REFERRAL_DATA = 0x80169F47;

        // bstrReferralIDSetXML parameter must be left empty for this API.
        public const uint XONLINE_E_BILLING_NO_REFERRAL_UPDATES_ALLOWED = 0x80169F4C;

        // Cannot schedule a new renewal because there exists already a free renewal on the subscription.
        public const uint XONLINE_E_BILLING_FREE_SCHEDULED_RENEWAL_EXISTS = 0x80169F4D;

        // Cannot convert a deal with multiple components with delayed provisioning.
        public const uint XONLINE_E_BILLING_DEAL_HAS_MULTIPLE_DELAYED_COMPONENTS = 0x80169F4E;

        // The specified cobrand is invalid.
        public const uint XONLINE_E_BILLING_INVALID_COBRAND = 0x80169F56;

        // This operation is not valid for wholesale subscriptions.
        public const uint XONLINE_E_BILLING_INVALID_OPERATION_FOR_WHOLESALE_SUBSCRIPTION = 0x80169F65;

        // HCI not valid for Account Id.
        public const uint XONLINE_E_BILLING_HCI_NOT_VALID = 0x80169F83;

        // Taiwan users cannot opt out of hard copy tax invoices.
        public const uint XONLINE_E_BILLING_CANT_STOP_TAIWAN_TAXINV = 0x80169F85;

        // Adjusting a resource balance is not allowed for subscriptions that are not active.
        public const uint XONLINE_E_BILLING_RESOURCE_BALANCE_CHANGE_ON_NONACTIVE_SUBS = 0x80169FB5;

        // The type of the token specified was invalid.
        public const uint XONLINE_E_BILLING_INVALID_TOKEN_TYPE = 0x8016A00A;

        // The token Id specified is not valid for the given offering.
        public const uint XONLINE_E_BILLING_TOKEN_NOT_VALID_FOR_OFFERING = 0x8016A04B;

        // Deal Token mapping currently not present in the system to be marked as invalid.
        public const uint XONLINE_E_BILLING_DEAL_TOKEN_MAPPING_NOT_PRESENT = 0x8016A04C;

        // Maximum consumption count per user reached.
        public const uint XONLINE_E_BILLING_MAXIMUM_CONSUMPTION_COUNT_PER_USER_REACHED = 0x8016A00B;

        // Error in inserting a new row in table user_token_hash.
        public const uint XONLINE_E_BILLING_INSERTING_USER_TOKEN_HASH = 0x8016A00C;

        // A token Id and a payment instrument Id cannot both be specified.
        public const uint XONLINE_E_BILLING_TOKEN_AND_PI_BOTH_SPECIFIED = 0x8016A06E;

        // The token class is invalid or does not exist.
        public const uint XONLINE_E_BILLING_TOKEN_CLASS_INVALID = 0x8016A073;

        // The Input TokenClass Restriction Info Filter is Missing.
        public const uint XONLINE_E_BILLING_INPUT_FILTER_XML_MISSING = 0x8016A074;

        // Unable to find the token mapping to the specified token class.
        public const uint XONLINE_E_BILLING_TOKEN_CLASS_NOT_FOUND = 0x801613AB;

        // Invalid TokenClass Restriction Info Filter.
        public const uint XONLINE_E_BILLING_INVALID_INPUT_FILTER_XML = 0x8016A075;

        // A payment instrument cannot be specified.
        public const uint XONLINE_E_BILLING_PI_CANNOT_BE_SPECIFIED = 0x8016A078;

        // The subscription specified is not a PrePaid subscription.
        public const uint XONLINE_E_BILLING_SUBSCRIPTION_NOT_PREPAID = 0x8016A07D;

        // The total number of extended days cannot be less than zero.
        public const uint XONLINE_E_BILLING_TOTAL_EXTENSION_LESS_THAN_ZERO = 0x8016A082;

        // The number of days specified is invalid, possibly because the subscription doesn't have that many days remaining.
        public const uint XONLINE_E_BILLING_INVALID_NUMBER_OF_DAYS = 0x8016A087;

        // The number of months specified is invalid, possibly because it is negative.
        public const uint XONLINE_E_BILLING_INVALID_NUMBER_OF_MONTHS = 0x8016A088;

        // The total number of extended days is greater than the maximum allowed for the current subscription.
        public const uint XONLINE_E_BILLING_TOTAL_EXTENSION_GREATER_THAN_MAX = 0x8016A08C;

        // The deal specified requires a valid Prepaid Token Id to be specified.
        public const uint XONLINE_E_BILLING_PREPAID_TOKEN_IS_REQUIRED = 0x8016A096;

        // There are remaining cycles on the current term commit.
        public const uint XONLINE_E_BILLING_TERM_COMMIT_EXISTS = 0x8016A09B;

        // The specified token cannot be used for the current operation.
        public const uint XONLINE_E_BILLING_TOKEN_NOT_APPLICABLE = 0x8016A0A0;

        // Renewal cannot be scheduled if there is already a token based renewal present.
        public const uint XONLINE_E_BILLING_TOKEN_RENEWAL_PRESENT = 0x8016A0A5;

        // Error subscription duration exceeds max duration.
        public const uint XONLINE_E_BILLING_EXCEEDS_MAXIMUM_DURATION = 0x8016A0FA;

        // Error conversion credits were applied but the offer does not support conversion credits.
        public const uint XONLINE_E_BILLING_CONVERSION_CREDITS_NOT_ENABLED = 0x8016A104;

        // Only BillableAccountAdmin can add the PI.
        public const uint XONLINE_E_BILLING_INVALID_USERROLE_FOR_ADDPI = 0x8016A10E;

        // BlacklistToken found actions to take, but BSTRSubscriptionAction was set to DONOTHING.
        public const uint XONLINE_E_BILLING_BLACKLIST_ACTION_NOT_PERFORMED = 0x8016A0AA;

        // BlacklistToken was called with invalid bstrSubscriptionAction parameter.
        public const uint XONLINE_E_BILLING_INVALID_SUBSCRIPTION_ACTION = 0x8016A0AF;

        // Invalid distribution channel specified for token class part number.
        public const uint XONLINE_E_BILLING_TOKEN_DISTRIBUTION_CHANNEL_NOT_FOUND = 0x8016A0B9;

        // Invalid length for token class part number.
        public const uint XONLINE_E_BILLING_INVALID_LEN_PART_NUMBER = 0x8016A0BE;

        // nvalid length for SAP customer name.
        public const uint XONLINE_E_BILLING_INVALID_LEN_SAP_CUST_NAME = 0x8016A0C3;

        // Invalid length for Support Vendor name.
        public const uint XONLINE_E_BILLING_INVALID_LEN_SUPPORT_VENDOR_NAME = 0x8016A0C8;

        // Failed while inserting in partner_token_class table.
        public const uint XONLINE_E_BILLING_INSERING_TOKEN_CLASS_PARTNER = 0x8016A0CD;

        // Token Part Number is currently associated with other token class please remove the association from the other token class and try again.
        public const uint XONLINE_E_BILLING_TOKEN_PART_NUMBER_ASSOC_WITH_OTHER_TOKEN_CLASS = 0x8016A0D2;

        // A token is being delivered to the same service instance at this moment. Please retry.
        public const uint XONLINE_E_BILLING_TOKEN_ALREADY_DELIVERED = 0x8016148D;

        // A Token passed in does not have an associated Distribution batch.
        public const uint XONLINE_E_BILLING_TOKEN_DISTRIBUTION_BATCH_INVALID = 0x80169DDA;

        // A Distribution Batch associated with the passed in Token is in inactive state.
        public const uint XONLINE_E_BILLING_TOKEN_DISTRIBUTION_BATCH_INACTIVE = 0x80169DDF;

        // A Distribution Program is in inactive state.
        public const uint XONLINE_E_BILLING_DISTRIBUTION_PROGRAM_INACTIVE = 0x80169DE9;

        // Failed while inserting in reconcile_history table.
        public const uint XONLINE_E_BILLING_INSERTING_RECONCILE_HISTORY = 0x801614BE;

        // Specified Token is already issued.
        public const uint XONLINE_E_BILLING_TOKEN_ALREADY_ISSUED = 0x801614C3;

        // Specified Token is already unissued, can not unissue the same token again.
        public const uint XONLINE_E_BILLING_TOKEN_ALREADY_UNISSUED = 0x801614C8;

        // Failed to update the token issue status in token_instance table.
        public const uint XONLINE_E_BILLING_TOKEN_ISSUE_UPDATE = 0x801614CD;

        // The input parameter combination does not match the system.
        public const uint XONLINE_E_BILLING_INVALID_COMBINATION = 0x801614D2;

        // Invalid Replacement Reason code specified.
        public const uint XONLINE_E_BILLING_INVALID_REPLACEMENT_REASON_CODE = 0x801614D7;

        // The request failed because the maximum number of replacements for this sequence number have exceeded the threshold value.
        public const uint XONLINE_E_BILLING_MAX_REPLACEMENT_REACHED = 0x801614DC;

        // Token Replacement failed due to unknown error.
        public const uint XONLINE_E_BILLING_TOKEN_REPLACEMENT_FAILED = 0x801614E1;

        // Failed to update Token Distribution status.
        public const uint XONLINE_E_BILLING_TOKEN_DISTRIBUTION_STATUS_UPDATE = 0x801614E6;

        // Signature does not belong to specified Token.
        public const uint XONLINE_E_BILLING_SIGNATURE_TOKEN_MISMATCH = 0x801614EB;

        // Invalid Token Staus Name specified.
        public const uint XONLINE_E_BILLING_INVALID_STATUS_NAME = 0x801614F0;

        // Invalid distribution status to issue token.
        public const uint XONLINE_E_BILLING_INVALID_TOKEN_DISTRIBUTION_STATUS = 0x801614F5;

        // Specified token is replaced token, can not provide replacement for Replaced Token.
        public const uint XONLINE_E_BILLING_ALREADY_REPLACED_TOKEN = 0x801614FA;

        // Invalid Partner specified or the partner does not have permission to take action on specified token.
        public const uint XONLINE_E_BILLING_TOKEN_ACTION_ACCESS_DENIED = 0x801614FF;

        // Value for returnStatementSet parameter must be 0, 1, or 2.
        public const uint XONLINE_E_BILLING_BAD_RETURN_STATEMENT_SET_INDICATOR = 0x8016A604;

        // The begin billing period is not valid for this account.
        public const uint XONLINE_E_BILLING_BAD_BEGIN_BILLING_PERIOD = 0x8016A609;

        // The end billing period is not valid for this account.
        public const uint XONLINE_E_BILLING_INVALID_END_BILLING_PERIOD = 0x8016A60E;

        // The billing period value cannot be negative.
        public const uint XONLINE_E_BILLING_BILLING_PERIOD_NEGATIVE = 0x8016A613;

        // The end period must be greater than start period.
        public const uint XONLINE_E_BILLING_BAD_START_END_BILLING_PERIOD = 0x8016A618;

        // The account history date cannot be greater than the current date.
        public const uint XONLINE_E_BILLING_CURRENT_DATE_LESS_THAN_ACCOUNT_HISTORY_DATE = 0x8016A61D;

        // Cannot pass null for all parameters.
        public const uint XONLINE_E_BILLING_NO_NON_NULL_PARAMS = 0x8016A622;

        // The billing period value must be of the format YYYYMM (Y representing the year and M representing month).
        public const uint XONLINE_E_BILLING_INVALID_SUBSCRIPTION_BILLING_PERIOD = 0x8016A627;

        // The billing period value cannot be greater than the subscription duration (i.e. past subscription expiration).
        public const uint XONLINE_E_BILLING_BILLING_PERIOD_GREATER_THAN_SUBSCRIPTION_DURATION = 0x8016A62C;

        // The offering guid passed in does not match offering guid on subscription.
        public const uint XONLINE_E_BILLING_MISMATCH_SUB_ID_OFFER_GUID = 0x8016A6FE;

        // The event time stamp is too far in future.
        public const uint XONLINE_E_BILLING_EVENT_TIMESTAMP_IN_THE_FUTURE = 0x8016A70D;

        // The policy GuidID/Version combination supplied does not exist.
        public const uint XONLINE_E_BILLING_INVALID_POLICY_ID = 0x80169F88;

        // The offering specified does not support the country of payment instrument being used.
        public const uint XONLINE_E_BILLING_OFFERING_PI_COUNTRY_MISMATCH = 0x80169F89;

        // Error inserting into table agreement_signature.
        public const uint XONLINE_E_BILLING_INSERT_AGREEMENT_SIGNATURE = 0x80169F8D;

        // Agreement for this subscription has already been signed by this user at a different time.
        public const uint XONLINE_E_BILLING_AGREEMENT_ALREADY_SIGNED = 0x80169F92;

        // The specified policy has not been localized in the specified locale.
        public const uint XONLINE_E_BILLING_LOCALE_NOT_SUPPORTED_FOR_POLICY = 0x80169F9C;

        // The policy specified is valid but the version is incorrect.
        public const uint XONLINE_E_BILLING_POLICY_DEAL_VERSION_MISMATCH = 0x80169F9E;

        // The policy specified exists but is not valid on the deal/country combination of the supplied subscription.
        public const uint XONLINE_E_BILLING_POLICY_DEAL_COUNTRY_MISMATCH = 0x80169FA1;

        // The subscription was previously a wholesale subscription which was converted to a direct subscription and is now trying to be converted to wholesale again.  This is not allowed.
        public const uint XONLINE_E_BILLING_CANNOT_CONVERT_BACK_TO_WHOLESALE = 0x8016A6D1;

        // A payment instrument cannot specified when the conversion mode is RENEW.
        public const uint XONLINE_E_BILLING_CANNOT_SPECIFY_PI_DURING_RENEW = 0x8016A6D6;

        // Renewing from a perpetual offering is not allowed.
        public const uint XONLINE_E_BILLING_NO_RENEWAL_FROM_PERPETUAL_OFFERING = 0x8016A6E5;

        // Tax Exempt Certificate Number is invalid.
        public const uint XONLINE_E_BILLING_INVALID_TECERTIFICATENUMBER = 0x8016A6EA;

        // Conversions between wholesale offers are not allowed.
        public const uint XONLINE_E_BILLING_NO_WHOLESALE_TO_WHOLESALE = 0x8016A708;

        // The status of the new payment instrument specified does not allow this operation.
        public const uint XONLINE_E_BILLING_INVALID_NEW_PAYMENT_INSTRUMENT_STATUS = 0x8016A712;

        // Renewal does not exist.
        public const uint XONLINE_E_BILLING_INVALID_RENEWAL = 0x8016A71C;

        // The length of phone number is greater than expected.
        public const uint XONLINE_E_BILLING_ERROR_PHONE_STRING_TOOLONG = 0x8016A721;

        // The calling partner does not have access to the token class.
        public const uint XONLINE_E_BILLING_ERROR_TOKEN_CLASS_ACCESS_DENIED = 0x8016A72B;

        // Last administrator role on the account cannot be removed.
        public const uint XONLINE_E_BILLING_LAST_ADMIN_ROLE = 0x8016C3C3;

        // The PUID is already being used as BillableAccountAdmin.
        public const uint XONLINE_E_BILLING_PUID_USED_AS_BILLABLEACCOUNTADMIN = 0x8016C3C4;

        // Error updating member name.
        public const uint XONLINE_E_BILLING_UPDATING_MEMBERNAME = 0x8016C3C8;

        // Object can have a maximum of 2000 roles.
        public const uint XONLINE_E_BILLING_OBJECT_ROLE_LIMIT_EXCEEDED = 0x8016C3CD;

        // The allowable number of the delegate admins for an account has reached its limit.
        public const uint XONLINE_E_BILLING_ACCOUNT_DELADMIN_ROLE_EXCEEDED = 0x8016C3CE;

        // Provisioning: Provision request malformed.
        public const uint XONLINE_E_BILLING_MALFORMED_REQUEST = 0x8016AB7D;

        // Provisioning: Wrong input parameters.
        public const uint XONLINE_E_BILLING_WRONG_INPUT_PARAMETERS = 0x8016AB7E;

        // Provisioning: Microsoft Provisioning Framework call failed. %1
        public const uint XONLINE_E_BILLING_MPF_CALL_FAILED = 0x8016AB7F;

        // Provisioning: Error during XML manipulation. %1
        public const uint XONLINE_E_BILLING_XML_OPERATION_ERROR = 0x8016AB80;

        // Provisioning: MPF client instantiation failed. %1
        public const uint XONLINE_E_BILLING_MPF_CREATE = 0x8016AB81;

        // Provisioning: General error in startup code. %1
        public const uint XONLINE_E_BILLING_CREATION = 0x8016AB82;

        // The number of service instances in the provisioning request exceeds the configured limit.
        public const uint XONLINE_E_BILLING_EXCEEDS_MAX_NUMBER_OF_SERVICE_INSTANCE_REQUESTS = 0x8016ABA2;

        // Invalid ZIP code.
        public const uint XONLINE_E_BILLING_DBBADZIP = 0x8016ABA3;

        // The account has subscription(s) in non-cancelled state that require information that you are attempting to remove.
        public const uint XONLINE_E_BILLING_REQUIRED_FIELD_MISSING_DUE_TO_SUBSCRIPTIONS = 0x8016ABA4;

        // The account requires additional attributes before performing the operation.
        public const uint XONLINE_E_BILLING_ADDITIONAL_ACCOUNT_DATA_REQUIRED = 0x8016ABA5;

        // The referrer has already reffered the customer to this offer.
        public const uint XONLINE_E_BILLING_ACCT_ALREADY_REFERRED = 0x8016ABCE;

        // There are no reward offers currently available in the system.
        public const uint XONLINE_E_BILLING_REWARD_OFFER_NOT_PURCHASABLE = 0x8016ABDA;

        // Need to sign the agreement before continuing with the call.
        public const uint XONLINE_E_BILLING_AGREEMENT_NOT_SIGNED = 0x8016AC79;

        // The user has a violation on their payment instrument.
        public const uint XONLINE_E_BILLING_ITEM_VIOLATION_EXISTS = 0x8016AC7A;

        // Title and/or category is not allowed for this offer.
        public const uint XONLINE_E_BILLING_DYNAMIC_TITLE_AND_CATEGORY_CONFIGURATION = 0x8016AC7B;

        // Account has a pending transaction.
        public const uint XONLINE_E_BILLING_PENDING_TRANSACTION = 0x8016AC7C;

        // Cannot update total.
        public const uint XONLINE_E_BILLING_INCREMENT_TOTAL = 0x80164E39;

        // Resource does not belong to this object id.
        public const uint XONLINE_E_BILLING_RES_NOT_BELONG_TO_OBJECT = 0x80164E57;

        // Payment instrument on the current subscription has a declining balance.
        public const uint XONLINE_E_BILLING_DECLINING_BALANCE = 0x80164E5C;

        // Duplicate tracking GUID.
        public const uint XONLINE_E_BILLING_DUPLICATE_TRACKING_GUID = 0x80164E75;

        // Invalid credit card expiration date.
        public const uint XONLINE_E_BILLING_INVALID_EXPIRATION_DATE = 0x80164EA7;

        // Invalid mandate status.
        public const uint XONLINE_E_BILLING_UNKNOWN_MANDATE_STATUS = 0x80164EAC;

        // Payment method of this type can't support the action
        public const uint XONLINE_E_BILLING_INVALID_PAYMENT_METHOD_TYPE = 0x80164EB2;

        // Invalid input currency.
        public const uint XONLINE_E_BILLING_INVALID_CURRENCY2 = 0x80164EC0;

        // Invalid amount passed in as argument.
        public const uint XONLINE_E_BILLING_INVALID_AMOUNT = 0x80164EFC;

        // Invalid billing period.
        public const uint XONLINE_E_BILLING_INVALID_BILLING_PERIOD = 0x80164F42;

        // Invalid billing anniversary date.
        public const uint XONLINE_E_BILLING_INVALID_ANNIV = 0x80164F9C;

        // Invalid line item ID.
        public const uint XONLINE_E_BILLING_INVALID_LINEITEM_ID = 0x80164FF6;

        // The event type of the line item is invalid for this operation.
        public const uint XONLINE_E_BILLING_INVALID_EVENT_TYPE = 0x8016501E;

        // Line item ID not associated with an open record.
        public const uint XONLINE_E_BILLING_LINE_ITEM_ID_NOT_OPEN = 0x80165046;

        // Line item has already been offset.
        public const uint XONLINE_E_BILLING_LINEITEM_ALREADY_OFFSET = 0x8016504B;

        // Line item has already been Charged back.
        public const uint XONLINE_E_BILLING_LINEITEM_ALREADY_CHARGED_BACK = 0x8016504D;

        // Offset amount must be greater than zero but less than or equal to original amount. %1
        public const uint XONLINE_E_BILLING_INVALID_OFFSET_AMOUNT = 0x80165050;

        // Cannot offset line item that is soft- or hard-declined.
        public const uint XONLINE_E_BILLING_CANNOT_OFFSET_HARD_SOFT_DECLINED = 0x80165055;

        // Amount has not been collected, so it cannot be offset and immediately settled.
        public const uint XONLINE_E_BILLING_AMOUNT_NOT_COLLECTED_YET = 0x8016505A;

        // Cannot offset line item amount of zero.
        public const uint XONLINE_E_BILLING_CANNOT_OFFSET_ZERO_AMOUNT = 0x8016505F;

        // The operation cannot be completed because an amount involved is in the process of being sent to the bank for collection.
        public const uint XONLINE_E_BILLING_AMOUNT_IN_PROCESS = 0x80165064;

        // Credit amount should not be zero.
        public const uint XONLINE_E_BILLING_INVALID_CREDIT_AMOUNT = 0x80165082;

        // Credit amount should not exceed the limit.
        public const uint XONLINE_E_BILLING_CREDIT_AMOUNT_OVER_LIMIT = 0x80165083;

        // Invalid amount for currency (JPY or KRW).
        public const uint XONLINE_E_BILLING_INVALID_AMOUNT_FOR_CURRENCY_2 = 0x80165084;

        // Same event id already been used, please create a new event id and retry.
        public const uint XONLINE_E_BILLING_DUPLICATE_EVENT_ID = 0x80165091;

        // Line items in the immediate_settle_in_progress state cannot be offset.
        public const uint XONLINE_E_BILLING_OFFSET_IMM_SETTLE_IN_PROG = 0x8016509B;

        // Line item with this settlement amount status cannot be offset.
        public const uint XONLINE_E_BILLING_SA_IN_STATE_UNOFFSETABLE = 0x801650A5;

        // this settlement amount status cannot be escheated.
        public const uint XONLINE_E_BILLING_SA_IN_STATE_UNESCHEATABLE = 0x801650A6;

        // Offset amount should never exceed the original item amount.
        public const uint XONLINE_E_BILLING_OFFSET_AMOUNT_GREATER_THAN_ORIGINAL = 0x801650AA;

        // The subscription is not active. The resource usage event is still being reported for the subscription.
        public const uint XONLINE_E_BILLING_RES_BALANCE_CHANGE_ON_NONACTIVE_SUBS = 0x801650AF;

        // the payment instrument already has declines on it
        public const uint XONLINE_E_BILLING_PI_IN_DECLINE = 0x801650C8;

        // The operation is not allowed when there are Settlement Amounts in intermediate status.
        public const uint XONLINE_E_BILLING_SA_IN_INTERMEDIATE_STATUS = 0x801651D1;

        // The specified settlement amount id is invalid.
        public const uint XONLINE_E_BILLING_INVALID_SETTLEMENT_AMOUNT_ID = 0x801651D6;

        // This thread has an out-dated usage total it is trying to rate and write a billing transaction for threshold billing.
        public const uint XONLINE_E_BILLING_MISMATCH_RATED_USAGE_TOTAL = 0x801651E5;

        // Value for returnStatementSet parameter must be 0, 1, or 2.
        public const uint XONLINE_E_BILLING_BAD_RETURN_STATEMENT_SET_INDICATOR2 = 0x801651BD;

        // %1
        public const uint XONLINE_E_BILLING_ARITHMETIC_OVERFLOW_FOR_ADD_OR_UPDATE_USAGE = 0x801651EA;

        // Refund failed - line item was offset but original line item was never settled.
        public const uint XONLINE_E_BILLING_REFUND_LINEITEM_NOT_SETTLED = 0x80165217;

        // Specified resource balance has already been billed.
        public const uint XONLINE_E_BILLING_RESOURCE_BALANCE_INACTIVE = 0x80165226;

        // Usage category does not exist for this resource.
        public const uint XONLINE_E_BILLING_INVALID_NUMBER_OF_UNITS = 0x80165235;

        // Usage category does not exist for this resource.
        public const uint XONLINE_E_BILLING_INVALID_USAGE_CATEGORY = 0x8016523A;

        // The prepaid resource balance is not sufficient for this usage event.
        public const uint XONLINE_E_BILLING_INSUFFICIENT_PREPAID_BALANCE = 0x8016523F;

        // Financial reason code does not exist.
        public const uint XONLINE_E_BILLING_INVALID_FINANCIAL_REASON_CODE = 0x80165262;

        // Offset of offset is not permitted through this API.
        public const uint XONLINE_E_BILLING_OFFSET_OF_OFFSET_NOT_PERMITTED = 0x80165267;

        // If offset is not to be shown by getstatement, the offset amount must match the original amount.
        public const uint XONLINE_E_BILLING_DONOTSHOWOFFSET_MISMATCHED_AMOUNT = 0x80165276;

        // Invalid financial reason code passed for the offset usage API.
        public const uint XONLINE_E_BILLING_INVALID_FIN_REASON_CODE_FOR_OFFSET = 0x8016527B;

        // The line item is associated with a non-offsettable event action.
        public const uint XONLINE_E_BILLING_EVENT_ACTION_NOT_OFFSETTABLE = 0x80165280;

        // Action is not permitted for immediate settle of usage offers.
        public const uint XONLINE_E_BILLING_IMMEDIATE_SETTLE_OF_USAGE_NOT_PERMITTED = 0x80165285;

        // Resource offset is only allowed for usage.
        public const uint XONLINE_E_BILLING_RESOURCE_OFFSET_ONLY_ALLOWED_FOR_USAGE = 0x8016528A;

        // Invalid Tax Refund Code.
        public const uint XONLINE_E_BILLING_ERROR_PP_INVALID_TAX_REFUND_CODE = 0x801652AD;

        // The transaction confirmation number is already used on the account.
        public const uint XONLINE_E_BILLING_DUPLICATE_TRANSACTION_CONFIRMATION_NUMBER = 0x801655FA;

        // The transaction does not exist.
        public const uint XONLINE_E_BILLING_TRANSACTION_NOT_EXIST = 0x80165609;

        // Invalid combination of cumulative authorized amount and cumulative reversed amount.
        public const uint XONLINE_E_BILLING_INVALID_CUMULATIVE_AMOUNT = 0x80165613;

        // The transaction event code is unknown.
        public const uint XONLINE_E_BILLING_TRANSACTION_EVENT_UNKNOWN = 0x80165618;

        // The transaction event code is not consistent.
        public const uint XONLINE_E_BILLING_TRANSACTION_EVENT_INCONSISTENT = 0x8016561D;

        // Invalid sequence number reported in transaction event.
        public const uint XONLINE_E_BILLING_INVALID_SEQUENCE_NUMBER = 0x80165622;

        // Invalid vendor internal transaction id.
        public const uint XONLINE_E_BILLING_INVALID_VENDOR_TRANSACTION_ID = 0x80165627;

        // Invalid rejection reason code.
        public const uint XONLINE_E_BILLING_INVALID_REJECTION_REASON_CODE = 0x8016562C;

        // Invalid transaction status.
        public const uint XONLINE_E_BILLING_INVALID_TRANSACTION_STATUS = 0x80165659;

        // Invalid combination of cumulative authorized tax amount and cumulative reversed tax amount.
        public const uint XONLINE_E_BILLING_INVALID_CUMULATIVE_TAX_AMOUNT = 0x8016566D;

        // Invalid merchant id.
        public const uint XONLINE_E_BILLING_UNKNOWN_MERCHANT_ID = 0x80165677;

        // Transaction has already been cancelled.
        public const uint XONLINE_E_BILLING_TRANSACTION_ALREADY_CANCELLED = 0x8016567C;

        // Passport member name could not be added.
        public const uint XONLINE_E_BILLING_PMN_INSERT_FAILURE = 0x801661BC;

        // Payment card number has been used multiple times.
        public const uint XONLINE_E_BILLING_BADSAMECARDUSEDMULTIPLETIMES = 0x801661D0;

        // Payment instrument already assigned to account.
        public const uint XONLINE_E_BILLING_PI_ALREADY_ON_ACCOUNT = 0x801661DF;

        // Passport ID can have a maximum of 100 roles.
        public const uint XONLINE_E_BILLING_PUID_ROLE_LIMIT_EXCEEDED = 0x801661E4;

        // Too many fraud enticing purchases on the payment instrument
        public const uint XONLINE_E_BILLING_TOOMANY_FDE_PURCHASES = 0x801661E5;

        // Passport PUIDs associated with this tax Id has already reaches the maximum limit.
        public const uint XONLINE_E_BILLING_TAX_ID_ASSOCIATION_LIMIT_EXCEEDED = 0x8016620C;

        // Access denied.
        public const uint XONLINE_E_BILLING_NOPERMISSION = 0x80162711;

        // Cannot remove self from object.
        public const uint XONLINE_E_BILLING_CANNOT_REMOVE_SELF = 0x80162712;

        // XML is either malformed or incorrect for this API.
        public const uint XONLINE_E_BILLING_BADXML = 0x80162713;

        // Comment text length must be between 1 and 512 characters.
        public const uint XONLINE_E_BILLING_INVALIDCOMMENTSIZE = 0x80162714;

        // Invalid cancellation mode.
        public const uint XONLINE_E_BILLING_BADCANCELMODE = 0x80162715;

        // Input parameter is the wrong size.
        public const uint XONLINE_E_BILLING_INVALID_BUF_SIZE = 0x80162716;

        // Invalid role.
        public const uint XONLINE_E_BILLING_INVALID_ROLE = 0x80162717;

        // Invalid Passport ID.
        public const uint XONLINE_E_BILLING_INVALID_PPORT_ID = 0x80162718;

        // Invalid argument.
        public const uint XONLINE_E_BILLING_INVALID_ARG = 0x8016271A;

        // Unknown server failure. API name: %2, Error code: 0x%3, Error description: %1.
        public const uint XONLINE_E_BILLING_UNKNOWN_SERVER_FAILURE = 0x8016271F;

        // Status must be ENABLED or SUSPENDED.
        public const uint XONLINE_E_BILLING_INVALID_STATUS_VALUE = 0x80162720;

        // Filter must be BASE, UPGRADE, DOWNGRADE, RENEWAL, or empty.
        public const uint XONLINE_E_BILLING_INVALID_FILTER = 0x80162721;

        // Missing category.
        public const uint XONLINE_E_BILLING_MISSING_CATEGORY = 0x80162722;

        // Input field is too short.
        public const uint XONLINE_E_BILLING_FIELD_TOO_SHORT = 0x80162723;

        // Input field is too long.
        public const uint XONLINE_E_BILLING_FIELD_TOO_LONG = 0x80162724;

        // Invalid ZIP code.
        public const uint XONLINE_E_BILLING_BADZIP = 0x80162725;

        // Only one of these nodes should be passed.
        public const uint XONLINE_E_BILLING_ONLYONENODE = 0x80162726;

        // Input field length does not meet requirement.
        public const uint XONLINE_E_BILLING_INVALID_FIELD_LENGTH = 0x80162727;

        // Only customer service representatives can invoke this API.
        public const uint XONLINE_E_BILLING_CSR_AUTHZ_FAILED = 0x80162728;

        // Caller is not an account administrator.
        public const uint XONLINE_E_BILLING_NOT_ACCOUNT_ADMIN = 0x80162729;

        // Delegate ID entered was invalid or not specified.
        public const uint XONLINE_E_BILLING_DELEGATE_ID_UNSPECIFIED = 0x8016272A;

        // Requester Passport ID must be specified.
        public const uint XONLINE_E_BILLING_REQUESTER_ID_UNSPECIFIED = 0x8016272B;

        // Boolean value must be 0 or 1
        public const uint XONLINE_E_BILLING_INVALID_FLAG_VALUE = 0x8016272C;

        // Subscription service instance is inactive.
        public const uint XONLINE_E_BILLING_PROVISIONING_INACTIVE_SUBSCRIPTION = 0x8016272D;

        // Invalid object.
        public const uint XONLINE_E_BILLING_INVALID_OBJECT_ID = 0x8016272E;

        // Input field length of first name does not meet requirement.
        public const uint XONLINE_E_BILLING_INVALID_FIRSTNAME_FIELD_LENGTH = 0x8016272F;

        // Input field length of last name does not meet requirement.
        public const uint XONLINE_E_BILLING_INVALID_LASTNAME_FIELD_LENGTH = 0x80162730;

        // Input field length of address does not meet requirement.
        public const uint XONLINE_E_BILLING_INVALID_ADDRESS_FIELD_LENGTH = 0x80162731;

        // Calling partner is not registered in SPS database.
        public const uint XONLINE_E_BILLING_PARTNERNOTINBILLING = 0x80162738;

        // Rating error has occurred. Check the event log and the tracer.
        public const uint XONLINE_E_BILLING_RATING_FAILURE = 0x8016273D;

        // BDKSVR2 started.
        public const uint XONLINE_E_BILLING_R2_STARTED = 0x80162742;

        // CSR call made.
        public const uint XONLINE_E_BILLING_R_API_CALL_MADE = 0x80162743;

        // CSR call attempt by non-CSR caller.
        public const uint XONLINE_E_BILLING_CSR_CALL_FROM_NONCSR = 0x80162744;

        // "From" and "to" payment instrument are not on the same account in TransferBalance.
        public const uint XONLINE_E_BILLING_TRANS_BALANCE_MISMATCHING_ACCTS = 0x8016274C;

        // Invalid "to" payment instrument in TransferBalance.
        public const uint XONLINE_E_BILLING_TRANS_BALANCE_TO_PI_INVALID = 0x80162751;

        // Cannot transfer to same payment instrument in TransferBalance.
        public const uint XONLINE_E_BILLING_TRANS_BALANCE_TO_SAME_PI = 0x80162756;

        // Cannot transfer balances between payment instrument types.
        public const uint XONLINE_E_BILLING_TRANS_BALANCE_NOT_ALLOW = 0x8016275B;

        // Internal database inconsistencies detected.
        public const uint XONLINE_E_BILLING_INTERNAL_ERROR = 0x80162760;

        // Payment instrument has outstanding balance.
        public const uint XONLINE_E_BILLING_OUTSTANDING_BALANCE = 0x80162765;

        // Invalid  data passed in ReferralData node. Verify that the node exists and that it contains valid XML (1-1024 characters).
        public const uint XONLINE_E_BILLING_INVALID_REFERRALDATA_XML = 0x8016276A;

        // Invalid GUID.
        public const uint XONLINE_E_BILLING_INVALID_GUID = 0x8016276F;

        // Payment instrument type not supported for SettleBalance.
        public const uint XONLINE_E_BILLING_UNSUPPORTED_PAYMENT_INSTRUMENT = 0x80162774;

        // Subscription is inactive.
        public const uint XONLINE_E_BILLING_SUBSCRIPTION_INACTIVE = 0x80162779;

        // Payments can only be stopped for credit card and direct debit transactions.
        public const uint XONLINE_E_BILLING_INVALID_PM_FOR_STOP_PAYMENTS = 0x8016277E;

        // Excessive number of usage events reported in one ReportUsageEvent() call.
        public const uint XONLINE_E_BILLING_EXCEEDS_MAX_NUMBER_OF_USAGE_EVENTS = 0x80162783;

        // Field cannot be updated.
        public const uint XONLINE_E_BILLING_FIELD_NOT_UPDATEABLE = 0x80162788;

        // Calling CancelSubscription with an end date and in compute-only mode is not supported.
        public const uint XONLINE_E_BILLING_DEFERRED_COMPUTE_ONLY_NOT_SUPPORTED = 0x8016278D;

        // The SETTLE event should be the last event in the event list for ImportSettleBillingItems.
        public const uint XONLINE_E_BILLING_SETTLE_SHOULD_BE_THE_LAST_EVENT = 0x8016278E;

        // Line item payment method is no longer valid.
        public const uint XONLINE_E_BILLING_PAYMENT_METHOD_NO_LONGER_VALID = 0x8016278F;

        // Failed to process all usage events.
        public const uint XONLINE_E_BILLING_PROCESS_USAGE_EVENTS = 0x80162790;

        // Object ID does not contain account and subscription information.
        public const uint XONLINE_E_BILLING_WRONG_OBJECT_ID_TYPE = 0x80162791;

        // Field contains invalid characters for a phone number.
        public const uint XONLINE_E_BILLING_INVALID_PHONE_VALUE = 0x80162792;

        // Invalid amount.
        public const uint XONLINE_E_BILLING_INVALID_AMOUNT_VALUE = 0x80162797;

        // Payment instrument ID and line item ID do not match.
        public const uint XONLINE_E_BILLING_MISMATCH_ACCTID_IN_CLOSEBALANCE = 0x80162793;

        // InternalAddComment failed. Escalate error to SPG development.
        public const uint XONLINE_E_BILLING_INTERNAL_ADD_COMMENT_FAILED = 0x80162794;

        // Immediate settle flag value not supported.
        public const uint XONLINE_E_BILLING_INVALID_IMMEDIATE_SETTLE_VALUE = 0x80162795;

        // No eligible records were found for this call.
        public const uint XONLINE_E_BILLING_NO_RECORDS_FOR_STOP_PAYMENTS = 0x8016279C;

        // Failed to update the settlement amount table with credit card authorization results. This needs to be escalated to SPG development.
        public const uint XONLINE_E_BILLING_FAILED_SETTLEMENT_AMOUNT_UPDATE = 0x801627A6;

        // The supplied telenumeric string does not consist of digits exclusively or exceeds the maximum limit.
        public const uint XONLINE_E_BILLING_INVALID_TELENUMERIC_STRING = 0x801627B0;

        // There are no matches for the requested information.
        public const uint XONLINE_E_BILLING_NO_MATCH = 0x801627BA;

        // There are multiple matches for the requested information.
        public const uint XONLINE_E_BILLING_MULTIPLE_MATCHES = 0x801627C4;

        // PUID entered was invalid.
        public const uint XONLINE_E_BILLING_BAD_PUID = 0x801627CE;

        // ObjectId length must be 16.
        public const uint XONLINE_E_BILLING_BAD_OBJECT_ID_LENGTH = 0x801627D9;

        // Start period can never be greater than End period.
        public const uint XONLINE_E_BILLING_END_PERIOD_LESS_THAN_START_PERIOD = 0x801627DA;

        // Billing period length must be 6.
        public const uint XONLINE_E_BILLING_BAD_BILLING_PERIOD_LENGTH = 0x801627DB;

        // Value for returnStatementSet parameter for GetStatement API must be 0, 1, or 2.
        public const uint XONLINE_E_BILLING_BAD_RETURN_STATEMENT_SET = 0x801627DC;

        // The usage event date specified was invalid.  One possible reason is that it is too far in the future.
        public const uint XONLINE_E_BILLING_INVALID_USAGE_EVENT_DATE = 0x801627DF;

        // The default billing period returned was null, cannot proceed. This could be due to the current date time being less than the account creation date.
        public const uint XONLINE_E_BILLING_NULL_DEFAULT_BILLING_PERIOD = 0x801627E0;

        // The start billing period is less than the currently available billing period.
        public const uint XONLINE_E_BILLING_BAD_START_BILLING_PERIOD = 0x801627E1;

        // The end billing period is less than the currently available billing period.
        public const uint XONLINE_E_BILLING_BAD_END_BILLING_PERIOD = 0x801627E2;

        // The new due date is in the past
        public const uint XONLINE_E_BILLING_NEW_DUE_DATE_IS_PAST = 0x801627E7;

        // The new due date is more than MAXIMUM DELAY days in the future than the original due date
        public const uint XONLINE_E_BILLING_NEW_DUE_DATE_THRESHOLD_PASSED = 0x801627EC;

        // If the applydeclineEffect is off, we need a new due date specified
        public const uint XONLINE_E_BILLING_NO_NEW_DUE_DATE_SPECIFIED = 0x801627F1;

        // Invalid transaction type
        public const uint XONLINE_E_BILLING_INVALID_TRANSACTION_TYPE = 0x801627F6;

        // Invalid reason code
        public const uint XONLINE_E_BILLING_INVALID_REASON_CODE = 0x801627FB;

        // Initialization of group SIDs from AD failed. It may indicate user group configuration is not correct or DNS failure.
        public const uint XONLINE_E_BILLING_GROUP_SID_INITIALIZATION_FAILED = 0x8016280B;

        // This operation is not valid for wholesale payment instruments.
        public const uint XONLINE_E_BILLING_INVALID_OPERATION_FOR_WHOLESALE_PI = 0x8016280C;

        // This operation is not valid for direct debit payment instrument.
        public const uint XONLINE_E_BILLING_INVALID_OPERATION_FOR_DIRECT_DEBIT = 0x8016280D;

        // Adjustment amount exceeds the resource credit limit.
        public const uint XONLINE_E_BILLING_EXCEEDS_RESOURCE_CREDIT_LIMIT = 0x8016280E;

        // Adjusting a resource balance is not allowed for subscriptions that are not active.
        public const uint XONLINE_E_BILLING_ADJUST_RESOURCE_BALANCE_FOR_NONACTIVE_SUBS = 0x8016280F;

        // Failed to create mail record for account: %1.
        public const uint XONLINE_E_BILLING_FAILED_TO_CREATE_MAIL_RECORD = 0x80162810;

        // This MSNIA usage event is for a billing period that is not active, in other words late usage is being reported but not billed.
        public const uint XONLINE_E_BILLING_MSNIA_LATE_USAGE = 0x80162811;

        // Failed to write asynchronous immediate settlement failure into the audit db for account: %1.
        public const uint XONLINE_E_BILLING_FAILED_TO_WRITE_TO_AUDIT_DB = 0x80162812;

        // This offering is not configured as a referral offer.
        public const uint XONLINE_E_BILLING_INVALID_REFERRAL_OFFER = 0x8016ABCC;

        // Reward referral XML is required as this is a referral based offer.
        public const uint XONLINE_E_BILLING_REWARD_REFERRAL_XML_REQUIRED = 0x80162813;

        // Referral PUID not found.
        public const uint XONLINE_E_BILLING_REFERRER_NOT_IN_SYSTEM = 0x80162814;

        // Referrer has exceeded the max number of referrals configured on the offer.
        public const uint XONLINE_E_BILLING_REFERRER_EXCEEDED_MAX_REFERRALS_ON_OFFER = 0x80162815;

        // The referrer does not have an Active or Locked account in the system.
        public const uint XONLINE_E_BILLING_REFERRER_NOT_ACTIVE = 0x80162816;

        // The referrer cannot refer self for the offer.
        public const uint XONLINE_E_BILLING_CANNOT_REFER_SELF = 0x80162817;

        // The referral xml has reward referral info but the offer is not configured for reward referrals.
        public const uint XONLINE_E_BILLING_OFFER_NOT_CONFIGURED_FOR_REFERRAL = 0x80162818;

        // The reward referral schema in the referral xml is invalid.
        public const uint XONLINE_E_BILLING_INVALID_REWARD_REFFERAL_SCHEMA = 0x80162819;

        // The referrer does not have any eligible offers configured for the reward.
        public const uint XONLINE_E_BILLING_REFERRER_NOT_ELIGIBLE_FOR_REWARD_OFFER = 0x8016281A;

        // Invalid mandate status for SettleBalance.
        public const uint XONLINE_E_BILLING_SETTLE_BALANCE_INVALID_MANDATE_STATUS = 0x8016281B;

        // More than one usage event reported to ReportSingleUsageEvent API
        public const uint XONLINE_E_BILLING_MULTIPLE_USAGE_EVENTS_REPORTED = 0x8016281C;

        // The reported usage is below the threshold in immediate settle usage.
        public const uint XONLINE_E_BILLING_BELOW_IMMEDIATE_SETTLE_MINIMUM = 0x8016281D;

        // ReportUsage cannot be used for immediate settle of usage deals; use ReportSingleUsage.
        public const uint XONLINE_E_BILLING_REPORT_USAGE_WITH_IMMEDIATE_SETTLE = 0x8016281E;

        // ReportUsage cannot be used for prepaid resource; use ReportSingleUsage.
        public const uint XONLINE_E_BILLING_REPORT_USAGE_WITH_PREPAID = 0x8016281F;

        // ReportSingleUsage cannot be used with empty event set.
        public const uint XONLINE_E_BILLING_NO_USAGE_EVENT_REPORTED = 0x80162820;

        // The payment instrument type does not support immediate settlements
        public const uint XONLINE_E_BILLING_IMMEDIATE_SETTLE_NOT_AVAILABLE_FOR_PAYMENT_INSTRUMENT = 0x80162821;

        // The reported resource and unit of measure do not match.
        public const uint XONLINE_E_BILLING_RESOURCE_UNIT_OF_MEASURE_DO_NOT_MATCH = 0x80162822;

        // Invalid  data passed in RedirectInputInfoXML node.
        public const uint XONLINE_E_BILLING_INVALID_REDIRECT_INPUTINFO_XML = 0x80162823;

        // Transaction cannot be cancelled.
        public const uint XONLINE_E_BILLING_TRANSACTION_NOT_CANCELLABLE = 0x80162824;

        // No CDs found.
        public const uint XONLINE_E_BILLING_NO_CDS_FOUND = 0x80162825;

        // Charge descriptor (e.g. credit card descriptor or support info) has invalid characters or length
        public const uint XONLINE_E_BILLING_INVALID_CHARGE_DESCRIPTOR = 0x80162826;

        // This Wholesale payment instrument has no related wholesale partner.
        public const uint XONLINE_E_BILLING_INVALID_WHOLESALEPI = 0x801628A0;

        // This partner is not BOBO wholesale partner.
        public const uint XONLINE_E_BILLING_NOT_BOBOPARTNER = 0x801628A1;

        // This BOBO wholesale partner has no entitle endpoint.
        public const uint XONLINE_E_BILLING_INVALID_BOBOPARTNER = 0x801628A2;

        // The entitlement endpoint web service could not be reached
        public const uint XONLINE_E_BILLING_ENTITLEMENT_ENDPOINT_UNAVAILABLE = 0x801628FA;

        // The entitlement endpoint returned a validation failure
        public const uint XONLINE_E_BILLING_ENTITLEMENT_VALIDATION_FAILED = 0x801628FB;

        // The entitlement endpoint is invalid
        public const uint XONLINE_E_BILLING_INVALID_ENTITLEMENT_ENDPOINT = 0x801628FC;

        // Calling partner does not have permissions to access the sandboxed object
        public const uint XONLINE_E_BILLING_NOT_AUTHORIZED_TO_ACCESS_OBJECT = 0x80169D57;

        // Calling partner does not have permissions to call on behalf of this partner
        public const uint XONLINE_E_BILLING_UNABLE_TO_CALL_ON_BEHALF_OF = 0x80162828;

        // Taxware error. Check the event log and the tracer.
        public const uint XONLINE_E_BILLING_TAXWARE_FAILURE = 0x8016EA60;

        // Address validation error. Check the event log and the tracer.
        public const uint XONLINE_E_BILLING_ADDRESS_VALIDATION_FAILURE = 0x8016EA61;

        // VERAZIP: Invalid ZIP code.
        public const uint XONLINE_E_BILLING_ZIP_INVALID = 0x8016EA6B;

        // VERAZIP: Invalid state code.
        public const uint XONLINE_E_BILLING_STATE_INVALID = 0x8016EA6C;

        // VERAZIP: Missing ZIP code or city name.
        public const uint XONLINE_E_BILLING_ZIP_CITY_MISSING = 0x8016EA6D;

        // VERAZIP: Invalid state code/ZIP code combination.
        public const uint XONLINE_E_BILLING_STATE_ZIP_INVALID = 0x8016EA6E;

        // VERAZIP: Invalid state code/city name combination.
        public const uint XONLINE_E_BILLING_STATE_CITY_INVALID = 0x8016EA6F;

        // VERAZIP: Invalid state code/ZIP code/city name combinations. Both state code/ZIP code and state code/city name were incorrect.
        public const uint XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID = 0x8016EA70;

        // VERAZIP: Invalid state code/ZIP code/city name combination.
        public const uint XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID2 = 0x8016EA71;

        // VERAZIP: Invalid state code/ZIP code/city name combination.
        public const uint XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID3 = 0x8016EA72;

        // VERAZIP: Invalid state code/ZIP code/city name combination. Verify that state code was passed.
        public const uint XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID4 = 0x8016EA73;

        // VERAZIP: Multiple counties exist for state code/ZIP code/city name combination.
        public const uint XONLINE_E_BILLING_MULTIPLE_COUNTIES_FOUND = 0x8016EA7D;

        // VERAZIP: Invalid state code for ZIP code. Changed to correct state code.
        public const uint XONLINE_E_BILLING_ZIP_INVALID_FOR_ENTERED_STATE = 0x8016EA7E;

        // VERAZIP: ZIP code has multiple city names.
        public const uint XONLINE_E_BILLING_STATE_ZIP_COVERS_MULTIPLE_CITIES = 0x8016EA89;

        // VERAZIP: City has multiple ZIP codes.
        public const uint XONLINE_E_BILLING_MULTIPLE_CITIES_FOUND = 0x8016EA8A;

        // Incorrect city name length.
        public const uint XONLINE_E_BILLING_BAD_CITYNAME_LENGTH = 0x8016EA8B;

        // Incorrect country code length.
        public const uint XONLINE_E_BILLING_BAD_COUNTRYCODE_LENGTH = 0x8016EA8C;

        // Incorrect code length for state or province.
        public const uint XONLINE_E_BILLING_BAD_STATECODE_LENGTH = 0x8016EA8D;

        // Incorrect zip code length.
        public const uint XONLINE_E_BILLING_BAD_ZIPCODE_LENGTH = 0x8016EA8E;

        // Incorrect product code length.
        public const uint XONLINE_E_BILLING_BAD_PRODUCTCODE_LENGTH = 0x8016EA8F;

        // Incorrect business location code length.
        public const uint XONLINE_E_BILLING_BAD_BUSINESSLOCATIONCODE_LENGTH = 0x8016EA90;

        // Incorrect transaction date length.
        public const uint XONLINE_E_BILLING_BAD_TRANSACTIONDATE_LENGTH = 0x8016EA91;

        // Incorrect VAT registration length.
        public const uint XONLINE_E_BILLING_BAD_VATREGISTRATION_LENGTH = 0x8016EA92;

        // Incorrect currency code length.
        public const uint XONLINE_E_BILLING_BAD_CURRENCYCODE_LENGTH = 0x8016EA93;

        // Incorrect WorldTax code length.
        public const uint XONLINE_E_BILLING_BAD_WTCODE_LENGTH = 0x8016EA94;

        // Invalid input parameter passed to TaxWare or VeraZip.
        public const uint XONLINE_E_BILLING_INVALID_INPUT_TO_TAXWARE_OR_VERAZIP = 0x8016EA95;

        // The Vat ID provided is of invalid format.
        public const uint XONLINE_E_BILLING_INVALID_VATID_FORMAT = 0x8016EA97;

        // The Vat ID provided is invalid.
        public const uint XONLINE_E_BILLING_INVALID_VATID_INVALID = 0x8016EA98;

        // Input string contains unsupported characters.
        public const uint XONLINE_E_BILLING_UNSUPPORTED_CHAR_EXIST = 0x8016EA9C;

        // Country code in Address does not match with the country code in Account Info.
        public const uint XONLINE_E_BILLING_ERROR_COUNTRYCODE_MISMATCH = 0x8016EAA1;

        // A Country code is required in Account Info.
        public const uint XONLINE_E_BILLING_ERROR_COUNTRYCODE_REQUIRED = 0x8016EAA6;

        // Token passed is Invalid.
        public const uint XONLINE_E_BILLING_INVALID_TOKEN_SPECIFIED = 0x8016138D;

        // The token is already blacklisted.
        public const uint XONLINE_E_BILLING_TOKEN_ALREADY_BLACKLISTED = 0x80161392;

        // The token is already un-blacklisted.
        public const uint XONLINE_E_BILLING_TOKEN_ALREADY_UNBLACKLISTED = 0x80161393;

        // The specified token has been blacklisted.
        public const uint XONLINE_E_BILLING_TOKEN_BLACKLISTED = 0x801613BF;

        // The specified token belongs to a blacklisted token range.
        public const uint XONLINE_E_BILLING_TOKEN_RANGE_BLACKLISTED = 0x801613C4;

        // The usage for the specified token has been exceeded.
        public const uint XONLINE_E_BILLING_USAGE_COUNT_FOR_TOKEN_EXCEEDED = 0x801613C9;

        // Token Expiry date not set as may be duration based token was not activated correctly.
        public const uint XONLINE_E_BILLING_TOKEN_EXPIRY_DATE_SET_AS_NULL = 0x801613CE;

        // Failed while consumption to create an entry in token_instance_deal_subscription table.
        public const uint XONLINE_E_BILLING_FAILED_INSERTING_TOKEN_INS_DEAL_SUBS = 0x801613CF;

        // Not found non-active token range to be activated.
        public const uint XONLINE_E_BILLING_ACTIVATE_TOKEN_RANGE_NOT_PRESENT = 0x801613D3;

        // The specified token has expired.
        public const uint XONLINE_E_BILLING_TOKEN_EXPIRED = 0x801613F1;

        // The specified token cannot be used yet.
        public const uint XONLINE_E_BILLING_TOKEN_NOT_STARTED = 0x801613F6;

        // The specified token has not been activated yet.
        public const uint XONLINE_E_BILLING_TOKEN_RANGE_NOT_ACTIVE = 0x801613FB;

        // The reason code specified is not valid.
        public const uint XONLINE_E_BILLING_INVALID_BLACKLIST_HISTORY_REASON_CODE = 0x8016141E;

        // The specified action is in progress.
        public const uint XONLINE_E_BILLING_TRACKING_GUID_NODATA = 0x8016145A;

        // The specified tracking has already been used
        public const uint XONLINE_E_BILLING_DUPLICATE_TOKEN_TRACKING_GUID = 0x8016145F;

        // The specified token has already been activated
        public const uint XONLINE_E_BILLING_ALREADY_ACTIVATED = 0x8016146E;

        // Committed status is not valid for this API.
        public const uint XONLINE_E_BILLING_INVALID_COMMITTED_STATUS = 0x80161470;

        // The description specified is not valid.
        public const uint XONLINE_E_BILLING_INVALID_BLACKLIST_HISTORY_DESCRIPTION = 0x80161473;

        // Blacklist Effective date passed was prior to the order creation date.
        public const uint XONLINE_E_BILLING_BLACKLIST_EFFECTIVE_DATE_LESS_THAN_ORDER_CREATION_DATE = 0x80161478;

        // The Token has been consumed.
        public const uint XONLINE_E_BILLING_TOKEN_CONSUMED = 0x8016147D;

        // Part Number specified for the token import is not a valid part number for the associated token class.
        public const uint XONLINE_E_BILLING_INVALID_PART_NUMBER_FOR_TOKEN_CLASS = 0x80161482;

        // External reference id is too long or invalid.
        public const uint XONLINE_E_BILLING_INVALID_EXTERNAL_REFERENCE_ID = 0x80161483;

        // The token is already deactivated.
        public const uint XONLINE_E_BILLING_TOKEN_ALREADY_DEACTIVATED = 0x80161487;

        // Token Passed in for consumption is a replacement token for which PUID specified at the time of replacement does not match the account admin PUID.
        public const uint XONLINE_E_BILLING_REPLACEMENT_TOKEN_PUID_MISMATCH = 0x80161491;

        // Null parameter was passed for Token Class GUID during token class access verification.
        public const uint XONLINE_E_BILLING_NULL_INPUT_PARAMETER_TOKEN_CLASS_GUID = 0x80161496;

        // The argument specified is not a valid bookmark.
        public const uint XONLINE_E_BILLING_INVALID_BOOKMARK = 0x80161484;

        // The max argument must be between 1 and 50.
        public const uint XONLINE_E_BILLING_INVALID_MAX = 0x80161485;

        // Internal inconsistency in Token Database.
        public const uint XONLINE_E_BILLING_INTERNAL_ERROR_TOKEN = 0x80161455;

        // Unable to retrieve event ID and billing impact for event.
        public const uint XONLINE_E_BILLING_PROCESSIMPORT_OFFSET_LINE_MISSING_FIELD = 0x8016CD14;

        // Unable to find line item matching event.
        public const uint XONLINE_E_BILLING_PROCESSIMPORT_OFFSET_LINE_MISSING_MATCH_EVENT = 0x8016CD46;

        // Cannot process if there is an offset of an offset.
        public const uint XONLINE_E_BILLING_CANCELREFUND_OFFSET_OF_OFFSET = 0x8016CD78;

        // This can't happen, both line item and related line item in the active list.
        public const uint XONLINE_E_BILLING_CANCELREFUND_BOTH_LINE_AND_RELATED_LINE = 0x8016CDAA;

        // The session key passed in does not pass validation checks.
        public const uint XONLINE_E_BILLING_INVALID_SESSION_KEY = 0x8016768E;

        // This object ID is not entitled to get a deliverable token.
        public const uint XONLINE_E_BILLING_NO_PRODUCT_KEY_FOR_OBJECT_ID = 0x8016A0B4;

        // The token cannot be issued, either because the database is unavailable or there are no more unused tokens.
        public const uint XONLINE_E_BILLING_PRODUCT_KEY_NOT_AVAILABLE = 0x80161488;

        // Either PIN or Sequence number is required as input parameter to validate Token.
        public const uint XONLINE_E_BILLING_PIN_OR_SEQ_REQUIRED = 0x80161489;

        // Either Token Class Guid or Signature or Part Number should be specified for validating Token.
        public const uint XONLINE_E_BILLING_INPUT_PARAM_MALFORMED = 0x8016148A;

        // The offset must be between -1 and 365 inclusive.
        public const uint XONLINE_E_BILLING_INVALID_ADJUSTMENT_OFFSET = 0x8016CDB7;

        // Invalid item instance ID.
        public const uint XONLINE_E_BILLING_INVALID_ITEM_INSTANCE_ID = 0x8016CDDC;

        // Invalid reason for reverse operation.
        public const uint XONLINE_E_BILLING_INVALID_REVERSE_REASON = 0x8016CDDD;

        // Only 1 item can be purchased at once.
        public const uint XONLINE_E_BILLING_TOO_MANY_ITEMS_IN_PURCHASE = 0x8016CDE0;

        // PurchaseItem accepts only offers that are configured for item, PurchaseSubscription accepts only subscription offers and the account must be specified, or free trial offer and account must not be specified.
        public const uint XONLINE_E_BILLING_INVALID_OFFERING_TYPE = 0x8016CDE1;

        // The price specified must be a positive value.
        public const uint XONLINE_E_BILLING_PRICE_IS_NEGATIVE = 0x8016CDE2;

        // Cannot pass in a price and/or currency because it is configured on the item.
        public const uint XONLINE_E_BILLING_DYNAMIC_PRICE_CONFIGURATION = 0x8016CDE3;

        // The maximum allowable DMP point balance is exceeded.
        public const uint XONLINE_E_BILLING_DMP_MAX_BALANCE_EXCEEDED = 0x8016CDE4;

        // Calling partner needs to add a currency because it is not pre-configured.
        public const uint XONLINE_E_BILLING_CURRENCY_MISSING = 0x8016CDE5;

        // The user already has a pending purchase for for this item that must first be cancelled or completed.
        public const uint XONLINE_E_BILLING_PENDING_ITEM_PURCHASE = 0x8016CDE6;

        // Unable to talk to DMP system.
        public const uint XONLINE_E_BILLING_DMP_FLOW_NOT_ENABLED = 0x8016CDE7;

        // Item has been already reversed.
        public const uint XONLINE_E_BILLING_ITEM_ALREADY_REVERSED = 0x8016CDE8;

        // Reversing an item that has not been fulfilled.
        public const uint XONLINE_E_BILLING_ITEM_NOT_FULFILLED = 0x8016CDE9;

        // Unknown DMP error has occurred.
        public const uint XONLINE_E_BILLING_DMP_UNKNOWN_ERROR = 0x8016CDEA;

        // Payment method type does not support operation.
        public const uint XONLINE_E_BILLING_ACTION_NOT_APPLICABLE_FOR_PAYMENT_TYPE = 0x8016CDEC;

        // Redirect vendor returned an invalid CancelTransaction result.
        public const uint XONLINE_E_BILLING_INVALID_CANCEL_TRANSACTION_RESULT = 0x8016CDED;

        // CVM code Missing
        public const uint XONLINE_E_BILLING_CVM_MISSING = 0x8016CDEE;

        // A fre Trial cannot be purchased using an account. Use only the PUID
        public const uint XONLINE_E_BILLING_ACCOUNT_CANNOT_PURCHASE_FREE_TRIAL = 0x8016CDEF;

        // Countries in the billable account (in payment method XML) of the donor and the Points account of the beneficiary mismatch
        public const uint XONLINE_E_BILLING_DONOR_BENEFICIARY_COUNTRY_MISMATCH = 0x8016CDF0;

        // The donor and the beneficiary are the same.
        public const uint XONLINE_E_BILLING_DONOR_BENEFICIARY_SAME = 0x8016CDF1;

        // The renewal does not exists.
        public const uint XONLINE_E_BILLING_RENEWAL_DOES_NOT_EXISTS = 0x8016AC9A;

        // The token schedule rennewal exists for this offer.
        public const uint XONLINE_E_BILLING_TOKEN_SCHEDULED_RENEWAL_EXISTS = 0x8016AC9C;

        // Specified Discount is invalid.
        public const uint XONLINE_E_BILLING_INVALID_DISCOUNT = 0x8016ACAD;

        // Could not insert into a discount table.
        public const uint XONLINE_E_BILLING_INSERT_DISCOUNT = 0x8016ACB2;

        // Only one discount permitted per subscription.
        public const uint XONLINE_E_BILLING_DISCOUNT_ALREADY_APPLIED = 0x8016ACB7;

        // Token is a discount coupon yet no discount was passed.
        public const uint XONLINE_E_BILLING_DISCOUNT_REQUIRED_FOR_TOKEN = 0x8016ACBC;

        // Token is a discount coupon and cannot be associated with a deal.
        public const uint XONLINE_E_BILLING_DISCOUNT_TOKEN = 0x8016ACC1;

        // Failed to insert record into discount_localize table.
        public const uint XONLINE_E_BILLING_INSERT_DISCOUNT_LOCALIZE = 0x8016ACC6;

        // Per Account Usage limit was exceeded for discount.
        public const uint XONLINE_E_BILLING_DISCOUNT_USAGE_EXCEEDED = 0x8016ACCB;

        // Token class and discount are not a valid combination.
        public const uint XONLINE_E_BILLING_DISCOUNT_TOKEN_CLASS_MISMATCH = 0x8016ACD0;

        // Partner does not have access to the specified customer type
        public const uint XONLINE_E_BILLING_INVALID_CUSTOMER_TYPE_FOR_PARTNER = 0x8016AD18;

        // Category should not be null.
        public const uint XONLINE_E_BILLING_NULL_CATEGORY = 0x8016AC62;

        // Account ID cannot be null.
        public const uint XONLINE_E_BILLING_NULL_ACCOUNTID = 0x8016AC63;

        // Subscription Ref ID cannot be null.
        public const uint XONLINE_E_BILLING_NULL_SUBSCRIPTIONREFID = 0x8016AC64;

        // Invalid Survey Result Code.
        public const uint XONLINE_E_BILLING_INVALID_SURVEYRESULTCODE = 0x8016AC65;

        // CD not found.
        public const uint XONLINE_E_BILLING_CD_NOTFOUND = 0x8016AC66;

        // Invalid Account ID.
        public const uint XONLINE_E_BILLING_INVALID_ACCOUNTID = 0x8016AC67;

        // Invalid AnonymousInfo Xml.
        public const uint XONLINE_E_BILLING_INVALID_ANONYMOUS_INFO_XML = 0x8016AC68;

        // Unsupported object type.
        public const uint XONLINE_E_BILLING_UNSUPPORTED_OBJECT_TYPE = 0x8016AC69;

        // Invalid Phone XML.
        public const uint XONLINE_E_BILLING_INVALID_PHONE_XML = 0x8016AC6A;

        // Invalid requestor info. Valid Requestor Info has a size limit of 256 Characters.
        public const uint XONLINE_E_BILLING_INVALID_REQUESTOR_INFO = 0x8016AC6C;

        // There are pending transactions on this deal or subscription.
        public const uint XONLINE_E_BILLING_PENDING_TRANSACTIONS = 0x8016ACAA;

        // The lineitem id and settlement id do not match
        public const uint XONLINE_E_BILLING_LINEITEM_SETTLEMENT_AMOUNT_NOT_MATCH = 0x801652D0;

        // Invalid original charge details
        public const uint XONLINE_E_BILLING_INVALID_ORIGINAL_CHARGE_DETAILS = 0x801652D5;

        // Partial Chargeback cannot be Processed
        public const uint XONLINE_E_BILLING_PARTIAL_CHAREGBACK = 0x801652D8;

        // Invalid lineitem id for reversal
        public const uint XONLINE_E_BILLING_INVALID_LINEITEM_ID_FOR_REVERSAL = 0x801652DA;

        // Invalid chargeback date. Chargeback date must greater or equals to original settlement date
        public const uint XONLINE_E_BILLING_INVALID_CHARGEBACK_DATE = 0x801652E9;

        // Invalid chargeback amount.
        public const uint XONLINE_E_BILLING_INVALID_CHARGEBACK_AMOUNT = 0x801652EE;

        // Tax was already offset for this line item.
        public const uint XONLINE_E_BILLING_ALREADY_OFFSET_TAX = 0x801652F1;

        // mappoint is not enabled for the country code.
        public const uint XONLINE_E_BILLING_COUNTRY_CODE_MAPPOINT_NOT_ENABLED = 0x80169CEB;

        // SCS had error connecting to mappoint due to some network problems.
        public const uint XONLINE_E_BILLING_NETWORK_ERROR_CONNECTING_TO_MAPPOINT = 0x8016CE4F;

        // SCS had some internal error connecting that is preventing connection to mappoint.
        public const uint XONLINE_E_BILLING_INTERNAL_ERROR_CONNECTING_TO_MAPPOINT = 0x8016CE50;

        // Mappoint returned 0 addresses.
        public const uint XONLINE_E_BILLING_ZERO_ADDRESSES_BY_MAPPOINT = 0x8016CE51;

        // UNKNOWN ERROR in MAPPOINT API.
        public const uint XONLINE_E_BILLING_UNKNOWN_ERROR = 0x8016CE52;

        // UNKNOWN ERROR ENCOUNTERED.
        public const uint XONLINE_E_BILLING_UPDATE_ADDRESS_UNKNOWN_ERROR = 0x8016ACA4;

        // Invalid AddressInfo Xml.
        public const uint XONLINE_E_BILLING_INVALID_ADDRESSINFOXML = 0x8016CE54;

        // Mappoint does not support Post Box Addresses currently.
        public const uint XONLINE_E_BILLING_POST_BOX_ERROR_MAPPOINT = 0x8016CE55;

        // The connection to Mappoint has timed out.
        public const uint XONLINE_E_BILLING_MAPPOINT_CONNECTION_MAPPOINT = 0x8016CE56;

        // Invalid Chargeback details provided as input
        public const uint XONLINE_E_BILLING_ERROR_INVALID_CHARGEBACK_INPUT_DETAILS = 0x8016D818;

        // Chargeback id not found
        public const uint XONLINE_E_BILLING_CHARGEBACK_NOT_FOUND = 0x8016D81D;

        // Chargeback id did not match
        public const uint XONLINE_E_BILLING_CHARGEBACK_NOT_MATCH = 0x8016D827;

        // Double chargeback
        public const uint XONLINE_E_BILLING_DOUBLE_CHARGEBACK = 0x8016D836;

        // Invalid chargebacklineitem id
        public const uint XONLINE_E_BILLING_INVALID_CHARGEBACK_LINEITEM_ID = 0x8016D83B;

        // Invalid reversal chargeback id
        public const uint XONLINE_E_BILLING_INVALID_CHARGEBACK_REVERSAL_ID = 0x8016D84A;

        // Invalid chargeback for reversal chargeback id
        public const uint XONLINE_E_BILLING_INVALID_CHARGEBACK_ID_FOR_REVERSAL_CHARGEBACK_ID = 0x8016D84F;

        // invalid lineitem id for chargeback id
        public const uint XONLINE_E_BILLING_INVALID_LINEITEM_ID_FOR_CHARGEBACK_ID = 0x8016D854;

        // invalid lineitem id
        public const uint XONLINE_E_BILLING_INVALID_LINEITEM_TYPE = 0x8016D859;

        // Double chargeback for reversal
        public const uint XONLINE_E_BILLING_DOUBLE_CHARGEBACK_FOR_REVERSAL = 0x8016D868;

        // The country of the address is not supported at this time
        public const uint XONLINE_E_BILLING_COUNTRY_NOT_SUPPORTED = 0x8016ACA5;

        // SCS has temporarily disabled MAPPOINT support for this country
        public const uint XONLINE_E_BILLING_COUNTRY_MAPPOINT_DISABLED = 0x8016ACA6;

        // The input parameter is incorrect
        public const uint XONLINE_E_BILLING_INVALID_PARAMETER = 0x8016ACA7;

        // Invalid ChargebackID Generation.
        public const uint XONLINE_E_BILLING_INVALID_CHARGEBACK_ID = 0x8016283C;

        // Error when Chargeback Processing Failure.
        public const uint XONLINE_E_BILLING_CHARGEBACK_PROCESSING_FAILURE = 0x8016283D;

        // Invalid Merchant Reference Number.
        public const uint XONLINE_E_BILLING_INVALID_MERCHANT_REFERENCE = 0x8016283E;

        // Error when any input details missing.
        public const uint XONLINE_E_BILLING_CHARGEBACK_INFO_MISSING = 0x8016283F;

        // Error while recording chargeback/reversal in Chargeback History table.
        public const uint XONLINE_E_BILLING_RECORD_CHARGEBACK_FAILED = 0x80162840;

        // Double Chargeback Reversal
        public const uint XONLINE_E_BILLING_DOUBLE_CHARGEBACK_REVERSAL = 0x80162841;

        // Chargeback Processing Reversal
        public const uint XONLINE_E_BILLING_REVERSAL_OF_PROCESSED_CHARGEBACK = 0x80162842;

        // Payment instrument not associated with subscription
        public const uint XONLINE_E_BILLING_MISMATCH_PAYMENT_SUBSCRIPTION = 0x80162843;

        // Subscription already converted or renewed
        public const uint XONLINE_E_BILLING_SUBSCRIPTION_ALREADY_CONVERTED_OR_RENEWED = 0x80162844;

        // Merchant Reference Number missing
        public const uint XONLINE_E_BILLING_MERCHANT_REFERENCE_NUMBER_MISSING = 0x80162845;

        // Invalid Encrypt Account number
        public const uint XONLINE_E_BILLING_INVALID_ENCRYPT_ACCOUNT_NUMBER = 0x80162846;

        // Subscription has been scheduled to renew
        public const uint XONLINE_E_BILLING_SUBSCRIPTION_SCHEDULED_RENEWAL = 0x80162847;

        // Account holder's profile already exists.
        public const uint XONLINE_E_BILLING_PROFILE_ALREADY_EXISTS = 0x80162848;

        // Account holder's profile does not exist.
        public const uint XONLINE_E_BILLING_PROFILE_DOES_NOT_EXIST = 0x80162849;

        // Account does not have an address associated with it.
        public const uint XONLINE_E_BILLING_ACCOUNT_WITHOUT_ADDRESS = 0x8016284A;

        // Payout preference (default) is not set.
        public const uint XONLINE_E_BILLING_NO_PAYOUT_PREFERENCE = 0x8016284B;

        // Payout preference (default) can not be deleted.
        public const uint XONLINE_E_BILLING_CAN_NOT_DELETE_DEFAULT_PAYOUT_PREFERENCE = 0x8016284C;

        // Invalid PayUserInfo XML.
        public const uint XONLINE_E_BILLING_INVALID_PAYUSERINFOXML = 0x8016284D;

        // Invalid UserProfile XML.
        public const uint XONLINE_E_BILLING_INVALID_USERPROFILEXML = 0x8016284E;

        // Account ID must not be specified.
        public const uint XONLINE_E_BILLING_CANNOT_SPECIFY_BILLABLE_ACCOUNT_ID = 0x8016284F;

        // Description length exceeded
        public const uint XONLINE_E_BILLING_DESCRIPTION_MAXLENGTH_EXCEEDED = 0x80162850;

        // RiME returns "Rejected"
        public const uint XONLINE_E_BILLING_RIME_REJECTED = 0x80162851;

        // Invalid Values were sent to RiME
        public const uint XONLINE_E_BILLING_RIME_INVALID_VALUE = 0x80162852;

        // Referral code not found in SCS database
        public const uint XONLINE_E_BILLING_REFERRAL_CODE_NOT_FOUND = 0x8016AC59;

        // There is no existing provisioning information to complete this call
        public const uint XONLINE_E_BILLING_MISSING_PROV_INFO = 0x8016D2FD;

        // Invalid Resource Type
        public const uint XONLINE_E_BILLING_INVALID_RESOURCE_TYPE = 0x8016AC5A;

        // fail when submit to payment provider
        public const uint XONLINE_E_BILLING_PAYMENT_PROVIDER_SUBMISSION_FAILED = 0x80164E2A;

        // declined when submit to payment provider
        public const uint XONLINE_E_BILLING_PAYMENT_PROVIDER_SUBMISSION_DECLINED = 0x80164E2B;

        // fail to encrypt file
        public const uint XONLINE_E_BILLING_ENCRYPTION_FAILURE = 0x80164E2C;

        // BDK_E_DMP_FIRST
        public const uint XONLINE_E_BILLING_DMP_FIRST = 0x8016FA00;

        // BDK_E_DMP_LAST
        public const uint XONLINE_E_BILLING_DMP_LAST = 0x8016FDE7;

        // Invalid target user information specified
        public const uint XONLINE_E_BILLING_INVALID_TARGET_USER_INFORMATION = 0x80167918;

        // Invalid delegate user information
        public const uint XONLINE_E_BILLING_INVALID_DELEGATE_USER_INFORMATION = 0x80167919;

        // Invalid source information
        public const uint XONLINE_E_BILLING_INVALID_SOURCE_USER_INFORMATION = 0x8016791A;

        // Invalid transaction Id
        public const uint XONLINE_E_BILLING_INVALID_TRANSACTION_INFORMATION = 0x8016791B;

        // Transaction information passed in does not match the information stored
        public const uint XONLINE_E_BILLING_NO_MATCHING_TRANSACTION = 0x8016791C;

        // Unable to find transaction in PENDING_PAYOUT state matching the input parameters
        public const uint XONLINE_E_BILLING_NO_MATCHING_PENDINGPAYOUT_TRANSACTION = 0x8016791D;

        // Unable to find transaction in PENDING state matching the input parameters
        public const uint XONLINE_E_BILLING_NO_MATCHING_PENDING_TRANSACTION = 0x8016791E;

        // BDK_E_ORDER_LAYER_FIRST
        public const uint XONLINE_E_BILLING_ORDER_LAYER_FIRST = 0x8016DAC1;

        // BDK_E_ORDER_LAYER_LAST
        public const uint XONLINE_E_BILLING_ORDER_LAYER_LAST = 0x8016DEA8;

        // BDK_E_TRANSACTION_LAYER_FIRST
        public const uint XONLINE_E_BILLING_TRANSACTION_LAYER_FIRST = 0x8016DEA9;

        // BDK_E_TRANSACTION_LAYER_LAST
        public const uint XONLINE_E_BILLING_TRANSACTION_LAYER_LAST = 0x8016E290;

        // SCS_E_CERT_INAVLID
        public const uint XONLINE_E_BILLING_CERT_INAVLID = 0x8016E678;

        // SCS_E_INAVLID_CALLING_PARTNER
        public const uint XONLINE_E_BILLING_INAVLID_CALLING_PARTNER = 0x8016E679;

        // BDK_E_RISK_EVALUATION_FAILED
        public const uint XONLINE_E_BILLING_RISK_EVALUATION_FAILED = 0x8016FDE9;

        // BDK_E_RISK_EVALUATION_EXCEPTION
        public const uint XONLINE_E_BILLING_RISK_EVALUATION_EXCEPTION = 0x8016FDEA;

        // BDK_E_RISK_EVALUATION_UNDEFINED
        public const uint XONLINE_E_BILLING_RISK_EVALUATION_UNDEFINED = 0x8016FDEB;

        // BDK_E_RISK_CONFIGURATION_ERROR
        public const uint XONLINE_E_BILLING_RISK_CONFIGURATION_ERROR = 0x8016FDEC;

        // BDK_E_RISK_NEXT
        public const uint XONLINE_E_BILLING_RISK_NEXT = 0x8016FDED;

        // Apartment number missing or not found
        public const uint XONLINE_E_BILLING_DAV_APARTMENT = 0x8016FE4C;

        // Insufficient address information
        public const uint XONLINE_E_BILLING_DAV_INSUFFICIENT = 0x8016FE4D;

        // House number or PO box not found
        public const uint XONLINE_E_BILLING_DAV_ID = 0x8016FE4E;

        // Multiple address matches found
        public const uint XONLINE_E_BILLING_DAV_MULTIPLE = 0x8016FE4F;

        // PO box identifier out of range
        public const uint XONLINE_E_BILLING_DAV_POBOX = 0x8016FE50;

        // Route service identified out of range
        public const uint XONLINE_E_BILLING_DAV_ROUTE = 0x8016FE51;

        // Street name not found
        public const uint XONLINE_E_BILLING_DAV_STREET = 0x8016FE52;

        // Postal code not found
        public const uint XONLINE_E_BILLING_DAV_POSTAL = 0x8016FE53;

        // Genreal address error
        public const uint XONLINE_E_BILLING_DAV_GENERAL = 0x8016FE54;

        // Missing required address field(s)
        public const uint XONLINE_E_BILLING_DAV_MISSING_DATA = 0x8016FE55;

        // Invalid address field(s)
        public const uint XONLINE_E_BILLING_DAV_INVALID_DATA = 0x8016FE56;

        // System failure during address check
        public const uint XONLINE_E_BILLING_DAV_SYSTEM_FAILURE = 0x8016FE57;

        // Timeout during DAV check
        public const uint XONLINE_E_BILLING_DAV_TIMEOUT = 0x8016FE58;

        // Delivery Address Verification system is not available at this time
        public const uint XONLINE_E_BILLING_DAV_DISABLED = 0x8016FE59;

        // BDK_E_RISK_LAST
        public const uint XONLINE_E_BILLING_RISK_LAST = 0x8016FFFF;

        // CVV reentry required
        public const uint XONLINE_E_BILLING_RISK_CVV_E_REENTRY_REQUIRED = 0x8016FDF0;

        // CVV reentry retryable failure
        public const uint XONLINE_E_BILLING_RISK_CVV_E_REENTRY_FAILED_RETRYABLE = 0x8016FDF1;

        // CVV reentry non retryable failure
        public const uint XONLINE_E_BILLING_RISK_CVV_E_REENTRY_FAILED_NONRETRYABLE = 0x8016FDF2;

     
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\XonCTPHResult.cs ===
using System;

namespace xonline.common.service
{
    /// <summary>
    /// CTP Error codes
    /// If a new error code is added by CTP then corresponding HRESULT needs to be added here as well.
    /// </summary>
    public partial struct HResult
    {
        // "Null input parameter passed to a ban API."
        public const uint XONLINE_E_CTP_BDK_E_BAN_NULL_INPUT_PARAMETER = 0x80190001;
        // "Already banned."
        public const uint XONLINE_E_CTP_BDK_E_ALREADY_BANNED = 0x80190002;
        // "Not banned."
        public const uint XONLINE_E_CTP_BDK_E_NOT_BANNED = 0x80190003;
        // "This account is banned."
        public const uint XONLINE_E_CTP_BDK_E_BANNEDPERSON = 0x80190004;
        // "Country/currency/payment instrument type mismatch."
        public const uint XONLINE_E_CTP_BDK_E_COUNTRY_CURRENCY_PI_MISMATCH = 0x80190005;
        // "Invalid payment instrument type."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PAYMENT_INSTRUMENT_TYPE = 0x80190006;
        // "Invalid credit card type."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CREDIT_CARD_TYPE = 0x80190007;
        // "Decryption failed. Verify that data is encrypted correctly."
        public const uint XONLINE_E_CTP_BDK_E_DECRYPTION_FAILURE = 0x80190008;
        // "Payment instrument is banned."
        public const uint XONLINE_E_CTP_BDK_E_BANNED_PAYMENT_INSTRUMENT = 0x80190009;
        // "Direct debit account validation failed."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_DD_ACCOUNT = 0x80190010;
        // "Concatenated direct debit account number exceeds 24 characters."
        public const uint XONLINE_E_CTP_BDK_E_DD_CONCATENATED_STRING_LENGTH_EXCEEDS_24 = 0x80190011;
        // "Invalid credit card number."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CREDIT_CARD_NUMBER = 0x80190012;
        // "Credit card has already expired."
        public const uint XONLINE_E_CTP_BDK_E_CREDIT_CARD_EXPIRED = 0x80190013;
        // "Address verification failed."
        public const uint XONLINE_E_CTP_BDK_E_AVS_FAILED = 0x80190014;
        // "Address verification through AVS did not provide a result."
        public const uint XONLINE_E_CTP_BDK_E_NO_AVS_RESULT = 0x80190015;
        // "Payment Instrument authorization failed."
        public const uint XONLINE_E_CTP_BDK_E_AUTHORIZATION_FAILED = 0x80190016;
        // "Unable to connect to payment provider."
        public const uint XONLINE_E_CTP_BDK_E_PAYMENT_PROVIDER_CONNECTION_FAILED = 0x80190017;
        // "Invalid country code."
        public const uint XONLINE_E_CTP_BDK_E_DD_INVALID_COUNTRY = 0x80190018;
        // "Invalid account format."
        public const uint XONLINE_E_CTP_BDK_E_DD_INVALID_ACCOUNT_FORMAT = 0x80190019;
        // "Invalid bank code format."
        public const uint XONLINE_E_CTP_BDK_E_DD_INVALID_BANKCODE_FORMAT = 0x80190020;
        // "Invalid branch code format."
        public const uint XONLINE_E_CTP_BDK_E_DD_INVALID_BRANCHCODE_FORMAT = 0x80190021;
        // "Invalid check digit format."
        public const uint XONLINE_E_CTP_BDK_E_DD_INVALID_CHECKDIGIT_FORMAT = 0x80190022;
        // "Account missing."
        public const uint XONLINE_E_CTP_BDK_E_DD_ACCOUNT_MISSING = 0x80190023;
        // "Bank code missing."
        public const uint XONLINE_E_CTP_BDK_E_DD_BANKCODE_MISSING = 0x80190024;
        // "Branch code missing."
        public const uint XONLINE_E_CTP_BDK_E_DD_BRANCHCODE_MISSING = 0x80190025;
        // "Check digit missing."
        public const uint XONLINE_E_CTP_BDK_E_DD_CHECKDIGIT_MISSING = 0x80190026;
        // "Some fields have errors."
        public const uint XONLINE_E_CTP_BDK_E_DD_ERROR_IN_FIELDS = 0x80190027;
        // "Invalid account code."
        public const uint XONLINE_E_CTP_BDK_E_DD_INVALID_ACCOUNT_VALUE = 0x80190028;
        // "Invalid bank code."
        public const uint XONLINE_E_CTP_BDK_E_DD_INVALID_BANKCODE_VALUE = 0x80190029;
        // "Invalid branch code."
        public const uint XONLINE_E_CTP_BDK_E_DD_INVALID_BRANCHCODE_VALUE = 0x80190030;
        // "Invalid check digit."
        public const uint XONLINE_E_CTP_BDK_E_DD_INVALID_CHECKDIGIT_VALUE = 0x80190031;
        // "Account holder name not specified or it exceeds 35 characters."
        public const uint XONLINE_E_CTP_BDK_E_DD_INVALID_ACCOUNT_HOLDER_NAME = 0x80190032;
        // "Soap call to provider failed."
        public const uint XONLINE_E_CTP_BDK_E_DD_UNKNOWN_PROVIDER_FAILURE = 0x80190033;
        // "Payment provider connection timed out."
        public const uint XONLINE_E_CTP_BDK_E_PAYMENT_PROVIDER_CONNECTION_TIMEOUT = 0x80190034;
        // "Transaction declined by payment provider."
        public const uint XONLINE_E_CTP_BDK_E_TRANSACTION_DECLINED_BY_PAYMENT_PROVIDER = 0x80190035;
        // "Payment provider error."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_INITIATE_TRANSACTION_RESULT = 0x80190036;
        // "The wholesale partner specified is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_WHOLESALE_PARTNER = 0x80190037;
        // "PI Not Supported in this version"
        public const uint XONLINE_E_CTP_BDK_E_PI_NOT_SUPPORTED = 0x80190038;
        // "A fatal error occured updating the UPS entries for all PUIDs relating to i_billable_acct_id %1. This account should be investigated and the UPS entries for PUIDs attached to it should be updated manually."
        public const uint XONLINE_E_CTP_BDK_E_UPS_NOT_UPDATED = 0x80190039;
        // "This branch will not support Direct Debit transactions."
        public const uint XONLINE_E_CTP_BDK_E_DD_UNSUPPORTED = 0x80190040;
        // "Internal error
        public const uint XONLINE_E_CTP_BDK_E_DD_MPF_NON_XML_RESPONSE = 0x80190041;
        // "Internal error
        public const uint XONLINE_E_CTP_BDK_E_DD_MPF_INCORRECT_XML_FORMAT = 0x80190042;
        // "Global Collect error
        public const uint XONLINE_E_CTP_BDK_E_DD_GC_NON_XML_RESPONSE = 0x80190043;
        // "Global Collect error
        public const uint XONLINE_E_CTP_BDK_E_DD_GC_INCORRECT_XML_FORMAT = 0x80190044;
        // "Global collect failed to process this request
        public const uint XONLINE_E_CTP_BDK_E_DD_GC_RETURNED_NOK_RESULT = 0x80190045;
        // "Direct Debit account Check performed by Global Collect is not complete for this account."
        public const uint XONLINE_E_CTP_BDK_E_DD_GC_CHECK_INCOMPLETE = 0x80190046;
        // "Global Collect error
        public const uint XONLINE_E_CTP_BDK_E_DD_OPENING_GC_XML_CHECKSPERFORMED = 0x80190047;
        // "Global Collect error
        public const uint XONLINE_E_CTP_BDK_E_DD_GC_XML_INVALID_CHECK_RESULT = 0x80190048;
        // "Global collect returned non null Reformatted Bank Code though the input Bank code was blank."
        public const uint XONLINE_E_CTP_BDK_E_DD_GC_INVALID_RFBANKCODE = 0x80190049;
        // "Invalid payment instrument details."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PAYMENT_INSTRUMENT_DETAILS = 0x80190050;
        // "Invalid ban reason code."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BAN_REASON_CODE = 0x80190051;
        // "Invalid encrypted CVM code."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CVM_CODE = 0x80190052;
        // "Unexpected CVM response code."
        public const uint XONLINE_E_CTP_BDK_E_UNEXPECTED_CVM_RESPONSE_CODE = 0x80190053;
        // "CVM check failed."
        public const uint XONLINE_E_CTP_BDK_E_CVM_FAILED = 0x80190054;
        // "Immediate settlement failed"
        public const uint XONLINE_E_CTP_BDK_E_IMMEDIATE_SETTLEMENT_FAILURE = 0x80190055;
        // "Frequency check failed."
        public const uint XONLINE_E_CTP_BDK_E_FREQUENCY_CHECK_FAILED = 0x80190056;
        // "Invalid merchant index."
        public const uint XONLINE_E_CTP_BDK_E_DD_INVALID_MERCHANT_INDEX = 0x80190057;
        // "Duplicate merchant reference."
        public const uint XONLINE_E_CTP_BDK_E_DD_DUPLICATE_MRN = 0x80190058;
        // "Account validation failed."
        public const uint XONLINE_E_CTP_BDK_E_DD_UNKNOWN_VALIDATION_FAILURE = 0x80190059;
        // "Bank account type may not be specified for this country."
        public const uint XONLINE_E_CTP_BDK_ERROR_DD_BANK_ACCOUNT_TYPE_MUST_BE_NULL = 0x80190060;
        // "Bank account type is required for this country."
        public const uint XONLINE_E_CTP_BDK_ERROR_DD_BANK_ACCOUNT_TYPE_MAY_NOT_BE_NULL = 0x80190061;
        // "Risk check failed."
        public const uint XONLINE_E_CTP_BDK_E_DD_RISK_DECLINE = 0x80190062;
        // "Unable to validate the tax ID."
        public const uint XONLINE_E_CTP_BDK_E_UNABLE_TO_VALIDATE_TAX_ID = 0x80190063;
        // "Number of updates allowed in a period has exceeded the maximum limit."
        public const uint XONLINE_E_CTP_BDK_E_TAX_ID_UPDATE_ATTEMPTS_EXCEEDED = 0x80190064;
        // "External vendor error."
        public const uint XONLINE_E_CTP_BDK_E_EXTERNAL_VENDOR_ERROR = 0x80190065;
        // "Object is already in the specified state."
        public const uint XONLINE_E_CTP_BDK_E_ALREADY_IN_SPECIFIED_STATE = 0x80190066;
        // "Required search criteria field missing. Either a phone number or both first name and last name is required."
        public const uint XONLINE_E_CTP_BDK_E_MISSING_SEARCH_CRITERIA = 0x80190067;
        // "Required field missing."
        public const uint XONLINE_E_CTP_BDK_E_REQUIRED_FIELD_MISSING = 0x80190068;
        // "The account has subscriptions."
        public const uint XONLINE_E_CTP_BDK_E_ACTIVE_SUBSCRIPTIONS = 0x80190069;
        // "Unexpected field"
        public const uint XONLINE_E_CTP_BDK_E_UNEXPECTED_FIELD = 0x80190070;
        // "Invalid account source."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ACCOUNT_SOUCE = 0x80190071;
        // "Creation date/time cannot be later than current date/time."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CREATION_DATE = 0x80190072;
        // "No more tax exemptions are allowed for this account."
        public const uint XONLINE_E_CTP_BDK_E_EXCEEDING_TAX_EXEMPT_LIMITS = 0x80190073;
        // "Generating next ID."
        public const uint XONLINE_E_CTP_BDK_E_GENERATE_NEXT_ID = 0x80190074;
        // "State invalid for the country."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_STATE_FOR_COUNTRY = 0x80190075;
        // "Country for address provided does not match existing country for account."
        public const uint XONLINE_E_CTP_BDK_E_ADDRESS_COUNTRY_ACCOUNT_MISMATCH = 0x80190076;
        // "The offering requested is not available in the country of this account."
        public const uint XONLINE_E_CTP_BDK_E_OFFERING_COUNTRY_ACCOUNT_MISMATCH = 0x80190077;
        // "Invalid account."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BILLABLE_ACCOUNT_ID = 0x80190078;
        // "Invalid account status."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BILLABLE_ACCOUNT_STATUS_ID = 0x80190079;
        // "Invalid phone type."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PHONE_TYPE = 0x80190080;
        // "Invalid offering."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_OFFERING_ID = 0x80190081;
        // "The combination of data passed to PurchaseOffering is invalid for the scenario."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PURCHASE_INPUT_DATA = 0x80190082;
        // "UPS profile is missing either FirstName
        public const uint XONLINE_E_CTP_BDK_E_PUID_MISSING_ATTRIBUTE = 0x80190083;
        // "Invalid country code."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_COUNTRY_CODE = 0x80190084;
        // "Invalid address ID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ADDRESS_ID = 0x80190085;
        // "Invalid payment instrument ID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PAYMENT_METHOD_ID = 0x80190086;
        // "Cannot exceed max ownership for the payment instrument."
        public const uint XONLINE_E_CTP_BDK_E_PI_EXECEED_MAX_OWNER_SHIP = 0x80190087;
        // "Subscription is already cancelled."
        public const uint XONLINE_E_CTP_BDK_E_SUBSCRIPTION_ALREADY_CANCELED = 0x80190088;
        // "A delayed expire request is already pending and should not be requested again."
        public const uint XONLINE_E_CTP_BDK_E_DELAYED_EXPIRE_ALREADY_PENDING = 0x80190089;
        // "A delayed expire is not pending and cannot be undone."
        public const uint XONLINE_E_CTP_BDK_E_DELAYED_EXPIRE_NOT_PENDING = 0x80190090;
        // "A delayed expire is not support unless the subscription is active with no term commits."
        public const uint XONLINE_E_CTP_BDK_E_DELAYED_EXPIRE_NOT_SUPPORTED = 0x80190091;
        // "The value specified for the cancel option/date should be DELAYED_EXPIRE
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CANCEL_DATE = 0x80190092;
        // "Invalid subscription ID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SUBSCRIPTION_ID = 0x80190093;
        // "Invalid period."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PERIOD_TO_PROCESS = 0x80190094;
        // "Invalid subscription status or invalid operation for the status."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SUBSCRIPTION_STATUS = 0x80190095;
        // "Account is inactive."
        public const uint XONLINE_E_CTP_BDK_E_NON_ACTIVE_ACCOUNT = 0x80190096;
        // "VATIDs do not have an expiration date."
        public const uint XONLINE_E_CTP_BDK_E_VATID_DOESNOTHAVEEXPDATE = 0x80190097;
        // "Expiration date was not specified."
        public const uint XONLINE_E_CTP_BDK_E_TAXID_EXPDATE = 0x80190098;
        // "Invalid tax exemption type."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TAX_EXEMPT_TYPE = 0x80190099;
        // "Invalid Tax Exempt Billable Account Id specified."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TAX_EXEMPT_BILLABLE_ACCOUNT_ID = 0x80190100;
        // "No active subscription for adding a service instance."
        public const uint XONLINE_E_CTP_BDK_E_NO_ACTIVE_SUBSCRIPTION = 0x80190101;
        // "Invalid service instance for adding a new user."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SERVICE_INSTANCE = 0x80190102;
        // "Failed to add a new user to a service instance."
        public const uint XONLINE_E_CTP_BDK_E_ADD_USER_TO_SERVICE_INSTANCE = 0x80190103;
        // "Status change not allowed."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BILLABLEACCTSTATUS = 0x80190104;
        // "No service instances available for the billable account."
        public const uint XONLINE_E_CTP_BDK_E_SERVICE_INSTANCES_NONE = 0x80190105;
        // "Account is already closed."
        public const uint XONLINE_E_CTP_BDK_E_ACCOUNT_CLOSED = 0x80190106;
        // "Period is already past."
        public const uint XONLINE_E_CTP_BDK_E_BILLINGPERIOD_PAST = 0x80190107;
        // "Invalid adjustment GUID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ADJUSTMENTGUID = 0x80190108;
        // "Adjustment not applicable to the specified period."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ADJUSMENT_FOR_PERIOD = 0x80190109;
        // "Adjustment amount is too large."
        public const uint XONLINE_E_CTP_BDK_E_ADJUSTMENT_TOOBIG = 0x80190110;
        // "Adjustment amount is too small."
        public const uint XONLINE_E_CTP_BDK_E_ADJUSTMENT_TOOSMALL = 0x80190111;
        // "Invalid locale."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_LOCALE = 0x80190112;
        // "Invalid customer type."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CUSTOMER_TYPE = 0x80190113;
        // "Invalid currency."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CURRENCY = 0x80190114;
        // "Date is already expired."
        public const uint XONLINE_E_CTP_BDK_E_DATE_EXPIRED = 0x80190115;
        // "GUID already exists."
        public const uint XONLINE_E_CTP_BDK_E_GUID_EXISTS = 0x80190116;
        // "Invalid violation ID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_VIOLATION_ID = 0x80190117;
        // "Violation ID is required."
        public const uint XONLINE_E_CTP_BDK_E_MISSING_VIOLATION_ID = 0x80190118;
        // "De-provision service instances before proceeding."
        public const uint XONLINE_E_CTP_BDK_E_NEEDTODEPROVISION = 0x80190119;
        // "Partial conversion is already initiated."
        public const uint XONLINE_E_CTP_BDK_E_PARTIALCONV_INITIATED = 0x80190120;
        // "The currency of the account cannot be updated."
        public const uint XONLINE_E_CTP_BDK_E_CANNOT_UPDATE_CURRENCY = 0x80190121;
        // "Subscription is expected to be in the partial state."
        public const uint XONLINE_E_CTP_BDK_E_PARTIALCONV_EXPECTED = 0x80190122;
        // "Invalid category. Valid category name has a size limit of 50 characters."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CATEGORY_NAME = 0x80190123;
        // "Offering cannot be purchased."
        public const uint XONLINE_E_CTP_BDK_E_OFFERING_NOT_PURCHASEABLE = 0x80190124;
        // "Offering currency does not match account currency."
        public const uint XONLINE_E_CTP_BDK_E_OFFERING_ACCOUNT_CURRENCY_MISMATCH = 0x80190125;
        // "Offering does not support payment instrument type."
        public const uint XONLINE_E_CTP_BDK_E_OFFERING_PAYMENT_INSTRUMENT_MISMATCH = 0x80190126;
        // "Invalid date."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_DATE = 0x80190127;
        // "Cannot exceed max ownership for the offering."
        public const uint XONLINE_E_CTP_BDK_E_CANNOT_EXCEED_MAX_OWNERSHIP = 0x80190128;
        // "Invalid resource ID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_RESOURCE_ID = 0x80190129;
        // "Unit of measure reported in the usage event does not match the one in SPS."
        public const uint XONLINE_E_CTP_BDK_E_UNIT_OF_MEASURE_MISMATCH = 0x80190130;
        // "Event date is before the subscription purchase date."
        public const uint XONLINE_E_CTP_BDK_E_EVT_DATE_BEFORE_PURCHASE_DATE = 0x80190131;
        // "Offering invalid for the locale."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_OFFERING_FOR_LOCALE = 0x80190132;
        // "Offering is not a base offering."
        public const uint XONLINE_E_CTP_BDK_E_NOT_A_BASE_OFFERING = 0x80190133;
        // "There is a scheduled renewal or pending conversion to an offer that does not support that payment instrument."
        public const uint XONLINE_E_CTP_BDK_E_FUTURE_OFFERING_PAYMENT_INSTRUMENT_MISMATCH = 0x80190134;
        // "Offering is invalid for Country."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_OFFERING_FOR_COUNTRY = 0x80190135;
        // "The offering requested conflicts with an existing subscription on this account."
        public const uint XONLINE_E_CTP_BDK_E_MEG_CONFLICT = 0x80190136;
        // "Account state does not allow this operation."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ACCOUNT_STATUS = 0x80190137;
        // "Payment instrument has active subscriptions."
        public const uint XONLINE_E_CTP_BDK_E_ACTIVE_SUBSCRIPTIONS_EXIST = 0x80190138;
        // "The account has billing charges."
        public const uint XONLINE_E_CTP_BDK_E_EXISTING_BILLING_ACTIVITY = 0x80190139;
        // "Subscription is in an invalid state for this operation."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SUBSCRIPTION_STATUS_FOR_OPERATION = 0x80190140;
        // "Primary phone required for payment instruments."
        public const uint XONLINE_E_CTP_BDK_E_PRIMARY_PHONE_REQUIRED = 0x80190141;
        // "Account requires an e-mail address for this operation."
        public const uint XONLINE_E_CTP_BDK_E_EMAIL_REQUIRED = 0x80190142;
        // "To perform this operation
        public const uint XONLINE_E_CTP_BDK_E_ACCOUNT_NOT_CLOSED = 0x80190143;
        // "Invalid violation ID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_VIOLATION = 0x80190144;
        // "Subscription is cancelled and cannot change status."
        public const uint XONLINE_E_CTP_BDK_E_SUBSCRIPTION_IS_CANCELLED = 0x80190145;
        // "Subscription has no violations."
        public const uint XONLINE_E_CTP_BDK_E_NO_VIOLATION = 0x80190146;
        // "Subscription has violations."
        public const uint XONLINE_E_CTP_BDK_E_EXISTS_VIOLATION = 0x80190147;
        // "Invalid Service Component Id was passed."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SERVICE_COMPONENT_ID = 0x80190148;
        // "End date is already past."
        public const uint XONLINE_E_CTP_BDK_E_END_DATE_IN_THE_PAST = 0x80190149;
        // "End date passed in is later than the latest allowable end date for this subscription."
        public const uint XONLINE_E_CTP_BDK_E_END_DATE_BEYOND_MAX = 0x80190150;
        // "Violation is already set."
        public const uint XONLINE_E_CTP_BDK_E_VIOLATION_ALREADY_SET = 0x80190151;
        // "Violation ID not set."
        public const uint XONLINE_E_CTP_BDK_E_NO_VIOLATION_SET = 0x80190152;
        // "Either there is no path between the current offering and the target offering or the path does not match the calling mode (Convert or Renew)."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CONVERSION = 0x80190153;
        // "Subscription is not in the partial state."
        public const uint XONLINE_E_CTP_BDK_E_SUBS_NOT_INTERMEDIATE = 0x80190154;
        // "Offering is not published."
        public const uint XONLINE_E_CTP_BDK_E_OFFERING_NOT_PUBLISHED = 0x80190155;
        // "Service instances must be de-provisioned to proceed."
        public const uint XONLINE_E_CTP_BDK_E_CONVERSION_NEEDTODEPROVISION = 0x80190156;
        // "Invalid mandate status."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_MANDATE_STATUS = 0x80190157;
        // "Payment instrument status is already GOOD."
        public const uint XONLINE_E_CTP_BDK_E_PI_ALREADY_GOOD = 0x80190158;
        // "Payment instrument status is already DECLINED."
        public const uint XONLINE_E_CTP_BDK_E_PI_ALREADY_DECLINED = 0x80190159;
        // "Payment instrument status is DISABLED and cannot be changed."
        public const uint XONLINE_E_CTP_BDK_E_PI_IS_DISABLED = 0x80190160;
        // "SAP Number is required for Invoice PI."
        public const uint XONLINE_E_CTP_BDK_E_INVOICEPI_SAP_NUMBER_REQUIRED = 0x80190161;
        // "Invoice XML was invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_INVOICE_INFO_XML = 0x80190162;
        // "Max Limit for this PI Type within account reached."
        public const uint XONLINE_E_CTP_BDK_E_MAX_PI_PER_ACCOUNT_REACHED = 0x80190163;
        // "PI country does not match Account country."
        public const uint XONLINE_E_CTP_BDK_E_PI_ACCOUNT_COUNTRY_MISMATCH = 0x80190164;
        // "An error occured. Try again later."
        public const uint XONLINE_E_CTP_BDK_E_ERROR_OCCURRED_TRY_LATER = 0x80190165;
        // "An error occured."
        public const uint XONLINE_E_CTP_BDK_E_ERROR_OCCURRED = 0x80190166;
        // "Payment instrument exists or the payment instrument status is invalid or does not allow the operation."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PAYMENT_INSTRUMENT_STATUS = 0x80190167;
        // "Invalid offering GUID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_OFFERING_GUID = 0x80190168;
        // "Offering requires a payment instrument."
        public const uint XONLINE_E_CTP_BDK_E_OFFERING_REQUIRES_PI = 0x80190169;
        // "Offering cannot be purchased because it has delayed provisioning components."
        public const uint XONLINE_E_CTP_BDK_E_DELAYED_PROVISIONING_COMPONENTS_EXIST = 0x80190170;
        // "Invalid currency format."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_AMOUNT_FOR_CURRENCY = 0x80190171;
        // "Invalid e-mail address."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_EMAIL_ADDRESS = 0x80190172;
        // "Invalid tax exemption status."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TAX_EXEMPT_STATUS = 0x80190173;
        // "No valid tax exemption certificates exist for the account."
        public const uint XONLINE_E_CTP_BDK_E_NO_VALID_TAX_EXEMPTION = 0x80190174;
        // "Invalid tax exemption status change."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TAX_EXEMPT_STATUS_CHANGE = 0x80190175;
        // "The status of the old payment instrument does not allow this operation."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_OLD_PAYMENT_INSTRUMENT_STATUS = 0x80190176;
        // "The specified start period is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_START_PERIOD = 0x80190177;
        // "The specified end period is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_END_PERIOD = 0x80190178;
        // "The specified Detailed level is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_DETAILEDLEVEL = 0x80190179;
        // "Difference between BeginDate and EndDate is more than 6 months"
        public const uint XONLINE_E_CTP_BDK_E_EXCEED_DATERANGE_LIMIT = 0x80190180;
        // "Begin Date can never be greater than EndDate"
        public const uint XONLINE_E_CTP_BDK_E_WRONG_DATERANGE = 0x80190181;
        // "Begin date is not valid"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BEGIN_DATE = 0x80190182;
        // "End date is not valid"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_END_DATE = 0x80190183;
        // "End date is greater than the current date"
        public const uint XONLINE_E_CTP_BDK_E_END_DATE_GREATER_THAN_CURRENT_DATE = 0x80190184;
        // "SPS is in compute-only mode."
        public const uint XONLINE_E_CTP_BDK_E_COMPUTE_ONLY = 0x80190185;
        // "Detected that month(s) were missed in periodic processing."
        public const uint XONLINE_E_CTP_BDK_E_MISSED_PROCESSING_PERIOD = 0x80190186;
        // "Subscription is not expired."
        public const uint XONLINE_E_CTP_BDK_E_SUBSCRIPTION_NOT_EXPIRED = 0x80190187;
        // "Subscription can no longer be reinstated."
        public const uint XONLINE_E_CTP_BDK_E_TOOLATE_REINSTATE = 0x80190188;
        // "Only a single Referral node may be passed in to this API."
        public const uint XONLINE_E_CTP_BDK_E_EXTRA_REFERRAL_DATA = 0x80190189;
        // "bstrReferralIDSetXML parameter must be left empty for this API."
        public const uint XONLINE_E_CTP_BDK_E_NO_REFERRAL_UPDATES_ALLOWED = 0x80190190;
        // "Cannot schedule a new renewal because there exists already a free renewal on the subscription."
        public const uint XONLINE_E_CTP_BDK_E_FREE_SCHEDULED_RENEWAL_EXISTS = 0x80190191;
        // "Cannot convert a deal with multiple components with delayed provisioning."
        public const uint XONLINE_E_CTP_BDK_E_DEAL_HAS_MULTIPLE_DELAYED_COMPONENTS = 0x80190192;
        // "The specified cobrand is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_COBRAND = 0x80190193;
        // "This operation is not valid for wholesale subscriptions."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_OPERATION_FOR_WHOLESALE_SUBSCRIPTION = 0x80190194;
        // "HCI not valid for Account Id."
        public const uint XONLINE_E_CTP_BDK_E_HCI_NOT_VALID = 0x80190195;
        // "Taiwan users cannot opt out of hard copy tax invoices."
        public const uint XONLINE_E_CTP_BDK_E_CANT_STOP_TAIWAN_TAXINV = 0x80190196;
        // "Adjusting a resource balance is not allowed for subscriptions that are not active."
        public const uint XONLINE_E_CTP_BDK_E_RESOURCE_BALANCE_CHANGE_ON_NONACTIVE_SUBS = 0x80190197;
        // "The type of the token specified was invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TOKEN_TYPE = 0x80190198;
        // "The token Id specified is not valid for the given offering."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_NOT_VALID_FOR_OFFERING = 0x80190199;
        // "Deal Token mapping currently not present in the system to be marked as invalid."
        public const uint XONLINE_E_CTP_BDK_E_DEAL_TOKEN_MAPPING_NOT_PRESENT = 0x80190200;
        // "Maximum consumption count per user reached."
        public const uint XONLINE_E_CTP_BDK_E_MAXIMUM_CONSUMPTION_COUNT_PER_USER_REACHED = 0x80190201;
        // "Error in inserting a new row in table user_token_hash."
        public const uint XONLINE_E_CTP_BDK_E_INSERTING_USER_TOKEN_HASH = 0x80190202;
        // "A token Id and a payment instrument Id cannot both be specified."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_AND_PI_BOTH_SPECIFIED = 0x80190203;
        // "The token class is invalid or does not exist."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_CLASS_INVALID = 0x80190204;
        // "The Input TokenClass Restriction Info Filter is Missing."
        public const uint XONLINE_E_CTP_BDK_E_INPUT_FILTER_XML_MISSING = 0x80190205;
        // "Unable to find the token mapping to the specified token class."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_CLASS_NOT_FOUND = 0x80190206;
        // "Invalid TokenClass Restriction Info Filter."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_INPUT_FILTER_XML = 0x80190207;
        // "A payment instrument cannot be specified."
        public const uint XONLINE_E_CTP_BDK_E_PI_CANNOT_BE_SPECIFIED = 0x80190208;
        // "The subscription specified is not a PrePaid subscription."
        public const uint XONLINE_E_CTP_BDK_E_SUBSCRIPTION_NOT_PREPAID = 0x80190209;
        // "The total number of extended days cannot be less than zero."
        public const uint XONLINE_E_CTP_BDK_E_TOTAL_EXTENSION_LESS_THAN_ZERO = 0x80190210;
        // "The number of days specified is invalid
        public const uint XONLINE_E_CTP_BDK_E_INVALID_NUMBER_OF_DAYS = 0x80190211;
        // "The number of months specified is invalid
        public const uint XONLINE_E_CTP_BDK_E_INVALID_NUMBER_OF_MONTHS = 0x80190212;
        // "The total number of extended days is greater than the maximum allowed for the current subscription."
        public const uint XONLINE_E_CTP_BDK_E_TOTAL_EXTENSION_GREATER_THAN_MAX = 0x80190213;
        // "The deal specified requires a valid Prepaid Token Id to be specified."
        public const uint XONLINE_E_CTP_BDK_E_PREPAID_TOKEN_IS_REQUIRED = 0x80190214;
        // "There are remaining cycles on the current term commit."
        public const uint XONLINE_E_CTP_BDK_E_TERM_COMMIT_EXISTS = 0x80190215;
        // "The specified token cannot be used for the current operation."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_NOT_APPLICABLE = 0x80190216;
        // "Renewal cannot be scheduled if there is already a token based renewal present."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_RENEWAL_PRESENT = 0x80190217;
        // "Error subscription duration exceeds max duration."
        public const uint XONLINE_E_CTP_BDK_E_EXCEEDS_MAXIMUM_DURATION = 0x80190218;
        // "Error conversion credits were applied but the offer does not support conversion credits."
        public const uint XONLINE_E_CTP_BDK_E_CONVERSION_CREDITS_NOT_ENABLED = 0x80190219;
        // "Only BillableAccountAdmin can add the PI."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_USERROLE_FOR_ADDPI = 0x80190220;
        // "Not authorized to use the tax rule configuration group."
        public const uint XONLINE_E_CTP_BDK_E_NOT_AUTHORIZED_TAX_RULE_CONFIG_GROUP = 0x80190221;
        // "BlacklistToken found actions to take
        public const uint XONLINE_E_CTP_BDK_E_BLACKLIST_ACTION_NOT_PERFORMED = 0x80190222;
        // "BlacklistToken was called with invalid bstrSubscriptionAction parameter."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SUBSCRIPTION_ACTION = 0x80190223;
        // "Invalid distribution channel specified for token class part number."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_DISTRIBUTION_CHANNEL_NOT_FOUND = 0x80190224;
        // "Invalid length for token class part number."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_LEN_PART_NUMBER = 0x80190225;
        // "nvalid length for SAP customer name."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_LEN_SAP_CUST_NAME = 0x80190226;
        // "Invalid length for Support Vendor name."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_LEN_SUPPORT_VENDOR_NAME = 0x80190227;
        // "Failed while inserting in partner_token_class table."
        public const uint XONLINE_E_CTP_BDK_E_INSERING_TOKEN_CLASS_PARTNER = 0x80190228;
        // "Token Part Number is currently associated with other token class please remove the association from the other token class and try again."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_PART_NUMBER_ASSOC_WITH_OTHER_TOKEN_CLASS = 0x80190229;
        // "A token is being delivered to the same service instance at this moment. Please retry."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_ALREADY_DELIVERED = 0x80190230;
        // "A Token passed in does not have an associated Distribution batch."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_DISTRIBUTION_BATCH_INVALID = 0x80190231;
        // "A Distribution Batch associated with the passed in Token is in inactive state."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_DISTRIBUTION_BATCH_INACTIVE = 0x80190232;
        // "A Distribution Program is in inactive state."
        public const uint XONLINE_E_CTP_BDK_E_DISTRIBUTION_PROGRAM_INACTIVE = 0x80190233;
        // "Failed while inserting in reconcile_history table."
        public const uint XONLINE_E_CTP_BDK_E_INSERTING_RECONCILE_HISTORY = 0x80190234;
        // "Specified Token is already issued."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_ALREADY_ISSUED = 0x80190235;
        // "Specified Token is already unissued
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_ALREADY_UNISSUED = 0x80190236;
        // "Failed to update the token issue status in token_instance table."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_ISSUE_UPDATE = 0x80190237;
        // "The input parameter combination does not match the system."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_COMBINATION = 0x80190238;
        // "Invalid Replacement Reason code specified."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_REPLACEMENT_REASON_CODE = 0x80190239;
        // "The request failed because the maximum number of replacements for this sequence number have exceeded the threshold value."
        public const uint XONLINE_E_CTP_BDK_E_MAX_REPLACEMENT_REACHED = 0x80190240;
        // "Token Replacement failed due to unknown error."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_REPLACEMENT_FAILED = 0x80190241;
        // "Failed to update Token Distribution status."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_DISTRIBUTION_STATUS_UPDATE = 0x80190242;
        // "Signature does not belong to specified Token."
        public const uint XONLINE_E_CTP_BDK_E_SIGNATURE_TOKEN_MISMATCH = 0x80190243;
        // "Invalid Token Staus Name specified."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_STATUS_NAME = 0x80190244;
        // "Invalid distribution status to issue token."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TOKEN_DISTRIBUTION_STATUS = 0x80190245;
        // "Specified token is replaced token
        public const uint XONLINE_E_CTP_BDK_E_ALREADY_REPLACED_TOKEN = 0x80190246;
        // "Invalid Partner specified or the partner does not have permission to take action on specified token."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_ACTION_ACCESS_DENIED = 0x80190247;
        // "Specified partner does not exist."
        public const uint XONLINE_E_CTP_BDK_E_NOT_EXISTS_PARTNER = 0x80190248;
        // "Specified reseller PKPN is duplicated with the existing PKPN configured by PCT."
        public const uint XONLINE_E_CTP_BDK_E_DUPLICATED_PKPN_WITH_PCT = 0x80190249;
        // "Specified reseller token part number does not exist."
        public const uint XONLINE_E_CTP_BDK_E_NOT_EXISTS_PKPN = 0x80190250;
        // "Specified reseller token instance has already been blacklisted."
        public const uint XONLINE_E_CTP_BDK_E_RESELLER_TOKEN_BLACKLISTED = 0x80190251;
        // "Specified reseller token instance has already been consumed."
        public const uint XONLINE_E_CTP_BDK_E_RESELLER_TOKEN_CONSUMED = 0x80190252;
        // "Server internal error occurred."
        public const uint XONLINE_E_CTP_BDK_E_SERVER_INTERNAL_ERROR = 0x80190253;
        // "Specified reseller channel SKU is duplicated with the existing channel SKU configured by PCT."
        public const uint XONLINE_E_CTP_BDK_E_DUPLICATED_CHANNELSKU_WITH_PCT = 0x80190254;
        // "Percentage on ChannelSKU-PKPN mapping cannot be updated."
        public const uint XONLINE_E_CTP_BDK_E_CHANNELSKU_PKPN_PERCENTAGE_CANNOT_UPDATE = 0x80190255;
        // "ChannelSKU-PKPN mappings cannot be added after setup."
        public const uint XONLINE_E_CTP_BKE_E_CHANNELSKU_PKPN_MAPPING_CANNOT_ADD = 0x80190256;
        // "Sum of all PKPNs' percentage under one channel sku should be less than or equal 1."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PKPN_ALLOCATION = 0x80190257;
        // "The input token number in batch exceeds max allowerd number."
        public const uint XONLINE_E_CTP_BDK_E_EXCEEDS_MAX_TOKEN_INSTANCE = 0x80190258;
        // "Value for returnStatementSet parameter must be 0
        public const uint XONLINE_E_CTP_BDK_E_BAD_RETURN_STATEMENT_SET_INDICATOR = 0x80190259;
        // "The begin billing period is not valid for this account."
        public const uint XONLINE_E_CTP_BDK_E_BAD_BEGIN_BILLING_PERIOD = 0x80190260;
        // "The end billing period is not valid for this account."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_END_BILLING_PERIOD = 0x80190261;
        // "The billing period value cannot be negative."
        public const uint XONLINE_E_CTP_BDK_E_BILLING_PERIOD_NEGATIVE = 0x80190262;
        // "The end period must be greater than start period."
        public const uint XONLINE_E_CTP_BDK_E_BAD_START_END_BILLING_PERIOD = 0x80190263;
        // "The account history date cannot be greater than the current date."
        public const uint XONLINE_E_CTP_BDK_E_CURRENT_DATE_LESS_THAN_ACCOUNT_HISTORY_DATE = 0x80190264;
        // "Cannot pass null for all parameters."
        public const uint XONLINE_E_CTP_BDK_E_NO_NON_NULL_PARAMS = 0x80190265;
        // "The billing period value must be of the format YYYYMM (Y representing the year and M representing month)."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SUBSCRIPTION_BILLING_PERIOD = 0x80190266;
        // "The billing period value cannot be greater than the subscription duration (i.e. past subscription expiration)."
        public const uint XONLINE_E_CTP_BDK_E_BILLING_PERIOD_GREATER_THAN_SUBSCRIPTION_DURATION = 0x80190267;
        // "The offering guid passed in does not match offering guid on subscription."
        public const uint XONLINE_E_CTP_BDK_E_MISMATCH_SUB_ID_OFFER_GUID = 0x80190268;
        // "The event time stamp is too far in future."
        public const uint XONLINE_E_CTP_BDK_E_EVENT_TIMESTAMP_IN_THE_FUTURE = 0x80190269;
        // "The policy GuidID/Version combination supplied does not exist."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_POLICY_ID = 0x80190270;
        // "The offering specified does not support the country of payment instrument being used."
        public const uint XONLINE_E_CTP_BDK_E_OFFERING_PI_COUNTRY_MISMATCH = 0x80190271;
        // "Error inserting into table agreement_signature."
        public const uint XONLINE_E_CTP_BDK_E_INSERT_AGREEMENT_SIGNATURE = 0x80190272;
        // "Agreement for this subscription has already been signed by this user at a different time."
        public const uint XONLINE_E_CTP_BDK_E_AGREEMENT_ALREADY_SIGNED = 0x80190273;
        // "The specified policy has not been localized in the specified locale."
        public const uint XONLINE_E_CTP_BDK_E_LOCALE_NOT_SUPPORTED_FOR_POLICY = 0x80190274;
        // "The policy specified is valid but the version is incorrect."
        public const uint XONLINE_E_CTP_BDK_E_POLICY_DEAL_VERSION_MISMATCH = 0x80190275;
        // "The policy specified exists but is not valid on the deal/country combination of the supplied subscription."
        public const uint XONLINE_E_CTP_BDK_E_POLICY_DEAL_COUNTRY_MISMATCH = 0x80190276;
        // "The subscription was previously a wholesale subscription which was converted to a direct subscription and is now trying to be converted to wholesale again.  This is not allowed."
        public const uint XONLINE_E_CTP_BDK_E_CANNOT_CONVERT_BACK_TO_WHOLESALE = 0x80190277;
        // "A payment instrument cannot specified when the conversion mode is RENEW."
        public const uint XONLINE_E_CTP_BDK_E_CANNOT_SPECIFY_PI_DURING_RENEW = 0x80190278;
        // "Renewing from a perpetual offering is not allowed."
        public const uint XONLINE_E_CTP_BDK_E_NO_RENEWAL_FROM_PERPETUAL_OFFERING = 0x80190279;
        // "Tax Exempt Certificate Number is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TECERTIFICATENUMBER = 0x80190280;
        // "Conversions between wholesale offers are not allowed."
        public const uint XONLINE_E_CTP_BDK_E_NO_WHOLESALE_TO_WHOLESALE = 0x80190281;
        // "The status of the new payment instrument specified does not allow this operation."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_NEW_PAYMENT_INSTRUMENT_STATUS = 0x80190282;
        // "Renewal does not exist."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_RENEWAL = 0x80190283;
        // "The length of phone number is greater than expected."
        public const uint XONLINE_E_CTP_BDK_E_ERROR_PHONE_STRING_TOOLONG = 0x80190284;
        // "The calling partner does not have access to the token class."
        public const uint XONLINE_E_CTP_BDK_E_ERROR_TOKEN_CLASS_ACCESS_DENIED = 0x80190285;
        // "Last administrator role on the account cannot be removed."
        public const uint XONLINE_E_CTP_BDK_E_LAST_ADMIN_ROLE = 0x80190286;
        // "The PUID is already being used as BillableAccountAdmin."
        public const uint XONLINE_E_CTP_BDK_E_PUID_USED_AS_BILLABLEACCOUNTADMIN = 0x80190287;
        // "Error updating member name."
        public const uint XONLINE_E_CTP_BDK_E_UPDATING_MEMBERNAME = 0x80190288;
        // "Object can have a maximum of 2000 roles."
        public const uint XONLINE_E_CTP_BDK_E_OBJECT_ROLE_LIMIT_EXCEEDED = 0x80190289;
        // "The allowable number of the delegate admins for an account has reached its limit."
        public const uint XONLINE_E_CTP_BDK_E_ACCOUNT_DELADMIN_ROLE_EXCEEDED = 0x80190290;
        // "Provisioning: Provision request malformed."
        public const uint XONLINE_E_CTP_PROVISION_E_MALFORMED_REQUEST = 0x80190291;
        // "Provisioning: Wrong input parameters."
        public const uint XONLINE_E_CTP_PROVISION_E_WRONG_INPUT_PARAMETERS = 0x80190292;
        // "Provisioning: Microsoft Provisioning Framework call failed. %1"
        public const uint XONLINE_E_CTP_PROVISION_E_MPF_CALL_FAILED = 0x80190293;
        // "Provisioning: Error during XML manipulation. %1"
        public const uint XONLINE_E_CTP_PROVISION_E_XML_OPERATION_ERROR = 0x80190294;
        // "Provisioning: MPF client instantiation failed. %1"
        public const uint XONLINE_E_CTP_PROVISION_E_MPF_CREATE = 0x80190295;
        // "Provisioning: General error in startup code. %1"
        public const uint XONLINE_E_CTP_PROVISION_E_CREATION = 0x80190296;
        // "The number of service instances in the provisioning request exceeds the configured limit."
        public const uint XONLINE_E_CTP_BDK_E_EXCEEDS_MAX_NUMBER_OF_SERVICE_INSTANCE_REQUESTS = 0x80190297;
        // "Invalid ZIP code."
        public const uint XONLINE_E_CTP_BDK_E_DBBADZIP = 0x80190298;
        // "The account has subscription(s) in non-cancelled state that require information that you are attempting to remove."
        public const uint XONLINE_E_CTP_BDK_E_REQUIRED_FIELD_MISSING_DUE_TO_SUBSCRIPTIONS = 0x80190299;
        // "The account requires additional attributes before performing the operation."
        public const uint XONLINE_E_CTP_BDK_E_ADDITIONAL_ACCOUNT_DATA_REQUIRED = 0x80190300;
        // "The referrer has already reffered the customer to this offer."
        public const uint XONLINE_E_CTP_BDK_E_ACCT_ALREADY_REFERRED = 0x80190301;
        // "There are no reward offers currently available in the system."
        public const uint XONLINE_E_CTP_BDK_E_REWARD_OFFER_NOT_PURCHASABLE = 0x80190302;
        // "Need to sign the agreement before continuing with the call."
        public const uint XONLINE_E_CTP_BDK_E_AGREEMENT_NOT_SIGNED = 0x80190303;
        // "The user has a violation on their payment instrument."
        public const uint XONLINE_E_CTP_BDK_E_ITEM_VIOLATION_EXISTS = 0x80190304;
        // "Title and/or category is not allowed for this offer."
        public const uint XONLINE_E_CTP_BDK_E_DYNAMIC_TITLE_AND_CATEGORY_CONFIGURATION = 0x80190305;
        // "Account has a pending transaction."
        public const uint XONLINE_E_CTP_BDK_E_PENDING_TRANSACTION = 0x80190306;
        // "Cannot update total."
        public const uint XONLINE_E_CTP_BDK_E_INCREMENT_TOTAL = 0x80190307;
        // "Resource does not belong to this object id."
        public const uint XONLINE_E_CTP_BDK_E_RES_NOT_BELONG_TO_OBJECT = 0x80190308;
        // "Payment instrument on the current subscription has a declining balance."
        public const uint XONLINE_E_CTP_BDK_E_DECLINING_BALANCE = 0x80190309;
        // "Duplicate tracking GUID."
        public const uint XONLINE_E_CTP_BDK_E_DUPLICATE_TRACKING_GUID = 0x80190310;
        // "Invalid credit card expiration date."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_EXPIRATION_DATE = 0x80190311;
        // "Invalid mandate status."
        public const uint XONLINE_E_CTP_BDK_E_UNKNOWN_MANDATE_STATUS = 0x80190312;
        // "Payment method of this type can't support the action"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PAYMENT_METHOD_TYPE = 0x80190313;
        // "Invalid input currency."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CURRENCY2 = 0x80190314;
        // "Invalid amount passed in as argument."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_AMOUNT = 0x80190315;
        // "Invalid billing period."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BILLING_PERIOD = 0x80190316;
        // "Invalid billing anniversary date."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ANNIV = 0x80190317;
        // "Invalid line item ID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_LINEITEM_ID = 0x80190318;
        // "Invalid line item status."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_LINEITEM_STATUS = 0x80190319;
        // "The event type of the line item is invalid for this operation."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_EVENT_TYPE = 0x80190320;
        // "Line item ID not associated with an open record."
        public const uint XONLINE_E_CTP_BDK_E_LINE_ITEM_ID_NOT_OPEN = 0x80190321;
        // "Line item has already been offset."
        public const uint XONLINE_E_CTP_BDK_E_LINEITEM_ALREADY_OFFSET = 0x80190322;
        // "Line item has already been Charged back."
        public const uint XONLINE_E_CTP_BDK_E_LINEITEM_ALREADY_CHARGED_BACK = 0x80190323;
        // "Offset amount must be greater than zero but less than or equal to original amount. %1"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_OFFSET_AMOUNT = 0x80190324;
        // "Cannot offset line item that is soft- or hard-declined."
        public const uint XONLINE_E_CTP_BDK_E_CANNOT_OFFSET_HARD_SOFT_DECLINED = 0x80190325;
        // "Cannot offset line item which is cross SA and BSS transfered."
        public const uint XONLINE_E_CTP_BDK_E_LINEITEM_ALREADY_CROSS_TRANSFERED = 0x80190326;
        // "Amount has not been collected
        public const uint XONLINE_E_CTP_BDK_E_AMOUNT_NOT_COLLECTED_YET = 0x80190327;
        // "Cannot offset line item amount of zero."
        public const uint XONLINE_E_CTP_BDK_E_CANNOT_OFFSET_ZERO_AMOUNT = 0x80190328;
        // "The operation cannot be completed because an amount involved is in the process of being sent to the bank for collection."
        public const uint XONLINE_E_CTP_BDK_E_AMOUNT_IN_PROCESS = 0x80190329;
        // "Credit amount should not be zero."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CREDIT_AMOUNT = 0x80190330;
        // "Credit amount should not exceed the limit."
        public const uint XONLINE_E_CTP_BDK_E_CREDIT_AMOUNT_OVER_LIMIT = 0x80190331;
        // "The requested currency(JPY
        public const uint XONLINE_E_CTP_BDK_E_INVALID_AMOUNT_FOR_CURRENCY_2 = 0x80190332;
        // "Same event id already been used
        public const uint XONLINE_E_CTP_BDK_E_DUPLICATE_EVENT_ID = 0x80190333;
        // "Line items in the immediate_settle_in_progress state cannot be offset."
        public const uint XONLINE_E_CTP_BDK_E_OFFSET_IMM_SETTLE_IN_PROG = 0x80190334;
        // "Line item with this settlement amount status cannot be offset."
        public const uint XONLINE_E_CTP_BDK_E_SA_IN_STATE_UNOFFSETABLE = 0x80190335;
        // "this settlement amount status cannot be escheated."
        public const uint XONLINE_E_CTP_BDK_E_SA_IN_STATE_UNESCHEATABLE = 0x80190336;
        // "Offset amount should never exceed the original item amount."
        public const uint XONLINE_E_CTP_BDK_E_OFFSET_AMOUNT_GREATER_THAN_ORIGINAL = 0x80190337;
        // "The subscription is not active. The resource usage event is still being reported for the subscription."
        public const uint XONLINE_E_CTP_BDK_E_RES_BALANCE_CHANGE_ON_NONACTIVE_SUBS = 0x80190338;
        // "the payment instrument already has declines on it"
        public const uint XONLINE_E_CTP_BDK_E_PI_IN_DECLINE = 0x80190339;
        // "The operation is not allowed when there are Settlement Amounts in intermediate status."
        public const uint XONLINE_E_CTP_BDK_E_SA_IN_INTERMEDIATE_STATUS = 0x80190340;
        // "The specified settlement amount id is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SETTLEMENT_AMOUNT_ID = 0x80190341;
        // "This thread has an out-dated usage total it is trying to rate and write a billing transaction for threshold billing."
        public const uint XONLINE_E_CTP_BDK_E_MISMATCH_RATED_USAGE_TOTAL = 0x80190342;
        // "Value for returnStatementSet parameter must be 0
        public const uint XONLINE_E_CTP_BDK_E_BAD_RETURN_STATEMENT_SET_INDICATOR2 = 0x80190343;
        // "%1"
        public const uint XONLINE_E_CTP_BDK_E_ARITHMETIC_OVERFLOW_FOR_ADD_OR_UPDATE_USAGE = 0x80190344;
        // "Refund failed - line item was offset but original line item was never settled."
        public const uint XONLINE_E_CTP_BDK_E_REFUND_LINEITEM_NOT_SETTLED = 0x80190345;
        // "Specified resource balance has already been billed."
        public const uint XONLINE_E_CTP_BDK_E_RESOURCE_BALANCE_INACTIVE = 0x80190346;
        // "The number of units specified is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_NUMBER_OF_UNITS = 0x80190347;
        // "Usage category does not exist for this resource."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_USAGE_CATEGORY = 0x80190348;
        // "The prepaid resource balance is not sufficient for this usage event."
        public const uint XONLINE_E_CTP_BDK_E_INSUFFICIENT_PREPAID_BALANCE = 0x80190349;
        // "Financial reason code does not exist."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_FINANCIAL_REASON_CODE = 0x80190350;
        // "Offset of offset is not permitted through this API."
        public const uint XONLINE_E_CTP_BDK_E_OFFSET_OF_OFFSET_NOT_PERMITTED = 0x80190351;
        // "If offset is not to be shown by getstatement
        public const uint XONLINE_E_CTP_BDK_E_DONOTSHOWOFFSET_MISMATCHED_AMOUNT = 0x80190352;
        // "Invalid financial reason code passed for the offset usage API."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_FIN_REASON_CODE_FOR_OFFSET = 0x80190353;
        // "The line item is associated with a non-offsettable event action."
        public const uint XONLINE_E_CTP_BDK_E_EVENT_ACTION_NOT_OFFSETTABLE = 0x80190354;
        // "Action is not permitted for immediate settle of usage offers."
        public const uint XONLINE_E_CTP_BDK_E_IMMEDIATE_SETTLE_OF_USAGE_NOT_PERMITTED = 0x80190355;
        // "Resource offset is only allowed for usage."
        public const uint XONLINE_E_CTP_BDK_E_RESOURCE_OFFSET_ONLY_ALLOWED_FOR_USAGE = 0x80190356;
        // "Invalid Tax Refund Code."
        public const uint XONLINE_E_CTP_BDK_E_ERROR_PP_INVALID_TAX_REFUND_CODE = 0x80190357;
        // "The transaction confirmation number is already used on the account."
        public const uint XONLINE_E_CTP_BDK_E_DUPLICATE_TRANSACTION_CONFIRMATION_NUMBER = 0x80190358;
        // "The transaction does not exist."
        public const uint XONLINE_E_CTP_BDK_E_TRANSACTION_NOT_EXIST = 0x80190359;
        // "Invalid combination of cumulative authorized amount and cumulative reversed amount."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CUMULATIVE_AMOUNT = 0x80190360;
        // "The transaction event code is unknown."
        public const uint XONLINE_E_CTP_BDK_E_TRANSACTION_EVENT_UNKNOWN = 0x80190361;
        // "The transaction event code is not consistent."
        public const uint XONLINE_E_CTP_BDK_E_TRANSACTION_EVENT_INCONSISTENT = 0x80190362;
        // "Invalid sequence number reported in transaction event."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SEQUENCE_NUMBER = 0x80190363;
        // "Invalid vendor internal transaction id."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_VENDOR_TRANSACTION_ID = 0x80190364;
        // "Invalid rejection reason code."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_REJECTION_REASON_CODE = 0x80190365;
        // "Invalid transaction status."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TRANSACTION_STATUS = 0x80190366;
        // "Invalid combination of cumulative authorized tax amount and cumulative reversed tax amount."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CUMULATIVE_TAX_AMOUNT = 0x80190367;
        // "Invalid merchant id."
        public const uint XONLINE_E_CTP_BDK_E_UNKNOWN_MERCHANT_ID = 0x80190368;
        // "Transaction has already been cancelled."
        public const uint XONLINE_E_CTP_BDK_E_TRANSACTION_ALREADY_CANCELLED = 0x80190369;
        // "Passport member name could not be added."
        public const uint XONLINE_E_CTP_BDK_E_PMN_INSERT_FAILURE = 0x80190370;
        // "Payment card number has been used multiple times."
        public const uint XONLINE_E_CTP_BDK_E_BADSAMECARDUSEDMULTIPLETIMES = 0x80190371;
        // "Payment instrument already assigned to account."
        public const uint XONLINE_E_CTP_BDK_E_PI_ALREADY_ON_ACCOUNT = 0x80190372;
        // "Passport ID can have a maximum of 100 roles."
        public const uint XONLINE_E_CTP_BDK_E_PUID_ROLE_LIMIT_EXCEEDED = 0x80190373;
        // "Too many fraud enticing purchases on the payment instrument"
        public const uint XONLINE_E_CTP_BDK_E_TOOMANY_FDE_PURCHASES = 0x80190374;
        // "Passport PUIDs associated with this tax Id has already reaches the maximum limit."
        public const uint XONLINE_E_CTP_BDK_E_TAX_ID_ASSOCIATION_LIMIT_EXCEEDED = 0x80190375;
        // "Access denied."
        public const uint XONLINE_E_CTP_BDK_E_NOPERMISSION = 0x80190376;
        // "Cannot remove self from object."
        public const uint XONLINE_E_CTP_BDK_E_CANNOT_REMOVE_SELF = 0x80190377;
        // "XML is either malformed or incorrect for this API."
        public const uint XONLINE_E_CTP_BDK_E_BADXML = 0x80190378;
        // "Comment text length must be between 1 and 512 characters."
        public const uint XONLINE_E_CTP_BDK_E_INVALIDCOMMENTSIZE = 0x80190379;
        // "Invalid cancellation mode."
        public const uint XONLINE_E_CTP_BDK_E_BADCANCELMODE = 0x80190380;
        // "Input parameter is the wrong size."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BUF_SIZE = 0x80190381;
        // "Invalid role."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ROLE = 0x80190382;
        // "Invalid Passport ID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PPORT_ID = 0x80190383;
        // "Invalid argument."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ARG = 0x80190384;
        // "Unknown server failure. API name: %2
        public const uint XONLINE_E_CTP_BDK_E_UNKNOWN_SERVER_FAILURE = 0x80190385;
        // "Status must be ENABLED or SUSPENDED."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_STATUS_VALUE = 0x80190386;
        // "Filter must be BASE
        public const uint XONLINE_E_CTP_BDK_E_INVALID_FILTER = 0x80190387;
        // "Missing category."
        public const uint XONLINE_E_CTP_BDK_E_MISSING_CATEGORY = 0x80190388;
        // "Input field is too short."
        public const uint XONLINE_E_CTP_BDK_E_FIELD_TOO_SHORT = 0x80190389;
        // "Input field is too long."
        public const uint XONLINE_E_CTP_BDK_E_FIELD_TOO_LONG = 0x80190390;
        // "Invalid ZIP code."
        public const uint XONLINE_E_CTP_BDK_E_BADZIP = 0x80190391;
        // "Only one of these nodes should be passed."
        public const uint XONLINE_E_CTP_BDK_E_ONLYONENODE = 0x80190392;
        // "Input field length does not meet requirement."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_FIELD_LENGTH = 0x80190393;
        // "Only customer service representatives can invoke this API."
        public const uint XONLINE_E_CTP_BDK_E_CSR_AUTHZ_FAILED = 0x80190394;
        // "Caller is not an account administrator."
        public const uint XONLINE_E_CTP_BDK_E_NOT_ACCOUNT_ADMIN = 0x80190395;
        // "Delegate ID entered was invalid or not specified."
        public const uint XONLINE_E_CTP_BDK_E_DELEGATE_ID_UNSPECIFIED = 0x80190396;
        // "Requester Passport ID must be specified."
        public const uint XONLINE_E_CTP_BDK_E_REQUESTER_ID_UNSPECIFIED = 0x80190397;
        // "Boolean value must be 0 or 1"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_FLAG_VALUE = 0x80190398;
        // "Subscription service instance is inactive."
        public const uint XONLINE_E_CTP_BDK_E_PROVISIONING_INACTIVE_SUBSCRIPTION = 0x80190399;
        // "Invalid object."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_OBJECT_ID = 0x80190400;
        // "Input field length of first name does not meet requirement."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_FIRSTNAME_FIELD_LENGTH = 0x80190401;
        // "Input field length of last name does not meet requirement."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_LASTNAME_FIELD_LENGTH = 0x80190402;
        // "Input field length of address does not meet requirement."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ADDRESS_FIELD_LENGTH = 0x80190403;
        // "Calling partner is not registered in SPS database."
        public const uint XONLINE_E_CTP_BDK_E_PARTNERNOTINBILLING = 0x80190404;
        // "Rating error has occurred. Check the event log and the tracer."
        public const uint XONLINE_E_CTP_BDK_E_RATING_FAILURE = 0x80190405;
        // "BDKSVR2 started."
        public const uint XONLINE_E_CTP_BDK_SVR2_STARTED = 0x80190406;
        // "CSR call made."
        public const uint XONLINE_E_CTP_BDK_CSR_API_CALL_MADE = 0x80190407;
        // "CSR call attempt by non-CSR caller."
        public const uint XONLINE_E_CTP_BDK_E_CSR_CALL_FROM_NONCSR = 0x80190408;
        // "From and to payment instrument are not on the same account in TransferBalance."
        public const uint XONLINE_E_CTP_BDK_E_TRANS_BALANCE_MISMATCHING_ACCTS = 0x80190409;
        // "Invalid to payment instrument in TransferBalance."
        public const uint XONLINE_E_CTP_BDK_E_TRANS_BALANCE_TO_PI_INVALID = 0x80190410;
        // "Cannot transfer to same payment instrument in TransferBalance."
        public const uint XONLINE_E_CTP_BDK_E_TRANS_BALANCE_TO_SAME_PI = 0x80190411;
        // "Cannot transfer balances between payment instrument types."
        public const uint XONLINE_E_CTP_BDK_E_TRANS_BALANCE_NOT_ALLOW = 0x80190412;
        // "Internal database inconsistencies detected."
        public const uint XONLINE_E_CTP_BDK_E_INTERNAL_ERROR = 0x80190413;
        // "Payment instrument has outstanding balance."
        public const uint XONLINE_E_CTP_BDK_E_OUTSTANDING_BALANCE = 0x80190414;
        // "Invalid  data passed in ReferralData node. Verify that the node exists and that it contains valid XML (1-1024 characters)."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_REFERRALDATA_XML = 0x80190415;
        // "Invalid GUID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_GUID = 0x80190416;
        // "Payment instrument type not supported for SettleBalance."
        public const uint XONLINE_E_CTP_E_UNSUPPORTED_PAYMENT_INSTRUMENT = 0x80190417;
        // "Subscription is inactive."
        public const uint XONLINE_E_CTP_BDK_E_SUBSCRIPTION_INACTIVE = 0x80190418;
        // "Payments can only be stopped for credit card and direct debit transactions."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PM_FOR_STOP_PAYMENTS = 0x80190419;
        // "Excessive number of usage events reported in one ReportUsageEvent() call."
        public const uint XONLINE_E_CTP_BDK_E_EXCEEDS_MAX_NUMBER_OF_USAGE_EVENTS = 0x80190420;
        // "Field cannot be updated."
        public const uint XONLINE_E_CTP_BDK_E_FIELD_NOT_UPDATEABLE = 0x80190421;
        // "Calling CancelSubscription with an end date and in compute-only mode is not supported."
        public const uint XONLINE_E_CTP_BDK_E_DEFERRED_COMPUTE_ONLY_NOT_SUPPORTED = 0x80190422;
        // "The SETTLE event should be the last event in the event list for ImportSettleBillingItems."
        public const uint XONLINE_E_CTP_BDK_E_SETTLE_SHOULD_BE_THE_LAST_EVENT = 0x80190423;
        // "Line item payment method is no longer valid."
        public const uint XONLINE_E_CTP_BDK_E_PAYMENT_METHOD_NO_LONGER_VALID = 0x80190424;
        // "Failed to process all usage events."
        public const uint XONLINE_E_CTP_BDK_E_PROCESS_USAGE_EVENTS = 0x80190425;
        // "Object ID does not contain account and subscription information."
        public const uint XONLINE_E_CTP_BDK_E_WRONG_OBJECT_ID_TYPE = 0x80190426;
        // "Field contains invalid characters for a phone number."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PHONE_VALUE = 0x80190427;
        // "Invalid amount."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_AMOUNT_VALUE = 0x80190428;
        // "Payment instrument ID and line item ID do not match."
        public const uint XONLINE_E_CTP_BDK_E_MISMATCH_ACCTID_IN_CLOSEBALANCE = 0x80190429;
        // "InternalAddComment failed. Escalate error to SPG development."
        public const uint XONLINE_E_CTP_BDK_E_INTERNAL_ADD_COMMENT_FAILED = 0x80190430;
        // "Immediate settle flag value not supported."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_IMMEDIATE_SETTLE_VALUE = 0x80190431;
        // "No eligible records were found for this call."
        public const uint XONLINE_E_CTP_BDK_E_NO_RECORDS_FOR_STOP_PAYMENTS = 0x80190432;
        // "Failed to update the settlement amount table with credit card authorization results. This needs to be escalated to SPG development."
        public const uint XONLINE_E_CTP_BDK_E_FAILED_SETTLEMENT_AMOUNT_UPDATE = 0x80190433;
        // "The supplied telenumeric string does not consist of digits exclusively or exceeds the maximum limit."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TELENUMERIC_STRING = 0x80190434;
        // "There are no matches for the requested information."
        public const uint XONLINE_E_CTP_BDK_E_NO_MATCH = 0x80190435;
        // "There are multiple matches for the requested information."
        public const uint XONLINE_E_CTP_BDK_E_MULTIPLE_MATCHES = 0x80190436;
        // "PUID entered was invalid."
        public const uint XONLINE_E_CTP_BDK_E_BAD_PUID = 0x80190437;
        // "ObjectId length must be 16."
        public const uint XONLINE_E_CTP_BDK_E_BAD_OBJECT_ID_LENGTH = 0x80190438;
        // "Start period can never be greater than End period."
        public const uint XONLINE_E_CTP_BDK_E_END_PERIOD_LESS_THAN_START_PERIOD = 0x80190439;
        // "Billing period length must be 6."
        public const uint XONLINE_E_CTP_BDK_E_BAD_BILLING_PERIOD_LENGTH = 0x80190440;
        // "Value for returnStatementSet parameter for GetStatement API must be 0
        public const uint XONLINE_E_CTP_BDK_E_BAD_RETURN_STATEMENT_SET = 0x80190441;
        // "The usage event date specified was invalid.  One possible reason is that it is too far in the future."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_USAGE_EVENT_DATE = 0x80190442;
        // "The default billing period returned was null
        public const uint XONLINE_E_CTP_BDK_E_NULL_DEFAULT_BILLING_PERIOD = 0x80190443;
        // "The start billing period is less than the currently available billing period."
        public const uint XONLINE_E_CTP_BDK_E_BAD_START_BILLING_PERIOD = 0x80190444;
        // "The end billing period is less than the currently available billing period."
        public const uint XONLINE_E_CTP_BDK_E_BAD_END_BILLING_PERIOD = 0x80190445;
        // "The new due date is in the past"
        public const uint XONLINE_E_CTP_BDK_E_NEW_DUE_DATE_IS_PAST = 0x80190446;
        // "The new due date is more than MAXIMUM DELAY days in the future than the original due date"
        public const uint XONLINE_E_CTP_BDK_E_NEW_DUE_DATE_THRESHOLD_PASSED = 0x80190447;
        // "If the applydeclineEffect is off
        public const uint XONLINE_E_CTP_BDK_E_NO_NEW_DUE_DATE_SPECIFIED = 0x80190448;
        // "Invalid transaction type"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TRANSACTION_TYPE = 0x80190449;
        // "Invalid reason code"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_REASON_CODE = 0x80190450;
        // "Initialization of group SIDs from AD failed. It may indicate user group configuration is not correct or DNS failure."
        public const uint XONLINE_E_CTP_BDK_E_GROUP_SID_INITIALIZATION_FAILED = 0x80190451;
        // "This operation is not valid for wholesale payment instruments."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_OPERATION_FOR_WHOLESALE_PI = 0x80190452;
        // "This operation is not valid for direct debit payment instrument."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_OPERATION_FOR_DIRECT_DEBIT = 0x80190453;
        // "Adjustment amount exceeds the resource credit limit."
        public const uint XONLINE_E_CTP_BDK_E_EXCEEDS_RESOURCE_CREDIT_LIMIT = 0x80190454;
        // "Adjusting a resource balance is not allowed for subscriptions that are not active."
        public const uint XONLINE_E_CTP_BDK_E_ADJUST_RESOURCE_BALANCE_FOR_NONACTIVE_SUBS = 0x80190455;
        // "Failed to create mail record for account: %1."
        public const uint XONLINE_E_CTP_BDK_E_FAILED_TO_CREATE_MAIL_RECORD = 0x80190456;
        // "This MSNIA usage event is for a billing period that is not active
        public const uint XONLINE_E_CTP_BDK_E_MSNIA_LATE_USAGE = 0x80190457;
        // "Failed to write asynchronous immediate settlement failure into the audit db for account: %1."
        public const uint XONLINE_E_CTP_BDK_E_FAILED_TO_WRITE_TO_AUDIT_DB = 0x80190458;
        // "This offering is not configured as a referral offer."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_REFERRAL_OFFER = 0x80190459;
        // "Reward referral XML is required as this is a referral based offer."
        public const uint XONLINE_E_CTP_BDK_E_REWARD_REFERRAL_XML_REQUIRED = 0x80190460;
        // "Referral PUID not found."
        public const uint XONLINE_E_CTP_BDK_E_REFERRER_NOT_IN_SYSTEM = 0x80190461;
        // "Referrer has exceeded the max number of referrals configured on the offer."
        public const uint XONLINE_E_CTP_BDK_E_REFERRER_EXCEEDED_MAX_REFERRALS_ON_OFFER = 0x80190462;
        // "The referrer does not have an Active or Locked account in the system."
        public const uint XONLINE_E_CTP_BDK_E_REFERRER_NOT_ACTIVE = 0x80190463;
        // "The referrer cannot refer self for the offer."
        public const uint XONLINE_E_CTP_BDK_E_CANNOT_REFER_SELF = 0x80190464;
        // "The referral xml has reward referral info but the offer is not configured for reward referrals."
        public const uint XONLINE_E_CTP_BDK_E_OFFER_NOT_CONFIGURED_FOR_REFERRAL = 0x80190465;
        // "The reward referral schema in the referral xml is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_REWARD_REFFERAL_SCHEMA = 0x80190466;
        // "The referrer does not have any eligible offers configured for the reward."
        public const uint XONLINE_E_CTP_BDK_E_REFERRER_NOT_ELIGIBLE_FOR_REWARD_OFFER = 0x80190467;
        // "Invalid mandate status for SettleBalance."
        public const uint XONLINE_E_CTP_BDK_E_SETTLE_BALANCE_INVALID_MANDATE_STATUS = 0x80190468;
        // "More than one usage event reported to ReportSingleUsageEvent API"
        public const uint XONLINE_E_CTP_BDK_E_MULTIPLE_USAGE_EVENTS_REPORTED = 0x80190469;
        // "The reported usage is below the threshold in immediate settle usage."
        public const uint XONLINE_E_CTP_BDK_E_BELOW_IMMEDIATE_SETTLE_MINIMUM = 0x80190470;
        // "ReportUsage cannot be used for immediate settle of usage deals; use ReportSingleUsage."
        public const uint XONLINE_E_CTP_BDK_E_REPORT_USAGE_WITH_IMMEDIATE_SETTLE = 0x80190471;
        // "ReportUsage cannot be used for prepaid resource; use ReportSingleUsage."
        public const uint XONLINE_E_CTP_BDK_E_REPORT_USAGE_WITH_PREPAID = 0x80190472;
        // "ReportSingleUsage cannot be used with empty event set."
        public const uint XONLINE_E_CTP_BDK_E_NO_USAGE_EVENT_REPORTED = 0x80190473;
        // "The payment instrument type does not support immediate settlements"
        public const uint XONLINE_E_CTP_BDK_E_IMMEDIATE_SETTLE_NOT_AVAILABLE_FOR_PAYMENT_INSTRUMENT = 0x80190474;
        // "The reported resource and unit of measure do not match."
        public const uint XONLINE_E_CTP_BDK_E_RESOURCE_UNIT_OF_MEASURE_DO_NOT_MATCH = 0x80190475;
        // "Invalid  data passed in RedirectInputInfoXML node."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_REDIRECT_INPUTINFO_XML = 0x80190476;
        // "Transaction cannot be cancelled."
        public const uint XONLINE_E_CTP_BDK_E_TRANSACTION_NOT_CANCELLABLE = 0x80190477;
        // "No CDs found."
        public const uint XONLINE_E_CTP_BDK_E_NO_CDS_FOUND = 0x80190478;
        // "Charge descriptor (e.g. credit card descriptor or support info) has invalid characters or length"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CHARGE_DESCRIPTOR = 0x80190479;
        // "This Wholesale payment instrument has no related wholesale partner."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_WHOLESALEPI = 0x80190480;
        // "This partner is not BOBO wholesale partner."
        public const uint XONLINE_E_CTP_BDK_E_NOT_BOBOPARTNER = 0x80190481;
        // "This BOBO wholesale partner has no entitle endpoint."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BOBOPARTNER = 0x80190482;
        // "The entitlement endpoint web service could not be reached"
        public const uint XONLINE_E_CTP_BDK_E_ENTITLEMENT_ENDPOINT_UNAVAILABLE = 0x80190483;
        // "The entitlement endpoint returned a validation failure"
        public const uint XONLINE_E_CTP_BDK_E_ENTITLEMENT_VALIDATION_FAILED = 0x80190484;
        // "The entitlement endpoint is invalid"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ENTITLEMENT_ENDPOINT = 0x80190485;
        // "Calling partner does not have permissions to access the sandboxed object"
        public const uint XONLINE_E_CTP_BDK_E_NOT_AUTHORIZED_TO_ACCESS_OBJECT = 0x80190486;
        // "Calling partner does not have permissions to call on behalf of this partner"
        public const uint XONLINE_E_CTP_BDK_E_UNABLE_TO_CALL_ON_BEHALF_OF = 0x80190487;
        // "Taxware error. Check the event log and the tracer."
        public const uint XONLINE_E_CTP_BDK_E_TAXWARE_FAILURE = 0x80190488;
        // "Address validation error. Check the event log and the tracer."
        public const uint XONLINE_E_CTP_BDK_E_ADDRESS_VALIDATION_FAILURE = 0x80190489;
        // "VERAZIP: Invalid ZIP code."
        public const uint XONLINE_E_CTP_BDK_E_ZIP_INVALID = 0x80190490;
        // "VERAZIP: Invalid state code."
        public const uint XONLINE_E_CTP_BDK_E_STATE_INVALID = 0x80190491;
        // "VERAZIP: Missing ZIP code or city name."
        public const uint XONLINE_E_CTP_BDK_E_ZIP_CITY_MISSING = 0x80190492;
        // "VERAZIP: Invalid state code/ZIP code combination."
        public const uint XONLINE_E_CTP_BDK_E_STATE_ZIP_INVALID = 0x80190493;
        // "VERAZIP: Invalid state code/city name combination."
        public const uint XONLINE_E_CTP_BDK_E_STATE_CITY_INVALID = 0x80190494;
        // "VERAZIP: Invalid state code/ZIP code/city name combinations. Both state code/ZIP code and state code/city name were incorrect."
        public const uint XONLINE_E_CTP_BDK_E_STATE_ZIP_CITY_INVALID = 0x80190495;
        // "VERAZIP: Invalid state code/ZIP code/city name combination."
        public const uint XONLINE_E_CTP_BDK_E_STATE_ZIP_CITY_INVALID2 = 0x80190496;
        // "VERAZIP: Invalid state code/ZIP code/city name combination."
        public const uint XONLINE_E_CTP_BDK_E_STATE_ZIP_CITY_INVALID3 = 0x80190497;
        // "VERAZIP: Invalid state code/ZIP code/city name combination. Verify that state code was passed."
        public const uint XONLINE_E_CTP_BDK_E_STATE_ZIP_CITY_INVALID4 = 0x80190498;
        // "Missing PayPalPayIn RedirectURL."
        public const uint XONLINE_E_CTP_BDK_E_REDIRECTURL_MISSING = 0x80190499;
        // "Invalid soft descriptor."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SOFT_DESCRIPTOR = 0x80190500;
        // "Failed to create billing agreement."
        public const uint XONLINE_E_CTP_BDK_E_CANNOT_CREATE_BILLING_AGREEMENT = 0x80190501;
        // "Failed to get payPal billing agreement details."
        public const uint XONLINE_E_CTP_BDK_E_GET_BADETAIL_FAILED = 0x80190502;
        // "Cannot update PayPalPayin payment method again."
        public const uint XONLINE_E_CTP_BDK_E_CANNOT_UPDATE_PAYPALPAYIN_PAYMENT_METHOD_AGAIN = 0x80190503;
        // "PayPal-Payin invalid filed value."
        public const uint XONLINE_E_CTP_BDK_E_PP_INVALID_FIELD_VALUE = 0x80190504;
        // "VERAZIP: Multiple counties exist for state code/ZIP code/city name combination."
        public const uint XONLINE_E_CTP_BDK_E_MULTIPLE_COUNTIES_FOUND = 0x80190505;
        // "VERAZIP: Invalid state code for ZIP code. Changed to correct state code."
        public const uint XONLINE_E_CTP_BDK_E_ZIP_INVALID_FOR_ENTERED_STATE = 0x80190506;
        // "VERAZIP: ZIP code has multiple city names."
        public const uint XONLINE_E_CTP_BDK_E_STATE_ZIP_COVERS_MULTIPLE_CITIES = 0x80190507;
        // "VERAZIP: City has multiple ZIP codes."
        public const uint XONLINE_E_CTP_BDK_E_MULTIPLE_CITIES_FOUND = 0x80190508;
        // "Incorrect city name length."
        public const uint XONLINE_E_CTP_BDK_E_BAD_CITYNAME_LENGTH = 0x80190509;
        // "Incorrect country code length."
        public const uint XONLINE_E_CTP_BDK_E_BAD_COUNTRYCODE_LENGTH = 0x80190510;
        // "Incorrect code length for state or province."
        public const uint XONLINE_E_CTP_BDK_E_BAD_STATECODE_LENGTH = 0x80190511;
        // "Incorrect zip code length."
        public const uint XONLINE_E_CTP_BDK_E_BAD_ZIPCODE_LENGTH = 0x80190512;
        // "Incorrect product code length."
        public const uint XONLINE_E_CTP_BDK_E_BAD_PRODUCTCODE_LENGTH = 0x80190513;
        // "Incorrect business location code length."
        public const uint XONLINE_E_CTP_BDK_E_BAD_BUSINESSLOCATIONCODE_LENGTH = 0x80190514;
        // "Incorrect transaction date length."
        public const uint XONLINE_E_CTP_BDK_E_BAD_TRANSACTIONDATE_LENGTH = 0x80190515;
        // "Incorrect VAT registration length."
        public const uint XONLINE_E_CTP_BDK_E_BAD_VATREGISTRATION_LENGTH = 0x80190516;
        // "Incorrect currency code length."
        public const uint XONLINE_E_CTP_BDK_E_BAD_CURRENCYCODE_LENGTH = 0x80190517;
        // "Incorrect WorldTax code length."
        public const uint XONLINE_E_CTP_BDK_E_BAD_WTCODE_LENGTH = 0x80190518;
        // "Invalid input parameter passed to TaxWare or VeraZip."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_INPUT_TO_TAXWARE_OR_VERAZIP = 0x80190519;
        // "The Vat ID provided is of invalid format."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_VATID_FORMAT = 0x80190520;
        // "The Vat ID provided is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_VATID_INVALID = 0x80190521;
        // "Input string contains unsupported characters."
        public const uint XONLINE_E_CTP_BDK_E_UNSUPPORTED_CHAR_EXIST = 0x80190522;
        // "Country code in Address does not match with the country code in Account Info."
        public const uint XONLINE_E_CTP_BDK_E_ERROR_COUNTRYCODE_MISMATCH = 0x80190523;
        // "A Country code is required in Account Info."
        public const uint XONLINE_E_CTP_BDK_E_ERROR_COUNTRYCODE_REQUIRED = 0x80190524;
        // "Token passed is Invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TOKEN_SPECIFIED = 0x80190525;
        // "The token is already blacklisted."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_ALREADY_BLACKLISTED = 0x80190526;
        // "The token is already un-blacklisted."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_ALREADY_UNBLACKLISTED = 0x80190527;
        // "The specified token has been blacklisted."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_BLACKLISTED = 0x80190528;
        // "The specified token belongs to a blacklisted token range."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_RANGE_BLACKLISTED = 0x80190529;
        // "The usage for the specified token has been exceeded."
        public const uint XONLINE_E_CTP_BDK_E_USAGE_COUNT_FOR_TOKEN_EXCEEDED = 0x80190530;
        // "Token Expiry date not set as may be duration based token was not activated correctly."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_EXPIRY_DATE_SET_AS_NULL = 0x80190531;
        // "Failed while consumption to create an entry in token_instance_deal_subscription table."
        public const uint XONLINE_E_CTP_BDK_E_FAILED_INSERTING_TOKEN_INS_DEAL_SUBS = 0x80190532;
        // "Not found non-active token range to be activated."
        public const uint XONLINE_E_CTP_BDK_E_ACTIVATE_TOKEN_RANGE_NOT_PRESENT = 0x80190533;
        // "The specified token has expired."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_EXPIRED = 0x80190534;
        // "The specified token cannot be used yet."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_NOT_STARTED = 0x80190535;
        // "The specified token has not been activated yet."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_RANGE_NOT_ACTIVE = 0x80190536;
        // "The reason code specified is not valid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BLACKLIST_HISTORY_REASON_CODE = 0x80190537;
        // "The specified action is in progress."
        public const uint XONLINE_E_CTP_BDK_E_TRACKING_GUID_NODATA = 0x80190538;
        // "The specified tracking has already been used"
        public const uint XONLINE_E_CTP_BDK_E_DUPLICATE_TOKEN_TRACKING_GUID = 0x80190539;
        // "The specified token has already been activated"
        public const uint XONLINE_E_CTP_BDK_E_ALREADY_ACTIVATED = 0x80190540;
        // "Committed status is not valid for this API."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_COMMITTED_STATUS = 0x80190541;
        // "The description specified is not valid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BLACKLIST_HISTORY_DESCRIPTION = 0x80190542;
        // "Blacklist Effective date passed was prior to the order creation date."
        public const uint XONLINE_E_CTP_BDK_E_BLACKLIST_EFFECTIVE_DATE_LESS_THAN_ORDER_CREATION_DATE = 0x80190543;
        // "The Token has been consumed."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_CONSUMED = 0x80190544;
        // "Part Number specified for the token import is not a valid part number for the associated token class."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PART_NUMBER_FOR_TOKEN_CLASS = 0x80190545;
        // "External reference id is too long or invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_EXTERNAL_REFERENCE_ID = 0x80190546;
        // "The token is already deactivated."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_ALREADY_DEACTIVATED = 0x80190547;
        // "Token Passed in for consumption is a replacement token for which PUID specified at the time of replacement does not match the account admin PUID."
        public const uint XONLINE_E_CTP_BDK_E_REPLACEMENT_TOKEN_PUID_MISMATCH = 0x80190548;
        // "Null parameter was passed for Token Class GUID during token class access verification."
        public const uint XONLINE_E_CTP_ERROR_NULL_INPUT_PARAMETER_TOKEN_CLASS_GUID = 0x80190549;
        // "The argument specified is not a valid bookmark."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BOOKMARK = 0x80190550;
        // "The max argument must be between 1 and 50."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_MAX = 0x80190551;
        // "Internal inconsistency in Token Database."
        public const uint XONLINE_E_CTP_BDK_E_INTERNAL_ERROR_TOKEN = 0x80190552;
        // "The version specified is not supported."
        public const uint XONLINE_E_CTP_BDK_E_UNSUPPORTED_VERSION = 0x80190553;
        // "The quantity specified is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_QUANTITY = 0x80190554;
        // "Invalid product type"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PRODUCT_TYPE = 0x80190555;
        // "The input item external id is duplicate"
        public const uint XONLINE_E_CTP_BDK_E_DUPLICATE_ITEM_EXTERNAL_ID = 0x80190556;
        // "No tax rule was returned for the specified country
        public const uint XONLINE_E_CTP_BDK_E_NO_TAX_RULE_CONFIGURED = 0x80190557;
        // "Fail to calculate tax"
        public const uint XONLINE_E_CTP_BDK_E_TAX_CALCULATION_FAILURE = 0x80190558;
        // "No tax info associated with the account"
        public const uint XONLINE_E_CTP_BDK_E_NO_ASSOCIATED_TAX_INFO = 0x80190559;
        // "Invalid tax calculation info."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TAX_CALCULATION_INFO = 0x80190560;
        // "Tax inclusive calculation cannot be performed for US and CA."
        public const uint XONLINE_E_CTP_BDK_E_NO_TAX_INCLUSIVE_CALCULATION = 0x80190561;
        // "Invalid revenue sku."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_REVENUE_SKU = 0x80190562;
        // "Invalid tax amount."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TAX_AMOUNT = 0x80190563;
        // "Invalid tax rate."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TAX_RATE = 0x80190564;
        // "Invalid billing mode."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BILLING_MODE = 0x80190565;
        // "Invalid item entry set."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ITEM_ENTRY_SET = 0x80190566;
        // "Failed to execute operation in billing component."
        public const uint XONLINE_E_CTP_BDK_E_BILLING_FAILURE = 0x80190567;
        // "Failed to execute operation in billing component
        public const uint XONLINE_E_CTP_BDK_E_BILLING_RETRYABLE_FAILURE = 0x80190568;
        // "The original order is is not specified."
        public const uint XONLINE_E_CTP_BDK_E_ORIGINAL_ORDER_ID_NOT_SPECIFIED = 0x80190569;
        // "No matching billing configuration for the specified partner
        public const uint XONLINE_E_CTP_BDK_E_NO_MATCHING_BILLING_CONFIGURATION = 0x80190570;
        // "Invalid billing reference id."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_BILLING_REFERENCE_ID = 0x80190571;
        // "The billing reference id has already been removed."
        public const uint XONLINE_E_CTP_BDK_E_BILLING_REFERENCE_ID_ALREADY_REMOVED = 0x80190572;
        // "Unable to retrieve event ID and billing impact for event."
        public const uint XONLINE_E_CTP_BDK_E_PROCESSIMPORT_OFFSET_LINE_MISSING_FIELD = 0x80190573;
        // "Unable to find line item matching event."
        public const uint XONLINE_E_CTP_BDK_E_PROCESSIMPORT_OFFSET_LINE_MISSING_MATCH_EVENT = 0x80190574;
        // "Cannot process if there is an offset of an offset."
        public const uint XONLINE_E_CTP_BDK_E_CANCELREFUND_OFFSET_OF_OFFSET = 0x80190575;
        // "This can't happen
        public const uint XONLINE_E_CTP_BDK_E_CANCELREFUND_BOTH_LINE_AND_RELATED_LINE = 0x80190575;
        // "The session key passed in does not pass validation checks."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SESSION_KEY = 0x80190577;
        // "This object ID is not entitled to get a deliverable token."
        public const uint XONLINE_E_CTP_BDK_E_NO_PRODUCT_KEY_FOR_OBJECT_ID = 0x80190578;
        // "The token cannot be issued
        public const uint XONLINE_E_CTP_BDK_E_PRODUCT_KEY_NOT_AVAILABLE = 0x80190579;
        // "Either PIN or Sequence number is required as input parameter to validate Token."
        public const uint XONLINE_E_CTP_BDK_E_PIN_OR_SEQ_REQUIRED = 0x80190580;
        // "Either Token Class Guid or Signature or Part Number should be specified for validating Token."
        public const uint XONLINE_E_CTP_BDK_E_INPUT_PARAM_MALFORMED = 0x80190581;
        // "The offset must be between -1 and 365 inclusive."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ADJUSTMENT_OFFSET = 0x80190582;
        // "Invalid item instance ID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ITEM_INSTANCE_ID = 0x80190583;
        // "Invalid reason for reverse operation."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_REVERSE_REASON = 0x80190584;
        // "Only 1 item can be purchased at once."
        public const uint XONLINE_E_CTP_BDK_E_TOO_MANY_ITEMS_IN_PURCHASE = 0x80190585;
        // "PurchaseItem accepts only offers that are configured for item
        public const uint XONLINE_E_CTP_BDK_E_INVALID_OFFERING_TYPE = 0x80190586;
        // "The price specified must be a positive value."
        public const uint XONLINE_E_CTP_BDK_E_PRICE_IS_NEGATIVE = 0x80190587;
        // "Cannot pass in a price and/or currency because it is configured on the item."
        public const uint XONLINE_E_CTP_BDK_E_DYNAMIC_PRICE_CONFIGURATION = 0x80190588;
        // "The maximum allowable DMP point balance is exceeded."
        public const uint XONLINE_E_CTP_BDK_E_DMP_MAX_BALANCE_EXCEEDED = 0x80190589;
        // "Calling partner needs to add a currency because it is not pre-configured."
        public const uint XONLINE_E_CTP_BDK_E_CURRENCY_MISSING = 0x80190590;
        // "The user already has a pending purchase for for this item that must first be cancelled or completed."
        public const uint XONLINE_E_CTP_BDK_E_PENDING_ITEM_PURCHASE = 0x80190591;
        // "Unable to talk to DMP system."
        public const uint XONLINE_E_CTP_BDK_E_DMP_FLOW_NOT_ENABLED = 0x80190592;
        // "Item has been already reversed."
        public const uint XONLINE_E_CTP_BDK_E_ITEM_ALREADY_REVERSED = 0x80190593;
        // "Reversing an item that has not been fulfilled."
        public const uint XONLINE_E_CTP_BDK_E_ITEM_NOT_FULFILLED = 0x80190594;
        // "Unknown DMP error has occurred."
        public const uint XONLINE_E_CTP_BDK_E_DMP_UNKNOWN_ERROR = 0x80190595;
        // "Payment method type does not support operation."
        public const uint XONLINE_E_CTP_BDK_E_ACTION_NOT_APPLICABLE_FOR_PAYMENT_TYPE = 0x80190596;
        // "Redirect vendor returned an invalid CancelTransaction result."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CANCEL_TRANSACTION_RESULT = 0x80190597;
        // "CVM code Missing"
        public const uint XONLINE_E_CTP_BDK_E_CVM_MISSING = 0x80190598;
        // "A fre Trial cannot be purchased using an account. Use only the PUID"
        public const uint XONLINE_E_CTP_BDK_E_ACCOUNT_CANNOT_PURCHASE_FREE_TRIAL = 0x80190599;
        // "Countries in the billable account (in payment method XML) of the donor and the Points account of the beneficiary mismatch"
        public const uint XONLINE_E_CTP_BDK_E_DONOR_BENEFICIARY_COUNTRY_MISMATCH = 0x80190600;
        // "The donor and the beneficiary are the same."
        public const uint XONLINE_E_CTP_BDK_E_DONOR_BENEFICIARY_SAME = 0x80190601;
        // "The renewal does not exists."
        public const uint XONLINE_E_CTP_BDK_E_RENEWAL_DOES_NOT_EXISTS = 0x80190602;
        // "The token schedule rennewal exists for this offer."
        public const uint XONLINE_E_CTP_BDK_E_TOKEN_SCHEDULED_RENEWAL_EXISTS = 0x80190603;
        // "The event could not be queued to notification engine frequently."
        public const uint XONLINE_E_CTP_BDK_E_NOTIFICATION_QUEUE_EVENT_FAIL_FREQUENTLY = 0x80190604;
        // "Unknown notification client error."
        public const uint XONLINE_E_CTP_BDK_E_NOTIFICATION_CLIENT_UNKNOWN_ERROR = 0x80190605;
        // "Notification client initialization failure."
        public const uint XONLINE_E_CTP_BDK_E_NOTIFICATION_CLIENT_INIT_FAIL = 0x80190606;
        // "Notification client queue option is not well configured in tower db."
        public const uint XONLINE_E_CTP_BDK_E_NOTIFICATION_CLIENT_INVALID_QUEUE_OPTION = 0x80190607;
        // "Notification client performs too slow."
        public const uint XONLINE_E_CTP_BDK_E_NOTIFICATION_CLIENT_TOO_SLOW = 0x80190608;
        // "The event could not be queued to notification engine but not happens frequently."
        public const uint XONLINE_E_CTP_BDK_E_NOTIFICATION_QUEUE_EVENT_FAIL_NOT_FREQUENTLY = 0x80190609;
        // "The notification is not related to any partner subscriptions."
        public const uint XONLINE_E_CTP_BDK_E_NOTIFICATION_NO_RELATED_PARTNER_SUBS = 0x80190610;
        // "Specified Discount is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_DISCOUNT = 0x80190611;
        // "Could not insert into a discount table."
        public const uint XONLINE_E_CTP_BDK_E_INSERT_DISCOUNT = 0x80190612;
        // "Only one discount permitted per subscription."
        public const uint XONLINE_E_CTP_BDK_E_DISCOUNT_ALREADY_APPLIED = 0x80190613;
        // "Token is a discount coupon yet no discount was passed."
        public const uint XONLINE_E_CTP_BDK_E_DISCOUNT_REQUIRED_FOR_TOKEN = 0x80190614;
        // "Token is a discount coupon and cannot be associated with a deal."
        public const uint XONLINE_E_CTP_BDK_E_DISCOUNT_TOKEN = 0x80190615;
        // "Failed to insert record into discount_localize table."
        public const uint XONLINE_E_CTP_BDK_E_INSERT_DISCOUNT_LOCALIZE = 0x80190616;
        // "Per Account Usage limit was exceeded for discount."
        public const uint XONLINE_E_CTP_BDK_E_DISCOUNT_USAGE_EXCEEDED = 0x80190617;
        // "Token class and discount are not a valid combination."
        public const uint XONLINE_E_CTP_BDK_E_DISCOUNT_TOKEN_CLASS_MISMATCH = 0x80190618;
        // "Partner does not have access to the specified customer type"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CUSTOMER_TYPE_FOR_PARTNER = 0x80190619;
        // "Category should not be null."
        public const uint XONLINE_E_CTP_BDK_E_NULL_CATEGORY = 0x80190620;
        // "Account ID cannot be null."
        public const uint XONLINE_E_CTP_BDK_E_NULL_ACCOUNTID = 0x80190621;
        // "Subscription Ref ID cannot be null."
        public const uint XONLINE_E_CTP_BDK_E_NULL_SUBSCRIPTIONREFID = 0x80190622;
        // "Invalid Survey Result Code."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SURVEYRESULTCODE = 0x80190623;
        // "CD not found."
        public const uint XONLINE_E_CTP_BDK_E_CD_NOTFOUND = 0x80190624;
        // "Invalid Account ID."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ACCOUNTID = 0x80190625;
        // "Invalid AnonymousInfo Xml."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ANONYMOUS_INFO_XML = 0x80190626;
        // "Unsupported object type."
        public const uint XONLINE_E_CTP_BDK_E_UNSUPPORTED_OBJECT_TYPE = 0x80190627;
        // "Invalid Phone XML."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PHONE_XML = 0x80190628;
        // "Invalid requestor info. Valid Requestor Info has a size limit of 256 Characters."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_REQUESTOR_INFO = 0x80190629;
        // "There are pending transactions on this deal or subscription."
        public const uint XONLINE_E_CTP_BDK_E_PENDING_TRANSACTIONS = 0x80190630;
        // "The lineitem id and settlement id do not match"
        public const uint XONLINE_E_CTP_BDK_E_LINEITEM_SETTLEMENT_AMOUNT_NOT_MATCH = 0x80190631;
        // "Invalid original charge details"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ORIGINAL_CHARGE_DETAILS = 0x80190632;
        // "Partial Chargeback cannot be Processed"
        public const uint XONLINE_E_CTP_BDK_E_PARTIAL_CHAREGBACK = 0x80190633;
        // "Invalid lineitem id for reversal"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_LINEITEM_ID_FOR_REVERSAL = 0x80190634;
        // "Invalid chargeback date. Chargeback date must greater or equals to original settlement date"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CHARGEBACK_DATE = 0x80190635;
        // "Invalid chargeback amount."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CHARGEBACK_AMOUNT = 0x80190636;
        // "Tax was already offset for this line item."
        public const uint XONLINE_E_CTP_BDK_E_ALREADY_OFFSET_TAX = 0x80190637;
        // "mappoint is not enabled for the country code."
        public const uint XONLINE_E_CTP_BDK_E_COUNTRY_CODE_MAPPOINT_NOT_ENABLED = 0x80190638;
        // "SCS had error connecting to mappoint due to some network problems."
        public const uint XONLINE_E_CTP_BDK_E_NETWORK_ERROR_CONNECTING_TO_MAPPOINT = 0x80190639;
        // "SCS had some internal error connecting that is preventing connection to mappoint."
        public const uint XONLINE_E_CTP_BDK_E_INTERNAL_ERROR_CONNECTING_TO_MAPPOINT = 0x80190640;
        // "Mappoint returned 0 addresses."
        public const uint XONLINE_E_CTP_BDK_E_ZERO_ADDRESSES_BY_MAPPOINT = 0x80190641;
        // "UNKNOWN ERROR in MAPPOINT API."
        public const uint XONLINE_E_CTP_BDK_E_UNKNOWN_ERROR = 0x80190642;
        // "UNKNOWN ERROR ENCOUNTERED."
        public const uint XONLINE_E_CTP_BDK_E_UPDATE_ADDRESS_UNKNOWN_ERROR = 0x80190643;
        // "Invalid AddressInfo Xml."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ADDRESSINFOXML = 0x80190644;
        // "Mappoint does not support Post Box Addresses currently."
        public const uint XONLINE_E_CTP_BDK_E_POST_BOX_ERROR_MAPPOINT = 0x80190645;
        // "The connection to Mappoint has timed out."
        public const uint XONLINE_E_CTP_BDK_E_MAPPOINT_CONNECTION_MAPPOINT = 0x80190646;
        // "Invalid Chargeback details provided as input"
        public const uint XONLINE_E_CTP_BDK_E_ERROR_INVALID_CHARGEBACK_INPUT_DETAILS = 0x80190647;
        // "Chargeback id not found"
        public const uint XONLINE_E_CTP_BDK_E_CHARGEBACK_NOT_FOUND = 0x80190648;
        // "Chargeback id did not match"
        public const uint XONLINE_E_CTP_BDK_E_CHARGEBACK_NOT_MATCH = 0x80190649;
        // "Double chargeback"
        public const uint XONLINE_E_CTP_BDK_E_DOUBLE_CHARGEBACK = 0x80190650;
        // "Invalid chargebacklineitem id"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CHARGEBACK_LINEITEM_ID = 0x80190651;
        // "Invalid reversal chargeback id"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CHARGEBACK_REVERSAL_ID = 0x80190652;
        // "Invalid chargeback for reversal chargeback id"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CHARGEBACK_ID_FOR_REVERSAL_CHARGEBACK_ID = 0x80190653;
        // "invalid lineitem id for chargeback id"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_LINEITEM_ID_FOR_CHARGEBACK_ID = 0x80190654;
        // "invalid lineitem id"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_LINEITEM_TYPE = 0x80190655;
        // "Double chargeback for reversal"
        public const uint XONLINE_E_CTP_BDK_E_DOUBLE_CHARGEBACK_FOR_REVERSAL = 0x80190656;
        // "The country of the address is not supported at this time"
        public const uint XONLINE_E_CTP_BDK_E_COUNTRY_NOT_SUPPORTED = 0x80190657;
        // "SCS has temporarily disabled MAPPOINT support for this country"
        public const uint XONLINE_E_CTP_BDK_E_COUNTRY_MAPPOINT_DISABLED = 0x80190658;
        // "The input parameter is incorrect"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PARAMETER = 0x80190659;
        // "The input ratingrules is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_INPUT_RATINGRULE_DATA = 0x80190660;
        // "Invalid time conversion ratio for time extension."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TIME_CONVERSION_RATIO = 0x80190661;
        // "Invalid round day boundary for time extension."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ROUND_DAY_BOUNDARY = 0x80190662;
        // "Time extension is not supported for target subscription."
        public const uint XONLINE_E_CTP_BDK_E_TIME_EXTENSION_NOT_SUPPORTED = 0x80190663;
        // "The subscription status is invalid for committing subscription conversion."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SUBS_STATUS_FOR_COMMIT_CONVERT = 0x80190664;
        // "The subscription status is invalid for committing subscription creation."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SUBS_STATUS_FOR_COMMIT_CREATESUBS = 0x80190665;
        // "Tax code is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TAX_CODE = 0x80190666;
        // "Multiple charge or proration rating rule found."
        public const uint XONLINE_E_CTP_BDK_E_MULTIPLE_RATING_RULE_FOUND = 0x80190667;
        // "The subscription status is invalid for abandoning subscription conversion."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SUBS_STATUS_FOR_ABANDON_CONVERT = 0x80190668;
        // "The subscription status is invalid for abandoning subscription creation."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SUBS_STATUS_FOR_ABANDON_CREATESUBS = 0x80190669;
        // "Tax included info is invalid."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TAX_INCLUDED = 0x80190670;
        // "Invalid description or price description."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_DESCRIPTION_PRICEDESC = 0x80190671;
        // "Renew mode of subscription conversion is not supported."
        public const uint XONLINE_E_CTP_BDK_E_RENEW_SUBSCRIPTION_NOT_SUPPORTED = 0x80190672;
        // "Invalid ChargebackID Generation."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_CHARGEBACK_ID = 0x80190673;
        // "Error when Chargeback Processing Failure."
        public const uint XONLINE_E_CTP_BDK_E_CHARGEBACK_PROCESSING_FAILURE = 0x80190674;
        // "Invalid Merchant Reference Number."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_MERCHANT_REFERENCE = 0x80190675;
        // "Error when any input details missing."
        public const uint XONLINE_E_CTP_BDK_E_CHARGEBACK_INFO_MISSING = 0x80190676;
        // "Error while recording chargeback/reversal in Chargeback History table."
        public const uint XONLINE_E_CTP_BDK_E_RECORD_CHARGEBACK_FAILED = 0x80190677;
        // "Double Chargeback Reversal"
        public const uint XONLINE_E_CTP_BDK_E_DOUBLE_CHARGEBACK_REVERSAL = 0x80190678;
        // "Chargeback Processing Reversal"
        public const uint XONLINE_E_CTP_BDK_E_REVERSAL_OF_PROCESSED_CHARGEBACK = 0x80190679;
        // "Payment instrument not associated with subscription"
        public const uint XONLINE_E_CTP_BDK_E_MISMATCH_PAYMENT_SUBSCRIPTION = 0x80190680;
        // "Subscription already converted or renewed"
        public const uint XONLINE_E_CTP_BDK_E_SUBSCRIPTION_ALREADY_CONVERTED_OR_RENEWED = 0x80190681;
        // "Merchant Reference Number missing"
        public const uint XONLINE_E_CTP_BDK_E_MERCHANT_REFERENCE_NUMBER_MISSING = 0x80190682;
        // "Invalid Encrypt Account number"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_ENCRYPT_ACCOUNT_NUMBER = 0x80190683;
        // "Subscription has been scheduled to renew"
        public const uint XONLINE_E_CTP_BDK_E_SUBSCRIPTION_SCHEDULED_RENEWAL = 0x80190684;
        // "Account holder's profile already exists."
        public const uint XONLINE_E_CTP_BDK_E_PROFILE_ALREADY_EXISTS = 0x80190685;
        // "Account holder's profile does not exist."
        public const uint XONLINE_E_CTP_BDK_E_PROFILE_DOES_NOT_EXIST = 0x80190686;
        // "Account does not have an address associated with it."
        public const uint XONLINE_E_CTP_BDK_E_ACCOUNT_WITHOUT_ADDRESS = 0x80190687;
        // "Payout preference (default) is not set."
        public const uint XONLINE_E_CTP_BDK_E_NO_PAYOUT_PREFERENCE = 0x80190688;
        // "Payout preference (default) can not be deleted."
        public const uint XONLINE_E_CTP_BDK_E_CAN_NOT_DELETE_DEFAULT_PAYOUT_PREFERENCE = 0x80190689;
        // "Invalid PayUserInfo XML."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_PAYUSERINFOXML = 0x80190690;
        // "Invalid UserProfile XML."
        public const uint XONLINE_E_CTP_BDK_E_INVALID_USERPROFILEXML = 0x80190691;
        // "Account ID must not be specified."
        public const uint XONLINE_E_CTP_BDK_E_CANNOT_SPECIFY_BILLABLE_ACCOUNT_ID = 0x80190692;
        // "Description length exceeded"
        public const uint XONLINE_E_CTP_BDK_E_DESCRIPTION_MAXLENGTH_EXCEEDED = 0x80190693;
        // "RiME returns Rejected"
        public const uint XONLINE_E_CTP_BDK_E_RIME_REJECTED = 0x80190694;
        // "Invalid Values were sent to RiME"
        public const uint XONLINE_E_CTP_BDK_E_RIME_INVALID_VALUE = 0x80190695;
        // "Referral code not found in SCS database"
        public const uint XONLINE_E_CTP_BDK_E_REFERRAL_CODE_NOT_FOUND = 0x80190696;
        // "Billing subsystem doesn't support line item id for processing chargeback"
        public const uint XONLINE_E_CTP_BDK_E_BSS_NOT_SUPPORTED_LINE_ITEM_ID = 0x80190697;
        // "Billing subsystem encountered internal error."
        public const uint XONLINE_E_CTP_BDK_E_BSS_INTERNAL_SERVER_ERROR = 0x80190698;
        // "Billing subsystem only
        public const uint XONLINE_E_CTP_BDK_E_BSS_INVALID_ORDER_STATUS = 0x80190699;
        // "Billing subsystem doesn't support partial chargeback."
        public const uint XONLINE_E_CTP_BDK_E_BSS_PARITAL_CHARGE_BACK = 0x80190700;
        // "Timeout when calling billing subsystem."
        public const uint XONLINE_E_CTP_BDK_E_BSS_TIMEOUT_ERROR = 0x80190701;
        // "There is no existing provisioning information to complete this call"
        public const uint XONLINE_E_CTP_ERROR_MISSING_PROV_INFO = 0x80190702;
        // "Invalid Resource Type"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_RESOURCE_TYPE = 0x80190703;
        // "fail when submit to payment provider"
        public const uint XONLINE_E_CTP_BDK_E_PAYMENT_PROVIDER_SUBMISSION_FAILED = 0x80190704;
        // "declined when submit to payment provider"
        public const uint XONLINE_E_CTP_BDK_E_PAYMENT_PROVIDER_SUBMISSION_DECLINED = 0x80190705;
        // "fail to encrypt file"
        public const uint XONLINE_E_CTP_BDK_E_ENCRYPTION_FAILURE = 0x80190706;
        // "BDK_E_DMP_FIRST"
        public const uint XONLINE_E_CTP_BDK_E_DMP_FIRST = 0x80190707;
        // "BDK_E_DMP_LAST"
        public const uint XONLINE_E_CTP_BDK_E_DMP_LAST = 0x80190708;
        // "Invalid target user information specified"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TARGET_USER_INFORMATION = 0x80190709;
        // "Invalid delegate user information"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_DELEGATE_USER_INFORMATION = 0x80190710;
        // "Invalid source information"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_SOURCE_USER_INFORMATION = 0x80190711;
        // "Invalid transaction Id"
        public const uint XONLINE_E_CTP_BDK_E_INVALID_TRANSACTION_INFORMATION = 0x80190712;
        // "Transaction information passed in does not match the information stored"
        public const uint XONLINE_E_CTP_BDK_E_NO_MATCHING_TRANSACTION = 0x80190713;
        // "Unable to find transaction in PENDING_PAYOUT state matching the input parameters"
        public const uint XONLINE_E_CTP_BDK_E_NO_MATCHING_PENDINGPAYOUT_TRANSACTION = 0x80190714;
        // "Unable to find transaction in PENDING state matching the input parameters"
        public const uint XONLINE_E_CTP_BDK_E_NO_MATCHING_PENDING_TRANSACTION = 0x80190715;
        // "BDK_E_ORDER_LAYER_FIRST"
        public const uint XONLINE_E_CTP_BDK_E_ORDER_LAYER_FIRST = 0x80190716;
        // "BDK_E_ORDER_LAYER_LAST"
        public const uint XONLINE_E_CTP_BDK_E_ORDER_LAYER_LAST = 0x80190717;
        // "BDK_E_TRANSACTION_LAYER_FIRST"
        public const uint XONLINE_E_CTP_BDK_E_TRANSACTION_LAYER_FIRST = 0x80190718;
        // "BDK_E_TRANSACTION_LAYER_LAST"
        public const uint XONLINE_E_CTP_BDK_E_TRANSACTION_LAYER_LAST = 0x80190719;
        // "Provisioning call from MPF to endpoint failed."
        public const uint XONLINE_E_CTP_BDK_E_PROVISIONING_MPF_CALL_FAILED = 0x80190720;
        // "Invalid adjustment date offset."
        public const uint XONLINE_E_CTP_BDK_E_PROVISIONING_INVALID_ADJUSTMENT_OFFSET = 0x80190721;
        // "Invalid arguments."
        public const uint XONLINE_E_CTP_BDK_E_PROVISIONING_INVALID_ARG = 0x80190722;
        // "Response file received but no request file sent for it."
        public const uint XONLINE_E_CTP_AU_E_NO_REQUEST_SENT = 0x80190723;
        // "CC Account Updater already run for the current day."
        public const uint XONLINE_E_CTP_AU_E_DUPLICATE_RUN = 0x80190724;
        // "Batch files are not configured properly: input
        public const uint XONLINE_E_CTP_AU_E_BAD_BATCH_FORMAT = 0x80190725;
        // "Could not archive inquiry / response file."
        public const uint XONLINE_E_CTP_AU_E_FAIL_TO_ARCHIVE = 0x80190726;
        // "Cannot generate Inquiry file."
        public const uint XONLINE_E_CTP_AU_E_FAIL_TO_GENERATE_INQUIRY_FILE = 0x80190727;
        // "Task for inquiry file generation ended: error(s) found(s) during process
        public const uint XONLINE_E_CTP_AU_E_INQUIRY_GENERATION_TASK_ENDED_UNSUCCESSFULLY = 0x80190728;
        // "Task for response file processing ended: error(s) found(s) during process
        public const uint XONLINE_E_CTP_AU_E_RESPONSE_PROCESS_TASK_ENDED_UNSUCCESSFULLY = 0x80190729;
        // "Task for response file processing ended: error(s) found(s) during process
        public const uint XONLINE_E_CTP_AU_E_UPDATE_PROCESS_TASK_ENDED_UNSUCCESSFULLY = 0x80190730;
        // "Task for request file sending ended: error(s) found(s) during process
        public const uint XONLINE_E_CTP_PP_E_REQUEST_PROCESS_TASK_ENDED_UNSUCCESSFULLY = 0x80190731;
        // "Task for response file processing ended: error(s) found(s) during process
        public const uint XONLINE_E_CTP_PP_E_RESPONSE_PROCESS_TASK_ENDED_UNSUCCESSFULLY = 0x80190732;
        // "SCS_E_CERT_INAVLID"
        public const uint XONLINE_E_CTP_SCS_E_CERT_INAVLID = 0x80190733;
        // "SCS_E_INAVLID_CALLING_PARTNER"
        public const uint XONLINE_E_CTP_SCS_E_INAVLID_CALLING_PARTNER = 0x80190734;
        // "BDK_E_RISK_EVALUATION_FAILED"
        public const uint XONLINE_E_CTP_BDK_E_RISK_EVALUATION_FAILED = 0x80190735;
        // "BDK_E_RISK_EVALUATION_EXCEPTION"
        public const uint XONLINE_E_CTP_BDK_E_RISK_EVALUATION_EXCEPTION = 0x80190736;
        // "BDK_E_RISK_EVALUATION_UNDEFINED"
        public const uint XONLINE_E_CTP_BDK_E_RISK_EVALUATION_UNDEFINED = 0x80190737;
        // "BDK_E_RISK_CONFIGURATION_ERROR"
        public const uint XONLINE_E_CTP_BDK_E_RISK_CONFIGURATION_ERROR = 0x80190738;
        // "BDK_E_RISK_NEXT"
        public const uint XONLINE_E_CTP_BDK_E_RISK_NEXT = 0x80190739;
        // "Risk Engine throw exception"
        public const uint XONLINE_E_CTP_BDK_E_RISK_ENGINE_EXCEPTION = 0x80190740;
        // "Risk Engine throw exception in argument validation"
        public const uint XONLINE_E_CTP_BDK_E_RISK_ARGUMENT_VALIDATION_FAILED = 0x80190741;
        // "Apartment number missing or not found"
        public const uint XONLINE_E_CTP_BDK_E_DAV_APARTMENT = 0x80190742;
        // "Insufficient address information"
        public const uint XONLINE_E_CTP_BDK_E_DAV_INSUFFICIENT = 0x80190743;
        // "House number or PO box not found"
        public const uint XONLINE_E_CTP_BDK_E_DAV_ID = 0x80190744;
        // "Multiple address matches found"
        public const uint XONLINE_E_CTP_BDK_E_DAV_MULTIPLE = 0x80190745;
        // "PO box identifier out of range"
        public const uint XONLINE_E_CTP_BDK_E_DAV_POBOX = 0x80190746;
        // "Route service identified out of range"
        public const uint XONLINE_E_CTP_BDK_E_DAV_ROUTE = 0x80190747;
        // "Street name not found"
        public const uint XONLINE_E_CTP_BDK_E_DAV_STREET = 0x80190748;
        // "Postal code not found"
        public const uint XONLINE_E_CTP_BDK_E_DAV_POSTAL = 0x80190749;
        // "Genreal address error"
        public const uint XONLINE_E_CTP_BDK_E_DAV_GENERAL = 0x80190750;
        // "Missing required address field(s)"
        public const uint XONLINE_E_CTP_BDK_E_DAV_MISSING_DATA = 0x80190751;
        // "Invalid address field(s)"
        public const uint XONLINE_E_CTP_BDK_E_DAV_INVALID_DATA = 0x80190752;
        // "System failure during address check"
        public const uint XONLINE_E_CTP_BDK_E_DAV_SYSTEM_FAILURE = 0x80190753;
        // "Timeout during DAV check"
        public const uint XONLINE_E_CTP_BDK_E_DAV_TIMEOUT = 0x80190754;
        // "Delivery Address Verification system is not available at this time"
        public const uint XONLINE_E_CTP_BDK_E_DAV_DISABLED = 0x80190755;
        // "The character set used for this transaction is not supported by the address verification service."
        public const uint XONLINE_E_CTP_BDK_E_DAV_INVALID_CHARSET = 0x80190756;
        // "BDK_E_RISK_LAST"
        public const uint XONLINE_E_CTP_BDK_E_RISK_LAST = 0x80190757;
        // "Soap request is invalid
        public const uint XONLINE_E_CTP_DMP_E_VALIDATION_ERROR = 0x80190758;
        // "Unknown Server Error."
        public const uint XONLINE_E_CTP_DMP_E_UNKNOWNSERVER_ERROR = 0x80190759;
        // "Server Configuration Problem."
        public const uint XONLINE_E_CTP_DMP_E_CONFIGURATION_ERROR = 0x80190760;
        // "A system internal error has occured."
        public const uint XONLINE_E_CTP_DMP_E_SYSTEM_INTERNAL_ERROR = 0x80190761;
        // "Invalid tenant ID input."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_TENANT = 0x80190762;
        // "The tracking guid does not match the api signature."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_API_SIGNATURE = 0x80190763;
        // "User already registered."
        public const uint XONLINE_E_CTP_DMP_E_USER_REGISTERED = 0x80190764;
        // "The request cannot be completed due to user state."
        public const uint XONLINE_E_CTP_DMP_E_REQUEST_CANNOT_BE_COMPLETED = 0x80190765;
        // "User is not registered."
        public const uint XONLINE_E_CTP_DMP_E_STATUS_UNREGISTERED = 0x80190766;
        // "The NextHandle parameter is invalid."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_NEXTHANDLE = 0x80190767;
        // "Date Range is not supported in the system."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_DATE_RANGE = 0x80190768;
        // "There is not sufficient balance to support this transaction."
        public const uint XONLINE_E_CTP_DMP_E_INSUFFICIENT_BALANCE = 0x80190769;
        // "The input data length is over system size limit."
        public const uint XONLINE_E_CTP_DMP_E_DATA_OVERLIMIT_ERROR = 0x80190770;
        // "The input item ExternalId is not unique within the items array."
        public const uint XONLINE_E_CTP_DMP_E_ITEM_UNIQUENESS_ERROR = 0x80190771;
        // "The item string input has invalid values."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_ITEM_VALUE = 0x80190772;
        // "Not all items included in this request are eligible for credit
        public const uint XONLINE_E_CTP_DMP_E_NOT_ALL_ITEMS_ELIGIBLE_FOR_CREDIT = 0x80190773;
        // "The confirmation id is invalid."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_CONFIRMATION_ID = 0x80190774;
        // "The SKU code is not supported."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_SKU = 0x80190775;
        // "The SKU Type is incorrect for the API."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_SKU_TYPE = 0x80190776;
        // "The promotional SKU has expired."
        public const uint XONLINE_E_CTP_DMP_E_PROMO_EXPIRED = 0x80190777;
        // "The user status is in requested state already."
        public const uint XONLINE_E_CTP_DMP_E_STATUS_NOT_CHANGED = 0x80190778;
        // "The user country is in requested state already."
        public const uint XONLINE_E_CTP_DMP_E_COUNTRY_NOT_CHANGED = 0x80190779;
        // "The transaction type passed in is not valid."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_TRANSACTION_TYPE = 0x80190780;
        // "The original transaction is not eligible for cancellation because it has all or partial credit on it."
        public const uint XONLINE_E_CTP_DMP_E_ORIGINAL_TRANSACTION_HAS_CREDIT = 0x80190781;
        // "The result point balance will exceed the policy max balance."
        public const uint XONLINE_E_CTP_DMP_E_MAX_BALANCE_EXCEEDED = 0x80190782;
        // "The point amount exceeds the policy max acquisition limit per transaction."
        public const uint XONLINE_E_CTP_DMP_E_MAX_ACQUISITION_EXCEEDED = 0x80190783;
        // "The user consumption per period of time would exceed the policy limit."
        public const uint XONLINE_E_CTP_DMP_E_MAX_CONSUMPTION_EXCEEDED = 0x80190784;
        // "There are no more points to distribute for this tenant sku combination."
        public const uint XONLINE_E_CTP_DMP_E_NO_MORE_PROMO_POINTS = 0x80190785;
        // "The system is busy
        public const uint XONLINE_E_CTP_DMP_E_PROMO_POINTS_UNAVAILIABLE = 0x80190786;
        // "The original record was not found
        public const uint XONLINE_E_CTP_DMP_E_ORIGINAL_TRANSACTION_NOT_FOUND = 0x80190787;
        // "The original transaction already is already debited."
        public const uint XONLINE_E_CTP_DMP_E_ORIGINAL_TRANSACTION_HAS_DEBIT = 0x80190788;
        // "The original transaction must be a PurchaseItem transaction type."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_TRANSACTION_TO_CREDIT = 0x80190789;
        // "The supplied reason code is invalid."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_REASON_CODE = 0x80190790;
        // "The promotional points user obtained would exceed the sku limit."
        public const uint XONLINE_E_CTP_DMP_E_PROMOTION_LIMIT_LIFE_MAX = 0x80190791;
        // "The requested state change is not allowed."
        public const uint XONLINE_E_CTP_DMP_E_STATUS_CHANGE_NOT_ALLOWED = 0x80190792;
        // "The property value did not change
        public const uint XONLINE_E_CTP_DMP_E_PROPERTY_VALUE_NOT_CHANGED = 0x80190793;
        // "Not all items eligible for offset."
        public const uint XONLINE_E_CTP_DMP_E_NOT_ALL_ITEMS_ELIGIBLE_FOR_OFFSET = 0x80190794;
        // "The confirmationId is required."
        public const uint XONLINE_E_CTP_DMP_E_MUST_SPECIFY_CONFIRMATION = 0x80190795;
        // "the confirmationId has to be null."
        public const uint XONLINE_E_CTP_DMP_E_CONFIRMATION_HAS_TO_BE_NULL = 0x80190796;
        // "Exchange type is not valid."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_EXCHANGE_TYPE = 0x80190797;
        // "The original transaction for creditbalance call must not be a subscription."
        public const uint XONLINE_E_CTP_DMP_E_CANNOT_CREDIT_SUBSCRIPTION = 0x80190798;
        // "Exchange price supplied does not match system rates."
        public const uint XONLINE_E_CTP_DMP_E_EXCHANGE_PRICE_MISMATCH = 0x80190799;
        // "Source Account is not in Active State for the Transaction."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_SOURCE_ACCOUNT = 0x80190800;
        // "Destination Account is not in Active State for the Transaction."
        public const uint XONLINE_E_CTP_DMP_E_INVALID_DESTINATION_ACCOUNT = 0x80190801;
        // "Source and Transfer Puid's are same."
        public const uint XONLINE_E_CTP_DMP_E_SOURCE_TRANSFER_PUIDS_SAME = 0x80190802;
        // "Source and Destination country code mismatch."
        public const uint XONLINE_E_CTP_DMP_E_COUNTRY_CODE_MISMATCH = 0x80190803;
        // "TransferBalance initiated within the no transfer window for the source account."
        public const uint XONLINE_E_CTP_DMP_E_SOURCETRANSFER_INITIATED_WITHIN_NO_TRANSFER_WINDOW = 0x80190804;
        // "TransferBalance initiated within the no transfer window for the target account."
        public const uint XONLINE_E_CTP_DMP_E_TARGETTRANSFER_INITIATED_WITHIN_NO_TRANSFER_WINDOW = 0x80190805;
        // "Transferred points balance exceeded the system transferred provisional max balance."
        public const uint XONLINE_E_CTP_DMP_E_MAX_BALANCE_TRANSFER_PROVISIONAL_EXCEEDED = 0x80190806;
        // "Transferred points balance exceeded the system transferred promotional max balance."
        public const uint XONLINE_E_CTP_DMP_E_MAX_BALANCE_TRANSFER_PROMOTIONAL_EXCEEDED = 0x80190807;
        // "TransferBalance doesnot support partial transfer
        public const uint XONLINE_E_CTP_DMP_E_PARTIAL_TRANSFER = 0x80190808;
        // "Source Puid cannot be zero for the Transaction."
        public const uint XONLINE_E_CTP_DMP_E_SOURCE_ZERO = 0x80190809;
        // "Destination Puid cannot be zero for the Transaction."
        public const uint XONLINE_E_CTP_DMP_E_DESTINATION_ZERO = 0x80190810;
        // "DelegateUser is not supported in Transfer Balance API"
        public const uint XONLINE_E_CTP_DMP_E_DELEGATE_NOT_SUPPORTED = 0x80190811;
        // "PMN does not exist"
        public const uint XONLINE_E_CTP_DMP_E_INVALID_PMN = 0x80190812;
        // "Invalid points distribution program."
        public const uint XONLINE_E_CTP_DMP_DP_INVALID_DISTRIBUTION_PROGRAM = 0x80190813;
        // "Invalid points distribution program calling partner."
        public const uint XONLINE_E_CTP_DMP_DP_INVALID_DISTRIBUTION_PROGRAM_CALLING_PARTNER = 0x80190814;
        // "Invalid points distribution program selling partner."
        public const uint XONLINE_E_CTP_DMP_DP_INVALID_DISTRIBUTION_PROGRAM_SELLING_PARTNER = 0x80190815;
        // "Invalid points distribution program SKU."
        public const uint XONLINE_E_CTP_DMP_DP_INVALID_DISTRIBUTION_PROGRAM_SKU = 0x80190816;
        // "Invalid points distribution program user."
        public const uint XONLINE_E_CTP_DMP_DP_INVALID_DISTRIBUTION_PROGRAM_USER = 0x80190817;
        // "User is not enrolled in the distribution program."
        public const uint XONLINE_E_CTP_DMP_DP_USER_NOT_ENROLLED = 0x80190818;
        // "User is disabled."
        public const uint XONLINE_E_CTP_DMP_E_USER_DISABLED = 0x80190819;
        // "The point amount acquired per period of time would exceed the policy limit."
        public const uint XONLINE_E_CTP_DMP_E_MAX_ACQUISITIONPERSPAN_EXCEEDED = 0x80190820;
        // "Risk check rejected"
        public const uint XONLINE_E_CTP_TRANSACTION_E_AUTHORIZATION_FAILED = 0x80190821;
        // "Invalid Subscription component response"
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_SUBS_RESPONSE = 0x80190822;
        // "The line item has already been refunded."
        public const uint XONLINE_E_CTP_BILLING_E_LINEITEM_ALREADY_REFUND = 0x80190823;
        // "The transaction status is in an invalid status for this operation."
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_TRANSACTION_STATUS = 0x80190824;
        // "Either the request is not allowed of this partner or the partner information is invalid"
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_CALLING_PARTER = 0x80190825;
        // "Invalid account status"
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_ACCOUNT_STATUS = 0x80190826;
        // "Server encountered unspecified error."
        public const uint XONLINE_E_CTP_BILLING_E_INTERNAL_SERVER_ERROR = 0x80190827;
        // "The partial charge back is not supported"
        public const uint XONLINE_E_CTP_BILLING_E_PARITAL_CHARGE_BACK = 0x80190828;
        // "The passed in line item event id is not consistent with the server side record"
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_LINE_ITEM_EVENT = 0x80190829;
        // "The passed in tracking guid is not consistent with the server side record"
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_TRACKING_GUID = 0x80190830;
        // "Timeout when calling external component"
        public const uint XONLINE_E_CTP_TRANSACTION_E_EXTERNAL_TIMEOUT_ERROR = 0x80190831;
        // "The passed in tracking guid is not consistent with the server side record"
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_TRACKING_GUID = 0x80190832;
        // "The payment method information is invalid or the action is not applicable for this payment method"
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_PAYMENT_INSTRUMENT_DETAILS = 0x80190833;
        // "The passed in line item is not consistent with the server side record"
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_LINE_ITEM = 0x80190834;
        // "The balance status is in an invalid status for this operation."
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_BALANCE_STATUS = 0x80190835;
        // "The partner payment reference is invalid"
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_PARTNER_PAYMENT_REF = 0x80190836;
        // "Cannot get decline type for the decline code"
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_DECLINE_CODE = 0x80190837;
        // "The line item has already been charged back."
        public const uint XONLINE_E_CTP_BILLING_E_LINEITEM_ALREADY_CHARGED_BACK = 0x80190838;
        // "The passed in balance id is not consistent with the server side record"
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_BALANCE_ID = 0x80190839;
        // "The order status is in an invalid status for this operation."
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_ORDER_STATUS = 0x80190840;
        // "Unsupported server operation."
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_OPERATION = 0x80190841;
        // "Invalid Account component response"
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_ACCOUNT_RESPONSE = 0x80190842;
        // "Unsupported server operation."
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_OPERATION = 0x80190843;
        // "Same trasaction was processed by other thread"
        public const uint XONLINE_E_CTP_TRANSACTION_E_TRANSACTION_RACE_CONDITION = 0x80190844;
        // "API request does not pass server side validation."
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_ARGUMENT = 0x80190845;
        // "Invalid PaymentMethod component response"
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_PAYMENTMETHOD_RESPONSE = 0x80190846;
        // "The line item has already been transfered cross SA and BSS."
        public const uint XONLINE_E_CTP_BILLING_E_LINEITEM_ALREADY_CROSS_TRANSFERED = 0x80190847;
        // "The payment provider declined the transaction"
        public const uint XONLINE_E_CTP_BILLING_E_PAYMENT_PROVIDER_DECLINE = 0x80190848;
        // "Offset amount must be greater than zero but less than or equal to original amount"
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_OFFSET_AMOUNT = 0x80190849;
        // "Server encountered unspecified error."
        public const uint XONLINE_E_CTP_TRANSACTION_E_INTERNAL_SERVER_ERROR = 0x80190850;
        // "The line item status is in an invalid status for this operation."
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_LINE_ITEM_STATUS = 0x80190851;
        // "Invalid DMP component response"
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_DMP_RESPONSE = 0x80190852;
        // "The payment provider returned a retryable error."
        public const uint XONLINE_E_CTP_BILLING_E_PAYMENT_PROVIDER_RETRYABLE_ERROR = 0x80190853;
        // "Invalid soft descriptor."
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_SOFT_DESCRIPTOR = 0x80190854;
        // "The payment event type is unexpected in server side."
        public const uint XONLINE_E_CTP_BILLING_E_UNEXPECTED_PAYMENT_EVENT = 0x80190855;
        // "The merchant reference number is invalid."
        public const uint XONLINE_E_CTP_BILLING_E_UNRECOGNIZED_MRN = 0x80190856;
        // "Invalid partner certificate"
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_PARTNER = 0x80190857;
        // "The payment provider returned an error."
        public const uint XONLINE_E_CTP_BILLING_E_PAYMENT_PROVIDER_ERROR = 0x80190858;
        // "Invalid Tax component response"
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_TAX_RESPONSE = 0x80190859;
        // "Invalid risk check response"
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_RISK_RESPONSE = 0x80190860;
        // "API request does not pass server side validation."
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_ARGUMENT = 0x80190861;
        // "The passed in order id is not consistent with the server side record"
        public const uint XONLINE_E_CTP_BILLING_E_INVALID_ORDER_ID = 0x80190862;
        // "Invalid Billing component response"
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_BILLING_RESPONSE = 0x80190863;
        // "Invalid payment instrument status"
        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_PAYMENT_INSTRUMENT_STATUS = 0x80190864;
        // "Currently DirectDebit Purchase API only supports purchase one and at least one new subscription"
        public const uint XONLINE_E_CTP_TRANSACTION_E_UNSUPPORTED_DD_OPERATION = 0x8015309A;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\XRLTrace.cs ===
using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.xrltrace)]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\service\HResult.cs ===
//
// HResult.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Managed HResult class, and constant HResult definitions
// used within Xbox Live.
//

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Schema;

namespace xonline.common.service
{

    // list of services as defined in xonline.x
    [ComVisible(false)]
    public enum XOService
    {
        InvalidService    = 0,
        PresNotification  = 1,
        StringService     = 2,
        Auto_Update       = 3,
        Base_Subscription = 4,
        User_Account      = 5,
        Matchmaking       = 6,
        Stats             = 7,
        Feedback          = 8,
        Billing_Offering  = 9,
        Lists             = 10,
        Tou               = 11,
        Signature_Server  = 12,
        Query             = 13,
        Name_Resolution   = 14,
        Storage           = 15,
        Arbitration       = 16,
        Cron              = 17,
        MessagingService  = 18,
        Teams             = 19,
        NatDetection      = 20,
        DRM               = 21,
        Massive           = 22,
        PCLocator         = 23,
        Crypto            = 24,
        Liveinfo          = 25,
        Connection_Server = 26,
        Ratings           = 27,
        TestFD            = 28,
        Sts               = 29,
        Reflector         = 30,
        SocialQuery       = 31,
        Vortex            = 32,
        XSts              = 33,
        Profile           = 34,
        Progress          = 35,
        MaxService        = 35      // update this const while adding new services
    }

    /// <summary>
    /// Constants required for Win32 Error conversion to Hresults.
    /// Add new constants required for Win32 errors here.
    /// </summary>
    [ComVisible(false)]
    public static class Win32ErrorCode
    {
        /// <summary>
        /// Picked up from winerror.h in the platform sdk
        /// </summary>
        ///
        public enum Codes
        {
        ERROR_USER_EXISTS = 1316,
        ERROR_NO_SUCH_USER = 1317
        }

        private const uint WIN32_FACILITY_PREFIX = 0x80070000;

        public static HResult GetHResult(Codes code)
        {
            return GetHResult((int)code);
        }

        /// <summary>
        /// Keep this private for now since it takes any uint
        /// Be mindful that during the int to uint promotion for less than zero values
        /// a simple conversion to HResult may lead to FACILITY_NULL in most cases.
        /// </summary>
        /// <param name="code"></param>
        /// <returns></returns>
        private static HResult GetHResult(int code)
        {
            return ( code < 0 ? ((uint)code) : (uint)(WIN32_FACILITY_PREFIX | ((uint)code & 0x0000ffff)) );
        }

        static Win32ErrorCode()
        {
            HResult.AddConstsAsHResults(typeof(Codes), o => GetHResult((int)o));
        }
    }

    public partial struct HResult : IEquatable<HResult>, IXmlSerializable
    {
        //
        //
        // NOTE: These defines should be a superset of everything defined in XONLINE.X which are exposed to the client
        //
        //


        //
        // standard HRESULTS
        //
        public const uint S_OK                      = 0x0;
        public const uint S_FALSE                   = 0x1;
        public const uint E_FAIL                    = 0x80004005;
        public const uint E_INVALIDARG              = 0x80070057;
        public const uint E_ABORT                   = 0x80004004;
        public const uint E_INVALID_DATA            = 0x8007000D;
        public const uint E_OUTOFMEMORY             = 0x8007000E;
        public const uint E_ACCESSDENIED            = 0x80070005;
        public const uint E_UNEXPECTED              = 0x8000FFFF;

        //
        // XOnline facility-wide HRESULTS                                            = 0x80150XXX
        //
        public const uint XONLINE_E_OVERFLOW                                         = 0x80150001;
        public const uint XONLINE_E_NO_SESSION                                       = 0x80150002;
        public const uint XONLINE_E_USER_NOT_LOGGED_ON                               = 0x80150003;
        public const uint XONLINE_E_NO_GUEST_ACCESS                                  = 0x80150004;
        public const uint XONLINE_E_NOT_INITIALIZED                                  = 0x80150005;
        public const uint XONLINE_E_NO_USER                                          = 0x80150006;
        public const uint XONLINE_E_INTERNAL_ERROR                                   = 0x80150007;
        public const uint XONLINE_E_OUT_OF_MEMORY                                    = 0x80150008;
        public const uint XONLINE_E_TASK_BUSY                                        = 0x80150009;
        public const uint XONLINE_E_SERVER_ERROR                                     = 0x8015000A;
        public const uint XONLINE_E_IO_ERROR                                         = 0x8015000B;
        public const uint XONLINE_E_BAD_CONTENT_TYPE                                 = 0x8015000C;
        public const uint XONLINE_E_USER_NOT_PRESENT                                 = 0x8015000D;
        public const uint XONLINE_E_PROTOCOL_MISMATCH                                = 0x8015000E;
        public const uint XONLINE_E_INVALID_SERVICE_ID                               = 0x8015000F;
        public const uint XONLINE_E_INVALID_REQUEST                                  = 0x80150010;
        public const uint XONLINE_E_TASK_THROTTLED                                   = 0x80150011;
        public const uint XONLINE_E_TASK_ABORTED_BY_DUPLICATE                        = 0x80150012;
        public const uint XONLINE_E_INVALID_TITLE_ID                                 = 0x80150013;
        public const uint XONLINE_E_SERVER_CONFIG_ERROR                              = 0x80150014;
        public const uint XONLINE_E_END_OF_STREAM                                    = 0x80150015;
        public const uint XONLINE_E_ACCESS_DENIED                                    = 0x80150016;
        public const uint XONLINE_E_GEO_DENIED                                       = 0x80150017;
        public const uint XONLINE_E_UNSUPPORTED_METHOD                               = 0x80150018; // XRL has wiredata request for an old/deprecated API-call received from new flash/client (or viceversa)
        public const uint XONLINE_E_RESOURCE_UNAVAILABLE                             = 0x80150019; // FastFail blocked the call
        public const uint XONLINE_E_AUTHDATA_MISMATCH                                = 0x80150020; // values in authdata don't match those in request
        public const uint XONLINE_E_ACCESS_TOKEN_ERROR                               = 0x80150021; // generic AccessToken error
        public const uint XONLINE_E_HEALTH_ERROR                                     = 0x80150022; // non-specific (catch all) health error
        public const uint XONLINE_E_RESPONSE_ERROR                                   = 0x80150023; // non-specific (catch all) response error
        public const uint XONLINE_E_ACTIVE_AUTH_ERROR                                = 0x80150024; // non-specific (catch all) active auth error
        public const uint XONLINE_E_MULTIPLE_USERS                                   = 0x80150025; // received multiple users when only one is expected
        public const uint XONLINE_E_CALL_SOURCE_INVALID                              = 0x80150026;
        public const uint XONLINE_E_DECRYPTION_ERROR       